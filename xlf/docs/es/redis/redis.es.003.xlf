<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="5a4574a1a3d9728a0a89d6b1668d9c8dc4ec0634" translate="yes" xml:space="preserve">
          <source>Notes on published config epochs</source>
          <target state="translated">Notas sobre las épocas de configuración publicadas</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="20be3b7a30a9bb9f7caa52a82e339d86765a7b3b" translate="yes" xml:space="preserve">
          <source>Number of commands processed</source>
          <target state="translated">Número de comandos procesados</target>
        </trans-unit>
        <trans-unit id="6567d67fead3b983bf0dd26e46b199bad4736caf" translate="yes" xml:space="preserve">
          <source>Number of connections received</source>
          <target state="translated">Número de conexiones recibidas</target>
        </trans-unit>
        <trans-unit id="c0e73dd590dc420faea4c4ac9906ba30e0259e37" translate="yes" xml:space="preserve">
          <source>Number of elements returned at every SCAN call</source>
          <target state="translated">Número de elementos devueltos en cada llamada de SCAN</target>
        </trans-unit>
        <trans-unit id="f4702f3357a94e0b51c79789087a3eb454b1e296" translate="yes" xml:space="preserve">
          <source>Number of expired keys</source>
          <target state="translated">Número de llaves caducadas</target>
        </trans-unit>
        <trans-unit id="8e0e833a8bbaf63a540fadb74be8461319161578" translate="yes" xml:space="preserve">
          <source>Number of rejected connections</source>
          <target state="translated">Número de conexiones rechazadas</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="9d8ec388e13faad9823f64e9acce4e1451d4eabf" translate="yes" xml:space="preserve">
          <source>OBJECT  subcommand [arguments [arguments ...]]   Inspect the internals of Redis objects</source>
          <target state="translated">Submando OBJETO [argumentos [argumentos ...]]Inspeccionar el interior de los objetos de Redis</target>
        </trans-unit>
        <trans-unit id="77ba3ba2dc482ece5e336da9db6f45f553748e64" translate="yes" xml:space="preserve">
          <source>Objects can be encoded in different ways:</source>
          <target state="translated">Los objetos pueden ser codificados de diferentes maneras:</target>
        </trans-unit>
        <trans-unit id="179e9e8b9188e3e0f2e120735c4089249f586f43" translate="yes" xml:space="preserve">
          <source>Obtaining the current length of the slow log</source>
          <target state="translated">Obtener la longitud actual del tronco lento</target>
        </trans-unit>
        <trans-unit id="5f6babf24c9404230c05a01781cf0ff83f2a099c" translate="yes" xml:space="preserve">
          <source>Of course it is also possible to use any other valid ID. If the specified consumer group already exists, the command returns a &lt;code&gt;-BUSYGROUP&lt;/code&gt; error. Otherwise the operation is performed and OK is returned. There are no hard limits to the number of consumer groups you can associate to a given stream.</source>
          <target state="translated">Por supuesto, tambi&amp;eacute;n es posible utilizar cualquier otra identificaci&amp;oacute;n v&amp;aacute;lida. Si el grupo de consumidores especificado ya existe, el comando devuelve un error &lt;code&gt;-BUSYGROUP&lt;/code&gt; . De lo contrario, se realiza la operaci&amp;oacute;n y se devuelve OK. No existen l&amp;iacute;mites estrictos para la cantidad de grupos de consumidores que puede asociar a una transmisi&amp;oacute;n determinada.</target>
        </trans-unit>
        <trans-unit id="fdc97913b5ee5e2b94550a726affb680e5e4737b" translate="yes" xml:space="preserve">
          <source>Of course the &quot;5&quot; above is an example. Each LOLWUT version takes a different set of arguments in order to change the output. The user is encouraged to play with it to discover how the output changes adding more numerical arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1bb1ff7a105fafca313a10f02e72dc891fbcf4" translate="yes" xml:space="preserve">
          <source>Of course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</source>
          <target state="translated">Por supuesto que esto no es suficiente,ya que hay llaves caducadas que nunca se volverán a acceder.Estas llaves deberían estar expiradas de todos modos,así que periódicamente Redis prueba unas cuantas llaves al azar entre las llaves con un conjunto de expiración.Todas las claves que ya están expiradas son eliminadas del espacio de claves.</target>
        </trans-unit>
        <trans-unit id="e1291438828df902dd44c789d43575a9bce5c968" translate="yes" xml:space="preserve">
          <source>On the other hand, defining commands using a special command or via &lt;code&gt;redis.conf&lt;/code&gt; would be a problem for a few reasons:</source>
          <target state="translated">Por otro lado, definir comandos usando un comando especial o mediante &lt;code&gt;redis.conf&lt;/code&gt; ser&amp;iacute;a un problema por algunas razones:</target>
        </trans-unit>
        <trans-unit id="9bcf11babeeb88215faca3f25a089c7e21ce30f5" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;succesfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">Una vez que un consumidor procesa con &lt;em&gt;&amp;eacute;xito&lt;/em&gt; un mensaje, debe llamar a &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; para que dicho mensaje no se procese nuevamente y, como efecto secundario, la entrada PEL sobre este mensaje tambi&amp;eacute;n se purga, liberando memoria del servidor de Redis.</target>
        </trans-unit>
        <trans-unit id="b17fd51767d49ce5f7f1a0550bff325504d720d8" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;successfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452b455cbf1a2a31d7d4b5005050bf4551fb3def" translate="yes" xml:space="preserve">
          <source>Once a node is turned into the replica of another master node, there is no need to inform the other cluster nodes about the change: heartbeat packets exchanged between nodes will propagate the new configuration automatically.</source>
          <target state="translated">Una vez que un nodo se convierte en la réplica de otro nodo maestro,no es necesario informar a los otros nodos del cúmulo sobre el cambio:los paquetes de latidos intercambiados entre los nodos propagarán la nueva configuración automáticamente.</target>
        </trans-unit>
        <trans-unit id="24b95a3638ec064976a3c5a5f6794040d2c4ed0b" translate="yes" xml:space="preserve">
          <source>Once new data is present on one of the lists, the client returns with the name of the key unblocking it and the popped value.</source>
          <target state="translated">Una vez que los nuevos datos están presentes en una de las listas,el cliente regresa con el nombre de la llave que la desbloquea y el valor que se ha desbloqueado.</target>
        </trans-unit>
        <trans-unit id="dd41998567cd1f4f810cbadee2b74617b57a32fa" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; and &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; commands.</source>
          <target state="translated">Una vez que el cliente entra en el estado de suscripci&amp;oacute;n, no se supone que debe emitir ning&amp;uacute;n otro comando, excepto los comandos adicionales &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt; , &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; , &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; y &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a78727304122280256c3edfc937460559a439ea" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt;, &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; and &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b215656d61ce9a1a4991539bbd4f84ece9f512" translate="yes" xml:space="preserve">
          <source>Once we get some replies, the next call will be something like:</source>
          <target state="translated">Una vez que obtengamos algunas respuestas,la siguiente llamada será algo así como:</target>
        </trans-unit>
        <trans-unit id="9de09a5350a4d4653c094b67b0dba8689a762e24" translate="yes" xml:space="preserve">
          <source>One client connection per line (separated by LF)</source>
          <target state="translated">Una conexión de cliente por línea (separada por LF)</target>
        </trans-unit>
        <trans-unit id="81d95091e8731132a88b7f9f02a3169be5e6b187" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgement of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">Una de las garant&amp;iacute;as de los grupos de consumidores es que un consumidor determinado solo puede ver el historial de mensajes que se le entregaron, por lo que un mensaje tiene un solo propietario. Sin embargo, existe una caracter&amp;iacute;stica especial llamada &lt;em&gt;reclamo de mensajes&lt;/em&gt; que permite a otros consumidores reclamar mensajes en caso de que haya una falla no recuperable de alg&amp;uacute;n consumidor. Para implementar dicha sem&amp;aacute;ntica, los grupos de consumidores requieren un reconocimiento expl&amp;iacute;cito de los mensajes procesados ​​con &amp;eacute;xito por el consumidor, a trav&amp;eacute;s del comando &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; . Esto es necesario porque la transmisi&amp;oacute;n rastrear&amp;aacute;, para cada grupo de consumidores, qui&amp;eacute;n est&amp;aacute; procesando qu&amp;eacute; mensaje.</target>
        </trans-unit>
        <trans-unit id="19ce1ec3b2311a2d98754806626a6daf14da6b47" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgment of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="daa479a36fbba3ff638d59ae19308e8976bd5ac3" translate="yes" xml:space="preserve">
          <source>Orders of bits</source>
          <target state="translated">Ordenes de bits</target>
        </trans-unit>
        <trans-unit id="dcfd7c36726b3d9723cbd1a8981b89247967a629" translate="yes" xml:space="preserve">
          <source>Other consumers may inspect the list of pending messages, that are stale for quite some time, using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command. In order to continue processing such messages, they use &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; to acquire the ownership of the message and continue.</source>
          <target state="translated">Otros consumidores pueden inspeccionar la lista de mensajes pendientes, que est&amp;aacute;n obsoletos durante bastante tiempo, usando el comando &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; . Para continuar procesando dichos mensajes, utilizan &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; para adquirir la propiedad del mensaje y continuar.</target>
        </trans-unit>
        <trans-unit id="3c2a27c636dc79870e309393531406e960ec4e18" translate="yes" xml:space="preserve">
          <source>Our previous example returns just the sorted IDs. In some cases, it is more useful to get the actual objects instead of their IDs (&lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;). Retrieving external keys based on the elements in a list, set or sorted set can be done with the following command:</source>
          <target state="translated">Nuestro ejemplo anterior devuelve solo los ID ordenados. En algunos casos, es m&amp;aacute;s &amp;uacute;til obtener los objetos reales en lugar de sus ID ( &lt;code&gt;object_1&lt;/code&gt; , &lt;code&gt;object_2&lt;/code&gt; y &lt;code&gt;object_3&lt;/code&gt; ). La recuperaci&amp;oacute;n de claves externas basadas en los elementos de una lista, conjunto o conjunto ordenado se puede realizar con el siguiente comando:</target>
        </trans-unit>
        <trans-unit id="e9c8427bc7498ec3380d38f116037bdd3bcddf6e" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the actual end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">Los &amp;iacute;ndices fuera de rango no producir&amp;aacute;n un error. Si el &lt;code&gt;start&lt;/code&gt; es mayor que el final de la lista, se devuelve una lista vac&amp;iacute;a. Si &lt;code&gt;stop&lt;/code&gt; es m&amp;aacute;s grande que el final real de la lista, Redis lo tratar&amp;aacute; como el &amp;uacute;ltimo elemento de la lista.</target>
        </trans-unit>
        <trans-unit id="c0a3cb19e89ec7bd7c87e53355299d0f62cc91cc" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the largest index in the sorted set, or &lt;code&gt;start &amp;gt;
stop&lt;/code&gt;, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the end of the sorted set Redis will treat it like it is the last element of the sorted set.</source>
          <target state="translated">Los &amp;iacute;ndices fuera de rango no producir&amp;aacute;n un error. Si &lt;code&gt;start&lt;/code&gt; es mayor que el &amp;iacute;ndice m&amp;aacute;s grande del conjunto ordenado, o &lt;code&gt;start &amp;gt; stop&lt;/code&gt; , se devuelve una lista vac&amp;iacute;a. Si &lt;code&gt;stop&lt;/code&gt; es mayor que el final del conjunto ordenado, Redis lo tratar&amp;aacute; como si fuera el &amp;uacute;ltimo elemento del conjunto ordenado.</target>
        </trans-unit>
        <trans-unit id="3dc054b880cd4ad0a83857995e10c362ec4b2504" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error: if &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, or &lt;code&gt;start &amp;gt; end&lt;/code&gt;, the result will be an empty list (which causes &lt;code&gt;key&lt;/code&gt; to be removed). If &lt;code&gt;end&lt;/code&gt; is larger than the end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">Los &amp;iacute;ndices fuera de rango no producir&amp;aacute;n un error: si el &lt;code&gt;start&lt;/code&gt; es mayor que el final de la lista, o el &lt;code&gt;start &amp;gt; end&lt;/code&gt; , el resultado ser&amp;aacute; una lista vac&amp;iacute;a (lo que hace que se elimine la &lt;code&gt;key&lt;/code&gt; ). Si &lt;code&gt;end&lt;/code&gt; es m&amp;aacute;s grande que el final de la lista, Redis lo tratar&amp;aacute; como el &amp;uacute;ltimo elemento de la lista.</target>
        </trans-unit>
        <trans-unit id="c4e6b6c77c67abd27de260eb5ce674860a95ad42" translate="yes" xml:space="preserve">
          <source>Out-of-range indexes</source>
          <target state="translated">Índices fuera de rango</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">Formato de salida</target>
        </trans-unit>
        <trans-unit id="275395efd6e79fdbe55cb36a4ebb4892dbdd5c40" translate="yes" xml:space="preserve">
          <source>Output of the command on replicas</source>
          <target state="translated">Salida del comando en las réplicas</target>
        </trans-unit>
        <trans-unit id="5ea9a43450142f5e1cfd51ca7b6956f8a9dbb82d" translate="yes" xml:space="preserve">
          <source>Overflow control</source>
          <target state="translated">Control de desbordamiento</target>
        </trans-unit>
        <trans-unit id="36fd64a953472994b938bbb13337305e87d9a9eb" translate="yes" xml:space="preserve">
          <source>Overwrites part of the string stored at &lt;em&gt;key&lt;/em&gt;, starting at the specified offset, for the entire length of &lt;em&gt;value&lt;/em&gt;. If the offset is larger than the current length of the string at &lt;em&gt;key&lt;/em&gt;, the string is padded with zero-bytes to make &lt;em&gt;offset&lt;/em&gt; fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set &lt;em&gt;value&lt;/em&gt; at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">Sobrescribe parte de la cadena almacenada en la &lt;em&gt;clave&lt;/em&gt; , comenzando en el desplazamiento especificado, para toda la longitud del &lt;em&gt;valor&lt;/em&gt; . Si el desplazamiento es mayor que la longitud actual de la cadena en la &lt;em&gt;clave&lt;/em&gt; , la cadena se rellena con bytes cero para ajustar el &lt;em&gt;desplazamiento&lt;/em&gt; . Las claves no existentes se consideran cadenas vac&amp;iacute;as, por lo que este comando se asegurar&amp;aacute; de que contenga una cadena lo suficientemente grande como para poder establecer un &lt;em&gt;valor&lt;/em&gt; en el &lt;em&gt;desplazamiento&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="34512fba1d256a361565532a3535096429399084" translate="yes" xml:space="preserve">
          <source>PERSIST</source>
          <target state="translated">PERSIST</target>
        </trans-unit>
        <trans-unit id="ae51373f050f6d2b0e0edfdd08e69fc1968bdf20" translate="yes" xml:space="preserve">
          <source>PERSIST  key   Remove the expiration from a key</source>
          <target state="translated">Tecla PERSIST Eliminar la caducidad de una tecla</target>
        </trans-unit>
        <trans-unit id="7fa59fa06dcb2c9dc1b2b2bd46df7f33912c57b3" translate="yes" xml:space="preserve">
          <source>PEXPIRE</source>
          <target state="translated">PEXPIRE</target>
        </trans-unit>
        <trans-unit id="77a946764b4ffdf95c5ae217ca7f9cec5340bdc1" translate="yes" xml:space="preserve">
          <source>PEXPIRE  key milliseconds   Set a key's time to live in milliseconds</source>
          <target state="translated">PEXPIRE clave milisegundos Establecer el tiempo de vida de una clave en milisegundos</target>
        </trans-unit>
        <trans-unit id="e609e3af460df9737d7d964f8bfec75a3773bde7" translate="yes" xml:space="preserve">
          <source>PEXPIREAT</source>
          <target state="translated">PEXPIREAT</target>
        </trans-unit>
        <trans-unit id="12d0e8f2d7d7718d124f2a5d583dfa8315ee3c0c" translate="yes" xml:space="preserve">
          <source>PEXPIREAT  key milliseconds-timestamp   Set the expiration for a key as a UNIX timestamp specified in milliseconds</source>
          <target state="translated">PEXPIREAT clave milisegundos-sello de tiempo Establecer la expiración de una clave como un sello de tiempo UNIX especificado en milisegundos</target>
        </trans-unit>
        <trans-unit id="fc7a17907dc63d1312607f17460e9eb6e7871f9d" translate="yes" xml:space="preserve">
          <source>PFADD</source>
          <target state="translated">PFADD</target>
        </trans-unit>
        <trans-unit id="e4e9e83ebacf78fb8cf3124d42502528b53d06ca" translate="yes" xml:space="preserve">
          <source>PFADD  key element [element ...]   Adds the specified elements to the specified HyperLogLog.</source>
          <target state="translated">Elemento clave PFADD [elemento ...]Añade los elementos especificados al HyperLogLog especificado.</target>
        </trans-unit>
        <trans-unit id="274e92a9d4138573a0f107d2e57b9d0b46e7ac01" translate="yes" xml:space="preserve">
          <source>PFCOUNT</source>
          <target state="translated">PFCOUNT</target>
        </trans-unit>
        <trans-unit id="f81913b01d976cbaac4ade6c06f6bf299ee86214" translate="yes" xml:space="preserve">
          <source>PFCOUNT  key [key ...]   Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</source>
          <target state="translated">Tecla PFCOUNT [tecla ...]Devuelve la cardinalidad aproximada del conjunto(s)observado por el HyperLogLog en la tecla(s).</target>
        </trans-unit>
        <trans-unit id="62f6ef6fa6924abe295c8c766f2b3e89d6d074fc" translate="yes" xml:space="preserve">
          <source>PFMERGE</source>
          <target state="translated">PFMERGE</target>
        </trans-unit>
        <trans-unit id="2ad005659587e94338ccd67e31dbc3fac2cb1536" translate="yes" xml:space="preserve">
          <source>PFMERGE  destkey sourcekey [sourcekey ...]   Merge N different HyperLogLogs into a single one.</source>
          <target state="translated">PFMERGE destkey sourcekey [sourcekey ...]Fusiona N diferentes HyperLogLogs en uno solo.</target>
        </trans-unit>
        <trans-unit id="0b1786a083a9087f0db36b08c1ff81a58930fbc2" translate="yes" xml:space="preserve">
          <source>PING</source>
          <target state="translated">PING</target>
        </trans-unit>
        <trans-unit id="45dae0d4784e1c9ea33d8d88f448f7989ea29500" translate="yes" xml:space="preserve">
          <source>PING  [message]   Ping the server</source>
          <target state="translated">PING [mensaje]Ping al servidor</target>
        </trans-unit>
        <trans-unit id="81efb783fc237efd685a1393fa9f947dd8abda5a" translate="yes" xml:space="preserve">
          <source>PSETEX</source>
          <target state="translated">PSETEX</target>
        </trans-unit>
        <trans-unit id="d7c40d1ee18ffeabe6099f89603c950454eb0276" translate="yes" xml:space="preserve">
          <source>PSETEX  key milliseconds value   Set the value and expiration in milliseconds of a key</source>
          <target state="translated">Valor de milisegundos de la llave PSETEX Establecer el valor y la caducidad en milisegundos de una llave</target>
        </trans-unit>
        <trans-unit id="9e7e79c8d02bde08c4e705066bd533ffa7218538" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE</source>
          <target state="translated">PSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="71ae64e5df443252e78a1d1f929289a8311a1ef4" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE  pattern [pattern ...]   Listen for messages published to channels matching the given patterns</source>
          <target state="translated">Patrón PSUBSCRIBE [patrón ...]Escuchar los mensajes publicados a los canales que coinciden con los patrones dados</target>
        </trans-unit>
        <trans-unit id="2c633ee880363a76906d0e48643fc6fd3afe6539" translate="yes" xml:space="preserve">
          <source>PSYNC</source>
          <target state="translated">PSYNC</target>
        </trans-unit>
        <trans-unit id="5d448b1760960854b1253a3a2cad23abdcfdac61" translate="yes" xml:space="preserve">
          <source>PSYNC  replicationid offset   Internal command used for replication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8bdca458042e425d2902f59f800419aed5c8b1" translate="yes" xml:space="preserve">
          <source>PTTL</source>
          <target state="translated">PTTL</target>
        </trans-unit>
        <trans-unit id="05bf8ee07e7053cfaf8f62c038f0255fadf89afe" translate="yes" xml:space="preserve">
          <source>PTTL  key   Get the time to live for a key in milliseconds</source>
          <target state="translated">Llave PTTL Obtener el tiempo de vida para una llave en milisegundos</target>
        </trans-unit>
        <trans-unit id="ff0fc30c743813f924dff4b751315af42d5ab08b" translate="yes" xml:space="preserve">
          <source>PUBLISH</source>
          <target state="translated">PUBLISH</target>
        </trans-unit>
        <trans-unit id="46e845a027f7bb36580703fc200d9108559fa747" translate="yes" xml:space="preserve">
          <source>PUBLISH  channel message   Post a message to a channel</source>
          <target state="translated">PUBLICAR mensaje de canal Publicar un mensaje en un canal</target>
        </trans-unit>
        <trans-unit id="9487f50e961af3141e0c7833372d9b2c28cfa2a4" translate="yes" xml:space="preserve">
          <source>PUBSUB</source>
          <target state="translated">PUBSUB</target>
        </trans-unit>
        <trans-unit id="acad4a3c05b50f5f04a99427d2a3cdbb983fb0b9" translate="yes" xml:space="preserve">
          <source>PUBSUB  subcommand [argument [argument ...]]   Inspect the state of the Pub/Sub subsystem</source>
          <target state="translated">Subcomando PUBSUB [argumento [argumento ...]]Inspeccionar el estado del subsistema Pub/Sub</target>
        </trans-unit>
        <trans-unit id="ca024e3f958c6b7f4c7fa3671697866707cfa352" translate="yes" xml:space="preserve">
          <source>PUBSUB CHANNELS [pattern]</source>
          <target state="translated">CANALES DE PUBSUB [patrón]</target>
        </trans-unit>
        <trans-unit id="56e20f63e75d465369356d3ab7aa54f42d22cbb4" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE</source>
          <target state="translated">PUNSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="e54d89cca768ad85f7527ac0169fa1af2910b1cf" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE  [pattern [pattern ...]]   Stop listening for messages posted to channels matching the given patterns</source>
          <target state="translated">PUNSUBSCRIBE [patrón [patrón ...]]Deje de escuchar los mensajes enviados a los canales que coinciden con los patrones dados</target>
        </trans-unit>
        <trans-unit id="df3251b7546bede28dd0b0e82a26302f58157038" translate="yes" xml:space="preserve">
          <source>Passing keys and arguments as additional &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; arguments is also very useful in this context as the script string remains constant and can be efficiently cached by Redis.</source>
          <target state="translated">Pasar claves y argumentos como argumentos &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; adicionales tambi&amp;eacute;n es muy &amp;uacute;til en este contexto, ya que la cadena del script permanece constante y Redis puede almacenarla en cach&amp;eacute; de manera eficiente.</target>
        </trans-unit>
        <trans-unit id="19999dd613b36fb0786e599a84893b1e8a156a95" translate="yes" xml:space="preserve">
          <source>Pattern: Circular list</source>
          <target state="translated">Patrón:Lista circular</target>
        </trans-unit>
        <trans-unit id="4d81f3aa2a2c95fc4a2b98f51dce59a3bb00d586" translate="yes" xml:space="preserve">
          <source>Pattern: Counter</source>
          <target state="translated">Patrón:Contador</target>
        </trans-unit>
        <trans-unit id="73ea3bc6eae64663018b769f7c415b912584ee38" translate="yes" xml:space="preserve">
          <source>Pattern: Event notification</source>
          <target state="translated">Patrón:Notificación de eventos</target>
        </trans-unit>
        <trans-unit id="9ff13cc43cfbf608a403dd95aced2e1c0f9fa96b" translate="yes" xml:space="preserve">
          <source>Pattern: Navigation session</source>
          <target state="translated">Patrón:Sesión de navegación</target>
        </trans-unit>
        <trans-unit id="a7fd682d147cfd39262ca78719007b5177407a15" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter</source>
          <target state="translated">Patrón:Limitador de velocidad</target>
        </trans-unit>
        <trans-unit id="527a190ff3f82d3d4bdfebea8586b0d301a67e3d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 1</source>
          <target state="translated">Patrón:Limitador de velocidad 1</target>
        </trans-unit>
        <trans-unit id="d037a3f2c416c91b7789e304c06bd5786301383d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 2</source>
          <target state="translated">Patrón:Limitador de velocidad 2</target>
        </trans-unit>
        <trans-unit id="18e48daae4954154a5de8c81ecf51283e080aacd" translate="yes" xml:space="preserve">
          <source>Pattern: Reliable queue</source>
          <target state="translated">Patrón:Cola confiable</target>
        </trans-unit>
        <trans-unit id="bc4ebd36f01622a36d608ba3197fe5c6b53d07d7" translate="yes" xml:space="preserve">
          <source>Pattern: Time series</source>
          <target state="translated">Patrón:Serie de tiempo</target>
        </trans-unit>
        <trans-unit id="aaa32185c003a60c49d4fa1de6cdca30261f99bd" translate="yes" xml:space="preserve">
          <source>Pattern: accessing the entire bitmap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa9774204b5b0358a99c12a75b97dace59e135d" translate="yes" xml:space="preserve">
          <source>Pattern: real time metrics using bitmaps</source>
          <target state="translated">Patrón:métricas en tiempo real usando mapas de bits</target>
        </trans-unit>
        <trans-unit id="387aa2d6e23537ab60fac1801379d3a3550c02d6" translate="yes" xml:space="preserve">
          <source>Pattern: real-time metrics using bitmaps</source>
          <target state="translated">Patrón:métrica en tiempo real usando mapas de bits</target>
        </trans-unit>
        <trans-unit id="4fd48af62eda73b71f46321f27a6f38fb4751056" translate="yes" xml:space="preserve">
          <source>Pattern: setting multiple bits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f113cb1df36820baa76cc50b4089ad6af9aea4" translate="yes" xml:space="preserve">
          <source>Pattern: weighted random selection of an element</source>
          <target state="translated">Patrón:selección aleatoria ponderada de un elemento</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="65bb2cda328eeb96caf6c6dce99ad10ccece742e" translate="yes" xml:space="preserve">
          <source>Pause the clients using &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</source>
          <target state="translated">Pause a los clientes usando &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="172162ae29287e5e829be8811d680119905ff86b" translate="yes" xml:space="preserve">
          <source>Perform a bitwise operation between multiple keys (containing string values) and store the result in the destination key.</source>
          <target state="translated">Realice una operación de bits entre varias teclas (que contengan valores de cadena)y almacene el resultado en la tecla de destino.</target>
        </trans-unit>
        <trans-unit id="1627d1d0d50fdeb9a3dce196f5de79d8f43842c0" translate="yes" xml:space="preserve">
          <source>Perform a blocking SAVE if at least one &lt;strong&gt;save point&lt;/strong&gt; is configured.</source>
          <target state="translated">Realice un bloqueo SAVE si al menos un &lt;strong&gt;punto de guardado&lt;/strong&gt; est&amp;aacute; configurado.</target>
        </trans-unit>
        <trans-unit id="c05e233359dba5b59b70fc0039c9fb4fdb4976d0" translate="yes" xml:space="preserve">
          <source>Perform a partial resynchronization after a disconnection.</source>
          <target state="translated">Realizar una resincronización parcial después de una desconexión.</target>
        </trans-unit>
        <trans-unit id="9d05c962f81bccc17939e7dff46bacb302dd37a2" translate="yes" xml:space="preserve">
          <source>Perform the SHA1 of the input string.</source>
          <target state="translated">Realiza el SHA1 de la cadena de entrada.</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">Consideraciones sobre el rendimiento</target>
        </trans-unit>
        <trans-unit id="c5453c00c8e4c4429dffd7c57ff9e409df17e57a" translate="yes" xml:space="preserve">
          <source>Performances</source>
          <target state="translated">Performances</target>
        </trans-unit>
        <trans-unit id="98a191010a72a819b496571f1515f19fc5db230c" translate="yes" xml:space="preserve">
          <source>Please check the example below and the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; documentation for more information about the command and its options.</source>
          <target state="translated">Consulte el siguiente ejemplo y la documentaci&amp;oacute;n de &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el comando y sus opciones.</target>
        </trans-unit>
        <trans-unit id="2adb7fe266cd87cc96a429b9dce43b2d62d33470" translate="yes" xml:space="preserve">
          <source>Please for the specific semantics of the command refer to the documentation of &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;.</source>
          <target state="translated">Para conocer la sem&amp;aacute;ntica espec&amp;iacute;fica del comando, consulte la documentaci&amp;oacute;n de &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d37ebc2f4f2d1c9e1508f49167dd6105a3aa57b4" translate="yes" xml:space="preserve">
          <source>Please note depending on the version of Redis some of the fields have been added or removed. A robust client application should therefore parse the result of this command by skipping unknown properties, and gracefully handle missing fields.</source>
          <target state="translated">Tenga en cuenta que,dependiendo de la versión de Redis,algunos de los campos se han añadido o eliminado.Por lo tanto,una aplicación cliente robusta debería analizar el resultado de este comando saltando las propiedades desconocidas,y manejar con gracia los campos que faltan.</target>
        </trans-unit>
        <trans-unit id="cf36c5202e34a4a67ab38d9f9bd7222bda763dfd" translate="yes" xml:space="preserve">
          <source>Please note that before reading this page, if you are new to streams, we recommend to read &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;our introduction to Redis Streams&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que antes de leer esta p&amp;aacute;gina, si es nuevo en las transmisiones, le recomendamos que lea &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;nuestra introducci&amp;oacute;n a Redis Streams&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95e0253f33057b2f70a061e11de2d3d4a685d9c7" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; documentation for detailed information about Redis Lua scripting.</source>
          <target state="translated">Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; para obtener informaci&amp;oacute;n detallada sobre las secuencias de comandos de Redis Lua.</target>
        </trans-unit>
        <trans-unit id="67fc81a1bc0292fa12fdf63856d1ae3a69b0523a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence documentation&lt;/a&gt; for detailed information.</source>
          <target state="translated">Consulte la &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;documentaci&amp;oacute;n de persistencia&lt;/a&gt; para obtener informaci&amp;oacute;n detallada.</target>
        </trans-unit>
        <trans-unit id="13eff9f035082f1c14cd73067127e19e708dd746" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a135ffdb71c43178f876e40f960bf45f1a29237" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; documentation.</source>
          <target state="translated">Consulte la descripci&amp;oacute;n del patr&amp;oacute;n en la documentaci&amp;oacute;n de &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aed6d393dd61d1ba31957e351636ff901b0e6fa8" translate="yes" xml:space="preserve">
          <source>Posts a message to the given channel.</source>
          <target state="translated">Publica un mensaje en el canal correspondiente.</target>
        </trans-unit>
        <trans-unit id="f815dfb4f6f438e54dc2f0a16193e4c96d3c1109" translate="yes" xml:space="preserve">
          <source>Practically speaking, for the client it is much better to simply assume that in the context of a given connection, cached scripts are guaranteed to be there unless an administrator explicitly called the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command.</source>
          <target state="translated">En t&amp;eacute;rminos pr&amp;aacute;cticos, para el cliente es mucho mejor simplemente asumir que en el contexto de una conexi&amp;oacute;n determinada, se garantiza que los scripts almacenados en cach&amp;eacute; estar&amp;aacute;n all&amp;iacute; a menos que un administrador llame expl&amp;iacute;citamente al comando &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8c495de1a9098dd3bc4b934ccc859d56035029" translate="yes" xml:space="preserve">
          <source>Produces an ASCII-art style graph for the specified event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d21fc376a96084ebb73d4e8b35c0a4c4be845e0" translate="yes" xml:space="preserve">
          <source>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, or &lt;code&gt;sentinel&lt;/code&gt;. The command also returns additional information about the state of the replication (if the role is master or slave) or the list of monitored master names (if the role is sentinel).</source>
          <target state="translated">Proporcione informaci&amp;oacute;n sobre el rol de una instancia de Redis en el contexto de la replicaci&amp;oacute;n, devolviendo si la instancia es actualmente &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; o &lt;code&gt;sentinel&lt;/code&gt; . El comando tambi&amp;eacute;n devuelve informaci&amp;oacute;n adicional sobre el estado de la replicaci&amp;oacute;n (si el rol es maestro o esclavo) o la lista de nombres de maestros monitoreados (si el rol es centinela).</target>
        </trans-unit>
        <trans-unit id="7ca91750d60fd45e80636934b3d1f1da26ffd9f9" translate="yes" xml:space="preserve">
          <source>Pub/Sub</source>
          <target state="translated">Pub/Sub</target>
        </trans-unit>
        <trans-unit id="5860c8458788e44e7636fa364548e067049a0d7b" translate="yes" xml:space="preserve">
          <source>QUIT</source>
          <target state="translated">QUIT</target>
        </trans-unit>
        <trans-unit id="7471799996c7de46c4ffa444365596fb514b6f5a" translate="yes" xml:space="preserve">
          <source>QUIT   Close the connection</source>
          <target state="translated">SALIR Cerrar la conexión</target>
        </trans-unit>
        <trans-unit id="baa5d3184c0cc0ce5e007af06198524a4d26548f" translate="yes" xml:space="preserve">
          <source>Quit the server.</source>
          <target state="translated">Deja el servidor.</target>
        </trans-unit>
        <trans-unit id="94386a96dc3f69665a14e74fb2942d92163c5d74" translate="yes" xml:space="preserve">
          <source>RANDOMKEY</source>
          <target state="translated">RANDOMKEY</target>
        </trans-unit>
        <trans-unit id="338552ba06825ef4f555f3d5ff79d40557c925de" translate="yes" xml:space="preserve">
          <source>RANDOMKEY   Return a random key from the keyspace</source>
          <target state="translated">RANDOMKEY Devuelve una clave aleatoria del espacio de teclas</target>
        </trans-unit>
        <trans-unit id="90a97e888676c2d0f3b14c8b4a5ca16d360880bc" translate="yes" xml:space="preserve">
          <source>READONLY</source>
          <target state="translated">READONLY</target>
        </trans-unit>
        <trans-unit id="21d1a8e094bd428debefea84e6dd96322d4c6011" translate="yes" xml:space="preserve">
          <source>READONLY   Enables read queries for a connection to a cluster replica node</source>
          <target state="translated">Permite leer consultas para una conexión a un nodo réplica de un cúmulo</target>
        </trans-unit>
        <trans-unit id="5305e8529d963d471cecc6faf967cedff2ea7494" translate="yes" xml:space="preserve">
          <source>READWRITE</source>
          <target state="translated">READWRITE</target>
        </trans-unit>
        <trans-unit id="2ae19352a72e6e879b7c82d353a544f20f6b355b" translate="yes" xml:space="preserve">
          <source>READWRITE   Disables read queries for a connection to a cluster replica node</source>
          <target state="translated">READWRITE Desactiva las consultas de lectura para una conexión a un nodo de réplica de un cúmulo</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="434016433de8ed51fc6a3df25c58d49e8397ca2e" translate="yes" xml:space="preserve">
          <source>RENAME  key newkey   Rename a key</source>
          <target state="translated">RENOMBRAR llave newkey Renombrar una llave</target>
        </trans-unit>
        <trans-unit id="eb9b6064a90c47e23a80adefc9b43f4215668dbe" translate="yes" xml:space="preserve">
          <source>RENAMENX</source>
          <target state="translated">RENAMENX</target>
        </trans-unit>
        <trans-unit id="e1288934ac4d4000f51ff88bf791420487a34758" translate="yes" xml:space="preserve">
          <source>RENAMENX  key newkey   Rename a key, only if the new key does not exist</source>
          <target state="translated">RENAMENX key newkey Renombra una llave,sólo si la nueva llave no existe</target>
        </trans-unit>
        <trans-unit id="12c92fcd35c554e1970345d0c852363a2bfff485" translate="yes" xml:space="preserve">
          <source>REPLICAOF</source>
          <target state="translated">REPLICAOF</target>
        </trans-unit>
        <trans-unit id="81253c78d1304948f92fc2d7488335ba2280cd3f" translate="yes" xml:space="preserve">
          <source>REPLICAOF  host port   Make the server a replica of another instance, or promote it as master.</source>
          <target state="translated">REPLICAOF puerto de host Hacer que el servidor sea una réplica de otra instancia,o promoverlo como maestro.</target>
        </trans-unit>
        <trans-unit id="995f2d9ddfbe7ab63a2a7ddd59856b61ae272710" translate="yes" xml:space="preserve">
          <source>RESET</source>
          <target state="translated">RESET</target>
        </trans-unit>
        <trans-unit id="1b3151a71b95e8cdeb31ff88835e69beefec4ac4" translate="yes" xml:space="preserve">
          <source>RESET   Reset the connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8135bcdb582d28d5425eef52faf6ac80eefb26" translate="yes" xml:space="preserve">
          <source>RESTORE</source>
          <target state="translated">RESTORE</target>
        </trans-unit>
        <trans-unit id="693be3f2ba1e3d54a77f2bd81f59053740c9352a" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTAURAR clave ttl valor serializado [SUSTITUIR]Crear una clave usando el valor serializado proporcionado,previamente obtenido usando DUMP.</target>
        </trans-unit>
        <trans-unit id="e604e0070c2d8dbd159ab393d370ee42dc12812f" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1631070e7f0b44982ae66b11640654e7ec5dc4bd" translate="yes" xml:space="preserve">
          <source>ROLE</source>
          <target state="translated">ROLE</target>
        </trans-unit>
        <trans-unit id="5b2e8afa66ad35a6843b32ab5ca521321ed80e09" translate="yes" xml:space="preserve">
          <source>ROLE   Return the role of the instance in the context of replication</source>
          <target state="translated">PAPEL Devolver el papel de la instancia en el contexto de la replicación</target>
        </trans-unit>
        <trans-unit id="b7ce3009275f8c79b50c7f42dcb85f259fc1334f" translate="yes" xml:space="preserve">
          <source>RPOP</source>
          <target state="translated">RPOP</target>
        </trans-unit>
        <trans-unit id="daae95751cd7b3b0d6286ba595f17b95a4dbf14d" translate="yes" xml:space="preserve">
          <source>RPOP  key   Remove and get the last element in a list</source>
          <target state="translated">Tecla RPOP Quitar y obtener el último elemento de una lista</target>
        </trans-unit>
        <trans-unit id="153bcead99c65ede929618b160dd530ec6817223" translate="yes" xml:space="preserve">
          <source>RPOP  key [count]   Remove and get the last elements in a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc91e22c7eda82f26217a9a276a557189795a83" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH</source>
          <target state="translated">RPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="9b4f14c63b639db09e2a8cbabb9aee76bf074fd7" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH  source destination   Remove the last element in a list, prepend it to another list and return it</source>
          <target state="translated">RPOPLPUSH origen destino Eliminar el último elemento de una lista,prepararlo para otra lista y devolverlo</target>
        </trans-unit>
        <trans-unit id="b9d73dc860be3da3eb63b95dc888be66d34c596b" translate="yes" xml:space="preserve">
          <source>RPUSH</source>
          <target state="translated">RPUSH</target>
        </trans-unit>
        <trans-unit id="3c855c64755366500528d84baa161e66c153eb2f" translate="yes" xml:space="preserve">
          <source>RPUSH  key element [element ...]   Append one or multiple elements to a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9293df01dd3379605fef72d334681379153757" translate="yes" xml:space="preserve">
          <source>RPUSH  key value [value ...]   Append one or multiple values to a list</source>
          <target state="translated">Valor de la clave RPUSH [valor ...]Añadir uno o varios valores a una lista</target>
        </trans-unit>
        <trans-unit id="a2fe5b491151e540de6422c6e85592df5f204dc3" translate="yes" xml:space="preserve">
          <source>RPUSHX</source>
          <target state="translated">RPUSHX</target>
        </trans-unit>
        <trans-unit id="9ca949029559acfa6521e4bf6649e713de5742b1" translate="yes" xml:space="preserve">
          <source>RPUSHX  key element [element ...]   Append an element to a list, only if the list exists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d6ff5cbc32d5fc0ed38bfb10b34d14916d1c00" translate="yes" xml:space="preserve">
          <source>RPUSHX  key value   Append a value to a list, only if the list exists</source>
          <target state="translated">Valor de la clave RPUSHX Agregar un valor a una lista,sólo si la lista existe</target>
        </trans-unit>
        <trans-unit id="a31a9b75b6318e8c48bf5d454b96698ee608da57" translate="yes" xml:space="preserve">
          <source>Range of integer scores that can be expressed precisely</source>
          <target state="translated">Rango de puntajes enteros que pueden ser expresados con precisión</target>
        </trans-unit>
        <trans-unit id="df8903174eb3eac863f1253076caa8171702cb53" translate="yes" xml:space="preserve">
          <source>Range: 3900-4000</source>
          <target state="translated">Rango:3900-4000</target>
        </trans-unit>
        <trans-unit id="e1d33f7270a253d76d9b6fe1deb9155ecce0ca42" translate="yes" xml:space="preserve">
          <source>Read data from one or multiple streams, only returning entries with an ID greater than the last received ID reported by the caller. This command has an option to block if items are not available, in a similar fashion to &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; and others.</source>
          <target state="translated">Leer datos de una o varias transmisiones, devolviendo &amp;uacute;nicamente las entradas con un ID mayor que el &amp;uacute;ltimo ID recibido informado por la persona que llama. Este comando tiene una opci&amp;oacute;n para bloquear si los elementos no est&amp;aacute;n disponibles, de manera similar a &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; o &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; y otros.</target>
        </trans-unit>
        <trans-unit id="58ccdcefd173a8269ea376346a634ff6e968e57b" translate="yes" xml:space="preserve">
          <source>Read only variants</source>
          <target state="translated">Variantes de sólo lectura</target>
        </trans-unit>
        <trans-unit id="b8590ac877c85f2030d4921db5e93ead78595a0f" translate="yes" xml:space="preserve">
          <source>Read queries against a Redis Cluster slave node are disabled by default, but you can use the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command to change this behavior on a per- connection basis. The &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; command resets the readonly mode flag of a connection back to readwrite.</source>
          <target state="translated">Las consultas de lectura contra un nodo esclavo de Redis Cluster est&amp;aacute;n deshabilitadas de forma predeterminada, pero puede usar el comando &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; para cambiar este comportamiento por conexi&amp;oacute;n. El comando &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; restablece el indicador de modo de solo lectura de una conexi&amp;oacute;n a lectura y escritura.</target>
        </trans-unit>
        <trans-unit id="9ec77fdefc87d676b3e9acb9a7b04ded405da8e4" translate="yes" xml:space="preserve">
          <source>Reading application code, the complete semantics might not be clear since the application calls commands defined server side.</source>
          <target state="translated">Leyendo el código de la aplicación,la semántica completa podría no estar clara ya que la aplicación llama a comandos definidos del lado del servidor.</target>
        </trans-unit>
        <trans-unit id="116cec955773e978e0eecf1499a10199d4278c99" translate="yes" xml:space="preserve">
          <source>Reading the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams introduction&lt;/a&gt; is highly suggested in order to understand more about the streams overall behavior and semantics.</source>
          <target state="translated">Se sugiere encarecidamente leer la &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introducci&amp;oacute;n de Redis Streams&lt;/a&gt; para comprender m&amp;aacute;s sobre el comportamiento general y la sem&amp;aacute;ntica de los streams.</target>
        </trans-unit>
        <trans-unit id="88951d0701502f598feecc55f4d3172c32a2db31" translate="yes" xml:space="preserve">
          <source>Reading the slow log</source>
          <target state="translated">Leyendo el registro lento</target>
        </trans-unit>
        <trans-unit id="a87de541283ca3bc3c0a398706ee3346da0564e3" translate="yes" xml:space="preserve">
          <source>Recent versions of Redis Sentinel (Redis 2.8.12 or greater) use CLIENT KILL in order to kill clients when an instance is reconfigured, in order to force clients to perform the handshake with one Sentinel again and update its configuration.</source>
          <target state="translated">Las versiones recientes de Redis Sentinel (Redis 2.8.12 o superior)utilizan CLIENT KILL para matar a los clientes cuando se reconfigura una instancia,con el fin de obligar a los clientes a realizar el apretón de manos con un Sentinel de nuevo y actualizar su configuración.</target>
        </trans-unit>
        <trans-unit id="68c1dff2ef06724a3eb5f0a503f24117784a62d1" translate="yes" xml:space="preserve">
          <source>Reconfigure clients to connect with the new master.</source>
          <target state="translated">Reconfigurar los clientes para conectar con el nuevo maestro.</target>
        </trans-unit>
        <trans-unit id="24071b57a13027c01339027dcccb98218f052a8f" translate="yes" xml:space="preserve">
          <source>Redis</source>
          <target state="translated">Redis</target>
        </trans-unit>
        <trans-unit id="64fb7fd6108bc6be312c9ee1e4ae786b08c32a13" translate="yes" xml:space="preserve">
          <source>Redis 3.2 introduced an optional &lt;code&gt;count&lt;/code&gt; argument that can be passed to &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; in order to retrieve multiple elements in a single call.</source>
          <target state="translated">Redis 3.2 introdujo un argumento de &lt;code&gt;count&lt;/code&gt; opcional que se puede pasar a &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; para recuperar m&amp;uacute;ltiples elementos en una sola llamada.</target>
        </trans-unit>
        <trans-unit id="ff9622e92b582b377cd9d107f3253f8a189b7cf9" translate="yes" xml:space="preserve">
          <source>Redis 6 connections starts in RESP2 mode, so clients implementing RESP2 do not need to change (nor there are short term plans to drop support for RESP2). Clients that want to handshake the RESP3 mode need to call the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command, using &quot;3&quot; as first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09da59c00f13190142c29bd0fc09b7580fb99363" translate="yes" xml:space="preserve">
          <source>Redis Cluster live resharding explained</source>
          <target state="translated">El grupo de Redis Cluster en vivo y en directo explicando la remodelación</target>
        </trans-unit>
        <trans-unit id="8be0343488efef207b0826c15486c08f81f5710d" translate="yes" xml:space="preserve">
          <source>Redis HyperLogLogs are represented using a double representation: the &lt;em&gt;sparse&lt;/em&gt; representation suitable for HLLs counting a small number of elements (resulting in a small number of registers set to non-zero value), and a &lt;em&gt;dense&lt;/em&gt; representation suitable for higher cardinalities. Redis automatically switches from the sparse to the dense representation when needed.</source>
          <target state="translated">Los HyperLogLog de Redis se representan mediante una doble representaci&amp;oacute;n: la representaci&amp;oacute;n &lt;em&gt;escasa&lt;/em&gt; adecuada para los HLL que cuentan una peque&amp;ntilde;a cantidad de elementos (lo que da como resultado una peque&amp;ntilde;a cantidad de registros establecidos en un valor distinto de cero) y una representaci&amp;oacute;n &lt;em&gt;densa&lt;/em&gt; adecuada para cardinalidades m&amp;aacute;s altas. Redis cambia autom&amp;aacute;ticamente de la representaci&amp;oacute;n escasa a la densa cuando es necesario.</target>
        </trans-unit>
        <trans-unit id="2e645ecd73ea1ffa136575150e55a17bbdaf4a35" translate="yes" xml:space="preserve">
          <source>Redis Nil bulk reply and Nil multi bulk reply -&amp;gt; Lua false boolean type</source>
          <target state="translated">Respuesta masiva Nil de Redis y respuesta masiva m&amp;uacute;ltiple Nil -&amp;gt; Lua tipo booleano falso</target>
        </trans-unit>
        <trans-unit id="12deb2b7b17fe48280b9acc8ac6e268a2fccdfc8" translate="yes" xml:space="preserve">
          <source>Redis bulk reply -&amp;gt; Lua string</source>
          <target state="translated">Respuesta masiva de Redis -&amp;gt; Cadena Lua</target>
        </trans-unit>
        <trans-unit id="28c992585f8b92e96ef7862e17fbc69b72429ffe" translate="yes" xml:space="preserve">
          <source>Redis commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements.</source>
          <target state="translated">Los comandos de Redis que pueden devolver elementos en orden aleatorio, como &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (porque los conjuntos de Redis &lt;em&gt;no&lt;/em&gt; est&amp;aacute;n &lt;em&gt;ordenados&lt;/em&gt; ) tienen un comportamiento diferente cuando se llaman desde Lua y se someten a un filtro de clasificaci&amp;oacute;n lexicogr&amp;aacute;fico silencioso antes de devolver los datos a los scripts de Lua. As&amp;iacute; que &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; siempre devolver&amp;aacute; los elementos Set en el mismo orden, mientras que el mismo comando invocado desde clientes normales puede devolver resultados diferentes incluso si la clave contiene exactamente los mismos elementos.</target>
        </trans-unit>
        <trans-unit id="9030a22b56473e440d80783adf7755f42e3cd798" translate="yes" xml:space="preserve">
          <source>Redis commands usually accept one key, two keys, or an unlimited number of keys.</source>
          <target state="translated">Los comandos de Redis suelen aceptar una tecla,dos teclas o un número ilimitado de teclas.</target>
        </trans-unit>
        <trans-unit id="4798309557a5e9b4d97ab42c59e238806f00fa04" translate="yes" xml:space="preserve">
          <source>Redis different selectable databases are a form of namespacing: all the databases are anyway persisted together in the same RDB / AOF file. However different databases can have keys having the same name, and there are commands available like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; that work on specific databases.</source>
          <target state="translated">Las diferentes bases de datos seleccionables de Redis son una forma de espacio de nombres: todas las bases de datos se conservan juntas en el mismo archivo RDB / AOF. Sin embargo, diferentes bases de datos pueden tener claves con el mismo nombre, y hay comandos disponibles como &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; , &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; o &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; que funcionan en bases de datos espec&amp;iacute;ficas.</target>
        </trans-unit>
        <trans-unit id="9e3076b9d3288c97597280422f53f06eb0450c13" translate="yes" xml:space="preserve">
          <source>Redis double reply -&amp;gt; Lua table with a single &lt;code&gt;score&lt;/code&gt; field containing a Lua number representing the double value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48311c837dbe1e0c3cec8f3114d4df2e8c16385" translate="yes" xml:space="preserve">
          <source>Redis error reply -&amp;gt; Lua table with a single &lt;code&gt;err&lt;/code&gt; field containing the error</source>
          <target state="translated">Respuesta de error de Redis -&amp;gt; Tabla Lua con un solo campo de &lt;code&gt;err&lt;/code&gt; or que contiene el error</target>
        </trans-unit>
        <trans-unit id="26c2d6e6bcc8ce21554bdf0baf74815e6f8c13dd" translate="yes" xml:space="preserve">
          <source>Redis false reply -&amp;gt; Lua false boolean value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="562ad79eb5fcdcd97d8a0283855bce99c0023855" translate="yes" xml:space="preserve">
          <source>Redis integer reply -&amp;gt; Lua number</source>
          <target state="translated">Respuesta de entero de Redis -&amp;gt; n&amp;uacute;mero Lua</target>
        </trans-unit>
        <trans-unit id="53c0959152bcf66e99f3ab4d98ebaba488b539de" translate="yes" xml:space="preserve">
          <source>Redis is UTF-8 aware, assuming you correctly set the &lt;code&gt;!LC_COLLATE&lt;/code&gt; environment variable.</source>
          <target state="translated">Redis es compatible con UTF-8, asumiendo que configur&amp;oacute; correctamente la variable de entorno &lt;code&gt;!LC_COLLATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac11208b3186492fddcf23ffb985bed2f4b921dd" translate="yes" xml:space="preserve">
          <source>Redis is now able to delete keys in the background in a different thread without blocking the server. An &lt;code&gt;ASYNC&lt;/code&gt; option was added to &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; in order to let the entire dataset or a single database to be freed asynchronously.</source>
          <target state="translated">Redis ahora puede eliminar claves en segundo plano en un hilo diferente sin bloquear el servidor. Se &lt;code&gt;ASYNC&lt;/code&gt; opci&amp;oacute;n ASYNC a &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; y &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; para permitir que todo el conjunto de datos o una sola base de datos se liberen de forma asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="f26191bd07f5d296d686b49ddf0fea28de008280" translate="yes" xml:space="preserve">
          <source>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (using polling), or &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; if the client is better served by a blocking operation.</source>
          <target state="translated">Redis se utiliza a menudo como servidor de mensajer&amp;iacute;a para implementar el procesamiento de trabajos en segundo plano u otros tipos de tareas de mensajer&amp;iacute;a. A menudo se obtiene una forma simple de cola insertando valores en una lista en el lado del productor y esperando estos valores en el lado del consumidor usando &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (usando sondeo), o &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; si el cliente est&amp;aacute; mejor atendido por una operaci&amp;oacute;n de bloqueo.</target>
        </trans-unit>
        <trans-unit id="42a27bac8c1f348420272658d3c655887b07c3ba" translate="yes" xml:space="preserve">
          <source>Redis keys are expired in two ways: a passive way, and an active way.</source>
          <target state="translated">Las claves de Redis expiran de dos maneras:una manera pasiva,y una manera activa.</target>
        </trans-unit>
        <trans-unit id="ea38abb16e6fc53c1055d716b8dafffc97128c14" translate="yes" xml:space="preserve">
          <source>Redis logs that a script is running too long.</source>
          <target state="translated">Redis registra que un guión se está ejecutando demasiado tiempo.</target>
        </trans-unit>
        <trans-unit id="07c6c60386c8d0b1cb8c0291d6e6212cf17c794b" translate="yes" xml:space="preserve">
          <source>Redis map reply -&amp;gt; Lua table with a single &lt;code&gt;map&lt;/code&gt; field containing a Lua table representing the fields and values of the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ada15ccb812ae3dfe260cac4cea16ab388a5061" translate="yes" xml:space="preserve">
          <source>Redis multi bulk reply -&amp;gt; Lua table (may have other Redis data types nested)</source>
          <target state="translated">Respuesta masiva de Redis -&amp;gt; Tabla Lua (puede tener otros tipos de datos de Redis anidados)</target>
        </trans-unit>
        <trans-unit id="6afefff72418c96bb7166299d904551e6e4c186a" translate="yes" xml:space="preserve">
          <source>Redis new RESP3 single null value -&amp;gt; Lua nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb910cc16645a1fbd760219098ebcbf7bc9f050c" translate="yes" xml:space="preserve">
          <source>Redis offers a SCRIPT command that can be used in order to control the scripting subsystem. SCRIPT currently accepts three different commands:</source>
          <target state="translated">Redis ofrece un comando SCRIPT que puede ser usado para controlar el subsistema de scripting.SCRIPT actualmente acepta tres comandos diferentes:</target>
        </trans-unit>
        <trans-unit id="0ab17f17e02f188a1bdf8cac0d6180f82fee1717" translate="yes" xml:space="preserve">
          <source>Redis return values are converted into Lua data types when Lua calls a Redis command using &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;pcall()&lt;/code&gt;. Similarly, Lua data types are converted into the Redis protocol when calling a Redis command and when a Lua script returns a value, so that scripts can control what &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will return to the client.</source>
          <target state="translated">Los valores de retorno de Redis se convierten en tipos de datos Lua cuando Lua llama a un comando de Redis usando &lt;code&gt;call()&lt;/code&gt; o &lt;code&gt;pcall()&lt;/code&gt; . De manera similar, los tipos de datos de Lua se convierten al protocolo de Redis cuando se llama a un comando de Redis y cuando un script de Lua devuelve un valor, de modo que los scripts pueden controlar lo que &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; devolver&amp;aacute; al cliente.</target>
        </trans-unit>
        <trans-unit id="0fa967ae24b949a1700795759c8cdfe062988a8a" translate="yes" xml:space="preserve">
          <source>Redis scripts are not allowed to create global variables, in order to avoid leaking data into the Lua state. If a script needs to maintain state between calls (a pretty uncommon need) it should use Redis keys instead.</source>
          <target state="translated">No se permite a los guiones de Redis crear variables globales,para evitar la fuga de datos al estado Lua.Si un script necesita mantener el estado entre llamadas (una necesidad bastante poco común)debe usar las teclas Redis en su lugar.</target>
        </trans-unit>
        <trans-unit id="62adbd77b4f8fad448a651b5f523abd0f146da57" translate="yes" xml:space="preserve">
          <source>Redis set reply -&amp;gt; Lua table with a single &lt;code&gt;set&lt;/code&gt; field containing a Lua table representing the elements of the set as fields, having as value just &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62135b0922f82850c893085d4cd08cc6fd7ccb4" translate="yes" xml:space="preserve">
          <source>Redis slow log overview</source>
          <target state="translated">Rediseño de la bitácora lenta</target>
        </trans-unit>
        <trans-unit id="add967db3e0dd55b3522bf60d87afa3192a4838a" translate="yes" xml:space="preserve">
          <source>Redis sorted sets use a &lt;em&gt;double 64-bit floating point number&lt;/em&gt; to represent the score. In all the architectures we support, this is represented as an &lt;strong&gt;IEEE 754 floating point number&lt;/strong&gt;, that is able to represent precisely integer numbers between &lt;code&gt;-(2^53)&lt;/code&gt; and &lt;code&gt;+(2^53)&lt;/code&gt; included. In more practical terms, all the integers between -9007199254740992 and 9007199254740992 are perfectly representable. Larger integers, or fractions, are internally represented in exponential form, so it is possible that you get only an approximation of the decimal number, or of the very big integer, that you set as score.</source>
          <target state="translated">Los conjuntos ordenados de Redis utilizan un &lt;em&gt;n&amp;uacute;mero de coma flotante doble de 64 bits&lt;/em&gt; para representar la puntuaci&amp;oacute;n. En todas las arquitecturas que admitimos, esto se representa como un &lt;strong&gt;n&amp;uacute;mero de punto flotante IEEE 754&lt;/strong&gt; , que es capaz de representar con precisi&amp;oacute;n n&amp;uacute;meros enteros entre &lt;code&gt;-(2^53)&lt;/code&gt; y &lt;code&gt;+(2^53)&lt;/code&gt; incluidos. En t&amp;eacute;rminos m&amp;aacute;s pr&amp;aacute;cticos, todos los n&amp;uacute;meros enteros entre -9007199254740992 y 9007199254740992 son perfectamente representables. Los enteros m&amp;aacute;s grandes, o fracciones, se representan internamente en forma exponencial, por lo que es posible que obtenga solo una aproximaci&amp;oacute;n del n&amp;uacute;mero decimal, o del entero muy grande, que estableci&amp;oacute; como puntuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="738a4a620b4c28b97c15ca1b2edd5526cb23af29" translate="yes" xml:space="preserve">
          <source>Redis status reply -&amp;gt; Lua table with a single &lt;code&gt;ok&lt;/code&gt; field containing the status</source>
          <target state="translated">Respuesta de estado de Redis -&amp;gt; Tabla Lua con un solo campo &lt;code&gt;ok&lt;/code&gt; que contiene el estado</target>
        </trans-unit>
        <trans-unit id="db935d0902ab47146d7cddc707ae23f8dbd30e13" translate="yes" xml:space="preserve">
          <source>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</source>
          <target state="translated">Redis almacena los números enteros en su representación de números enteros,así que para los valores de cadena que realmente contienen un número entero,no hay gastos generales para almacenar la representación de la cadena del número entero.</target>
        </trans-unit>
        <trans-unit id="b6955638f080137455ca2315a3e774bacb29e670" translate="yes" xml:space="preserve">
          <source>Redis streams are represented in a way that makes them memory efficient: a radix tree is used in order to index macro-nodes that pack linearly tens of stream entries. Normally what happens when you delete an entry from a stream is that the entry is not &lt;em&gt;really&lt;/em&gt; evicted, it just gets marked as deleted.</source>
          <target state="translated">Los flujos de Redis se representan de una manera que los hace eficientes en memoria: se utiliza un &amp;aacute;rbol de base para indexar macro-nodos que empaquetan linealmente decenas de entradas de flujo. Normalmente, lo que sucede cuando elimina una entrada de una secuencia es que la entrada no &lt;em&gt;se&lt;/em&gt; desaloja &lt;em&gt;realmente&lt;/em&gt; , simplemente se marca como eliminada.</target>
        </trans-unit>
        <trans-unit id="5d32a14fd1723b346b2a3b7e8ab15af43e61bb43" translate="yes" xml:space="preserve">
          <source>Redis true reply -&amp;gt; Lua true boolean value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7af6984c788798f4aee1b72f3fb15136c972f4" translate="yes" xml:space="preserve">
          <source>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</source>
          <target state="translated">Redis usa el mismo int&amp;eacute;rprete de Lua para ejecutar todos los comandos. Adem&amp;aacute;s, Redis garantiza que un script se ejecuta de forma at&amp;oacute;mica: no se ejecutar&amp;aacute; ning&amp;uacute;n otro script o comando de Redis mientras se ejecuta un script. Esta sem&amp;aacute;ntica es similar a la de &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; . Desde el punto de vista de todos los dem&amp;aacute;s clientes, los efectos de un script a&amp;uacute;n no son visibles o ya est&amp;aacute;n completados.</target>
        </trans-unit>
        <trans-unit id="358fd429e373e6f088abb4b934d2faf8511ecbc9" translate="yes" xml:space="preserve">
          <source>Redis versions prior of Redis 6 were only able to understand the one argument version of the command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315e6feef25876fa664b37d723e94c657b1c8f6a" translate="yes" xml:space="preserve">
          <source>Redis will block the script with an error if a script calls a Redis command able to alter the data set &lt;strong&gt;after&lt;/strong&gt; a Redis &lt;em&gt;random&lt;/em&gt; command like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;. This means that if a script is read-only and does not modify the data set it is free to call those commands. Note that a &lt;em&gt;random command&lt;/em&gt; does not necessarily mean a command that uses random numbers: any non-deterministic command is considered a random command (the best example in this regard is the &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command).</source>
          <target state="translated">Redis bloquear&amp;aacute; la secuencia de comandos con un error si una secuencia de comandos llama a un comando de Redis capaz de alterar el conjunto de datos &lt;strong&gt;despu&amp;eacute;s de&lt;/strong&gt; un comando &lt;em&gt;aleatorio de&lt;/em&gt; Redis como &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; , &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; , &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; . Esto significa que si un script es de solo lectura y no modifica el conjunto de datos, es libre de llamar a esos comandos. Tenga en cuenta que un &lt;em&gt;comando aleatorio&lt;/em&gt; no significa necesariamente un comando que utiliza n&amp;uacute;meros aleatorios: cualquier comando no determinista se considera un comando aleatorio (el mejor ejemplo a este respecto es el comando &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d65bbb9c212a9d98ffb329def918b64ef3d8889" translate="yes" xml:space="preserve">
          <source>Refreshing expires</source>
          <target state="translated">El refresco caduca</target>
        </trans-unit>
        <trans-unit id="26ca731c99535195e55e64ad25c62f00fdbd2a4c" translate="yes" xml:space="preserve">
          <source>Reliable queues</source>
          <target state="translated">Colas fiables</target>
        </trans-unit>
        <trans-unit id="ea59d67e277c60b336a409408ff4d775b8225584" translate="yes" xml:space="preserve">
          <source>Remove a specific consumer from a consumer group.</source>
          <target state="translated">Eliminar a un consumidor específico de un grupo de consumidores.</target>
        </trans-unit>
        <trans-unit id="ce4d2a865a5a06124187f3a0d8a5354cd701d61f" translate="yes" xml:space="preserve">
          <source>Remove the existing timeout on &lt;code&gt;key&lt;/code&gt;, turning the key from &lt;em&gt;volatile&lt;/em&gt; (a key with an expire set) to &lt;em&gt;persistent&lt;/em&gt; (a key that will never expire as no timeout is associated).</source>
          <target state="translated">Elimine el tiempo de espera existente en la &lt;code&gt;key&lt;/code&gt; , cambiando la clave de &lt;em&gt;vol&amp;aacute;til&lt;/em&gt; (una clave con un vencimiento establecido) a &lt;em&gt;persistente&lt;/em&gt; (una clave que nunca caducar&amp;aacute; ya que no hay tiempo de espera asociado).</target>
        </trans-unit>
        <trans-unit id="c1d260f4e3da83fa28a692c23e66ed0cb15dd796" translate="yes" xml:space="preserve">
          <source>Remove the specified members from the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are not a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty set and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Elimina los miembros especificados del conjunto almacenado en &lt;code&gt;key&lt;/code&gt; . Los miembros especificados que no son miembros de este conjunto se ignoran. Si la &lt;code&gt;key&lt;/code&gt; no existe, se trata como un conjunto vac&amp;iacute;o y este comando devuelve &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0b8cb5dfcd4da1251a55ebacec477902ab7fa1" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (inclusive).</source>
          <target state="translated">Elimina todos los elementos del conjunto ordenado almacenados en &lt;code&gt;key&lt;/code&gt; con una puntuaci&amp;oacute;n entre &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; (inclusive).</target>
        </trans-unit>
        <trans-unit id="cbb3fc019bde7aa5a4f4696386c7635ab2172c17" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with rank between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt; -based indexes with &lt;code&gt;0&lt;/code&gt; being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score. For example: &lt;code&gt;-1&lt;/code&gt; is the element with the highest score, &lt;code&gt;-2&lt;/code&gt; the element with the second highest score and so forth.</source>
          <target state="translated">Elimina todos los elementos del conjunto ordenado almacenados en la &lt;code&gt;key&lt;/code&gt; con rango entre &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;stop&lt;/code&gt; . Tanto &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;stop&lt;/code&gt; son &lt;code&gt;0&lt;/code&gt; &amp;iacute;ndices basados con &lt;code&gt;0&lt;/code&gt; siendo el elemento con la puntuaci&amp;oacute;n m&amp;aacute;s baja. Estos &amp;iacute;ndices pueden ser n&amp;uacute;meros negativos, donde indican compensaciones que comienzan en el elemento con la puntuaci&amp;oacute;n m&amp;aacute;s alta. Por ejemplo: &lt;code&gt;-1&lt;/code&gt; es el elemento con la puntuaci&amp;oacute;n m&amp;aacute;s alta, &lt;code&gt;-2&lt;/code&gt; el elemento con la segunda puntuaci&amp;oacute;n m&amp;aacute;s alta y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="da37c36034834387a9dd7fbda191a975ebb105b0" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random elements from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Elimina y devuelve uno o m&amp;aacute;s elementos aleatorios del valor establecido almacenado en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbdedbfa9e258d96431019af8d58bcfa65137941" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random members from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870ac46dca2c1a6689064e1cced801af5e158f69" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Elimina y devuelve el primer elemento de la lista almacenado en &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abb0c00334891c9a62b73bcc7669016da3f5a06d" translate="yes" xml:space="preserve">
          <source>Removes and returns the first elements of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2ce52901cbc45793a1c6bb41b722b9057d2bc4" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Elimina y devuelve el &amp;uacute;ltimo elemento de la lista almacenado en &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="068c1fcc92f924f323a2866cd513ee38912fea94" translate="yes" xml:space="preserve">
          <source>Removes and returns the last elements of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52acb45013cdb2a41dc580913c01c50bd6ebca86" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the highest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Elimina y vuelve a &lt;code&gt;count&lt;/code&gt; miembros con las puntuaciones m&amp;aacute;s altas en el conjunto ordenado almacenado en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac48e8c652eae033a19d95a11cb8d9dbd5e35dab" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the lowest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Elimina y vuelve a &lt;code&gt;count&lt;/code&gt; miembros con las puntuaciones m&amp;aacute;s bajas en el conjunto ordenado almacenado en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f36f141768a197b4276a61d3b54c8f396195cafb" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;element&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6ffaff6ffe08c9f43baab9718f030d2162d111" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;value&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">Elimina las primeras apariciones de &lt;code&gt;count&lt;/code&gt; de elementos iguales a &lt;code&gt;value&lt;/code&gt; de la lista almacenada en &lt;code&gt;key&lt;/code&gt; . El argumento de &lt;code&gt;count&lt;/code&gt; influye en la operaci&amp;oacute;n de las siguientes formas:</target>
        </trans-unit>
        <trans-unit id="494ca7e2faa6bd5b36a369eb7746bb78fb3e96bc" translate="yes" xml:space="preserve">
          <source>Removes the specified entries from a stream, and returns the number of entries deleted, that may be different from the number of IDs passed to the command in case certain IDs do not exist.</source>
          <target state="translated">Elimina las entradas especificadas de un flujo y devuelve el número de entradas eliminadas,que puede ser diferente del número de identificaciones pasadas al comando en caso de que no existan determinadas identificaciones.</target>
        </trans-unit>
        <trans-unit id="594397839f7156989bc1b259c19072c5484f7bdc" translate="yes" xml:space="preserve">
          <source>Removes the specified fields from the hash stored at &lt;code&gt;key&lt;/code&gt;. Specified fields that do not exist within this hash are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty hash and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Elimina los campos especificados del hash almacenado en &lt;code&gt;key&lt;/code&gt; . Los campos especificados que no existen dentro de este hash se ignoran. Si la &lt;code&gt;key&lt;/code&gt; no existe, se trata como un hash vac&amp;iacute;o y este comando devuelve &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="322e3109be94b3ac9ea4c2a44f232f96c6cd905a" translate="yes" xml:space="preserve">
          <source>Removes the specified keys. A key is ignored if it does not exist.</source>
          <target state="translated">Elimina las claves especificadas.Una clave es ignorada si no existe.</target>
        </trans-unit>
        <trans-unit id="933e4f3eff042f249c190608a122f8e43bd494af" translate="yes" xml:space="preserve">
          <source>Removes the specified members from the sorted set stored at &lt;code&gt;key&lt;/code&gt;. Non existing members are ignored.</source>
          <target state="translated">Elimina los miembros especificados del conjunto ordenado almacenado en &lt;code&gt;key&lt;/code&gt; . Los miembros no existentes se ignoran.</target>
        </trans-unit>
        <trans-unit id="17baa9fe7f8ed0143fa7df75975e104465db4e59" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; does not yet exist. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">Cambia el nombre de la &lt;code&gt;key&lt;/code&gt; a &lt;code&gt;newkey&lt;/code&gt; si &lt;code&gt;newkey&lt;/code&gt; a&amp;uacute;n no existe. Devuelve un error cuando la &lt;code&gt;key&lt;/code&gt; no existe.</target>
        </trans-unit>
        <trans-unit id="0155259665636f6ceaaa0a0ebda67bb195d98a6d" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt;. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist. If &lt;code&gt;newkey&lt;/code&gt; already exists it is overwritten, when this happens &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; executes an implicit &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation, so if the deleted key contains a very big value it may cause high latency even if &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; itself is usually a constant-time operation.</source>
          <target state="translated">Cambia el nombre de la &lt;code&gt;key&lt;/code&gt; a &lt;code&gt;newkey&lt;/code&gt; . Devuelve un error cuando la &lt;code&gt;key&lt;/code&gt; no existe. Si la &lt;code&gt;newkey&lt;/code&gt; ya existe, se sobrescribe, cuando esto sucede, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; ejecuta una operaci&amp;oacute;n &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; impl&amp;iacute;cita , por lo que si la clave eliminada contiene un valor muy grande, puede causar una latencia alta incluso si &lt;a href=&quot;rename&quot;&gt;RENAME en&lt;/a&gt; s&amp;iacute; mismo suele ser una operaci&amp;oacute;n de tiempo constante.</target>
        </trans-unit>
        <trans-unit id="351fb2e9d60cd91bf6510354de71fa6c06419ab4" translate="yes" xml:space="preserve">
          <source>Replicas broadcast their master's config epochs (in order to get an &lt;code&gt;UPDATE&lt;/code&gt; message if they are found to be stale), so the real config epoch of the replica (which is meaningless more or less, since they don't serve hash slots) can be only obtained checking the node flagged as &lt;code&gt;myself&lt;/code&gt;, which is the entry of the node we are asking to generate &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output. The other replicas epochs reflect what they publish in heartbeat packets, which is, the configuration epoch of the masters they are currently replicating.</source>
          <target state="translated">Las r&amp;eacute;plicas transmiten las &amp;eacute;pocas de configuraci&amp;oacute;n de su maestro (para obtener un mensaje de &lt;code&gt;UPDATE&lt;/code&gt; si se encuentran obsoletas), por lo que la &amp;eacute;poca de configuraci&amp;oacute;n real de la r&amp;eacute;plica (que no tiene sentido m&amp;aacute;s o menos, ya que no sirven ranuras hash) puede ser Solo se obtuvo verificando el nodo marcado como &lt;code&gt;myself&lt;/code&gt; , que es la entrada del nodo que estamos pidiendo para generar la salida de &lt;a href=&quot;cluster-nodes&quot;&gt;NODOS DE CLUSTER&lt;/a&gt; . Las otras &amp;eacute;pocas de r&amp;eacute;plicas reflejan lo que publican en paquetes de latidos, es decir, la &amp;eacute;poca de configuraci&amp;oacute;n de los maestros que est&amp;aacute;n replicando actualmente.</target>
        </trans-unit>
        <trans-unit id="57ee014fca43ed90896705e17d43f35b06757596" translate="yes" xml:space="preserve">
          <source>Replicating commands instead of scripts</source>
          <target state="translated">Replicando comandos en lugar de guiones</target>
        </trans-unit>
        <trans-unit id="054fb8240ac6c1ab20550a9e5b79d9d4cd6d1345" translate="yes" xml:space="preserve">
          <source>Request for authentication in a password-protected Redis server. Redis can be instructed to require a password before allowing clients to execute commands. This is done using the &lt;code&gt;requirepass&lt;/code&gt; directive in the configuration file.</source>
          <target state="translated">Solicitud de autenticaci&amp;oacute;n en un servidor Redis protegido por contrase&amp;ntilde;a. Se puede indicar a Redis que solicite una contrase&amp;ntilde;a antes de permitir que los clientes ejecuten comandos. Esto se hace usando la directiva &lt;code&gt;requirepass&lt;/code&gt; en el archivo de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="da1bb4a2fc17746f7a5baea5144086fae0563a1a" translate="yes" xml:space="preserve">
          <source>Reset a Redis Cluster node, in a more or less drastic way depending on the reset type, that can be &lt;strong&gt;hard&lt;/strong&gt; or &lt;strong&gt;soft&lt;/strong&gt;. Note that this command &lt;strong&gt;does not work for masters if they hold one or more keys&lt;/strong&gt;, in that case to completely reset a master node keys must be removed first, e.g. by using &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; first, and then &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;.</source>
          <target state="translated">Restablecer un nodo de Redis Cluster, de forma m&amp;aacute;s o menos dr&amp;aacute;stica seg&amp;uacute;n el tipo de restablecimiento, que puede ser &lt;strong&gt;duro&lt;/strong&gt; o &lt;strong&gt;suave&lt;/strong&gt; . Tenga en cuenta que este comando &lt;strong&gt;no funciona para los maestros si tienen una o m&amp;aacute;s claves&lt;/strong&gt; , en ese caso, para restablecer completamente un nodo maestro, las claves deben eliminarse primero, por ejemplo, usando primero &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; y luego &lt;a href=&quot;cluster-reset&quot;&gt;RESET CLUSTER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b45f167ccc9268d6db2b2030f5f33cd642304b9" translate="yes" xml:space="preserve">
          <source>Resets the statistics reported by Redis using the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command.</source>
          <target state="translated">Restablece las estad&amp;iacute;sticas informadas por Redis mediante el comando &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b4926f937540a054f457674fa7da321fbd6a1f7" translate="yes" xml:space="preserve">
          <source>Resetting the slow log.</source>
          <target state="translated">Reajustando el registro lento.</target>
        </trans-unit>
        <trans-unit id="401feffc58d082a7dc99bf3cdbc90af756748e94" translate="yes" xml:space="preserve">
          <source>Reshard all the hash slots from D to nodes A, B, C.</source>
          <target state="translated">Resuelve todas las ranuras de hachís de la D a los nodos A,B,C.</target>
        </trans-unit>
        <trans-unit id="d71f5749e9e28d5922b96f1c26e811052165fc71" translate="yes" xml:space="preserve">
          <source>Retrieving external keys</source>
          <target state="translated">Recuperar las llaves externas</target>
        </trans-unit>
        <trans-unit id="6fc93fde5d23bf392c79a9f984537ca96d065420" translate="yes" xml:space="preserve">
          <source>Return a random key from the currently selected database.</source>
          <target state="translated">Devuelve una clave aleatoria de la base de datos seleccionada actualmente.</target>
        </trans-unit>
        <trans-unit id="6fd47a35bf916d5d67439ea375fe4e2fb769d84c" translate="yes" xml:space="preserve">
          <source>Return the UNIX TIME of the last DB save executed with success. A client may check if a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command succeeded reading the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; value, then issuing a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command and checking at regular intervals every N seconds if &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; changed.</source>
          <target state="translated">Devuelve el TIEMPO UNIX del &amp;uacute;ltimo guardado de base de datos ejecutado con &amp;eacute;xito. Un cliente puede verificar si un comando &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; tuvo &amp;eacute;xito al leer el valor &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; , luego emitir un comando &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; y verificar a intervalos regulares cada N segundos si &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; cambi&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="7298f92c54146228ead6d1a31b40025056a03b02" translate="yes" xml:space="preserve">
          <source>Return the distance between two members in the geospatial index represented by the sorted set.</source>
          <target state="translated">Devuelve la distancia entre dos miembros en el índice geoespacial representado por el conjunto ordenado.</target>
        </trans-unit>
        <trans-unit id="da507356e98e4d51d3b0a5e69a99468bdb6da16d" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified by a given shape. This command extends the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; command, so in addition to searching within circular areas, it supports searching within rectangular areas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb126873153beb4e986e8428f3f0a902f06d1bc" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified with the center location and the maximum distance from the center (the radius).</source>
          <target state="translated">Devuelve los miembros de un conjunto ordenado poblado con informaci&amp;oacute;n geoespacial usando &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; , que est&amp;aacute;n dentro de los l&amp;iacute;mites del &amp;aacute;rea especificada con la ubicaci&amp;oacute;n del centro y la distancia m&amp;aacute;xima desde el centro (el radio).</target>
        </trans-unit>
        <trans-unit id="a7ff116fa994743f4fb0646cce53a6396e097c89" translate="yes" xml:space="preserve">
          <source>Return the number of keys in the currently-selected database.</source>
          <target state="translated">Devuelve el número de claves en la base de datos seleccionada actualmente.</target>
        </trans-unit>
        <trans-unit id="06398ca22b9ef82a3c94cf8b1160f8f9c766b74a" translate="yes" xml:space="preserve">
          <source>Return the position of the first bit set to 1 or 0 in a string.</source>
          <target state="translated">Devuelve la posición del primer bit a 1 o 0 en una cadena.</target>
        </trans-unit>
        <trans-unit id="1d1482b5db471b056549fa1a5580198ec9701587" translate="yes" xml:space="preserve">
          <source>Return the positions (longitude,latitude) of all the specified members of the geospatial index represented by the sorted set at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">Devuelve las posiciones (longitud, latitud) de todos los miembros especificados del &amp;iacute;ndice geoespacial representado por el conjunto ordenado en &lt;em&gt;clave&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="38c82e40bf5034793c00ae747edeb8cd30dfe3ef" translate="yes" xml:space="preserve">
          <source>Return the username the current connection is authenticated with. New connections are authenticated with the &quot;default&quot; user. They can change user using &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0492bdeb7afe890056ed3d150bcd3cc644b0be83" translate="yes" xml:space="preserve">
          <source>Return valid &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; strings representing the position of one or more elements in a sorted set value representing a geospatial index (where elements were added using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;).</source>
          <target state="translated">Devuelve cadenas de &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; v&amp;aacute;lidas que representan la posici&amp;oacute;n de uno o m&amp;aacute;s elementos en un valor de conjunto ordenado que representa un &amp;iacute;ndice geoespacial (donde los elementos se agregaron usando &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">Valor de retorno</target>
        </trans-unit>
        <trans-unit id="864674bcd0783b3457690f475310b938e42a7db7" translate="yes" xml:space="preserve">
          <source>Returning a maximum number of entries</source>
          <target state="translated">Devolver un número máximo de entradas</target>
        </trans-unit>
        <trans-unit id="8f278b9f0e4f851622b8ed184503714c9eb2b40b" translate="yes" xml:space="preserve">
          <source>Returning items in a specific time range. This is possible because Stream IDs are &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;related to time&lt;/a&gt;.</source>
          <target state="translated">Devoluci&amp;oacute;n de art&amp;iacute;culos en un intervalo de tiempo espec&amp;iacute;fico. Esto es posible porque las ID de transmisi&amp;oacute;n est&amp;aacute;n &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;relacionadas con el tiempo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fecab38b77030a1f63f2810d6747aa68c069f23" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about all Redis commands.</source>
          <target state="translated">Devuelve la &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;respuesta&lt;/a&gt; de matriz de detalles sobre todos los comandos de Redis.</target>
        </trans-unit>
        <trans-unit id="fc344310aece8efa4afcb637dd3fdf8dc24fa45b" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about multiple Redis commands.</source>
          <target state="translated">Devuelve la &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;respuesta&lt;/a&gt; de matriz de detalles sobre varios comandos de Redis.</target>
        </trans-unit>
        <trans-unit id="4a134a2f3cf379373d004a605091cb6cf69dedcb" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of keys from a full Redis command.</source>
          <target state="translated">Devuelve la &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;respuesta&lt;/a&gt; de matriz de claves de un comando completo de Redis.</target>
        </trans-unit>
        <trans-unit id="bce4982fceed9f9a0c759decc9c92ecb37cc9be2" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; of number of total commands in this Redis server.</source>
          <target state="translated">Devuelve la &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;respuesta entera&lt;/a&gt; del n&amp;uacute;mero total de comandos en este servidor Redis.</target>
        </trans-unit>
        <trans-unit id="a915d042e7bc17cfcfeeccbd870dfc5af9c1ca16" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;PONG&lt;/code&gt; if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to test if a connection is still alive, or to measure latency.</source>
          <target state="translated">Devuelve &lt;code&gt;PONG&lt;/code&gt; si no se proporciona ning&amp;uacute;n argumento; de lo contrario, devuelve una copia del argumento en bloque. Este comando se usa a menudo para probar si una conexi&amp;oacute;n a&amp;uacute;n est&amp;aacute; viva o para medir la latencia.</target>
        </trans-unit>
        <trans-unit id="dd1b58db010b114867573670782f464e9b034412" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">Devuelve el &lt;code&gt;message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8491e8a1858fe4a13538635b038fd1bb846df79" translate="yes" xml:space="preserve">
          <source>Returns all field names in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve todos los nombres de campo en el hash almacenado en &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="514836e0465ae87a7f738140eb4e2b3ae4475e1f" translate="yes" xml:space="preserve">
          <source>Returns all fields and values of the hash stored at &lt;code&gt;key&lt;/code&gt;. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash.</source>
          <target state="translated">Devuelve todos los campos y valores del hash almacenados en la &lt;code&gt;key&lt;/code&gt; . En el valor devuelto, cada nombre de campo va seguido de su valor, por lo que la longitud de la respuesta es el doble del tama&amp;ntilde;o del hash.</target>
        </trans-unit>
        <trans-unit id="e9924b464875fe91e2b89cf6f97649ff9ec1b5ce" translate="yes" xml:space="preserve">
          <source>Returns all keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">Devuelve todas las claves que coinciden con el &lt;code&gt;pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ceba3296cc87483f6becfe1cdae897e811a1b1e" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; (including elements with score equal to &lt;code&gt;max&lt;/code&gt; or &lt;code&gt;min&lt;/code&gt;). In contrary to the default ordering of sorted sets, for this command the elements are considered to be ordered from high to low scores.</source>
          <target state="translated">Devuelve todos los elementos del conjunto ordenado en &lt;code&gt;key&lt;/code&gt; con una puntuaci&amp;oacute;n entre &lt;code&gt;max&lt;/code&gt; Y &lt;code&gt;min&lt;/code&gt; (Incluidos los elementos con puntuaci&amp;oacute;n igual a &lt;code&gt;max&lt;/code&gt; O &lt;code&gt;min&lt;/code&gt; .). A diferencia del orden predeterminado de conjuntos ordenados, para este comando los elementos se consideran ordenados de puntajes altos a bajos.</target>
        </trans-unit>
        <trans-unit id="6def9bec387c3e744963c6ac4b0bf7f4010504e6" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (including elements with score equal to &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt;). The elements are considered to be ordered from low to high scores.</source>
          <target state="translated">Devuelve todos los elementos del conjunto ordenado en &lt;code&gt;key&lt;/code&gt; con una puntuaci&amp;oacute;n entre &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; (incluidos los elementos con puntuaci&amp;oacute;n igual a &lt;code&gt;min&lt;/code&gt; o &lt;code&gt;max&lt;/code&gt; ). Se considera que los elementos est&amp;aacute;n ordenados de puntajes bajos a altos.</target>
        </trans-unit>
        <trans-unit id="1925ffaf420a57d589c1888eb5b09007e4f1d203" translate="yes" xml:space="preserve">
          <source>Returns all the members of the set value stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve todos los miembros del valor establecido almacenados en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c11f5fe0471c6d472d362d6dbbf041c048b49125" translate="yes" xml:space="preserve">
          <source>Returns all values in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve todos los valores del hash almacenados en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4792ce321c7a364f3dc2071cf137fcc522daf25d" translate="yes" xml:space="preserve">
          <source>Returns an integer identifying the hash slot the specified key hashes to. This command is mainly useful for debugging and testing, since it exposes via an API the underlying Redis implementation of the hashing algorithm. Example use cases for this command:</source>
          <target state="translated">Devuelve un número entero que identifica la ranura de la llave especificada.Este comando es principalmente útil para la depuración y las pruebas,ya que expone a través de una API la implementación de Redis subyacente del algoritmo de hash.Ejemplos de casos de uso de este comando:</target>
        </trans-unit>
        <trans-unit id="899ca03feedce83f7aa728b87a784b60bd95adf0" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;field&lt;/code&gt; is an existing field in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve si el &lt;code&gt;field&lt;/code&gt; es un campo existente en el hash almacenado en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e13b7a867bbaf0e4121d5da403d54edbe4a8b1f" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;key&lt;/code&gt; exists.</source>
          <target state="translated">Devuelve si existe la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="163373a24e8be296b7e7c88d0c4da2f59ceca677" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve si el &lt;code&gt;member&lt;/code&gt; es un miembro del conjunto almacenado en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abd92cbd9d7d0b6e4392a36873fd8c21767b398a" translate="yes" xml:space="preserve">
          <source>Returns information about the existence of the scripts in the script cache.</source>
          <target state="translated">Devuelve la información sobre la existencia de los scripts en la caché de scripts.</target>
        </trans-unit>
        <trans-unit id="820ae40f339c061fc09ac87d928788d5e7ea006a" translate="yes" xml:space="preserve">
          <source>Returns information about the modules loaded to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13855077d7cb93a1fce1c3432c59e7e463ea29a6" translate="yes" xml:space="preserve">
          <source>Returns or stores the elements contained in the &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;list&lt;/a&gt;, &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;set&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted set&lt;/a&gt; at &lt;code&gt;key&lt;/code&gt;. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. This is &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; in its simplest form:</source>
          <target state="translated">Devuelve o almacena los elementos contenidos en la &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;lista&lt;/a&gt; , &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;conjunto&lt;/a&gt; o &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;conjunto ordenado&lt;/a&gt; en &lt;code&gt;key&lt;/code&gt; . De forma predeterminada, la clasificaci&amp;oacute;n es num&amp;eacute;rica y los elementos se comparan por su valor interpretado como un n&amp;uacute;mero de punto flotante de doble precisi&amp;oacute;n. Esto es &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; en su forma m&amp;aacute;s simple:</target>
        </trans-unit>
        <trans-unit id="f68574957008d127438140f50ac56b278260cf09" translate="yes" xml:space="preserve">
          <source>Returns the bit value at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">Devuelve el valor del bit en el &lt;em&gt;desplazamiento&lt;/em&gt; en el valor de cadena almacenado en la &lt;em&gt;clave&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e6d63c7c2388918da907438c78c891dff4a16999" translate="yes" xml:space="preserve">
          <source>Returns the element at index &lt;code&gt;index&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt;. The index is zero-based, so &lt;code&gt;0&lt;/code&gt; means the first element, &lt;code&gt;1&lt;/code&gt; the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, &lt;code&gt;-1&lt;/code&gt; means the last element, &lt;code&gt;-2&lt;/code&gt; means the penultimate and so forth.</source>
          <target state="translated">Devuelve el elemento en el &amp;iacute;ndice &lt;code&gt;index&lt;/code&gt; en la lista almacenada en &lt;code&gt;key&lt;/code&gt; . El &amp;iacute;ndice es de base cero, por lo que &lt;code&gt;0&lt;/code&gt; significa el primer elemento, &lt;code&gt;1&lt;/code&gt; el segundo elemento y as&amp;iacute; sucesivamente. Se pueden usar &amp;iacute;ndices negativos para designar elementos que comienzan en la cola de la lista. Aqu&amp;iacute;, &lt;code&gt;-1&lt;/code&gt; significa el &amp;uacute;ltimo elemento, &lt;code&gt;-2&lt;/code&gt; significa el pen&amp;uacute;ltimo y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="669652a24b746680e968eb8d19e304712aaafbef" translate="yes" xml:space="preserve">
          <source>Returns the length of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is interpreted as an empty list and &lt;code&gt;0&lt;/code&gt; is returned. An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a list.</source>
          <target state="translated">Devuelve la longitud de la lista almacenada en la &lt;code&gt;key&lt;/code&gt; . Si la &lt;code&gt;key&lt;/code&gt; no existe, se interpreta como una lista vac&amp;iacute;a y se devuelve &lt;code&gt;0&lt;/code&gt; . Se devuelve un error cuando el valor almacenado en la &lt;code&gt;key&lt;/code&gt; no es una lista.</target>
        </trans-unit>
        <trans-unit id="b1b9de7b079dd5e1ad7bef3504c123ad01db9ecc" translate="yes" xml:space="preserve">
          <source>Returns the length of the string value stored at &lt;code&gt;key&lt;/code&gt;. An error is returned when &lt;code&gt;key&lt;/code&gt; holds a non-string value.</source>
          <target state="translated">Devuelve la longitud del valor de cadena almacenado en la &lt;code&gt;key&lt;/code&gt; . Se devuelve un error cuando la &lt;code&gt;key&lt;/code&gt; contiene un valor que no es una cadena.</target>
        </trans-unit>
        <trans-unit id="5ca8167d0a845062b5e1c8307dc022d4e1bbe99c" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the difference between the first set and all the successive sets.</source>
          <target state="translated">Devuelve los miembros del conjunto resultante de la diferencia entre el primer conjunto y todos los sucesivos.</target>
        </trans-unit>
        <trans-unit id="65286cf35136f5258861b04a7983164ea5b463a3" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the intersection of all the given sets.</source>
          <target state="translated">Devuelve los miembros del conjunto resultante de la intersección de todos los conjuntos dados.</target>
        </trans-unit>
        <trans-unit id="473b41ab8be68badcb9ee743f59ebda61ccb6efd" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the union of all the given sets.</source>
          <target state="translated">Devuelve los miembros del conjunto resultante de la unión de todos los conjuntos dados.</target>
        </trans-unit>
        <trans-unit id="5f50e5f3ee257d3917e04c66ed0f097e9a6cbcd0" translate="yes" xml:space="preserve">
          <source>Returns the node's id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae58574da7b69acb45d5608e905fbe416f5828a3" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">Devuelve el n&amp;uacute;mero de elementos del conjunto ordenado en &lt;code&gt;key&lt;/code&gt; con una puntuaci&amp;oacute;n entre &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ba5a6e2cdf681a72b81189fc73dab62a38a2630" translate="yes" xml:space="preserve">
          <source>Returns the number of entries inside a stream. If the specified key does not exist the command returns zero, as if the stream was empty. However note that unlike other Redis types, zero-length streams are possible, so you should call &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; or &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; in order to check if a key exists or not.</source>
          <target state="translated">Devuelve el n&amp;uacute;mero de entradas dentro de una secuencia. Si la clave especificada no existe, el comando devuelve cero, como si la secuencia estuviera vac&amp;iacute;a. Sin embargo, tenga en cuenta que, a diferencia de otros tipos de Redis, las transmisiones de longitud cero son posibles, por lo que debe llamar a &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; o &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; para verificar si existe una clave o no.</target>
        </trans-unit>
        <trans-unit id="05ec2c01f1e7966c86d566259fe9827a1ce5788e" translate="yes" xml:space="preserve">
          <source>Returns the number of fields contained in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve el n&amp;uacute;mero de campos contenidos en el hash almacenado en &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba9b6e741951a2ea3575443214cf403c194bc0f" translate="yes" xml:space="preserve">
          <source>Returns the number of keys in the specified Redis Cluster hash slot. The command only queries the local data set, so contacting a node that is not serving the specified hash slot will always result in a count of zero being returned.</source>
          <target state="translated">Devuelve el número de llaves en la ranura de hash del Cúmulo Redis especificado.El comando sólo consulta el conjunto de datos locales,por lo que al contactar con un nodo que no está sirviendo el espacio de hash especificado siempre se devolverá un recuento de cero.</target>
        </trans-unit>
        <trans-unit id="567352a29cfaef33a8cd3fcbcac829c78575fb62" translate="yes" xml:space="preserve">
          <source>Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.</source>
          <target state="translated">Devuelve el número de suscriptores (sin contar los clientes suscritos a las pautas)de los canales especificados.</target>
        </trans-unit>
        <trans-unit id="56eb7af42eb7b4bb5b7efb363837228225fedb8e" translate="yes" xml:space="preserve">
          <source>Returns the number of subscriptions to patterns (that are performed using the &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; command). Note that this is not just the count of clients subscribed to patterns but the total number of patterns all the clients are subscribed to.</source>
          <target state="translated">Devuelve el n&amp;uacute;mero de suscripciones a patrones (que se realizan mediante el comando &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; ). Tenga en cuenta que este no es solo el recuento de clientes suscritos a patrones, sino el n&amp;uacute;mero total de patrones a los que est&amp;aacute;n suscritos todos los clientes.</target>
        </trans-unit>
        <trans-unit id="029e626a83e98d1ddd2b45f2a08391faf674382c" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from high to low. The rank (or index) is 0-based, which means that the member with the highest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Devuelve el rango de &lt;code&gt;member&lt;/code&gt; en el conjunto ordenado almacenado en &lt;code&gt;key&lt;/code&gt; , con las puntuaciones ordenadas de mayor a menor. El rango (o &amp;iacute;ndice) se basa en 0, lo que significa que el miembro con la puntuaci&amp;oacute;n m&amp;aacute;s alta tiene el rango &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04ac6b8e04ac2d5fa91a42abbe270ab24969dcf8" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Devuelve el rango del &lt;code&gt;member&lt;/code&gt; en el conjunto ordenado almacenado en &lt;code&gt;key&lt;/code&gt; , con las puntuaciones ordenadas de menor a mayor. El rango (o &amp;iacute;ndice) se basa en 0, lo que significa que el miembro con la puntuaci&amp;oacute;n m&amp;aacute;s baja tiene el rango &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dac65708cc841972517b49f4a323aba557dd7743" translate="yes" xml:space="preserve">
          <source>Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.</source>
          <target state="translated">Devuelve el tiempo restante de vida de una llave que tiene un tiempo de espera.Esta capacidad de introspección permite a un cliente de Redis comprobar cuántos segundos una clave determinada seguirá formando parte del conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="bdaf416765952fb3c543f080075ad7115471f130" translate="yes" xml:space="preserve">
          <source>Returns the score of &lt;code&gt;member&lt;/code&gt; in the sorted set at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve la puntuaci&amp;oacute;n del &lt;code&gt;member&lt;/code&gt; en el conjunto ordenado en &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bb764cd364e3749541c7692eea4d198b1e88fce" translate="yes" xml:space="preserve">
          <source>Returns the scores associated with the specified &lt;code&gt;members&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0525192497ba351f01f7c69505a721186043f122" translate="yes" xml:space="preserve">
          <source>Returns the set cardinality (number of elements) of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve la cardinalidad del conjunto (n&amp;uacute;mero de elementos) del conjunto almacenado en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="538e8ccb043255bf1866a8c948a35b08642708eb" translate="yes" xml:space="preserve">
          <source>Returns the sorted set cardinality (number of elements) of the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve la cardinalidad del conjunto ordenado (n&amp;uacute;mero de elementos) del conjunto ordenado almacenado en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aed5ad61cf2dae51ecb526ffeb96e8ae6f66dd61" translate="yes" xml:space="preserve">
          <source>Returns the specified elements of the list stored at &lt;code&gt;key&lt;/code&gt;. The offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, with &lt;code&gt;0&lt;/code&gt; being the first element of the list (the head of the list), &lt;code&gt;1&lt;/code&gt; being the next element and so on.</source>
          <target state="translated">Devuelve los elementos especificados de la lista almacenados en &lt;code&gt;key&lt;/code&gt; . Las compensaciones de &lt;code&gt;start&lt;/code&gt; y &lt;code&gt;stop&lt;/code&gt; son &amp;iacute;ndices de base cero, siendo &lt;code&gt;0&lt;/code&gt; el primer elemento de la lista (el encabezado de la lista), &lt;code&gt;1&lt;/code&gt; el siguiente elemento y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="165e254b16f95c82b554bb625de96b2c2d45635e" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the highest to the lowest score. Descending lexicographical order is used for elements with equal score.</source>
          <target state="translated">Devuelve el rango especificado de elementos en el conjunto ordenado almacenado en &lt;code&gt;key&lt;/code&gt; . Se considera que los elementos est&amp;aacute;n ordenados de mayor a menor puntuaci&amp;oacute;n. El orden lexicogr&amp;aacute;fico descendente se utiliza para elementos con igual puntuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c5f3848ec567b8c9da3f19a86ff736fd69145ae8" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.</source>
          <target state="translated">Devuelve el rango especificado de elementos en el conjunto ordenado almacenado en &lt;code&gt;key&lt;/code&gt; . Se considera que los elementos est&amp;aacute;n ordenados de menor a mayor puntuaci&amp;oacute;n. El orden lexicogr&amp;aacute;fico se utiliza para elementos con igual puntuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d28b315a7a61b9bf04b21fccdd6ae5bd4f8eb130" translate="yes" xml:space="preserve">
          <source>Returns the string length of the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;. If the &lt;code&gt;key&lt;/code&gt; or the &lt;code&gt;field&lt;/code&gt; do not exist, 0 is returned.</source>
          <target state="translated">Devuelve la longitud de la cadena del valor asociado con el &lt;code&gt;field&lt;/code&gt; en el hash almacenado en la &lt;code&gt;key&lt;/code&gt; . Si la &lt;code&gt;key&lt;/code&gt; o el &lt;code&gt;field&lt;/code&gt; no existen, se devuelve 0.</target>
        </trans-unit>
        <trans-unit id="ffb4e3b3a6a5708cfdef83bd04363741160ed0a4" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt; and &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">Devuelve la representaci&amp;oacute;n de cadena del tipo de valor almacenado en &lt;code&gt;key&lt;/code&gt; . Los diferentes tipos que se pueden devolver son: &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; a , &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;zset&lt;/code&gt; y &lt;code&gt;hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9feb2d475967dd13f03c72121d597fd1520318c" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a246620818088ec9a16f70b9fb4ae809aad9ad2" translate="yes" xml:space="preserve">
          <source>Returns the substring of the string value stored at &lt;code&gt;key&lt;/code&gt;, determined by the offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth.</source>
          <target state="translated">Devuelve la subcadena del valor de la cadena almacenada en la &lt;code&gt;key&lt;/code&gt; , determinada por el &lt;code&gt;start&lt;/code&gt; y el &lt;code&gt;end&lt;/code&gt; las compensaciones (ambos son incluidos). Se pueden usar compensaciones negativas para proporcionar una compensaci&amp;oacute;n comenzando desde el final de la cadena. Entonces -1 significa el &amp;uacute;ltimo car&amp;aacute;cter, -2 el pen&amp;uacute;ltimo y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="ff8cb8f9712a465de8610b460278556869c01387" translate="yes" xml:space="preserve">
          <source>Returns the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve el valor asociado con el &lt;code&gt;field&lt;/code&gt; en el hash almacenado en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e8fea73a6efe9b1e714890adedb119e477e5b94" translate="yes" xml:space="preserve">
          <source>Returns the values associated with the specified &lt;code&gt;fields&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Devuelve los valores asociados con los &lt;code&gt;fields&lt;/code&gt; especificados en el hash almacenado en la &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a3f6c24ab0b5bf50119e41442adccdd069520b2" translate="yes" xml:space="preserve">
          <source>Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value &lt;code&gt;nil&lt;/code&gt; is returned. Because of this, the operation never fails.</source>
          <target state="translated">Devuelve los valores de todas las claves especificadas. Por cada llave que no posea un valor de cadena o no existe, el valor especial &lt;code&gt;nil&lt;/code&gt; se devuelve. Por eso, la operaci&amp;oacute;n nunca falla.</target>
        </trans-unit>
        <trans-unit id="0b14b8f8217819a1f6163396383d48d4cd2d94d9" translate="yes" xml:space="preserve">
          <source>Returns whether each &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fe03995fd835515d8b0c378391e0d80d6d96a2" translate="yes" xml:space="preserve">
          <source>Running the bitmap incrementally using the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;&lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; optional parameters, accumulating the results client-side, and optionally caching the result into a key.</source>
          <target state="translated">Ejecutar el mapa de bits de forma incremental utilizando los par&amp;aacute;metros opcionales &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT &lt;/a&gt;&lt;em&gt;start&lt;/em&gt; y &lt;em&gt;end&lt;/em&gt; , acumulando los resultados del lado del cliente y, opcionalmente, almacenando en cach&amp;eacute; el resultado en una clave.</target>
        </trans-unit>
        <trans-unit id="afc896d0c818d9d81d1502addeeed94d978515cb" translate="yes" xml:space="preserve">
          <source>SADD</source>
          <target state="translated">SADD</target>
        </trans-unit>
        <trans-unit id="afe4d83e232611365cc3a02706eeee448267b671" translate="yes" xml:space="preserve">
          <source>SADD  key member [member ...]   Add one or more members to a set</source>
          <target state="translated">SADD miembro clave [miembro ...]Añadir uno o más miembros a un conjunto</target>
        </trans-unit>
        <trans-unit id="508156a39b09ccfe61cc81d984e9317e5e0d8eec" translate="yes" xml:space="preserve">
          <source>SAVE</source>
          <target state="translated">SAVE</target>
        </trans-unit>
        <trans-unit id="a806788f2be230df4e533ace9d23ff41f5ebd919" translate="yes" xml:space="preserve">
          <source>SAVE   Synchronously save the dataset to disk</source>
          <target state="translated">GUARDAR Sincronizadamente guardar el conjunto de datos en el disco</target>
        </trans-unit>
        <trans-unit id="65b4fd3a026ef6fa00d5747035f289ef54695f24" translate="yes" xml:space="preserve">
          <source>SAVE and NOSAVE modifiers</source>
          <target state="translated">Modificadores SAVE y NOSAVE</target>
        </trans-unit>
        <trans-unit id="c5a19955ea5dab3fd18ab68f367f98693df1b60b" translate="yes" xml:space="preserve">
          <source>SCAN</source>
          <target state="translated">SCAN</target>
        </trans-unit>
        <trans-unit id="f6a353aff0f0da25a0e7f7c1d96621ee0a75fe99" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count]   Incrementally iterate the keys space</source>
          <target state="translated">ESCANEAR el cursor [patrón de coincidencia][recuento de recuento]Incrementar el espacio de las teclas</target>
        </trans-unit>
        <trans-unit id="72556acd6ec7fd4188e74406d411c51d45f1c442" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count] [TYPE type]   Incrementally iterate the keys space</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f904e681db7d6de1d40ec70145524cd0367d1bf0" translate="yes" xml:space="preserve">
          <source>SCAN basic usage</source>
          <target state="translated">SCAN uso básico</target>
        </trans-unit>
        <trans-unit id="aa3b23325236e95772d7cd2d8a5db2f2530e669f" translate="yes" xml:space="preserve">
          <source>SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call.</source>
          <target state="translated">SCAN es un iterador basado en un cursor.Esto significa que en cada llamada del comando,el servidor devuelve un cursor actualizado que el usuario debe usar como argumento del cursor en la siguiente llamada.</target>
        </trans-unit>
        <trans-unit id="0431790b7b638b530f089a6638b4b046bf245d05" translate="yes" xml:space="preserve">
          <source>SCARD</source>
          <target state="translated">SCARD</target>
        </trans-unit>
        <trans-unit id="45b0af77625a8e40fbd9c79a72bf85a01a682a2e" translate="yes" xml:space="preserve">
          <source>SCARD  key   Get the number of members in a set</source>
          <target state="translated">Clave SCARD Obtener el número de miembros en un conjunto</target>
        </trans-unit>
        <trans-unit id="46ab5a918078b88865c34d46d45763f78a5cc2a8" translate="yes" xml:space="preserve">
          <source>SCRIPT</source>
          <target state="translated">SCRIPT</target>
        </trans-unit>
        <trans-unit id="942ec0d4567f537a05d81b40e79ed670c8098df1" translate="yes" xml:space="preserve">
          <source>SCRIPT DEBUG  YES|SYNC|NO   Set the debug mode for executed scripts.</source>
          <target state="translated">SCRIPT DEBUG YES|SYNC|NO Establecer el modo de depuración para los guiones ejecutados.</target>
        </trans-unit>
        <trans-unit id="d4f0300810cbd56a02078e94b26444e04a369df1" translate="yes" xml:space="preserve">
          <source>SCRIPT EXISTS  sha1 [sha1 ...]   Check existence of scripts in the script cache.</source>
          <target state="translated">SCRIPT EXISTS sha1 [sha1 ...]Comprueba la existencia de scripts en la caché de scripts.</target>
        </trans-unit>
        <trans-unit id="155351693709972a944322985f623357a60203d8" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH</source>
          <target state="translated">SCRIPT FLUSH</target>
        </trans-unit>
        <trans-unit id="ff5ac14542c8a5c4ff717c937c92483157332c48" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH   Remove all the scripts from the script cache.</source>
          <target state="translated">SCRIPT FLUSH Elimina todos los scripts de la caché de scripts.</target>
        </trans-unit>
        <trans-unit id="5e2a68acdd358effce354e479fe828441291386c" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL</source>
          <target state="translated">SCRIPT KILL</target>
        </trans-unit>
        <trans-unit id="898216faf82d0e8094a40fff1a1d11316572b3a1" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL   Kill the script currently in execution.</source>
          <target state="translated">SCRIPT KILL Mata el guión actualmente en ejecución.</target>
        </trans-unit>
        <trans-unit id="bf00a0ed4afe21cec9ac5006aa471a2c75ce80dd" translate="yes" xml:space="preserve">
          <source>SCRIPT LOAD  script   Load the specified Lua script into the script cache.</source>
          <target state="translated">CARGA DE SCRIPTOS Script Carga el script Lua especificado en el caché de scripts.</target>
        </trans-unit>
        <trans-unit id="605e7c9dd422426230eae60c02acc7d7a5705884" translate="yes" xml:space="preserve">
          <source>SDIFF</source>
          <target state="translated">SDIFF</target>
        </trans-unit>
        <trans-unit id="18d8e0e316b86cf9a259f83877f9d4536e919048" translate="yes" xml:space="preserve">
          <source>SDIFF  key [key ...]   Subtract multiple sets</source>
          <target state="translated">Tecla SDIFF [tecla ...]Restar varios conjuntos</target>
        </trans-unit>
        <trans-unit id="144b2bd3509fd63bb1b369b8c7665713eb587bd9" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE</source>
          <target state="translated">SDIFFSTORE</target>
        </trans-unit>
        <trans-unit id="de1820fefd3db78a9062bc31ca0bace599879b7b" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE  destination key [key ...]   Subtract multiple sets and store the resulting set in a key</source>
          <target state="translated">Tecla de destino SDIFFSTORE [tecla ...]Reste varios conjuntos y guarde el conjunto resultante en una tecla</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="f439068c5eb4482362ce42c7382665b32a13512a" translate="yes" xml:space="preserve">
          <source>SELECT  index   Change the selected database for the current connection</source>
          <target state="translated">SELECT index Cambiar la base de datos seleccionada para la conexión actual</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="b2f1db45c77eaf2c94d566bc200555c564e53670" translate="yes" xml:space="preserve">
          <source>SET  key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX] [GET]   Set the string value of a key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a720b839d692fc7a7e17565ac1e4963650fe98" translate="yes" xml:space="preserve">
          <source>SET  key value [expiration EX seconds|PX milliseconds] [NX|XX]   Set the string value of a key</source>
          <target state="translated">Valor de la tecla SET [expiración EX segundos|PX milisegundos][NX|XX]Establecer el valor de la cadena de una tecla</target>
        </trans-unit>
        <trans-unit id="7df70cb863a3d3a5e4a199b5d8ef3c9851ce87bf" translate="yes" xml:space="preserve">
          <source>SETBIT</source>
          <target state="translated">SETBIT</target>
        </trans-unit>
        <trans-unit id="b66f69a03f672489d4ae1d69a757435c5b63bd51" translate="yes" xml:space="preserve">
          <source>SETBIT  key offset value   Sets or clears the bit at offset in the string value stored at key</source>
          <target state="translated">Valor de offset de la tecla SETBIT Establece o borra el bit en offset en el valor de la cadena almacenado en la tecla</target>
        </trans-unit>
        <trans-unit id="c92872db8021ac60dd456ca7447fb52919f32143" translate="yes" xml:space="preserve">
          <source>SETEX</source>
          <target state="translated">SETEX</target>
        </trans-unit>
        <trans-unit id="0b5df1d3ddffe0fdbb568accc5d3c3dac5121afc" translate="yes" xml:space="preserve">
          <source>SETEX  key seconds value   Set the value and expiration of a key</source>
          <target state="translated">Valor de los segundos de la tecla SETEX Ajustar el valor y la caducidad de una tecla</target>
        </trans-unit>
        <trans-unit id="1ace6531f1c27b916c1368f17e1a7ae87aa79f97" translate="yes" xml:space="preserve">
          <source>SETNX</source>
          <target state="translated">SETNX</target>
        </trans-unit>
        <trans-unit id="a50f293fa49f962b5d82c0bb86c82df413a498b7" translate="yes" xml:space="preserve">
          <source>SETNX  key value   Set the value of a key, only if the key does not exist</source>
          <target state="translated">Valor de la llave SETNX Establecer el valor de una llave,sólo si la llave no existe</target>
        </trans-unit>
        <trans-unit id="c1d82383232438676e2182b69bf2797640b1fcd2" translate="yes" xml:space="preserve">
          <source>SETRANGE</source>
          <target state="translated">SETRANGE</target>
        </trans-unit>
        <trans-unit id="a2132f99e69e7919051651c2b4fc7de24734eba2" translate="yes" xml:space="preserve">
          <source>SETRANGE  key offset value   Overwrite part of a string at key starting at the specified offset</source>
          <target state="translated">Valor de offset de la clave SETRANGE Sobrescribir parte de una cadena en la clave a partir del offset especificado</target>
        </trans-unit>
        <trans-unit id="ec493147ec1b78adab002626ee80cc23772aded8" translate="yes" xml:space="preserve">
          <source>SHUTDOWN</source>
          <target state="translated">SHUTDOWN</target>
        </trans-unit>
        <trans-unit id="606e1ec5d1ea13b283de4e59cd16289518254c6c" translate="yes" xml:space="preserve">
          <source>SHUTDOWN  [NOSAVE|SAVE]   Synchronously save the dataset to disk and then shut down the server</source>
          <target state="translated">SHUTDOWN [NOSAVE|SAVE]Guarda sincronizadamente el conjunto de datos en el disco y luego apaga el servidor</target>
        </trans-unit>
        <trans-unit id="c340be94a16bd060ccd24ece053ed10ff4cfb1a2" translate="yes" xml:space="preserve">
          <source>SINTER</source>
          <target state="translated">SINTER</target>
        </trans-unit>
        <trans-unit id="acc6f9a5a6867145ccd5835b170277c3127f8f60" translate="yes" xml:space="preserve">
          <source>SINTER  key [key ...]   Intersect multiple sets</source>
          <target state="translated">Tecla SINTER [tecla ...]Intersecta múltiples conjuntos</target>
        </trans-unit>
        <trans-unit id="ae286ac2efddc7ffc6de81fb4eef82083c5d0d0a" translate="yes" xml:space="preserve">
          <source>SINTERSTORE</source>
          <target state="translated">SINTERSTORE</target>
        </trans-unit>
        <trans-unit id="3cc889bdb24445318099b6bfa98a849204bc5321" translate="yes" xml:space="preserve">
          <source>SINTERSTORE  destination key [key ...]   Intersect multiple sets and store the resulting set in a key</source>
          <target state="translated">Tecla de destino SINTERSTORE [tecla ...]Intersecta múltiples conjuntos y almacena el conjunto resultante en una tecla</target>
        </trans-unit>
        <trans-unit id="8074903f43c428dec41033b139437bb9d7e46e61" translate="yes" xml:space="preserve">
          <source>SISMEMBER</source>
          <target state="translated">SISMEMBER</target>
        </trans-unit>
        <trans-unit id="2613d73d648b1f6845f55faac8664acb5e2e9af6" translate="yes" xml:space="preserve">
          <source>SISMEMBER  key member   Determine if a given value is a member of a set</source>
          <target state="translated">Miembro clave de SISMEMBER Determinar si un valor dado es miembro de un conjunto</target>
        </trans-unit>
        <trans-unit id="bb3731aa645af4f77072e934700ff033a81e173b" translate="yes" xml:space="preserve">
          <source>SLAVEOF</source>
          <target state="translated">SLAVEOF</target>
        </trans-unit>
        <trans-unit id="9bb4401fd3b09a14ad63da1fc4e0ebcc9c0ee189" translate="yes" xml:space="preserve">
          <source>SLAVEOF  host port   Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.</source>
          <target state="translated">Puerto de host SLAVEOF Hacer que el servidor sea una réplica de otra instancia,o promocionarlo como maestro.Desaprobado a partir de Redis 5.Use REPLICAOF en su lugar.</target>
        </trans-unit>
        <trans-unit id="4078b703021998b0c963d9636d85d96b1ddfa618" translate="yes" xml:space="preserve">
          <source>SLOWLOG</source>
          <target state="translated">SLOWLOG</target>
        </trans-unit>
        <trans-unit id="acfcd934ccfd2203f5ccc3e824371c24109642b8" translate="yes" xml:space="preserve">
          <source>SLOWLOG  subcommand [argument]   Manages the Redis slow queries log</source>
          <target state="translated">El subcomando SLOWLOG [argumento]administra el registro de consultas lentas de Redis</target>
        </trans-unit>
        <trans-unit id="e6687e28d8b75312f0ea51bc9520b394ec2a7a63" translate="yes" xml:space="preserve">
          <source>SMEMBERS</source>
          <target state="translated">SMEMBERS</target>
        </trans-unit>
        <trans-unit id="fe66421f332187f83010e275c4b51042858f5234" translate="yes" xml:space="preserve">
          <source>SMEMBERS  key   Get all the members in a set</source>
          <target state="translated">Llave de los miembros Consigue todos los miembros en un conjunto</target>
        </trans-unit>
        <trans-unit id="3a5a30822e064f7dd03cefac6d437e4654f3aca9" translate="yes" xml:space="preserve">
          <source>SMISMEMBER</source>
          <target state="translated">SMISMEMBER</target>
        </trans-unit>
        <trans-unit id="aaa0292e655dd3747fc97cd25825a806d4aa708b" translate="yes" xml:space="preserve">
          <source>SMISMEMBER  key member [member ...]   Returns the membership associated with the given elements for a set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f84dbd21a3d84899dade0a24ef5c6978f0403e" translate="yes" xml:space="preserve">
          <source>SMOVE</source>
          <target state="translated">SMOVE</target>
        </trans-unit>
        <trans-unit id="1f7888e464279456fc99ea1259b436e9ad0d4f64" translate="yes" xml:space="preserve">
          <source>SMOVE  source destination member   Move a member from one set to another</source>
          <target state="translated">SMOVE origen destino miembro Mover un miembro de un conjunto a otro</target>
        </trans-unit>
        <trans-unit id="2434fe1de87e4949f51786cc87dd6a83c095a422" translate="yes" xml:space="preserve">
          <source>SORT</source>
          <target state="translated">SORT</target>
        </trans-unit>
        <trans-unit id="8e248ec645f54a08b3eb01462adb200f94f15d79" translate="yes" xml:space="preserve">
          <source>SORT  key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]   Sort the elements in a list, set or sorted set</source>
          <target state="translated">Tecla SORT [POR patrón][LIMITAR la cuenta de compensación][OBTENER patrón [OBTENER patrón ...]][ASC|DESC][ALFA][ALMACENAR destino]Ordenar los elementos de una lista,conjunto o conjunto ordenado</target>
        </trans-unit>
        <trans-unit id="757f5e1ed1192585c3e7deb4986d7e204a0c8613" translate="yes" xml:space="preserve">
          <source>SPOP</source>
          <target state="translated">SPOP</target>
        </trans-unit>
        <trans-unit id="a1bcd919a884989656266471e065ce0ed9f3b014" translate="yes" xml:space="preserve">
          <source>SPOP  key [count]   Remove and return one or multiple random members from a set</source>
          <target state="translated">Tecla SPOP [recuento]Quitar y devolver uno o varios miembros aleatorios de un conjunto</target>
        </trans-unit>
        <trans-unit id="fa889adf02f632d165c3f2d12d9b5ec8d781cbb2" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER</source>
          <target state="translated">SRANDMEMBER</target>
        </trans-unit>
        <trans-unit id="a3aa05de6787d8cb6b5fb2eeb41ce24756a254c7" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER  key [count]   Get one or multiple random members from a set</source>
          <target state="translated">Clave SRANDMEMBER [recuento]Obtener uno o varios miembros al azar de un conjunto</target>
        </trans-unit>
        <trans-unit id="a25d27e5f9def5c1d9e1a790c413156760a00937" translate="yes" xml:space="preserve">
          <source>SREM</source>
          <target state="translated">SREM</target>
        </trans-unit>
        <trans-unit id="68363946a4081440ca501f29c43f5fbe4f7eefc4" translate="yes" xml:space="preserve">
          <source>SREM  key member [member ...]   Remove one or more members from a set</source>
          <target state="translated">Miembro clave del SREM [miembro...]Quitar uno o más miembros de un conjunto</target>
        </trans-unit>
        <trans-unit id="39f084973b61a7bea28e4e94336a3c5a0bf9fee7" translate="yes" xml:space="preserve">
          <source>SSCAN</source>
          <target state="translated">SSCAN</target>
        </trans-unit>
        <trans-unit id="9c2bba696b7b86cd88c82a287899370d9f0e3bb5" translate="yes" xml:space="preserve">
          <source>SSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate Set elements</source>
          <target state="translated">Cursor de la tecla SSCAN [Patrón de coincidencia][Conteo]Iteración incremental Elementos del conjunto</target>
        </trans-unit>
        <trans-unit id="746fc78a74ffba46a591afc21fe85ad08b00b6da" translate="yes" xml:space="preserve">
          <source>STRALGO</source>
          <target state="translated">STRALGO</target>
        </trans-unit>
        <trans-unit id="3faaaa804aaa356ec8a33bd42d375f1bc189c7e7" translate="yes" xml:space="preserve">
          <source>STRALGO  LCS algo-specific-argument [algo-specific-argument ...]   Run algorithms (currently LCS) against strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89c4cb21a1d403bb307b502f69a87f9e3b3a8ab" translate="yes" xml:space="preserve">
          <source>STRLEN</source>
          <target state="translated">STRLEN</target>
        </trans-unit>
        <trans-unit id="ba1403b52701f08d29eb084587b5d84ec8dde893" translate="yes" xml:space="preserve">
          <source>STRLEN  key   Get the length of the value stored in a key</source>
          <target state="translated">Tecla STRLEN Obtener la longitud del valor almacenado en una tecla</target>
        </trans-unit>
        <trans-unit id="43a6e12318adbbee03f06872c109322b0f558e29" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE</source>
          <target state="translated">SUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="47236795c3b9acd1da0f66ecb88ffdd913189ac5" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE  channel [channel ...]   Listen for messages published to the given channels</source>
          <target state="translated">Canal SUSCRIPCIÓN [canal ...]Escuche los mensajes publicados en los canales dados</target>
        </trans-unit>
        <trans-unit id="a9a4bd3707fb7f204fddf46673a38114093dbb82" translate="yes" xml:space="preserve">
          <source>SUNION</source>
          <target state="translated">SUNION</target>
        </trans-unit>
        <trans-unit id="5b757c33f2f9e74b674645b6ccda3d80138ff877" translate="yes" xml:space="preserve">
          <source>SUNION  key [key ...]   Add multiple sets</source>
          <target state="translated">Tecla SUNION [tecla ...]Añadir varios juegos</target>
        </trans-unit>
        <trans-unit id="48b1035f133322c326cae720a6ee6ad1108226dc" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE</source>
          <target state="translated">SUNIONSTORE</target>
        </trans-unit>
        <trans-unit id="be4a84a92460ba7a99f970a1bd856700c5285869" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE  destination key [key ...]   Add multiple sets and store the resulting set in a key</source>
          <target state="translated">Tecla de destino de SUNIONSTORE [tecla ...]Sume varios conjuntos y guarde el conjunto resultante en una tecla</target>
        </trans-unit>
        <trans-unit id="52e8b5aa51a1b6c9b46c6f4abe8b613e777665e4" translate="yes" xml:space="preserve">
          <source>SWAPDB</source>
          <target state="translated">SWAPDB</target>
        </trans-unit>
        <trans-unit id="b86537c7b961d4302819caedcc63376c729b2e03" translate="yes" xml:space="preserve">
          <source>SWAPDB  index index   Swaps two Redis databases</source>
          <target state="translated">Índice SWAPDB Intercambia dos bases de datos Redis</target>
        </trans-unit>
        <trans-unit id="77754660ca2a32513ded08ad488bd2a9af650258" translate="yes" xml:space="preserve">
          <source>SWAPDB  index1 index2   Swaps two Redis databases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8d236566d2393cd3a112e7190d8837c8004cc2" translate="yes" xml:space="preserve">
          <source>SYNC</source>
          <target state="translated">SYNC</target>
        </trans-unit>
        <trans-unit id="7dade54cfe46a1450fe32e252c2fe2557e402641" translate="yes" xml:space="preserve">
          <source>SYNC   Internal command used for replication</source>
          <target state="translated">SYNC Comando interno usado para la replicación</target>
        </trans-unit>
        <trans-unit id="b54491fb2810da81b1ac818eeb380198be74decd" translate="yes" xml:space="preserve">
          <source>Same result format as &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; except you can specify which commands get returned.</source>
          <target state="translated">El mismo formato de resultado que &lt;a href=&quot;command&quot;&gt;COMMAND,&lt;/a&gt; excepto que puede especificar qu&amp;eacute; comandos se devuelven.</target>
        </trans-unit>
        <trans-unit id="1cc201c6f067fb6b6182b441f2b6dc0f4b71649b" translate="yes" xml:space="preserve">
          <source>Sample Output (new version, includes IDs)</source>
          <target state="translated">Salida de la muestra (nueva versión,incluye identificaciones)</target>
        </trans-unit>
        <trans-unit id="fb0cb1b1aa0fcb98cea480e75b0d7dffc839cef1" translate="yes" xml:space="preserve">
          <source>Sample Output (old version)</source>
          <target state="translated">Salida de la muestra (versión antigua)</target>
        </trans-unit>
        <trans-unit id="7a614be0679e1660abb7ab566a46118d4e5207f9" translate="yes" xml:space="preserve">
          <source>Sandbox and maximum execution time</source>
          <target state="translated">Caja de arena y tiempo máximo de ejecución</target>
        </trans-unit>
        <trans-unit id="c660854037806380c25fadc61428fa995d1aa015" translate="yes" xml:space="preserve">
          <source>Save the DB in background.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444bd4af75b503112dd46c6982e0bae0a08cf7c2" translate="yes" xml:space="preserve">
          <source>Save the DB in background. The OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits. A client may be able to check if the operation succeeded using the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; command.</source>
          <target state="translated">Guarde la base de datos en segundo plano. El c&amp;oacute;digo OK se devuelve inmediatamente. Redis se bifurca, el padre contin&amp;uacute;a sirviendo a los clientes, el hijo guarda la base de datos en el disco y luego sale. Un cliente puede comprobar si la operaci&amp;oacute;n se realiz&amp;oacute; &lt;a href=&quot;lastsave&quot;&gt;correctamente&lt;/a&gt; mediante el comando LASTSAVE .</target>
        </trans-unit>
        <trans-unit id="6e73e4e94939b275e189527f28b962ac1035dc5b" translate="yes" xml:space="preserve">
          <source>Scan guarantees</source>
          <target state="translated">Las garantías de escaneo</target>
        </trans-unit>
        <trans-unit id="983987071368a426b6b0e610cd5b5142cb273380" translate="yes" xml:space="preserve">
          <source>Script cache semantics</source>
          <target state="translated">Semántica de la memoria caché</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">Scripting</target>
        </trans-unit>
        <trans-unit id="745fe7d4baa466214b942befb3f50f3311c89d23" translate="yes" xml:space="preserve">
          <source>Scripts are also subject to a maximum execution time (five seconds by default). This default timeout is huge since a script should usually run in under a millisecond. The limit is mostly to handle accidental infinite loops created during development.</source>
          <target state="translated">Los guiones también están sujetos a un tiempo máximo de ejecución (cinco segundos por defecto).Este tiempo de espera por defecto es enorme,ya que un script debería ejecutarse normalmente en menos de un milisegundo.El límite es sobre todo para manejar los bucles infinitos accidentales creados durante el desarrollo.</target>
        </trans-unit>
        <trans-unit id="aef3e907fc9586fb823b51b6f43074de8b409561" translate="yes" xml:space="preserve">
          <source>Scripts as pure functions</source>
          <target state="translated">Los guiones como funciones puras</target>
        </trans-unit>
        <trans-unit id="18ec3225e4d3fe66e7449672a6973e4c283e8bfa" translate="yes" xml:space="preserve">
          <source>Scripts should never try to access the external system, like the file system or any other system call. A script should only operate on Redis data and passed arguments.</source>
          <target state="translated">Los scripts nunca deben intentar acceder al sistema externo,como el sistema de archivos o cualquier otra llamada del sistema.Un script sólo debe operar con datos de Redis y argumentos pasados.</target>
        </trans-unit>
        <trans-unit id="96faa0a78d5b1890951d8f5b8b1cde571bd90423" translate="yes" xml:space="preserve">
          <source>Second replica</source>
          <target state="translated">Segunda réplica</target>
        </trans-unit>
        <trans-unit id="3eb4e043552c7873cf099793db5b7d1e5db95809" translate="yes" xml:space="preserve">
          <source>Security notice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a6bb51bed42ec84477a8c64f567145dc6b3f5b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; for documentation.</source>
          <target state="translated">Consulte &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; para obtener documentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="82b75cc42f6596f8de98cea0e684609b487d2473" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for extra information on increment/decrement operations.</source>
          <target state="translated">Consulte &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; para obtener informaci&amp;oacute;n adicional sobre las operaciones de incremento / decremento.</target>
        </trans-unit>
        <trans-unit id="b864667dcad5904883861ad9695e349acea56ad8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107b4f4ca6c2e49d71158688712e821a1f6afcf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; for more information.</source>
          <target state="translated">Consulte &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="54208184c8545cb10751d54f17912e96124fdcce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">Consulte &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; para &lt;a href=&quot;hscan&quot;&gt;obtener la&lt;/a&gt; documentaci&amp;oacute;n de HSCAN .</target>
        </trans-unit>
        <trans-unit id="c7350f489b2f884299284e290b37d7bb050416da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">Consulte &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; para &lt;a href=&quot;sscan&quot;&gt;obtener la&lt;/a&gt; documentaci&amp;oacute;n de SSCAN .</target>
        </trans-unit>
        <trans-unit id="23e07b46cb9a86395d17dec6e25da38c0a253bd8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">Consulte &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; para &lt;a href=&quot;zscan&quot;&gt;obtener la&lt;/a&gt; documentaci&amp;oacute;n de ZSCAN .</target>
        </trans-unit>
        <trans-unit id="cf5419ddb7be58d105f864a1bb383d4d274d8979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).</source>
          <target state="translated">Consulte &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; cuando necesite los elementos ordenados de mayor a menor puntuaci&amp;oacute;n (y orden lexicogr&amp;aacute;fico descendente para elementos con igual puntuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="a4157bb7f9bac5025b0c70053cd9e97522de9f5f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command that returns the same information with milliseconds resolution (Only available in Redis 2.6 or greater).</source>
          <target state="translated">Consulte tambi&amp;eacute;n el comando &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; que devuelve la misma informaci&amp;oacute;n con una resoluci&amp;oacute;n de milisegundos (solo disponible en Redis 2.6 o superior).</target>
        </trans-unit>
        <trans-unit id="3f65c6fd246f3e1cbd884a1abc8369fa9e3fec12" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being that it pops elements from the tail of a list instead of popping from the head.</source>
          <target state="translated">Consulte la &lt;a href=&quot;blpop&quot;&gt;documentaci&amp;oacute;n de BLPOP&lt;/a&gt; para conocer la sem&amp;aacute;ntica exacta, ya que &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; es id&amp;eacute;ntico a &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; con la &amp;uacute;nica diferencia de que extrae elementos de la cola de una lista en lugar de aparecer de la cabeza.</target>
        </trans-unit>
        <trans-unit id="98f2a156aa61e815ac476620027b033818a3853f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being the data structure being popped from.</source>
          <target state="translated">Consulte la &lt;a href=&quot;blpop&quot;&gt;documentaci&amp;oacute;n de BLPOP&lt;/a&gt; para conocer la sem&amp;aacute;ntica exacta, ya que &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; es id&amp;eacute;ntico a &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; con la &amp;uacute;nica diferencia de que la estructura de datos se extrae.</target>
        </trans-unit>
        <trans-unit id="682db2e97701526e3ecf1f9201b3297eab6f9ec7" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is identical to &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; with the only difference being that it pops members with the highest scores instead of popping the ones with the lowest scores.</source>
          <target state="translated">Consulte la &lt;a href=&quot;bzpopmin&quot;&gt;documentaci&amp;oacute;n de BZPOPMIN&lt;/a&gt; para conocer la sem&amp;aacute;ntica exacta, ya que &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; es id&amp;eacute;ntico a &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; con la &amp;uacute;nica diferencia de que muestra a los miembros con las puntuaciones m&amp;aacute;s altas en lugar de a los que tienen las puntuaciones m&amp;aacute;s bajas.</target>
        </trans-unit>
        <trans-unit id="58bc20fb0dd298ffb8cf41a50998826b6c62ee0f" translate="yes" xml:space="preserve">
          <source>See the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot; for a interesting use cases.</source>
          <target state="translated">Consulte el art&amp;iacute;culo titulado &quot; &lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;M&amp;eacute;tricas r&amp;aacute;pidas y f&amp;aacute;ciles en tiempo real con mapas de bits de Redis&lt;/a&gt; &quot; para ver casos de uso interesantes.</target>
        </trans-unit>
        <trans-unit id="2b55d9f15b0ea2d72611a684c74d755e0354f5c5" translate="yes" xml:space="preserve">
          <source>Select the Redis logical database having the specified zero-based numeric index. New connections always use the database 0.</source>
          <target state="translated">Seleccione la base de datos lógica Redis que tiene el índice numérico de base cero especificado.Las nuevas conexiones siempre usan la base de datos 0.</target>
        </trans-unit>
        <trans-unit id="5e585c2b51baeb7604c1d696f4c6be82b1e7c611" translate="yes" xml:space="preserve">
          <source>Selectable Redis databases are a form of namespacing: all databases are still persisted in the same RDB / AOF file. However different databases can have keys with the same name, and commands like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; work on specific databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19899928b5f8951aa558a826d2465808d72a01a5" translate="yes" xml:space="preserve">
          <source>Selective replication of commands</source>
          <target state="translated">Réplica selectiva de los comandos</target>
        </trans-unit>
        <trans-unit id="49cedc3ef8c6db0043eba553132d30f3fe261b2a" translate="yes" xml:space="preserve">
          <source>Sentinel output</source>
          <target state="translated">Salida del centinela</target>
        </trans-unit>
        <trans-unit id="23e75937982f844ac2efdda93d0cf6e15629e1a7" translate="yes" xml:space="preserve">
          <source>Serialization format</source>
          <target state="translated">Formato de serialización</target>
        </trans-unit>
        <trans-unit id="7af4afd659e0dc29f7d2d75a3f48646f5eb4ec0b" translate="yes" xml:space="preserve">
          <source>Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command.</source>
          <target state="translated">Serialice el valor almacenado en la clave en un formato espec&amp;iacute;fico de Redis y devu&amp;eacute;lvalo al usuario. El valor devuelto se puede sintetizar nuevamente en una clave de Redis usando el comando &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="c0ae85ee6d7ed57f6a577247b126ae67f64df433" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold string &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist. In that case, it is equal to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. When &lt;code&gt;key&lt;/code&gt; already holds a value, no operation is performed. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; is short for &quot;&lt;strong&gt;SET&lt;/strong&gt; if &lt;strong&gt;N&lt;/strong&gt;ot e&lt;strong&gt;X&lt;/strong&gt;ists&quot;.</source>
          <target state="translated">Configure la &lt;code&gt;key&lt;/code&gt; para contener el &lt;code&gt;value&lt;/code&gt; cadena si la &lt;code&gt;key&lt;/code&gt; no existe. En ese caso, es igual a &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; . Cuando la &lt;code&gt;key&lt;/code&gt; ya tiene un valor, no se realiza ninguna operaci&amp;oacute;n. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; es la abreviatura de &quot; &lt;strong&gt;SET&lt;/strong&gt; if &lt;strong&gt;N&lt;/strong&gt; ot e &lt;strong&gt;X&lt;/strong&gt; ists&quot;.</target>
        </trans-unit>
        <trans-unit id="68ffd036a56e1e5a5a24f70d86f4819eb308fad6" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt; and set &lt;code&gt;key&lt;/code&gt; to timeout after a given number of seconds. This command is equivalent to executing the following commands:</source>
          <target state="translated">Configure la &lt;code&gt;key&lt;/code&gt; para mantener el &lt;code&gt;value&lt;/code&gt; la cadena y configure la &lt;code&gt;key&lt;/code&gt; para que se agote el tiempo de espera despu&amp;eacute;s de un n&amp;uacute;mero determinado de segundos. Este comando es equivalente a ejecutar los siguientes comandos:</target>
        </trans-unit>
        <trans-unit id="e17569ffaef1d28acdfd66d09de8af3c0b06dd1a" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation.</source>
          <target state="translated">Establecer &lt;code&gt;key&lt;/code&gt; para contener el &lt;code&gt;value&lt;/code&gt; la cadena . Si la &lt;code&gt;key&lt;/code&gt; ya tiene un valor, se sobrescribe, independientemente de su tipo. Cualquier tiempo de vida anterior asociado con la clave se descarta en la operaci&amp;oacute;n &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; exitosa .</target>
        </trans-unit>
        <trans-unit id="1f4c1e8e25a5de08761510d1ae33392ed98c3afb" translate="yes" xml:space="preserve">
          <source>Set a timeout on &lt;code&gt;key&lt;/code&gt;. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be &lt;em&gt;volatile&lt;/em&gt; in Redis terminology.</source>
          <target state="translated">Establezca un tiempo de espera en la &lt;code&gt;key&lt;/code&gt; . Una vez transcurrido el tiempo de espera, la clave se eliminar&amp;aacute; autom&amp;aacute;ticamente. A menudo se dice que una clave con un tiempo de espera asociado es &lt;em&gt;vol&amp;aacute;til&lt;/em&gt; en la terminolog&amp;iacute;a de Redis.</target>
        </trans-unit>
        <trans-unit id="eaec93cdacc6eb6c55472f85e73e6fb3ad082dbe" translate="yes" xml:space="preserve">
          <source>Set the consumer group &lt;em&gt;last delivered ID&lt;/em&gt; to something else.</source>
          <target state="translated">Configure el &lt;em&gt;&amp;uacute;ltimo ID entregado del&lt;/em&gt; grupo de consumidores en otra cosa.</target>
        </trans-unit>
        <trans-unit id="5d89ad31b7de012f12a03f34f4620f730e4db31a" translate="yes" xml:space="preserve">
          <source>Set the debug mode for subsequent scripts executed with &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;. Redis includes a complete Lua debugger, codename LDB, that can be used to make the task of writing complex scripts much simpler. In debug mode Redis acts as a remote debugging server and a client, such as &lt;code&gt;redis-cli&lt;/code&gt;, can execute scripts step by step, set breakpoints, inspect variables and more - for additional information about LDB refer to the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt; page.</source>
          <target state="translated">Establezca el modo de depuraci&amp;oacute;n para los siguientes scripts ejecutados con &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; . Redis incluye un depurador Lua completo, nombre en clave LDB, que se puede usar para simplificar la tarea de escribir scripts complejos. En el modo de depuraci&amp;oacute;n, Redis act&amp;uacute;a como un servidor de depuraci&amp;oacute;n remoto y un cliente, como &lt;code&gt;redis-cli&lt;/code&gt; , puede ejecutar scripts paso a paso, establecer puntos de interrupci&amp;oacute;n, inspeccionar variables y m&amp;aacute;s; para obtener informaci&amp;oacute;n adicional sobre LDB, consulte la p&amp;aacute;gina del &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;depurador de Redis Lua&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6550b71f96cbf89e715fc6e575e8db9958a3525f" translate="yes" xml:space="preserve">
          <source>Set the destination node slot to &lt;em&gt;importing&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Configure la ranura del nodo de destino en el estado de &lt;em&gt;importaci&amp;oacute;n&lt;/em&gt; mediante &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84c2dc8e1aa43a852766a49a5d96696d6e7e9329" translate="yes" xml:space="preserve">
          <source>Set the source node slot to &lt;em&gt;migrating&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Configure la ranura del nodo de origen en el estado de &lt;em&gt;migraci&amp;oacute;n&lt;/em&gt; mediante &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab262f44dfc9e1ee8adf98c1aa64de34434fa83" translate="yes" xml:space="preserve">
          <source>Sets</source>
          <target state="translated">Sets</target>
        </trans-unit>
        <trans-unit id="d9264103cd2db8160e2072438f28377ce6a9fc7b" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, only if &lt;code&gt;field&lt;/code&gt; does not yet exist. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists, this operation has no effect.</source>
          <target state="translated">Establece el &lt;code&gt;field&lt;/code&gt; en el hash almacenado en la &lt;code&gt;key&lt;/code&gt; al &lt;code&gt;value&lt;/code&gt; , solo si el &lt;code&gt;field&lt;/code&gt; a&amp;uacute;n no existe. Si la &lt;code&gt;key&lt;/code&gt; no existe, se crea una nueva clave que contiene un hash. Si el &lt;code&gt;field&lt;/code&gt; ya existe, esta operaci&amp;oacute;n no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="4067fd3c70d6275dbeb4b012c5dce8cf613a429a" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists in the hash, it is overwritten.</source>
          <target state="translated">Establece el &lt;code&gt;field&lt;/code&gt; en el hash almacenado en la &lt;code&gt;key&lt;/code&gt; al &lt;code&gt;value&lt;/code&gt; . Si la &lt;code&gt;key&lt;/code&gt; no existe, se crea una nueva clave que contiene un hash. Si el &lt;code&gt;field&lt;/code&gt; ya existe en el hash, se sobrescribe.</target>
        </trans-unit>
        <trans-unit id="e0c3c8b5846a6b7343db97e53a136456e18a31e2" translate="yes" xml:space="preserve">
          <source>Sets can be encoded as &lt;code&gt;intset&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;intset&lt;/code&gt; is a special encoding used for small sets composed solely of integers.</source>
          <target state="translated">Los conjuntos pueden ser codificados como &lt;code&gt;intset&lt;/code&gt; o &lt;code&gt;hashtable&lt;/code&gt; . El &lt;code&gt;intset&lt;/code&gt; es una codificaci&amp;oacute;n especial que se utiliza para peque&amp;ntilde;os conjuntos compuestos &amp;uacute;nicamente por n&amp;uacute;meros enteros.</target>
        </trans-unit>
        <trans-unit id="e2de8a522a3c6c1fa9f2cb3110ab55a427778354" translate="yes" xml:space="preserve">
          <source>Sets or clears the bit at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">Establece o borra el bit en el &lt;em&gt;desplazamiento&lt;/em&gt; en el valor de cadena almacenado en la &lt;em&gt;tecla&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e97dcc6f663f896d57a6785f5e028d865ad0719f" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; replaces existing values with new values, just as regular &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. See &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; if you don't want to overwrite existing values.</source>
          <target state="translated">Establece las claves dadas en sus respectivos valores. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; reemplaza los valores existentes con valores nuevos, al igual que &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; regular . Consulte &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; si no desea sobrescribir los valores existentes.</target>
        </trans-unit>
        <trans-unit id="5a2c8ceb3bc610f26a67627aba4acc8339a9ce7d" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; will not perform any operation at all even if just a single key already exists.</source>
          <target state="translated">Establece las claves dadas en sus respectivos valores. &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; no realizar&amp;aacute; ninguna operaci&amp;oacute;n, incluso si ya existe una sola clave.</target>
        </trans-unit>
        <trans-unit id="97465787360d692779d220c22de863eac3b87265" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;element&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8750c7a418a307afb7502f752e1bd4c1264fa761" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">Establece el elemento de la lista en el &lt;code&gt;index&lt;/code&gt; en &lt;code&gt;value&lt;/code&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el argumento de &lt;code&gt;index&lt;/code&gt; , consulte &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3acb8a6c67905faa893fe92726100c83a3b40b2e" translate="yes" xml:space="preserve">
          <source>Sets the specified fields to their respective values in the hash stored at &lt;code&gt;key&lt;/code&gt;. This command overwrites any specified fields already existing in the hash. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created.</source>
          <target state="translated">Establece los campos especificados en sus respectivos valores en el hash almacenado en la &lt;code&gt;key&lt;/code&gt; . Este comando sobrescribe los campos especificados que ya existen en el hash. Si la &lt;code&gt;key&lt;/code&gt; no existe, se crea una nueva clave que contiene un hash.</target>
        </trans-unit>
        <trans-unit id="66e4a6395d06dd6c9ac9889a54defa5d69368f6e" translate="yes" xml:space="preserve">
          <source>Similarly to get just the last element added into the stream it is enough to send:</source>
          <target state="translated">Del mismo modo,para conseguir que sólo se añada el último elemento en la corriente es suficiente con enviar:</target>
        </trans-unit>
        <trans-unit id="e66ca1aceaf1d95b66f61ef999386ba4322050ac" translate="yes" xml:space="preserve">
          <source>Simple string reply</source>
          <target state="translated">Respuesta de cadena simple</target>
        </trans-unit>
        <trans-unit id="d1d2334a81971315130c4fe2db94eeb5d843a482" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; and &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; have a &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; option they are technically flagged as writing commands in the Redis command table. For this reason read-only replicas will flag them, and Redis Cluster replicas will redirect them to the master instance even if the connection is in read only mode (See the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command of Redis Cluster).</source>
          <target state="translated">Dado que &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; y &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; tienen una opci&amp;oacute;n &lt;code&gt;STORE&lt;/code&gt; y &lt;code&gt;STOREDIST&lt;/code&gt; , t&amp;eacute;cnicamente est&amp;aacute;n marcados como comandos de escritura en la tabla de comandos de Redis. Por esta raz&amp;oacute;n, las r&amp;eacute;plicas de solo lectura las marcar&amp;aacute;n y las r&amp;eacute;plicas de Redis Cluster las redirigir&amp;aacute;n a la instancia maestra, incluso si la conexi&amp;oacute;n est&amp;aacute; en modo de solo lectura (consulte el comando &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; de Redis Cluster).</target>
        </trans-unit>
        <trans-unit id="97d9bd95aec04226ad20ff34e75e5087d27999bb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; returns the number of replicas reached both in case of failure and success, the client should check that the returned value is equal or greater to the replication level it demanded.</source>
          <target state="translated">Dado que &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; devuelve la cantidad de r&amp;eacute;plicas alcanzadas tanto en caso de falla como de &amp;eacute;xito, el cliente debe verificar que el valor devuelto sea igual o mayor al nivel de replicaci&amp;oacute;n que exigi&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="d91e505ea765c9a82be96ae5534dfec641b36446" translate="yes" xml:space="preserve">
          <source>Since Redis 2.4 the AOF rewrite is automatically triggered by Redis, however the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; command can be used to trigger a rewrite at any time.</source>
          <target state="translated">Desde Redis 2.4, Redis activa autom&amp;aacute;ticamente la reescritura de AOF, sin embargo, el comando &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; se puede utilizar para activar una reescritura en cualquier momento.</target>
        </trans-unit>
        <trans-unit id="fea1afb4200834342d36841c2047774edeed20c3" translate="yes" xml:space="preserve">
          <source>Since Redis 2.6 the expire error is from 0 to 1 milliseconds.</source>
          <target state="translated">Desde Redis 2.6 el error de caducidad es de 0 a 1 milisegundo.</target>
        </trans-unit>
        <trans-unit id="c0dcf1f129fbdd5b581db58c1a230256a6836c37" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 it is possible to specify multiple keys instead of a single one. In such a case, it returns the total number of keys existing. Note that returning 1 or 0 for a single key is just a special case of the variadic usage, so the command is completely backward compatible.</source>
          <target state="translated">Desde Redis 3.0.3 es posible especificar múltiples claves en lugar de una sola.En tal caso,devuelve el número total de claves existentes.Tenga en cuenta que devolver 1 o 0 para una sola clave es sólo un caso especial del uso variado,por lo que el comando es completamente compatible hacia atrás.</target>
        </trans-unit>
        <trans-unit id="f8bcf2ebedfce566d24835d3a2aba17bb7c2d1ca" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 the command accepts a variable number of keys and the return value is generalized:</source>
          <target state="translated">Desde Redis 3.0.3 el comando acepta un número variable de teclas y el valor de retorno es generalizado:</target>
        </trans-unit>
        <trans-unit id="e151485b203362c942ed95e59fd38510a0f0ba0d" translate="yes" xml:space="preserve">
          <source>Since Redis 3.2.10 / 4.0.0, this command also prevents keys to be evicted or expired during the time clients are paused. This way the dataset is guaranteed to be static not just from the point of view of clients not being able to write, but also from the point of view of internal operations.</source>
          <target state="translated">Desde Redis 3.2.10/4.0.0,este comando también evita que las teclas sean desalojadas o caducadas durante el tiempo en que los clientes están en pausa.De esta manera se garantiza que el conjunto de datos sea estático no sólo desde el punto de vista de los clientes que no pueden escribir,sino también desde el punto de vista de las operaciones internas.</target>
        </trans-unit>
        <trans-unit id="b23d8947d72fa1ab05d11117a996f014677a635b" translate="yes" xml:space="preserve">
          <source>Since in the second call the returned cursor is 0, the server signaled to the caller that the iteration finished, and the collection was completely explored. Starting an iteration with a cursor value of 0, and calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; until the returned cursor is 0 again is called a &lt;strong&gt;full iteration&lt;/strong&gt;.</source>
          <target state="translated">Dado que en la segunda llamada el cursor devuelto es 0, el servidor le indic&amp;oacute; a la persona que llam&amp;oacute; que la iteraci&amp;oacute;n termin&amp;oacute; y la colecci&amp;oacute;n se explor&amp;oacute; por completo. Comenzar una iteraci&amp;oacute;n con un valor de cursor de 0 y llamar a &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; hasta que el cursor devuelto sea 0 nuevamente se denomina &lt;strong&gt;iteraci&amp;oacute;n completa&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5ff6f2c9633e20e1d4f2fc7a23a6109e8917c9ab" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;increment&lt;/code&gt; argument is signed, both increment and decrement operations can be performed:</source>
          <target state="translated">Dado que el argumento de &lt;code&gt;increment&lt;/code&gt; o est&amp;aacute; firmado, se pueden realizar operaciones de incremento y decremento:</target>
        </trans-unit>
        <trans-unit id="37a6aaafe1e5adca5e6fbd58e615c9ceed7c328a" translate="yes" xml:space="preserve">
          <source>Since the currently selected database is a property of the connection, clients should track the currently selected database and re-select it on reconnection. While there is no command in order to query the selected database in the current connection, the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; output shows, for each client, the currently selected database.</source>
          <target state="translated">Dado que la base de datos actualmente seleccionada es una propiedad de la conexi&amp;oacute;n, los clientes deben rastrear la base de datos actualmente seleccionada y volver a seleccionarla al volver a conectarse. Si bien no existe un comando para consultar la base de datos seleccionada en la conexi&amp;oacute;n actual, la salida de la &lt;a href=&quot;client-list&quot;&gt;LISTA DE CLIENTES&lt;/a&gt; muestra, para cada cliente, la base de datos actualmente seleccionada.</target>
        </trans-unit>
        <trans-unit id="52b5e60090730a6d250177de9e20295f9eac7ba4" translate="yes" xml:space="preserve">
          <source>Since the introduction of partial resynchronization with replicas (PSYNC feature) Redis replicas asynchronously ping their master with the offset they already processed in the replication stream. This is used in multiple ways:</source>
          <target state="translated">Desde la introducción de la resincronización parcial con las réplicas (característica de PSYNC)las réplicas de Redis hacen ping asincrónicamente a su maestro con el offset que ya procesaron en el flujo de replicación.Esto se utiliza de múltiples maneras:</target>
        </trans-unit>
        <trans-unit id="22f6371320dc02af91620e9a2e69ac86d721aec2" translate="yes" xml:space="preserve">
          <source>Since there is no state server side, but the full state is captured by the cursor, the caller is free to terminate an iteration half-way without signaling this to the server in any way. An infinite number of iterations can be started and never terminated without any issue.</source>
          <target state="translated">Dado que no hay un lado del servidor del estado,sino que el estado completo es capturado por el cursor,el que llama es libre de terminar una iteración a medio camino sin señalarlo al servidor de ninguna manera.Un número infinito de iteraciones pueden ser iniciadas y nunca terminadas sin ningún problema.</target>
        </trans-unit>
        <trans-unit id="262e696e012026f3d4f6a8415b02d5a7c46227f9" translate="yes" xml:space="preserve">
          <source>Since these commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands like &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; or &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; that may block the server for a long time (even several seconds) when called against big collections of keys or elements.</source>
          <target state="translated">Dado que estos comandos permiten la iteraci&amp;oacute;n incremental, devolviendo solo una peque&amp;ntilde;a cantidad de elementos por llamada, se pueden usar en producci&amp;oacute;n sin la desventaja de comandos como &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; o &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; que pueden bloquear el servidor durante mucho tiempo (incluso varios segundos) cuando se llaman en contra. grandes colecciones de claves o elementos.</target>
        </trans-unit>
        <trans-unit id="3c0c8d4b217b1b3c149a8290667da3e389e7ef26" translate="yes" xml:space="preserve">
          <source>Since this involves approximations, in order to avoid C is set to, like, 0.998 instead of 1, we just modify the above algorithm to make sure the last score is 1 (left as an exercise for the reader...).</source>
          <target state="translated">Como esto implica aproximaciones,para evitar que C se fije en 0,998 en lugar de 1,sólo modificamos el algoritmo anterior para asegurarnos de que la última puntuación sea 1 (se deja como ejercicio para el lector...).</target>
        </trans-unit>
        <trans-unit id="7872f5590df64a34d5d83302b83736d78de377e5" translate="yes" xml:space="preserve">
          <source>Since version 2.1.6, &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be exclusive, following the syntax of &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">Desde la versi&amp;oacute;n 2.1.6, &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; pueden ser exclusivos, siguiendo la sintaxis de &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62c6108c3b6b3ae8ea558c2fa3e4a664136371f3" translate="yes" xml:space="preserve">
          <source>Since version 6.2 it is possible to filter entries by their idle-time, given in milliseconds (useful for &lt;code&gt;XCLAIM&lt;/code&gt;ing entries that have not been processed for some time):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1d2abc7675af0239fa910c466960e644589788" translate="yes" xml:space="preserve">
          <source>Single number: 3894</source>
          <target state="translated">Número único:3894</target>
        </trans-unit>
        <trans-unit id="f4a53209e61b36ab81faa5f943fba8e855032018" translate="yes" xml:space="preserve">
          <source>Skip sorting the elements</source>
          <target state="translated">Saltar la clasificación de los elementos</target>
        </trans-unit>
        <trans-unit id="8eab09bbd450823e91103eb2aaa19c7c3697409f" translate="yes" xml:space="preserve">
          <source>So for example the command &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; will return each item in the following way:</source>
          <target state="translated">Entonces, por ejemplo, el comando &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; devolver&amp;aacute; cada elemento de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="76d0f19de574ac1304a0b3b169f72caa92244d72" translate="yes" xml:space="preserve">
          <source>So for instance, to get all the elements from the higher ID to the lower ID one could use:</source>
          <target state="translated">Así que,por ejemplo,para obtener todos los elementos de la ID superior a la ID inferior se podría utilizar:</target>
        </trans-unit>
        <trans-unit id="605cfa3fd340ae3e5e756672779740b80a689628" translate="yes" xml:space="preserve">
          <source>So in order for a given node to accept another one into the list of nodes composing a Redis Cluster, there are only two ways:</source>
          <target state="translated">Así que para que un nodo dado acepte a otro en la lista de nodos que componen un Cluster de Redis,sólo hay dos maneras:</target>
        </trans-unit>
        <trans-unit id="2350b72b46e64aeb370c2cbfa4c601de95c3d620" translate="yes" xml:space="preserve">
          <source>So we start with a list of keys, and later continue with all the associated IDs, representing &lt;em&gt;the last ID we received for that stream&lt;/em&gt;, so that the call will serve us only greater IDs from the same stream.</source>
          <target state="translated">Entonces comenzamos con una lista de claves, y luego continuamos con todos los ID asociados, que representan &lt;em&gt;el &amp;uacute;ltimo ID que recibimos para ese flujo&lt;/em&gt; , de modo que la llamada nos sirva solo ID mayores del mismo flujo.</target>
        </trans-unit>
        <trans-unit id="46ddca2244f21f2b27c1eb6025f1e694d4b8bea0" translate="yes" xml:space="preserve">
          <source>So what the command really does is:</source>
          <target state="translated">Así que lo que el comando realmente hace es:</target>
        </trans-unit>
        <trans-unit id="f434d4f52b4b99882f1b83c63bcdd004df128d69" translate="yes" xml:space="preserve">
          <source>So, if we link node A with node B via &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;, and B with C, A and C will find their ways to handshake and create a link.</source>
          <target state="translated">Entonces, si vinculamos el nodo A con el nodo B a trav&amp;eacute;s de &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; , y B con C, A y C encontrar&amp;aacute;n sus formas de apret&amp;oacute;n de manos y crear&amp;aacute;n un enlace.</target>
        </trans-unit>
        <trans-unit id="60790236df4f5916ea98a7288f81aafe33a99ab5" translate="yes" xml:space="preserve">
          <source>So, using &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt;, when a new cluster is created, we can assign a different progressive configuration epoch to each node before joining the cluster together.</source>
          <target state="translated">Entonces, usando &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt; , cuando se crea un nuevo cl&amp;uacute;ster, podemos asignar una &amp;eacute;poca de configuraci&amp;oacute;n progresiva diferente a cada nodo antes de unir el cl&amp;uacute;ster.</target>
        </trans-unit>
        <trans-unit id="f4318ce82f602a680da3fd3d1f1b92cbeae45d01" translate="yes" xml:space="preserve">
          <source>So, we want to say, give me the first element starting from the tail of the list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173217936882f8d5719c8defa86bf0d23eac51fe" translate="yes" xml:space="preserve">
          <source>Some Redis commands have no predetermined key locations. For those commands, flag &lt;code&gt;movablekeys&lt;/code&gt; is added to the command flags &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;. Your Redis Cluster client needs to parse commands marked &lt;code&gt;movablekeys&lt;/code&gt; to locate all relevant key positions.</source>
          <target state="translated">Algunos comandos de Redis no tienen ubicaciones de teclas predeterminadas. Para esos comandos, el indicador &lt;code&gt;movablekeys&lt;/code&gt; se agrega al comando flags &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; . Su cliente de Redis Cluster necesita analizar los comandos marcados como &lt;code&gt;movablekeys&lt;/code&gt; para ubicar todas las posiciones clave relevantes.</target>
        </trans-unit>
        <trans-unit id="ddceed7fe40007b57317ba7df983076bcd185123" translate="yes" xml:space="preserve">
          <source>Some consumer A reads a message via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; from a stream, in the context of that consumer group.</source>
          <target state="translated">Alg&amp;uacute;n consumidor A lee un mensaje a trav&amp;eacute;s de &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; de una secuencia, en el contexto de ese grupo de consumidores.</target>
        </trans-unit>
        <trans-unit id="28d440075fc880e5ff5b66c8a65009bc3be5acfb" translate="yes" xml:space="preserve">
          <source>Sometimes it can be useful for clients to completely disable replies from the Redis server. For example when the client sends fire and forget commands or performs a mass loading of data, or in caching contexts where new data is streamed constantly. In such contexts to use server time and bandwidth in order to send back replies to clients, which are going to be ignored, is considered wasteful.</source>
          <target state="translated">A veces puede ser útil para los clientes deshabilitar completamente las respuestas del servidor de Redis.Por ejemplo,cuando el cliente envía comandos de disparar y olvidar o realiza una carga masiva de datos,o en contextos de caché donde se transmiten constantemente nuevos datos.En esos contextos,utilizar el tiempo y el ancho de banda del servidor para enviar respuestas a los clientes,que van a ser ignoradas,se considera un desperdicio.</target>
        </trans-unit>
        <trans-unit id="a1fbf7ca3941093b616976378d4450adc4f2adb7" translate="yes" xml:space="preserve">
          <source>Sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295b7c77aec21f1ec78f8bb6debbc23501dae53f" translate="yes" xml:space="preserve">
          <source>Sometimes we need just the length of the match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a212e08b7709fdef0e43a6ae14d5840bfa05846" translate="yes" xml:space="preserve">
          <source>Sometimes we want to return not just the Nth matching element, but the position of all the first N matching elements. This can be achieved using the &lt;code&gt;COUNT&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43292f17e4e5fce7b6e4920a4500928789cc3b9d" translate="yes" xml:space="preserve">
          <source>Sometimes you want to sort elements using external keys as weights to compare instead of comparing the actual elements in the list, set or sorted set. Let's say the list &lt;code&gt;mylist&lt;/code&gt; contains the elements &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; representing unique IDs of objects stored in &lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;. When these objects have associated weights stored in &lt;code&gt;weight_1&lt;/code&gt;, &lt;code&gt;weight_2&lt;/code&gt; and &lt;code&gt;weight_3&lt;/code&gt;, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; can be instructed to use these weights to sort &lt;code&gt;mylist&lt;/code&gt; with the following statement:</source>
          <target state="translated">A veces, desea ordenar elementos utilizando claves externas como pesos para comparar en lugar de comparar los elementos reales en la lista, conjunto o conjunto ordenado. Digamos que la lista &lt;code&gt;mylist&lt;/code&gt; contiene los elementos &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; que representan ID &amp;uacute;nicos de objetos almacenados en &lt;code&gt;object_1&lt;/code&gt; , &lt;code&gt;object_2&lt;/code&gt; y &lt;code&gt;object_3&lt;/code&gt; . Cuando estos objetos tienen pesos asociados almacenados en &lt;code&gt;weight_1&lt;/code&gt; , &lt;code&gt;weight_2&lt;/code&gt; y &lt;code&gt;weight_3&lt;/code&gt; , se puede indicar a &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; que utilice estos pesos para ordenar &lt;code&gt;mylist&lt;/code&gt; con la siguiente declaraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="b2397d818d7562914c5b062b54f97e833db314f2" translate="yes" xml:space="preserve">
          <source>Sorted Sets</source>
          <target state="translated">Conjuntos ordenados</target>
        </trans-unit>
        <trans-unit id="25ab5e6a0d5f2c9c6bc25d348c156dc61d5c8552" translate="yes" xml:space="preserve">
          <source>Sorted Sets can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;skiplist&lt;/code&gt; format. As for the List type small sorted sets can be specially encoded using &lt;code&gt;ziplist&lt;/code&gt;, while the &lt;code&gt;skiplist&lt;/code&gt; encoding is the one that works with sorted sets of any size.</source>
          <target state="translated">Los conjuntos &lt;code&gt;ziplist&lt;/code&gt; se pueden codificar como formato ziplist o &lt;code&gt;skiplist&lt;/code&gt; . En cuanto al tipo de lista, los conjuntos peque&amp;ntilde;os ordenados se pueden codificar especialmente usando &lt;code&gt;ziplist&lt;/code&gt; , mientras que la codificaci&amp;oacute;n de lista de &lt;code&gt;skiplist&lt;/code&gt; es la que funciona con conjuntos ordenados de cualquier tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="86e387fe2a33fb39f76cfff98ea344b952f84a62" translate="yes" xml:space="preserve">
          <source>Sorted sets 101</source>
          <target state="translated">Sets ordenados 101</target>
        </trans-unit>
        <trans-unit id="785f83ba9125723b72d2c573196ef8beabb345a8" translate="yes" xml:space="preserve">
          <source>Sorted sets are sorted by their score in an ascending way. The same element only exists a single time, no repeated elements are permitted. The score can be modified both by &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; that will update the element score, and as a side effect, its position on the sorted set, and by &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; that can be used in order to update the score relatively to its previous value.</source>
          <target state="translated">Los conjuntos ordenados se ordenan por su puntuaci&amp;oacute;n de forma ascendente. El mismo elemento solo existe una vez, no se permiten elementos repetidos. La puntuaci&amp;oacute;n puede ser modificada tanto por &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; que actualizar&amp;aacute; la puntuaci&amp;oacute;n del elemento, y como efecto secundario, su posici&amp;oacute;n en el conjunto ordenado, y por &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; que se puede usar para actualizar la puntuaci&amp;oacute;n en relaci&amp;oacute;n con su valor anterior.</target>
        </trans-unit>
        <trans-unit id="2f2a07b6f7677455f1b32d657bbc8366bfa48bf3" translate="yes" xml:space="preserve">
          <source>Sorting by external keys</source>
          <target state="translated">Clasificado por teclas externas</target>
        </trans-unit>
        <trans-unit id="614fb399b6728ae041f21780ab6202d98e11c79a" translate="yes" xml:space="preserve">
          <source>Special conditions not allowing the command execution</source>
          <target state="translated">Condiciones especiales que no permiten la ejecución del comando</target>
        </trans-unit>
        <trans-unit id="0869a917cb9ab140bb00f5d52e7332ad6727fd9a" translate="yes" xml:space="preserve">
          <source>Special slot entries</source>
          <target state="translated">Entradas de ranuras especiales</target>
        </trans-unit>
        <trans-unit id="549c2b56d95e908566338d2fd5914a21fd08d936" translate="yes" xml:space="preserve">
          <source>Specifically if a given write is transferred to one or more replicas, it is more likely (but not guaranteed) that if the master fails, we'll be able to promote, during a failover, a replica that received the write: both Sentinel and Redis Cluster will do a best-effort attempt to promote the best replica among the set of available replicas.</source>
          <target state="translated">Específicamente si una escritura dada se transfiere a una o más réplicas,es más probable (pero no garantizado)que si el maestro falla,podremos promover,durante un failover,una réplica que recibió la escritura:tanto Sentinel como Redis Cluster harán el mejor esfuerzo para promover la mejor réplica entre el conjunto de réplicas disponibles.</target>
        </trans-unit>
        <trans-unit id="d526406a65071e1fec15bd4174751e7a5bc387d7" translate="yes" xml:space="preserve">
          <source>Specifically this is what Redis does 10 times per second:</source>
          <target state="translated">Específicamente esto es lo que Redis hace 10 veces por segundo:</target>
        </trans-unit>
        <trans-unit id="2fa9940f1d66c2c57fbda5e1ef12bce097cf18d3" translate="yes" xml:space="preserve">
          <source>Specifically, it lists the user's ACL flags, password hashes and key name patterns. Note that command rules are returned as a string in the same format used with the &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt; command. This description of command rules reflects the user's effective permissions, so while it may not be identical to the set of rules used to configure the user, it is still functionally identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="37ec7d989573caff7ef9f45953dba8d022709000" translate="yes" xml:space="preserve">
          <source>Specification of the behavior when count is passed</source>
          <target state="translated">Especificación del comportamiento cuando se pasa la cuenta</target>
        </trans-unit>
        <trans-unit id="14c30af049c8842dbcbd1159d5db60d5f0981029" translate="yes" xml:space="preserve">
          <source>Specifying a Stream ID as an argument</source>
          <target state="translated">Especificar una identificación de la corriente como argumento</target>
        </trans-unit>
        <trans-unit id="1544a5bc78a2aee56854818668d14afd235ec6c9" translate="yes" xml:space="preserve">
          <source>Start slot range</source>
          <target state="translated">Rango de la ranura de inicio</target>
        </trans-unit>
        <trans-unit id="ee455845986f290115764586b0c8b62db6794d99" translate="yes" xml:space="preserve">
          <source>Starting from Redis version 2.6, when called with the additional &lt;code&gt;count&lt;/code&gt; argument, return an array of &lt;code&gt;count&lt;/code&gt;&lt;strong&gt;distinct elements&lt;/strong&gt; if &lt;code&gt;count&lt;/code&gt; is positive. If called with a negative &lt;code&gt;count&lt;/code&gt; the behavior changes and the command is allowed to return the &lt;strong&gt;same element multiple times&lt;/strong&gt;. In this case the number of returned elements is the absolute value of the specified &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 2.6 de Redis, cuando se llama con el argumento adicional &lt;code&gt;count&lt;/code&gt; , devuelve una matriz de &lt;strong&gt;elementos distintos&lt;/strong&gt; de &lt;code&gt;count&lt;/code&gt; si el &lt;code&gt;count&lt;/code&gt; es positivo. Si se llama con un &lt;code&gt;count&lt;/code&gt; negativo, el comportamiento cambia y el comando puede devolver el &lt;strong&gt;mismo elemento varias veces&lt;/strong&gt; . En este caso, el n&amp;uacute;mero de elementos devueltos es el valor absoluto del &lt;code&gt;count&lt;/code&gt; especificado .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83f9c28598d952311fc09fa54e334ed57a68832b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; supports a set of options that modify its behavior:</source>
          <target state="translated">A partir de Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; admite un conjunto de opciones que modifican su comportamiento:</target>
        </trans-unit>
        <trans-unit id="f154b597ac1178d82fc4c50afc3e83d654688468" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.8 the return value in case of error changed:</source>
          <target state="translated">A partir de Redis 2.8 el valor de retorno en caso de error cambió:</target>
        </trans-unit>
        <trans-unit id="cb9c10a639cbbf2b71b38cd0e777ffb915ed4e8b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.0.6 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; supports a new bulk-migration mode that uses pipelining in order to migrate multiple keys between instances without incurring in the round trip time latency and other overheads that there are when moving each key with a single &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; call.</source>
          <target state="translated">A partir de Redis 3.0.6, &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; admite un nuevo modo de migraci&amp;oacute;n masiva que utiliza canalizaci&amp;oacute;n para migrar varias claves entre instancias sin incurrir en la latencia de tiempo de ida y vuelta y otros gastos generales que existen cuando se mueve cada clave con una &amp;uacute;nica llamada &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6578980d36f8246047edd57af78a6f9934454cea" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, Redis has support for native Lua debugging. The Redis Lua debugger is a remote debugger consisting of a server, which is Redis itself, and a client, which is by default &lt;code&gt;redis-cli&lt;/code&gt;.</source>
          <target state="translated">A partir de Redis 3.2, Redis admite la depuraci&amp;oacute;n nativa de Lua. El depurador de Redis Lua es un depurador remoto que consta de un servidor, que es el propio Redis, y un cliente, que es &lt;code&gt;redis-cli&lt;/code&gt; por defecto .</target>
        </trans-unit>
        <trans-unit id="5b01b9bd2a097f98e87d6033b411073bab6691f7" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, it is possible to select an alternative replication method. Instead of replication whole scripts, we can just replicate single write commands generated by the script. We call this &lt;strong&gt;script effects replication&lt;/strong&gt;.</source>
          <target state="translated">A partir de Redis 3.2, es posible seleccionar un m&amp;eacute;todo de replicaci&amp;oacute;n alternativo. En lugar de replicar scripts completos, podemos simplemente replicar comandos de escritura &amp;uacute;nicos generados por el script. A esto lo llamamos &lt;strong&gt;replicaci&amp;oacute;n de efectos de script&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2b5108a4d347209131d9cdaa00d48ad36bea64af" translate="yes" xml:space="preserve">
          <source>Starting with Redis version 6, the server supports two different protocols. One is called RESP2, and is the old protocol: all the new connections to the server start in this mode. However clients are able to negotiate the new protocol using the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command: this way the connection is put in RESP3 mode. In this mode certain commands, like for instance &lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt;, reply with a new data type (the Map data type in this specific case). The RESP3 protocol is semantically more powerful, however most scripts are OK with using just RESP2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffd355623442762e32037427cffdb34a18e3984" translate="yes" xml:space="preserve">
          <source>Step 4 does not technically need to use &lt;code&gt;SETSLOT&lt;/code&gt; in the nodes not involved in the resharding, since the configuration will eventually propagate itself, however it is a good idea to do so in order to stop nodes from pointing to the wrong node for the hash slot moved as soon as possible, resulting in less redirections to find the right node.</source>
          <target state="translated">El paso 4 no necesita t&amp;eacute;cnicamente usar &lt;code&gt;SETSLOT&lt;/code&gt; en los nodos que no est&amp;aacute;n involucrados en la nueva compartici&amp;oacute;n, ya que la configuraci&amp;oacute;n eventualmente se propagar&amp;aacute; por s&amp;iacute; misma, sin embargo, es una buena idea hacerlo para evitar que los nodos apunten al nodo incorrecto para la ranura hash. movido tan pronto como sea posible, resultando en menos redirecciones para encontrar el nodo correcto.</target>
        </trans-unit>
        <trans-unit id="f75b76768d708a29fc0fb9becaf181931853bd99" translate="yes" xml:space="preserve">
          <source>Step Count</source>
          <target state="translated">Conteo de pasos</target>
        </trans-unit>
        <trans-unit id="f7fa846d5511789adfec64aa9b8751f7351a0ca5" translate="yes" xml:space="preserve">
          <source>Stop all the clients.</source>
          <target state="translated">Detener a todos los clientes.</target>
        </trans-unit>
        <trans-unit id="6cb759f69a54fcb63d47af649e368c12075f71be" translate="yes" xml:space="preserve">
          <source>Storing the result of a SORT operation</source>
          <target state="translated">Almacenamiento del resultado de una operación SORT</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="61c2b2148d7f362f23210527dbc1bd6b0437b131" translate="yes" xml:space="preserve">
          <source>Stream IDs are composed of two parts, a Unix millisecond time stamp and a sequence number for entries inserted in the same millisecond. It is possible to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; specifying just the first part of the ID, the millisecond time, like in the following example:</source>
          <target state="translated">Los ID de flujo se componen de dos partes, una marca de tiempo de milisegundos de Unix y un n&amp;uacute;mero de secuencia para las entradas insertadas en el mismo milisegundo. Es posible usar &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; especificando solo la primera parte del ID, el tiempo de milisegundos, como en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="e577b53fb1794580c0560fa9502cf28744dcd504" translate="yes" xml:space="preserve">
          <source>Stream entries are returned, including fields and values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e700aeb9d8c3a456c6730300f1abde75268288" translate="yes" xml:space="preserve">
          <source>Streams are not auto-deleted once they have no entries inside (for instance after an &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; call), because the stream may have consumer groups associated with it.</source>
          <target state="translated">Las transmisiones no se eliminan autom&amp;aacute;ticamente una vez que no tienen entradas dentro (por ejemplo, despu&amp;eacute;s de una llamada &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; ), porque la transmisi&amp;oacute;n puede tener grupos de consumidores asociados.</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="48c2711e04347f7b6d1ddd6b4a79296a8d2830ea" translate="yes" xml:space="preserve">
          <source>Strings are compared as binary array of bytes. Because of how the ASCII character set is specified, this means that usually this also have the effect of comparing normal ASCII characters in an obvious dictionary way. However this is not true if non plain ASCII strings are used (for example utf8 strings).</source>
          <target state="translated">Las cadenas se comparan como una matriz binaria de bytes.Debido a la forma en que se especifica el conjunto de caracteres ASCII,esto significa que normalmente también tiene el efecto de comparar los caracteres ASCII normales de una forma obvia en el diccionario.Sin embargo,esto no es cierto si se utilizan cadenas ASCII no normales (por ejemplo,cadenas utf8).</target>
        </trans-unit>
        <trans-unit id="2593368d27635cc5293b7e53f7145a56dff05dd8" translate="yes" xml:space="preserve">
          <source>Strings can be encoded as &lt;code&gt;raw&lt;/code&gt; (normal string encoding) or &lt;code&gt;int&lt;/code&gt; (strings representing integers in a 64 bit signed interval are encoded in this way in order to save space).</source>
          <target state="translated">Las cadenas se pueden codificar como sin &lt;code&gt;raw&lt;/code&gt; (codificaci&amp;oacute;n de cadena normal) o &lt;code&gt;int&lt;/code&gt; (las cadenas que representan n&amp;uacute;meros enteros en un intervalo con signo de 64 bits se codifican de esta manera para ahorrar espacio).</target>
        </trans-unit>
        <trans-unit id="d5294ece475c0dd1b0e5c4f6f621c1e0c0bf7039" translate="yes" xml:space="preserve">
          <source>Strings with a similar prefix are nearby, but the contrary is not true, it is possible that strings with different prefixes are nearby too.</source>
          <target state="translated">Las cuerdas con un prefijo similar están cerca,pero lo contrario no es cierto,es posible que las cuerdas con prefijos diferentes también estén cerca.</target>
        </trans-unit>
        <trans-unit id="3f9d46e5fb83a7700b4c788a03b12a80a7e61e08" translate="yes" xml:space="preserve">
          <source>Subcommand &lt;code&gt;encoding&lt;/code&gt; returns a bulk reply.</source>
          <target state="translated">La &lt;code&gt;encoding&lt;/code&gt; subcomando devuelve una respuesta masiva.</target>
        </trans-unit>
        <trans-unit id="03e52fefcd721e1070e1756817dc5fb3908630a4" translate="yes" xml:space="preserve">
          <source>Subcommands &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;idletime&lt;/code&gt; return integers.</source>
          <target state="translated">Los subcomandos &lt;code&gt;refcount&lt;/code&gt; y &lt;code&gt;idletime&lt;/code&gt; devuelven n&amp;uacute;meros enteros.</target>
        </trans-unit>
        <trans-unit id="9cdf88a718c3f491225fa1cc2fd76602c7208ad1" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the given patterns.</source>
          <target state="translated">Suscribe al cliente a los patrones dados.</target>
        </trans-unit>
        <trans-unit id="481c5cf231fde7f8730860922d6f3194fc5f2170" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the specified channels.</source>
          <target state="translated">Suscribe al cliente a los canales especificados.</target>
        </trans-unit>
        <trans-unit id="4a47fd9934d349f948abbf361726590ff096c6b8" translate="yes" xml:space="preserve">
          <source>Summary form of XPENDING</source>
          <target state="translated">Forma resumida de XPENDING</target>
        </trans-unit>
        <trans-unit id="dfe7ee6f8d575326187ecdb8ea7e6fb7cbf4ec35" translate="yes" xml:space="preserve">
          <source>Supported glob-style patterns:</source>
          <target state="translated">Patrones de estilo global apoyados:</target>
        </trans-unit>
        <trans-unit id="ced890cac00d712740bdc4d39c1db48f7483c499" translate="yes" xml:space="preserve">
          <source>Supported subcommands and integer types</source>
          <target state="translated">Subcomandos y tipos enteros soportados</target>
        </trans-unit>
        <trans-unit id="108e22a5749de8f07b0272d8029eeb2811ea28dd" translate="yes" xml:space="preserve">
          <source>Switch the connection to a different protocol. Redis version 6 or greater are able to support two protocols, the old protocol, RESP2, and a new one introduced with Redis 6, RESP3. RESP3 has certain advantages since when the connection is in this mode, Redis is able to reply with more semantical replies: for instance &lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt; will return a &lt;em&gt;map type&lt;/em&gt;, so a client library implementation no longer requires to know in advance to translate the array into a hash before returning it to the caller. For a full coverage of RESP3 please &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;check this repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8398e47e81dab008569a234703960eb8bab2f11" translate="yes" xml:space="preserve">
          <source>TAKEOVER option: manual failover without cluster consensus</source>
          <target state="translated">Opción TAKEOVER:conmutación manual sin consenso del grupo</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="8696f7a4c64b4516c2d96434e8b7824957a37d2a" translate="yes" xml:space="preserve">
          <source>TIME   Return the current server time</source>
          <target state="translated">TIEMPO Devuelve la hora actual del servidor</target>
        </trans-unit>
        <trans-unit id="c701f5f92060225c236ac0e6b3051e03bb0ad061" translate="yes" xml:space="preserve">
          <source>TOUCH</source>
          <target state="translated">TOUCH</target>
        </trans-unit>
        <trans-unit id="ad5ae533c502772151a704d28a2bece0e0f4ca1b" translate="yes" xml:space="preserve">
          <source>TOUCH  key [key ...]   Alters the last access time of a key(s). Returns the number of existing keys specified.</source>
          <target state="translated">Tecla TOQUE [tecla ...]Altera el último tiempo de acceso de una o varias teclas.Devuelve el número de teclas existentes especificadas.</target>
        </trans-unit>
        <trans-unit id="878260dfb888c3312c119e6db2253c2aa207ae98" translate="yes" xml:space="preserve">
          <source>TTL</source>
          <target state="translated">TTL</target>
        </trans-unit>
        <trans-unit id="8ef7742bd419d3406904eb9723c6ce85d49c0f81" translate="yes" xml:space="preserve">
          <source>TTL  key   Get the time to live for a key</source>
          <target state="translated">Llave TTL Obtener el tiempo para vivir por una llave</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="7d0cfb250d49bba162e019907ea71cfcab32d9f4" translate="yes" xml:space="preserve">
          <source>TYPE  key   Determine the type stored at key</source>
          <target state="translated">TYPE key Determinar el tipo almacenado en la tecla</target>
        </trans-unit>
        <trans-unit id="5bbc08d2de04a7034dc9edbe2e20759367a5f82f" translate="yes" xml:space="preserve">
          <source>Taking a separated key that is incremented every time the bitmap is modified. This can be very efficient and atomic using a small Redis Lua script.</source>
          <target state="translated">Tomando una clave separada que se incrementa cada vez que se modifica el mapa de bits.Esto puede ser muy eficiente y atómico usando una pequeña escritura Redis Lua.</target>
        </trans-unit>
        <trans-unit id="8b5d4fb8b75675d300f4de7425675abc3149473f" translate="yes" xml:space="preserve">
          <source>Terminating iterations in the middle</source>
          <target state="translated">Terminar las iteraciones en el medio</target>
        </trans-unit>
        <trans-unit id="8a78f0cb0822107a63b906522f8970fb02d3906a" translate="yes" xml:space="preserve">
          <source>Test 20 random keys from the set of keys with an associated expire.</source>
          <target state="translated">Pruebe 20 claves aleatorias del conjunto de claves con un vencimiento asociado.</target>
        </trans-unit>
        <trans-unit id="0c0c5f66ed89ad8b7f73f25128b137a4d67fcbb8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; and the analogous &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; commands, you can use Redis strings as a linear array with O(1) random access. This is a very fast and efficient storage in many real world use cases.</source>
          <target state="translated">Gracias a &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; y los comandos &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; an&amp;aacute;logos , puede usar cadenas de Redis como una matriz lineal con acceso aleatorio O (1). Este es un almacenamiento muy r&amp;aacute;pido y eficiente en muchos casos de uso del mundo real.</target>
        </trans-unit>
        <trans-unit id="8026b8ed5921c819cac7c44288be64954a1b0af5" translate="yes" xml:space="preserve">
          <source>That is, the second occurrence of &quot;c&quot; is at position 6. A negative &quot;rank&quot; as the &lt;code&gt;RANK&lt;/code&gt; argument tells &lt;a href=&quot;lpos&quot;&gt;LPOS&lt;/a&gt; to invert the search direction, starting from the tail to the head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733be8ce43bb740e68f58527c40732d288c9eb0b" translate="yes" xml:space="preserve">
          <source>That said, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; can be used, and was historically used, as a locking primitive. For example, to acquire the lock of the key &lt;code&gt;foo&lt;/code&gt;, the client could try the following:</source>
          <target state="translated">Dicho esto, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; se puede usar, y se us&amp;oacute; hist&amp;oacute;ricamente, como una primitiva de bloqueo. Por ejemplo, para adquirir la cerradura de la llave &lt;code&gt;foo&lt;/code&gt; , el cliente podr&amp;iacute;a intentar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b0aa14a2afe89147b651f01c25f18c35b9adb8d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;acl-help&quot;&gt;ACL HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d6d135447dbf512e1ae2af8102405447c9f874" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; command can be used to create a very compact representation of a list of fixed-size samples, usually referred as &lt;em&gt;time series&lt;/em&gt;. Every time a new sample arrives we can store it using the command</source>
          <target state="translated">El comando &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; se puede utilizar para crear una representaci&amp;oacute;n muy compacta de una lista de muestras de tama&amp;ntilde;o fijo, generalmente denominadas &lt;em&gt;series de tiempo&lt;/em&gt; . Cada vez que llega una nueva muestra podemos almacenarla usando el comando</target>
        </trans-unit>
        <trans-unit id="af3680004f1f3af89a74cfdd597524f1d5b57aa0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; command supports four bitwise operations: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;, &lt;strong&gt;XOR&lt;/strong&gt; and &lt;strong&gt;NOT&lt;/strong&gt;, thus the valid forms to call the command are:</source>
          <target state="translated">El comando &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; admite cuatro operaciones bit a bit: &lt;strong&gt;AND&lt;/strong&gt; , &lt;strong&gt;OR&lt;/strong&gt; , &lt;strong&gt;XOR&lt;/strong&gt; y &lt;strong&gt;NOT&lt;/strong&gt; , por lo que las formas v&amp;aacute;lidas para llamar al comando son:</target>
        </trans-unit>
        <trans-unit id="4dd66d959585425a19858f722e901be8748f987c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; returns the name of the current connection as set by &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;. Since every new connection starts without an associated name, if no name was assigned a null bulk reply is returned.</source>
          <target state="translated">El &lt;a href=&quot;client-getname&quot;&gt;GETNAME CLIENTE&lt;/a&gt; devuelve el nombre de la conexi&amp;oacute;n actual como conjunto por &lt;a href=&quot;client-setname&quot;&gt;SETNAME CLIENTE&lt;/a&gt; . Dado que cada nueva conexi&amp;oacute;n comienza sin un nombre asociado, si no se asign&amp;oacute; ning&amp;uacute;n nombre, se devuelve una respuesta masiva nula.</target>
        </trans-unit>
        <trans-unit id="1660d56ff9988d9b97b8e4b556121bfa1958f2dd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. This command support two formats, the old format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77571e239b6c4924e5ae8625b133ece1b2fb165b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. Up to Redis 2.8.11 it was possible to close a connection only by client address, using the following form:</source>
          <target state="translated">El comando &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; cierra una conexi&amp;oacute;n de cliente determinada. Hasta Redis 2.8.11 era posible cerrar una conexi&amp;oacute;n solo por la direcci&amp;oacute;n del cliente, usando el siguiente formulario:</target>
        </trans-unit>
        <trans-unit id="c0d7e72efd1901513aa26d76fc6efa880b0ffcd7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command returns information and statistics about the client connections server in a mostly human readable format.</source>
          <target state="translated">El comando &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; devuelve informaci&amp;oacute;n y estad&amp;iacute;sticas sobre el servidor de conexiones del cliente en un formato legible principalmente por humanos.</target>
        </trans-unit>
        <trans-unit id="99ea497bab9ec2eb991df932e164aeadc0d98009" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; command controls whether the server will reply the client's commands. The following modes are available:</source>
          <target state="translated">El comando &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; controla si el servidor responder&amp;aacute; a los comandos del cliente. Est&amp;aacute;n disponibles los siguientes modos:</target>
        </trans-unit>
        <trans-unit id="66ef05bc81ce96b58454a695580464830edc9445" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command assigns a name to the current connection.</source>
          <target state="translated">El comando &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; asigna un nombre a la conexi&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="43f3ab9bcc1ea0150ec08bf3548ed1a84c95f9e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-bumpepoch&quot;&gt;CLUSTER BUMPEPOCH&lt;/a&gt; command triggers an increment to the cluster's config epoch from the connected node. The epoch will be incremented if the node's config epoch is zero, or if it is less than the cluster's greatest epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5540561e37398d0ed7b865d91ceff7a71f6377" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-flushslots&quot;&gt;CLUSTER FLUSHSLOTS&lt;/a&gt; deletes all information about slots from the connected node. It can only be called when the database is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca5f595e917e610d79a666d6599f3f325569dcf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-myid&quot;&gt;CLUSTER MYID&lt;/a&gt; command returns the unique, auto-generated identifier that is associated with the connected cluster node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ca3ac0a9d2f6b99b3b3cfed122170d73c27a26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command is an important piece used by Redis Cluster in order to migrate all the keys contained in one hash slot from one node to another. This is how the migration is orchestrated, with the help of other commands as well. We'll call the node that has the current ownership of the hash slot the &lt;code&gt;source&lt;/code&gt; node, and the node where we want to migrate the &lt;code&gt;destination&lt;/code&gt; node.</source>
          <target state="translated">El comando &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; es una pieza importante utilizada por Redis Cluster para migrar todas las claves contenidas en una ranura hash de un nodo a otro. As&amp;iacute; es como se organiza la migraci&amp;oacute;n, tambi&amp;eacute;n con la ayuda de otros comandos. Llamaremos al nodo que tiene la propiedad actual de la ranura hash el nodo de &lt;code&gt;source&lt;/code&gt; y al nodo al que queremos migrar el nodo de &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9969254dbf9ad62d16ce54578a579c12bed90714" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; command is used to read the configuration parameters of a running Redis server. Not all the configuration parameters are supported in Redis 2.4, while Redis 2.6 can read the whole configuration of a server using this command.</source>
          <target state="translated">El comando &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; se utiliza para leer los par&amp;aacute;metros de configuraci&amp;oacute;n de un servidor Redis en ejecuci&amp;oacute;n. No todos los par&amp;aacute;metros de configuraci&amp;oacute;n son compatibles con Redis 2.4, mientras que Redis 2.6 puede leer la configuraci&amp;oacute;n completa de un servidor usando este comando.</target>
        </trans-unit>
        <trans-unit id="b44e010365af8a822e0e64c895b3b9356396e69b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; command rewrites the &lt;code&gt;redis.conf&lt;/code&gt; file the server was started with, applying the minimal changes needed to make it reflect the configuration currently used by the server, which may be different compared to the original one because of the use of the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command.</source>
          <target state="translated">El comando &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; reescribe el archivo &lt;code&gt;redis.conf&lt;/code&gt; con el que se inici&amp;oacute; el servidor, aplicando los cambios m&amp;iacute;nimos necesarios para que refleje la configuraci&amp;oacute;n utilizada actualmente por el servidor, que puede ser diferente a la original debido al uso del &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; mando.</target>
        </trans-unit>
        <trans-unit id="a94ff0d50f7b4db45f039a4dafafa3f4c9259a89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command is used in order to reconfigure the server at run time without the need to restart Redis. You can change both trivial parameters or switch from one to another persistence option using this command.</source>
          <target state="translated">El comando &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; se utiliza para reconfigurar el servidor en tiempo de ejecuci&amp;oacute;n sin la necesidad de reiniciar Redis. Puede cambiar ambos par&amp;aacute;metros triviales o cambiar de una a otra opci&amp;oacute;n de persistencia usando este comando.</target>
        </trans-unit>
        <trans-unit id="166c68e394d8ab06f1a3bb76f56f32a612a6683d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command forces you to send the script body again and again. Redis does not need to recompile the script every time as it uses an internal caching mechanism, however paying the cost of the additional bandwidth may not be optimal in many contexts.</source>
          <target state="translated">El comando &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; te obliga a enviar el cuerpo del script una y otra vez. Redis no necesita volver a compilar el script cada vez que utiliza un mecanismo de almacenamiento en cach&amp;eacute; interno, sin embargo, pagar el costo del ancho de banda adicional puede no ser &amp;oacute;ptimo en muchos contextos.</target>
        </trans-unit>
        <trans-unit id="bd6411fae08a91e9b321232ed876a3d9070cad9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; family of commands is able to associate an expire to a given key, at the cost of some additional memory used by the key. When a key has an expire set, Redis will make sure to remove the key when the specified amount of time elapsed.</source>
          <target state="translated">La familia de comandos &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; puede asociar una expiraci&amp;oacute;n a una clave determinada, a costa de una memoria adicional utilizada por la clave. Cuando una clave tiene un vencimiento establecido, Redis se asegurar&amp;aacute; de quitar la clave cuando haya transcurrido el tiempo especificado.</target>
        </trans-unit>
        <trans-unit id="9537af381c721635428a198bca98f65d00f50bfa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command has a useful reply that will state a number of facts about the server: the exact version, the set of modules loaded, the client ID, the replication role and so forth. Because of that, and given that the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command also works with &quot;2&quot; as argument, both in order to downgrade the protocol back to version 2, or just to get the reply from the server without switching the protocol, client library authors may consider using this command instead of the canonical &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt; when setting up the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae44c019fde6841c16a68c04d38047f2e0f60739" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command returns information and statistics about the server in a format that is simple to parse by computers and easy to read by humans.</source>
          <target state="translated">El comando &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; devuelve informaci&amp;oacute;n y estad&amp;iacute;sticas sobre el servidor en un formato que es f&amp;aacute;cil de analizar por computadoras y f&amp;aacute;cil de leer por humanos.</target>
        </trans-unit>
        <trans-unit id="a72bec6083e79854302b4e9ff14a0e8f3e859562" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-doctor&quot;&gt;LATENCY DOCTOR&lt;/a&gt; command reports about different latency-related issues and advises about possible remedies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1066b09a9b25b6b6ed879ca10e517428a219419a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-help&quot;&gt;LATENCY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50807ff2bf2c847fd5988e426fdf8c05c9a36546" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-history&quot;&gt;LATENCY HISTORY&lt;/a&gt; command returns the raw data of the &lt;code&gt;event&lt;/code&gt;'s latency spikes time series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c78093ad61fe69ebb2499c714e0f2256697635" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-latest&quot;&gt;LATENCY LATEST&lt;/a&gt; command reports the latest latency events logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147880a1d1ea91581373c0559cd3dfedfc864e5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-reset&quot;&gt;LATENCY RESET&lt;/a&gt; command resets the latency spikes time series of all, or only some, events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c3a5fba12b1ed2508a72f81c29ed6c56b41d88" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; command reports about different memory-related issues that the Redis server experiences, and advises about possible remedies.</source>
          <target state="translated">El comando &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; informa sobre diferentes problemas relacionados con la memoria que experimenta el servidor Redis y aconseja sobre posibles soluciones.</target>
        </trans-unit>
        <trans-unit id="09f518db007c555b3fc51849cb715d5f37978149" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">El comando &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; devuelve un texto &amp;uacute;til que describe los diferentes subcomandos.</target>
        </trans-unit>
        <trans-unit id="ff16e624359e33f1f97dfa1a1d20188c59460b7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATS&lt;/a&gt; command provides an internal statistics report from the memory allocator.</source>
          <target state="translated">El comando &lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATS&lt;/a&gt; proporciona un informe de estad&amp;iacute;sticas internas del asignador de memoria.</target>
        </trans-unit>
        <trans-unit id="abed28f03c444a07fa9a013ee06dd6217f071068" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-purge&quot;&gt;MEMORY PURGE&lt;/a&gt; command attempts to purge dirty pages so these can be reclaimed by the allocator.</source>
          <target state="translated">El comando &lt;a href=&quot;memory-purge&quot;&gt;MEMORY PURGE&lt;/a&gt; intenta purgar las p&amp;aacute;ginas sucias para que el asignador pueda reclamarlas.</target>
        </trans-unit>
        <trans-unit id="6661981989e0edd2ff7e2bf5fdb3e79066d8b8f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; command returns an &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; about the memory usage of the server.</source>
          <target state="translated">El comando &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; devuelve una &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;respuesta de matriz&lt;/a&gt; sobre el uso de memoria del servidor.</target>
        </trans-unit>
        <trans-unit id="753fff2843cf4f675766fb16f94fa6b171989202" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-usage&quot;&gt;MEMORY USAGE&lt;/a&gt; command reports the number of bytes that a key and its value require to be stored in RAM.</source>
          <target state="translated">El comando &lt;a href=&quot;memory-usage&quot;&gt;MEMORY USAGE&lt;/a&gt; informa el n&amp;uacute;mero de bytes que una clave y su valor requieren para ser almacenados en RAM.</target>
        </trans-unit>
        <trans-unit id="2af70a6f2971f44c0c1aa28591f8b6524acbcca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command allows to inspect the internals of Redis Objects associated with keys. It is useful for debugging or to understand if your keys are using the specially encoded data types to save space. Your application may also use the information reported by the &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command to implement application level key eviction policies when using Redis as a Cache.</source>
          <target state="translated">El comando &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; permite inspeccionar el interior de los Objetos de Redis asociados con las claves. Es &amp;uacute;til para depurar o para comprender si sus claves est&amp;aacute;n utilizando tipos de datos especialmente codificados para ahorrar espacio. Su aplicaci&amp;oacute;n tambi&amp;eacute;n puede usar la informaci&amp;oacute;n proporcionada por el comando &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; para implementar pol&amp;iacute;ticas de desalojo de claves a nivel de aplicaci&amp;oacute;n cuando usa Redis como cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="eea48beebb7220fe5ecc2f8e71ddc8ce2e90d62c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command supports multiple sub commands:</source>
          <target state="translated">El comando &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; admite varios subcomandos:</target>
        </trans-unit>
        <trans-unit id="ca3cc9ef5973b2b3ef21bdff9c9e13b41c03044f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt; command is called by Redis replicas for initiating a replication stream from the master.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc73cb913e243c94705a7071cd05dd7f69ae35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; command can change the replication settings of a replica on the fly.</source>
          <target state="translated">El comando &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; puede cambiar la configuraci&amp;oacute;n de replicaci&amp;oacute;n de una r&amp;eacute;plica sobre la marcha.</target>
        </trans-unit>
        <trans-unit id="4ce9249bde2a45fd1e0f497151a2d69b16bbda13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rpushx&quot;&gt;RPUSHX&lt;/a&gt; command only pushes the element if the key already exists.</source>
          <target state="translated">El comando &lt;a href=&quot;rpushx&quot;&gt;RPUSHX&lt;/a&gt; solo empuja el elemento si la clave ya existe.</target>
        </trans-unit>
        <trans-unit id="614a32f854070cdcbbba350287fb7c58ac067da4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; commands performs a &lt;strong&gt;synchronous&lt;/strong&gt; save of the dataset producing a &lt;em&gt;point in time&lt;/em&gt; snapshot of all the data inside the Redis instance, in the form of an RDB file.</source>
          <target state="translated">Los comandos &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; realizan un guardado &lt;strong&gt;sincr&amp;oacute;nico&lt;/strong&gt; del conjunto de datos que produce una instant&amp;aacute;nea de un &lt;em&gt;punto en el tiempo&lt;/em&gt; de todos los datos dentro de la instancia de Redis, en forma de un archivo RDB.</target>
        </trans-unit>
        <trans-unit id="67466c1875af0bcc544ed2934fa216ebaf0fb8ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; algorithm is guaranteed to terminate only if the size of the iterated collection remains bounded to a given maximum size, otherwise iterating a collection that always grows may result into &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to never terminate a full iteration.</source>
          <target state="translated">Se garantiza que el algoritmo &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; terminar&amp;aacute; solo si el tama&amp;ntilde;o de la colecci&amp;oacute;n iterada permanece limitado a un tama&amp;ntilde;o m&amp;aacute;ximo dado; de lo contrario, la iteraci&amp;oacute;n de una colecci&amp;oacute;n que siempre crece puede dar como resultado que &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; nunca termine una iteraci&amp;oacute;n completa.</target>
        </trans-unit>
        <trans-unit id="9b83fdceccccced73f803ea3fe0587ccedbc5d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command and the closely related commands &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; are used in order to incrementally iterate over a collection of elements.</source>
          <target state="translated">El comando &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; y los comandos &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; y &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; estrechamente relacionados se utilizan para iterar de forma incremental sobre una colecci&amp;oacute;n de elementos.</target>
        </trans-unit>
        <trans-unit id="debbeaf11369c9e161ae3c316731408d752cc02f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command, and the other commands in the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family, are able to provide to the user a set of guarantees associated to full iterations.</source>
          <target state="translated">El comando &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; y los dem&amp;aacute;s comandos de la familia &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; pueden proporcionar al usuario un conjunto de garant&amp;iacute;as asociadas a iteraciones completas.</target>
        </trans-unit>
        <trans-unit id="1745a85b233cd9864512e1af6c727c0eb8686c05" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command supports a set of options that modify its behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bb1ffaa9cf08918dd7437412b9271325c4076a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; command can change the replication settings of a replica on the fly. If a Redis server is already acting as replica, the command &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">El comando &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; puede cambiar la configuraci&amp;oacute;n de replicaci&amp;oacute;n de una r&amp;eacute;plica sobre la marcha. Si un servidor Redis ya est&amp;aacute; actuando como r&amp;eacute;plica, el comando &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NADIE apagar&amp;aacute; la r&amp;eacute;plica, convirtiendo el servidor Redis en un MAESTRO. En la forma adecuada, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port har&amp;aacute; que el servidor sea una r&amp;eacute;plica de otro servidor que escucha en el nombre de host y puerto especificados.</target>
        </trans-unit>
        <trans-unit id="0ff4cdfae050eccc9a56820c72e2716bcf7a7f22" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sync&quot;&gt;SYNC&lt;/a&gt; command is called by Redis replicas for initiating a replication stream from the master. It has been replaced in newer versions of Redis by &lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3e1b27429bbc884368294b8f7962375860257e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command returns the current server time as a two items lists: a Unix timestamp and the amount of microseconds already elapsed in the current second. Basically the interface is very similar to the one of the &lt;code&gt;gettimeofday&lt;/code&gt; system call.</source>
          <target state="translated">El comando &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; devuelve la hora actual del servidor como una lista de dos elementos: una marca de tiempo Unix y la cantidad de microsegundos ya transcurridos en el segundo actual. B&amp;aacute;sicamente, la interfaz es muy similar a la de la llamada al sistema &lt;code&gt;gettimeofday&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70be0ca493bf011ad2206bbde68c46ec552ad130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command removes one or multiple messages from the &lt;em&gt;pending entries list&lt;/em&gt; (PEL) of a stream consumer group. A message is pending, and as such stored inside the PEL, when it was delivered to some consumer, normally as a side effect of calling &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, or when a consumer took ownership of a message calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. The pending message was delivered to some consumer but the server is yet not sure it was processed at least once. So new calls to &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; to grab the messages history for a consumer (for instance using an ID of 0), will return such message. Similarly the pending message will be listed by the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command, that inspects the PEL.</source>
          <target state="translated">El comando &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; elimina uno o varios mensajes de la &lt;em&gt;lista de entradas pendientes&lt;/em&gt; (PEL) de un grupo de consumidores de flujo. Un mensaje est&amp;aacute; pendiente y, como tal, almacenado dentro del PEL, cuando se entreg&amp;oacute; a alg&amp;uacute;n consumidor, normalmente como un efecto secundario de llamar a &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; , o cuando un consumidor tom&amp;oacute; posesi&amp;oacute;n de un mensaje que llama a &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; . El mensaje pendiente se entreg&amp;oacute; a alg&amp;uacute;n consumidor, pero el servidor a&amp;uacute;n no est&amp;aacute; seguro de que se haya procesado al menos una vez. Entonces, las nuevas llamadas a &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; para obtener el historial de mensajes de un consumidor (por ejemplo, usando un ID de 0), devolver&amp;aacute;n dicho mensaje. De manera similar, el mensaje pendiente ser&amp;aacute; listado por el comando &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; , que inspecciona el PEL.</target>
        </trans-unit>
        <trans-unit id="7dd37542831e217f80423791c1758b898b47cbcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command allows iterating over the pending entries just like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; and &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; allow for the stream's entries. You can do this by prefixing the ID of the last-read pending entry with the &lt;code&gt;(&lt;/code&gt; character that denotes an open (exclusive) range, and proving it to the subsequent call to the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f919fa1bdb0a477435ee790e9628136dda8f63ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command is the interface to inspect the list of pending messages, and is as thus a very important command in order to observe and understand what is happening with a streams consumer groups: what clients are active, what messages are pending to be consumed, or to see if there are idle messages. Moreover this command, together with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; is used in order to implement recovering of consumers that are failing for a long time, and as a result certain messages are not processed: a different consumer can claim the message and continue. This is better explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;streams intro&lt;/a&gt; and in the &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; command page, and is not covered here.</source>
          <target state="translated">El comando &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; es la interfaz para inspeccionar la lista de mensajes pendientes, por lo que es un comando muy importante para observar y comprender lo que est&amp;aacute; sucediendo con un grupo de consumidores de streams: qu&amp;eacute; clientes est&amp;aacute;n activos, qu&amp;eacute; mensajes est&amp;aacute;n pendientes de ser consumidos, o para ver si hay mensajes inactivos. Adem&amp;aacute;s, este comando, junto con &lt;a href=&quot;xclaim&quot;&gt;XCLAIM,&lt;/a&gt; se utiliza para implementar la recuperaci&amp;oacute;n de consumidores que fallan durante mucho tiempo y, como resultado, ciertos mensajes no se procesan: un consumidor diferente puede reclamar el mensaje y continuar. Esto se explica mejor en la &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introducci&amp;oacute;n de secuencias&lt;/a&gt; y en la p&amp;aacute;gina de comandos de &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; , y no se trata aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="be7aa14ec80fad3a57ca56d203c2ac6e1198edd2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; command has a number of applications:</source>
          <target state="translated">El comando &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; tiene varias aplicaciones:</target>
        </trans-unit>
        <trans-unit id="1033731d720ba1e5c57d34f9f982462de081667c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command is a special version of the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command with support for consumer groups. Probably you will have to understand the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command before reading this page will makes sense.</source>
          <target state="translated">El comando &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; es una versi&amp;oacute;n especial del comando &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; con soporte para grupos de consumidores. Probablemente tendr&amp;aacute; que entender el comando &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; antes de que leer esta p&amp;aacute;gina tenga sentido.</target>
        </trans-unit>
        <trans-unit id="7ac305f70170c901011610af97e0bc42f712f0a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; ID is effectively just exactly as specifying &lt;code&gt;0-0&lt;/code&gt;, while &lt;code&gt;+&lt;/code&gt; is equivalent to &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt;, however they are nicer to type.</source>
          <target state="translated">El &lt;code&gt;-&lt;/code&gt; ID es exactamente igual que la especificaci&amp;oacute;n &lt;code&gt;0-0&lt;/code&gt; , mientras que &lt;code&gt;+&lt;/code&gt; es equivalente a &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt; , sin embargo, son m&amp;aacute;s agradables de escribir.</target>
        </trans-unit>
        <trans-unit id="ad556b3da4050d845b9c3a874361828db5c442a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; special IDs mean respectively the minimum ID possible and the maximum ID possible inside a stream, so the following command will just return every entry in the stream:</source>
          <target state="translated">Las ID especiales &lt;code&gt;-&lt;/code&gt; y &lt;code&gt;+&lt;/code&gt; significan respectivamente la ID m&amp;iacute;nima posible y la ID m&amp;aacute;xima posible dentro de una secuencia, por lo que el siguiente comando solo devolver&amp;aacute; cada entrada en la secuencia:</target>
        </trans-unit>
        <trans-unit id="7b7c72e7ac11e971e25ca474ee3da37e97621a8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option can also take a non-existent key, which causes &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; to skip the sorting operation. This is useful if you want to retrieve external keys (see the &lt;code&gt;GET&lt;/code&gt; option below) without the overhead of sorting.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;BY&lt;/code&gt; tambi&amp;eacute;n puede tomar una clave inexistente, lo que hace que &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; omita la operaci&amp;oacute;n de clasificaci&amp;oacute;n. Esto es &amp;uacute;til si desea recuperar claves externas (vea la opci&amp;oacute;n &lt;code&gt;GET&lt;/code&gt; a continuaci&amp;oacute;n) sin la sobrecarga de ordenar.</target>
        </trans-unit>
        <trans-unit id="04d5c46b7c9e4c0432ac2f85c4c63dc2b3333abd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option takes a pattern (equal to &lt;code&gt;weight_*&lt;/code&gt; in this example) that is used to generate the keys that are used for sorting. These key names are obtained substituting the first occurrence of &lt;code&gt;*&lt;/code&gt; with the actual value of the element in the list (&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; in this example).</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;BY&lt;/code&gt; toma un patr&amp;oacute;n (igual a &lt;code&gt;weight_*&lt;/code&gt; en este ejemplo) que se usa para generar las claves que se usan para ordenar. Estos nombres de clave se obtienen sustituyendo la primera aparici&amp;oacute;n de &lt;code&gt;*&lt;/code&gt; con el valor real del elemento en la lista ( &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; en este ejemplo).</target>
        </trans-unit>
        <trans-unit id="bd7cf93ba7657f4f2966769280d74bac3ba29a14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COUNT&lt;/code&gt; option is used to limit the amount of stream/PEL entries that are returned (The first &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; entries are returned). The default &lt;code&gt;COUNT&lt;/code&gt; is 10 and a &lt;code&gt;COUNT&lt;/code&gt; of 0 means that all entries will be returned (Execution time may be long if the stream has a lot of entries)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7781d414a168c2c6071c960ca2a2f476d429921c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELSLOTS&lt;/code&gt; command asks a particular Redis Cluster node to forget which master is serving the hash slots specified as arguments.</source>
          <target state="translated">El comando &lt;code&gt;DELSLOTS&lt;/code&gt; le pide a un nodo de Redis Cluster en particular que olvide qu&amp;eacute; maestro est&amp;aacute; sirviendo las ranuras hash especificadas como argumentos.</target>
        </trans-unit>
        <trans-unit id="f40cf7905426fe2efaf1d7bb82912ca46b5d481b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; option can be used multiple times in order to get more keys for every element of the original list, set or sorted set.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;GET&lt;/code&gt; se puede utilizar varias veces para obtener m&amp;aacute;s claves para cada elemento de la lista original, conjunto o conjunto ordenado.</target>
        </trans-unit>
        <trans-unit id="d2200d7bc7ff4797c7f7c14add0d36376defba47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ID&lt;/code&gt; filter only returns entries for clients with IDs matching the &lt;code&gt;client-id&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692cd27ca778c52fb164170863c312f93a4febd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOACK&lt;/code&gt; subcommand can be used to avoid adding the message to the PEL in cases where reliability is not a requirement and the occasional message loss is acceptable. This is equivalent to acknowledging the message when it is read.</source>
          <target state="translated">El subcomando &lt;code&gt;NOACK&lt;/code&gt; se puede utilizar para evitar agregar el mensaje al PEL en los casos en que la confiabilidad no es un requisito y la p&amp;eacute;rdida ocasional del mensaje es aceptable. Esto equivale a reconocer el mensaje cuando se lee.</target>
        </trans-unit>
        <trans-unit id="70ae9c69379861ae43b186cc1aea347b195c9116" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NODE&lt;/code&gt; subcommand is the one with the most complex semantics. It associates the hash slot with the specified node, however the command works only in specific situations and has different side effects depending on the slot state. The following is the set of pre-conditions and side effects of the command:</source>
          <target state="translated">El subcomando &lt;code&gt;NODE&lt;/code&gt; es el que tiene la sem&amp;aacute;ntica m&amp;aacute;s compleja. Asocia la ranura hash con el nodo especificado, sin embargo, el comando funciona solo en situaciones espec&amp;iacute;ficas y tiene diferentes efectos secundarios seg&amp;uacute;n el estado de la ranura. El siguiente es el conjunto de condiciones previas y efectos secundarios del comando:</target>
        </trans-unit>
        <trans-unit id="f3353a302ef9a9215dfe9198dea9a7e8ef365e65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aof_delayed_fsync&lt;/code&gt; counter</source>
          <target state="translated">El contador &lt;code&gt;aof_delayed_fsync&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b5f4a6fffad95a3f4be7e216981db9fcd1d6fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; argument is available since version 3.2.</source>
          <target state="translated">El argumento de &lt;code&gt;count&lt;/code&gt; est&amp;aacute; disponible desde la versi&amp;oacute;n 3.2.</target>
        </trans-unit>
        <trans-unit id="8ce90da51cb5b392562f97eba72b463845c11c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip:port&lt;/code&gt; should match a line returned by the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command (&lt;code&gt;addr&lt;/code&gt; field).</source>
          <target state="translated">El &lt;code&gt;ip:port&lt;/code&gt; debe coincidir con una l&amp;iacute;nea devuelta por el comando &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; ( campo &lt;code&gt;addr&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5777eb84fcb1170d8747af88e5c07f98feb04ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;message&lt;/code&gt; argument is simply a string. Example:</source>
          <target state="translated">El argumento del &lt;code&gt;message&lt;/code&gt; es simplemente una cadena. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="9ea110d8be26fa3611a695ea1e98f388ddefd010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same meaning as described for &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">Los argumentos &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; tienen el mismo significado que se describe para &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="109dd07703928b5f87b169ad0c30d69a49fafa5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same semantic as described for &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">Los argumentos &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; tienen la misma sem&amp;aacute;ntica que se describe para &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07c405abf8ce41269def6794789e4d59831e2dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;score&lt;/code&gt; value should be the string representation of a numeric value, and accepts double precision floating point numbers. It is possible to provide a negative value to decrement the score.</source>
          <target state="translated">El valor de la &lt;code&gt;score&lt;/code&gt; debe ser la representaci&amp;oacute;n de cadena de un valor num&amp;eacute;rico y acepta n&amp;uacute;meros de coma flotante de doble precisi&amp;oacute;n. Es posible proporcionar un valor negativo para disminuir la puntuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4192359597f0ce567f180b8ce4e1911ba0a4fee7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as a double value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f5712887288aace7cb25c9ca1f98dbdf6c03f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an double value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4c3a5926b2e82699f6692683e7c60016ad3961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an integer value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">El argumento de &lt;code&gt;timeout&lt;/code&gt; se interpreta como un valor entero que especifica el n&amp;uacute;mero m&amp;aacute;ximo de segundos para bloquear. Se puede usar un tiempo de espera de cero para bloquear indefinidamente.</target>
        </trans-unit>
        <trans-unit id="1ad755fb1756745bfb0855cce9d6737683c771bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument is the same string name that the &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; command returns. Note a quirk where some Redis types, such as GeoHashes, HyperLogLogs, Bitmaps, and Bitfields, may internally be implemented using other Redis types, such as a string or zset, so can't be distinguished from other keys of that same type by &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;. For example, a ZSET and GEOHASH:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70e592aaa3d9e8f7df4a512dc479e926a2adbc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; argument between the &lt;strong&gt;MAXLEN&lt;/strong&gt; option and the actual count means that the user is not really requesting that the stream length is exactly 1000 items, but instead it could be a few tens of entries more, but never less than 1000 items. When this option modifier is used, the trimming is performed only when Redis is able to remove a whole macro node. This makes it much more efficient, and it is usually what you want.</source>
          <target state="translated">El argumento &lt;code&gt;~&lt;/code&gt; entre la opci&amp;oacute;n &lt;strong&gt;MAXLEN&lt;/strong&gt; y el recuento real significa que el usuario no est&amp;aacute; solicitando realmente que la longitud del flujo sea exactamente 1000 elementos, sino que podr&amp;iacute;a ser unas pocas decenas de entradas m&amp;aacute;s, pero nunca menos de 1000 elementos. Cuando se usa este modificador de opci&amp;oacute;n, el recorte se realiza solo cuando Redis puede eliminar un macro nodo completo. Esto lo hace mucho m&amp;aacute;s eficiente y, por lo general, es lo que desea.</target>
        </trans-unit>
        <trans-unit id="ea8b5fbf2699e6884711237f84a50ed662e87dcb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;STREAMS&lt;/strong&gt; option is mandatory and MUST be the final option because such option gets a variable length of argument in the following format:</source>
          <target state="translated">La opci&amp;oacute;n &lt;strong&gt;STREAMS&lt;/strong&gt; es obligatoria y DEBE ser la &amp;uacute;ltima opci&amp;oacute;n porque dicha opci&amp;oacute;n obtiene una longitud variable de argumento en el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="f1467c9ba6d40cf52b5cdae46604d845510d3c66" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TAKEOVER&lt;/strong&gt; option implies everything &lt;strong&gt;FORCE&lt;/strong&gt; implies, but also does not uses any cluster authorization in order to failover. A replica receiving &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; will instead:</source>
          <target state="translated">La opci&amp;oacute;n &lt;strong&gt;TAKEOVER&lt;/strong&gt; implica todo lo que &lt;strong&gt;FORCE&lt;/strong&gt; implica, pero tampoco utiliza ninguna autorizaci&amp;oacute;n de cl&amp;uacute;ster para realizar la conmutaci&amp;oacute;n por error. En su lugar, una r&amp;eacute;plica que reciba &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="706ee50ff413a981311879f38f0325b685e418ae" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cluster&lt;/strong&gt; section currently only contains a unique field:</source>
          <target state="translated">El &lt;strong&gt;grupo de&lt;/strong&gt; la secci&amp;oacute;n en la actualidad s&amp;oacute;lo contiene un campo &amp;uacute;nico:</target>
        </trans-unit>
        <trans-unit id="e18469751043e4051869a86bbcba03716b45e346" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;commandstats&lt;/strong&gt; section provides statistics based on the command type, including the number of calls, the total CPU time consumed by these commands, and the average CPU consumed per command execution.</source>
          <target state="translated">La secci&amp;oacute;n &lt;strong&gt;commandstats&lt;/strong&gt; proporciona estad&amp;iacute;sticas basadas en el tipo de comando, incluido el n&amp;uacute;mero de llamadas, el tiempo total de CPU consumido por estos comandos y el CPU promedio consumido por ejecuci&amp;oacute;n de comando.</target>
        </trans-unit>
        <trans-unit id="f90c39a55fa63248e76899e871ade6a1431c29d1" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;keyspace&lt;/strong&gt; section provides statistics on the main dictionary of each database. The statistics are the number of keys, and the number of keys with an expiration.</source>
          <target state="translated">La secci&amp;oacute;n de &lt;strong&gt;espacio de claves&lt;/strong&gt; proporciona estad&amp;iacute;sticas sobre el diccionario principal de cada base de datos. Las estad&amp;iacute;sticas son el n&amp;uacute;mero de claves y el n&amp;uacute;mero de claves con vencimiento.</target>
        </trans-unit>
        <trans-unit id="3a0202270041736b1216ba5baa1f54459be4f741" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;modules&lt;/strong&gt; section contains additional information about loaded modules if the modules provide it. The field part of properties lines in this section is always prefixed with the module's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac8492c1e70ee526ecccc4abef734bddc537815" translate="yes" xml:space="preserve">
          <source>The AUTH command authenticates the current connection in two cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff483a1ce1f770bdb2f62a76889e8f7ada78a73" translate="yes" xml:space="preserve">
          <source>The CJSON library provides extremely fast JSON manipulation within Lua.</source>
          <target state="translated">La biblioteca de CJSON proporciona una manipulación extremadamente rápida de JSON dentro de Lua.</target>
        </trans-unit>
        <trans-unit id="7530389adb107898a8e0437c53cce50bad07ea36" translate="yes" xml:space="preserve">
          <source>The COUNT option</source>
          <target state="translated">La opción COUNT</target>
        </trans-unit>
        <trans-unit id="e8dffa28f7261bfe8a1090fc2b6db1ae98bb313f" translate="yes" xml:space="preserve">
          <source>The HyperLogLog data structure can be used in order to count &lt;strong&gt;unique&lt;/strong&gt; elements in a set using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog (plus a few bytes for the key itself).</source>
          <target state="translated">La estructura de datos de HyperLogLog se puede usar para contar elementos &lt;strong&gt;&amp;uacute;nicos&lt;/strong&gt; en un conjunto usando solo una peque&amp;ntilde;a cantidad constante de memoria, espec&amp;iacute;ficamente 12k bytes para cada HyperLogLog (m&amp;aacute;s algunos bytes para la clave en s&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="5d5e9e7569c5ac826ef312fb92859c0deffb60e9" translate="yes" xml:space="preserve">
          <source>The HyperLogLog, being a Redis string, can be retrieved with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; and restored with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. Calling &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;, &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; or &lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt; commands with a corrupted HyperLogLog is never a problem, it may return random values but does not affect the stability of the server. Most of the times when corrupting a sparse representation, the server recognizes the corruption and returns an error.</source>
          <target state="translated">El HyperLogLog, que es una cadena de Redis, se puede recuperar con &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; y restaurar con &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; . Llamar &lt;a href=&quot;pfadd&quot;&gt;comandos PFADD&lt;/a&gt; , &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; o &lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt; con un HyperLogLog da&amp;ntilde;ado nunca es un problema, puede devolver valores aleatorios pero no afecta la estabilidad del servidor. La mayor&amp;iacute;a de las veces, cuando se corrompe una representaci&amp;oacute;n escasa, el servidor reconoce la corrupci&amp;oacute;n y devuelve un error.</target>
        </trans-unit>
        <trans-unit id="b9ffa717a680ea863704c9d4cbe178090dee5908" translate="yes" xml:space="preserve">
          <source>The ID is monotonically incremental. If the ID of a connection is greater than the ID of another connection, it is guaranteed that the second connection was established with the server at a later time.</source>
          <target state="translated">La identificación es monótonamente incremental.Si el ID de una conexión es mayor que el ID de otra conexión,se garantiza que la segunda conexión se estableció con el servidor en un momento posterior.</target>
        </trans-unit>
        <trans-unit id="7f2d6cad55038bdb71cc5342903dad20539f48ed" translate="yes" xml:space="preserve">
          <source>The ID is never reset in the course of the Redis server execution, only a server restart will reset it.</source>
          <target state="translated">El ID nunca se reinicia en el curso de la ejecución del servidor de Redis,sólo un reinicio del servidor lo reiniciará.</target>
        </trans-unit>
        <trans-unit id="5028f5e06740630088beea552d56dbc9a9d96305" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just add 1 to the sequence to obtain &lt;code&gt;1526985685298-1&lt;/code&gt;, and continue our iteration:</source>
          <target state="translated">El ID de la &amp;uacute;ltima entrada es &lt;code&gt;1526985685298-0&lt;/code&gt; , por lo que solo agregamos 1 a la secuencia para obtener &lt;code&gt;1526985685298-1&lt;/code&gt; y continuamos nuestra iteraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="7eefbc13fad88639889dfca1eea5bd903a412b2f" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just prefix it with a '(', and continue our iteration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc0d85cea060a3580771bdafcea7e5bc90996bb" translate="yes" xml:space="preserve">
          <source>The ID of the message.</source>
          <target state="translated">La identificación del mensaje.</target>
        </trans-unit>
        <trans-unit id="10ecce9f88d9ae56cb1bcd6efbec98fbc1a5f68e" translate="yes" xml:space="preserve">
          <source>The ID to specify in the &lt;strong&gt;STREAMS&lt;/strong&gt; option when using &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; can be one of the following two:</source>
          <target state="translated">El ID para especificar en la opci&amp;oacute;n &lt;strong&gt;STREAMS&lt;/strong&gt; cuando se usa &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; puede ser uno de los siguientes dos:</target>
        </trans-unit>
        <trans-unit id="a5addd3dd6a1b78a37c68a12e4b0f086415a0b5b" translate="yes" xml:space="preserve">
          <source>The IP of the master.</source>
          <target state="translated">La IP del maestro.</target>
        </trans-unit>
        <trans-unit id="5bcb92df23fdb05d8a0140fd9087b6b631c09793" translate="yes" xml:space="preserve">
          <source>The LCS subcommand implements the longest common subsequence algorithm. Note that this is different than the longest common string algorithm, since matching characters in the string does not need to be contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e326a0ab79090e9945701455a9f67576780adbaf" translate="yes" xml:space="preserve">
          <source>The LOLWUT command displays the Redis version: however as a side effect of doing so, it also creates a piece of generative computer art that is different with each version of Redis. The command was introduced in Redis 5 and announced with this &lt;a href=&quot;http://antirez.com/news/123&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f53ea350a50177374bcdd35f9332bb81e5298f0" translate="yes" xml:space="preserve">
          <source>The Lua Bit Operations Module adds bitwise operations on numbers. It is available for scripting in Redis since version 2.8.18.</source>
          <target state="translated">El módulo de operaciones de Lua Bit añade operaciones de bits en los números.Está disponible para scripts en Redis desde la versión 2.8.18.</target>
        </trans-unit>
        <trans-unit id="1051d37718542a5598a286cc56e5f5aaafbf73d5" translate="yes" xml:space="preserve">
          <source>The Lua PRNG in this mode is seeded randomly at every call.</source>
          <target state="translated">El Lua PRNG en este modo es sembrado al azar en cada llamada.</target>
        </trans-unit>
        <trans-unit id="a8d85991ddfb0f169b9f806f86a3cc0413e31e4e" translate="yes" xml:space="preserve">
          <source>The Lua debugger is described in the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Lua scripts debugging&lt;/a&gt; section of the Redis documentation.</source>
          <target state="translated">El depurador de Lua se describe en la secci&amp;oacute;n de &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;depuraci&amp;oacute;n de scripts de Lua&lt;/a&gt; de la documentaci&amp;oacute;n de Redis.</target>
        </trans-unit>
        <trans-unit id="4515a3f12b04929b3987b1647823726616d895eb" translate="yes" xml:space="preserve">
          <source>The Lua engine always assumes to run in RESP2 mode when talking with Redis, so whatever the connection that is invoking the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; or &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command is in RESP2 or RESP3 mode, Lua scripts will, by default, still see the same kind of replies they used to see in the past from Redis, when calling commands using the &lt;code&gt;redis.call()&lt;/code&gt; built-in function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a696a748eaeb904c163e6d11e4f1f007a0ef038" translate="yes" xml:space="preserve">
          <source>The MATCH option</source>
          <target state="translated">La opción MATCH</target>
        </trans-unit>
        <trans-unit id="4eb0859176601ed31b0ed60fbf24deb7442f3423" translate="yes" xml:space="preserve">
          <source>The PUBSUB command is an introspection command that allows to inspect the state of the Pub/Sub subsystem. It is composed of subcommands that are documented separately. The general form is:</source>
          <target state="translated">El comando PUBSUB es un comando de introspección que permite inspeccionar el estado del subsistema Pub/Sub.Está compuesto por subcomandos que se documentan por separado.La forma general es:</target>
        </trans-unit>
        <trans-unit id="82e7a6dd485996953664282bec28fa4f1043afe7" translate="yes" xml:space="preserve">
          <source>The Redis Lua interpreter loads the following Lua libraries:</source>
          <target state="translated">El intérprete de Redis Lua carga las siguientes bibliotecas de Lua:</target>
        </trans-unit>
        <trans-unit id="bb0c5eade03c486c5f8281c1da8633f26a4b714d" translate="yes" xml:space="preserve">
          <source>The Redis Slow Log is a system to log queries that exceeded a specified execution time. The execution time does not include I/O operations like talking with the client, sending the reply and so forth, but just the time needed to actually execute the command (this is the only stage of command execution where the thread is blocked and can not serve other requests in the meantime).</source>
          <target state="translated">El Redis Slow Log es un sistema para registrar las consultas que superan un tiempo de ejecución especificado.El tiempo de ejecución no incluye operaciones de E/S como hablar con el cliente,enviar la respuesta,etc.,sino sólo el tiempo necesario para ejecutar realmente el comando (esta es la única etapa de ejecución del comando en la que el hilo se bloquea y no puede servir a otras peticiones mientras tanto).</target>
        </trans-unit>
        <trans-unit id="63b3dcb2e93d3c4b06fb3ccd03dd7de69fb04d43" translate="yes" xml:space="preserve">
          <source>The SCRIPT command</source>
          <target state="translated">El comando SCRIPT</target>
        </trans-unit>
        <trans-unit id="7b0199097175bc8f260d469794e2e96bed7dab06" translate="yes" xml:space="preserve">
          <source>The STRALGO implements complex algorithms that operate on strings. Right now the only algorithm implemented is the LCS algorithm (longest common substring). However new algorithms could be implemented in the future. The goal of this command is to provide to Redis users algorithms that need fast implementations and are normally not provided in the standard library of most programming languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04ad115145f4340fd6a7e75d3c008104af8a7d2" translate="yes" xml:space="preserve">
          <source>The TYPE option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9be29f5758f4e3311e10dd99d11effd38e89f6" translate="yes" xml:space="preserve">
          <source>The ability to see all the requests processed by the server is useful in order to spot bugs in an application both when using Redis as a database and as a distributed caching system.</source>
          <target state="translated">La capacidad de ver todas las solicitudes procesadas por el servidor es útil para detectar errores en una aplicación tanto cuando se utiliza Redis como base de datos como sistema de caché distribuido.</target>
        </trans-unit>
        <trans-unit id="a9a4c4b85d74e390cf97f77d86569a9c392136a7" translate="yes" xml:space="preserve">
          <source>The above command will create a user called &lt;code&gt;virginia&lt;/code&gt; that is active (the on rule), can access any key (allkeys rule), and can call the set command (+set rule). Then another SETUSER call can modify the user rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f195a8757b1d8a55a19d37ee9ad3a22c5c0a4e17" translate="yes" xml:space="preserve">
          <source>The above makes it very simple to implement a system where a set of items must be processed by N workers continuously as fast as possible. An example is a monitoring system that must check that a set of web sites are reachable, with the smallest delay possible, using a number of parallel workers.</source>
          <target state="translated">Lo anterior hace que sea muy sencillo implementar un sistema en el que un conjunto de artículos debe ser procesado por N trabajadores de forma continua y lo más rápido posible.Un ejemplo es un sistema de vigilancia que debe comprobar que un conjunto de sitios web son accesibles,con la menor demora posible,utilizando un número de trabajadores paralelos.</target>
        </trans-unit>
        <trans-unit id="75a3a44602ce55e23d207b895b5a485f6d4a2fc0" translate="yes" xml:space="preserve">
          <source>The above pattern works even if the following two conditions:</source>
          <target state="translated">El patrón anterior funciona incluso si se dan las dos condiciones siguientes:</target>
        </trans-unit>
        <trans-unit id="27a55611f4365743e826db0b0f9378c4a66a4f67" translate="yes" xml:space="preserve">
          <source>The above rule will not apply the new rule to the user virginia, so other than &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, the user virginia will now be able to also use the &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d153745d60911da280f1df79b2e372158711e77" translate="yes" xml:space="preserve">
          <source>The above script sets the key &lt;code&gt;foo&lt;/code&gt; to the string &lt;code&gt;bar&lt;/code&gt;. However it violates the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command semantics as all the keys that the script uses should be passed using the &lt;code&gt;KEYS&lt;/code&gt; array:</source>
          <target state="translated">El script anterior establece la clave &lt;code&gt;foo&lt;/code&gt; en la &lt;code&gt;bar&lt;/code&gt; ra de cadenas . Sin embargo, viola la sem&amp;aacute;ntica del comando &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; ya que todas las claves que usa el script deben pasarse usando la matriz &lt;code&gt;KEYS&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0dd21e93f4a7ab544f682629858a1ca7196710f4" translate="yes" xml:space="preserve">
          <source>The additional elements of the array depends on the role.</source>
          <target state="translated">Los elementos adicionales del conjunto dependen de la función.</target>
        </trans-unit>
        <trans-unit id="b4c1764b30cb0625e6c253a27bb41e84ea603d9e" translate="yes" xml:space="preserve">
          <source>The algorithm used, that is implemented inside dict.c, samples the hash table buckets to find a non-empty one. Once a non empty bucket is found, since we use chaining in our hash table implementation, the number of elements inside the bucket is checked and a random element is selected.</source>
          <target state="translated">El algoritmo utilizado,que se implementa dentro del dict.c,muestrea los cubos de la mesa de hash para encontrar uno no vacío.Una vez que se encuentra un cubo no vacío,ya que usamos encadenamiento en nuestra implementación de la tabla de hachís,se comprueba el número de elementos dentro del cubo y se selecciona un elemento al azar.</target>
        </trans-unit>
        <trans-unit id="6de2e476596fcaba51a4ddd43e2a8bd4d48c346f" translate="yes" xml:space="preserve">
          <source>The amount of data received from the replica so far in terms of master replication offset.</source>
          <target state="translated">La cantidad de datos recibidos de la réplica hasta ahora en términos de compensación de la réplica maestra.</target>
        </trans-unit>
        <trans-unit id="5d8b8009ef4dd06c8c025f1eed58b5b1787f1f48" translate="yes" xml:space="preserve">
          <source>The amount of time needed for its execution, in microseconds.</source>
          <target state="translated">La cantidad de tiempo necesaria para su ejecución,en microsegundos.</target>
        </trans-unit>
        <trans-unit id="e5407b8706df1e8319a7a989bf68d7ad75911c3a" translate="yes" xml:space="preserve">
          <source>The approximated number of unique elements observed via &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;.</source>
          <target state="translated">El n&amp;uacute;mero aproximado de elementos &amp;uacute;nicos observados mediante &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d3457f0c58f45dac774e34be45c19b72f462db2" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;redis.call()&lt;/code&gt; and &lt;code&gt;redis.pcall()&lt;/code&gt; functions are all the arguments of a well formed Redis command:</source>
          <target state="translated">Los argumentos de las &lt;code&gt;redis.call()&lt;/code&gt; y &lt;code&gt;redis.pcall()&lt;/code&gt; son todos los argumentos de un comando de Redis bien formado:</target>
        </trans-unit>
        <trans-unit id="120865be87c8e6ca3cb347b65ffdefe018090581" translate="yes" xml:space="preserve">
          <source>The array composing the arguments of the command.</source>
          <target state="translated">La matriz que compone los argumentos del comando.</target>
        </trans-unit>
        <trans-unit id="a010440d8c2596df424c379b3133bfd83782f2d9" translate="yes" xml:space="preserve">
          <source>The assigned name is displayed in the output of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; so that it is possible to identify the client that performed a given connection.</source>
          <target state="translated">El nombre asignado se muestra en la salida de la &lt;a href=&quot;client-list&quot;&gt;LISTA DE CLIENTES&lt;/a&gt; para que sea posible identificar al cliente que realiz&amp;oacute; una conexi&amp;oacute;n determinada.</target>
        </trans-unit>
        <trans-unit id="885f9339188f139f7b1172052e203973f59a224e" translate="yes" xml:space="preserve">
          <source>The basic idea is that nodes by default don't trust each other, and are considered unknown, so that it is unlikely that different cluster nodes will mix into a single one because of system administration errors or network addresses modifications.</source>
          <target state="translated">La idea básica es que los nodos por defecto no se confían entre sí y se consideran desconocidos,por lo que es poco probable que diferentes nodos del grupo se mezclen en uno solo debido a errores de administración del sistema o a modificaciones de las direcciones de la red.</target>
        </trans-unit>
        <trans-unit id="d3155ed9386ade27ef1929683ef41081fb15be86" translate="yes" xml:space="preserve">
          <source>The basic usage is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9c85f3c202fdd59f8f147e36c3ec1f770f703e" translate="yes" xml:space="preserve">
          <source>The behavior of Redis 2.4 creates a lot of problems when replicating or persisting data into the AOF file, so the much more generic and semantically simpler behavior was introduced into Redis 2.6 to prevent problems.</source>
          <target state="translated">El comportamiento de Redis 2.4 crea muchos problemas al replicar o persistir los datos en el archivo AOF,por lo que se introdujo un comportamiento mucho más genérico y semánticamente simple en Redis 2.6 para evitar problemas.</target>
        </trans-unit>
        <trans-unit id="b344dc2bc04bb34933613eb7044804cab8c272df" translate="yes" xml:space="preserve">
          <source>The binary nature of the comparison allows to use sorted sets as a general purpose index, for example the first part of the element can be a 64 bit big endian number: since big endian numbers have the most significant bytes in the initial positions, the binary comparison will match the numerical comparison of the numbers. This can be used in order to implement range queries on 64 bit values. As in the example below, after the first 8 bytes we can store the value of the element we are actually indexing.</source>
          <target state="translated">La naturaleza binaria de la comparación permite utilizar conjuntos ordenados como un índice de propósito general,por ejemplo la primera parte del elemento puede ser un número indían grande de 64 bits:dado que los números indían grandes tienen los bytes más significativos en las posiciones iniciales,la comparación binaria coincidirá con la comparación numérica de los números.Esto puede utilizarse para implementar consultas de rango en valores de 64 bits.Como en el ejemplo siguiente,después de los primeros 8 bytes podemos almacenar el valor del elemento que estamos indexando realmente.</target>
        </trans-unit>
        <trans-unit id="f19a05fbdb75f958bfa6f09541362b1de2c7798d" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3282d877e14a9e1a4f618e1ae58563eb55cb394" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1. When &lt;em&gt;key&lt;/em&gt; does not exist, a new string value is created. The string is grown to make sure it can hold a bit at &lt;em&gt;offset&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; argument is required to be greater than or equal to 0, and smaller than 2&lt;sup&gt;32&lt;/sup&gt; (this limits bitmaps to 512MB). When the string at &lt;em&gt;key&lt;/em&gt; is grown, added bits are set to 0.</source>
          <target state="translated">El bit se establece o se borra seg&amp;uacute;n el &lt;em&gt;valor&lt;/em&gt; , que puede ser 0 o 1. Cuando la &lt;em&gt;clave&lt;/em&gt; no existe, se crea un nuevo valor de cadena. La cuerda crece para asegurarse de que pueda aguantar un poco en el &lt;em&gt;desplazamiento&lt;/em&gt; . Se requiere que el argumento de &lt;em&gt;desplazamiento&lt;/em&gt; sea ​​mayor o igual a 0 y menor que 2 &lt;sup&gt;32&lt;/sup&gt; (esto limita los mapas de bits a 512 MB). Cuando la cadena en la &lt;em&gt;clave&lt;/em&gt; crece, los bits agregados se establecen en 0.</target>
        </trans-unit>
        <trans-unit id="0b7af7df323735c0dce87d77fcd93c888e45e3a0" translate="yes" xml:space="preserve">
          <source>The client explicitly checks the &lt;code&gt;runid&lt;/code&gt; field in the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command in order to make sure the server was not restarted and is still the same process.</source>
          <target state="translated">El cliente verifica expl&amp;iacute;citamente el campo &lt;code&gt;runid&lt;/code&gt; en el comando &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; para asegurarse de que el servidor no se reinici&amp;oacute; y sigue siendo el mismo proceso.</target>
        </trans-unit>
        <trans-unit id="9350ca0340f5b792f129eec734a9c6029b8bad38" translate="yes" xml:space="preserve">
          <source>The client flags can be a combination of:</source>
          <target state="translated">Las banderas de los clientes pueden ser una combinación de:</target>
        </trans-unit>
        <trans-unit id="ef7c4ea851346ff688f43804007664e07a0ee9aa" translate="yes" xml:space="preserve">
          <source>The client library implementation can always optimistically send &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; under the hood even when the client actually calls &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;, in the hope the script was already seen by the server. If the &lt;code&gt;NOSCRIPT&lt;/code&gt; error is returned &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will be used instead.</source>
          <target state="translated">La implementaci&amp;oacute;n de la biblioteca cliente siempre puede enviar &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; bajo el cap&amp;oacute; de manera optimista incluso cuando el cliente realmente llama a &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; , con la esperanza de que el servidor ya haya visto el script. Si se devuelve el error &lt;code&gt;NOSCRIPT&lt;/code&gt; , se utilizar&amp;aacute; &lt;a href=&quot;eval&quot;&gt;EVAL en&lt;/a&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="5dfcddce441b9e425d29945dfa151dd5838c9e0e" translate="yes" xml:space="preserve">
          <source>The client library implementation should take one of the following approaches:</source>
          <target state="translated">La aplicación de la biblioteca de clientes debería adoptar uno de los siguientes enfoques:</target>
        </trans-unit>
        <trans-unit id="cea5f73089ab49d55692f68c7533b954be4a4271" translate="yes" xml:space="preserve">
          <source>The client sent a command about hash slots never served by the master of this replica.</source>
          <target state="translated">El cliente envió un comando sobre ranuras de hachís nunca servidas por el maestro de esta réplica.</target>
        </trans-unit>
        <trans-unit id="4f3cae0941780fdfb0d5aa096cbd40be72c4d373" translate="yes" xml:space="preserve">
          <source>The client will have to acknowledge the message processing using &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; in order for the pending entry to be removed from the PEL. The PEL can be inspected using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">El cliente tendr&amp;aacute; que acusar recibo del procesamiento del mensaje usando &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; para que la entrada pendiente sea eliminada del PEL. El PEL se puede inspeccionar usando el comando &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82fd513f621c09ac0869a99d08b31390f0bc842b" translate="yes" xml:space="preserve">
          <source>The cluster was reconfigured (for example resharded) and the replica is no longer able to serve commands for a given hash slot.</source>
          <target state="translated">El cúmulo se reconfiguró (por ejemplo,se volvió a endurecer)y la réplica ya no es capaz de servir comandos para una determinada ranura de hachís.</target>
        </trans-unit>
        <trans-unit id="9940f805fd9de379d7d0c58cd1b84f3338b5e58f" translate="yes" xml:space="preserve">
          <source>The cmsgpack library provides simple and fast MessagePack manipulation within Lua.</source>
          <target state="translated">La biblioteca del cmsgpack proporciona una simple y rápida manipulación del MessagePack dentro de Lua.</target>
        </trans-unit>
        <trans-unit id="0b9bb30b2dbe12e3fa62af10a99007a2ae4848a9" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is also able to iterate the stream. The command &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; can iterate the stream reverse, from higher IDs (or times) to lower IDs (or times).</source>
          <target state="translated">El comando &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; tambi&amp;eacute;n puede iterar la secuencia. El comando &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; puede iterar el flujo inverso, desde ID m&amp;aacute;s altos (o tiempos) a ID m&amp;aacute;s bajos (o tiempos).</target>
        </trans-unit>
        <trans-unit id="4fbd17702a2c89af4ecc45167e7c6a7b02c943ed" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; is a simple way to implement a locking system with Redis.</source>
          <target state="translated">El comando &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; es una forma sencilla de implementar un sistema de bloqueo con Redis.</target>
        </trans-unit>
        <trans-unit id="2dbda62e4a8fd31c5ca6fc1f4cddf22961ead108" translate="yes" xml:space="preserve">
          <source>The command &lt;strong&gt;will always return&lt;/strong&gt; the number of replicas that acknowledged the write commands sent before the &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; command, both in the case where the specified number of replicas are reached, or when the timeout is reached.</source>
          <target state="translated">El comando &lt;strong&gt;siempre devolver&amp;aacute;&lt;/strong&gt; el n&amp;uacute;mero de r&amp;eacute;plicas que reconocieron los comandos de escritura enviados antes del comando &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; , tanto en el caso en el que se alcanza el n&amp;uacute;mero especificado de r&amp;eacute;plicas como cuando se alcanza el tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="4a44b122481ff3652c96ef6533c739e783fe19c3" translate="yes" xml:space="preserve">
          <source>The command also has a reciprocal command returning items in the reverse order, called &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;, which is otherwise identical.</source>
          <target state="translated">El comando tambi&amp;eacute;n tiene un comando rec&amp;iacute;proco que devuelve elementos en el orden inverso, llamado &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; , que por lo dem&amp;aacute;s es id&amp;eacute;ntico.</target>
        </trans-unit>
        <trans-unit id="b51d9780c5d61a87b53bd27d3ac5c24a4b0638d8" translate="yes" xml:space="preserve">
          <source>The command behavior can be modified by two options: &lt;strong&gt;FORCE&lt;/strong&gt; and &lt;strong&gt;TAKEOVER&lt;/strong&gt;.</source>
          <target state="translated">El comportamiento del comando se puede modificar con dos opciones: &lt;strong&gt;FORZAR&lt;/strong&gt; y &lt;strong&gt;TOMAR&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0e77b773bc1837b920cb41a24e1a0ef629792be6" translate="yes" xml:space="preserve">
          <source>The command behavior is the following:</source>
          <target state="translated">El comportamiento del comando es el siguiente:</target>
        </trans-unit>
        <trans-unit id="913ef9d1ec1890a263c7a3667b134a3de340bd38" translate="yes" xml:space="preserve">
          <source>The command can accept a variable number of arguments so it always returns an array of positions even when a single element is specified.</source>
          <target state="translated">El comando puede aceptar un número variable de argumentos,por lo que siempre devuelve una serie de posiciones,incluso cuando se especifica un solo elemento.</target>
        </trans-unit>
        <trans-unit id="b9a60a6fc9ab713863d0cdace7cfdb88da1428ea" translate="yes" xml:space="preserve">
          <source>The command can be called with four different arguments:</source>
          <target state="translated">El comando puede ser llamado con cuatro argumentos diferentes:</target>
        </trans-unit>
        <trans-unit id="d2095dc05dd59018ca256f0a5fc566c35f0f4cc7" translate="yes" xml:space="preserve">
          <source>The command default is to return unsorted items. Two different sorting methods can be invoked using the following two options:</source>
          <target state="translated">El comando por defecto es devolver los artículos sin clasificar.Se pueden invocar dos métodos de clasificación diferentes utilizando las dos opciones siguientes:</target>
        </trans-unit>
        <trans-unit id="958832c31d8e5542b245102310cbd53d9f34320f" translate="yes" xml:space="preserve">
          <source>The command does not succeed and returns an error in the following cases:</source>
          <target state="translated">El comando no tiene éxito y devuelve un error en los siguientes casos:</target>
        </trans-unit>
        <trans-unit id="32a8711ea8a78a0226239432ccf720cba86e66af" translate="yes" xml:space="preserve">
          <source>The command fails if the same slot is specified multiple times.</source>
          <target state="translated">El comando falla si se especifica la misma ranura varias veces.</target>
        </trans-unit>
        <trans-unit id="b6f1f38c10e41d6cb188193c5859a8d2a04588ed" translate="yes" xml:space="preserve">
          <source>The command has multiple options, however most are mainly for internal use in order to transfer the effects of &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; or other commands to the AOF file and to propagate the same effects to the slaves, and are unlikely to be useful to normal users:</source>
          <target state="translated">El comando tiene m&amp;uacute;ltiples opciones, sin embargo, la mayor&amp;iacute;a son principalmente para uso interno para transferir los efectos de &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; u otros comandos al archivo AOF y propagar los mismos efectos a los esclavos, y es poco probable que sean &amp;uacute;tiles para usuarios normales:</target>
        </trans-unit>
        <trans-unit id="aff611203495e6eb730550d71c578dbd6ea9eaee" translate="yes" xml:space="preserve">
          <source>The command internally uses &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; to generate the serialized version of the key value, and &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; in order to synthesize the key in the target instance. The source instance acts as a client for the target instance. If the target instance returns OK to the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command, the source instance deletes the key using &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;.</source>
          <target state="translated">El comando utiliza internamente &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; para generar la versi&amp;oacute;n serializada del valor de la clave y &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; para sintetizar la clave en la instancia de destino. La instancia de origen act&amp;uacute;a como cliente de la instancia de destino. Si la instancia de destino devuelve OK al comando &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; , la instancia de origen elimina la clave usando &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8dc74da7f9aeeb2a318e48a6c60e1183a0da365" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">El comando siempre se propaga en el enlace de replicaci&amp;oacute;n y en el archivo &lt;a href=&quot;hset&quot;&gt;adjuntar&lt;/a&gt; solo como una operaci&amp;oacute;n HSET , de modo que las diferencias en la implementaci&amp;oacute;n matem&amp;aacute;tica de punto flotante subyacente no ser&amp;aacute;n fuentes de inconsistencia.</target>
        </trans-unit>
        <trans-unit id="89297d1be1338bce5eaa89c5524f124377b2d8a5" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">El comando siempre se propaga en el enlace de replicaci&amp;oacute;n y en el archivo de solo adjuntar como una operaci&amp;oacute;n &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; , de modo que las diferencias en la implementaci&amp;oacute;n matem&amp;aacute;tica de punto flotante subyacente no ser&amp;aacute;n fuentes de inconsistencia.</target>
        </trans-unit>
        <trans-unit id="a86933f06a2ba31db5ee212ee8cc903bc3c40f34" translate="yes" xml:space="preserve">
          <source>The command is atomic and blocks the two instances for the time required to transfer the key, at any given time the key will appear to exist in a given instance or in the other instance, unless a timeout error occurs. In 3.2 and above, multiple keys can be pipelined in a single call to &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; by passing the empty string (&quot;&quot;) as key and adding the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; clause.</source>
          <target state="translated">El comando es at&amp;oacute;mico y bloquea las dos instancias durante el tiempo necesario para transferir la clave; en cualquier momento, la clave parecer&amp;aacute; existir en una instancia determinada o en la otra instancia, a menos que se produzca un error de tiempo de espera. En 3.2 y superior, se pueden canalizar varias claves en una sola llamada a &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; pasando la cadena vac&amp;iacute;a (&quot;&quot;) como clave y agregando la cl&amp;aacute;usula &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4335b586f31c83a0ae96d3ccf6ca0cfaf3a8429" translate="yes" xml:space="preserve">
          <source>The command is used in order to remove a node, specified via its node ID, from the set of &lt;em&gt;known nodes&lt;/em&gt; of the Redis Cluster node receiving the command. In other words the specified node is removed from the &lt;em&gt;nodes table&lt;/em&gt; of the node receiving the command.</source>
          <target state="translated">El comando se utiliza para eliminar un nodo, especificado a trav&amp;eacute;s de su ID de nodo, del conjunto de &lt;em&gt;nodos conocidos&lt;/em&gt; del nodo Redis Cluster que recibe el comando. En otras palabras, el nodo especificado se elimina de la &lt;em&gt;tabla&lt;/em&gt; de nodos del nodo que recibe el comando.</target>
        </trans-unit>
        <trans-unit id="9389c07b5be98086699ffdc71ab5655cfb6ab6aa" translate="yes" xml:space="preserve">
          <source>The command just returns the ID of the current connection. Every connection ID has certain guarantees:</source>
          <target state="translated">El comando sólo devuelve el ID de la conexión actual.Cada ID de conexión tiene ciertas garantías:</target>
        </trans-unit>
        <trans-unit id="1e36a1bc65a56400c52d66e29f9ce1757bbf2e26" translate="yes" xml:space="preserve">
          <source>The command may fail with an error for several reasons: if the file cannot be written or if the server is not configured to use an external ACL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344468f4b5f6d51949f0a2c14063fc0a3b852987" translate="yes" xml:space="preserve">
          <source>The command may fail with an error for several reasons: if the file is not readable, if there is an error inside the file, and in such case the error will be reported to the user in the error. Finally the command will fail if the server is not configured to use an external ACL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa2b5549f1c670208cc851a7701050140450874" translate="yes" xml:space="preserve">
          <source>The command may reply with an error in certain cases, as documented above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d0753b06a3754e2b6097d7df536fcb852c4ed" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are already associated with some node.</source>
          <target state="translated">El comando sólo funciona si todas las ranuras especificadas ya están asociadas a algún nodo.</target>
        </trans-unit>
        <trans-unit id="43abdb47aec6d5ef3beb1e76ddc4c6370f0f6354" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are, from the point of view of the node receiving the command, currently not assigned. A node will refuse to take ownership for slots that already belong to some other node (including itself).</source>
          <target state="translated">El comando sólo funciona si todos los slots especificados están,desde el punto de vista del nodo que recibe el comando,actualmente no asignados.Un nodo se negará a asumir la propiedad de los slots que ya pertenecen a otro nodo (incluido él mismo).</target>
        </trans-unit>
        <trans-unit id="63f80c4f55dda4254e917500ebea54b888f88f18" translate="yes" xml:space="preserve">
          <source>The command optionally returns additional information using the following options:</source>
          <target state="translated">El comando devuelve opcionalmente información adicional utilizando las siguientes opciones:</target>
        </trans-unit>
        <trans-unit id="94c796162b217920f7fda542eef1c135d9fe60f2" translate="yes" xml:space="preserve">
          <source>The command output is an hexadecimal representation of a binary string. By default it emits 256 bits (so 64 hex characters). The user can provide an argument in form of number of bits to emit from 1 to 1024 to change the output length. Note that the number of bits provided is always rounded to the next multiple of 4. So for instance asking for just 1 bit password will result in 4 bits to be emitted, in the form of a single hex character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f65176db9808f7847abb3d37f52b1528a65ac2" translate="yes" xml:space="preserve">
          <source>The command performs the following actions:</source>
          <target state="translated">El comando realiza las siguientes acciones:</target>
        </trans-unit>
        <trans-unit id="4778a65d0ba749aa47da2ae16d4895853e331c48" translate="yes" xml:space="preserve">
          <source>The command provides a list of replica nodes replicating from the specified master node. The list is provided in the same format used by &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; (please refer to its documentation for the specification of the format).</source>
          <target state="translated">El comando proporciona una lista de nodos de r&amp;eacute;plica que se replican desde el nodo principal especificado. La lista se proporciona en el mismo formato utilizado por &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; (consulte su documentaci&amp;oacute;n para la especificaci&amp;oacute;n del formato).</target>
        </trans-unit>
        <trans-unit id="75946e7c075807ac0ec08889c9ae03a9a184e3d3" translate="yes" xml:space="preserve">
          <source>The command reconfigures a node as a replica of the specified master. If the node receiving the command is an &lt;em&gt;empty master&lt;/em&gt;, as a side effect of the command, the node role is changed from master to replica.</source>
          <target state="translated">El comando reconfigura un nodo como una r&amp;eacute;plica del maestro especificado. Si el nodo que recibe el comando es un &lt;em&gt;maestro vac&amp;iacute;o&lt;/em&gt; , como efecto secundario del comando, la funci&amp;oacute;n del nodo se cambia de maestro a r&amp;eacute;plica.</target>
        </trans-unit>
        <trans-unit id="4ebd54c736f27aa3986d5c357015059ce2df6b55" translate="yes" xml:space="preserve">
          <source>The command returns 11 characters Geohash strings, so no precision is loss compared to the Redis internal 52 bit representation. The returned Geohashes have the following properties:</source>
          <target state="translated">El comando devuelve cadenas Geohash de 11 caracteres,por lo que no hay pérdida de precisión en comparación con la representación interna de 52 bits de Redis.Los Geohashes devueltos tienen las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="68e0628c08bc7ef387bda65ff2fbb36117fe6040" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-1&lt;/code&gt; if the key exists but has no associated expire.</source>
          <target state="translated">El comando devuelve &lt;code&gt;-1&lt;/code&gt; si la clave existe pero no tiene una expiraci&amp;oacute;n asociada.</target>
        </trans-unit>
        <trans-unit id="9900e726bbbfd1d7f718d4225bf8abc8e591a526" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-2&lt;/code&gt; if the key does not exist.</source>
          <target state="translated">El comando devuelve &lt;code&gt;-2&lt;/code&gt; si la clave no existe.</target>
        </trans-unit>
        <trans-unit id="263f04bc6090861d15e393e44fe1a4d42bd2408e" translate="yes" xml:space="preserve">
          <source>The command returns a &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt; when used with the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option and the key doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf3ff8b30b845ead44db4d82109c56f01457aed" translate="yes" xml:space="preserve">
          <source>The command returns all the messages successfully claimed, in the same format as &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;. However if the &lt;code&gt;JUSTID&lt;/code&gt; option was specified, only the message IDs are reported, without including the actual message.</source>
          <target state="translated">El comando devuelve todos los mensajes reclamados con &amp;eacute;xito, en el mismo formato que &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; . Sin embargo, si se especific&amp;oacute; la opci&amp;oacute;n &lt;code&gt;JUSTID&lt;/code&gt; , solo se informan los ID de mensaje, sin incluir el mensaje real.</target>
        </trans-unit>
        <trans-unit id="d91929db6b639c8bbfadd32a8fc0bdbaccdfc27a" translate="yes" xml:space="preserve">
          <source>The command returns all the rules defined for an existing ACL user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a71cfae2a2b43a889c9e6bd259963281080b15" translate="yes" xml:space="preserve">
          <source>The command returns an array of elements. The first element is the role of the instance, as one of the following three strings:</source>
          <target state="translated">El comando devuelve un conjunto de elementos.El primer elemento es el papel de la instancia,como una de las tres cadenas siguientes:</target>
        </trans-unit>
        <trans-unit id="aa91d91e133acc78d18bba2922ce5bd5a6f7f354" translate="yes" xml:space="preserve">
          <source>The command returns an array of keys names stored in the contacted node and hashing to the specified hash slot. The maximum number of keys to return is specified via the &lt;code&gt;count&lt;/code&gt; argument, so that it is possible for the user of this API to batch-processing keys.</source>
          <target state="translated">El comando devuelve una matriz de nombres de claves almacenados en el nodo contactado y hash en la ranura de hash especificada. El n&amp;uacute;mero m&amp;aacute;ximo de claves para devolver se especifica mediante el argumento de &lt;code&gt;count&lt;/code&gt; , de modo que el usuario de esta API pueda procesar las claves por lotes.</target>
        </trans-unit>
        <trans-unit id="e6bc3ec726a066c82649799db4b402b18c37620c" translate="yes" xml:space="preserve">
          <source>The command returns an array of results: each element of the returned array is an array composed of a two element containing the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;.</source>
          <target state="translated">El comando devuelve una matriz de resultados: cada elemento de la matriz devuelta es una matriz compuesta por dos elementos que contienen el nombre de la clave y las entradas informadas para esa clave. Las entradas informadas son entradas de flujo completo, con ID y la lista de todos los campos y valores. Se garantiza que los campos y los valores se informar&amp;aacute;n en el mismo orden en que fueron agregados por &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59dca4232b984a49106f20180ccd68dd85cde434" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a four elements array representing the event's name, timestamp, latest and all-time latency measurements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59bdbda1d4276c59a205bc75690c8792da83930" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command.</source>
          <target state="translated">El comando devuelve una matriz en la que cada elemento es una matriz de dos elementos que representan la longitud y la latitud (x,y)de cada nombre de miembro pasado como argumento al comando.</target>
        </trans-unit>
        <trans-unit id="c2da6177dc0df5d03aa7780c4ae1b3e2b3b664b6" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing the timestamp and the latency of the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299bd584711e094e5bb4f6fecbd5c79b634a792b" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is the Geohash corresponding to each member name passed as argument to the command.</source>
          <target state="translated">El comando devuelve una matriz donde cada elemento es el Geohash correspondiente a cada nombre de miembro pasado como argumento al comando.</target>
        </trans-unit>
        <trans-unit id="63618225d498ac1d95054dac445c00eb7942b4b2" translate="yes" xml:space="preserve">
          <source>The command returns an array with each entry being the corresponding result of the sub command given at the same position. &lt;code&gt;OVERFLOW&lt;/code&gt; subcommands don't count as generating a reply.</source>
          <target state="translated">El comando devuelve una matriz con cada entrada siendo el resultado correspondiente del subcomando dado en la misma posici&amp;oacute;n. &lt;code&gt;OVERFLOW&lt;/code&gt; subcomandos OVERFLOW no cuentan como generar una respuesta.</target>
        </trans-unit>
        <trans-unit id="0d3fdeb1c470e8f290735d9f570986e08dde9291" translate="yes" xml:space="preserve">
          <source>The command returns an error when the &lt;code&gt;destination&lt;/code&gt; key already exists. The &lt;code&gt;REPLACE&lt;/code&gt; option removes the &lt;code&gt;destination&lt;/code&gt; key before copying the value to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599682f8e696ffcef9a41f128a35f008ec692b72" translate="yes" xml:space="preserve">
          <source>The command returns data in different format depending on the way it is called, as previously explained in this page. However the reply is always an array of items.</source>
          <target state="translated">El comando devuelve los datos en un formato diferente dependiendo de la forma en que se llame,como se explicó anteriormente en esta página.Sin embargo,la respuesta es siempre un conjunto de elementos.</target>
        </trans-unit>
        <trans-unit id="64555ea6ac3dd842f32e77db3528c6314f55ca4d" translate="yes" xml:space="preserve">
          <source>The command returns data in the same format as &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;.</source>
          <target state="translated">El comando devuelve datos en el mismo formato que &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f11ff6c087b294c263c888936947fb519a703574" translate="yes" xml:space="preserve">
          <source>The command returns information about the current client connection's use of the &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;server assisted client side caching&lt;/a&gt; feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84d7525c4b51e3bbe67ae31259831e14b15be40" translate="yes" xml:space="preserve">
          <source>The command returns information and statistics about the current client connection in a mostly human readable format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854de1e7ab31a436fe3503c72376101ec2883922" translate="yes" xml:space="preserve">
          <source>The command returns the ID of the added entry. The ID is the one auto-generated if &lt;code&gt;*&lt;/code&gt; is passed as ID argument, otherwise the command just returns the same ID specified by the user during insertion.</source>
          <target state="translated">El comando devuelve el ID de la entrada agregada. El ID es el que se genera autom&amp;aacute;ticamente si se pasa &lt;code&gt;*&lt;/code&gt; como argumento de ID; de lo contrario, el comando simplemente devuelve el mismo ID especificado por el usuario durante la inserci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7247b723aad05766caad65ebc7ede74ba6d1e1dd" translate="yes" xml:space="preserve">
          <source>The command returns the distance as a double (represented as a string) in the specified unit, or NULL if one or both the elements are missing.</source>
          <target state="translated">El comando devuelve la distancia como un doble (representado como una cadena)en la unidad especificada,o NULL si falta uno o ambos elementos.</target>
        </trans-unit>
        <trans-unit id="a226a6dbee33f1a9bdf015f4eb2291dd60f7022b" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range, from the higher ID to the lower ID matching. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">El comando devuelve las entradas con ID que coinciden con el rango especificado, desde el ID m&amp;aacute;s alto hasta el ID m&amp;aacute;s bajo. Las entradas devueltas est&amp;aacute;n completas, eso significa que se devuelve el ID y todos los campos que est&amp;aacute;n compuestos. Adem&amp;aacute;s, las entradas se devuelven con sus campos y valores exactamente en el mismo orden en que las agreg&amp;oacute; &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="444f426015abc65778606f24926eb62888ddcfbe" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover, the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">El comando devuelve las entradas con ID que coinciden con el rango especificado. Las entradas devueltas est&amp;aacute;n completas, eso significa que se devuelve el ID y todos los campos que est&amp;aacute;n compuestos. Adem&amp;aacute;s, las entradas se devuelven con sus campos y valores exactamente en el mismo orden en que las agreg&amp;oacute; &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62939248d8e32365e6957d42055f2de89814a292" translate="yes" xml:space="preserve">
          <source>The command returns the index of matching elements inside a Redis list. By default, when no options are given, it will scan the list from head to tail, looking for the first match of &quot;element&quot;. If the element is found, its index (the zero-based position in the list) is returned. Otherwise, if no match is found, NULL is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f216246f788da7553b72042887561f848de4e55c" translate="yes" xml:space="preserve">
          <source>The command returns the integer representing the matching element, or null if there is no match. However, if the &lt;code&gt;COUNT&lt;/code&gt; option is given the command returns an array (empty if there are no matches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a3d21f3dbcaa198bbe343d23738bbd28a872e1" translate="yes" xml:space="preserve">
          <source>The command returns the number of &lt;em&gt;failure reports&lt;/em&gt; for the specified node. Failure reports are the way Redis Cluster uses in order to promote a &lt;code&gt;PFAIL&lt;/code&gt; state, that means a node is not reachable, to a &lt;code&gt;FAIL&lt;/code&gt; state, that means that the majority of masters in the cluster agreed within a window of time that the node is not reachable.</source>
          <target state="translated">El comando devuelve el n&amp;uacute;mero de &lt;em&gt;informes&lt;/em&gt; de &lt;em&gt;fallas&lt;/em&gt; para el nodo especificado. Los informes de fallas son la forma en que Redis Cluster usa para promover un estado &lt;code&gt;PFAIL&lt;/code&gt; , es decir, un nodo no es accesible, a un estado &lt;code&gt;FAIL&lt;/code&gt; , eso significa que la mayor&amp;iacute;a de los maestros en el cl&amp;uacute;ster acordaron dentro de una ventana de tiempo que el nodo no est&amp;aacute; accesible.</target>
        </trans-unit>
        <trans-unit id="11d6963d3c757dd171e4446f81aa6fbb2b4f3cbe" translate="yes" xml:space="preserve">
          <source>The command returns the number of entries deleted from the stream.</source>
          <target state="translated">El comando devuelve el número de entradas borradas de la corriente.</target>
        </trans-unit>
        <trans-unit id="90a0913f53aff4fc9a2c5f477057692b16cb61c2" translate="yes" xml:space="preserve">
          <source>The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have been already acknowledge), and XACK will not count them as successfully acknowledged.</source>
          <target state="translated">El comando devuelve el número de mensajes reconocidos con éxito.Ciertos ID de mensajes pueden no formar parte del PEL (por ejemplo porque ya han sido reconocidos),y XACK no los contará como reconocidos con éxito.</target>
        </trans-unit>
        <trans-unit id="25862d0137651f4c50c642c84cec4c703a39cc67" translate="yes" xml:space="preserve">
          <source>The command returns the position of the first bit set to 1 or 0 according to the request.</source>
          <target state="translated">El comando devuelve la posición del primer bit a 1 o 0 según la petición.</target>
        </trans-unit>
        <trans-unit id="0f2fe335e56363e46ba8079d81809ab997be12eb" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entires having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="translated">El comando devuelve las entradas de la corriente que coinciden con un rango determinado de identificaciones.El rango se especifica con un ID mínimo y máximo.Se devuelven todos los enteros que tengan un ID entre los dos especificados o exactamente uno de los dos ID especificados (intervalo cerrado).</target>
        </trans-unit>
        <trans-unit id="383ccd477dc944e0c3ebd47dbea4b6b2017eb35b" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entries having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be8f3674812a7bb5d9fb3101b17c38b3646405b" translate="yes" xml:space="preserve">
          <source>The command shows a list of all the usernames of the currently configured users in the Redis ACL system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c06047a0b602e177d71981a4d9e29349f77a37" translate="yes" xml:space="preserve">
          <source>The command shows a list of recent ACL security events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2382a9cd868ca3bdb3953efcef5f79ded0789a3c" translate="yes" xml:space="preserve">
          <source>The command shows the available ACL categories if called without arguments. If a category name is given, the command shows all the Redis commands in the specified category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724b74eeaa692174c50661ecd1cc035a30521473" translate="yes" xml:space="preserve">
          <source>The command shows the currently active ACL rules in the Redis server. Each line in the returned array defines a different user, and the format is the same used in the redis.conf file or the external ACL file, so you can cut and paste what is returned by the ACL LIST command directly inside a configuration file if you wish (but make sure to check &lt;a href=&quot;acl-save&quot;&gt;ACL SAVE&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b22d366f18019ba16fe8b5883618685376f0fb" translate="yes" xml:space="preserve">
          <source>The command takes arguments in the standard format x,y so the longitude must be specified before the latitude. There are limits to the coordinates that can be indexed: areas very near to the poles are not indexable. The exact limits, as specified by EPSG:900913 / EPSG:3785 / OSGEO:41001 are the following:</source>
          <target state="translated">El comando toma los argumentos en el formato estándar x,y por lo que la longitud debe ser especificada antes que la latitud.Hay límites a las coordenadas que pueden ser indexadas:las áreas muy cercanas a los polos no son indexables.Los límites exactos,como se especifica en EPSG:900913/EPSG:3785/OSGEO:41001 son los siguientes:</target>
        </trans-unit>
        <trans-unit id="69e46f6ba0a5d03f8dc0e5aa7af7b003d2e71820" translate="yes" xml:space="preserve">
          <source>The command treats a Redis string as a array of bits, and is capable of addressing specific integer fields of varying bit widths and arbitrary non (necessary) aligned offset. In practical terms using this command you can set, for example, a signed 5 bits integer at bit offset 1234 to a specific value, retrieve a 31 bit unsigned integer from offset 4567. Similarly the command handles increments and decrements of the specified integers, providing guaranteed and well specified overflow and underflow behavior that the user can configure.</source>
          <target state="translated">El comando trata una cadena de Redis como un conjunto de bits,y es capaz de abordar campos enteros específicos de anchos de bits variables y desplazamientos arbitrarios no alineados (necesarios).En términos prácticos,utilizando este comando se puede establecer,por ejemplo,un entero de 5 bits con signo en el offset de bits 1234 a un valor específico,recuperar un entero de 31 bits sin signo del offset 4567.De manera similar,el comando maneja incrementos y decrementos de los enteros especificados,proporcionando un comportamiento de desbordamiento y subdesbordamiento garantizado y bien especificado que el usuario puede configurar.</target>
        </trans-unit>
        <trans-unit id="13c5fae6e8ea2d19068840627307808e57ed434f" translate="yes" xml:space="preserve">
          <source>The command will fail if the specified node is not known or if it is not a master according to the node table of the node receiving the command.</source>
          <target state="translated">El comando fallará si no se conoce el nodo especificado o si no es un maestro según la tabla de nodos del nodo que recibe el comando.</target>
        </trans-unit>
        <trans-unit id="83094ac4a33e4188f42d4a2c20d7dbf3f6620df3" translate="yes" xml:space="preserve">
          <source>The command will report an error when the user attempts to index coordinates outside the specified ranges.</source>
          <target state="translated">El comando informará de un error cuando el usuario intente indexar las coordenadas fuera de los rangos especificados.</target>
        </trans-unit>
        <trans-unit id="c3184d09a508b5c6fdb922b8b826ae4f98d9a67a" translate="yes" xml:space="preserve">
          <source>The command will return up to 160 timestamp-latency pairs for the &lt;code&gt;event&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a427adc7c29c84562496f4e3dd746f3b4883cbf" translate="yes" xml:space="preserve">
          <source>The command with its set of subcommands is useful in order to start and end cluster live resharding operations, which are accomplished by setting a hash slot in migrating state in the source node, and importing state in the destination node.</source>
          <target state="translated">El comando con su conjunto de subcomandos es útil para iniciar y finalizar las operaciones de reordenación en vivo del grupo,que se logran estableciendo una ranura de hachís en estado de migración en el nodo de origen,y estado de importación en el nodo de destino.</target>
        </trans-unit>
        <trans-unit id="f34a45ceabab28f1008f0f9d2405fbba32c8e338" translate="yes" xml:space="preserve">
          <source>The command works in the same way even if the script was already present in the script cache.</source>
          <target state="translated">El comando funciona de la misma manera incluso si el guión ya estaba presente en la caché del guión.</target>
        </trans-unit>
        <trans-unit id="58212b0000147d5bba3264e4996ad46fd286b905" translate="yes" xml:space="preserve">
          <source>The common use case for this command is to retrieve geospatial items near a specified point not farther than a given amount of meters (or other units). This allows, for example, to suggest mobile users of an application nearby places.</source>
          <target state="translated">El caso de uso común de este comando es recuperar elementos geoespaciales cerca de un punto específico no más allá de una cantidad dada de metros (u otras unidades).Esto permite,por ejemplo,sugerir a los usuarios móviles de una aplicación los lugares cercanos.</target>
        </trans-unit>
        <trans-unit id="83d84f2e6d0bc285dccf475994bf2dfe5a7034d1" translate="yes" xml:space="preserve">
          <source>The computed merged HyperLogLog is set to the destination variable, which is created if does not exist (defaulting to an empty HyperLogLog).</source>
          <target state="translated">El HyperLogLog fusionado computarizado se establece en la variable de destino,que se crea si no existe (por defecto,un HyperLogLog vacío).</target>
        </trans-unit>
        <trans-unit id="892b6264b392f8ad48dfbfcfe6dff8a94a45c598" translate="yes" xml:space="preserve">
          <source>The configuration can be done by editing &lt;code&gt;redis.conf&lt;/code&gt; or while the server is running using the &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; and &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; commands.</source>
          <target state="translated">La configuraci&amp;oacute;n se puede realizar editando &lt;code&gt;redis.conf&lt;/code&gt; o mientras el servidor se est&amp;aacute; ejecutando usando los comandos &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; y &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9924fa1c31458da66b46121ed81593fd5a4fbad" translate="yes" xml:space="preserve">
          <source>The connection name can be inspected using &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt;.</source>
          <target state="translated">El nombre de la conexi&amp;oacute;n se puede inspeccionar utilizando &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6da99886277806746e8e984d617153310b22b176" translate="yes" xml:space="preserve">
          <source>The connection we have with the server is persistent and was never closed so far.</source>
          <target state="translated">La conexión que tenemos con el servidor es persistente y nunca se ha cerrado hasta ahora.</target>
        </trans-unit>
        <trans-unit id="812045821e03fcc1f9ffc04b5ef35de3b612856e" translate="yes" xml:space="preserve">
          <source>The consumer group will be destroyed even if there are active consumers and pending messages, so make sure to call this command only when really needed.</source>
          <target state="translated">El grupo de consumidores será destruido incluso si hay consumidores activos y mensajes pendientes,así que asegúrate de llamar a este comando sólo cuando sea realmente necesario.</target>
        </trans-unit>
        <trans-unit id="8d4c2cd743047005cdb993a3a9d7afc356bb6664" translate="yes" xml:space="preserve">
          <source>The consumer will do:</source>
          <target state="translated">El consumidor lo hará:</target>
        </trans-unit>
        <trans-unit id="a09ada6e198e1cc27a58e1c5cd2063765d34a60e" translate="yes" xml:space="preserve">
          <source>The coordinates as a two items x,y array (longitude,latitude).</source>
          <target state="translated">Las coordenadas como una matriz de dos elementos x,y (longitud,latitud).</target>
        </trans-unit>
        <trans-unit id="d6f85adf1bad41bef7242defbfacbfdea663e0f0" translate="yes" xml:space="preserve">
          <source>The counter is created in a way that it only will survive one second, starting from the first request performed in the current second. If there are more than 10 requests in the same second the counter will reach a value greater than 10, otherwise it will expire and start again from 0.</source>
          <target state="translated">El contador se crea de manera que sólo sobrevivirá un segundo,a partir de la primera petición realizada en el segundo actual.Si hay más de 10 peticiones en el mismo segundo,el contador alcanzará un valor superior a 10,de lo contrario expirará y volverá a empezar desde 0.</target>
        </trans-unit>
        <trans-unit id="224e5c836dc00eb5744ec82792c094203a16fc27" translate="yes" xml:space="preserve">
          <source>The counter pattern is the most obvious thing you can do with Redis atomic increment operations. The idea is simply send an &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; command to Redis every time an operation occurs. For instance in a web application we may want to know how many page views this user did every day of the year.</source>
          <target state="translated">El patr&amp;oacute;n de contador es lo m&amp;aacute;s obvio que puede hacer con las operaciones de incremento at&amp;oacute;mico de Redis. La idea es simplemente enviar un comando &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; a Redis cada vez que ocurra una operaci&amp;oacute;n. Por ejemplo, en una aplicaci&amp;oacute;n web, es posible que deseemos saber cu&amp;aacute;ntas visitas a la p&amp;aacute;gina hizo este usuario todos los d&amp;iacute;as del a&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="b77e139112433671a542addfa1a32daf47ee322d" translate="yes" xml:space="preserve">
          <source>The crashed client C3 still holds it, so Redis will reply with &lt;code&gt;0&lt;/code&gt; to C4.</source>
          <target state="translated">El cliente bloqueado C3 todav&amp;iacute;a lo retiene, por lo que Redis responder&amp;aacute; con &lt;code&gt;0&lt;/code&gt; a C4.</target>
        </trans-unit>
        <trans-unit id="8423b58d7e3aaab1a157d34537088cf7071837ad" translate="yes" xml:space="preserve">
          <source>The current field content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">El contenido del campo actual o el incremento especificado no son parsables como un número de punto flotante de doble precisión.</target>
        </trans-unit>
        <trans-unit id="838fa5216f1f1cdff3694527a8a6d1c1f9f94411" translate="yes" xml:space="preserve">
          <source>The current key content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">El contenido clave actual o el incremento especificado no son parsables como un número de punto flotante de doble precisión.</target>
        </trans-unit>
        <trans-unit id="931ea7e75c2dded718677c9f4a1676825fcb3baa" translate="yes" xml:space="preserve">
          <source>The current master replication offset, which is an offset that masters and replicas share to understand, in partial resynchronizations, the part of the replication stream the replicas needs to fetch to continue.</source>
          <target state="translated">El actual offset de la réplica maestra,que es un offset que los maestros y las réplicas comparten para entender,en resincronizaciones parciales,la parte del flujo de replicación que las réplicas deben buscar para continuar.</target>
        </trans-unit>
        <trans-unit id="b7064688c0f4d788a94324f8ce3624a598ba7058" translate="yes" xml:space="preserve">
          <source>The current score of an element can be retrieved using the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command, that can also be used to verify if an element already exists or not.</source>
          <target state="translated">La puntuaci&amp;oacute;n actual de un elemento se puede recuperar mediante el comando &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; , que tambi&amp;eacute;n se puede utilizar para verificar si un elemento ya existe o no.</target>
        </trans-unit>
        <trans-unit id="30d1eb14ec245a20077a7d25213dc588a8512c5c" translate="yes" xml:space="preserve">
          <source>The cursor returned by the previous call to SCAN in order to continue the iteration.</source>
          <target state="translated">El cursor regresó por la llamada anterior a SCAN para continuar la iteración.</target>
        </trans-unit>
        <trans-unit id="219c36e5291d2c3051ee7cf69aa75399bb2fc52c" translate="yes" xml:space="preserve">
          <source>The cursor value of 0 when starting an iteration.</source>
          <target state="translated">El valor del cursor de 0 al iniciar una iteración.</target>
        </trans-unit>
        <trans-unit id="93cb8fd7598a4e9c87b91141380a4bde0e9f7ad1" translate="yes" xml:space="preserve">
          <source>The default COUNT value is 10.</source>
          <target state="translated">El valor por defecto de COUNT es 10.</target>
        </trans-unit>
        <trans-unit id="1472348f89b9c094e365f856bf74ca11dcb1cdde" translate="yes" xml:space="preserve">
          <source>The deliveries counter, that is the fourth element in the array, is incremented when some other consumer &lt;em&gt;claims&lt;/em&gt; the message with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;, or when the message is delivered again via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, when accessing the history of a consumer in a consumer group (see the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; page for more info).</source>
          <target state="translated">El contador de entregas, que es el cuarto elemento de la matriz, se incrementa cuando alg&amp;uacute;n otro consumidor &lt;em&gt;reclama&lt;/em&gt; el mensaje con &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; , o cuando el mensaje se env&amp;iacute;a de nuevo a trav&amp;eacute;s de &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; , al acceder al historial de un consumidor en un grupo de consumidores (ver el &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; p&amp;aacute;gina para obtener m&amp;aacute;s informaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="c29b8b8f823cca94ef6ad774fed42578a146e94a" translate="yes" xml:space="preserve">
          <source>The difference between this command and the vanilla &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is that this one supports consumer groups.</source>
          <target state="translated">La diferencia entre este comando y el vanilla &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; es que este admite grupos de consumidores.</target>
        </trans-unit>
        <trans-unit id="3c1c5811c1d1a274026dcc95a504bdc2dd6d5a09" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the radius.</source>
          <target state="translated">La distancia desde el centro como un número de punto flotante,en la misma unidad especificada en el radio.</target>
        </trans-unit>
        <trans-unit id="e1121b0e8297b7fecce16b935b4718ce15930933" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afe599a4181bcd5a732c0ec177cb011be65df41" translate="yes" xml:space="preserve">
          <source>The distance is computed assuming that the Earth is a perfect sphere, so errors up to 0.5% are possible in edge cases.</source>
          <target state="translated">La distancia se calcula asumiendo que la Tierra es una esfera perfecta,por lo que es posible que haya errores de hasta el 0,5% en los casos de borde.</target>
        </trans-unit>
        <trans-unit id="a8be9ff0b07a549071a611002c4a08732b5c80a8" translate="yes" xml:space="preserve">
          <source>The distribution of the returned elements is far from perfect when the number of elements in the set is small, this is due to the fact that we used an approximated random element function that does not really guarantees good distribution.</source>
          <target state="translated">La distribución de los elementos devueltos está lejos de ser perfecta cuando el número de elementos en el conjunto es pequeño,esto se debe al hecho de que utilizamos una función de elementos aleatorios aproximados que no garantiza realmente una buena distribución.</target>
        </trans-unit>
        <trans-unit id="e2451d0313184cb7cb1bfd5f5707106d6b571329" translate="yes" xml:space="preserve">
          <source>The elements are considered to be ordered from lower to higher strings as compared byte-by-byte using the &lt;code&gt;memcmp()&lt;/code&gt; C function. Longer strings are considered greater than shorter strings if the common part is identical.</source>
          <target state="translated">Se considera que los elementos est&amp;aacute;n ordenados de cadenas inferiores a superiores en comparaci&amp;oacute;n byte a byte utilizando la funci&amp;oacute;n &lt;code&gt;memcmp()&lt;/code&gt; C. Las cadenas m&amp;aacute;s largas se consideran mayores que las cadenas m&amp;aacute;s cortas si la parte com&amp;uacute;n es id&amp;eacute;ntica.</target>
        </trans-unit>
        <trans-unit id="7dd12a75b48ac332a2dfe23f1549d87b855bfd6d" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in lexicographical order (this follows from a property of the sorted set implementation in Redis and does not involve further computation).</source>
          <target state="translated">Los elementos que tienen la misma puntuación se devuelven en orden lexicográfico (esto se desprende de una propiedad de la implementación del conjunto ordenado en Redis y no implica un cálculo posterior).</target>
        </trans-unit>
        <trans-unit id="12d2f968d07516f9654dcc50b588d898c0361273" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in reverse lexicographical order.</source>
          <target state="translated">Los elementos que tienen la misma puntuación se devuelven en orden lexicográfico inverso.</target>
        </trans-unit>
        <trans-unit id="8a7336e9649584aeb5dd7541a2422de663fa783e" translate="yes" xml:space="preserve">
          <source>The entry's unique ID can be used in order to avoid processing slow log entries multiple times (for instance you may have a script sending you an email alert for every new slow log entry).</source>
          <target state="translated">La identificación única de la entrada puede utilizarse para evitar el procesamiento de entradas de registro lento varias veces (por ejemplo,puede tener un guión que le envíe una alerta de correo electrónico por cada nueva entrada de registro lento).</target>
        </trans-unit>
        <trans-unit id="4c3c6b922261a4a3c02503cd2200bbc2e1969187" translate="yes" xml:space="preserve">
          <source>The exact behavior of this command is identical to the one of the &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; command, please refer to the documentation of &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; for further information.</source>
          <target state="translated">El comportamiento exacto de este comando es id&amp;eacute;ntico al del comando &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; , consulte la documentaci&amp;oacute;n de &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="81ef5cb9ba6108b82ece4143c01d73481b4f607e" translate="yes" xml:space="preserve">
          <source>The fact that the user can count on Redis not removing scripts is semantically useful in the context of pipelining.</source>
          <target state="translated">El hecho de que el usuario pueda contar con que Redis no elimine los guiones es semánticamente útil en el contexto de la canalización.</target>
        </trans-unit>
        <trans-unit id="a0c00c319cfd875c00a2280921682c92066dd97a" translate="yes" xml:space="preserve">
          <source>The feature will remain active in the current connection for all its life, unless tracking is turned on with &lt;code&gt;CLIENT TRACKING off&lt;/code&gt; at some point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccad1b83c48c6dc04cc17404f3912c32d936c720" translate="yes" xml:space="preserve">
          <source>The field contains a value of the wrong type (not a string).</source>
          <target state="translated">El campo contiene un valor del tipo equivocado (no una cadena).</target>
        </trans-unit>
        <trans-unit id="6058628e04e98718045db43e11d253a6db12f594" translate="yes" xml:space="preserve">
          <source>The file descriptor events can be:</source>
          <target state="translated">Los eventos del descriptor del archivo pueden ser:</target>
        </trans-unit>
        <trans-unit id="d4261d3e5eb2c06f28ad9faa68309fdf262f21cb" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is a Lua 5.1 script. The script does not need to define a Lua function (and should not). It is just a Lua program that will run in the context of the Redis server.</source>
          <target state="translated">El primer argumento de &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; es un script Lua 5.1. El script no necesita definir una funci&amp;oacute;n Lua (y no deber&amp;iacute;a). Es solo un programa Lua que se ejecutar&amp;aacute; en el contexto del servidor Redis.</target>
        </trans-unit>
        <trans-unit id="46870f99efa0c3b2959dcb93e1e13013212f023d" translate="yes" xml:space="preserve">
          <source>The first argument of the command selects the algorithm to use, right now the argument must be &quot;LCS&quot;, since this is the only implemented one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647fb34e5b11b941bb5e49ce5d7abfd78a858447" translate="yes" xml:space="preserve">
          <source>The first case will return the first 10 (or less) PEL entries of the entire group that are idle for over 9 seconds, whereas in the second case only those of &lt;code&gt;consumer-123&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cbda77e6bd32de6a17a5ed2d8395d40439856eb" translate="yes" xml:space="preserve">
          <source>The following are a few examples of importing and migrating slots:</source>
          <target state="translated">A continuación se presentan algunos ejemplos de ranuras de importación y migración:</target>
        </trans-unit>
        <trans-unit id="6c3d5dc29a069636be48f90bb368850ce3fda788" translate="yes" xml:space="preserve">
          <source>The following are the list of options that modify the behavior of the command when enabling tracking:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b94aea73b4255f0bc659c9805b5380b0565b107" translate="yes" xml:space="preserve">
          <source>The following command removes the association for slots 5000 and 5001 from the node receiving the command:</source>
          <target state="translated">El siguiente comando elimina la asociación para las ranuras 5000 y 5001 del nodo que recibe el comando:</target>
        </trans-unit>
        <trans-unit id="784815ebd70c0fe925bcd60bddc497d55949fa3a" translate="yes" xml:space="preserve">
          <source>The following documentation is a reference manual about the capabilities of this command, however our &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL tutorial&lt;/a&gt; may be a more gentle introduction to how the ACL system works in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00075a28fdc9ff572c3eac87bcaf7c44d932e7da" translate="yes" xml:space="preserve">
          <source>The following example should clarify what stated above:</source>
          <target state="translated">El siguiente ejemplo debería aclarar lo que se ha dicho anteriormente:</target>
        </trans-unit>
        <trans-unit id="1ec034b27145454749448bb4c66e40315aa13e2f" translate="yes" xml:space="preserve">
          <source>The following example using &lt;code&gt;WITHSCORES&lt;/code&gt; shows how the command returns always an array, but this time, populated with &lt;em&gt;element_1&lt;/em&gt;, &lt;em&gt;score_1&lt;/em&gt;, &lt;em&gt;element_2&lt;/em&gt;, &lt;em&gt;score_2&lt;/em&gt;, ..., &lt;em&gt;element_N&lt;/em&gt;, &lt;em&gt;score_N&lt;/em&gt;.</source>
          <target state="translated">El siguiente ejemplo usando &lt;code&gt;WITHSCORES&lt;/code&gt; muestra c&amp;oacute;mo el comando siempre devuelve una matriz, pero esta vez, poblada con &lt;em&gt;element_1&lt;/em&gt; , &lt;em&gt;score_1&lt;/em&gt; , &lt;em&gt;element_2&lt;/em&gt; , &lt;em&gt;score_2&lt;/em&gt; , ..., &lt;em&gt;element_N&lt;/em&gt; , &lt;em&gt;score_N&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69face26cb0b6283ed9eddef9110c599dd9ae6eb" translate="yes" xml:space="preserve">
          <source>The following field is always provided:</source>
          <target state="translated">Siempre se proporciona el siguiente campo:</target>
        </trans-unit>
        <trans-unit id="5fede26fc672e9d5137b89bc60a98de02e5d6528" translate="yes" xml:space="preserve">
          <source>The following is an example of &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; returning NULL.</source>
          <target state="translated">El siguiente es un ejemplo de &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; que devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="f26894ffa2e5bfa52e8acebe022822e6a159ac5d" translate="yes" xml:space="preserve">
          <source>The following is the list of supported commands.</source>
          <target state="translated">La siguiente es la lista de comandos soportados.</target>
        </trans-unit>
        <trans-unit id="487db5ff0187b77e2cfe37d8572892092c01e33a" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">Se desaconseja el siguiente patr&amp;oacute;n en favor del &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;algoritmo Redlock,&lt;/a&gt; que es solo un poco m&amp;aacute;s complejo de implementar, pero ofrece mejores garant&amp;iacute;as y es tolerante a fallas.</target>
        </trans-unit>
        <trans-unit id="8e9fc798f24c122b5b0b23c06739d7c4c95610dd" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685c86199b8431155924b73d00e71167faabb72e" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">El formulario &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NADIE detendr&amp;aacute; la replicaci&amp;oacute;n, convirtiendo el servidor en un MASTER, pero no descartar&amp;aacute; la replicaci&amp;oacute;n. Entonces, si el antiguo maestro deja de funcionar, es posible convertir la r&amp;eacute;plica en un maestro y configurar la aplicaci&amp;oacute;n para usar este nuevo maestro en lectura / escritura. M&amp;aacute;s tarde, cuando el otro servidor de Redis est&amp;eacute; reparado, se puede volver a configurar para que funcione como una r&amp;eacute;plica.</target>
        </trans-unit>
        <trans-unit id="2a758769f42fa16fd49a6c65e260a443efa58858" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">El formulario &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NADIE detendr&amp;aacute; la replicaci&amp;oacute;n, convirtiendo el servidor en un MASTER, pero no descartar&amp;aacute; la replicaci&amp;oacute;n. Entonces, si el antiguo maestro deja de funcionar, es posible convertir la r&amp;eacute;plica en un maestro y configurar la aplicaci&amp;oacute;n para usar este nuevo maestro en lectura / escritura. M&amp;aacute;s tarde, cuando el otro servidor de Redis est&amp;eacute; reparado, se puede volver a configurar para que funcione como una r&amp;eacute;plica.</target>
        </trans-unit>
        <trans-unit id="cfb81787e75be423c5bbd1da337f47a738269c3b" translate="yes" xml:space="preserve">
          <source>The function handles out of range requests by limiting the resulting range to the actual length of the string.</source>
          <target state="translated">La función maneja las solicitudes fuera de rango limitando el rango resultante a la longitud real de la cadena.</target>
        </trans-unit>
        <trans-unit id="bae822e06654577340df39aec8c279a41923dbdf" translate="yes" xml:space="preserve">
          <source>The function returns true if the script effects replication was enabled, otherwise if the function was called after the script already called some write command, it returns false, and normal whole script replication is used.</source>
          <target state="translated">La función devuelve true si se habilitó la replicación de efectos de guión,de lo contrario,si la función fue llamada después de que el guión ya llamó algún comando de escritura,devuelve false,y se utiliza la replicación normal de todo el guión.</target>
        </trans-unit>
        <trans-unit id="e3d352c9158e45827d58fa0bb1daa62cb827202a" translate="yes" xml:space="preserve">
          <source>The geohash integer.</source>
          <target state="translated">El entero geohash.</target>
        </trans-unit>
        <trans-unit id="a74105f90399289d271dac87ebbc775e37f16a9d" translate="yes" xml:space="preserve">
          <source>The graph is normalized in the min-max scale so that the zero (the underscore in the lower row) is the minimum, and a # in the higher row is the maximum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1802968f15db7e03ec0c89118a7963b7fbc9d55a" translate="yes" xml:space="preserve">
          <source>The group name is just the name of a consumer group associated to the stream. The group is created using the &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; command. The consumer name is the string that is used by the client to identify itself inside the group. The consumer is auto created inside the consumer group the first time it is saw. Different clients should select a different consumer name.</source>
          <target state="translated">El nombre del grupo es solo el nombre de un grupo de consumidores asociado a la transmisi&amp;oacute;n. El grupo se crea mediante el comando &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; . El nombre del consumidor es la cadena que utiliza el cliente para identificarse dentro del grupo. El consumidor se crea autom&amp;aacute;ticamente dentro del grupo de consumidores la primera vez que se ve. Los diferentes clientes deben seleccionar un nombre de consumidor diferente.</target>
        </trans-unit>
        <trans-unit id="9501214421f828fe1bcfe6cfb269ae7881da1706" translate="yes" xml:space="preserve">
          <source>The id of the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfb24eb9709d7c83208076fd77b0d419da27db0" translate="yes" xml:space="preserve">
          <source>The information about memory usage is provided as metrics and their respective values. The following metrics are reported:</source>
          <target state="translated">La información sobre el uso de la memoria se proporciona como métrica y sus respectivos valores.Se informa de las siguientes métricas:</target>
        </trans-unit>
        <trans-unit id="34a2e40e15b32f6149b206a299f7840113d10818" translate="yes" xml:space="preserve">
          <source>The key contains a value of the wrong type (not a string).</source>
          <target state="translated">La clave contiene un valor del tipo equivocado (no una cadena).</target>
        </trans-unit>
        <trans-unit id="09d97b8e7dc4c8276b96f5602bc74dea1d0e36c5" translate="yes" xml:space="preserve">
          <source>The key may be on both the instances.</source>
          <target state="translated">La clave puede estar en ambas instancias.</target>
        </trans-unit>
        <trans-unit id="317c7c0e8fc5ce228ab50cadfc186268268a73ba" translate="yes" xml:space="preserve">
          <source>The key may be only in the source instance.</source>
          <target state="translated">La clave puede estar sólo en el caso de la fuente.</target>
        </trans-unit>
        <trans-unit id="770d7559e7b2fdc7128e6105d19ea9ca36a0376e" translate="yes" xml:space="preserve">
          <source>The key time to live can be updated or entirely removed using the &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; and &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command (or other strictly related commands).</source>
          <target state="translated">El momento clave para vivo se puede actualizar o totalmente eliminado mediante el &lt;a href=&quot;expire&quot;&gt;EXPIRA&lt;/a&gt; y &lt;a href=&quot;persist&quot;&gt;persisten&lt;/a&gt; comando (u otros comandos estrictamente relacionados).</target>
        </trans-unit>
        <trans-unit id="547c694280239130253479a419ced5c053003ea8" translate="yes" xml:space="preserve">
          <source>The last ID returned is &lt;code&gt;1526985712947-0&lt;/code&gt;, since the sequence number is already zero, the next ID I'll use instead of the &lt;code&gt;+&lt;/code&gt; special ID will be &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt;, or just &lt;code&gt;18446744073709551615&lt;/code&gt;:</source>
          <target state="translated">El &amp;uacute;ltimo ID devuelto es &lt;code&gt;1526985712947-0&lt;/code&gt; , dado que el n&amp;uacute;mero de secuencia ya es cero, el siguiente ID que &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt; lugar del &lt;code&gt;+&lt;/code&gt; ID especial ser&amp;aacute; 1526985712946-18446744073709551615 , o solo &lt;code&gt;18446744073709551615&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="11471f50fbf81f6258a27201c930e977959ad0cd" translate="yes" xml:space="preserve">
          <source>The last argument is the ID of the last item in the stream to consider already delivered. In the above case we used the special ID '$' (that means: the ID of the last item in the stream). In this case the consumers fetching data from that consumer group will only see new elements arriving in the stream.</source>
          <target state="translated">El último argumento es la identificación del último artículo de la corriente a considerar ya entregado.En el caso anterior utilizamos el ID especial &quot;$&quot; (que significa:el ID del último artículo en el flujo).En este caso,los consumidores que obtengan datos de ese grupo de consumidores sólo verán los nuevos elementos que lleguen a la corriente.</target>
        </trans-unit>
        <trans-unit id="42e7923c299c01e54ed6170cd5e8fc34b5599898" translate="yes" xml:space="preserve">
          <source>The last example shows how it is possible to receive the exact return value of &lt;code&gt;redis.call()&lt;/code&gt; or &lt;code&gt;redis.pcall()&lt;/code&gt; from Lua that would be returned if the command was called directly.</source>
          <target state="translated">El &amp;uacute;ltimo ejemplo muestra c&amp;oacute;mo es posible recibir el valor de retorno exacto de &lt;code&gt;redis.call()&lt;/code&gt; o &lt;code&gt;redis.pcall()&lt;/code&gt; de Lua que se devolver&amp;iacute;a si el comando fuera llamado directamente.</target>
        </trans-unit>
        <trans-unit id="898edad6fe267446764a3f01813e23c34e6a4dc9" translate="yes" xml:space="preserve">
          <source>The lexicographic ordering used is binary, it compares strings as array of bytes.</source>
          <target state="translated">El orden lexicográfico utilizado es binario,compara las cadenas como un conjunto de bytes.</target>
        </trans-unit>
        <trans-unit id="e89335ad1d56e8f847f0e52f7c837e0cf165daeb" translate="yes" xml:space="preserve">
          <source>The limitation of this pattern is that we are forced into an append-only mode of operation, there is no way to cut the time series to a given size easily because Redis currently lacks a command able to trim string objects. However the space efficiency of time series stored in this way is remarkable.</source>
          <target state="translated">La limitación de este patrón es que estamos forzados a un modo de operación de sólo aplicación,no hay manera de cortar las series temporales a un tamaño determinado fácilmente porque Redis actualmente carece de un comando capaz de recortar objetos de cuerda.Sin embargo,la eficiencia espacial de las series temporales almacenadas de esta manera es notable.</target>
        </trans-unit>
        <trans-unit id="da33cd971f0747462e42ccd2282a1e6fb83aa7be" translate="yes" xml:space="preserve">
          <source>The list of configuration parameters supported by &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; can be obtained issuing a &lt;code&gt;CONFIG GET *&lt;/code&gt; command, that is the symmetrical command used to obtain information about the configuration of a running Redis instance.</source>
          <target state="translated">La lista de par&amp;aacute;metros de configuraci&amp;oacute;n admitidos por &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; se puede obtener emitiendo un comando &lt;code&gt;CONFIG GET *&lt;/code&gt; , que es el comando sim&amp;eacute;trico utilizado para obtener informaci&amp;oacute;n sobre la configuraci&amp;oacute;n de una instancia de Redis en ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8095634a38168f2c281c9616bbb338721d7efd28" translate="yes" xml:space="preserve">
          <source>The lock will be auto-released after the expire time is reached.</source>
          <target state="translated">La cerradura se liberará automáticamente después de que se alcance el tiempo de caducidad.</target>
        </trans-unit>
        <trans-unit id="08a7894ad23c8503b151cc8bfa325bf87f080cfd" translate="yes" xml:space="preserve">
          <source>The main drawback with the &lt;em&gt;whole scripts replication&lt;/em&gt; approach is that scripts are required to have the following property:</source>
          <target state="translated">El principal inconveniente con el enfoque de &lt;em&gt;replicaci&amp;oacute;n de scripts completos&lt;/em&gt; es que se requiere que los scripts tengan la siguiente propiedad:</target>
        </trans-unit>
        <trans-unit id="7e2e2adfa0c27b3c4fcd6715d167f77cf7aab615" translate="yes" xml:space="preserve">
          <source>The main usage of this command is during rehashing of cluster slots from one node to another. The way the rehashing is performed is exposed in the Redis Cluster specification, or in a more simple to digest form, as an appendix of the &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command documentation.</source>
          <target state="translated">El uso principal de este comando es durante la repetici&amp;oacute;n de ranuras de cl&amp;uacute;ster de un nodo a otro. La forma en que se realiza el refrito se expone en la especificaci&amp;oacute;n de Redis Cluster, o en una forma m&amp;aacute;s simple de resumir, como un ap&amp;eacute;ndice de la documentaci&amp;oacute;n del comando &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51aa615de4288430f4f542dd741b0be9823a9984" translate="yes" xml:space="preserve">
          <source>The master output is composed of the following parts:</source>
          <target state="translated">La salida maestra se compone de las siguientes partes:</target>
        </trans-unit>
        <trans-unit id="9294413196a1d66d0e89a267022407a00ed67b4f" translate="yes" xml:space="preserve">
          <source>The master replies to the replica with the current &lt;em&gt;replication offset&lt;/em&gt;.</source>
          <target state="translated">El maestro responde a la r&amp;eacute;plica con el &lt;em&gt;desplazamiento de r&amp;eacute;plica&lt;/em&gt; actual .</target>
        </trans-unit>
        <trans-unit id="9aa0f4e849bf549de77dfa2bc7bf7ffcfaf99bf4" translate="yes" xml:space="preserve">
          <source>The meaning of &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are the same of the &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; command. Similarly, this command actually returns the same elements that &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; would return if called with the same &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments.</source>
          <target state="translated">El significado de &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; es el mismo que el del comando &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; . De manera similar, este comando en realidad devuelve los mismos elementos que &lt;a href=&quot;zrangebylex&quot;&gt;devolver&amp;iacute;a ZRANGEBYLEX&lt;/a&gt; si se llamara con los mismos argumentos &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e23ac08d91ce30fa5d8f4e6bbb8d1a66fed8600" translate="yes" xml:space="preserve">
          <source>The meaning of each filed is the following:</source>
          <target state="translated">El significado de cada archivo es el siguiente:</target>
        </trans-unit>
        <trans-unit id="69174101963d6daf8e0c498390ca52d478774c02" translate="yes" xml:space="preserve">
          <source>The meaning of the two states is explained in the Redis Specification, however the gist of the two states is the following:</source>
          <target state="translated">El significado de los dos estados se explica en la Especificación de Redis,sin embargo la esencia de los dos estados es la siguiente:</target>
        </trans-unit>
        <trans-unit id="5fe7d63b1ebc573c80de8db8907af87f4669998b" translate="yes" xml:space="preserve">
          <source>The more simple and direct implementation of this pattern is the following:</source>
          <target state="translated">La aplicación más simple y directa de este patrón es la siguiente:</target>
        </trans-unit>
        <trans-unit id="8eafae6da4cd26a48b49e41708a6136f1a6de4a6" translate="yes" xml:space="preserve">
          <source>The motivation for this command is that the ability to store many small integers as a single large bitmap (or segmented over a few keys to avoid having huge keys) is extremely memory efficient, and opens new use cases for Redis to be applied, especially in the field of real time analytics. This use cases are supported by the ability to specify the overflow in a controlled way.</source>
          <target state="translated">La motivación de este comando es que la capacidad de almacenar muchos números enteros pequeños como un único mapa de bits grande (o segmentado sobre unas pocas teclas para evitar tener teclas enormes)es extremadamente eficiente en cuanto a la memoria,y abre nuevos casos de uso para que se aplique Redis,especialmente en el campo de la analítica en tiempo real.Estos casos de uso se apoyan en la capacidad de especificar el desbordamiento de forma controlada.</target>
        </trans-unit>
        <trans-unit id="8a6f6dffc18be981185e9a84435cd70cbbe693b9" translate="yes" xml:space="preserve">
          <source>The name of the consumer that fetched the message and has still to acknowledge it. We call it the current &lt;em&gt;owner&lt;/em&gt; of the message.</source>
          <target state="translated">El nombre del consumidor que obtuvo el mensaje y a&amp;uacute;n debe reconocerlo. Lo llamamos el &lt;em&gt;propietario&lt;/em&gt; actual del mensaje.</target>
        </trans-unit>
        <trans-unit id="95a0cef10627d21f971cf58ca481b45ed9811331" translate="yes" xml:space="preserve">
          <source>The new configuration is persisted on disk in the node cluster configuration file.</source>
          <target state="translated">La nueva configuración se mantiene en el disco en el archivo de configuración del clúster de nodos.</target>
        </trans-unit>
        <trans-unit id="ce3fd26b48bfdbc550ce60034f680213e04e3fa5" translate="yes" xml:space="preserve">
          <source>The new format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69cbd0fd1035f94debad3eb8086987173fc0e180" translate="yes" xml:space="preserve">
          <source>The new score of &lt;code&gt;member&lt;/code&gt; (a double precision floating point number) represented as string, or &lt;code&gt;nil&lt;/code&gt; if the operation was aborted (when called with either the &lt;code&gt;XX&lt;/code&gt; or the &lt;code&gt;NX&lt;/code&gt; option).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1512d4f9273a472bf5054bc09af80c7b583c9993" translate="yes" xml:space="preserve">
          <source>The node ID identifies the same node we are sending the command to.</source>
          <target state="translated">El ID del nodo identifica el mismo nodo al que estamos enviando el comando.</target>
        </trans-unit>
        <trans-unit id="4a94b0edb207a0f9aad4e9890ab6a41a4abc596d" translate="yes" xml:space="preserve">
          <source>The node ID of the removed node gets added to the ban-list, for 1 minute.</source>
          <target state="translated">El ID del nodo eliminado se añade a la lista de prohibiciones,durante 1 minuto.</target>
        </trans-unit>
        <trans-unit id="7282e91e365e1582b64fd77e649fb8fae6ff8480" translate="yes" xml:space="preserve">
          <source>The node current &lt;em&gt;config epoch&lt;/em&gt; is zero.</source>
          <target state="translated">La &lt;em&gt;&amp;eacute;poca de configuraci&amp;oacute;n&lt;/em&gt; actual del nodo es cero.</target>
        </trans-unit>
        <trans-unit id="96c472bb576e96ca78ba9e6916a3879a69d9af69" translate="yes" xml:space="preserve">
          <source>The node is empty, no keys are stored at all in the key space.</source>
          <target state="translated">El nodo está vacío,no hay ninguna llave almacenada en el espacio de las llaves.</target>
        </trans-unit>
        <trans-unit id="c909806a718de9cb07358d8ed9ed00c019748494" translate="yes" xml:space="preserve">
          <source>The node is not serving any hash slots.</source>
          <target state="translated">El nodo no está sirviendo ninguna ranura de hachís.</target>
        </trans-unit>
        <trans-unit id="ce819a3025f8ff3393901c2c8e810e36e0f1c69b" translate="yes" xml:space="preserve">
          <source>The node receiving the command is a replica, and the specified node ID identifies its current master.</source>
          <target state="translated">El nodo que recibe el comando es una réplica,y el ID del nodo especificado identifica a su maestro actual.</target>
        </trans-unit>
        <trans-unit id="3debb3fa567694b78b44554108f738a7a81cf421" translate="yes" xml:space="preserve">
          <source>The node will skip all the node IDs listed in the ban-list when processing gossip sections received in heartbeat packets from other nodes.</source>
          <target state="translated">El nodo se saltará todas las identificaciones de los nodos que figuran en la lista de prohibiciones cuando procese las secciones de chismes recibidas en paquetes de latidos de otros nodos.</target>
        </trans-unit>
        <trans-unit id="a02415f9a093ecefd5c824168bfb43638285dd33" translate="yes" xml:space="preserve">
          <source>The nodes table of the node is empty.</source>
          <target state="translated">La tabla de nodos del nodo está vacía.</target>
        </trans-unit>
        <trans-unit id="a21d4be2cd3c8386a5bd51f51d8e281923d2f322" translate="yes" xml:space="preserve">
          <source>The number of bits set to 1.</source>
          <target state="translated">El número de bits fijado en 1.</target>
        </trans-unit>
        <trans-unit id="59385708853390f9ca74251fea5131270265eecd" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted set, not including elements already existing for which the score was updated.</source>
          <target state="translated">El número de elementos añadidos al conjunto clasificado,sin incluir los elementos ya existentes para los que se actualizó la puntuación.</target>
        </trans-unit>
        <trans-unit id="dc1eea05d5c0b5d2f315739abfba0f7deefc344d" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted sets, not including elements already existing for which the score was updated.</source>
          <target state="translated">El número de elementos añadidos a los conjuntos ordenados,sin incluir los elementos ya existentes para los que se actualizó la puntuación.</target>
        </trans-unit>
        <trans-unit id="e1784080520f069f819c069f9066d039833cf4fa" translate="yes" xml:space="preserve">
          <source>The number of keys existing among the ones specified as arguments. Keys mentioned multiple times and existing are counted multiple times.</source>
          <target state="translated">El número de claves que existen entre las especificadas como argumentos.Las claves mencionadas varias veces y existentes se cuentan varias veces.</target>
        </trans-unit>
        <trans-unit id="3563b055f87d27dac0ac55fd291fab644c82615a" translate="yes" xml:space="preserve">
          <source>The number of members removed from the sorted set, not including non existing members.</source>
          <target state="translated">El número de miembros retirados del conjunto clasificado,sin incluir los miembros no existentes.</target>
        </trans-unit>
        <trans-unit id="2eae56d8105036d6f2b2f01b5669d022f7996c37" translate="yes" xml:space="preserve">
          <source>The number of milliseconds that elapsed since the last time this message was delivered to this consumer.</source>
          <target state="translated">El número de milisegundos que ha pasado desde la última vez que este mensaje fue entregado a este consumidor.</target>
        </trans-unit>
        <trans-unit id="bbb45a4c926e88dd9593fe92bcaf35382576535c" translate="yes" xml:space="preserve">
          <source>The number of returned elements can be limited using the &lt;code&gt;LIMIT&lt;/code&gt; modifier. This modifier takes the &lt;code&gt;offset&lt;/code&gt; argument, specifying the number of elements to skip and the &lt;code&gt;count&lt;/code&gt; argument, specifying the number of elements to return from starting at &lt;code&gt;offset&lt;/code&gt;. The following example will return 10 elements of the sorted version of &lt;code&gt;mylist&lt;/code&gt;, starting at element 0 (&lt;code&gt;offset&lt;/code&gt; is zero-based):</source>
          <target state="translated">El n&amp;uacute;mero de elementos devueltos se puede limitar mediante el modificador &lt;code&gt;LIMIT&lt;/code&gt; . Este modificador toma el argumento de &lt;code&gt;offset&lt;/code&gt; , especificando el n&amp;uacute;mero de elementos a omitir y el argumento de &lt;code&gt;count&lt;/code&gt; , especificando la cantidad de elementos a regresar desde el inicio del &lt;code&gt;offset&lt;/code&gt; . El siguiente ejemplo devolver&amp;aacute; 10 elementos de la versi&amp;oacute;n ordenada de &lt;code&gt;mylist&lt;/code&gt; , comenzando en el elemento 0 (el &lt;code&gt;offset&lt;/code&gt; se basa en cero):</target>
        </trans-unit>
        <trans-unit id="2eeaa2bda10c14131d8f8224aae3f44fbab1d33b" translate="yes" xml:space="preserve">
          <source>The number of times this message was delivered.</source>
          <target state="translated">El número de veces que este mensaje fue entregado.</target>
        </trans-unit>
        <trans-unit id="4b95ac5bed75bd380b7e253506beeb45e5dcdf48" translate="yes" xml:space="preserve">
          <source>The old master receives the configuration update: unblocks its clients and starts replying with redirection messages so that they'll continue the chat with the new master.</source>
          <target state="translated">El antiguo maestro recibe la actualización de la configuración:desbloquea a sus clientes y comienza a responder con mensajes de redirección para que continúen el chat con el nuevo maestro.</target>
        </trans-unit>
        <trans-unit id="1d689942edb764c6bd34cea24670f1e2f9a34fe2" translate="yes" xml:space="preserve">
          <source>The only valid cursors to use are:</source>
          <target state="translated">Los únicos cursores válidos para usar son:</target>
        </trans-unit>
        <trans-unit id="71d7b3a0d8bb44887a86cd184249f11ce4bd68cd" translate="yes" xml:space="preserve">
          <source>The only way to flush the script cache is by explicitly calling the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command, which will &lt;em&gt;completely flush&lt;/em&gt; the scripts cache removing all the scripts executed so far.</source>
          <target state="translated">La &amp;uacute;nica forma de vaciar la cach&amp;eacute; de scripts es llamando expl&amp;iacute;citamente al comando &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; , que vaciar&amp;aacute; &lt;em&gt;completamente&lt;/em&gt; la cach&amp;eacute; de scripts eliminando todos los scripts ejecutados hasta el momento.</target>
        </trans-unit>
        <trans-unit id="851a4dff1ddadeea08eb160100034cb226114c6d" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). A negative &lt;code&gt;count&lt;/code&gt; returns all elements from the &lt;code&gt;offset&lt;/code&gt;. Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79325b395f9601a80868e44ee285b402fa0bfad" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="translated">El argumento opcional &lt;code&gt;LIMIT&lt;/code&gt; se puede usar para obtener solo un rango de los elementos coincidentes (similar al &lt;em&gt;desplazamiento SELECT LIMIT, contar&lt;/em&gt; en SQL). Tenga en cuenta que si el &lt;code&gt;offset&lt;/code&gt; es grande, el conjunto ordenado debe atravesarse para &lt;code&gt;offset&lt;/code&gt; elementos de desplazamiento antes de llegar a los elementos que deben regresar, lo que puede sumar una complejidad de tiempo O (N).</target>
        </trans-unit>
        <trans-unit id="500dba23b5e32b54cd518b60d5bf8b2bf6fe3ec8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITHSCORES&lt;/code&gt; argument makes the command return both the element and its score, instead of the element alone. This option is available since Redis 2.0.</source>
          <target state="translated">El argumento opcional &lt;code&gt;WITHSCORES&lt;/code&gt; hace que el comando devuelva tanto el elemento como su puntuaci&amp;oacute;n, en lugar del elemento solo. Esta opci&amp;oacute;n est&amp;aacute; disponible desde Redis 2.0.</target>
        </trans-unit>
        <trans-unit id="0f54b06c2148c9b6919787651cb0104f905c8131" translate="yes" xml:space="preserve">
          <source>The optional argument specifies how many entries to show. By default up to ten failures are returned. The special &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; argument clears the log. Entries are displayed starting from the most recent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b302b8ebe5d4f766a30687aa495211b0a41cc8" translate="yes" xml:space="preserve">
          <source>The optional arguments and options can modify the command's behavior. The &lt;code&gt;RANK&lt;/code&gt; option specifies the &quot;rank&quot; of the first element to return, in case there are multiple matches. A rank of 1 means to return the first match, 2 to return the second match, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8aa34d3ef4ed317f6f4c66d1281cf452a3e134" translate="yes" xml:space="preserve">
          <source>The optional parameter can be used to select a specific section of information:</source>
          <target state="translated">El parámetro opcional puede utilizarse para seleccionar una sección específica de información:</target>
        </trans-unit>
        <trans-unit id="d3f8920e23cd2f39487b2140b719e87054ae2b2b" translate="yes" xml:space="preserve">
          <source>The order of step 1 and 2 is important. We want the destination node to be ready to accept &lt;code&gt;ASK&lt;/code&gt; redirections when the source node is configured to redirect.</source>
          <target state="translated">El orden de los pasos 1 y 2 es importante. Queremos que el nodo de destino est&amp;eacute; listo para aceptar redirecciones &lt;code&gt;ASK&lt;/code&gt; cuando el nodo de origen est&amp;eacute; configurado para redireccionar.</target>
        </trans-unit>
        <trans-unit id="b62304b58ff7ffb9f9709c25da7f4765174f07a9" translate="yes" xml:space="preserve">
          <source>The output of the command is just a space-separated CSV string, where each line represents a node in the cluster. The following is an example of output:</source>
          <target state="translated">La salida del comando es sólo una cadena CSV separada del espacio,donde cada línea representa un nodo del cúmulo.El siguiente es un ejemplo de salida:</target>
        </trans-unit>
        <trans-unit id="27eaed3275801016a87c11dc8a65ad526a22ea0c" translate="yes" xml:space="preserve">
          <source>The port number of the master.</source>
          <target state="translated">El número de puerto del capitán.</target>
        </trans-unit>
        <trans-unit id="251a4c07dcd21d1710028ff045133e0223bd8086" translate="yes" xml:space="preserve">
          <source>The position is returned, thinking of the string as an array of bits from left to right, where the first byte's most significant bit is at position 0, the second byte's most significant bit is at position 8, and so forth.</source>
          <target state="translated">La posición es devuelta,pensando en la cadena como una matriz de bits de izquierda a derecha,donde el bit más significativo del primer byte está en la posición 0,el bit más significativo del segundo byte está en la posición 8,y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="cf1bf81ee9d88a76e67d9f14175bdac96ea2eae6" translate="yes" xml:space="preserve">
          <source>The position of the specified member is used as the center of the query.</source>
          <target state="translated">La posición del miembro especificado se utiliza como centro de la consulta.</target>
        </trans-unit>
        <trans-unit id="fe9f9e53a4720c0a3b3f8dd9ba6795a8d524ecc9" translate="yes" xml:space="preserve">
          <source>The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.</source>
          <target state="translated">La precisión de la salida está fijada en 17 dígitos después del punto decimal,independientemente de la precisión interna real del cálculo.</target>
        </trans-unit>
        <trans-unit id="77e23fa703efecfb1c5bf352cb4f0529fa3a9d39" translate="yes" xml:space="preserve">
          <source>The query's center point is provided by one of these mandatory options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e2a1f42bcb6a5e4c6e642aa88cfced9dff68d3" translate="yes" xml:space="preserve">
          <source>The query's shape is provided by one of these mandatory options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9079c728747b4e6051aebcc896878af23a86276" translate="yes" xml:space="preserve">
          <source>The radius is specified in one of the following units:</source>
          <target state="translated">El radio se especifica en una de las siguientes unidades:</target>
        </trans-unit>
        <trans-unit id="5d69c6f303471181769a8ce1e67050c18c180806" translate="yes" xml:space="preserve">
          <source>The range is close (inclusive) by default, meaning that the reply can include entries with IDs matching the query's start and end intervals. It is possible to specify an open interval (exclusive) by prefixing the ID with the character &lt;code&gt;(&lt;/code&gt;. This is useful for iterating the stream, as explained below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa101056c680bd6adea2c67580ad18683b432390" translate="yes" xml:space="preserve">
          <source>The range of values supported by &lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt; is limited to 64 bit signed integers.</source>
          <target state="translated">El rango de valores admitidos por &lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt; est&amp;aacute; limitado a enteros de 64 bits con signo.</target>
        </trans-unit>
        <trans-unit id="33bdfca071502b90c1a8026acb1caf737da192b8" translate="yes" xml:space="preserve">
          <source>The rate limiter pattern is a special counter that is used to limit the rate at which an operation can be performed. The classical materialization of this pattern involves limiting the number of requests that can be performed against a public API.</source>
          <target state="translated">El patrón de limitación de la tasa es un contador especial que se utiliza para limitar la tasa a la que se puede realizar una operación.La materialización clásica de esta pauta consiste en limitar el número de solicitudes que pueden realizarse contra una API pública.</target>
        </trans-unit>
        <trans-unit id="602f859c103a55957a4cbd71395a1cae9a978824" translate="yes" xml:space="preserve">
          <source>The reason is that sending a script to another Redis instance is often much faster than sending the multiple commands the script generates, so if the client is sending many scripts to the master, converting the scripts into individual commands for the replica / AOF would result in too much bandwidth for the replication link or the Append Only File (and also too much CPU since dispatching a command received via network is a lot more work for Redis compared to dispatching a command invoked by Lua scripts).</source>
          <target state="translated">La razón es que el envío de un guión a otra instancia de Redis suele ser mucho más rápido que el envío de los múltiples comandos que el guión genera,por lo que si el cliente está enviando muchos guiones al maestro,la conversión de los guiones en comandos individuales para la réplica/AOF resultaría en demasiado ancho de banda para el enlace de la réplica o el archivo Append Only (y también demasiado CPU,ya que el envío de un comando recibido a través de la red es mucho más trabajo para Redis en comparación con el envío de un comando invocado por los guiones Lua).</target>
        </trans-unit>
        <trans-unit id="f4d6d43d2e03d821aeb88801c0d8fb884cbca911" translate="yes" xml:space="preserve">
          <source>The reason why scripts can be cached for long time is that it is unlikely for a well written application to have enough different scripts to cause memory problems. Every script is conceptually like the implementation of a new command, and even a large application will likely have just a few hundred of them. Even if the application is modified many times and scripts will change, the memory used is negligible.</source>
          <target state="translated">La razón por la que los guiones pueden ser almacenados en caché durante mucho tiempo es que es poco probable que una aplicación bien escrita tenga suficientes guiones diferentes para causar problemas de memoria.Cada guión es conceptualmente como la implementación de un nuevo comando,e incluso una gran aplicación probablemente tendrá sólo unos pocos cientos de ellos.Incluso si la aplicación se modifica muchas veces y los guiones cambian,la memoria utilizada es insignificante.</target>
        </trans-unit>
        <trans-unit id="0e5533e8fee1cbd59ebef949c8411c0d7d01dc8e" translate="yes" xml:space="preserve">
          <source>The replica output is composed of the following parts:</source>
          <target state="translated">La salida de la réplica se compone de las siguientes partes:</target>
        </trans-unit>
        <trans-unit id="d985304abe6bf0f8f4ea24090445b6bf55af90d3" translate="yes" xml:space="preserve">
          <source>The replica starts a failover, obtains a new configuration epoch from the majority of the masters, and broadcasts the new configuration.</source>
          <target state="translated">La réplica inicia un failover,obtiene una nueva época de configuración de la mayoría de los maestros,y transmite la nueva configuración.</target>
        </trans-unit>
        <trans-unit id="7c096a5e647ff1a64af00045529cba5bd168f06b" translate="yes" xml:space="preserve">
          <source>The replica tells the master to stop processing queries from clients.</source>
          <target state="translated">La réplica le dice al maestro que deje de procesar las consultas de los clientes.</target>
        </trans-unit>
        <trans-unit id="e43729fea60babeefa0888b3097ef84a1143b1a0" translate="yes" xml:space="preserve">
          <source>The replica waits for the replication offset to match on its side, to make sure it processed all the data from the master before it continues.</source>
          <target state="translated">La réplica espera a que la compensación de la réplica coincida en su lado,para asegurarse de que procesó todos los datos del maestro antes de continuar.</target>
        </trans-unit>
        <trans-unit id="71f9285cf89c4539aedf2939b67fe3ee74695f78" translate="yes" xml:space="preserve">
          <source>The reply format is identical to that of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;, and the content consists only of information about the current client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6d847d0bceaf13a4c9effd31564050074fa753" translate="yes" xml:space="preserve">
          <source>The reported information contains all of the fields reported by the simple form of &lt;code&gt;XINFO STREAM&lt;/code&gt;, with some additional information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb0e618b4e3d9e5fe2c17d1edb7fb80034a8b4f" translate="yes" xml:space="preserve">
          <source>The reported usage is the total of memory allocations for data and administrative overheads that a key its value require.</source>
          <target state="translated">El uso comunicado es el total de las asignaciones de memoria para los datos y los gastos generales administrativos que una clave requiere su valor.</target>
        </trans-unit>
        <trans-unit id="79c8f80736bb00aecddcc76c1b8f02af94064a15" translate="yes" xml:space="preserve">
          <source>The representation is neutral from the point of view of the processor word size and endianness, so the same representation is used by 32 bit and 64 bit processor, big endian or little endian.</source>
          <target state="translated">La representación es neutra desde el punto de vista del tamaño de la palabra del procesador y de la endianidad,por lo que la misma representación es utilizada por el procesador de 32 y 64 bits,la gran endian o la pequeña endian.</target>
        </trans-unit>
        <trans-unit id="d07c8ceb7018e1bcd908f1c44ebce957404cda02" translate="yes" xml:space="preserve">
          <source>The representation used by &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; considers the bitmap as having the bit number 0 to be the most significant bit of the first byte, and so forth, so for example setting a 5 bits unsigned integer to value 23 at offset 7 into a bitmap previously set to all zeroes, will produce the following representation:</source>
          <target state="translated">La representaci&amp;oacute;n utilizada por &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; considera que el mapa de bits tiene el n&amp;uacute;mero de bit 0 como el bit m&amp;aacute;s significativo del primer byte, y as&amp;iacute; sucesivamente, por ejemplo, establecer un entero sin signo de 5 bits en el valor 23 en el desplazamiento 7 en un mapa de bits previamente establecido en todos ceros, producir&amp;aacute; la siguiente representaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="69c89883952564695abb2bebcaf5f11f6b3d6f75" translate="yes" xml:space="preserve">
          <source>The result of the operation is always stored at &lt;code&gt;destkey&lt;/code&gt;.</source>
          <target state="translated">El resultado de la operaci&amp;oacute;n siempre se almacena en &lt;code&gt;destkey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8563416a363c2cdbe31060c220e5e3844f6d8270" translate="yes" xml:space="preserve">
          <source>The return type of the command is a &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;.</source>
          <target state="translated">El tipo de retorno del comando es una &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;respuesta de matriz&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29bc7d6c144c9d4891cb5866b63897dea6e00bee" translate="yes" xml:space="preserve">
          <source>The returned cardinality of the observed set is not exact, but approximated with a standard error of 0.81%.</source>
          <target state="translated">La cardinalidad devuelta del conjunto observado no es exacta,pero se aproxima con un error estándar de 0,81%.</target>
        </trans-unit>
        <trans-unit id="f485b5467a04f58f023ce0589b088bae79cd349e" translate="yes" xml:space="preserve">
          <source>The rewrite is performed in a very conservative way:</source>
          <target state="translated">La reescritura se realiza de forma muy conservadora:</target>
        </trans-unit>
        <trans-unit id="3d4aef252f6710693b627be68f7b05c7734609ba" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ba82b2fd87a033c00319b26e5a7be447966868" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence. Specifically:</source>
          <target state="translated">La reescritura sólo será activada por Redis si no hay ya un proceso de fondo haciendo persistencia.Específicamente:</target>
        </trans-unit>
        <trans-unit id="1f1d9ccb03a5f0171c2e12fc9e5717671728f51a" translate="yes" xml:space="preserve">
          <source>The same bit position convention is followed by &lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt; and &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;.</source>
          <target state="translated">La misma convenci&amp;oacute;n de posici&amp;oacute;n de bit es seguida por &lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt; y &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2db5a15e45c348362ce43e64d992a94fa7834d6c" translate="yes" xml:space="preserve">
          <source>The same holds true for non-existent keys, that are considered as a stream of zero bytes up to the length of the longest string.</source>
          <target state="translated">Lo mismo ocurre con las claves inexistentes,que se consideran como una corriente de cero bytes hasta la longitud de la cadena más larga.</target>
        </trans-unit>
        <trans-unit id="459993ded23b09fc27e5d6a4bf1ae20c56fbcf0c" translate="yes" xml:space="preserve">
          <source>The save parameter is a single string of space-separated integers. Every pair of integers represent a seconds/modifications threshold.</source>
          <target state="translated">El parámetro de guardado es una sola cadena de números enteros separados por el espacio.Cada par de números enteros representa un umbral de segundos/modificaciones.</target>
        </trans-unit>
        <trans-unit id="19337abd9b3767724cccba46357082deb732a2c0" translate="yes" xml:space="preserve">
          <source>The score values should be the string representation of a double precision floating point number. &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; values are valid values as well.</source>
          <target state="translated">Los valores de puntuaci&amp;oacute;n deben ser la representaci&amp;oacute;n de cadena de un n&amp;uacute;mero de punto flotante de doble precisi&amp;oacute;n. &lt;code&gt;-inf&lt;/code&gt; valores &lt;code&gt;+inf&lt;/code&gt; y -inf tambi&amp;eacute;n son valores v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="8704ce1cdf5da36cc8175add936925537e2b6762" translate="yes" xml:space="preserve">
          <source>The script is guaranteed to stay in the script cache forever (unless &lt;code&gt;SCRIPT
FLUSH&lt;/code&gt; is called).</source>
          <target state="translated">Se garantiza que el script permanecer&amp;aacute; en la cach&amp;eacute; del script para siempre (a menos que se llame a &lt;code&gt;SCRIPT FLUSH&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="84e6859345305305b03236c94f49ebcdfaf9f284" translate="yes" xml:space="preserve">
          <source>The script must always evaluates the same Redis &lt;em&gt;write&lt;/em&gt; commands with the same arguments given the same input data set. Operations performed by the script cannot depend on any hidden (non-explicit) information or state that may change as script execution proceeds or between different executions of the script, nor can it depend on any external input from I/O devices.</source>
          <target state="translated">El script siempre debe evaluar los mismos comandos de &lt;em&gt;escritura de&lt;/em&gt; Redis con los mismos argumentos dado el mismo conjunto de datos de entrada. Las operaciones realizadas por el script no pueden depender de ninguna informaci&amp;oacute;n oculta (no expl&amp;iacute;cita) o estado que pueda cambiar a medida que avanza la ejecuci&amp;oacute;n del script o entre diferentes ejecuciones del script, ni puede depender de ninguna entrada externa de los dispositivos de E / S.</target>
        </trans-unit>
        <trans-unit id="f6f50abe88117410baf6ae78d63eac9d06193d38" translate="yes" xml:space="preserve">
          <source>The script should be called with &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt;</source>
          <target state="translated">Se debe llamar al &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt; con EVAL ... script ... 1 nombre-recurso valor-token</target>
        </trans-unit>
        <trans-unit id="ae5f9a8c3637986eaac0c1b5c2a821ed62bfff96" translate="yes" xml:space="preserve">
          <source>The second argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is the number of arguments that follows the script (starting from the third argument) that represent Redis key names. The arguments can be accessed by Lua using the &lt;code&gt;KEYS&lt;/code&gt; global variable in the form of a one-based array (so &lt;code&gt;KEYS[1]&lt;/code&gt;, &lt;code&gt;KEYS[2]&lt;/code&gt;, ...).</source>
          <target state="translated">El segundo argumento de &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; es el n&amp;uacute;mero de argumentos que siguen al script (a partir del tercer argumento) que representan los nombres de las claves de Redis. Lua puede acceder a los argumentos utilizando la variable global &lt;code&gt;KEYS&lt;/code&gt; en forma de una matriz basada en uno (por lo tanto, &lt;code&gt;KEYS[1]&lt;/code&gt; , &lt;code&gt;KEYS[2]&lt;/code&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="5e06049c7fb2a08a77ed966e80b1bd0de88bb6c2" translate="yes" xml:space="preserve">
          <source>The semantic change between patch level releases was needed since the old behavior was inherently incompatible with the Redis replication layer and was the cause of bugs.</source>
          <target state="translated">El cambio semántico entre las liberaciones de nivel de parche era necesario ya que el viejo comportamiento era inherentemente incompatible con la capa de replicación de Redis y era la causa de los bichos.</target>
        </trans-unit>
        <trans-unit id="c86d0b330e63015ff6018ffba522da6d3c2c8fb8" translate="yes" xml:space="preserve">
          <source>The sentinel output is composed of the following parts:</source>
          <target state="translated">La salida del centinela se compone de las siguientes partes:</target>
        </trans-unit>
        <trans-unit id="295a39c211fe9b12478b873df477a317d327e2b4" translate="yes" xml:space="preserve">
          <source>The serialization format is opaque and non-standard, however it has a few semantic characteristics:</source>
          <target state="translated">El formato de serialización es opaco y no estándar,sin embargo tiene algunas características semánticas:</target>
        </trans-unit>
        <trans-unit id="06e5cb4e4d36f51aabfd49438bd236dcf9c4976a" translate="yes" xml:space="preserve">
          <source>The serialized value does NOT contain expire information. In order to capture the time to live of the current value the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command should be used.</source>
          <target state="translated">El valor serializado NO contiene informaci&amp;oacute;n de vencimiento. Para capturar el tiempo de vida del valor actual, se debe utilizar el comando &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd5acc612a2b52a80de5b2a3e24e38f5ba00302b" translate="yes" xml:space="preserve">
          <source>The size of the string stored in the destination key, that is equal to the size of the longest input string.</source>
          <target state="translated">El tamaño de la cadena almacenada en la tecla de destino,que es igual al tamaño de la cadena de entrada más larga.</target>
        </trans-unit>
        <trans-unit id="1a0a5df2b74e73a15c2817e253d14a10935a2191" translate="yes" xml:space="preserve">
          <source>The slow log is accumulated in memory, so no file is written with information about the slow command executions. This makes the slow log remarkably fast at the point that you can enable the logging of all the commands (setting the &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; config parameter to zero) with minor performance hit.</source>
          <target state="translated">El registro lento se acumula en la memoria, por lo que no se escribe ning&amp;uacute;n archivo con informaci&amp;oacute;n sobre las ejecuciones lentas de los comandos. Esto hace que el registro lento sea notablemente r&amp;aacute;pido en el punto en que puede habilitar el registro de todos los comandos (estableciendo el par&amp;aacute;metro &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; config en cero) con un impacto menor en el rendimiento.</target>
        </trans-unit>
        <trans-unit id="4eaa8de726819dc3e71079d7a6f328e12fd9ddc2" translate="yes" xml:space="preserve">
          <source>The sparse representation uses a run-length encoding optimized to store efficiently a big number of registers set to zero. The dense representation is a Redis string of 12288 bytes in order to store 16384 6-bit counters. The need for the double representation comes from the fact that using 12k (which is the dense representation memory requirement) to encode just a few registers for smaller cardinalities is extremely suboptimal.</source>
          <target state="translated">La representación dispersa utiliza una codificación de duración optimizada para almacenar eficientemente un gran número de registros puestos a cero.La representación densa es una cadena Redis de 12288 bytes para almacenar 16384 contadores de 6 bits.La necesidad de la doble representación proviene del hecho de que utilizar 12k (que es el requisito de memoria de representación densa)para codificar sólo unos pocos registros para cardinalidades más pequeñas es extremadamente subóptimo.</target>
        </trans-unit>
        <trans-unit id="8eeebccfe9d0cfc87769de4a2c07747fec580fbc" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$&lt;/code&gt; ID.</source>
          <target state="translated">El &lt;code&gt;$&lt;/code&gt; ID especial .</target>
        </trans-unit>
        <trans-unit id="0f067eeaba3e5a87a3236774a27fada6161ea70f" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;&amp;gt;&lt;/code&gt; ID, which means that the consumer want to receive only messages that were &lt;em&gt;never delivered to any other consumer&lt;/em&gt;. It just means, give me new messages.</source>
          <target state="translated">El &lt;code&gt;&amp;gt;&lt;/code&gt; ID especial , que significa que el consumidor desea recibir solo mensajes que &lt;em&gt;nunca se entregaron a ning&amp;uacute;n otro consumidor&lt;/em&gt; . Solo significa, dame nuevos mensajes.</target>
        </trans-unit>
        <trans-unit id="5029fc6d051bb809efc7fcb4a44af5a544f6b49f" translate="yes" xml:space="preserve">
          <source>The specified node ID does not identify the instance we are sending the command to.</source>
          <target state="translated">El ID del nodo especificado no identifica la instancia a la que estamos enviando el comando.</target>
        </trans-unit>
        <trans-unit id="15f8e4eecac9b5616dbc97abb4f74fd51bce6356" translate="yes" xml:space="preserve">
          <source>The specified node ID exists in its nodes table.</source>
          <target state="translated">El ID del nodo especificado existe en su tabla de nodos.</target>
        </trans-unit>
        <trans-unit id="07565949c7a13614b4cf396e3dee4474076dd98c" translate="yes" xml:space="preserve">
          <source>The specified node ID is a master.</source>
          <target state="translated">El ID de nodo especificado es un maestro.</target>
        </trans-unit>
        <trans-unit id="92c45a066b5df5b3300ad8d74734dc668cec5a44" translate="yes" xml:space="preserve">
          <source>The specified node ID is not found in the nodes table.</source>
          <target state="translated">El ID de nodo especificado no se encuentra en la tabla de nodos.</target>
        </trans-unit>
        <trans-unit id="dadcfd8e793bf395f94eff22f99b0da2a7a715b6" translate="yes" xml:space="preserve">
          <source>The specified node gets removed from the nodes table.</source>
          <target state="translated">El nodo especificado se elimina de la tabla de nodos.</target>
        </trans-unit>
        <trans-unit id="3be929a4c6ff231339b330125852213fb5229ce4" translate="yes" xml:space="preserve">
          <source>The state of the replication from the point of view of the master, that can be &lt;code&gt;connect&lt;/code&gt; (the instance needs to connect to its master), &lt;code&gt;connecting&lt;/code&gt; (the master-replica connection is in progress), &lt;code&gt;sync&lt;/code&gt; (the master and replica are trying to perform the synchronization), &lt;code&gt;connected&lt;/code&gt; (the replica is online).</source>
          <target state="translated">El estado de la replicaci&amp;oacute;n desde el punto de vista del maestro, que se puede &lt;code&gt;connect&lt;/code&gt; (la instancia necesita conectarse a su maestro), &lt;code&gt;connecting&lt;/code&gt; (la conexi&amp;oacute;n maestro-r&amp;eacute;plica est&amp;aacute; en curso), &lt;code&gt;sync&lt;/code&gt; (el maestro y la r&amp;eacute;plica est&amp;aacute;n intentando realizar la sincronizaci&amp;oacute;n), &lt;code&gt;connected&lt;/code&gt; (la r&amp;eacute;plica est&amp;aacute; en l&amp;iacute;nea).</target>
        </trans-unit>
        <trans-unit id="b8b0d67ec2d33e9415285fa0b1b04c01c7c00db9" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;-&amp;gt;&lt;/code&gt; is used to separate the key name from the hash field name. The key is substituted as documented above, and the hash stored at the resulting key is accessed to retrieve the specified hash field.</source>
          <target state="translated">La cadena &lt;code&gt;-&amp;gt;&lt;/code&gt; se usa para separar el nombre de la clave del nombre del campo hash. La clave se sustituye como se document&amp;oacute; anteriormente, y se accede al hash almacenado en la clave resultante para recuperar el campo hash especificado.</target>
        </trans-unit>
        <trans-unit id="f708ccbae2afe95a0cd4653de56c8fb34c79374e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;master&lt;/code&gt; cuerdas .</target>
        </trans-unit>
        <trans-unit id="b2940a9d939b4548e348a547825fc4662aaec04e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;sentinel&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;sentinel&lt;/code&gt; cuerdas .</target>
        </trans-unit>
        <trans-unit id="4d8519eae0e62aff504d921a1adc6159ed001fa3" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatbility (see note at the end of this page).</source>
          <target state="translated">El &lt;code&gt;slave&lt;/code&gt; cadena , debido a la compatibilidad con versiones anteriores (consulte la nota al final de esta p&amp;aacute;gina).</target>
        </trans-unit>
        <trans-unit id="6831b1a65326ef3cc261059e475703f978f1b6bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatibility (see note at the end of this page).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a409de83f682db65c898664c9dbb138b1160b8f1" translate="yes" xml:space="preserve">
          <source>The summary provides a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cc70797e244120c92cdce0be9d797bbb5993d5" translate="yes" xml:space="preserve">
          <source>The supported types are up to 64 bits for signed integers, and up to 63 bits for unsigned integers. This limitation with unsigned integers is due to the fact that currently the Redis protocol is unable to return 64 bit unsigned integers as replies.</source>
          <target state="translated">Los tipos soportados son hasta 64 bits para los enteros con signo,y hasta 63 bits para los enteros sin signo.Esta limitación con los números enteros sin signo se debe a que actualmente el protocolo Redis no puede devolver como respuesta números enteros sin signo de 64 bits.</target>
        </trans-unit>
        <trans-unit id="7a2d3466f691698508a75fad6644713be3c44a8f" translate="yes" xml:space="preserve">
          <source>The symmetric command used to alter the configuration at run time is &lt;code&gt;CONFIG
SET&lt;/code&gt;.</source>
          <target state="translated">El comando sim&amp;eacute;trico utilizado para modificar la configuraci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n es &lt;code&gt;CONFIG SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4ef14ef5924effb0e2166473b48d643f3dd0b5a" translate="yes" xml:space="preserve">
          <source>The system administrator sends a &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; command to force a node to meet another one.</source>
          <target state="translated">El administrador del sistema env&amp;iacute;a un comando &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; para forzar a un nodo a encontrarse con otro.</target>
        </trans-unit>
        <trans-unit id="f7dd65cc5a619424783dd395e5066f1952bf62a3" translate="yes" xml:space="preserve">
          <source>The third nested reply is guaranteed to be the IP/Port pair of the master instance for the slot range. All IP/Port pairs after the third nested reply are replicas of the master.</source>
          <target state="translated">La tercera respuesta anidada se garantiza que es el par IP/puerto de la instancia maestra para el rango de ranura.Todos los pares IP/puerto después de la tercera respuesta anidada son réplicas de la maestra.</target>
        </trans-unit>
        <trans-unit id="bc7c54ea663acc1cd16d645f286e49bdb17828f2" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in all existing databases.</source>
          <target state="translated">La complejidad temporal de esta operación es O(N),siendo N el número de claves en todas las bases de datos existentes.</target>
        </trans-unit>
        <trans-unit id="5dd2a246bdbf984a712d84e324dfcd54e3e83cfb" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in the database.</source>
          <target state="translated">La complejidad temporal de esta operación es O(N),siendo N el número de claves en la base de datos.</target>
        </trans-unit>
        <trans-unit id="33b9dc1580854319ae2c493dffcae592f1834dfc" translate="yes" xml:space="preserve">
          <source>The timeout can also be cleared, turning the key back into a persistent key, using the &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command.</source>
          <target state="translated">El tiempo de espera tambi&amp;eacute;n se puede borrar, convirtiendo la clave nuevamente en una clave persistente, usando el comando &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3cd5936158e61d7536637d6c3696dfb0161419" translate="yes" xml:space="preserve">
          <source>The timeout specifies the maximum idle time in any moment of the communication with the destination instance in milliseconds. This means that the operation does not need to be completed within the specified amount of milliseconds, but that the transfer should make progresses without blocking for more than the specified amount of milliseconds.</source>
          <target state="translated">El tiempo de espera especifica el máximo tiempo de inactividad en cualquier momento de la comunicación con la instancia de destino en milisegundos.Esto significa que la operación no necesita ser completada dentro de la cantidad especificada de milisegundos,sino que la transferencia debe progresar sin bloquearse por más de la cantidad especificada de milisegundos.</target>
        </trans-unit>
        <trans-unit id="47a97f0f97c34f511b051b78756091a74729e20b" translate="yes" xml:space="preserve">
          <source>The timeout will only be cleared by commands that delete or overwrite the contents of the key, including &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; and all the &lt;code&gt;*STORE&lt;/code&gt; commands. This means that all the operations that conceptually &lt;em&gt;alter&lt;/em&gt; the value stored at the key without replacing it with a new one will leave the timeout untouched. For instance, incrementing the value of a key with &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;, pushing a new value into a list with &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, or altering the field value of a hash with &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; are all operations that will leave the timeout untouched.</source>
          <target state="translated">El tiempo de espera solo se borrar&amp;aacute; mediante comandos que eliminen o sobrescriban el contenido de la clave, incluidos &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; , &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; , &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; y todos los comandos &lt;code&gt;*STORE&lt;/code&gt; . Esto significa que todas las operaciones que &lt;em&gt;alteren&lt;/em&gt; conceptualmente el valor almacenado en la clave sin reemplazarlo por uno nuevo dejar&amp;aacute;n intacto el tiempo de espera. Por ejemplo, incrementar el valor de una clave con &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; , insertar un nuevo valor en una lista con &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; o alterar el valor de campo de un hash con &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; son operaciones que dejar&amp;aacute;n el tiempo de espera intacto.</target>
        </trans-unit>
        <trans-unit id="b4902022e2711d4049af153f6960e9c07559e3db" translate="yes" xml:space="preserve">
          <source>The unit must be one of the following, and defaults to meters:</source>
          <target state="translated">La unidad debe ser una de las siguientes,y por defecto,metros:</target>
        </trans-unit>
        <trans-unit id="a995cbd615ab3e6d82df762d54a3d2493e68cc0e" translate="yes" xml:space="preserve">
          <source>The unix timestamp at which the logged command was processed.</source>
          <target state="translated">La marca de tiempo unix en la que se procesó el comando registrado.</target>
        </trans-unit>
        <trans-unit id="a0310f88660618094c01bca5ea0d0463bbd02002" translate="yes" xml:space="preserve">
          <source>The user just turned on AOF, and the server triggered the first AOF rewrite in order to create the initial AOF file. In this context, stopping will result in losing the dataset at all: once restarted, the server will potentially have AOF enabled without having any AOF file at all.</source>
          <target state="translated">El usuario acaba de encender el AOF,y el servidor disparó la primera reescritura del AOF para crear el archivo AOF inicial.En este contexto,detenerse resultará en la pérdida del conjunto de datos en absoluto:una vez reiniciado,el servidor potencialmente tendrá AOF activado sin tener ningún archivo AOF en absoluto.</target>
        </trans-unit>
        <trans-unit id="5f17b8b7fd14b72046eefe6ae0e142f682927503" translate="yes" xml:space="preserve">
          <source>The user should be aware that if the same existing key is mentioned in the arguments multiple times, it will be counted multiple times. So if &lt;code&gt;somekey&lt;/code&gt; exists, &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; will return 2.</source>
          <target state="translated">El usuario debe tener en cuenta que si la misma clave existente se menciona en los argumentos varias veces, se contar&amp;aacute; varias veces. As&amp;iacute; que si &lt;code&gt;somekey&lt;/code&gt; existe, &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; volver&amp;aacute; 2.</target>
        </trans-unit>
        <trans-unit id="a2b1b03bb92333675d117bc7fc8c0c76fc472f63" translate="yes" xml:space="preserve">
          <source>The user should take in mind that single-key and multiple-keys executions of this command are semantically different and have different performances.</source>
          <target state="translated">El usuario debe tener en cuenta que las ejecuciones de una sola tecla y de varias teclas de este comando son semánticamente diferentes y tienen diferentes rendimientos.</target>
        </trans-unit>
        <trans-unit id="aee2053c45b6ced184922e49824bb87ce4f26e87" translate="yes" xml:space="preserve">
          <source>The vertical labels under each graph column represent the amount of seconds, minutes, hours or days ago the event happened. For example &quot;15s&quot; means that the first graphed event happened 15 seconds ago.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0c79b31b353c9ce51c111498c89af1634cee6b" translate="yes" xml:space="preserve">
          <source>The way the sorted set is populated is using a technique called &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;. Latitude and Longitude bits are interleaved in order to form an unique 52 bit integer. We know that a sorted set double score can represent a 52 bit integer without losing precision.</source>
          <target state="translated">La forma en que se completa el conjunto ordenado es mediante una t&amp;eacute;cnica llamada &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; . Los bits de latitud y longitud se intercalan para formar un entero &amp;uacute;nico de 52 bits. Sabemos que una puntuaci&amp;oacute;n doble de un conjunto ordenado puede representar un entero de 52 bits sin perder precisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7b31bb2e561758eaef35a12c00599f8b3a9ccbe4" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call as an exclusive interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473281da4300480447326ee40d8d889bb9d90481" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call, adding the sequence part of the ID by one.</source>
          <target state="translated">Luego, en lugar de comenzar la iteraci&amp;oacute;n nuevamente desde &lt;code&gt;-&lt;/code&gt; , como el inicio del rango, usamos el ID de entrada de la &lt;em&gt;&amp;uacute;ltima&lt;/em&gt; entrada devuelta por la llamada &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; anterior , agregando la parte de secuencia del ID en uno.</target>
        </trans-unit>
        <trans-unit id="49d73108f34c912bc3dcd46d706878a2b1cfa83b" translate="yes" xml:space="preserve">
          <source>Then suddenly that consumer fails forever.</source>
          <target state="translated">Entonces,de repente,ese consumidor falla para siempre.</target>
        </trans-unit>
        <trans-unit id="c54ead856d23cc39661d8102bdb6330ddb30ed3d" translate="yes" xml:space="preserve">
          <source>Then we may want to know what commands are part of a given category:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66921f715545a310ecff4dca64b25267fdd5efb" translate="yes" xml:space="preserve">
          <source>There are also optional fields emitted only by Redis 4.0 or greater:</source>
          <target state="translated">También hay campos opcionales emitidos sólo por Redis 4.0 o superior:</target>
        </trans-unit>
        <trans-unit id="a381e0a250a57263ea1da7d6465921f290bc2868" translate="yes" xml:space="preserve">
          <source>There are cases when you need to set all the bits of single bitmap at once, for example when initializing it to a default non-zero value. It is possible to do this with multiple calls to the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command, one for each bit that needs to be set. However, so as an optimization you can use a single &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to set the entire bitmap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf4557f2ee4da2fe1ae76ce2cecd829e57c75d9" translate="yes" xml:space="preserve">
          <source>There are conditions when we want just to terminate a Redis instance ASAP, regardless of what its content is. In such a case, the right combination of commands is to send a &lt;strong&gt;CONFIG appendonly no&lt;/strong&gt; followed by a &lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt;. The first command will turn off the AOF if needed, and will terminate the AOF rewriting child if there is one active. The second command will not have any problem to execute since the AOF is no longer enabled.</source>
          <target state="translated">Hay condiciones en las que solo queremos terminar una instancia de Redis lo antes posible, independientemente de cu&amp;aacute;l sea su contenido. En tal caso, la combinaci&amp;oacute;n correcta de comandos es enviar un &lt;strong&gt;CONFIG adjunto solo no&lt;/strong&gt; seguido de un &lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt; . El primer comando apagar&amp;aacute; el AOF si es necesario, y terminar&amp;aacute; el hijo de reescritura de AOF si hay uno activo. El segundo comando no tendr&amp;aacute; ning&amp;uacute;n problema para ejecutarse ya que el AOF ya no est&amp;aacute; habilitado.</target>
        </trans-unit>
        <trans-unit id="158a7d63bcc769d78e3493a2bc55c7a4ee6bce03" translate="yes" xml:space="preserve">
          <source>There are multiple clients rotating the list: they'll fetch different elements, until all the elements of the list are visited, and the process restarts.</source>
          <target state="translated">Hay múltiples clientes que rotan la lista:van a buscar diferentes elementos,hasta que todos los elementos de la lista son visitados,y el proceso se reinicia.</target>
        </trans-unit>
        <trans-unit id="bdda3afdb8163e659ca9981491dbe7bcadb74afd" translate="yes" xml:space="preserve">
          <source>There are situations where this is not enough, and we want a replica to failover without any agreement with the rest of the cluster. A real world use case for this is to mass promote replicas in a different data center to masters in order to perform a data center switch, while all the masters are down or partitioned away.</source>
          <target state="translated">Hay situaciones en las que esto no es suficiente,y queremos una réplica para la conmutación por error sin ningún acuerdo con el resto del grupo.Un caso de uso en el mundo real para esto es promover en masa réplicas en un centro de datos diferente a los maestros con el fin de realizar un cambio de centro de datos,mientras que todos los maestros están abajo o particionados.</target>
        </trans-unit>
        <trans-unit id="6bd7c5396466fc74307415d5fb57447e1fc4a356" translate="yes" xml:space="preserve">
          <source>There are times when a list can receive multiple elements in the context of the same conceptual command:</source>
          <target state="translated">Hay veces en que una lista puede recibir múltiples elementos en el contexto del mismo comando conceptual:</target>
        </trans-unit>
        <trans-unit id="8e2a3e6a950f5d8a609385be1af06951e77dc2ea" translate="yes" xml:space="preserve">
          <source>There are two helper functions to return Redis types from Lua.</source>
          <target state="translated">Hay dos funciones de ayuda para devolver los tipos de Redis de Lua.</target>
        </trans-unit>
        <trans-unit id="be8d4180a42a37a500975b93ef1e55ade0e6286d" translate="yes" xml:space="preserve">
          <source>There are two ways in order to specify offsets in the bitfield command. If a number without any prefix is specified, it is used just as a zero based bit offset inside the string.</source>
          <target state="translated">Hay dos maneras de especificar las compensaciones en el comando de campo de bits.Si se especifica un número sin ningún prefijo,se utiliza como un desplazamiento de bits basado en cero dentro de la cadena.</target>
        </trans-unit>
        <trans-unit id="d75f55602fddc93ba9011e7393a6bc36a64ba5a7" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;no simple way to have nils inside Lua arrays&lt;/a&gt;, this is a result of Lua table semantics, so when Redis converts a Lua array into Redis protocol the conversion is stopped if a nil is encountered.</source>
          <target state="translated">No &lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;hay una forma sencilla de tener nulos dentro de las matrices Lua&lt;/a&gt; , esto es el resultado de la sem&amp;aacute;ntica de la tabla Lua, por lo que cuando Redis convierte una matriz Lua en el protocolo Redis, la conversi&amp;oacute;n se detiene si se encuentra un nil.</target>
        </trans-unit>
        <trans-unit id="1181df382608fdc99dac69533a65959f383591cd" translate="yes" xml:space="preserve">
          <source>There is a different way to fix this issue without using scripting, but using Redis lists instead of counters. The implementation is more complex and uses more advanced features but has the advantage of remembering the IP addresses of the clients currently performing an API call, that may be useful or not depending on the application.</source>
          <target state="translated">Hay una forma diferente de arreglar este problema sin usar scripts,pero usando listas Redis en lugar de contadores.La implementación es más compleja y utiliza características más avanzadas,pero tiene la ventaja de recordar las direcciones IP de los clientes que actualmente realizan una llamada a la API,que puede ser útil o no dependiendo de la aplicación.</target>
        </trans-unit>
        <trans-unit id="2318fb4edc6b835e7f3009f7b1cfc0bceadc13e5" translate="yes" xml:space="preserve">
          <source>There is a stream with an associated consumer group.</source>
          <target state="translated">Hay una corriente con un grupo de consumidores asociado.</target>
        </trans-unit>
        <trans-unit id="f5813da89c7be6046d913f1f5df04a5cf2e30994" translate="yes" xml:space="preserve">
          <source>There is an additional Lua-to-Redis conversion rule that has no corresponding Redis to Lua conversion rule:</source>
          <target state="translated">Hay una regla adicional de conversión de Lua a Redis que no tiene una regla de conversión de Redis a Lua correspondiente:</target>
        </trans-unit>
        <trans-unit id="3c2e8ff8c03c52243caafd83d9c21a0190459a1a" translate="yes" xml:space="preserve">
          <source>There is another subcommand that only changes the behavior of successive &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; subcommand calls by setting the overflow behavior:</source>
          <target state="translated">Hay otro subcomando que solo cambia el comportamiento de las sucesivas &lt;a href=&quot;incrby&quot;&gt;llamadas de&lt;/a&gt; subcomando INCRBY estableciendo el comportamiento de desbordamiento:</target>
        </trans-unit>
        <trans-unit id="ad004d677ac8d1220049f68515cbe366e16611b0" translate="yes" xml:space="preserve">
          <source>There is no difference between using the helper functions or directly returning the table with the specified format, so the following two forms are equivalent:</source>
          <target state="translated">No hay diferencia entre utilizar las funciones de ayuda o devolver directamente la tabla con el formato especificado,por lo que las dos formas siguientes son equivalentes:</target>
        </trans-unit>
        <trans-unit id="688604faa0496cccdc56e5c3415b7e254e6c2086" translate="yes" xml:space="preserve">
          <source>There is no guarantee that it is actually the higher configuration epoch, since, for example, we can use the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option within a minority, nor any message exchange is performed to generate the new configuration epoch.</source>
          <target state="translated">No hay garant&amp;iacute;a de que sea realmente la &amp;eacute;poca de configuraci&amp;oacute;n superior, ya que, por ejemplo, podemos usar la opci&amp;oacute;n &lt;strong&gt;TAKEOVER&lt;/strong&gt; dentro de una minor&amp;iacute;a, ni se realiza ning&amp;uacute;n intercambio de mensajes para generar la nueva &amp;eacute;poca de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f9d2324c27d0bdf5977e444923fed05e29f7f2d5" translate="yes" xml:space="preserve">
          <source>There is no limit to the length of the name that can be assigned if not the usual limits of the Redis string type (512 MB). However it is not possible to use spaces in the connection name as this would violate the format of the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; reply.</source>
          <target state="translated">No hay l&amp;iacute;mite para la longitud del nombre que se puede asignar, salvo los l&amp;iacute;mites habituales del tipo de cadena de Redis (512 MB). Sin embargo, no es posible utilizar espacios en el nombre de la conexi&amp;oacute;n, ya que esto violar&amp;iacute;a el formato de la respuesta de la &lt;a href=&quot;client-list&quot;&gt;LISTA DE CLIENTES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="939fac74be0ef5905e18fc0965563dbdb047a83f" translate="yes" xml:space="preserve">
          <source>There is one key thing to understand: in case Lua replies with RESP3 types, but the connection calling Lua is in RESP2 mode, Redis will automatically convert the RESP3 protocol to RESP2 compatible protocol, as it happens for normal commands. For instance returning a map type to a connection in RESP2 mode will have the effect of returning a flat array of fields and values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5147f1530dd4898c039cd6ac5ba9eae79430a62" translate="yes" xml:space="preserve">
          <source>These are the counters that are reset:</source>
          <target state="translated">Estos son los contadores que se reinician:</target>
        </trans-unit>
        <trans-unit id="3f9525d03220e878ebb457481ab1b1546ad897b4" translate="yes" xml:space="preserve">
          <source>These bytes are pure overhead at the moment as no actual data is stored, and are used for maintaining the internal data structures of the server. Longer keys and values show asymptotically linear usage.</source>
          <target state="translated">Estos bytes son pura sobrecarga por el momento,ya que no se almacenan datos reales,y se utilizan para mantener las estructuras de datos internas del servidor.Las claves y valores más largos muestran un uso asintóticamente lineal.</target>
        </trans-unit>
        <trans-unit id="0c0d7819e41ea841eca9c54ef01aab00acdd805e" translate="yes" xml:space="preserve">
          <source>These offsets can also be negative numbers indicating offsets starting at the end of the list. For example, &lt;code&gt;-1&lt;/code&gt; is the last element of the list, &lt;code&gt;-2&lt;/code&gt; the penultimate, and so on.</source>
          <target state="translated">Estas compensaciones tambi&amp;eacute;n pueden ser n&amp;uacute;meros negativos que indican compensaciones que comienzan al final de la lista. Por ejemplo, &lt;code&gt;-1&lt;/code&gt; es el &amp;uacute;ltimo elemento de la lista, &lt;code&gt;-2&lt;/code&gt; el pen&amp;uacute;ltimo, y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="3327f4f330ea4245b93a5884cfe66d7c642a01a1" translate="yes" xml:space="preserve">
          <source>These prerequisites are needed since usually, manually altering the configuration epoch of a node is unsafe, we want to be sure that the node with the higher configuration epoch value (that is the last that failed over) wins over other nodes in claiming the hash slots ownership.</source>
          <target state="translated">Estos prerrequisitos son necesarios ya que normalmente,alterar manualmente la época de configuración de un nodo es inseguro,queremos estar seguros de que el nodo con el valor más alto de la época de configuración (que es el último que falló)gana sobre los otros nodos al reclamar la propiedad de los hash slots.</target>
        </trans-unit>
        <trans-unit id="74cdd9a11d855a7fe9706564ff82f50aed545b21" translate="yes" xml:space="preserve">
          <source>They can be shortened removing characters from the right. It will lose precision but will still point to the same area.</source>
          <target state="translated">Se pueden acortar eliminando los caracteres de la derecha.Perderá precisión pero seguirá apuntando a la misma zona.</target>
        </trans-unit>
        <trans-unit id="de21a5f9f7664481a629fd440bf41584926e640e" translate="yes" xml:space="preserve">
          <source>They correspond directly to the normal Redis log levels. Only logs emitted by scripting using a log level that is equal or greater than the currently configured Redis instance log level will be emitted.</source>
          <target state="translated">Se corresponden directamente con los niveles normales de registro de Redis.Sólo se emitirán los registros emitidos por la escritura utilizando un nivel de registro que sea igual o mayor que el nivel de registro de la instancia de Redis actualmente configurado.</target>
        </trans-unit>
        <trans-unit id="1163c9f8d8e2d599dd815fa54afcf7fcd4819d93" translate="yes" xml:space="preserve">
          <source>Things like using the system time, calling Redis random commands like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, or using Lua random number generator, could result into scripts that will not always evaluate in the same way.</source>
          <target state="translated">Cosas como usar la hora del sistema, llamar a comandos aleatorios de Redis como &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; , o usar el generador de n&amp;uacute;meros aleatorios Lua, podr&amp;iacute;an resultar en scripts que no siempre se evaluar&amp;aacute;n de la misma manera.</target>
        </trans-unit>
        <trans-unit id="3a6c24e6bcae98d8b374c6b8a2cb2e847242de7f" translate="yes" xml:space="preserve">
          <source>Think at a Lua script where we perform an intersection between two sets. Pick five random elements, and create a new set with this five random elements. Finally we delete the temporary key representing the intersection between the two original sets. What we want to replicate is only the creation of the new set with the five elements. It's not useful to also replicate the commands creating the temporary key.</source>
          <target state="translated">Piensa en un guión de Lua donde realizamos una intersección entre dos conjuntos.Escoge cinco elementos aleatorios,y crea un nuevo conjunto con estos cinco elementos aleatorios.Finalmente eliminamos la clave temporal que representa la intersección entre los dos conjuntos originales.Lo que queremos replicar es sólo la creación del nuevo conjunto con los cinco elementos.No es útil replicar también los comandos que crean la clave temporal.</target>
        </trans-unit>
        <trans-unit id="d05a95556307e74d8c3d500f8eaf5b432fd6a284" translate="yes" xml:space="preserve">
          <source>This avoids that a client will try to release the lock after the expire time deleting the key created by another client that acquired the lock later.</source>
          <target state="translated">Esto evita que un cliente intente liberar la cerradura después del tiempo de expiración borrando la llave creada por otro cliente que adquirió la cerradura más tarde.</target>
        </trans-unit>
        <trans-unit id="e05975c8ace39fb16ed1689fdd42d78b56751af2" translate="yes" xml:space="preserve">
          <source>This can be a problem with some application where we want a more reliable messaging system. When this is the case, please check the &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; command, that is a variant of &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; that adds the returned element to a target list before returning it to the client.</source>
          <target state="translated">Esto puede ser un problema con alguna aplicaci&amp;oacute;n donde queremos un sistema de mensajer&amp;iacute;a m&amp;aacute;s confiable. Cuando este sea el caso, verifique el comando &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; , que es una variante de &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; que agrega el elemento devuelto a una lista de destino antes de devolverlo al cliente.</target>
        </trans-unit>
        <trans-unit id="7d43703d663f6362b0a28ec9100f4db91d08a310" translate="yes" xml:space="preserve">
          <source>This can be fixed easily turning the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; with optional &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; into a Lua script that is send using the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command (only available since Redis version 2.6).</source>
          <target state="translated">Esto se puede solucionar f&amp;aacute;cilmente girando el &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; con la opci&amp;oacute;n de &lt;a href=&quot;expire&quot;&gt;EXPIRA&lt;/a&gt; en un script Lua que se env&amp;iacute;a utilizando el &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; de comandos (s&amp;oacute;lo disponible desde Redis versi&amp;oacute;n 2.6).</target>
        </trans-unit>
        <trans-unit id="72b1b07f3e247301ca1521cd5c3a4e2df6db2967" translate="yes" xml:space="preserve">
          <source>This command accepts one or more SHA1 digests and returns a list of ones or zeros to signal if the scripts are already defined or not inside the script cache. This can be useful before a pipelining operation to ensure that scripts are loaded (and if not, to load them using &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt;) so that the pipelining operation can be performed solely using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; instead of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; to save bandwidth.</source>
          <target state="translated">Este comando acepta uno o m&amp;aacute;s res&amp;uacute;menes SHA1 y devuelve una lista de unos o ceros para se&amp;ntilde;alar si los scripts ya est&amp;aacute;n definidos o no dentro de la cach&amp;eacute; de scripts. Esto puede ser &amp;uacute;til antes de una operaci&amp;oacute;n de canalizaci&amp;oacute;n para asegurar que los scripts est&amp;eacute;n cargados (y si no, para cargarlos usando &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; ) para que la operaci&amp;oacute;n de canalizaci&amp;oacute;n se pueda realizar &amp;uacute;nicamente usando &lt;a href=&quot;evalsha&quot;&gt;EVALSHA en&lt;/a&gt; lugar de &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; para ahorrar ancho de banda.</target>
        </trans-unit>
        <trans-unit id="dcfeceb3df3a9d1203f8df4602183697ddf7897a" translate="yes" xml:space="preserve">
          <source>This command accepts two non mandatory options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43467785cd12ce45437b2b4eecb4c3b0671ef615" translate="yes" xml:space="preserve">
          <source>This command blocks the current client until all the previous write commands are successfully transferred and acknowledged by at least the specified number of replicas. If the timeout, specified in milliseconds, is reached, the command returns even if the specified number of replicas were not yet reached.</source>
          <target state="translated">Este comando bloquea el cliente actual hasta que todos los comandos de escritura anteriores se transfieran con éxito y sean reconocidos por al menos el número especificado de réplicas.Si se alcanza el tiempo de espera,especificado en milisegundos,el comando regresa incluso si el número especificado de réplicas no se ha alcanzado todavía.</target>
        </trans-unit>
        <trans-unit id="7a62033f131f44c3fe86c2c4ab2196a020d7e337" translate="yes" xml:space="preserve">
          <source>This command can be called with multiple streams if we want to read at the same time from a number of keys. This is a key feature of &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; because especially when blocking with &lt;strong&gt;BLOCK&lt;/strong&gt;, to be able to listen with a single connection to multiple keys is a vital feature.</source>
          <target state="translated">Este comando se puede llamar con m&amp;uacute;ltiples flujos si queremos leer al mismo tiempo desde varias claves. Esta es una caracter&amp;iacute;stica clave de &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; porque especialmente cuando se bloquea con &lt;strong&gt;BLOCK&lt;/strong&gt; , poder escuchar con una sola conexi&amp;oacute;n a m&amp;uacute;ltiples teclas es una caracter&amp;iacute;stica vital.</target>
        </trans-unit>
        <trans-unit id="ea63b36c2daa60b6b416fb9f70368e117feeda86" translate="yes" xml:space="preserve">
          <source>This command can unblock, from a different connection, a client blocked in a blocking operation, such as for instance &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; or &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">Este comando puede desbloquear, desde una conexi&amp;oacute;n diferente, un cliente bloqueado en una operaci&amp;oacute;n de bloqueo, como por ejemplo &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; o &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; o &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d6f9176a21b0c3f64b6d59331a54d4112960a8c" translate="yes" xml:space="preserve">
          <source>This command comes in place of the now deprecated &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;. Doing &lt;code&gt;BLMOVE RIGHT LEFT&lt;/code&gt; is equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4b7969f891e0631e6b36c849a8182bdc4a8ebc" translate="yes" xml:space="preserve">
          <source>This command comes in place of the now deprecated &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. Doing &lt;code&gt;LMOVE RIGHT LEFT&lt;/code&gt; is equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f02c76dc59dbdc13fe5dd0f4a1731c43a14ddd0" translate="yes" xml:space="preserve">
          <source>This command controls the tracking of the keys in the next command executed by the connection, when tracking is enabled in &lt;code&gt;OPTIN&lt;/code&gt; or &lt;code&gt;OPTOUT&lt;/code&gt; mode. Please check the &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;client side caching documentation&lt;/a&gt; for background information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f8b881a98ea2d40bfed754bab550d934301142" translate="yes" xml:space="preserve">
          <source>This command copies the value stored at the &lt;code&gt;source&lt;/code&gt; key to the &lt;code&gt;destination&lt;/code&gt; key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff095ce217da2e3523c4effed757c97e397dac6" translate="yes" xml:space="preserve">
          <source>This command enables the tracking feature of the Redis server, that is used for &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;server assisted client side caching&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b31d1c2eb93e0473a8a5492fa02a9c8c2c2d69" translate="yes" xml:space="preserve">
          <source>This command is currently implemented only when using &lt;strong&gt;jemalloc&lt;/strong&gt; as an allocator, and evaluates to a benign NOOP for all others.</source>
          <target state="translated">Este comando se implementa actualmente solo cuando se usa &lt;strong&gt;jemalloc&lt;/strong&gt; como asignador y se eval&amp;uacute;a como un NOOP benigno para todos los dem&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="932344d8190e35db9df40d94e5197fd7c1d13364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Este comando es igual a &lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt; , pero en lugar de devolver el conjunto resultante, se almacena en el &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="507f9a2dec2a09af16c3fc0fe75de6b0370a3364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Este comando es igual a &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; , pero en lugar de devolver el conjunto resultante, se almacena en &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86af64e6b7731ea035f82e2694ba78f231528031" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Este comando es igual a &lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt; , pero en lugar de devolver el conjunto resultante, se almacena en &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e32e7ca3fa8b824bc6b60a666e52d947d9640ed" translate="yes" xml:space="preserve">
          <source>This command is especially useful together with &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; which was introduced also in Redis 5 together with &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;. Check the &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; command page for a pattern involving the two commands.</source>
          <target state="translated">Este comando es especialmente &amp;uacute;til junto con &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK,&lt;/a&gt; que tambi&amp;eacute;n se introdujo en Redis 5 junto con &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; . Consulte la p&amp;aacute;gina de comandos &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; para ver un patr&amp;oacute;n que incluya los dos comandos.</target>
        </trans-unit>
        <trans-unit id="86526f15e70874597af78fb5a748e15addec9fd4" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; with the sole difference that instead of taking, as the center of the area to query, a longitude and latitude value, it takes the name of a member already existing inside the geospatial index represented by the sorted set.</source>
          <target state="translated">Este comando es exactamente como &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; con la &amp;uacute;nica diferencia de que en lugar de tomar, como centro del &amp;aacute;rea a consultar, un valor de longitud y latitud, toma el nombre de un miembro ya existente dentro del &amp;iacute;ndice geoespacial representado por el conjunto ordenado.</target>
        </trans-unit>
        <trans-unit id="20782308b0ebe308769b63e3df355d6efd05d3a3" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, but with the notable difference of returning the entries in reverse order, and also taking the start-end range in reverse order: in &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; you need to state the &lt;em&gt;end&lt;/em&gt; ID and later the &lt;em&gt;start&lt;/em&gt; ID, and the command will produce all the element between (or exactly like) the two IDs, starting from the &lt;em&gt;end&lt;/em&gt; side.</source>
          <target state="translated">Este comando es exactamente como &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; , pero con la notable diferencia de devolver las entradas en orden inverso, y tambi&amp;eacute;n tomar el rango de inicio y fin en orden inverso: en &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; debe indicar el ID &lt;em&gt;final&lt;/em&gt; y luego el ID de &lt;em&gt;inicio&lt;/em&gt; , y el comando producir&amp;aacute; todo el elemento entre (o exactamente igual) los dos ID, comenzando desde el lado &lt;em&gt;final&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="076bd15f23123ea6b78baa94e15f792d2be93592" translate="yes" xml:space="preserve">
          <source>This command is like &lt;a href=&quot;geosearch&quot;&gt;GEOSEARCH&lt;/a&gt;, but stores the result in destination key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0909cd0cbb5b65dceb56a6821a06b32b029f0ae" translate="yes" xml:space="preserve">
          <source>This command is mainly used in the event a &lt;code&gt;nodes.conf&lt;/code&gt; node state file gets lost / deleted for some reason, and we want to generate it again from scratch. It can also be useful in case of mundane alterations of a node cluster configuration via the &lt;code&gt;CLUSTER&lt;/code&gt; command in order to ensure the new configuration is persisted on disk, however all the commands should normally be able to auto schedule to persist the configuration on disk when it is important to do so for the correctness of the system in the event of a restart.</source>
          <target state="translated">Este comando se utiliza principalmente en el caso de que un archivo de estado de nodo &lt;code&gt;nodes.conf&lt;/code&gt; se pierda / elimine por alguna raz&amp;oacute;n, y queremos generarlo nuevamente desde cero. Tambi&amp;eacute;n puede ser &amp;uacute;til en caso de alteraciones mundanas de la configuraci&amp;oacute;n de un cl&amp;uacute;ster de nodos a trav&amp;eacute;s del comando &lt;code&gt;CLUSTER&lt;/code&gt; para garantizar que la nueva configuraci&amp;oacute;n se mantenga en el disco; sin embargo, todos los comandos normalmente deber&amp;iacute;an poder programar autom&amp;aacute;ticamente para conservar la configuraci&amp;oacute;n en el disco cuando Es importante hacerlo para que el sistema sea correcto en caso de reinicio.</target>
        </trans-unit>
        <trans-unit id="b0d65e64e68abf2d5af87daf134cb637fc1df1f2" translate="yes" xml:space="preserve">
          <source>This command is mainly useful for debugging, when the failure detector of Redis Cluster is not operating as we believe it should.</source>
          <target state="translated">Este comando es principalmente útil para la depuración,cuando el detector de fallas de Redis Cluster no está operando como creemos que debería.</target>
        </trans-unit>
        <trans-unit id="30fc3be6e9d8c6b14224168e93a2ce61a33ebf6a" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to kill a script that is running for too much time(for instance because it entered an infinite loop because of a bug). The script will be killed and the client currently blocked into EVAL will see the command returning with an error.</source>
          <target state="translated">Este comando es principalmente útil para matar un script que se está ejecutando durante demasiado tiempo (por ejemplo,porque entró en un bucle infinito debido a un error).El script se matará y el cliente actualmente bloqueado en EVAL verá que el comando vuelve con un error.</target>
        </trans-unit>
        <trans-unit id="37c2b15b0fd4a88889c5862b221daca96c7ea555" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to re-provision a Redis Cluster node in order to be used in the context of a new, different cluster. The command is also extensively used by the Redis Cluster testing framework in order to reset the state of the cluster every time a new test unit is executed.</source>
          <target state="translated">Este comando es principalmente útil para reaprovisionar un nodo de Redis Cluster para ser usado en el contexto de un nuevo y diferente cluster.El comando también es ampliamente utilizado por el marco de pruebas del Redis Cluster para restablecer el estado del cluster cada vez que se ejecuta una nueva unidad de prueba.</target>
        </trans-unit>
        <trans-unit id="fed8489efd023df6aa3b9c8828a92cf9cbe79777" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zdiffstore&quot;&gt;ZDIFFSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b570683c8482e1a6ba032781b807f8695533eb" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d880d1fb82050509f79c50bd6fb5ec73f51cf212" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de9c0357b2f6bf5f5b30bfd602eff2f9c1cbcf1" translate="yes" xml:space="preserve">
          <source>This command is the most powerful analysis tool in the latency monitoring framework, and is able to provide additional statistical data like the average period between latency spikes, the median deviation, and a human-readable analysis of the event. For certain events, like &lt;code&gt;fork&lt;/code&gt;, additional information is provided, like the rate at which the system forks processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9cd1ceade82d616f55d37288e27be4ecc550c1" translate="yes" xml:space="preserve">
          <source>This command is the only way to force Redis to flush the scripts cache. It is most useful in a cloud environment where the same instance can be reassigned to a different user. It is also useful for testing client libraries' implementations of the scripting feature.</source>
          <target state="translated">Este comando es la única manera de obligar a Redis a vaciar el caché de scripts.Es más útil en un entorno de nubes donde la misma instancia puede ser reasignada a un usuario diferente.También es útil para probar las implementaciones de las bibliotecas de clientes de la función de scripts.</target>
        </trans-unit>
        <trans-unit id="8562c28aa29c0aee65ed6fb4a3d690ee24e35388" translate="yes" xml:space="preserve">
          <source>This command is the only way to interrupt a long-running script that reaches the configured maximum execution time for scripts. The SCRIPT KILL command can only be used with scripts that did not modify the dataset during their execution (since stopping a read-only script does not violate the scripting engine's guaranteed atomicity). See the next sections for more information about long running scripts.</source>
          <target state="translated">Este comando es la única manera de interrumpir un guión de larga duración que alcanza el tiempo máximo de ejecución configurado para los guiones.El comando SCRIPT KILL sólo puede utilizarse con scripts que no modificaron el conjunto de datos durante su ejecución (ya que detener un script de sólo lectura no viola la atomicidad garantizada del motor de scripts).Consulte las siguientes secciones para obtener más información sobre los scripts de larga duración.</target>
        </trans-unit>
        <trans-unit id="74540a3a51962d64e542e90991498fda99b11c4b" translate="yes" xml:space="preserve">
          <source>This command is used in order to manage the consumer groups associated with a stream data structure. Using &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; you can:</source>
          <target state="translated">Este comando se utiliza para administrar los grupos de consumidores asociados con una estructura de datos de flujo. Usando &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; puede:</target>
        </trans-unit>
        <trans-unit id="0f3f38de2ae9dc1853425848b341ace4420d82e4" translate="yes" xml:space="preserve">
          <source>This command is used in order to read and reset the Redis slow queries log.</source>
          <target state="translated">Este comando se utiliza para leer y reiniciar el registro de consultas lentas de Redis.</target>
        </trans-unit>
        <trans-unit id="4469a3906600e48388ff32654f41a170c058ed11" translate="yes" xml:space="preserve">
          <source>This command is useful as it makes able to switch clients from a Redis instance to another one in a controlled way. For example during an instance upgrade the system administrator could do the following:</source>
          <target state="translated">Este comando es útil ya que permite cambiar los clientes de una instancia de Redis a otra de forma controlada.Por ejemplo,durante la actualización de una instancia el administrador del sistema podría hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="7716c05ccc0dd7cac30547152d82c808312925c0" translate="yes" xml:space="preserve">
          <source>This command is useful especially when we are monitoring many keys with a limited number of connections. For instance we may want to monitor multiple streams with &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; without using more than N connections. However at some point the consumer process is informed that there is one more stream key to monitor. In order to avoid using more connections, the best behavior would be to stop the blocking command from one of the connections in the pool, add the new key, and issue the blocking command again.</source>
          <target state="translated">Este comando es &amp;uacute;til especialmente cuando estamos monitoreando muchas claves con un n&amp;uacute;mero limitado de conexiones. Por ejemplo, es posible que deseemos monitorear m&amp;uacute;ltiples transmisiones con &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; sin usar m&amp;aacute;s de N conexiones. Sin embargo, en alg&amp;uacute;n momento se informa al proceso del consumidor que hay una clave de flujo m&amp;aacute;s para monitorear. Para evitar el uso de m&amp;aacute;s conexiones, el mejor comportamiento ser&amp;iacute;a detener el comando de bloqueo de una de las conexiones en el grupo, agregar la nueva clave y emitir el comando de bloqueo nuevamente.</target>
        </trans-unit>
        <trans-unit id="59ff8c186eb229a2dac30dbd70e43e24baabed7c" translate="yes" xml:space="preserve">
          <source>This command is useful in order to modify a node's view of the cluster configuration. Specifically it assigns a set of hash slots to the node receiving the command. If the command is successful, the node will map the specified hash slots to itself, and will start broadcasting the new configuration.</source>
          <target state="translated">Este comando es útil para modificar la vista de un nodo de la configuración del clúster.Específicamente asigna un conjunto de ranuras de hash al nodo que recibe el comando.Si el comando tiene éxito,el nodo se asignará a sí mismo las ranuras de hash especificadas y comenzará a emitir la nueva configuración.</target>
        </trans-unit>
        <trans-unit id="afcb99c36c15189824ecdc3091bf486391211187" translate="yes" xml:space="preserve">
          <source>This command is very similar to &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;: it removes the specified keys. Just like &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; is. This is where the command name comes from: the command just &lt;strong&gt;unlinks&lt;/strong&gt; the keys from the keyspace. The actual removal will happen later asynchronously.</source>
          <target state="translated">Este comando es muy similar a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; : elimina las claves especificadas. Al igual que &lt;a href=&quot;del&quot;&gt;DEL,&lt;/a&gt; una clave se ignora si no existe. Sin embargo, el comando realiza la recuperaci&amp;oacute;n de memoria real en un subproceso diferente, por lo que no est&amp;aacute; bloqueando, mientras que &lt;a href=&quot;del&quot;&gt;DEL lo&lt;/a&gt; est&amp;aacute;. Aqu&amp;iacute; es de donde proviene el nombre del comando: el comando simplemente &lt;strong&gt;desvincula&lt;/strong&gt; las claves del espacio de claves. La eliminaci&amp;oacute;n real ocurrir&amp;aacute; m&amp;aacute;s tarde de forma asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="8d70f66fb80485b6d531d7d9ab8ad149118bee56" translate="yes" xml:space="preserve">
          <source>This command loads and initializes the Redis module from the dynamic library specified by the &lt;code&gt;path&lt;/code&gt; argument. The &lt;code&gt;path&lt;/code&gt; should be the absolute path of the library, including the full filename. Any additional arguments are passed unmodified to the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7d9161cbb27663ecc1a90a3f6bb05f23dbad84" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and is useful in the following Redis Cluster operations:</source>
          <target state="translated">Este comando sólo funciona en modo clúster y es útil en las siguientes operaciones de Redis Cluster:</target>
        </trans-unit>
        <trans-unit id="ae45a8ae2f8e5aecd7b6912a681c88c74a505274" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and may be useful for debugging and in order to manually orchestrate a cluster configuration when a new cluster is created. It is currently not used by &lt;code&gt;redis-trib&lt;/code&gt;, and mainly exists for API completeness.</source>
          <target state="translated">Este comando solo funciona en modo de cl&amp;uacute;ster y puede ser &amp;uacute;til para depurar y para orquestar manualmente una configuraci&amp;oacute;n de cl&amp;uacute;ster cuando se crea un nuevo cl&amp;uacute;ster. Actualmente no es utilizado por &lt;code&gt;redis-trib&lt;/code&gt; , y existe principalmente para completar API.</target>
        </trans-unit>
        <trans-unit id="b0562f793b35f58a57b7250775581e06cabbe124" translate="yes" xml:space="preserve">
          <source>This command performs a full reset of the connection's server-side context, mimicking the effect of disconnecting and reconnecting again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5304131d86dfa25555f9abe5b57dd4ad31bed60" translate="yes" xml:space="preserve">
          <source>This command registers the specified script in the Redis script cache. The command is useful in all the contexts where we want to make sure that &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will not fail (for instance during a pipeline or MULTI/EXEC operation), without the need to actually execute the script.</source>
          <target state="translated">Este comando registra la secuencia de comandos especificada en la cach&amp;eacute; de secuencias de comandos de Redis. El comando es &amp;uacute;til en todos los contextos en los que queremos asegurarnos de que &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; no fallar&amp;aacute; (por ejemplo, durante una canalizaci&amp;oacute;n o una operaci&amp;oacute;n MULTI / EXEC), sin la necesidad de ejecutar realmente el script.</target>
        </trans-unit>
        <trans-unit id="09806309aef17ea4d51d659e1cc3d714503d0680" translate="yes" xml:space="preserve">
          <source>This command returns the client ID we are redirecting our &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;tracking&lt;/a&gt; notifications to. We set a client to redirect to when using &lt;a href=&quot;client-tracking&quot;&gt;CLIENT TRACKING&lt;/a&gt; to enable tracking. However in order to avoid forcing client libraries implementations to remember the ID notifications are redirected to, this command exists in order to improve introspection and allow clients to check later if redirection is active and towards which client ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7e7424bc09f286d32a4b812efe8253277e59f5" translate="yes" xml:space="preserve">
          <source>This command returns the number of failure reports for the current node which are currently not expired (so received within two times the &lt;em&gt;node timeout&lt;/em&gt; time). The count does not include what the node we are asking this count believes about the node ID we pass as argument, the count &lt;em&gt;only&lt;/em&gt; includes the failure reports the node received from other nodes.</source>
          <target state="translated">Este comando devuelve el n&amp;uacute;mero de informes de fallas para el nodo actual que actualmente no est&amp;aacute;n vencidos (por lo que se reciben dentro de dos veces el &lt;em&gt;tiempo de espera&lt;/em&gt; del &lt;em&gt;nodo&lt;/em&gt; ). El recuento no incluye lo que cree el nodo al que le preguntamos este recuento sobre el ID de nodo que pasamos como argumento, el recuento &lt;em&gt;solo&lt;/em&gt; incluye los informes de falla que el nodo recibi&amp;oacute; de otros nodos.</target>
        </trans-unit>
        <trans-unit id="541223fddf4b501cc96317842ccc50859641cd10" translate="yes" xml:space="preserve">
          <source>This command sets a specific &lt;em&gt;config epoch&lt;/em&gt; in a fresh node. It only works when:</source>
          <target state="translated">Este comando establece una &lt;em&gt;&amp;eacute;poca de configuraci&amp;oacute;n&lt;/em&gt; espec&amp;iacute;fica en un nodo nuevo. Solo funciona cuando:</target>
        </trans-unit>
        <trans-unit id="18e23f892090be38939eafd00c77e503dab8c192" translate="yes" xml:space="preserve">
          <source>This command swaps two Redis databases, so that immediately all the clients connected to a given database will see the data of the other database, and the other way around. Example:</source>
          <target state="translated">Este comando intercambia dos bases de datos Redis,de modo que inmediatamente todos los clientes conectados a una base de datos determinada verán los datos de la otra base,y al revés.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="75c1ca96e42909a085011b83f917c82db8bdd8f7" translate="yes" xml:space="preserve">
          <source>This command unloads the module specified by &lt;code&gt;name&lt;/code&gt;. Note that the module's name is reported by the &lt;a href=&quot;module-list&quot;&gt;MODULE LIST&lt;/a&gt; command, and may differ from the dynamic library's filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adc7a43ee507fff544bbc6adc515bc47ac97ad4" translate="yes" xml:space="preserve">
          <source>This command was introduced in the middle of a Redis stable release, specifically with Redis 2.8.12.</source>
          <target state="translated">Este comando se introdujo en medio de una liberación estable de Redis,específicamente con Redis 2.8.12.</target>
        </trans-unit>
        <trans-unit id="838bb242e39a256bd97fcf68121a5b0ba9ba6cad" translate="yes" xml:space="preserve">
          <source>This command works exactly like &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; but the time to live of the key is specified in milliseconds instead of seconds.</source>
          <target state="translated">Este comando funciona exactamente como &lt;a href=&quot;expire&quot;&gt;EXPIRE,&lt;/a&gt; pero el tiempo de vida de la clave se especifica en milisegundos en lugar de segundos.</target>
        </trans-unit>
        <trans-unit id="7341623725ef962c36ad811614642ab5632c4c2c" translate="yes" xml:space="preserve">
          <source>This command, that can only be sent to a Redis Cluster replica node, forces the replica to start a manual failover of its master instance.</source>
          <target state="translated">Este comando,que sólo puede ser enviado a un nodo de réplica de Redis Cluster,obliga a la réplica a iniciar un failover manual de su instancia maestra.</target>
        </trans-unit>
        <trans-unit id="4da304a4683087def0d8d26eb2c481c6af27db0a" translate="yes" xml:space="preserve">
          <source>This conversion between data types is designed in a way that if a Redis type is converted into a Lua type, and then the result is converted back into a Redis type, the result is the same as the initial value.</source>
          <target state="translated">Esta conversión entre los tipos de datos está diseñada de tal manera que si un tipo Redis se convierte en un tipo Lua,y luego el resultado se convierte de nuevo en un tipo Redis,el resultado es el mismo que el valor inicial.</target>
        </trans-unit>
        <trans-unit id="e18d68145955b4559f3ba803d90954ff94c0dac8" translate="yes" xml:space="preserve">
          <source>This dynamic is clearly explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Stream intro documentation&lt;/a&gt;.</source>
          <target state="translated">Esta din&amp;aacute;mica se explica claramente en la &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;documentaci&amp;oacute;n de introducci&amp;oacute;n de Stream&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19d5d3191e2445ef69de01881bb5939b9f401be6" translate="yes" xml:space="preserve">
          <source>This example shows the application in the context of Redis streams, however the pattern is a general one and can be applied to other cases.</source>
          <target state="translated">Este ejemplo muestra la aplicación en el contexto de las corrientes de Redis,aunque la pauta es general y puede aplicarse a otros casos.</target>
        </trans-unit>
        <trans-unit id="7b81b5550c835cb846e3da1e36e1dc058efa8bc9" translate="yes" xml:space="preserve">
          <source>This form just authenticates against the password set with &lt;code&gt;requirepass&lt;/code&gt;. In this configuration Redis will deny any command executed by the just connected clients, unless the connection gets authenticated via &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30a4ad86f29101d3c1fcdfab12485ff0ca6c027" translate="yes" xml:space="preserve">
          <source>This format allows for radius querying by checking the 1+8 areas needed to cover the whole radius, and discarding elements outside the radius. The areas are checked by calculating the range of the box covered removing enough bits from the less significant part of the sorted set score, and computing the score range to query in the sorted set for each area.</source>
          <target state="translated">Este formato permite la consulta del radio comprobando las áreas 1+8 necesarias para cubrir todo el radio,y desechando los elementos fuera del radio.Las áreas se comprueban calculando el rango de la caja cubierta eliminando suficientes bits de la parte menos significativa de la puntuación del conjunto ordenado,y calculando el rango de la puntuación a consultar en el conjunto ordenado para cada área.</target>
        </trans-unit>
        <trans-unit id="5f7d96d3049d4f76efb356668757ef71fbc55342" translate="yes" xml:space="preserve">
          <source>This has the same effect as running &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; with one argument &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Esto tiene el mismo efecto que ejecutar &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; con una &lt;code&gt;key&lt;/code&gt; argumento .</target>
        </trans-unit>
        <trans-unit id="5d0bfed0b5c7c513675b9c26b7ab5ed0c6f3d603" translate="yes" xml:space="preserve">
          <source>This is a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="translated">Esta es una buena descripci&amp;oacute;n general, pero a veces nos interesan los detalles. Para poder ver todos los mensajes pendientes con m&amp;aacute;s informaci&amp;oacute;n asociada necesitamos pasar tambi&amp;eacute;n un rango de IDs, de manera similar lo hacemos con &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; , y un argumento de &lt;em&gt;conteo&lt;/em&gt; no opcional , para limitar la cantidad de mensajes devueltos por llamada:</target>
        </trans-unit>
        <trans-unit id="90aa8094613e02ff36a67a68b984d933a74e701a" translate="yes" xml:space="preserve">
          <source>This is a list of all the supported Redis ACL rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b4d531c8516c33061d94d3a8959add03c42f29" translate="yes" xml:space="preserve">
          <source>This is a trivial probabilistic algorithm, basically the assumption is that our sample is representative of the whole key space, and we continue to expire until the percentage of keys that are likely to be expired is under 25%</source>
          <target state="translated">Este es un algoritmo probabilístico trivial,básicamente la suposición es que nuestra muestra es representativa de todo el espacio de claves,y seguimos expirando hasta que el porcentaje de claves que es probable que expiren está por debajo del 25%</target>
        </trans-unit>
        <trans-unit id="c48adb8e8d877ae182110cc1e68d2e6bc1d83311" translate="yes" xml:space="preserve">
          <source>This is an example of blocking invocation, where the command later returns a null reply because the timeout has elapsed without new data arriving:</source>
          <target state="translated">Este es un ejemplo de bloqueo de la invocación,en el que el comando devuelve más tarde una respuesta nula porque el tiempo de espera ha transcurrido sin que lleguen nuevos datos:</target>
        </trans-unit>
        <trans-unit id="622bd341d8dc701d53c24284f457bffb1eb9df29" translate="yes" xml:space="preserve">
          <source>This is an example of iteration using &lt;strong&gt;MATCH&lt;/strong&gt;:</source>
          <target state="translated">Este es un ejemplo de iteraci&amp;oacute;n usando &lt;strong&gt;MATCH&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4d789554ece00f72c77acd57e4f313f31c717e24" translate="yes" xml:space="preserve">
          <source>This is an introspection command used in order to retrieve different information about the streams and associated consumer groups. Three forms are possible:</source>
          <target state="translated">Se trata de un comando de introspección que se utiliza para recuperar diferentes informaciones sobre las corrientes y los grupos de consumidores asociados.Tres formas son posibles:</target>
        </trans-unit>
        <trans-unit id="fa13476351797926204e99a9b54034d28b5780cc" translate="yes" xml:space="preserve">
          <source>This is easy to see intuitively: if the collection grows there is more and more work to do in order to visit all the possible elements, and the ability to terminate the iteration depends on the number of calls to &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; and its COUNT option value compared with the rate at which the collection grows.</source>
          <target state="translated">Esto es f&amp;aacute;cil de ver intuitivamente: si la colecci&amp;oacute;n crece, hay m&amp;aacute;s y m&amp;aacute;s trabajo por hacer para visitar todos los elementos posibles, y la capacidad de terminar la iteraci&amp;oacute;n depende del n&amp;uacute;mero de llamadas a &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; y su valor de opci&amp;oacute;n COUNT en comparaci&amp;oacute;n con la velocidad a la que crece la colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5ecf6a9694906630d3be8ffa19f791d25178c710" translate="yes" xml:space="preserve">
          <source>This is how a typical &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; call looks like in the first iteration of a consumer willing to consume only new entries:</source>
          <target state="translated">As&amp;iacute; es como se ve una llamada &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; t&amp;iacute;pica en la primera iteraci&amp;oacute;n de un consumidor dispuesto a consumir solo nuevas entradas:</target>
        </trans-unit>
        <trans-unit id="720fb76cbe63b3ee37bb596512afa1691c9ba3f2" translate="yes" xml:space="preserve">
          <source>This is how to understand if you want to use a consumer group or not:</source>
          <target state="translated">Así es como se entiende si se quiere usar un grupo de consumidores o no:</target>
        </trans-unit>
        <trans-unit id="2d94df873adfd43289accd82b71abdee4a8063f4" translate="yes" xml:space="preserve">
          <source>This is how we use this command in order to mount such an algorithm:</source>
          <target state="translated">Así es como usamos este comando para montar tal algoritmo:</target>
        </trans-unit>
        <trans-unit id="c0d3b602529b7dea150254bfa283c67fb2eed932" translate="yes" xml:space="preserve">
          <source>This is the output you should post in the Redis mailing list if you are looking for help about Latency related issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9658590fc318422333085d731b93a7035c7459f" translate="yes" xml:space="preserve">
          <source>This is useful in several ways depending on the use case:</source>
          <target state="translated">Esto es útil de varias maneras dependiendo del caso de uso:</target>
        </trans-unit>
        <trans-unit id="bcf3a4afdd1a41afed7a49db731a6c6ebfa0cc2a" translate="yes" xml:space="preserve">
          <source>This is useful to an application that wants to fetch raw data in order to perform monitoring, display graphs, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a58d44535039d5a20b0fa97b3b1ee43b1b6dd46" translate="yes" xml:space="preserve">
          <source>This is usually needed only when the instance is going to be instantiated for another customer or application in a cloud environment.</source>
          <target state="translated">Por lo general,esto sólo es necesario cuando la instancia va a ser instanciada para otro cliente o aplicación en un entorno de nube.</target>
        </trans-unit>
        <trans-unit id="bbfa8fbc11f623748d63d11e9bf5ee03c12ff234" translate="yes" xml:space="preserve">
          <source>This manual page also covers the &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; variants (see the section below for more information).</source>
          <target state="translated">Esta p&amp;aacute;gina de manual tambi&amp;eacute;n cubre las variantes &lt;code&gt;GEORADIUS_RO&lt;/code&gt; y &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; (consulte la secci&amp;oacute;n siguiente para obtener m&amp;aacute;s informaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="d223d35db64e1d19fc9f2926f21b42e4ab2344a9" translate="yes" xml:space="preserve">
          <source>This means that at any given moment the maximum amount of keys already expired that are using memory is at max equal to max amount of write operations per second divided by 4.</source>
          <target state="translated">Esto significa que en un momento dado la cantidad máxima de teclas ya caducadas que están utilizando la memoria es como máximo igual a la cantidad máxima de operaciones de escritura por segundo dividida por 4.</target>
        </trans-unit>
        <trans-unit id="aabcd9a95a39d430c629afa9fad1b539c022ac85" translate="yes" xml:space="preserve">
          <source>This means that if you have two non-empty buckets in the entire hash table, and one has three elements while one has just one, the element that is alone in its bucket will be returned with much higher probability.</source>
          <target state="translated">Esto significa que si se tienen dos cubos no vacíos en toda la mesa de hachís,y uno tiene tres elementos mientras que el otro sólo tiene uno,el elemento que está solo en su cubo será devuelto con una probabilidad mucho mayor.</target>
        </trans-unit>
        <trans-unit id="249f94aa848de22f03290fa35dfb93a51fdb5d7d" translate="yes" xml:space="preserve">
          <source>This means that this command should be used with care only by applications orchestrating Redis Cluster, like &lt;code&gt;redis-trib&lt;/code&gt;, and the command if used out of the right context can leave the cluster in a wrong state or cause data loss.</source>
          <target state="translated">Esto significa que este comando debe usarse con cuidado solo por las aplicaciones que organizan Redis Cluster, como &lt;code&gt;redis-trib&lt;/code&gt; , y el comando, si se usa fuera del contexto correcto, puede dejar el cl&amp;uacute;ster en un estado incorrecto o provocar la p&amp;eacute;rdida de datos.</target>
        </trans-unit>
        <trans-unit id="b4b18f04b9acb83f71f24c60b244188e2d234cce" translate="yes" xml:space="preserve">
          <source>This means that you set:</source>
          <target state="translated">Esto significa que te pones en marcha:</target>
        </trans-unit>
        <trans-unit id="8a0b4cfa314b524daabda36aba34d428f894ef1e" translate="yes" xml:space="preserve">
          <source>This operation is similar to &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, that returns one or more random elements from a set but does not remove it.</source>
          <target state="translated">Esta operaci&amp;oacute;n es similar a &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; , que devuelve uno o m&amp;aacute;s elementos aleatorios de un conjunto pero no los elimina.</target>
        </trans-unit>
        <trans-unit id="b82ae6d609ba5f4bff538ca99ae907087f8e8c97" translate="yes" xml:space="preserve">
          <source>This pair of commands will push a new element on the list, while making sure that the list will not grow larger than 100 elements. This is very useful when using Redis to store logs for example. It is important to note that when used in this way &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; is an O(1) operation because in the average case just one element is removed from the tail of the list.</source>
          <target state="translated">Este par de comandos empujar&amp;aacute; un nuevo elemento en la lista, mientras se asegura de que la lista no supere los 100 elementos. Esto es muy &amp;uacute;til cuando se usa Redis para almacenar registros, por ejemplo. Es importante notar que cuando se usa de esta manera, &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; es una operaci&amp;oacute;n O (1) porque en el caso promedio solo se elimina un elemento de la cola de la lista.</target>
        </trans-unit>
        <trans-unit id="80b9715de053267e5fffa59b0b1112d991e9ba3f" translate="yes" xml:space="preserve">
          <source>This pattern is easily modified to use counters using &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; instead of lists using &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;.</source>
          <target state="translated">Este patr&amp;oacute;n se modifica f&amp;aacute;cilmente para usar contadores usando &lt;a href=&quot;incr&quot;&gt;INCR en&lt;/a&gt; lugar de listas usando &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d386987d572848d3712f1ff810e5567134c02087" translate="yes" xml:space="preserve">
          <source>This simple pattern can be extended in many ways:</source>
          <target state="translated">Este simple patrón puede extenderse de muchas maneras:</target>
        </trans-unit>
        <trans-unit id="92785c4b9f557c4d2558a4fa95a80f3ac27c63a5" translate="yes" xml:space="preserve">
          <source>This subcommand is the reverse of &lt;code&gt;MIGRATING&lt;/code&gt;, and prepares the destination node to import keys from the specified source node. The command only works if the node is not already owner of the specified hash slot.</source>
          <target state="translated">Este subcomando es el reverso de &lt;code&gt;MIGRATING&lt;/code&gt; y prepara el nodo de destino para importar claves desde el nodo de origen especificado. El comando solo funciona si el nodo a&amp;uacute;n no es propietario de la ranura de hash especificada.</target>
        </trans-unit>
        <trans-unit id="3af1b4ceac0630f2f07d73ce38551a82afebcee6" translate="yes" xml:space="preserve">
          <source>This subcommand just clears migrating / importing state from the slot. It is mainly used to fix a cluster stuck in a wrong state by &lt;code&gt;redis-trib fix&lt;/code&gt;. Normally the two states are cleared automatically at the end of the migration using the &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; subcommand as explained in the next section.</source>
          <target state="translated">Este subcomando simplemente borra el estado de migraci&amp;oacute;n / importaci&amp;oacute;n de la ranura. Se utiliza principalmente para reparar un cl&amp;uacute;ster atascado en un estado incorrecto mediante la &lt;code&gt;redis-trib fix&lt;/code&gt; de redistribuci&amp;oacute;n . Normalmente, los dos estados se borran autom&amp;aacute;ticamente al final de la migraci&amp;oacute;n mediante el &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; como se explica en la siguiente secci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9fe3e638e8830d97f18b8e18e7bb1f71a19b5a85" translate="yes" xml:space="preserve">
          <source>This subcommand sets a slot to &lt;em&gt;migrating&lt;/em&gt; state. In order to set a slot in this state, the node receiving the command must be the hash slot owner, otherwise an error is returned.</source>
          <target state="translated">Este subcomando establece una ranura para el estado de &lt;em&gt;migraci&amp;oacute;n&lt;/em&gt; . Para establecer una ranura en este estado, el nodo que recibe el comando debe ser el propietario de la ranura hash; de lo contrario, se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="edb8d5f6aeacab24056a48e5cdeee519f5cf870a" translate="yes" xml:space="preserve">
          <source>This way clients are moved away from the old master to the new master atomically and only when the replica that is turning into the new master has processed all of the replication stream from the old master.</source>
          <target state="translated">De esta manera los clientes son trasladados del antiguo maestro al nuevo maestro atómicamente y sólo cuando la réplica que se está convirtiendo en el nuevo maestro ha procesado todo el flujo de la réplica del antiguo maestro.</target>
        </trans-unit>
        <trans-unit id="eabc7eeeb462a96b3b77723425f464bf9ccbef27" translate="yes" xml:space="preserve">
          <source>This way we have a 60 second window to inform all the nodes in the cluster that we want to remove a node.</source>
          <target state="translated">De esta manera tenemos una ventana de 60 segundos para informar a todos los nodos del cúmulo que queremos eliminar un nodo.</target>
        </trans-unit>
        <trans-unit id="e40460902c1181221678071c434b045c404620fa" translate="yes" xml:space="preserve">
          <source>This will swap database 0 with database 1. All the clients connected with database 0 will immediately see the new data, exactly like all the clients connected with database 1 will see the data that was formerly of database 0.</source>
          <target state="translated">Esto intercambiará la base de datos 0 con la base de datos 1.Todos los clientes conectados con la base de datos 0 verán inmediatamente los nuevos datos,exactamente como todos los clientes conectados con la base de datos 1 verán los datos que antes eran de la base de datos 0.</target>
        </trans-unit>
        <trans-unit id="d5bfb565b7330daf67d56a70b8a026b02f7b8efa" translate="yes" xml:space="preserve">
          <source>Tip: setting names to connections is a good way to debug connection leaks due to bugs in the application using Redis.</source>
          <target state="translated">Consejo:establecer nombres para las conexiones es una buena manera de depurar las fugas de conexión debidas a errores en la aplicación usando Redis.</target>
        </trans-unit>
        <trans-unit id="ff53653923ebddab009510a619b44980ec4c2bad" translate="yes" xml:space="preserve">
          <source>To call the command without elements but just the variable name is valid, this will result into no operation performed if the variable already exists, or just the creation of the data structure if the key does not exist (in the latter case 1 is returned).</source>
          <target state="translated">Llamar el comando sin elementos pero sólo el nombre de la variable es válido,esto resultará en que no se realice ninguna operación si la variable ya existe,o sólo la creación de la estructura de datos si la clave no existe (en este último caso se devuelve 1).</target>
        </trans-unit>
        <trans-unit id="480b89cfe665e37f5248f03df59af64d3763158a" translate="yes" xml:space="preserve">
          <source>To continue iterating the two streams I'll call:</source>
          <target state="translated">Para continuar iterando las dos corrientes llamaré:</target>
        </trans-unit>
        <trans-unit id="0314c05fdc90b76eea71abe37038408de3a97e39" translate="yes" xml:space="preserve">
          <source>To create a new cluster ADDSLOTS is used in order to initially setup master nodes splitting the available hash slots among them.</source>
          <target state="translated">Para crear un nuevo grupo se utiliza ADDSLOTS para configurar inicialmente nodos maestros que dividen las ranuras hash disponibles entre ellos.</target>
        </trans-unit>
        <trans-unit id="44bff97be54184d5c7829a3927adcbbc623cd71d" translate="yes" xml:space="preserve">
          <source>To create a new consumer group, use the following form:</source>
          <target state="translated">Para crear un nuevo grupo de consumidores,utilice el siguiente formulario:</target>
        </trans-unit>
        <trans-unit id="89c4cf93004db2e7ed530c2bd4661a6d909ed66e" translate="yes" xml:space="preserve">
          <source>To do so the web application may simply increment a key every time the user performs a page view, creating the key name concatenating the User ID and a string representing the current date.</source>
          <target state="translated">Para ello,la aplicación web puede simplemente incrementar una tecla cada vez que el usuario realiza una vista de página,creando el nombre de la tecla concatenando el ID de usuario y una cadena que representa la fecha actual.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
