<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="ff16e624359e33f1f97dfa1a1d20188c59460b7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATS&lt;/a&gt; command provides an internal statistics report from the memory allocator.</source>
          <target state="translated">El comando &lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATS&lt;/a&gt; proporciona un informe de estad&amp;iacute;sticas internas del asignador de memoria.</target>
        </trans-unit>
        <trans-unit id="abed28f03c444a07fa9a013ee06dd6217f071068" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-purge&quot;&gt;MEMORY PURGE&lt;/a&gt; command attempts to purge dirty pages so these can be reclaimed by the allocator.</source>
          <target state="translated">El comando &lt;a href=&quot;memory-purge&quot;&gt;MEMORY PURGE&lt;/a&gt; intenta purgar las p&amp;aacute;ginas sucias para que el asignador pueda reclamarlas.</target>
        </trans-unit>
        <trans-unit id="6661981989e0edd2ff7e2bf5fdb3e79066d8b8f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; command returns an &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; about the memory usage of the server.</source>
          <target state="translated">El comando &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; devuelve una &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;respuesta de matriz&lt;/a&gt; sobre el uso de memoria del servidor.</target>
        </trans-unit>
        <trans-unit id="753fff2843cf4f675766fb16f94fa6b171989202" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-usage&quot;&gt;MEMORY USAGE&lt;/a&gt; command reports the number of bytes that a key and its value require to be stored in RAM.</source>
          <target state="translated">El comando &lt;a href=&quot;memory-usage&quot;&gt;MEMORY USAGE&lt;/a&gt; informa el n&amp;uacute;mero de bytes que una clave y su valor requieren para ser almacenados en RAM.</target>
        </trans-unit>
        <trans-unit id="2af70a6f2971f44c0c1aa28591f8b6524acbcca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command allows to inspect the internals of Redis Objects associated with keys. It is useful for debugging or to understand if your keys are using the specially encoded data types to save space. Your application may also use the information reported by the &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command to implement application level key eviction policies when using Redis as a Cache.</source>
          <target state="translated">El comando &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; permite inspeccionar el interior de los Objetos de Redis asociados con las claves. Es &amp;uacute;til para depurar o para comprender si sus claves est&amp;aacute;n utilizando tipos de datos especialmente codificados para ahorrar espacio. Su aplicaci&amp;oacute;n tambi&amp;eacute;n puede usar la informaci&amp;oacute;n proporcionada por el comando &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; para implementar pol&amp;iacute;ticas de desalojo de claves a nivel de aplicaci&amp;oacute;n cuando usa Redis como cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="eea48beebb7220fe5ecc2f8e71ddc8ce2e90d62c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command supports multiple sub commands:</source>
          <target state="translated">El comando &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; admite varios subcomandos:</target>
        </trans-unit>
        <trans-unit id="6bc73cb913e243c94705a7071cd05dd7f69ae35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; command can change the replication settings of a replica on the fly.</source>
          <target state="translated">El comando &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; puede cambiar la configuraci&amp;oacute;n de replicaci&amp;oacute;n de una r&amp;eacute;plica sobre la marcha.</target>
        </trans-unit>
        <trans-unit id="4ce9249bde2a45fd1e0f497151a2d69b16bbda13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rpushx&quot;&gt;RPUSHX&lt;/a&gt; command only pushes the element if the key already exists.</source>
          <target state="translated">El comando &lt;a href=&quot;rpushx&quot;&gt;RPUSHX&lt;/a&gt; solo empuja el elemento si la clave ya existe.</target>
        </trans-unit>
        <trans-unit id="614a32f854070cdcbbba350287fb7c58ac067da4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; commands performs a &lt;strong&gt;synchronous&lt;/strong&gt; save of the dataset producing a &lt;em&gt;point in time&lt;/em&gt; snapshot of all the data inside the Redis instance, in the form of an RDB file.</source>
          <target state="translated">Los comandos &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; realizan un guardado &lt;strong&gt;sincr&amp;oacute;nico&lt;/strong&gt; del conjunto de datos que produce una instant&amp;aacute;nea de un &lt;em&gt;punto en el tiempo&lt;/em&gt; de todos los datos dentro de la instancia de Redis, en forma de un archivo RDB.</target>
        </trans-unit>
        <trans-unit id="67466c1875af0bcc544ed2934fa216ebaf0fb8ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; algorithm is guaranteed to terminate only if the size of the iterated collection remains bounded to a given maximum size, otherwise iterating a collection that always grows may result into &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to never terminate a full iteration.</source>
          <target state="translated">Se garantiza que el algoritmo &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; terminar&amp;aacute; solo si el tama&amp;ntilde;o de la colecci&amp;oacute;n iterada permanece limitado a un tama&amp;ntilde;o m&amp;aacute;ximo dado; de lo contrario, la iteraci&amp;oacute;n de una colecci&amp;oacute;n que siempre crece puede dar como resultado que &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; nunca termine una iteraci&amp;oacute;n completa.</target>
        </trans-unit>
        <trans-unit id="9b83fdceccccced73f803ea3fe0587ccedbc5d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command and the closely related commands &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; are used in order to incrementally iterate over a collection of elements.</source>
          <target state="translated">El comando &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; y los comandos &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; y &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; estrechamente relacionados se utilizan para iterar de forma incremental sobre una colecci&amp;oacute;n de elementos.</target>
        </trans-unit>
        <trans-unit id="debbeaf11369c9e161ae3c316731408d752cc02f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command, and the other commands in the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family, are able to provide to the user a set of guarantees associated to full iterations.</source>
          <target state="translated">El comando &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; y los dem&amp;aacute;s comandos de la familia &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; pueden proporcionar al usuario un conjunto de garant&amp;iacute;as asociadas a iteraciones completas.</target>
        </trans-unit>
        <trans-unit id="c8bb1ffaa9cf08918dd7437412b9271325c4076a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; command can change the replication settings of a replica on the fly. If a Redis server is already acting as replica, the command &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">El comando &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; puede cambiar la configuraci&amp;oacute;n de replicaci&amp;oacute;n de una r&amp;eacute;plica sobre la marcha. Si un servidor Redis ya est&amp;aacute; actuando como r&amp;eacute;plica, el comando &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NADIE apagar&amp;aacute; la r&amp;eacute;plica, convirtiendo el servidor Redis en un MAESTRO. En la forma adecuada, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port har&amp;aacute; que el servidor sea una r&amp;eacute;plica de otro servidor que escucha en el nombre de host y puerto especificados.</target>
        </trans-unit>
        <trans-unit id="bd3e1b27429bbc884368294b8f7962375860257e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command returns the current server time as a two items lists: a Unix timestamp and the amount of microseconds already elapsed in the current second. Basically the interface is very similar to the one of the &lt;code&gt;gettimeofday&lt;/code&gt; system call.</source>
          <target state="translated">El comando &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; devuelve la hora actual del servidor como una lista de dos elementos: una marca de tiempo Unix y la cantidad de microsegundos ya transcurridos en el segundo actual. B&amp;aacute;sicamente, la interfaz es muy similar a la de la llamada al sistema &lt;code&gt;gettimeofday&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70be0ca493bf011ad2206bbde68c46ec552ad130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command removes one or multiple messages from the &lt;em&gt;pending entries list&lt;/em&gt; (PEL) of a stream consumer group. A message is pending, and as such stored inside the PEL, when it was delivered to some consumer, normally as a side effect of calling &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, or when a consumer took ownership of a message calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. The pending message was delivered to some consumer but the server is yet not sure it was processed at least once. So new calls to &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; to grab the messages history for a consumer (for instance using an ID of 0), will return such message. Similarly the pending message will be listed by the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command, that inspects the PEL.</source>
          <target state="translated">El comando &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; elimina uno o varios mensajes de la &lt;em&gt;lista de entradas pendientes&lt;/em&gt; (PEL) de un grupo de consumidores de flujo. Un mensaje est&amp;aacute; pendiente y, como tal, almacenado dentro del PEL, cuando se entreg&amp;oacute; a alg&amp;uacute;n consumidor, normalmente como un efecto secundario de llamar a &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; , o cuando un consumidor tom&amp;oacute; posesi&amp;oacute;n de un mensaje que llama a &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; . El mensaje pendiente se entreg&amp;oacute; a alg&amp;uacute;n consumidor, pero el servidor a&amp;uacute;n no est&amp;aacute; seguro de que se haya procesado al menos una vez. Entonces, las nuevas llamadas a &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; para obtener el historial de mensajes de un consumidor (por ejemplo, usando un ID de 0), devolver&amp;aacute;n dicho mensaje. De manera similar, el mensaje pendiente ser&amp;aacute; listado por el comando &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; , que inspecciona el PEL.</target>
        </trans-unit>
        <trans-unit id="f919fa1bdb0a477435ee790e9628136dda8f63ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command is the interface to inspect the list of pending messages, and is as thus a very important command in order to observe and understand what is happening with a streams consumer groups: what clients are active, what messages are pending to be consumed, or to see if there are idle messages. Moreover this command, together with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; is used in order to implement recovering of consumers that are failing for a long time, and as a result certain messages are not processed: a different consumer can claim the message and continue. This is better explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;streams intro&lt;/a&gt; and in the &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; command page, and is not covered here.</source>
          <target state="translated">El comando &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; es la interfaz para inspeccionar la lista de mensajes pendientes, por lo que es un comando muy importante para observar y comprender lo que est&amp;aacute; sucediendo con un grupo de consumidores de streams: qu&amp;eacute; clientes est&amp;aacute;n activos, qu&amp;eacute; mensajes est&amp;aacute;n pendientes de ser consumidos, o para ver si hay mensajes inactivos. Adem&amp;aacute;s, este comando, junto con &lt;a href=&quot;xclaim&quot;&gt;XCLAIM,&lt;/a&gt; se utiliza para implementar la recuperaci&amp;oacute;n de consumidores que fallan durante mucho tiempo y, como resultado, ciertos mensajes no se procesan: un consumidor diferente puede reclamar el mensaje y continuar. Esto se explica mejor en la &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introducci&amp;oacute;n de secuencias&lt;/a&gt; y en la p&amp;aacute;gina de comandos de &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; , y no se trata aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="be7aa14ec80fad3a57ca56d203c2ac6e1198edd2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; command has a number of applications:</source>
          <target state="translated">El comando &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; tiene varias aplicaciones:</target>
        </trans-unit>
        <trans-unit id="1033731d720ba1e5c57d34f9f982462de081667c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command is a special version of the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command with support for consumer groups. Probably you will have to understand the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command before reading this page will makes sense.</source>
          <target state="translated">El comando &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; es una versi&amp;oacute;n especial del comando &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; con soporte para grupos de consumidores. Probablemente tendr&amp;aacute; que entender el comando &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; antes de que leer esta p&amp;aacute;gina tenga sentido.</target>
        </trans-unit>
        <trans-unit id="7ac305f70170c901011610af97e0bc42f712f0a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; ID is effectively just exactly as specifying &lt;code&gt;0-0&lt;/code&gt;, while &lt;code&gt;+&lt;/code&gt; is equivalent to &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt;, however they are nicer to type.</source>
          <target state="translated">El &lt;code&gt;-&lt;/code&gt; ID es exactamente igual que la especificaci&amp;oacute;n &lt;code&gt;0-0&lt;/code&gt; , mientras que &lt;code&gt;+&lt;/code&gt; es equivalente a &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt; , sin embargo, son m&amp;aacute;s agradables de escribir.</target>
        </trans-unit>
        <trans-unit id="ad556b3da4050d845b9c3a874361828db5c442a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; special IDs mean respectively the minimum ID possible and the maximum ID possible inside a stream, so the following command will just return every entry in the stream:</source>
          <target state="translated">Las ID especiales &lt;code&gt;-&lt;/code&gt; y &lt;code&gt;+&lt;/code&gt; significan respectivamente la ID m&amp;iacute;nima posible y la ID m&amp;aacute;xima posible dentro de una secuencia, por lo que el siguiente comando solo devolver&amp;aacute; cada entrada en la secuencia:</target>
        </trans-unit>
        <trans-unit id="7b7c72e7ac11e971e25ca474ee3da37e97621a8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option can also take a non-existent key, which causes &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; to skip the sorting operation. This is useful if you want to retrieve external keys (see the &lt;code&gt;GET&lt;/code&gt; option below) without the overhead of sorting.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;BY&lt;/code&gt; tambi&amp;eacute;n puede tomar una clave inexistente, lo que hace que &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; omita la operaci&amp;oacute;n de clasificaci&amp;oacute;n. Esto es &amp;uacute;til si desea recuperar claves externas (vea la opci&amp;oacute;n &lt;code&gt;GET&lt;/code&gt; a continuaci&amp;oacute;n) sin la sobrecarga de ordenar.</target>
        </trans-unit>
        <trans-unit id="04d5c46b7c9e4c0432ac2f85c4c63dc2b3333abd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option takes a pattern (equal to &lt;code&gt;weight_*&lt;/code&gt; in this example) that is used to generate the keys that are used for sorting. These key names are obtained substituting the first occurrence of &lt;code&gt;*&lt;/code&gt; with the actual value of the element in the list (&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; in this example).</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;BY&lt;/code&gt; toma un patr&amp;oacute;n (igual a &lt;code&gt;weight_*&lt;/code&gt; en este ejemplo) que se usa para generar las claves que se usan para ordenar. Estos nombres de clave se obtienen sustituyendo la primera aparici&amp;oacute;n de &lt;code&gt;*&lt;/code&gt; con el valor real del elemento en la lista ( &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; y &lt;code&gt;3&lt;/code&gt; en este ejemplo).</target>
        </trans-unit>
        <trans-unit id="7781d414a168c2c6071c960ca2a2f476d429921c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELSLOTS&lt;/code&gt; command asks a particular Redis Cluster node to forget which master is serving the hash slots specified as arguments.</source>
          <target state="translated">El comando &lt;code&gt;DELSLOTS&lt;/code&gt; le pide a un nodo de Redis Cluster en particular que olvide qu&amp;eacute; maestro est&amp;aacute; sirviendo las ranuras hash especificadas como argumentos.</target>
        </trans-unit>
        <trans-unit id="f40cf7905426fe2efaf1d7bb82912ca46b5d481b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; option can be used multiple times in order to get more keys for every element of the original list, set or sorted set.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;GET&lt;/code&gt; se puede utilizar varias veces para obtener m&amp;aacute;s claves para cada elemento de la lista original, conjunto o conjunto ordenado.</target>
        </trans-unit>
        <trans-unit id="692cd27ca778c52fb164170863c312f93a4febd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOACK&lt;/code&gt; subcommand can be used to avoid adding the message to the PEL in cases where reliability is not a requirement and the occasional message loss is acceptable. This is equivalent to acknowledging the message when it is read.</source>
          <target state="translated">El subcomando &lt;code&gt;NOACK&lt;/code&gt; se puede utilizar para evitar agregar el mensaje al PEL en los casos en que la confiabilidad no es un requisito y la p&amp;eacute;rdida ocasional del mensaje es aceptable. Esto equivale a reconocer el mensaje cuando se lee.</target>
        </trans-unit>
        <trans-unit id="70ae9c69379861ae43b186cc1aea347b195c9116" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NODE&lt;/code&gt; subcommand is the one with the most complex semantics. It associates the hash slot with the specified node, however the command works only in specific situations and has different side effects depending on the slot state. The following is the set of pre-conditions and side effects of the command:</source>
          <target state="translated">El subcomando &lt;code&gt;NODE&lt;/code&gt; es el que tiene la sem&amp;aacute;ntica m&amp;aacute;s compleja. Asocia la ranura hash con el nodo especificado, sin embargo, el comando funciona solo en situaciones espec&amp;iacute;ficas y tiene diferentes efectos secundarios seg&amp;uacute;n el estado de la ranura. El siguiente es el conjunto de condiciones previas y efectos secundarios del comando:</target>
        </trans-unit>
        <trans-unit id="f3353a302ef9a9215dfe9198dea9a7e8ef365e65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aof_delayed_fsync&lt;/code&gt; counter</source>
          <target state="translated">El contador &lt;code&gt;aof_delayed_fsync&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b5f4a6fffad95a3f4be7e216981db9fcd1d6fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; argument is available since version 3.2.</source>
          <target state="translated">El argumento de &lt;code&gt;count&lt;/code&gt; est&amp;aacute; disponible desde la versi&amp;oacute;n 3.2.</target>
        </trans-unit>
        <trans-unit id="8ce90da51cb5b392562f97eba72b463845c11c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip:port&lt;/code&gt; should match a line returned by the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command (&lt;code&gt;addr&lt;/code&gt; field).</source>
          <target state="translated">El &lt;code&gt;ip:port&lt;/code&gt; debe coincidir con una l&amp;iacute;nea devuelta por el comando &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; ( campo &lt;code&gt;addr&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5777eb84fcb1170d8747af88e5c07f98feb04ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;message&lt;/code&gt; argument is simply a string. Example:</source>
          <target state="translated">El argumento del &lt;code&gt;message&lt;/code&gt; es simplemente una cadena. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="9ea110d8be26fa3611a695ea1e98f388ddefd010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same meaning as described for &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">Los argumentos &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; tienen el mismo significado que se describe para &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="109dd07703928b5f87b169ad0c30d69a49fafa5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same semantic as described for &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">Los argumentos &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; tienen la misma sem&amp;aacute;ntica que se describe para &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07c405abf8ce41269def6794789e4d59831e2dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;score&lt;/code&gt; value should be the string representation of a numeric value, and accepts double precision floating point numbers. It is possible to provide a negative value to decrement the score.</source>
          <target state="translated">El valor de la &lt;code&gt;score&lt;/code&gt; debe ser la representaci&amp;oacute;n de cadena de un valor num&amp;eacute;rico y acepta n&amp;uacute;meros de coma flotante de doble precisi&amp;oacute;n. Es posible proporcionar un valor negativo para disminuir la puntuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ca4c3a5926b2e82699f6692683e7c60016ad3961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an integer value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">El argumento de &lt;code&gt;timeout&lt;/code&gt; se interpreta como un valor entero que especifica el n&amp;uacute;mero m&amp;aacute;ximo de segundos para bloquear. Se puede usar un tiempo de espera de cero para bloquear indefinidamente.</target>
        </trans-unit>
        <trans-unit id="b70e592aaa3d9e8f7df4a512dc479e926a2adbc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; argument between the &lt;strong&gt;MAXLEN&lt;/strong&gt; option and the actual count means that the user is not really requesting that the stream length is exactly 1000 items, but instead it could be a few tens of entries more, but never less than 1000 items. When this option modifier is used, the trimming is performed only when Redis is able to remove a whole macro node. This makes it much more efficient, and it is usually what you want.</source>
          <target state="translated">El argumento &lt;code&gt;~&lt;/code&gt; entre la opci&amp;oacute;n &lt;strong&gt;MAXLEN&lt;/strong&gt; y el recuento real significa que el usuario no est&amp;aacute; solicitando realmente que la longitud del flujo sea exactamente 1000 elementos, sino que podr&amp;iacute;a ser unas pocas decenas de entradas m&amp;aacute;s, pero nunca menos de 1000 elementos. Cuando se usa este modificador de opci&amp;oacute;n, el recorte se realiza solo cuando Redis puede eliminar un macro nodo completo. Esto lo hace mucho m&amp;aacute;s eficiente y, por lo general, es lo que desea.</target>
        </trans-unit>
        <trans-unit id="ea8b5fbf2699e6884711237f84a50ed662e87dcb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;STREAMS&lt;/strong&gt; option is mandatory and MUST be the final option because such option gets a variable length of argument in the following format:</source>
          <target state="translated">La opci&amp;oacute;n &lt;strong&gt;STREAMS&lt;/strong&gt; es obligatoria y DEBE ser la &amp;uacute;ltima opci&amp;oacute;n porque dicha opci&amp;oacute;n obtiene una longitud variable de argumento en el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="f1467c9ba6d40cf52b5cdae46604d845510d3c66" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TAKEOVER&lt;/strong&gt; option implies everything &lt;strong&gt;FORCE&lt;/strong&gt; implies, but also does not uses any cluster authorization in order to failover. A replica receiving &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; will instead:</source>
          <target state="translated">La opci&amp;oacute;n &lt;strong&gt;TAKEOVER&lt;/strong&gt; implica todo lo que &lt;strong&gt;FORCE&lt;/strong&gt; implica, pero tampoco utiliza ninguna autorizaci&amp;oacute;n de cl&amp;uacute;ster para realizar la conmutaci&amp;oacute;n por error. En su lugar, una r&amp;eacute;plica que reciba &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="706ee50ff413a981311879f38f0325b685e418ae" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cluster&lt;/strong&gt; section currently only contains a unique field:</source>
          <target state="translated">El &lt;strong&gt;grupo de&lt;/strong&gt; la secci&amp;oacute;n en la actualidad s&amp;oacute;lo contiene un campo &amp;uacute;nico:</target>
        </trans-unit>
        <trans-unit id="e18469751043e4051869a86bbcba03716b45e346" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;commandstats&lt;/strong&gt; section provides statistics based on the command type, including the number of calls, the total CPU time consumed by these commands, and the average CPU consumed per command execution.</source>
          <target state="translated">La secci&amp;oacute;n &lt;strong&gt;commandstats&lt;/strong&gt; proporciona estad&amp;iacute;sticas basadas en el tipo de comando, incluido el n&amp;uacute;mero de llamadas, el tiempo total de CPU consumido por estos comandos y el CPU promedio consumido por ejecuci&amp;oacute;n de comando.</target>
        </trans-unit>
        <trans-unit id="f90c39a55fa63248e76899e871ade6a1431c29d1" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;keyspace&lt;/strong&gt; section provides statistics on the main dictionary of each database. The statistics are the number of keys, and the number of keys with an expiration.</source>
          <target state="translated">La secci&amp;oacute;n de &lt;strong&gt;espacio de claves&lt;/strong&gt; proporciona estad&amp;iacute;sticas sobre el diccionario principal de cada base de datos. Las estad&amp;iacute;sticas son el n&amp;uacute;mero de claves y el n&amp;uacute;mero de claves con vencimiento.</target>
        </trans-unit>
        <trans-unit id="3ff483a1ce1f770bdb2f62a76889e8f7ada78a73" translate="yes" xml:space="preserve">
          <source>The CJSON library provides extremely fast JSON manipulation within Lua.</source>
          <target state="translated">La biblioteca de CJSON proporciona una manipulación extremadamente rápida de JSON dentro de Lua.</target>
        </trans-unit>
        <trans-unit id="7530389adb107898a8e0437c53cce50bad07ea36" translate="yes" xml:space="preserve">
          <source>The COUNT option</source>
          <target state="translated">La opción COUNT</target>
        </trans-unit>
        <trans-unit id="e8dffa28f7261bfe8a1090fc2b6db1ae98bb313f" translate="yes" xml:space="preserve">
          <source>The HyperLogLog data structure can be used in order to count &lt;strong&gt;unique&lt;/strong&gt; elements in a set using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog (plus a few bytes for the key itself).</source>
          <target state="translated">La estructura de datos de HyperLogLog se puede usar para contar elementos &lt;strong&gt;&amp;uacute;nicos&lt;/strong&gt; en un conjunto usando solo una peque&amp;ntilde;a cantidad constante de memoria, espec&amp;iacute;ficamente 12k bytes para cada HyperLogLog (m&amp;aacute;s algunos bytes para la clave en s&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="5d5e9e7569c5ac826ef312fb92859c0deffb60e9" translate="yes" xml:space="preserve">
          <source>The HyperLogLog, being a Redis string, can be retrieved with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; and restored with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. Calling &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;, &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; or &lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt; commands with a corrupted HyperLogLog is never a problem, it may return random values but does not affect the stability of the server. Most of the times when corrupting a sparse representation, the server recognizes the corruption and returns an error.</source>
          <target state="translated">El HyperLogLog, que es una cadena de Redis, se puede recuperar con &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; y restaurar con &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; . Llamar &lt;a href=&quot;pfadd&quot;&gt;comandos PFADD&lt;/a&gt; , &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; o &lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt; con un HyperLogLog da&amp;ntilde;ado nunca es un problema, puede devolver valores aleatorios pero no afecta la estabilidad del servidor. La mayor&amp;iacute;a de las veces, cuando se corrompe una representaci&amp;oacute;n escasa, el servidor reconoce la corrupci&amp;oacute;n y devuelve un error.</target>
        </trans-unit>
        <trans-unit id="b9ffa717a680ea863704c9d4cbe178090dee5908" translate="yes" xml:space="preserve">
          <source>The ID is monotonically incremental. If the ID of a connection is greater than the ID of another connection, it is guaranteed that the second connection was established with the server at a later time.</source>
          <target state="translated">La identificación es monótonamente incremental.Si el ID de una conexión es mayor que el ID de otra conexión,se garantiza que la segunda conexión se estableció con el servidor en un momento posterior.</target>
        </trans-unit>
        <trans-unit id="7f2d6cad55038bdb71cc5342903dad20539f48ed" translate="yes" xml:space="preserve">
          <source>The ID is never reset in the course of the Redis server execution, only a server restart will reset it.</source>
          <target state="translated">El ID nunca se reinicia en el curso de la ejecución del servidor de Redis,sólo un reinicio del servidor lo reiniciará.</target>
        </trans-unit>
        <trans-unit id="5028f5e06740630088beea552d56dbc9a9d96305" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just add 1 to the sequence to obtain &lt;code&gt;1526985685298-1&lt;/code&gt;, and continue our iteration:</source>
          <target state="translated">El ID de la &amp;uacute;ltima entrada es &lt;code&gt;1526985685298-0&lt;/code&gt; , por lo que solo agregamos 1 a la secuencia para obtener &lt;code&gt;1526985685298-1&lt;/code&gt; y continuamos nuestra iteraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="bfc0d85cea060a3580771bdafcea7e5bc90996bb" translate="yes" xml:space="preserve">
          <source>The ID of the message.</source>
          <target state="translated">La identificación del mensaje.</target>
        </trans-unit>
        <trans-unit id="10ecce9f88d9ae56cb1bcd6efbec98fbc1a5f68e" translate="yes" xml:space="preserve">
          <source>The ID to specify in the &lt;strong&gt;STREAMS&lt;/strong&gt; option when using &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; can be one of the following two:</source>
          <target state="translated">El ID para especificar en la opci&amp;oacute;n &lt;strong&gt;STREAMS&lt;/strong&gt; cuando se usa &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; puede ser uno de los siguientes dos:</target>
        </trans-unit>
        <trans-unit id="a5addd3dd6a1b78a37c68a12e4b0f086415a0b5b" translate="yes" xml:space="preserve">
          <source>The IP of the master.</source>
          <target state="translated">La IP del maestro.</target>
        </trans-unit>
        <trans-unit id="4f53ea350a50177374bcdd35f9332bb81e5298f0" translate="yes" xml:space="preserve">
          <source>The Lua Bit Operations Module adds bitwise operations on numbers. It is available for scripting in Redis since version 2.8.18.</source>
          <target state="translated">El módulo de operaciones de Lua Bit añade operaciones de bits en los números.Está disponible para scripts en Redis desde la versión 2.8.18.</target>
        </trans-unit>
        <trans-unit id="1051d37718542a5598a286cc56e5f5aaafbf73d5" translate="yes" xml:space="preserve">
          <source>The Lua PRNG in this mode is seeded randomly at every call.</source>
          <target state="translated">El Lua PRNG en este modo es sembrado al azar en cada llamada.</target>
        </trans-unit>
        <trans-unit id="a8d85991ddfb0f169b9f806f86a3cc0413e31e4e" translate="yes" xml:space="preserve">
          <source>The Lua debugger is described in the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Lua scripts debugging&lt;/a&gt; section of the Redis documentation.</source>
          <target state="translated">El depurador de Lua se describe en la secci&amp;oacute;n de &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;depuraci&amp;oacute;n de scripts de Lua&lt;/a&gt; de la documentaci&amp;oacute;n de Redis.</target>
        </trans-unit>
        <trans-unit id="0a696a748eaeb904c163e6d11e4f1f007a0ef038" translate="yes" xml:space="preserve">
          <source>The MATCH option</source>
          <target state="translated">La opción MATCH</target>
        </trans-unit>
        <trans-unit id="4eb0859176601ed31b0ed60fbf24deb7442f3423" translate="yes" xml:space="preserve">
          <source>The PUBSUB command is an introspection command that allows to inspect the state of the Pub/Sub subsystem. It is composed of subcommands that are documented separately. The general form is:</source>
          <target state="translated">El comando PUBSUB es un comando de introspección que permite inspeccionar el estado del subsistema Pub/Sub.Está compuesto por subcomandos que se documentan por separado.La forma general es:</target>
        </trans-unit>
        <trans-unit id="82e7a6dd485996953664282bec28fa4f1043afe7" translate="yes" xml:space="preserve">
          <source>The Redis Lua interpreter loads the following Lua libraries:</source>
          <target state="translated">El intérprete de Redis Lua carga las siguientes bibliotecas de Lua:</target>
        </trans-unit>
        <trans-unit id="bb0c5eade03c486c5f8281c1da8633f26a4b714d" translate="yes" xml:space="preserve">
          <source>The Redis Slow Log is a system to log queries that exceeded a specified execution time. The execution time does not include I/O operations like talking with the client, sending the reply and so forth, but just the time needed to actually execute the command (this is the only stage of command execution where the thread is blocked and can not serve other requests in the meantime).</source>
          <target state="translated">El Redis Slow Log es un sistema para registrar las consultas que superan un tiempo de ejecución especificado.El tiempo de ejecución no incluye operaciones de E/S como hablar con el cliente,enviar la respuesta,etc.,sino sólo el tiempo necesario para ejecutar realmente el comando (esta es la única etapa de ejecución del comando en la que el hilo se bloquea y no puede servir a otras peticiones mientras tanto).</target>
        </trans-unit>
        <trans-unit id="63b3dcb2e93d3c4b06fb3ccd03dd7de69fb04d43" translate="yes" xml:space="preserve">
          <source>The SCRIPT command</source>
          <target state="translated">El comando SCRIPT</target>
        </trans-unit>
        <trans-unit id="0f9be29f5758f4e3311e10dd99d11effd38e89f6" translate="yes" xml:space="preserve">
          <source>The ability to see all the requests processed by the server is useful in order to spot bugs in an application both when using Redis as a database and as a distributed caching system.</source>
          <target state="translated">La capacidad de ver todas las solicitudes procesadas por el servidor es útil para detectar errores en una aplicación tanto cuando se utiliza Redis como base de datos como sistema de caché distribuido.</target>
        </trans-unit>
        <trans-unit id="f195a8757b1d8a55a19d37ee9ad3a22c5c0a4e17" translate="yes" xml:space="preserve">
          <source>The above makes it very simple to implement a system where a set of items must be processed by N workers continuously as fast as possible. An example is a monitoring system that must check that a set of web sites are reachable, with the smallest delay possible, using a number of parallel workers.</source>
          <target state="translated">Lo anterior hace que sea muy sencillo implementar un sistema en el que un conjunto de artículos debe ser procesado por N trabajadores de forma continua y lo más rápido posible.Un ejemplo es un sistema de vigilancia que debe comprobar que un conjunto de sitios web son accesibles,con la menor demora posible,utilizando un número de trabajadores paralelos.</target>
        </trans-unit>
        <trans-unit id="75a3a44602ce55e23d207b895b5a485f6d4a2fc0" translate="yes" xml:space="preserve">
          <source>The above pattern works even if the following two conditions:</source>
          <target state="translated">El patrón anterior funciona incluso si se dan las dos condiciones siguientes:</target>
        </trans-unit>
        <trans-unit id="4d153745d60911da280f1df79b2e372158711e77" translate="yes" xml:space="preserve">
          <source>The above script sets the key &lt;code&gt;foo&lt;/code&gt; to the string &lt;code&gt;bar&lt;/code&gt;. However it violates the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command semantics as all the keys that the script uses should be passed using the &lt;code&gt;KEYS&lt;/code&gt; array:</source>
          <target state="translated">El script anterior establece la clave &lt;code&gt;foo&lt;/code&gt; en la &lt;code&gt;bar&lt;/code&gt; ra de cadenas . Sin embargo, viola la sem&amp;aacute;ntica del comando &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; ya que todas las claves que usa el script deben pasarse usando la matriz &lt;code&gt;KEYS&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0dd21e93f4a7ab544f682629858a1ca7196710f4" translate="yes" xml:space="preserve">
          <source>The additional elements of the array depends on the role.</source>
          <target state="translated">Los elementos adicionales del conjunto dependen de la función.</target>
        </trans-unit>
        <trans-unit id="b4c1764b30cb0625e6c253a27bb41e84ea603d9e" translate="yes" xml:space="preserve">
          <source>The algorithm used, that is implemented inside dict.c, samples the hash table buckets to find a non-empty one. Once a non empty bucket is found, since we use chaining in our hash table implementation, the number of elements inside the bucket is checked and a random element is selected.</source>
          <target state="translated">El algoritmo utilizado,que se implementa dentro del dict.c,muestrea los cubos de la mesa de hash para encontrar uno no vacío.Una vez que se encuentra un cubo no vacío,ya que usamos encadenamiento en nuestra implementación de la tabla de hachís,se comprueba el número de elementos dentro del cubo y se selecciona un elemento al azar.</target>
        </trans-unit>
        <trans-unit id="6de2e476596fcaba51a4ddd43e2a8bd4d48c346f" translate="yes" xml:space="preserve">
          <source>The amount of data received from the replica so far in terms of master replication offset.</source>
          <target state="translated">La cantidad de datos recibidos de la réplica hasta ahora en términos de compensación de la réplica maestra.</target>
        </trans-unit>
        <trans-unit id="5d8b8009ef4dd06c8c025f1eed58b5b1787f1f48" translate="yes" xml:space="preserve">
          <source>The amount of time needed for its execution, in microseconds.</source>
          <target state="translated">La cantidad de tiempo necesaria para su ejecución,en microsegundos.</target>
        </trans-unit>
        <trans-unit id="e5407b8706df1e8319a7a989bf68d7ad75911c3a" translate="yes" xml:space="preserve">
          <source>The approximated number of unique elements observed via &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;.</source>
          <target state="translated">El n&amp;uacute;mero aproximado de elementos &amp;uacute;nicos observados mediante &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d3457f0c58f45dac774e34be45c19b72f462db2" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;redis.call()&lt;/code&gt; and &lt;code&gt;redis.pcall()&lt;/code&gt; functions are all the arguments of a well formed Redis command:</source>
          <target state="translated">Los argumentos de las &lt;code&gt;redis.call()&lt;/code&gt; y &lt;code&gt;redis.pcall()&lt;/code&gt; son todos los argumentos de un comando de Redis bien formado:</target>
        </trans-unit>
        <trans-unit id="120865be87c8e6ca3cb347b65ffdefe018090581" translate="yes" xml:space="preserve">
          <source>The array composing the arguments of the command.</source>
          <target state="translated">La matriz que compone los argumentos del comando.</target>
        </trans-unit>
        <trans-unit id="a010440d8c2596df424c379b3133bfd83782f2d9" translate="yes" xml:space="preserve">
          <source>The assigned name is displayed in the output of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; so that it is possible to identify the client that performed a given connection.</source>
          <target state="translated">El nombre asignado se muestra en la salida de la &lt;a href=&quot;client-list&quot;&gt;LISTA DE CLIENTES&lt;/a&gt; para que sea posible identificar al cliente que realiz&amp;oacute; una conexi&amp;oacute;n determinada.</target>
        </trans-unit>
        <trans-unit id="885f9339188f139f7b1172052e203973f59a224e" translate="yes" xml:space="preserve">
          <source>The basic idea is that nodes by default don't trust each other, and are considered unknown, so that it is unlikely that different cluster nodes will mix into a single one because of system administration errors or network addresses modifications.</source>
          <target state="translated">La idea básica es que los nodos por defecto no se confían entre sí y se consideran desconocidos,por lo que es poco probable que diferentes nodos del grupo se mezclen en uno solo debido a errores de administración del sistema o a modificaciones de las direcciones de la red.</target>
        </trans-unit>
        <trans-unit id="da9c85f3c202fdd59f8f147e36c3ec1f770f703e" translate="yes" xml:space="preserve">
          <source>The behavior of Redis 2.4 creates a lot of problems when replicating or persisting data into the AOF file, so the much more generic and semantically simpler behavior was introduced into Redis 2.6 to prevent problems.</source>
          <target state="translated">El comportamiento de Redis 2.4 crea muchos problemas al replicar o persistir los datos en el archivo AOF,por lo que se introdujo un comportamiento mucho más genérico y semánticamente simple en Redis 2.6 para evitar problemas.</target>
        </trans-unit>
        <trans-unit id="b344dc2bc04bb34933613eb7044804cab8c272df" translate="yes" xml:space="preserve">
          <source>The binary nature of the comparison allows to use sorted sets as a general purpose index, for example the first part of the element can be a 64 bit big endian number: since big endian numbers have the most significant bytes in the initial positions, the binary comparison will match the numerical comparison of the numbers. This can be used in order to implement range queries on 64 bit values. As in the example below, after the first 8 bytes we can store the value of the element we are actually indexing.</source>
          <target state="translated">La naturaleza binaria de la comparación permite utilizar conjuntos ordenados como un índice de propósito general,por ejemplo la primera parte del elemento puede ser un número indían grande de 64 bits:dado que los números indían grandes tienen los bytes más significativos en las posiciones iniciales,la comparación binaria coincidirá con la comparación numérica de los números.Esto puede utilizarse para implementar consultas de rango en valores de 64 bits.Como en el ejemplo siguiente,después de los primeros 8 bytes podemos almacenar el valor del elemento que estamos indexando realmente.</target>
        </trans-unit>
        <trans-unit id="d3282d877e14a9e1a4f618e1ae58563eb55cb394" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1. When &lt;em&gt;key&lt;/em&gt; does not exist, a new string value is created. The string is grown to make sure it can hold a bit at &lt;em&gt;offset&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; argument is required to be greater than or equal to 0, and smaller than 2&lt;sup&gt;32&lt;/sup&gt; (this limits bitmaps to 512MB). When the string at &lt;em&gt;key&lt;/em&gt; is grown, added bits are set to 0.</source>
          <target state="translated">El bit se establece o se borra seg&amp;uacute;n el &lt;em&gt;valor&lt;/em&gt; , que puede ser 0 o 1. Cuando la &lt;em&gt;clave&lt;/em&gt; no existe, se crea un nuevo valor de cadena. La cuerda crece para asegurarse de que pueda aguantar un poco en el &lt;em&gt;desplazamiento&lt;/em&gt; . Se requiere que el argumento de &lt;em&gt;desplazamiento&lt;/em&gt; sea ​​mayor o igual a 0 y menor que 2 &lt;sup&gt;32&lt;/sup&gt; (esto limita los mapas de bits a 512 MB). Cuando la cadena en la &lt;em&gt;clave&lt;/em&gt; crece, los bits agregados se establecen en 0.</target>
        </trans-unit>
        <trans-unit id="0b7af7df323735c0dce87d77fcd93c888e45e3a0" translate="yes" xml:space="preserve">
          <source>The client explicitly checks the &lt;code&gt;runid&lt;/code&gt; field in the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command in order to make sure the server was not restarted and is still the same process.</source>
          <target state="translated">El cliente verifica expl&amp;iacute;citamente el campo &lt;code&gt;runid&lt;/code&gt; en el comando &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; para asegurarse de que el servidor no se reinici&amp;oacute; y sigue siendo el mismo proceso.</target>
        </trans-unit>
        <trans-unit id="9350ca0340f5b792f129eec734a9c6029b8bad38" translate="yes" xml:space="preserve">
          <source>The client flags can be a combination of:</source>
          <target state="translated">Las banderas de los clientes pueden ser una combinación de:</target>
        </trans-unit>
        <trans-unit id="ef7c4ea851346ff688f43804007664e07a0ee9aa" translate="yes" xml:space="preserve">
          <source>The client library implementation can always optimistically send &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; under the hood even when the client actually calls &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;, in the hope the script was already seen by the server. If the &lt;code&gt;NOSCRIPT&lt;/code&gt; error is returned &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will be used instead.</source>
          <target state="translated">La implementaci&amp;oacute;n de la biblioteca cliente siempre puede enviar &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; bajo el cap&amp;oacute; de manera optimista incluso cuando el cliente realmente llama a &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; , con la esperanza de que el servidor ya haya visto el script. Si se devuelve el error &lt;code&gt;NOSCRIPT&lt;/code&gt; , se utilizar&amp;aacute; &lt;a href=&quot;eval&quot;&gt;EVAL en&lt;/a&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="5dfcddce441b9e425d29945dfa151dd5838c9e0e" translate="yes" xml:space="preserve">
          <source>The client library implementation should take one of the following approaches:</source>
          <target state="translated">La aplicación de la biblioteca de clientes debería adoptar uno de los siguientes enfoques:</target>
        </trans-unit>
        <trans-unit id="cea5f73089ab49d55692f68c7533b954be4a4271" translate="yes" xml:space="preserve">
          <source>The client sent a command about hash slots never served by the master of this replica.</source>
          <target state="translated">El cliente envió un comando sobre ranuras de hachís nunca servidas por el maestro de esta réplica.</target>
        </trans-unit>
        <trans-unit id="4f3cae0941780fdfb0d5aa096cbd40be72c4d373" translate="yes" xml:space="preserve">
          <source>The client will have to acknowledge the message processing using &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; in order for the pending entry to be removed from the PEL. The PEL can be inspected using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">El cliente tendr&amp;aacute; que acusar recibo del procesamiento del mensaje usando &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; para que la entrada pendiente sea eliminada del PEL. El PEL se puede inspeccionar usando el comando &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82fd513f621c09ac0869a99d08b31390f0bc842b" translate="yes" xml:space="preserve">
          <source>The cluster was reconfigured (for example resharded) and the replica is no longer able to serve commands for a given hash slot.</source>
          <target state="translated">El cúmulo se reconfiguró (por ejemplo,se volvió a endurecer)y la réplica ya no es capaz de servir comandos para una determinada ranura de hachís.</target>
        </trans-unit>
        <trans-unit id="9940f805fd9de379d7d0c58cd1b84f3338b5e58f" translate="yes" xml:space="preserve">
          <source>The cmsgpack library provides simple and fast MessagePack manipulation within Lua.</source>
          <target state="translated">La biblioteca del cmsgpack proporciona una simple y rápida manipulación del MessagePack dentro de Lua.</target>
        </trans-unit>
        <trans-unit id="0b9bb30b2dbe12e3fa62af10a99007a2ae4848a9" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is also able to iterate the stream. The command &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; can iterate the stream reverse, from higher IDs (or times) to lower IDs (or times).</source>
          <target state="translated">El comando &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; tambi&amp;eacute;n puede iterar la secuencia. El comando &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; puede iterar el flujo inverso, desde ID m&amp;aacute;s altos (o tiempos) a ID m&amp;aacute;s bajos (o tiempos).</target>
        </trans-unit>
        <trans-unit id="4fbd17702a2c89af4ecc45167e7c6a7b02c943ed" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; is a simple way to implement a locking system with Redis.</source>
          <target state="translated">El comando &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; es una forma sencilla de implementar un sistema de bloqueo con Redis.</target>
        </trans-unit>
        <trans-unit id="2dbda62e4a8fd31c5ca6fc1f4cddf22961ead108" translate="yes" xml:space="preserve">
          <source>The command &lt;strong&gt;will always return&lt;/strong&gt; the number of replicas that acknowledged the write commands sent before the &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; command, both in the case where the specified number of replicas are reached, or when the timeout is reached.</source>
          <target state="translated">El comando &lt;strong&gt;siempre devolver&amp;aacute;&lt;/strong&gt; el n&amp;uacute;mero de r&amp;eacute;plicas que reconocieron los comandos de escritura enviados antes del comando &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; , tanto en el caso en el que se alcanza el n&amp;uacute;mero especificado de r&amp;eacute;plicas como cuando se alcanza el tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="4a44b122481ff3652c96ef6533c739e783fe19c3" translate="yes" xml:space="preserve">
          <source>The command also has a reciprocal command returning items in the reverse order, called &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;, which is otherwise identical.</source>
          <target state="translated">El comando tambi&amp;eacute;n tiene un comando rec&amp;iacute;proco que devuelve elementos en el orden inverso, llamado &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; , que por lo dem&amp;aacute;s es id&amp;eacute;ntico.</target>
        </trans-unit>
        <trans-unit id="b51d9780c5d61a87b53bd27d3ac5c24a4b0638d8" translate="yes" xml:space="preserve">
          <source>The command behavior can be modified by two options: &lt;strong&gt;FORCE&lt;/strong&gt; and &lt;strong&gt;TAKEOVER&lt;/strong&gt;.</source>
          <target state="translated">El comportamiento del comando se puede modificar con dos opciones: &lt;strong&gt;FORZAR&lt;/strong&gt; y &lt;strong&gt;TOMAR&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0e77b773bc1837b920cb41a24e1a0ef629792be6" translate="yes" xml:space="preserve">
          <source>The command behavior is the following:</source>
          <target state="translated">El comportamiento del comando es el siguiente:</target>
        </trans-unit>
        <trans-unit id="913ef9d1ec1890a263c7a3667b134a3de340bd38" translate="yes" xml:space="preserve">
          <source>The command can accept a variable number of arguments so it always returns an array of positions even when a single element is specified.</source>
          <target state="translated">El comando puede aceptar un número variable de argumentos,por lo que siempre devuelve una serie de posiciones,incluso cuando se especifica un solo elemento.</target>
        </trans-unit>
        <trans-unit id="b9a60a6fc9ab713863d0cdace7cfdb88da1428ea" translate="yes" xml:space="preserve">
          <source>The command can be called with four different arguments:</source>
          <target state="translated">El comando puede ser llamado con cuatro argumentos diferentes:</target>
        </trans-unit>
        <trans-unit id="d2095dc05dd59018ca256f0a5fc566c35f0f4cc7" translate="yes" xml:space="preserve">
          <source>The command default is to return unsorted items. Two different sorting methods can be invoked using the following two options:</source>
          <target state="translated">El comando por defecto es devolver los artículos sin clasificar.Se pueden invocar dos métodos de clasificación diferentes utilizando las dos opciones siguientes:</target>
        </trans-unit>
        <trans-unit id="958832c31d8e5542b245102310cbd53d9f34320f" translate="yes" xml:space="preserve">
          <source>The command does not succeed and returns an error in the following cases:</source>
          <target state="translated">El comando no tiene éxito y devuelve un error en los siguientes casos:</target>
        </trans-unit>
        <trans-unit id="32a8711ea8a78a0226239432ccf720cba86e66af" translate="yes" xml:space="preserve">
          <source>The command fails if the same slot is specified multiple times.</source>
          <target state="translated">El comando falla si se especifica la misma ranura varias veces.</target>
        </trans-unit>
        <trans-unit id="b6f1f38c10e41d6cb188193c5859a8d2a04588ed" translate="yes" xml:space="preserve">
          <source>The command has multiple options, however most are mainly for internal use in order to transfer the effects of &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; or other commands to the AOF file and to propagate the same effects to the slaves, and are unlikely to be useful to normal users:</source>
          <target state="translated">El comando tiene m&amp;uacute;ltiples opciones, sin embargo, la mayor&amp;iacute;a son principalmente para uso interno para transferir los efectos de &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; u otros comandos al archivo AOF y propagar los mismos efectos a los esclavos, y es poco probable que sean &amp;uacute;tiles para usuarios normales:</target>
        </trans-unit>
        <trans-unit id="aff611203495e6eb730550d71c578dbd6ea9eaee" translate="yes" xml:space="preserve">
          <source>The command internally uses &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; to generate the serialized version of the key value, and &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; in order to synthesize the key in the target instance. The source instance acts as a client for the target instance. If the target instance returns OK to the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command, the source instance deletes the key using &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;.</source>
          <target state="translated">El comando utiliza internamente &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; para generar la versi&amp;oacute;n serializada del valor de la clave y &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; para sintetizar la clave en la instancia de destino. La instancia de origen act&amp;uacute;a como cliente de la instancia de destino. Si la instancia de destino devuelve OK al comando &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; , la instancia de origen elimina la clave usando &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8dc74da7f9aeeb2a318e48a6c60e1183a0da365" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">El comando siempre se propaga en el enlace de replicaci&amp;oacute;n y en el archivo &lt;a href=&quot;hset&quot;&gt;adjuntar&lt;/a&gt; solo como una operaci&amp;oacute;n HSET , de modo que las diferencias en la implementaci&amp;oacute;n matem&amp;aacute;tica de punto flotante subyacente no ser&amp;aacute;n fuentes de inconsistencia.</target>
        </trans-unit>
        <trans-unit id="89297d1be1338bce5eaa89c5524f124377b2d8a5" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">El comando siempre se propaga en el enlace de replicaci&amp;oacute;n y en el archivo de solo adjuntar como una operaci&amp;oacute;n &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; , de modo que las diferencias en la implementaci&amp;oacute;n matem&amp;aacute;tica de punto flotante subyacente no ser&amp;aacute;n fuentes de inconsistencia.</target>
        </trans-unit>
        <trans-unit id="a86933f06a2ba31db5ee212ee8cc903bc3c40f34" translate="yes" xml:space="preserve">
          <source>The command is atomic and blocks the two instances for the time required to transfer the key, at any given time the key will appear to exist in a given instance or in the other instance, unless a timeout error occurs. In 3.2 and above, multiple keys can be pipelined in a single call to &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; by passing the empty string (&quot;&quot;) as key and adding the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; clause.</source>
          <target state="translated">El comando es at&amp;oacute;mico y bloquea las dos instancias durante el tiempo necesario para transferir la clave; en cualquier momento, la clave parecer&amp;aacute; existir en una instancia determinada o en la otra instancia, a menos que se produzca un error de tiempo de espera. En 3.2 y superior, se pueden canalizar varias claves en una sola llamada a &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; pasando la cadena vac&amp;iacute;a (&quot;&quot;) como clave y agregando la cl&amp;aacute;usula &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4335b586f31c83a0ae96d3ccf6ca0cfaf3a8429" translate="yes" xml:space="preserve">
          <source>The command is used in order to remove a node, specified via its node ID, from the set of &lt;em&gt;known nodes&lt;/em&gt; of the Redis Cluster node receiving the command. In other words the specified node is removed from the &lt;em&gt;nodes table&lt;/em&gt; of the node receiving the command.</source>
          <target state="translated">El comando se utiliza para eliminar un nodo, especificado a trav&amp;eacute;s de su ID de nodo, del conjunto de &lt;em&gt;nodos conocidos&lt;/em&gt; del nodo Redis Cluster que recibe el comando. En otras palabras, el nodo especificado se elimina de la &lt;em&gt;tabla&lt;/em&gt; de nodos del nodo que recibe el comando.</target>
        </trans-unit>
        <trans-unit id="9389c07b5be98086699ffdc71ab5655cfb6ab6aa" translate="yes" xml:space="preserve">
          <source>The command just returns the ID of the current connection. Every connection ID has certain guarantees:</source>
          <target state="translated">El comando sólo devuelve el ID de la conexión actual.Cada ID de conexión tiene ciertas garantías:</target>
        </trans-unit>
        <trans-unit id="1a0d0753b06a3754e2b6097d7df536fcb852c4ed" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are already associated with some node.</source>
          <target state="translated">El comando sólo funciona si todas las ranuras especificadas ya están asociadas a algún nodo.</target>
        </trans-unit>
        <trans-unit id="43abdb47aec6d5ef3beb1e76ddc4c6370f0f6354" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are, from the point of view of the node receiving the command, currently not assigned. A node will refuse to take ownership for slots that already belong to some other node (including itself).</source>
          <target state="translated">El comando sólo funciona si todos los slots especificados están,desde el punto de vista del nodo que recibe el comando,actualmente no asignados.Un nodo se negará a asumir la propiedad de los slots que ya pertenecen a otro nodo (incluido él mismo).</target>
        </trans-unit>
        <trans-unit id="63f80c4f55dda4254e917500ebea54b888f88f18" translate="yes" xml:space="preserve">
          <source>The command optionally returns additional information using the following options:</source>
          <target state="translated">El comando devuelve opcionalmente información adicional utilizando las siguientes opciones:</target>
        </trans-unit>
        <trans-unit id="11f65176db9808f7847abb3d37f52b1528a65ac2" translate="yes" xml:space="preserve">
          <source>The command performs the following actions:</source>
          <target state="translated">El comando realiza las siguientes acciones:</target>
        </trans-unit>
        <trans-unit id="4778a65d0ba749aa47da2ae16d4895853e331c48" translate="yes" xml:space="preserve">
          <source>The command provides a list of replica nodes replicating from the specified master node. The list is provided in the same format used by &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; (please refer to its documentation for the specification of the format).</source>
          <target state="translated">El comando proporciona una lista de nodos de r&amp;eacute;plica que se replican desde el nodo principal especificado. La lista se proporciona en el mismo formato utilizado por &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; (consulte su documentaci&amp;oacute;n para la especificaci&amp;oacute;n del formato).</target>
        </trans-unit>
        <trans-unit id="75946e7c075807ac0ec08889c9ae03a9a184e3d3" translate="yes" xml:space="preserve">
          <source>The command reconfigures a node as a replica of the specified master. If the node receiving the command is an &lt;em&gt;empty master&lt;/em&gt;, as a side effect of the command, the node role is changed from master to replica.</source>
          <target state="translated">El comando reconfigura un nodo como una r&amp;eacute;plica del maestro especificado. Si el nodo que recibe el comando es un &lt;em&gt;maestro vac&amp;iacute;o&lt;/em&gt; , como efecto secundario del comando, la funci&amp;oacute;n del nodo se cambia de maestro a r&amp;eacute;plica.</target>
        </trans-unit>
        <trans-unit id="4ebd54c736f27aa3986d5c357015059ce2df6b55" translate="yes" xml:space="preserve">
          <source>The command returns 11 characters Geohash strings, so no precision is loss compared to the Redis internal 52 bit representation. The returned Geohashes have the following properties:</source>
          <target state="translated">El comando devuelve cadenas Geohash de 11 caracteres,por lo que no hay pérdida de precisión en comparación con la representación interna de 52 bits de Redis.Los Geohashes devueltos tienen las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="68e0628c08bc7ef387bda65ff2fbb36117fe6040" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-1&lt;/code&gt; if the key exists but has no associated expire.</source>
          <target state="translated">El comando devuelve &lt;code&gt;-1&lt;/code&gt; si la clave existe pero no tiene una expiraci&amp;oacute;n asociada.</target>
        </trans-unit>
        <trans-unit id="9900e726bbbfd1d7f718d4225bf8abc8e591a526" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-2&lt;/code&gt; if the key does not exist.</source>
          <target state="translated">El comando devuelve &lt;code&gt;-2&lt;/code&gt; si la clave no existe.</target>
        </trans-unit>
        <trans-unit id="7cf3ff8b30b845ead44db4d82109c56f01457aed" translate="yes" xml:space="preserve">
          <source>The command returns all the messages successfully claimed, in the same format as &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;. However if the &lt;code&gt;JUSTID&lt;/code&gt; option was specified, only the message IDs are reported, without including the actual message.</source>
          <target state="translated">El comando devuelve todos los mensajes reclamados con &amp;eacute;xito, en el mismo formato que &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; . Sin embargo, si se especific&amp;oacute; la opci&amp;oacute;n &lt;code&gt;JUSTID&lt;/code&gt; , solo se informan los ID de mensaje, sin incluir el mensaje real.</target>
        </trans-unit>
        <trans-unit id="61a71cfae2a2b43a889c9e6bd259963281080b15" translate="yes" xml:space="preserve">
          <source>The command returns an array of elements. The first element is the role of the instance, as one of the following three strings:</source>
          <target state="translated">El comando devuelve un conjunto de elementos.El primer elemento es el papel de la instancia,como una de las tres cadenas siguientes:</target>
        </trans-unit>
        <trans-unit id="aa91d91e133acc78d18bba2922ce5bd5a6f7f354" translate="yes" xml:space="preserve">
          <source>The command returns an array of keys names stored in the contacted node and hashing to the specified hash slot. The maximum number of keys to return is specified via the &lt;code&gt;count&lt;/code&gt; argument, so that it is possible for the user of this API to batch-processing keys.</source>
          <target state="translated">El comando devuelve una matriz de nombres de claves almacenados en el nodo contactado y hash en la ranura de hash especificada. El n&amp;uacute;mero m&amp;aacute;ximo de claves para devolver se especifica mediante el argumento de &lt;code&gt;count&lt;/code&gt; , de modo que el usuario de esta API pueda procesar las claves por lotes.</target>
        </trans-unit>
        <trans-unit id="e6bc3ec726a066c82649799db4b402b18c37620c" translate="yes" xml:space="preserve">
          <source>The command returns an array of results: each element of the returned array is an array composed of a two element containing the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;.</source>
          <target state="translated">El comando devuelve una matriz de resultados: cada elemento de la matriz devuelta es una matriz compuesta por dos elementos que contienen el nombre de la clave y las entradas informadas para esa clave. Las entradas informadas son entradas de flujo completo, con ID y la lista de todos los campos y valores. Se garantiza que los campos y los valores se informar&amp;aacute;n en el mismo orden en que fueron agregados por &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d59bdbda1d4276c59a205bc75690c8792da83930" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command.</source>
          <target state="translated">El comando devuelve una matriz en la que cada elemento es una matriz de dos elementos que representan la longitud y la latitud (x,y)de cada nombre de miembro pasado como argumento al comando.</target>
        </trans-unit>
        <trans-unit id="299bd584711e094e5bb4f6fecbd5c79b634a792b" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is the Geohash corresponding to each member name passed as argument to the command.</source>
          <target state="translated">El comando devuelve una matriz donde cada elemento es el Geohash correspondiente a cada nombre de miembro pasado como argumento al comando.</target>
        </trans-unit>
        <trans-unit id="63618225d498ac1d95054dac445c00eb7942b4b2" translate="yes" xml:space="preserve">
          <source>The command returns an array with each entry being the corresponding result of the sub command given at the same position. &lt;code&gt;OVERFLOW&lt;/code&gt; subcommands don't count as generating a reply.</source>
          <target state="translated">El comando devuelve una matriz con cada entrada siendo el resultado correspondiente del subcomando dado en la misma posici&amp;oacute;n. &lt;code&gt;OVERFLOW&lt;/code&gt; subcomandos OVERFLOW no cuentan como generar una respuesta.</target>
        </trans-unit>
        <trans-unit id="599682f8e696ffcef9a41f128a35f008ec692b72" translate="yes" xml:space="preserve">
          <source>The command returns data in different format depending on the way it is called, as previously explained in this page. However the reply is always an array of items.</source>
          <target state="translated">El comando devuelve los datos en un formato diferente dependiendo de la forma en que se llame,como se explicó anteriormente en esta página.Sin embargo,la respuesta es siempre un conjunto de elementos.</target>
        </trans-unit>
        <trans-unit id="64555ea6ac3dd842f32e77db3528c6314f55ca4d" translate="yes" xml:space="preserve">
          <source>The command returns data in the same format as &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;.</source>
          <target state="translated">El comando devuelve datos en el mismo formato que &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="854de1e7ab31a436fe3503c72376101ec2883922" translate="yes" xml:space="preserve">
          <source>The command returns the ID of the added entry. The ID is the one auto-generated if &lt;code&gt;*&lt;/code&gt; is passed as ID argument, otherwise the command just returns the same ID specified by the user during insertion.</source>
          <target state="translated">El comando devuelve el ID de la entrada agregada. El ID es el que se genera autom&amp;aacute;ticamente si se pasa &lt;code&gt;*&lt;/code&gt; como argumento de ID; de lo contrario, el comando simplemente devuelve el mismo ID especificado por el usuario durante la inserci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7247b723aad05766caad65ebc7ede74ba6d1e1dd" translate="yes" xml:space="preserve">
          <source>The command returns the distance as a double (represented as a string) in the specified unit, or NULL if one or both the elements are missing.</source>
          <target state="translated">El comando devuelve la distancia como un doble (representado como una cadena)en la unidad especificada,o NULL si falta uno o ambos elementos.</target>
        </trans-unit>
        <trans-unit id="a226a6dbee33f1a9bdf015f4eb2291dd60f7022b" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range, from the higher ID to the lower ID matching. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">El comando devuelve las entradas con ID que coinciden con el rango especificado, desde el ID m&amp;aacute;s alto hasta el ID m&amp;aacute;s bajo. Las entradas devueltas est&amp;aacute;n completas, eso significa que se devuelve el ID y todos los campos que est&amp;aacute;n compuestos. Adem&amp;aacute;s, las entradas se devuelven con sus campos y valores exactamente en el mismo orden en que las agreg&amp;oacute; &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="444f426015abc65778606f24926eb62888ddcfbe" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover, the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">El comando devuelve las entradas con ID que coinciden con el rango especificado. Las entradas devueltas est&amp;aacute;n completas, eso significa que se devuelve el ID y todos los campos que est&amp;aacute;n compuestos. Adem&amp;aacute;s, las entradas se devuelven con sus campos y valores exactamente en el mismo orden en que las agreg&amp;oacute; &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25a3d21f3dbcaa198bbe343d23738bbd28a872e1" translate="yes" xml:space="preserve">
          <source>The command returns the number of &lt;em&gt;failure reports&lt;/em&gt; for the specified node. Failure reports are the way Redis Cluster uses in order to promote a &lt;code&gt;PFAIL&lt;/code&gt; state, that means a node is not reachable, to a &lt;code&gt;FAIL&lt;/code&gt; state, that means that the majority of masters in the cluster agreed within a window of time that the node is not reachable.</source>
          <target state="translated">El comando devuelve el n&amp;uacute;mero de &lt;em&gt;informes&lt;/em&gt; de &lt;em&gt;fallas&lt;/em&gt; para el nodo especificado. Los informes de fallas son la forma en que Redis Cluster usa para promover un estado &lt;code&gt;PFAIL&lt;/code&gt; , es decir, un nodo no es accesible, a un estado &lt;code&gt;FAIL&lt;/code&gt; , eso significa que la mayor&amp;iacute;a de los maestros en el cl&amp;uacute;ster acordaron dentro de una ventana de tiempo que el nodo no est&amp;aacute; accesible.</target>
        </trans-unit>
        <trans-unit id="11d6963d3c757dd171e4446f81aa6fbb2b4f3cbe" translate="yes" xml:space="preserve">
          <source>The command returns the number of entries deleted from the stream.</source>
          <target state="translated">El comando devuelve el número de entradas borradas de la corriente.</target>
        </trans-unit>
        <trans-unit id="90a0913f53aff4fc9a2c5f477057692b16cb61c2" translate="yes" xml:space="preserve">
          <source>The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have been already acknowledge), and XACK will not count them as successfully acknowledged.</source>
          <target state="translated">El comando devuelve el número de mensajes reconocidos con éxito.Ciertos ID de mensajes pueden no formar parte del PEL (por ejemplo porque ya han sido reconocidos),y XACK no los contará como reconocidos con éxito.</target>
        </trans-unit>
        <trans-unit id="25862d0137651f4c50c642c84cec4c703a39cc67" translate="yes" xml:space="preserve">
          <source>The command returns the position of the first bit set to 1 or 0 according to the request.</source>
          <target state="translated">El comando devuelve la posición del primer bit a 1 o 0 según la petición.</target>
        </trans-unit>
        <trans-unit id="0f2fe335e56363e46ba8079d81809ab997be12eb" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entires having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="translated">El comando devuelve las entradas de la corriente que coinciden con un rango determinado de identificaciones.El rango se especifica con un ID mínimo y máximo.Se devuelven todos los enteros que tengan un ID entre los dos especificados o exactamente uno de los dos ID especificados (intervalo cerrado).</target>
        </trans-unit>
        <trans-unit id="26b22d366f18019ba16fe8b5883618685376f0fb" translate="yes" xml:space="preserve">
          <source>The command takes arguments in the standard format x,y so the longitude must be specified before the latitude. There are limits to the coordinates that can be indexed: areas very near to the poles are not indexable. The exact limits, as specified by EPSG:900913 / EPSG:3785 / OSGEO:41001 are the following:</source>
          <target state="translated">El comando toma los argumentos en el formato estándar x,y por lo que la longitud debe ser especificada antes que la latitud.Hay límites a las coordenadas que pueden ser indexadas:las áreas muy cercanas a los polos no son indexables.Los límites exactos,como se especifica en EPSG:900913/EPSG:3785/OSGEO:41001 son los siguientes:</target>
        </trans-unit>
        <trans-unit id="69e46f6ba0a5d03f8dc0e5aa7af7b003d2e71820" translate="yes" xml:space="preserve">
          <source>The command treats a Redis string as a array of bits, and is capable of addressing specific integer fields of varying bit widths and arbitrary non (necessary) aligned offset. In practical terms using this command you can set, for example, a signed 5 bits integer at bit offset 1234 to a specific value, retrieve a 31 bit unsigned integer from offset 4567. Similarly the command handles increments and decrements of the specified integers, providing guaranteed and well specified overflow and underflow behavior that the user can configure.</source>
          <target state="translated">El comando trata una cadena de Redis como un conjunto de bits,y es capaz de abordar campos enteros específicos de anchos de bits variables y desplazamientos arbitrarios no alineados (necesarios).En términos prácticos,utilizando este comando se puede establecer,por ejemplo,un entero de 5 bits con signo en el offset de bits 1234 a un valor específico,recuperar un entero de 31 bits sin signo del offset 4567.De manera similar,el comando maneja incrementos y decrementos de los enteros especificados,proporcionando un comportamiento de desbordamiento y subdesbordamiento garantizado y bien especificado que el usuario puede configurar.</target>
        </trans-unit>
        <trans-unit id="13c5fae6e8ea2d19068840627307808e57ed434f" translate="yes" xml:space="preserve">
          <source>The command will fail if the specified node is not known or if it is not a master according to the node table of the node receiving the command.</source>
          <target state="translated">El comando fallará si no se conoce el nodo especificado o si no es un maestro según la tabla de nodos del nodo que recibe el comando.</target>
        </trans-unit>
        <trans-unit id="83094ac4a33e4188f42d4a2c20d7dbf3f6620df3" translate="yes" xml:space="preserve">
          <source>The command will report an error when the user attempts to index coordinates outside the specified ranges.</source>
          <target state="translated">El comando informará de un error cuando el usuario intente indexar las coordenadas fuera de los rangos especificados.</target>
        </trans-unit>
        <trans-unit id="7a427adc7c29c84562496f4e3dd746f3b4883cbf" translate="yes" xml:space="preserve">
          <source>The command with its set of subcommands is useful in order to start and end cluster live resharding operations, which are accomplished by setting a hash slot in migrating state in the source node, and importing state in the destination node.</source>
          <target state="translated">El comando con su conjunto de subcomandos es útil para iniciar y finalizar las operaciones de reordenación en vivo del grupo,que se logran estableciendo una ranura de hachís en estado de migración en el nodo de origen,y estado de importación en el nodo de destino.</target>
        </trans-unit>
        <trans-unit id="f34a45ceabab28f1008f0f9d2405fbba32c8e338" translate="yes" xml:space="preserve">
          <source>The command works in the same way even if the script was already present in the script cache.</source>
          <target state="translated">El comando funciona de la misma manera incluso si el guión ya estaba presente en la caché del guión.</target>
        </trans-unit>
        <trans-unit id="58212b0000147d5bba3264e4996ad46fd286b905" translate="yes" xml:space="preserve">
          <source>The common use case for this command is to retrieve geospatial items near a specified point not farther than a given amount of meters (or other units). This allows, for example, to suggest mobile users of an application nearby places.</source>
          <target state="translated">El caso de uso común de este comando es recuperar elementos geoespaciales cerca de un punto específico no más allá de una cantidad dada de metros (u otras unidades).Esto permite,por ejemplo,sugerir a los usuarios móviles de una aplicación los lugares cercanos.</target>
        </trans-unit>
        <trans-unit id="83d84f2e6d0bc285dccf475994bf2dfe5a7034d1" translate="yes" xml:space="preserve">
          <source>The computed merged HyperLogLog is set to the destination variable, which is created if does not exist (defaulting to an empty HyperLogLog).</source>
          <target state="translated">El HyperLogLog fusionado computarizado se establece en la variable de destino,que se crea si no existe (por defecto,un HyperLogLog vacío).</target>
        </trans-unit>
        <trans-unit id="892b6264b392f8ad48dfbfcfe6dff8a94a45c598" translate="yes" xml:space="preserve">
          <source>The configuration can be done by editing &lt;code&gt;redis.conf&lt;/code&gt; or while the server is running using the &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; and &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; commands.</source>
          <target state="translated">La configuraci&amp;oacute;n se puede realizar editando &lt;code&gt;redis.conf&lt;/code&gt; o mientras el servidor se est&amp;aacute; ejecutando usando los comandos &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; y &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9924fa1c31458da66b46121ed81593fd5a4fbad" translate="yes" xml:space="preserve">
          <source>The connection name can be inspected using &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt;.</source>
          <target state="translated">El nombre de la conexi&amp;oacute;n se puede inspeccionar utilizando &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6da99886277806746e8e984d617153310b22b176" translate="yes" xml:space="preserve">
          <source>The connection we have with the server is persistent and was never closed so far.</source>
          <target state="translated">La conexión que tenemos con el servidor es persistente y nunca se ha cerrado hasta ahora.</target>
        </trans-unit>
        <trans-unit id="812045821e03fcc1f9ffc04b5ef35de3b612856e" translate="yes" xml:space="preserve">
          <source>The consumer group will be destroyed even if there are active consumers and pending messages, so make sure to call this command only when really needed.</source>
          <target state="translated">El grupo de consumidores será destruido incluso si hay consumidores activos y mensajes pendientes,así que asegúrate de llamar a este comando sólo cuando sea realmente necesario.</target>
        </trans-unit>
        <trans-unit id="8d4c2cd743047005cdb993a3a9d7afc356bb6664" translate="yes" xml:space="preserve">
          <source>The consumer will do:</source>
          <target state="translated">El consumidor lo hará:</target>
        </trans-unit>
        <trans-unit id="a09ada6e198e1cc27a58e1c5cd2063765d34a60e" translate="yes" xml:space="preserve">
          <source>The coordinates as a two items x,y array (longitude,latitude).</source>
          <target state="translated">Las coordenadas como una matriz de dos elementos x,y (longitud,latitud).</target>
        </trans-unit>
        <trans-unit id="d6f85adf1bad41bef7242defbfacbfdea663e0f0" translate="yes" xml:space="preserve">
          <source>The counter is created in a way that it only will survive one second, starting from the first request performed in the current second. If there are more than 10 requests in the same second the counter will reach a value greater than 10, otherwise it will expire and start again from 0.</source>
          <target state="translated">El contador se crea de manera que sólo sobrevivirá un segundo,a partir de la primera petición realizada en el segundo actual.Si hay más de 10 peticiones en el mismo segundo,el contador alcanzará un valor superior a 10,de lo contrario expirará y volverá a empezar desde 0.</target>
        </trans-unit>
        <trans-unit id="224e5c836dc00eb5744ec82792c094203a16fc27" translate="yes" xml:space="preserve">
          <source>The counter pattern is the most obvious thing you can do with Redis atomic increment operations. The idea is simply send an &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; command to Redis every time an operation occurs. For instance in a web application we may want to know how many page views this user did every day of the year.</source>
          <target state="translated">El patr&amp;oacute;n de contador es lo m&amp;aacute;s obvio que puede hacer con las operaciones de incremento at&amp;oacute;mico de Redis. La idea es simplemente enviar un comando &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; a Redis cada vez que ocurra una operaci&amp;oacute;n. Por ejemplo, en una aplicaci&amp;oacute;n web, es posible que deseemos saber cu&amp;aacute;ntas visitas a la p&amp;aacute;gina hizo este usuario todos los d&amp;iacute;as del a&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="b77e139112433671a542addfa1a32daf47ee322d" translate="yes" xml:space="preserve">
          <source>The crashed client C3 still holds it, so Redis will reply with &lt;code&gt;0&lt;/code&gt; to C4.</source>
          <target state="translated">El cliente bloqueado C3 todav&amp;iacute;a lo retiene, por lo que Redis responder&amp;aacute; con &lt;code&gt;0&lt;/code&gt; a C4.</target>
        </trans-unit>
        <trans-unit id="8423b58d7e3aaab1a157d34537088cf7071837ad" translate="yes" xml:space="preserve">
          <source>The current field content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">El contenido del campo actual o el incremento especificado no son parsables como un número de punto flotante de doble precisión.</target>
        </trans-unit>
        <trans-unit id="838fa5216f1f1cdff3694527a8a6d1c1f9f94411" translate="yes" xml:space="preserve">
          <source>The current key content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">El contenido clave actual o el incremento especificado no son parsables como un número de punto flotante de doble precisión.</target>
        </trans-unit>
        <trans-unit id="931ea7e75c2dded718677c9f4a1676825fcb3baa" translate="yes" xml:space="preserve">
          <source>The current master replication offset, which is an offset that masters and replicas share to understand, in partial resynchronizations, the part of the replication stream the replicas needs to fetch to continue.</source>
          <target state="translated">El actual offset de la réplica maestra,que es un offset que los maestros y las réplicas comparten para entender,en resincronizaciones parciales,la parte del flujo de replicación que las réplicas deben buscar para continuar.</target>
        </trans-unit>
        <trans-unit id="b7064688c0f4d788a94324f8ce3624a598ba7058" translate="yes" xml:space="preserve">
          <source>The current score of an element can be retrieved using the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command, that can also be used to verify if an element already exists or not.</source>
          <target state="translated">La puntuaci&amp;oacute;n actual de un elemento se puede recuperar mediante el comando &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; , que tambi&amp;eacute;n se puede utilizar para verificar si un elemento ya existe o no.</target>
        </trans-unit>
        <trans-unit id="30d1eb14ec245a20077a7d25213dc588a8512c5c" translate="yes" xml:space="preserve">
          <source>The cursor returned by the previous call to SCAN in order to continue the iteration.</source>
          <target state="translated">El cursor regresó por la llamada anterior a SCAN para continuar la iteración.</target>
        </trans-unit>
        <trans-unit id="219c36e5291d2c3051ee7cf69aa75399bb2fc52c" translate="yes" xml:space="preserve">
          <source>The cursor value of 0 when starting an iteration.</source>
          <target state="translated">El valor del cursor de 0 al iniciar una iteración.</target>
        </trans-unit>
        <trans-unit id="93cb8fd7598a4e9c87b91141380a4bde0e9f7ad1" translate="yes" xml:space="preserve">
          <source>The default COUNT value is 10.</source>
          <target state="translated">El valor por defecto de COUNT es 10.</target>
        </trans-unit>
        <trans-unit id="1472348f89b9c094e365f856bf74ca11dcb1cdde" translate="yes" xml:space="preserve">
          <source>The deliveries counter, that is the fourth element in the array, is incremented when some other consumer &lt;em&gt;claims&lt;/em&gt; the message with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;, or when the message is delivered again via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, when accessing the history of a consumer in a consumer group (see the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; page for more info).</source>
          <target state="translated">El contador de entregas, que es el cuarto elemento de la matriz, se incrementa cuando alg&amp;uacute;n otro consumidor &lt;em&gt;reclama&lt;/em&gt; el mensaje con &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; , o cuando el mensaje se env&amp;iacute;a de nuevo a trav&amp;eacute;s de &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; , al acceder al historial de un consumidor en un grupo de consumidores (ver el &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; p&amp;aacute;gina para obtener m&amp;aacute;s informaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="c29b8b8f823cca94ef6ad774fed42578a146e94a" translate="yes" xml:space="preserve">
          <source>The difference between this command and the vanilla &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is that this one supports consumer groups.</source>
          <target state="translated">La diferencia entre este comando y el vanilla &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; es que este admite grupos de consumidores.</target>
        </trans-unit>
        <trans-unit id="3c1c5811c1d1a274026dcc95a504bdc2dd6d5a09" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the radius.</source>
          <target state="translated">La distancia desde el centro como un número de punto flotante,en la misma unidad especificada en el radio.</target>
        </trans-unit>
        <trans-unit id="3afe599a4181bcd5a732c0ec177cb011be65df41" translate="yes" xml:space="preserve">
          <source>The distance is computed assuming that the Earth is a perfect sphere, so errors up to 0.5% are possible in edge cases.</source>
          <target state="translated">La distancia se calcula asumiendo que la Tierra es una esfera perfecta,por lo que es posible que haya errores de hasta el 0,5% en los casos de borde.</target>
        </trans-unit>
        <trans-unit id="a8be9ff0b07a549071a611002c4a08732b5c80a8" translate="yes" xml:space="preserve">
          <source>The distribution of the returned elements is far from perfect when the number of elements in the set is small, this is due to the fact that we used an approximated random element function that does not really guarantees good distribution.</source>
          <target state="translated">La distribución de los elementos devueltos está lejos de ser perfecta cuando el número de elementos en el conjunto es pequeño,esto se debe al hecho de que utilizamos una función de elementos aleatorios aproximados que no garantiza realmente una buena distribución.</target>
        </trans-unit>
        <trans-unit id="e2451d0313184cb7cb1bfd5f5707106d6b571329" translate="yes" xml:space="preserve">
          <source>The elements are considered to be ordered from lower to higher strings as compared byte-by-byte using the &lt;code&gt;memcmp()&lt;/code&gt; C function. Longer strings are considered greater than shorter strings if the common part is identical.</source>
          <target state="translated">Se considera que los elementos est&amp;aacute;n ordenados de cadenas inferiores a superiores en comparaci&amp;oacute;n byte a byte utilizando la funci&amp;oacute;n &lt;code&gt;memcmp()&lt;/code&gt; C. Las cadenas m&amp;aacute;s largas se consideran mayores que las cadenas m&amp;aacute;s cortas si la parte com&amp;uacute;n es id&amp;eacute;ntica.</target>
        </trans-unit>
        <trans-unit id="7dd12a75b48ac332a2dfe23f1549d87b855bfd6d" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in lexicographical order (this follows from a property of the sorted set implementation in Redis and does not involve further computation).</source>
          <target state="translated">Los elementos que tienen la misma puntuación se devuelven en orden lexicográfico (esto se desprende de una propiedad de la implementación del conjunto ordenado en Redis y no implica un cálculo posterior).</target>
        </trans-unit>
        <trans-unit id="12d2f968d07516f9654dcc50b588d898c0361273" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in reverse lexicographical order.</source>
          <target state="translated">Los elementos que tienen la misma puntuación se devuelven en orden lexicográfico inverso.</target>
        </trans-unit>
        <trans-unit id="8a7336e9649584aeb5dd7541a2422de663fa783e" translate="yes" xml:space="preserve">
          <source>The entry's unique ID can be used in order to avoid processing slow log entries multiple times (for instance you may have a script sending you an email alert for every new slow log entry).</source>
          <target state="translated">La identificación única de la entrada puede utilizarse para evitar el procesamiento de entradas de registro lento varias veces (por ejemplo,puede tener un guión que le envíe una alerta de correo electrónico por cada nueva entrada de registro lento).</target>
        </trans-unit>
        <trans-unit id="4c3c6b922261a4a3c02503cd2200bbc2e1969187" translate="yes" xml:space="preserve">
          <source>The exact behavior of this command is identical to the one of the &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; command, please refer to the documentation of &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; for further information.</source>
          <target state="translated">El comportamiento exacto de este comando es id&amp;eacute;ntico al del comando &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; , consulte la documentaci&amp;oacute;n de &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="81ef5cb9ba6108b82ece4143c01d73481b4f607e" translate="yes" xml:space="preserve">
          <source>The fact that the user can count on Redis not removing scripts is semantically useful in the context of pipelining.</source>
          <target state="translated">El hecho de que el usuario pueda contar con que Redis no elimine los guiones es semánticamente útil en el contexto de la canalización.</target>
        </trans-unit>
        <trans-unit id="ccad1b83c48c6dc04cc17404f3912c32d936c720" translate="yes" xml:space="preserve">
          <source>The field contains a value of the wrong type (not a string).</source>
          <target state="translated">El campo contiene un valor del tipo equivocado (no una cadena).</target>
        </trans-unit>
        <trans-unit id="6058628e04e98718045db43e11d253a6db12f594" translate="yes" xml:space="preserve">
          <source>The file descriptor events can be:</source>
          <target state="translated">Los eventos del descriptor del archivo pueden ser:</target>
        </trans-unit>
        <trans-unit id="d4261d3e5eb2c06f28ad9faa68309fdf262f21cb" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is a Lua 5.1 script. The script does not need to define a Lua function (and should not). It is just a Lua program that will run in the context of the Redis server.</source>
          <target state="translated">El primer argumento de &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; es un script Lua 5.1. El script no necesita definir una funci&amp;oacute;n Lua (y no deber&amp;iacute;a). Es solo un programa Lua que se ejecutar&amp;aacute; en el contexto del servidor Redis.</target>
        </trans-unit>
        <trans-unit id="8cbda77e6bd32de6a17a5ed2d8395d40439856eb" translate="yes" xml:space="preserve">
          <source>The following are a few examples of importing and migrating slots:</source>
          <target state="translated">A continuación se presentan algunos ejemplos de ranuras de importación y migración:</target>
        </trans-unit>
        <trans-unit id="3b94aea73b4255f0bc659c9805b5380b0565b107" translate="yes" xml:space="preserve">
          <source>The following command removes the association for slots 5000 and 5001 from the node receiving the command:</source>
          <target state="translated">El siguiente comando elimina la asociación para las ranuras 5000 y 5001 del nodo que recibe el comando:</target>
        </trans-unit>
        <trans-unit id="00075a28fdc9ff572c3eac87bcaf7c44d932e7da" translate="yes" xml:space="preserve">
          <source>The following example should clarify what stated above:</source>
          <target state="translated">El siguiente ejemplo debería aclarar lo que se ha dicho anteriormente:</target>
        </trans-unit>
        <trans-unit id="1ec034b27145454749448bb4c66e40315aa13e2f" translate="yes" xml:space="preserve">
          <source>The following example using &lt;code&gt;WITHSCORES&lt;/code&gt; shows how the command returns always an array, but this time, populated with &lt;em&gt;element_1&lt;/em&gt;, &lt;em&gt;score_1&lt;/em&gt;, &lt;em&gt;element_2&lt;/em&gt;, &lt;em&gt;score_2&lt;/em&gt;, ..., &lt;em&gt;element_N&lt;/em&gt;, &lt;em&gt;score_N&lt;/em&gt;.</source>
          <target state="translated">El siguiente ejemplo usando &lt;code&gt;WITHSCORES&lt;/code&gt; muestra c&amp;oacute;mo el comando siempre devuelve una matriz, pero esta vez, poblada con &lt;em&gt;element_1&lt;/em&gt; , &lt;em&gt;score_1&lt;/em&gt; , &lt;em&gt;element_2&lt;/em&gt; , &lt;em&gt;score_2&lt;/em&gt; , ..., &lt;em&gt;element_N&lt;/em&gt; , &lt;em&gt;score_N&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69face26cb0b6283ed9eddef9110c599dd9ae6eb" translate="yes" xml:space="preserve">
          <source>The following field is always provided:</source>
          <target state="translated">Siempre se proporciona el siguiente campo:</target>
        </trans-unit>
        <trans-unit id="5fede26fc672e9d5137b89bc60a98de02e5d6528" translate="yes" xml:space="preserve">
          <source>The following is an example of &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; returning NULL.</source>
          <target state="translated">El siguiente es un ejemplo de &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; que devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="f26894ffa2e5bfa52e8acebe022822e6a159ac5d" translate="yes" xml:space="preserve">
          <source>The following is the list of supported commands.</source>
          <target state="translated">La siguiente es la lista de comandos soportados.</target>
        </trans-unit>
        <trans-unit id="487db5ff0187b77e2cfe37d8572892092c01e33a" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">Se desaconseja el siguiente patr&amp;oacute;n en favor del &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;algoritmo Redlock,&lt;/a&gt; que es solo un poco m&amp;aacute;s complejo de implementar, pero ofrece mejores garant&amp;iacute;as y es tolerante a fallas.</target>
        </trans-unit>
        <trans-unit id="685c86199b8431155924b73d00e71167faabb72e" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">El formulario &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NADIE detendr&amp;aacute; la replicaci&amp;oacute;n, convirtiendo el servidor en un MASTER, pero no descartar&amp;aacute; la replicaci&amp;oacute;n. Entonces, si el antiguo maestro deja de funcionar, es posible convertir la r&amp;eacute;plica en un maestro y configurar la aplicaci&amp;oacute;n para usar este nuevo maestro en lectura / escritura. M&amp;aacute;s tarde, cuando el otro servidor de Redis est&amp;eacute; reparado, se puede volver a configurar para que funcione como una r&amp;eacute;plica.</target>
        </trans-unit>
        <trans-unit id="2a758769f42fa16fd49a6c65e260a443efa58858" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">El formulario &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NADIE detendr&amp;aacute; la replicaci&amp;oacute;n, convirtiendo el servidor en un MASTER, pero no descartar&amp;aacute; la replicaci&amp;oacute;n. Entonces, si el antiguo maestro deja de funcionar, es posible convertir la r&amp;eacute;plica en un maestro y configurar la aplicaci&amp;oacute;n para usar este nuevo maestro en lectura / escritura. M&amp;aacute;s tarde, cuando el otro servidor de Redis est&amp;eacute; reparado, se puede volver a configurar para que funcione como una r&amp;eacute;plica.</target>
        </trans-unit>
        <trans-unit id="cfb81787e75be423c5bbd1da337f47a738269c3b" translate="yes" xml:space="preserve">
          <source>The function handles out of range requests by limiting the resulting range to the actual length of the string.</source>
          <target state="translated">La función maneja las solicitudes fuera de rango limitando el rango resultante a la longitud real de la cadena.</target>
        </trans-unit>
        <trans-unit id="bae822e06654577340df39aec8c279a41923dbdf" translate="yes" xml:space="preserve">
          <source>The function returns true if the script effects replication was enabled, otherwise if the function was called after the script already called some write command, it returns false, and normal whole script replication is used.</source>
          <target state="translated">La función devuelve true si se habilitó la replicación de efectos de guión,de lo contrario,si la función fue llamada después de que el guión ya llamó algún comando de escritura,devuelve false,y se utiliza la replicación normal de todo el guión.</target>
        </trans-unit>
        <trans-unit id="e3d352c9158e45827d58fa0bb1daa62cb827202a" translate="yes" xml:space="preserve">
          <source>The geohash integer.</source>
          <target state="translated">El entero geohash.</target>
        </trans-unit>
        <trans-unit id="1802968f15db7e03ec0c89118a7963b7fbc9d55a" translate="yes" xml:space="preserve">
          <source>The group name is just the name of a consumer group associated to the stream. The group is created using the &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; command. The consumer name is the string that is used by the client to identify itself inside the group. The consumer is auto created inside the consumer group the first time it is saw. Different clients should select a different consumer name.</source>
          <target state="translated">El nombre del grupo es solo el nombre de un grupo de consumidores asociado a la transmisi&amp;oacute;n. El grupo se crea mediante el comando &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; . El nombre del consumidor es la cadena que utiliza el cliente para identificarse dentro del grupo. El consumidor se crea autom&amp;aacute;ticamente dentro del grupo de consumidores la primera vez que se ve. Los diferentes clientes deben seleccionar un nombre de consumidor diferente.</target>
        </trans-unit>
        <trans-unit id="5dfb24eb9709d7c83208076fd77b0d419da27db0" translate="yes" xml:space="preserve">
          <source>The information about memory usage is provided as metrics and their respective values. The following metrics are reported:</source>
          <target state="translated">La información sobre el uso de la memoria se proporciona como métrica y sus respectivos valores.Se informa de las siguientes métricas:</target>
        </trans-unit>
        <trans-unit id="34a2e40e15b32f6149b206a299f7840113d10818" translate="yes" xml:space="preserve">
          <source>The key contains a value of the wrong type (not a string).</source>
          <target state="translated">La clave contiene un valor del tipo equivocado (no una cadena).</target>
        </trans-unit>
        <trans-unit id="09d97b8e7dc4c8276b96f5602bc74dea1d0e36c5" translate="yes" xml:space="preserve">
          <source>The key may be on both the instances.</source>
          <target state="translated">La clave puede estar en ambas instancias.</target>
        </trans-unit>
        <trans-unit id="317c7c0e8fc5ce228ab50cadfc186268268a73ba" translate="yes" xml:space="preserve">
          <source>The key may be only in the source instance.</source>
          <target state="translated">La clave puede estar sólo en el caso de la fuente.</target>
        </trans-unit>
        <trans-unit id="770d7559e7b2fdc7128e6105d19ea9ca36a0376e" translate="yes" xml:space="preserve">
          <source>The key time to live can be updated or entirely removed using the &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; and &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command (or other strictly related commands).</source>
          <target state="translated">El momento clave para vivo se puede actualizar o totalmente eliminado mediante el &lt;a href=&quot;expire&quot;&gt;EXPIRA&lt;/a&gt; y &lt;a href=&quot;persist&quot;&gt;persisten&lt;/a&gt; comando (u otros comandos estrictamente relacionados).</target>
        </trans-unit>
        <trans-unit id="547c694280239130253479a419ced5c053003ea8" translate="yes" xml:space="preserve">
          <source>The last ID returned is &lt;code&gt;1526985712947-0&lt;/code&gt;, since the sequence number is already zero, the next ID I'll use instead of the &lt;code&gt;+&lt;/code&gt; special ID will be &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt;, or just &lt;code&gt;18446744073709551615&lt;/code&gt;:</source>
          <target state="translated">El &amp;uacute;ltimo ID devuelto es &lt;code&gt;1526985712947-0&lt;/code&gt; , dado que el n&amp;uacute;mero de secuencia ya es cero, el siguiente ID que &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt; lugar del &lt;code&gt;+&lt;/code&gt; ID especial ser&amp;aacute; 1526985712946-18446744073709551615 , o solo &lt;code&gt;18446744073709551615&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="11471f50fbf81f6258a27201c930e977959ad0cd" translate="yes" xml:space="preserve">
          <source>The last argument is the ID of the last item in the stream to consider already delivered. In the above case we used the special ID '$' (that means: the ID of the last item in the stream). In this case the consumers fetching data from that consumer group will only see new elements arriving in the stream.</source>
          <target state="translated">El último argumento es la identificación del último artículo de la corriente a considerar ya entregado.En el caso anterior utilizamos el ID especial &quot;$&quot; (que significa:el ID del último artículo en el flujo).En este caso,los consumidores que obtengan datos de ese grupo de consumidores sólo verán los nuevos elementos que lleguen a la corriente.</target>
        </trans-unit>
        <trans-unit id="42e7923c299c01e54ed6170cd5e8fc34b5599898" translate="yes" xml:space="preserve">
          <source>The last example shows how it is possible to receive the exact return value of &lt;code&gt;redis.call()&lt;/code&gt; or &lt;code&gt;redis.pcall()&lt;/code&gt; from Lua that would be returned if the command was called directly.</source>
          <target state="translated">El &amp;uacute;ltimo ejemplo muestra c&amp;oacute;mo es posible recibir el valor de retorno exacto de &lt;code&gt;redis.call()&lt;/code&gt; o &lt;code&gt;redis.pcall()&lt;/code&gt; de Lua que se devolver&amp;iacute;a si el comando fuera llamado directamente.</target>
        </trans-unit>
        <trans-unit id="898edad6fe267446764a3f01813e23c34e6a4dc9" translate="yes" xml:space="preserve">
          <source>The lexicographic ordering used is binary, it compares strings as array of bytes.</source>
          <target state="translated">El orden lexicográfico utilizado es binario,compara las cadenas como un conjunto de bytes.</target>
        </trans-unit>
        <trans-unit id="e89335ad1d56e8f847f0e52f7c837e0cf165daeb" translate="yes" xml:space="preserve">
          <source>The limitation of this pattern is that we are forced into an append-only mode of operation, there is no way to cut the time series to a given size easily because Redis currently lacks a command able to trim string objects. However the space efficiency of time series stored in this way is remarkable.</source>
          <target state="translated">La limitación de este patrón es que estamos forzados a un modo de operación de sólo aplicación,no hay manera de cortar las series temporales a un tamaño determinado fácilmente porque Redis actualmente carece de un comando capaz de recortar objetos de cuerda.Sin embargo,la eficiencia espacial de las series temporales almacenadas de esta manera es notable.</target>
        </trans-unit>
        <trans-unit id="da33cd971f0747462e42ccd2282a1e6fb83aa7be" translate="yes" xml:space="preserve">
          <source>The list of configuration parameters supported by &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; can be obtained issuing a &lt;code&gt;CONFIG GET *&lt;/code&gt; command, that is the symmetrical command used to obtain information about the configuration of a running Redis instance.</source>
          <target state="translated">La lista de par&amp;aacute;metros de configuraci&amp;oacute;n admitidos por &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; se puede obtener emitiendo un comando &lt;code&gt;CONFIG GET *&lt;/code&gt; , que es el comando sim&amp;eacute;trico utilizado para obtener informaci&amp;oacute;n sobre la configuraci&amp;oacute;n de una instancia de Redis en ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8095634a38168f2c281c9616bbb338721d7efd28" translate="yes" xml:space="preserve">
          <source>The lock will be auto-released after the expire time is reached.</source>
          <target state="translated">La cerradura se liberará automáticamente después de que se alcance el tiempo de caducidad.</target>
        </trans-unit>
        <trans-unit id="08a7894ad23c8503b151cc8bfa325bf87f080cfd" translate="yes" xml:space="preserve">
          <source>The main drawback with the &lt;em&gt;whole scripts replication&lt;/em&gt; approach is that scripts are required to have the following property:</source>
          <target state="translated">El principal inconveniente con el enfoque de &lt;em&gt;replicaci&amp;oacute;n de scripts completos&lt;/em&gt; es que se requiere que los scripts tengan la siguiente propiedad:</target>
        </trans-unit>
        <trans-unit id="7e2e2adfa0c27b3c4fcd6715d167f77cf7aab615" translate="yes" xml:space="preserve">
          <source>The main usage of this command is during rehashing of cluster slots from one node to another. The way the rehashing is performed is exposed in the Redis Cluster specification, or in a more simple to digest form, as an appendix of the &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command documentation.</source>
          <target state="translated">El uso principal de este comando es durante la repetici&amp;oacute;n de ranuras de cl&amp;uacute;ster de un nodo a otro. La forma en que se realiza el refrito se expone en la especificaci&amp;oacute;n de Redis Cluster, o en una forma m&amp;aacute;s simple de resumir, como un ap&amp;eacute;ndice de la documentaci&amp;oacute;n del comando &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51aa615de4288430f4f542dd741b0be9823a9984" translate="yes" xml:space="preserve">
          <source>The master output is composed of the following parts:</source>
          <target state="translated">La salida maestra se compone de las siguientes partes:</target>
        </trans-unit>
        <trans-unit id="9294413196a1d66d0e89a267022407a00ed67b4f" translate="yes" xml:space="preserve">
          <source>The master replies to the replica with the current &lt;em&gt;replication offset&lt;/em&gt;.</source>
          <target state="translated">El maestro responde a la r&amp;eacute;plica con el &lt;em&gt;desplazamiento de r&amp;eacute;plica&lt;/em&gt; actual .</target>
        </trans-unit>
        <trans-unit id="9aa0f4e849bf549de77dfa2bc7bf7ffcfaf99bf4" translate="yes" xml:space="preserve">
          <source>The meaning of &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are the same of the &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; command. Similarly, this command actually returns the same elements that &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; would return if called with the same &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments.</source>
          <target state="translated">El significado de &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; es el mismo que el del comando &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; . De manera similar, este comando en realidad devuelve los mismos elementos que &lt;a href=&quot;zrangebylex&quot;&gt;devolver&amp;iacute;a ZRANGEBYLEX&lt;/a&gt; si se llamara con los mismos argumentos &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e23ac08d91ce30fa5d8f4e6bbb8d1a66fed8600" translate="yes" xml:space="preserve">
          <source>The meaning of each filed is the following:</source>
          <target state="translated">El significado de cada archivo es el siguiente:</target>
        </trans-unit>
        <trans-unit id="69174101963d6daf8e0c498390ca52d478774c02" translate="yes" xml:space="preserve">
          <source>The meaning of the two states is explained in the Redis Specification, however the gist of the two states is the following:</source>
          <target state="translated">El significado de los dos estados se explica en la Especificación de Redis,sin embargo la esencia de los dos estados es la siguiente:</target>
        </trans-unit>
        <trans-unit id="5fe7d63b1ebc573c80de8db8907af87f4669998b" translate="yes" xml:space="preserve">
          <source>The more simple and direct implementation of this pattern is the following:</source>
          <target state="translated">La aplicación más simple y directa de este patrón es la siguiente:</target>
        </trans-unit>
        <trans-unit id="8eafae6da4cd26a48b49e41708a6136f1a6de4a6" translate="yes" xml:space="preserve">
          <source>The motivation for this command is that the ability to store many small integers as a single large bitmap (or segmented over a few keys to avoid having huge keys) is extremely memory efficient, and opens new use cases for Redis to be applied, especially in the field of real time analytics. This use cases are supported by the ability to specify the overflow in a controlled way.</source>
          <target state="translated">La motivación de este comando es que la capacidad de almacenar muchos números enteros pequeños como un único mapa de bits grande (o segmentado sobre unas pocas teclas para evitar tener teclas enormes)es extremadamente eficiente en cuanto a la memoria,y abre nuevos casos de uso para que se aplique Redis,especialmente en el campo de la analítica en tiempo real.Estos casos de uso se apoyan en la capacidad de especificar el desbordamiento de forma controlada.</target>
        </trans-unit>
        <trans-unit id="8a6f6dffc18be981185e9a84435cd70cbbe693b9" translate="yes" xml:space="preserve">
          <source>The name of the consumer that fetched the message and has still to acknowledge it. We call it the current &lt;em&gt;owner&lt;/em&gt; of the message.</source>
          <target state="translated">El nombre del consumidor que obtuvo el mensaje y a&amp;uacute;n debe reconocerlo. Lo llamamos el &lt;em&gt;propietario&lt;/em&gt; actual del mensaje.</target>
        </trans-unit>
        <trans-unit id="95a0cef10627d21f971cf58ca481b45ed9811331" translate="yes" xml:space="preserve">
          <source>The new configuration is persisted on disk in the node cluster configuration file.</source>
          <target state="translated">La nueva configuración se mantiene en el disco en el archivo de configuración del clúster de nodos.</target>
        </trans-unit>
        <trans-unit id="1512d4f9273a472bf5054bc09af80c7b583c9993" translate="yes" xml:space="preserve">
          <source>The node ID identifies the same node we are sending the command to.</source>
          <target state="translated">El ID del nodo identifica el mismo nodo al que estamos enviando el comando.</target>
        </trans-unit>
        <trans-unit id="4a94b0edb207a0f9aad4e9890ab6a41a4abc596d" translate="yes" xml:space="preserve">
          <source>The node ID of the removed node gets added to the ban-list, for 1 minute.</source>
          <target state="translated">El ID del nodo eliminado se añade a la lista de prohibiciones,durante 1 minuto.</target>
        </trans-unit>
        <trans-unit id="7282e91e365e1582b64fd77e649fb8fae6ff8480" translate="yes" xml:space="preserve">
          <source>The node current &lt;em&gt;config epoch&lt;/em&gt; is zero.</source>
          <target state="translated">La &lt;em&gt;&amp;eacute;poca de configuraci&amp;oacute;n&lt;/em&gt; actual del nodo es cero.</target>
        </trans-unit>
        <trans-unit id="96c472bb576e96ca78ba9e6916a3879a69d9af69" translate="yes" xml:space="preserve">
          <source>The node is empty, no keys are stored at all in the key space.</source>
          <target state="translated">El nodo está vacío,no hay ninguna llave almacenada en el espacio de las llaves.</target>
        </trans-unit>
        <trans-unit id="c909806a718de9cb07358d8ed9ed00c019748494" translate="yes" xml:space="preserve">
          <source>The node is not serving any hash slots.</source>
          <target state="translated">El nodo no está sirviendo ninguna ranura de hachís.</target>
        </trans-unit>
        <trans-unit id="ce819a3025f8ff3393901c2c8e810e36e0f1c69b" translate="yes" xml:space="preserve">
          <source>The node receiving the command is a replica, and the specified node ID identifies its current master.</source>
          <target state="translated">El nodo que recibe el comando es una réplica,y el ID del nodo especificado identifica a su maestro actual.</target>
        </trans-unit>
        <trans-unit id="3debb3fa567694b78b44554108f738a7a81cf421" translate="yes" xml:space="preserve">
          <source>The node will skip all the node IDs listed in the ban-list when processing gossip sections received in heartbeat packets from other nodes.</source>
          <target state="translated">El nodo se saltará todas las identificaciones de los nodos que figuran en la lista de prohibiciones cuando procese las secciones de chismes recibidas en paquetes de latidos de otros nodos.</target>
        </trans-unit>
        <trans-unit id="a02415f9a093ecefd5c824168bfb43638285dd33" translate="yes" xml:space="preserve">
          <source>The nodes table of the node is empty.</source>
          <target state="translated">La tabla de nodos del nodo está vacía.</target>
        </trans-unit>
        <trans-unit id="a21d4be2cd3c8386a5bd51f51d8e281923d2f322" translate="yes" xml:space="preserve">
          <source>The number of bits set to 1.</source>
          <target state="translated">El número de bits fijado en 1.</target>
        </trans-unit>
        <trans-unit id="59385708853390f9ca74251fea5131270265eecd" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted set, not including elements already existing for which the score was updated.</source>
          <target state="translated">El número de elementos añadidos al conjunto clasificado,sin incluir los elementos ya existentes para los que se actualizó la puntuación.</target>
        </trans-unit>
        <trans-unit id="dc1eea05d5c0b5d2f315739abfba0f7deefc344d" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted sets, not including elements already existing for which the score was updated.</source>
          <target state="translated">El número de elementos añadidos a los conjuntos ordenados,sin incluir los elementos ya existentes para los que se actualizó la puntuación.</target>
        </trans-unit>
        <trans-unit id="e1784080520f069f819c069f9066d039833cf4fa" translate="yes" xml:space="preserve">
          <source>The number of keys existing among the ones specified as arguments. Keys mentioned multiple times and existing are counted multiple times.</source>
          <target state="translated">El número de claves que existen entre las especificadas como argumentos.Las claves mencionadas varias veces y existentes se cuentan varias veces.</target>
        </trans-unit>
        <trans-unit id="3563b055f87d27dac0ac55fd291fab644c82615a" translate="yes" xml:space="preserve">
          <source>The number of members removed from the sorted set, not including non existing members.</source>
          <target state="translated">El número de miembros retirados del conjunto clasificado,sin incluir los miembros no existentes.</target>
        </trans-unit>
        <trans-unit id="2eae56d8105036d6f2b2f01b5669d022f7996c37" translate="yes" xml:space="preserve">
          <source>The number of milliseconds that elapsed since the last time this message was delivered to this consumer.</source>
          <target state="translated">El número de milisegundos que ha pasado desde la última vez que este mensaje fue entregado a este consumidor.</target>
        </trans-unit>
        <trans-unit id="bbb45a4c926e88dd9593fe92bcaf35382576535c" translate="yes" xml:space="preserve">
          <source>The number of returned elements can be limited using the &lt;code&gt;LIMIT&lt;/code&gt; modifier. This modifier takes the &lt;code&gt;offset&lt;/code&gt; argument, specifying the number of elements to skip and the &lt;code&gt;count&lt;/code&gt; argument, specifying the number of elements to return from starting at &lt;code&gt;offset&lt;/code&gt;. The following example will return 10 elements of the sorted version of &lt;code&gt;mylist&lt;/code&gt;, starting at element 0 (&lt;code&gt;offset&lt;/code&gt; is zero-based):</source>
          <target state="translated">El n&amp;uacute;mero de elementos devueltos se puede limitar mediante el modificador &lt;code&gt;LIMIT&lt;/code&gt; . Este modificador toma el argumento de &lt;code&gt;offset&lt;/code&gt; , especificando el n&amp;uacute;mero de elementos a omitir y el argumento de &lt;code&gt;count&lt;/code&gt; , especificando la cantidad de elementos a regresar desde el inicio del &lt;code&gt;offset&lt;/code&gt; . El siguiente ejemplo devolver&amp;aacute; 10 elementos de la versi&amp;oacute;n ordenada de &lt;code&gt;mylist&lt;/code&gt; , comenzando en el elemento 0 (el &lt;code&gt;offset&lt;/code&gt; se basa en cero):</target>
        </trans-unit>
        <trans-unit id="2eeaa2bda10c14131d8f8224aae3f44fbab1d33b" translate="yes" xml:space="preserve">
          <source>The number of times this message was delivered.</source>
          <target state="translated">El número de veces que este mensaje fue entregado.</target>
        </trans-unit>
        <trans-unit id="4b95ac5bed75bd380b7e253506beeb45e5dcdf48" translate="yes" xml:space="preserve">
          <source>The old master receives the configuration update: unblocks its clients and starts replying with redirection messages so that they'll continue the chat with the new master.</source>
          <target state="translated">El antiguo maestro recibe la actualización de la configuración:desbloquea a sus clientes y comienza a responder con mensajes de redirección para que continúen el chat con el nuevo maestro.</target>
        </trans-unit>
        <trans-unit id="1d689942edb764c6bd34cea24670f1e2f9a34fe2" translate="yes" xml:space="preserve">
          <source>The only valid cursors to use are:</source>
          <target state="translated">Los únicos cursores válidos para usar son:</target>
        </trans-unit>
        <trans-unit id="71d7b3a0d8bb44887a86cd184249f11ce4bd68cd" translate="yes" xml:space="preserve">
          <source>The only way to flush the script cache is by explicitly calling the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command, which will &lt;em&gt;completely flush&lt;/em&gt; the scripts cache removing all the scripts executed so far.</source>
          <target state="translated">La &amp;uacute;nica forma de vaciar la cach&amp;eacute; de scripts es llamando expl&amp;iacute;citamente al comando &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; , que vaciar&amp;aacute; &lt;em&gt;completamente&lt;/em&gt; la cach&amp;eacute; de scripts eliminando todos los scripts ejecutados hasta el momento.</target>
        </trans-unit>
        <trans-unit id="b79325b395f9601a80868e44ee285b402fa0bfad" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="translated">El argumento opcional &lt;code&gt;LIMIT&lt;/code&gt; se puede usar para obtener solo un rango de los elementos coincidentes (similar al &lt;em&gt;desplazamiento SELECT LIMIT, contar&lt;/em&gt; en SQL). Tenga en cuenta que si el &lt;code&gt;offset&lt;/code&gt; es grande, el conjunto ordenado debe atravesarse para &lt;code&gt;offset&lt;/code&gt; elementos de desplazamiento antes de llegar a los elementos que deben regresar, lo que puede sumar una complejidad de tiempo O (N).</target>
        </trans-unit>
        <trans-unit id="500dba23b5e32b54cd518b60d5bf8b2bf6fe3ec8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITHSCORES&lt;/code&gt; argument makes the command return both the element and its score, instead of the element alone. This option is available since Redis 2.0.</source>
          <target state="translated">El argumento opcional &lt;code&gt;WITHSCORES&lt;/code&gt; hace que el comando devuelva tanto el elemento como su puntuaci&amp;oacute;n, en lugar del elemento solo. Esta opci&amp;oacute;n est&amp;aacute; disponible desde Redis 2.0.</target>
        </trans-unit>
        <trans-unit id="0d8aa34d3ef4ed317f6f4c66d1281cf452a3e134" translate="yes" xml:space="preserve">
          <source>The optional parameter can be used to select a specific section of information:</source>
          <target state="translated">El parámetro opcional puede utilizarse para seleccionar una sección específica de información:</target>
        </trans-unit>
        <trans-unit id="d3f8920e23cd2f39487b2140b719e87054ae2b2b" translate="yes" xml:space="preserve">
          <source>The order of step 1 and 2 is important. We want the destination node to be ready to accept &lt;code&gt;ASK&lt;/code&gt; redirections when the source node is configured to redirect.</source>
          <target state="translated">El orden de los pasos 1 y 2 es importante. Queremos que el nodo de destino est&amp;eacute; listo para aceptar redirecciones &lt;code&gt;ASK&lt;/code&gt; cuando el nodo de origen est&amp;eacute; configurado para redireccionar.</target>
        </trans-unit>
        <trans-unit id="b62304b58ff7ffb9f9709c25da7f4765174f07a9" translate="yes" xml:space="preserve">
          <source>The output of the command is just a space-separated CSV string, where each line represents a node in the cluster. The following is an example of output:</source>
          <target state="translated">La salida del comando es sólo una cadena CSV separada del espacio,donde cada línea representa un nodo del cúmulo.El siguiente es un ejemplo de salida:</target>
        </trans-unit>
        <trans-unit id="27eaed3275801016a87c11dc8a65ad526a22ea0c" translate="yes" xml:space="preserve">
          <source>The port number of the master.</source>
          <target state="translated">El número de puerto del capitán.</target>
        </trans-unit>
        <trans-unit id="251a4c07dcd21d1710028ff045133e0223bd8086" translate="yes" xml:space="preserve">
          <source>The position is returned, thinking of the string as an array of bits from left to right, where the first byte's most significant bit is at position 0, the second byte's most significant bit is at position 8, and so forth.</source>
          <target state="translated">La posición es devuelta,pensando en la cadena como una matriz de bits de izquierda a derecha,donde el bit más significativo del primer byte está en la posición 0,el bit más significativo del segundo byte está en la posición 8,y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="cf1bf81ee9d88a76e67d9f14175bdac96ea2eae6" translate="yes" xml:space="preserve">
          <source>The position of the specified member is used as the center of the query.</source>
          <target state="translated">La posición del miembro especificado se utiliza como centro de la consulta.</target>
        </trans-unit>
        <trans-unit id="fe9f9e53a4720c0a3b3f8dd9ba6795a8d524ecc9" translate="yes" xml:space="preserve">
          <source>The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.</source>
          <target state="translated">La precisión de la salida está fijada en 17 dígitos después del punto decimal,independientemente de la precisión interna real del cálculo.</target>
        </trans-unit>
        <trans-unit id="a9079c728747b4e6051aebcc896878af23a86276" translate="yes" xml:space="preserve">
          <source>The radius is specified in one of the following units:</source>
          <target state="translated">El radio se especifica en una de las siguientes unidades:</target>
        </trans-unit>
        <trans-unit id="fa101056c680bd6adea2c67580ad18683b432390" translate="yes" xml:space="preserve">
          <source>The range of values supported by &lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt; is limited to 64 bit signed integers.</source>
          <target state="translated">El rango de valores admitidos por &lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt; est&amp;aacute; limitado a enteros de 64 bits con signo.</target>
        </trans-unit>
        <trans-unit id="33bdfca071502b90c1a8026acb1caf737da192b8" translate="yes" xml:space="preserve">
          <source>The rate limiter pattern is a special counter that is used to limit the rate at which an operation can be performed. The classical materialization of this pattern involves limiting the number of requests that can be performed against a public API.</source>
          <target state="translated">El patrón de limitación de la tasa es un contador especial que se utiliza para limitar la tasa a la que se puede realizar una operación.La materialización clásica de esta pauta consiste en limitar el número de solicitudes que pueden realizarse contra una API pública.</target>
        </trans-unit>
        <trans-unit id="602f859c103a55957a4cbd71395a1cae9a978824" translate="yes" xml:space="preserve">
          <source>The reason is that sending a script to another Redis instance is often much faster than sending the multiple commands the script generates, so if the client is sending many scripts to the master, converting the scripts into individual commands for the replica / AOF would result in too much bandwidth for the replication link or the Append Only File (and also too much CPU since dispatching a command received via network is a lot more work for Redis compared to dispatching a command invoked by Lua scripts).</source>
          <target state="translated">La razón es que el envío de un guión a otra instancia de Redis suele ser mucho más rápido que el envío de los múltiples comandos que el guión genera,por lo que si el cliente está enviando muchos guiones al maestro,la conversión de los guiones en comandos individuales para la réplica/AOF resultaría en demasiado ancho de banda para el enlace de la réplica o el archivo Append Only (y también demasiado CPU,ya que el envío de un comando recibido a través de la red es mucho más trabajo para Redis en comparación con el envío de un comando invocado por los guiones Lua).</target>
        </trans-unit>
        <trans-unit id="f4d6d43d2e03d821aeb88801c0d8fb884cbca911" translate="yes" xml:space="preserve">
          <source>The reason why scripts can be cached for long time is that it is unlikely for a well written application to have enough different scripts to cause memory problems. Every script is conceptually like the implementation of a new command, and even a large application will likely have just a few hundred of them. Even if the application is modified many times and scripts will change, the memory used is negligible.</source>
          <target state="translated">La razón por la que los guiones pueden ser almacenados en caché durante mucho tiempo es que es poco probable que una aplicación bien escrita tenga suficientes guiones diferentes para causar problemas de memoria.Cada guión es conceptualmente como la implementación de un nuevo comando,e incluso una gran aplicación probablemente tendrá sólo unos pocos cientos de ellos.Incluso si la aplicación se modifica muchas veces y los guiones cambian,la memoria utilizada es insignificante.</target>
        </trans-unit>
        <trans-unit id="0e5533e8fee1cbd59ebef949c8411c0d7d01dc8e" translate="yes" xml:space="preserve">
          <source>The replica output is composed of the following parts:</source>
          <target state="translated">La salida de la réplica se compone de las siguientes partes:</target>
        </trans-unit>
        <trans-unit id="d985304abe6bf0f8f4ea24090445b6bf55af90d3" translate="yes" xml:space="preserve">
          <source>The replica starts a failover, obtains a new configuration epoch from the majority of the masters, and broadcasts the new configuration.</source>
          <target state="translated">La réplica inicia un failover,obtiene una nueva época de configuración de la mayoría de los maestros,y transmite la nueva configuración.</target>
        </trans-unit>
        <trans-unit id="7c096a5e647ff1a64af00045529cba5bd168f06b" translate="yes" xml:space="preserve">
          <source>The replica tells the master to stop processing queries from clients.</source>
          <target state="translated">La réplica le dice al maestro que deje de procesar las consultas de los clientes.</target>
        </trans-unit>
        <trans-unit id="e43729fea60babeefa0888b3097ef84a1143b1a0" translate="yes" xml:space="preserve">
          <source>The replica waits for the replication offset to match on its side, to make sure it processed all the data from the master before it continues.</source>
          <target state="translated">La réplica espera a que la compensación de la réplica coincida en su lado,para asegurarse de que procesó todos los datos del maestro antes de continuar.</target>
        </trans-unit>
        <trans-unit id="2fb0e618b4e3d9e5fe2c17d1edb7fb80034a8b4f" translate="yes" xml:space="preserve">
          <source>The reported usage is the total of memory allocations for data and administrative overheads that a key its value require.</source>
          <target state="translated">El uso comunicado es el total de las asignaciones de memoria para los datos y los gastos generales administrativos que una clave requiere su valor.</target>
        </trans-unit>
        <trans-unit id="79c8f80736bb00aecddcc76c1b8f02af94064a15" translate="yes" xml:space="preserve">
          <source>The representation is neutral from the point of view of the processor word size and endianness, so the same representation is used by 32 bit and 64 bit processor, big endian or little endian.</source>
          <target state="translated">La representación es neutra desde el punto de vista del tamaño de la palabra del procesador y de la endianidad,por lo que la misma representación es utilizada por el procesador de 32 y 64 bits,la gran endian o la pequeña endian.</target>
        </trans-unit>
        <trans-unit id="d07c8ceb7018e1bcd908f1c44ebce957404cda02" translate="yes" xml:space="preserve">
          <source>The representation used by &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; considers the bitmap as having the bit number 0 to be the most significant bit of the first byte, and so forth, so for example setting a 5 bits unsigned integer to value 23 at offset 7 into a bitmap previously set to all zeroes, will produce the following representation:</source>
          <target state="translated">La representaci&amp;oacute;n utilizada por &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; considera que el mapa de bits tiene el n&amp;uacute;mero de bit 0 como el bit m&amp;aacute;s significativo del primer byte, y as&amp;iacute; sucesivamente, por ejemplo, establecer un entero sin signo de 5 bits en el valor 23 en el desplazamiento 7 en un mapa de bits previamente establecido en todos ceros, producir&amp;aacute; la siguiente representaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="69c89883952564695abb2bebcaf5f11f6b3d6f75" translate="yes" xml:space="preserve">
          <source>The result of the operation is always stored at &lt;code&gt;destkey&lt;/code&gt;.</source>
          <target state="translated">El resultado de la operaci&amp;oacute;n siempre se almacena en &lt;code&gt;destkey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8563416a363c2cdbe31060c220e5e3844f6d8270" translate="yes" xml:space="preserve">
          <source>The return type of the command is a &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;.</source>
          <target state="translated">El tipo de retorno del comando es una &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;respuesta de matriz&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29bc7d6c144c9d4891cb5866b63897dea6e00bee" translate="yes" xml:space="preserve">
          <source>The returned cardinality of the observed set is not exact, but approximated with a standard error of 0.81%.</source>
          <target state="translated">La cardinalidad devuelta del conjunto observado no es exacta,pero se aproxima con un error estándar de 0,81%.</target>
        </trans-unit>
        <trans-unit id="f485b5467a04f58f023ce0589b088bae79cd349e" translate="yes" xml:space="preserve">
          <source>The rewrite is performed in a very conservative way:</source>
          <target state="translated">La reescritura se realiza de forma muy conservadora:</target>
        </trans-unit>
        <trans-unit id="95ba82b2fd87a033c00319b26e5a7be447966868" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence. Specifically:</source>
          <target state="translated">La reescritura sólo será activada por Redis si no hay ya un proceso de fondo haciendo persistencia.Específicamente:</target>
        </trans-unit>
        <trans-unit id="1f1d9ccb03a5f0171c2e12fc9e5717671728f51a" translate="yes" xml:space="preserve">
          <source>The same bit position convention is followed by &lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt; and &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;.</source>
          <target state="translated">La misma convenci&amp;oacute;n de posici&amp;oacute;n de bit es seguida por &lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt; y &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2db5a15e45c348362ce43e64d992a94fa7834d6c" translate="yes" xml:space="preserve">
          <source>The same holds true for non-existent keys, that are considered as a stream of zero bytes up to the length of the longest string.</source>
          <target state="translated">Lo mismo ocurre con las claves inexistentes,que se consideran como una corriente de cero bytes hasta la longitud de la cadena más larga.</target>
        </trans-unit>
        <trans-unit id="459993ded23b09fc27e5d6a4bf1ae20c56fbcf0c" translate="yes" xml:space="preserve">
          <source>The save parameter is a single string of space-separated integers. Every pair of integers represent a seconds/modifications threshold.</source>
          <target state="translated">El parámetro de guardado es una sola cadena de números enteros separados por el espacio.Cada par de números enteros representa un umbral de segundos/modificaciones.</target>
        </trans-unit>
        <trans-unit id="19337abd9b3767724cccba46357082deb732a2c0" translate="yes" xml:space="preserve">
          <source>The score values should be the string representation of a double precision floating point number. &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; values are valid values as well.</source>
          <target state="translated">Los valores de puntuaci&amp;oacute;n deben ser la representaci&amp;oacute;n de cadena de un n&amp;uacute;mero de punto flotante de doble precisi&amp;oacute;n. &lt;code&gt;-inf&lt;/code&gt; valores &lt;code&gt;+inf&lt;/code&gt; y -inf tambi&amp;eacute;n son valores v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="8704ce1cdf5da36cc8175add936925537e2b6762" translate="yes" xml:space="preserve">
          <source>The script is guaranteed to stay in the script cache forever (unless &lt;code&gt;SCRIPT
FLUSH&lt;/code&gt; is called).</source>
          <target state="translated">Se garantiza que el script permanecer&amp;aacute; en la cach&amp;eacute; del script para siempre (a menos que se llame a &lt;code&gt;SCRIPT FLUSH&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="84e6859345305305b03236c94f49ebcdfaf9f284" translate="yes" xml:space="preserve">
          <source>The script must always evaluates the same Redis &lt;em&gt;write&lt;/em&gt; commands with the same arguments given the same input data set. Operations performed by the script cannot depend on any hidden (non-explicit) information or state that may change as script execution proceeds or between different executions of the script, nor can it depend on any external input from I/O devices.</source>
          <target state="translated">El script siempre debe evaluar los mismos comandos de &lt;em&gt;escritura de&lt;/em&gt; Redis con los mismos argumentos dado el mismo conjunto de datos de entrada. Las operaciones realizadas por el script no pueden depender de ninguna informaci&amp;oacute;n oculta (no expl&amp;iacute;cita) o estado que pueda cambiar a medida que avanza la ejecuci&amp;oacute;n del script o entre diferentes ejecuciones del script, ni puede depender de ninguna entrada externa de los dispositivos de E / S.</target>
        </trans-unit>
        <trans-unit id="f6f50abe88117410baf6ae78d63eac9d06193d38" translate="yes" xml:space="preserve">
          <source>The script should be called with &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt;</source>
          <target state="translated">Se debe llamar al &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt; con EVAL ... script ... 1 nombre-recurso valor-token</target>
        </trans-unit>
        <trans-unit id="ae5f9a8c3637986eaac0c1b5c2a821ed62bfff96" translate="yes" xml:space="preserve">
          <source>The second argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is the number of arguments that follows the script (starting from the third argument) that represent Redis key names. The arguments can be accessed by Lua using the &lt;code&gt;KEYS&lt;/code&gt; global variable in the form of a one-based array (so &lt;code&gt;KEYS[1]&lt;/code&gt;, &lt;code&gt;KEYS[2]&lt;/code&gt;, ...).</source>
          <target state="translated">El segundo argumento de &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; es el n&amp;uacute;mero de argumentos que siguen al script (a partir del tercer argumento) que representan los nombres de las claves de Redis. Lua puede acceder a los argumentos utilizando la variable global &lt;code&gt;KEYS&lt;/code&gt; en forma de una matriz basada en uno (por lo tanto, &lt;code&gt;KEYS[1]&lt;/code&gt; , &lt;code&gt;KEYS[2]&lt;/code&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="5e06049c7fb2a08a77ed966e80b1bd0de88bb6c2" translate="yes" xml:space="preserve">
          <source>The semantic change between patch level releases was needed since the old behavior was inherently incompatible with the Redis replication layer and was the cause of bugs.</source>
          <target state="translated">El cambio semántico entre las liberaciones de nivel de parche era necesario ya que el viejo comportamiento era inherentemente incompatible con la capa de replicación de Redis y era la causa de los bichos.</target>
        </trans-unit>
        <trans-unit id="c86d0b330e63015ff6018ffba522da6d3c2c8fb8" translate="yes" xml:space="preserve">
          <source>The sentinel output is composed of the following parts:</source>
          <target state="translated">La salida del centinela se compone de las siguientes partes:</target>
        </trans-unit>
        <trans-unit id="295a39c211fe9b12478b873df477a317d327e2b4" translate="yes" xml:space="preserve">
          <source>The serialization format is opaque and non-standard, however it has a few semantic characteristics:</source>
          <target state="translated">El formato de serialización es opaco y no estándar,sin embargo tiene algunas características semánticas:</target>
        </trans-unit>
        <trans-unit id="06e5cb4e4d36f51aabfd49438bd236dcf9c4976a" translate="yes" xml:space="preserve">
          <source>The serialized value does NOT contain expire information. In order to capture the time to live of the current value the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command should be used.</source>
          <target state="translated">El valor serializado NO contiene informaci&amp;oacute;n de vencimiento. Para capturar el tiempo de vida del valor actual, se debe utilizar el comando &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd5acc612a2b52a80de5b2a3e24e38f5ba00302b" translate="yes" xml:space="preserve">
          <source>The size of the string stored in the destination key, that is equal to the size of the longest input string.</source>
          <target state="translated">El tamaño de la cadena almacenada en la tecla de destino,que es igual al tamaño de la cadena de entrada más larga.</target>
        </trans-unit>
        <trans-unit id="1a0a5df2b74e73a15c2817e253d14a10935a2191" translate="yes" xml:space="preserve">
          <source>The slow log is accumulated in memory, so no file is written with information about the slow command executions. This makes the slow log remarkably fast at the point that you can enable the logging of all the commands (setting the &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; config parameter to zero) with minor performance hit.</source>
          <target state="translated">El registro lento se acumula en la memoria, por lo que no se escribe ning&amp;uacute;n archivo con informaci&amp;oacute;n sobre las ejecuciones lentas de los comandos. Esto hace que el registro lento sea notablemente r&amp;aacute;pido en el punto en que puede habilitar el registro de todos los comandos (estableciendo el par&amp;aacute;metro &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; config en cero) con un impacto menor en el rendimiento.</target>
        </trans-unit>
        <trans-unit id="4eaa8de726819dc3e71079d7a6f328e12fd9ddc2" translate="yes" xml:space="preserve">
          <source>The sparse representation uses a run-length encoding optimized to store efficiently a big number of registers set to zero. The dense representation is a Redis string of 12288 bytes in order to store 16384 6-bit counters. The need for the double representation comes from the fact that using 12k (which is the dense representation memory requirement) to encode just a few registers for smaller cardinalities is extremely suboptimal.</source>
          <target state="translated">La representación dispersa utiliza una codificación de duración optimizada para almacenar eficientemente un gran número de registros puestos a cero.La representación densa es una cadena Redis de 12288 bytes para almacenar 16384 contadores de 6 bits.La necesidad de la doble representación proviene del hecho de que utilizar 12k (que es el requisito de memoria de representación densa)para codificar sólo unos pocos registros para cardinalidades más pequeñas es extremadamente subóptimo.</target>
        </trans-unit>
        <trans-unit id="8eeebccfe9d0cfc87769de4a2c07747fec580fbc" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$&lt;/code&gt; ID.</source>
          <target state="translated">El &lt;code&gt;$&lt;/code&gt; ID especial .</target>
        </trans-unit>
        <trans-unit id="0f067eeaba3e5a87a3236774a27fada6161ea70f" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;&amp;gt;&lt;/code&gt; ID, which means that the consumer want to receive only messages that were &lt;em&gt;never delivered to any other consumer&lt;/em&gt;. It just means, give me new messages.</source>
          <target state="translated">El &lt;code&gt;&amp;gt;&lt;/code&gt; ID especial , que significa que el consumidor desea recibir solo mensajes que &lt;em&gt;nunca se entregaron a ning&amp;uacute;n otro consumidor&lt;/em&gt; . Solo significa, dame nuevos mensajes.</target>
        </trans-unit>
        <trans-unit id="5029fc6d051bb809efc7fcb4a44af5a544f6b49f" translate="yes" xml:space="preserve">
          <source>The specified node ID does not identify the instance we are sending the command to.</source>
          <target state="translated">El ID del nodo especificado no identifica la instancia a la que estamos enviando el comando.</target>
        </trans-unit>
        <trans-unit id="15f8e4eecac9b5616dbc97abb4f74fd51bce6356" translate="yes" xml:space="preserve">
          <source>The specified node ID exists in its nodes table.</source>
          <target state="translated">El ID del nodo especificado existe en su tabla de nodos.</target>
        </trans-unit>
        <trans-unit id="07565949c7a13614b4cf396e3dee4474076dd98c" translate="yes" xml:space="preserve">
          <source>The specified node ID is a master.</source>
          <target state="translated">El ID de nodo especificado es un maestro.</target>
        </trans-unit>
        <trans-unit id="92c45a066b5df5b3300ad8d74734dc668cec5a44" translate="yes" xml:space="preserve">
          <source>The specified node ID is not found in the nodes table.</source>
          <target state="translated">El ID de nodo especificado no se encuentra en la tabla de nodos.</target>
        </trans-unit>
        <trans-unit id="dadcfd8e793bf395f94eff22f99b0da2a7a715b6" translate="yes" xml:space="preserve">
          <source>The specified node gets removed from the nodes table.</source>
          <target state="translated">El nodo especificado se elimina de la tabla de nodos.</target>
        </trans-unit>
        <trans-unit id="3be929a4c6ff231339b330125852213fb5229ce4" translate="yes" xml:space="preserve">
          <source>The state of the replication from the point of view of the master, that can be &lt;code&gt;connect&lt;/code&gt; (the instance needs to connect to its master), &lt;code&gt;connecting&lt;/code&gt; (the master-replica connection is in progress), &lt;code&gt;sync&lt;/code&gt; (the master and replica are trying to perform the synchronization), &lt;code&gt;connected&lt;/code&gt; (the replica is online).</source>
          <target state="translated">El estado de la replicaci&amp;oacute;n desde el punto de vista del maestro, que se puede &lt;code&gt;connect&lt;/code&gt; (la instancia necesita conectarse a su maestro), &lt;code&gt;connecting&lt;/code&gt; (la conexi&amp;oacute;n maestro-r&amp;eacute;plica est&amp;aacute; en curso), &lt;code&gt;sync&lt;/code&gt; (el maestro y la r&amp;eacute;plica est&amp;aacute;n intentando realizar la sincronizaci&amp;oacute;n), &lt;code&gt;connected&lt;/code&gt; (la r&amp;eacute;plica est&amp;aacute; en l&amp;iacute;nea).</target>
        </trans-unit>
        <trans-unit id="b8b0d67ec2d33e9415285fa0b1b04c01c7c00db9" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;-&amp;gt;&lt;/code&gt; is used to separate the key name from the hash field name. The key is substituted as documented above, and the hash stored at the resulting key is accessed to retrieve the specified hash field.</source>
          <target state="translated">La cadena &lt;code&gt;-&amp;gt;&lt;/code&gt; se usa para separar el nombre de la clave del nombre del campo hash. La clave se sustituye como se document&amp;oacute; anteriormente, y se accede al hash almacenado en la clave resultante para recuperar el campo hash especificado.</target>
        </trans-unit>
        <trans-unit id="f708ccbae2afe95a0cd4653de56c8fb34c79374e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;master&lt;/code&gt; cuerdas .</target>
        </trans-unit>
        <trans-unit id="b2940a9d939b4548e348a547825fc4662aaec04e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;sentinel&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;sentinel&lt;/code&gt; cuerdas .</target>
        </trans-unit>
        <trans-unit id="4d8519eae0e62aff504d921a1adc6159ed001fa3" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatbility (see note at the end of this page).</source>
          <target state="translated">El &lt;code&gt;slave&lt;/code&gt; cadena , debido a la compatibilidad con versiones anteriores (consulte la nota al final de esta p&amp;aacute;gina).</target>
        </trans-unit>
        <trans-unit id="d2cc70797e244120c92cdce0be9d797bbb5993d5" translate="yes" xml:space="preserve">
          <source>The supported types are up to 64 bits for signed integers, and up to 63 bits for unsigned integers. This limitation with unsigned integers is due to the fact that currently the Redis protocol is unable to return 64 bit unsigned integers as replies.</source>
          <target state="translated">Los tipos soportados son hasta 64 bits para los enteros con signo,y hasta 63 bits para los enteros sin signo.Esta limitación con los números enteros sin signo se debe a que actualmente el protocolo Redis no puede devolver como respuesta números enteros sin signo de 64 bits.</target>
        </trans-unit>
        <trans-unit id="7a2d3466f691698508a75fad6644713be3c44a8f" translate="yes" xml:space="preserve">
          <source>The symmetric command used to alter the configuration at run time is &lt;code&gt;CONFIG
SET&lt;/code&gt;.</source>
          <target state="translated">El comando sim&amp;eacute;trico utilizado para modificar la configuraci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n es &lt;code&gt;CONFIG SET&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4ef14ef5924effb0e2166473b48d643f3dd0b5a" translate="yes" xml:space="preserve">
          <source>The system administrator sends a &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; command to force a node to meet another one.</source>
          <target state="translated">El administrador del sistema env&amp;iacute;a un comando &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; para forzar a un nodo a encontrarse con otro.</target>
        </trans-unit>
        <trans-unit id="f7dd65cc5a619424783dd395e5066f1952bf62a3" translate="yes" xml:space="preserve">
          <source>The third nested reply is guaranteed to be the IP/Port pair of the master instance for the slot range. All IP/Port pairs after the third nested reply are replicas of the master.</source>
          <target state="translated">La tercera respuesta anidada se garantiza que es el par IP/puerto de la instancia maestra para el rango de ranura.Todos los pares IP/puerto después de la tercera respuesta anidada son réplicas de la maestra.</target>
        </trans-unit>
        <trans-unit id="bc7c54ea663acc1cd16d645f286e49bdb17828f2" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in all existing databases.</source>
          <target state="translated">La complejidad temporal de esta operación es O(N),siendo N el número de claves en todas las bases de datos existentes.</target>
        </trans-unit>
        <trans-unit id="5dd2a246bdbf984a712d84e324dfcd54e3e83cfb" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in the database.</source>
          <target state="translated">La complejidad temporal de esta operación es O(N),siendo N el número de claves en la base de datos.</target>
        </trans-unit>
        <trans-unit id="33b9dc1580854319ae2c493dffcae592f1834dfc" translate="yes" xml:space="preserve">
          <source>The timeout can also be cleared, turning the key back into a persistent key, using the &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command.</source>
          <target state="translated">El tiempo de espera tambi&amp;eacute;n se puede borrar, convirtiendo la clave nuevamente en una clave persistente, usando el comando &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3cd5936158e61d7536637d6c3696dfb0161419" translate="yes" xml:space="preserve">
          <source>The timeout specifies the maximum idle time in any moment of the communication with the destination instance in milliseconds. This means that the operation does not need to be completed within the specified amount of milliseconds, but that the transfer should make progresses without blocking for more than the specified amount of milliseconds.</source>
          <target state="translated">El tiempo de espera especifica el máximo tiempo de inactividad en cualquier momento de la comunicación con la instancia de destino en milisegundos.Esto significa que la operación no necesita ser completada dentro de la cantidad especificada de milisegundos,sino que la transferencia debe progresar sin bloquearse por más de la cantidad especificada de milisegundos.</target>
        </trans-unit>
        <trans-unit id="47a97f0f97c34f511b051b78756091a74729e20b" translate="yes" xml:space="preserve">
          <source>The timeout will only be cleared by commands that delete or overwrite the contents of the key, including &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; and all the &lt;code&gt;*STORE&lt;/code&gt; commands. This means that all the operations that conceptually &lt;em&gt;alter&lt;/em&gt; the value stored at the key without replacing it with a new one will leave the timeout untouched. For instance, incrementing the value of a key with &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;, pushing a new value into a list with &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, or altering the field value of a hash with &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; are all operations that will leave the timeout untouched.</source>
          <target state="translated">El tiempo de espera solo se borrar&amp;aacute; mediante comandos que eliminen o sobrescriban el contenido de la clave, incluidos &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; , &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; , &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; y todos los comandos &lt;code&gt;*STORE&lt;/code&gt; . Esto significa que todas las operaciones que &lt;em&gt;alteren&lt;/em&gt; conceptualmente el valor almacenado en la clave sin reemplazarlo por uno nuevo dejar&amp;aacute;n intacto el tiempo de espera. Por ejemplo, incrementar el valor de una clave con &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; , insertar un nuevo valor en una lista con &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; o alterar el valor de campo de un hash con &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; son operaciones que dejar&amp;aacute;n el tiempo de espera intacto.</target>
        </trans-unit>
        <trans-unit id="b4902022e2711d4049af153f6960e9c07559e3db" translate="yes" xml:space="preserve">
          <source>The unit must be one of the following, and defaults to meters:</source>
          <target state="translated">La unidad debe ser una de las siguientes,y por defecto,metros:</target>
        </trans-unit>
        <trans-unit id="a995cbd615ab3e6d82df762d54a3d2493e68cc0e" translate="yes" xml:space="preserve">
          <source>The unix timestamp at which the logged command was processed.</source>
          <target state="translated">La marca de tiempo unix en la que se procesó el comando registrado.</target>
        </trans-unit>
        <trans-unit id="a0310f88660618094c01bca5ea0d0463bbd02002" translate="yes" xml:space="preserve">
          <source>The user just turned on AOF, and the server triggered the first AOF rewrite in order to create the initial AOF file. In this context, stopping will result in losing the dataset at all: once restarted, the server will potentially have AOF enabled without having any AOF file at all.</source>
          <target state="translated">El usuario acaba de encender el AOF,y el servidor disparó la primera reescritura del AOF para crear el archivo AOF inicial.En este contexto,detenerse resultará en la pérdida del conjunto de datos en absoluto:una vez reiniciado,el servidor potencialmente tendrá AOF activado sin tener ningún archivo AOF en absoluto.</target>
        </trans-unit>
        <trans-unit id="5f17b8b7fd14b72046eefe6ae0e142f682927503" translate="yes" xml:space="preserve">
          <source>The user should be aware that if the same existing key is mentioned in the arguments multiple times, it will be counted multiple times. So if &lt;code&gt;somekey&lt;/code&gt; exists, &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; will return 2.</source>
          <target state="translated">El usuario debe tener en cuenta que si la misma clave existente se menciona en los argumentos varias veces, se contar&amp;aacute; varias veces. As&amp;iacute; que si &lt;code&gt;somekey&lt;/code&gt; existe, &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; volver&amp;aacute; 2.</target>
        </trans-unit>
        <trans-unit id="a2b1b03bb92333675d117bc7fc8c0c76fc472f63" translate="yes" xml:space="preserve">
          <source>The user should take in mind that single-key and multiple-keys executions of this command are semantically different and have different performances.</source>
          <target state="translated">El usuario debe tener en cuenta que las ejecuciones de una sola tecla y de varias teclas de este comando son semánticamente diferentes y tienen diferentes rendimientos.</target>
        </trans-unit>
        <trans-unit id="2e0c79b31b353c9ce51c111498c89af1634cee6b" translate="yes" xml:space="preserve">
          <source>The way the sorted set is populated is using a technique called &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;. Latitude and Longitude bits are interleaved in order to form an unique 52 bit integer. We know that a sorted set double score can represent a 52 bit integer without losing precision.</source>
          <target state="translated">La forma en que se completa el conjunto ordenado es mediante una t&amp;eacute;cnica llamada &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; . Los bits de latitud y longitud se intercalan para formar un entero &amp;uacute;nico de 52 bits. Sabemos que una puntuaci&amp;oacute;n doble de un conjunto ordenado puede representar un entero de 52 bits sin perder precisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="473281da4300480447326ee40d8d889bb9d90481" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call, adding the sequence part of the ID by one.</source>
          <target state="translated">Luego, en lugar de comenzar la iteraci&amp;oacute;n nuevamente desde &lt;code&gt;-&lt;/code&gt; , como el inicio del rango, usamos el ID de entrada de la &lt;em&gt;&amp;uacute;ltima&lt;/em&gt; entrada devuelta por la llamada &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; anterior , agregando la parte de secuencia del ID en uno.</target>
        </trans-unit>
        <trans-unit id="49d73108f34c912bc3dcd46d706878a2b1cfa83b" translate="yes" xml:space="preserve">
          <source>Then suddenly that consumer fails forever.</source>
          <target state="translated">Entonces,de repente,ese consumidor falla para siempre.</target>
        </trans-unit>
        <trans-unit id="b66921f715545a310ecff4dca64b25267fdd5efb" translate="yes" xml:space="preserve">
          <source>There are also optional fields emitted only by Redis 4.0 or greater:</source>
          <target state="translated">También hay campos opcionales emitidos sólo por Redis 4.0 o superior:</target>
        </trans-unit>
        <trans-unit id="faf4557f2ee4da2fe1ae76ce2cecd829e57c75d9" translate="yes" xml:space="preserve">
          <source>There are conditions when we want just to terminate a Redis instance ASAP, regardless of what its content is. In such a case, the right combination of commands is to send a &lt;strong&gt;CONFIG appendonly no&lt;/strong&gt; followed by a &lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt;. The first command will turn off the AOF if needed, and will terminate the AOF rewriting child if there is one active. The second command will not have any problem to execute since the AOF is no longer enabled.</source>
          <target state="translated">Hay condiciones en las que solo queremos terminar una instancia de Redis lo antes posible, independientemente de cu&amp;aacute;l sea su contenido. En tal caso, la combinaci&amp;oacute;n correcta de comandos es enviar un &lt;strong&gt;CONFIG adjunto solo no&lt;/strong&gt; seguido de un &lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt; . El primer comando apagar&amp;aacute; el AOF si es necesario, y terminar&amp;aacute; el hijo de reescritura de AOF si hay uno activo. El segundo comando no tendr&amp;aacute; ning&amp;uacute;n problema para ejecutarse ya que el AOF ya no est&amp;aacute; habilitado.</target>
        </trans-unit>
        <trans-unit id="158a7d63bcc769d78e3493a2bc55c7a4ee6bce03" translate="yes" xml:space="preserve">
          <source>There are multiple clients rotating the list: they'll fetch different elements, until all the elements of the list are visited, and the process restarts.</source>
          <target state="translated">Hay múltiples clientes que rotan la lista:van a buscar diferentes elementos,hasta que todos los elementos de la lista son visitados,y el proceso se reinicia.</target>
        </trans-unit>
        <trans-unit id="bdda3afdb8163e659ca9981491dbe7bcadb74afd" translate="yes" xml:space="preserve">
          <source>There are situations where this is not enough, and we want a replica to failover without any agreement with the rest of the cluster. A real world use case for this is to mass promote replicas in a different data center to masters in order to perform a data center switch, while all the masters are down or partitioned away.</source>
          <target state="translated">Hay situaciones en las que esto no es suficiente,y queremos una réplica para la conmutación por error sin ningún acuerdo con el resto del grupo.Un caso de uso en el mundo real para esto es promover en masa réplicas en un centro de datos diferente a los maestros con el fin de realizar un cambio de centro de datos,mientras que todos los maestros están abajo o particionados.</target>
        </trans-unit>
        <trans-unit id="6bd7c5396466fc74307415d5fb57447e1fc4a356" translate="yes" xml:space="preserve">
          <source>There are times when a list can receive multiple elements in the context of the same conceptual command:</source>
          <target state="translated">Hay veces en que una lista puede recibir múltiples elementos en el contexto del mismo comando conceptual:</target>
        </trans-unit>
        <trans-unit id="8e2a3e6a950f5d8a609385be1af06951e77dc2ea" translate="yes" xml:space="preserve">
          <source>There are two helper functions to return Redis types from Lua.</source>
          <target state="translated">Hay dos funciones de ayuda para devolver los tipos de Redis de Lua.</target>
        </trans-unit>
        <trans-unit id="be8d4180a42a37a500975b93ef1e55ade0e6286d" translate="yes" xml:space="preserve">
          <source>There are two ways in order to specify offsets in the bitfield command. If a number without any prefix is specified, it is used just as a zero based bit offset inside the string.</source>
          <target state="translated">Hay dos maneras de especificar las compensaciones en el comando de campo de bits.Si se especifica un número sin ningún prefijo,se utiliza como un desplazamiento de bits basado en cero dentro de la cadena.</target>
        </trans-unit>
        <trans-unit id="d75f55602fddc93ba9011e7393a6bc36a64ba5a7" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;no simple way to have nils inside Lua arrays&lt;/a&gt;, this is a result of Lua table semantics, so when Redis converts a Lua array into Redis protocol the conversion is stopped if a nil is encountered.</source>
          <target state="translated">No &lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;hay una forma sencilla de tener nulos dentro de las matrices Lua&lt;/a&gt; , esto es el resultado de la sem&amp;aacute;ntica de la tabla Lua, por lo que cuando Redis convierte una matriz Lua en el protocolo Redis, la conversi&amp;oacute;n se detiene si se encuentra un nil.</target>
        </trans-unit>
        <trans-unit id="1181df382608fdc99dac69533a65959f383591cd" translate="yes" xml:space="preserve">
          <source>There is a different way to fix this issue without using scripting, but using Redis lists instead of counters. The implementation is more complex and uses more advanced features but has the advantage of remembering the IP addresses of the clients currently performing an API call, that may be useful or not depending on the application.</source>
          <target state="translated">Hay una forma diferente de arreglar este problema sin usar scripts,pero usando listas Redis en lugar de contadores.La implementación es más compleja y utiliza características más avanzadas,pero tiene la ventaja de recordar las direcciones IP de los clientes que actualmente realizan una llamada a la API,que puede ser útil o no dependiendo de la aplicación.</target>
        </trans-unit>
        <trans-unit id="2318fb4edc6b835e7f3009f7b1cfc0bceadc13e5" translate="yes" xml:space="preserve">
          <source>There is a stream with an associated consumer group.</source>
          <target state="translated">Hay una corriente con un grupo de consumidores asociado.</target>
        </trans-unit>
        <trans-unit id="f5813da89c7be6046d913f1f5df04a5cf2e30994" translate="yes" xml:space="preserve">
          <source>There is an additional Lua-to-Redis conversion rule that has no corresponding Redis to Lua conversion rule:</source>
          <target state="translated">Hay una regla adicional de conversión de Lua a Redis que no tiene una regla de conversión de Redis a Lua correspondiente:</target>
        </trans-unit>
        <trans-unit id="3c2e8ff8c03c52243caafd83d9c21a0190459a1a" translate="yes" xml:space="preserve">
          <source>There is another subcommand that only changes the behavior of successive &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; subcommand calls by setting the overflow behavior:</source>
          <target state="translated">Hay otro subcomando que solo cambia el comportamiento de las sucesivas &lt;a href=&quot;incrby&quot;&gt;llamadas de&lt;/a&gt; subcomando INCRBY estableciendo el comportamiento de desbordamiento:</target>
        </trans-unit>
        <trans-unit id="ad004d677ac8d1220049f68515cbe366e16611b0" translate="yes" xml:space="preserve">
          <source>There is no difference between using the helper functions or directly returning the table with the specified format, so the following two forms are equivalent:</source>
          <target state="translated">No hay diferencia entre utilizar las funciones de ayuda o devolver directamente la tabla con el formato especificado,por lo que las dos formas siguientes son equivalentes:</target>
        </trans-unit>
        <trans-unit id="688604faa0496cccdc56e5c3415b7e254e6c2086" translate="yes" xml:space="preserve">
          <source>There is no guarantee that it is actually the higher configuration epoch, since, for example, we can use the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option within a minority, nor any message exchange is performed to generate the new configuration epoch.</source>
          <target state="translated">No hay garant&amp;iacute;a de que sea realmente la &amp;eacute;poca de configuraci&amp;oacute;n superior, ya que, por ejemplo, podemos usar la opci&amp;oacute;n &lt;strong&gt;TAKEOVER&lt;/strong&gt; dentro de una minor&amp;iacute;a, ni se realiza ning&amp;uacute;n intercambio de mensajes para generar la nueva &amp;eacute;poca de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f9d2324c27d0bdf5977e444923fed05e29f7f2d5" translate="yes" xml:space="preserve">
          <source>There is no limit to the length of the name that can be assigned if not the usual limits of the Redis string type (512 MB). However it is not possible to use spaces in the connection name as this would violate the format of the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; reply.</source>
          <target state="translated">No hay l&amp;iacute;mite para la longitud del nombre que se puede asignar, salvo los l&amp;iacute;mites habituales del tipo de cadena de Redis (512 MB). Sin embargo, no es posible utilizar espacios en el nombre de la conexi&amp;oacute;n, ya que esto violar&amp;iacute;a el formato de la respuesta de la &lt;a href=&quot;client-list&quot;&gt;LISTA DE CLIENTES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5147f1530dd4898c039cd6ac5ba9eae79430a62" translate="yes" xml:space="preserve">
          <source>These are the counters that are reset:</source>
          <target state="translated">Estos son los contadores que se reinician:</target>
        </trans-unit>
        <trans-unit id="3f9525d03220e878ebb457481ab1b1546ad897b4" translate="yes" xml:space="preserve">
          <source>These bytes are pure overhead at the moment as no actual data is stored, and are used for maintaining the internal data structures of the server. Longer keys and values show asymptotically linear usage.</source>
          <target state="translated">Estos bytes son pura sobrecarga por el momento,ya que no se almacenan datos reales,y se utilizan para mantener las estructuras de datos internas del servidor.Las claves y valores más largos muestran un uso asintóticamente lineal.</target>
        </trans-unit>
        <trans-unit id="0c0d7819e41ea841eca9c54ef01aab00acdd805e" translate="yes" xml:space="preserve">
          <source>These offsets can also be negative numbers indicating offsets starting at the end of the list. For example, &lt;code&gt;-1&lt;/code&gt; is the last element of the list, &lt;code&gt;-2&lt;/code&gt; the penultimate, and so on.</source>
          <target state="translated">Estas compensaciones tambi&amp;eacute;n pueden ser n&amp;uacute;meros negativos que indican compensaciones que comienzan al final de la lista. Por ejemplo, &lt;code&gt;-1&lt;/code&gt; es el &amp;uacute;ltimo elemento de la lista, &lt;code&gt;-2&lt;/code&gt; el pen&amp;uacute;ltimo, y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="3327f4f330ea4245b93a5884cfe66d7c642a01a1" translate="yes" xml:space="preserve">
          <source>These prerequisites are needed since usually, manually altering the configuration epoch of a node is unsafe, we want to be sure that the node with the higher configuration epoch value (that is the last that failed over) wins over other nodes in claiming the hash slots ownership.</source>
          <target state="translated">Estos prerrequisitos son necesarios ya que normalmente,alterar manualmente la época de configuración de un nodo es inseguro,queremos estar seguros de que el nodo con el valor más alto de la época de configuración (que es el último que falló)gana sobre los otros nodos al reclamar la propiedad de los hash slots.</target>
        </trans-unit>
        <trans-unit id="74cdd9a11d855a7fe9706564ff82f50aed545b21" translate="yes" xml:space="preserve">
          <source>They can be shortened removing characters from the right. It will lose precision but will still point to the same area.</source>
          <target state="translated">Se pueden acortar eliminando los caracteres de la derecha.Perderá precisión pero seguirá apuntando a la misma zona.</target>
        </trans-unit>
        <trans-unit id="de21a5f9f7664481a629fd440bf41584926e640e" translate="yes" xml:space="preserve">
          <source>They correspond directly to the normal Redis log levels. Only logs emitted by scripting using a log level that is equal or greater than the currently configured Redis instance log level will be emitted.</source>
          <target state="translated">Se corresponden directamente con los niveles normales de registro de Redis.Sólo se emitirán los registros emitidos por la escritura utilizando un nivel de registro que sea igual o mayor que el nivel de registro de la instancia de Redis actualmente configurado.</target>
        </trans-unit>
        <trans-unit id="1163c9f8d8e2d599dd815fa54afcf7fcd4819d93" translate="yes" xml:space="preserve">
          <source>Things like using the system time, calling Redis random commands like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, or using Lua random number generator, could result into scripts that will not always evaluate in the same way.</source>
          <target state="translated">Cosas como usar la hora del sistema, llamar a comandos aleatorios de Redis como &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; , o usar el generador de n&amp;uacute;meros aleatorios Lua, podr&amp;iacute;an resultar en scripts que no siempre se evaluar&amp;aacute;n de la misma manera.</target>
        </trans-unit>
        <trans-unit id="3a6c24e6bcae98d8b374c6b8a2cb2e847242de7f" translate="yes" xml:space="preserve">
          <source>Think at a Lua script where we perform an intersection between two sets. Pick five random elements, and create a new set with this five random elements. Finally we delete the temporary key representing the intersection between the two original sets. What we want to replicate is only the creation of the new set with the five elements. It's not useful to also replicate the commands creating the temporary key.</source>
          <target state="translated">Piensa en un guión de Lua donde realizamos una intersección entre dos conjuntos.Escoge cinco elementos aleatorios,y crea un nuevo conjunto con estos cinco elementos aleatorios.Finalmente eliminamos la clave temporal que representa la intersección entre los dos conjuntos originales.Lo que queremos replicar es sólo la creación del nuevo conjunto con los cinco elementos.No es útil replicar también los comandos que crean la clave temporal.</target>
        </trans-unit>
        <trans-unit id="d05a95556307e74d8c3d500f8eaf5b432fd6a284" translate="yes" xml:space="preserve">
          <source>This avoids that a client will try to release the lock after the expire time deleting the key created by another client that acquired the lock later.</source>
          <target state="translated">Esto evita que un cliente intente liberar la cerradura después del tiempo de expiración borrando la llave creada por otro cliente que adquirió la cerradura más tarde.</target>
        </trans-unit>
        <trans-unit id="e05975c8ace39fb16ed1689fdd42d78b56751af2" translate="yes" xml:space="preserve">
          <source>This can be a problem with some application where we want a more reliable messaging system. When this is the case, please check the &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; command, that is a variant of &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; that adds the returned element to a target list before returning it to the client.</source>
          <target state="translated">Esto puede ser un problema con alguna aplicaci&amp;oacute;n donde queremos un sistema de mensajer&amp;iacute;a m&amp;aacute;s confiable. Cuando este sea el caso, verifique el comando &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; , que es una variante de &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; que agrega el elemento devuelto a una lista de destino antes de devolverlo al cliente.</target>
        </trans-unit>
        <trans-unit id="7d43703d663f6362b0a28ec9100f4db91d08a310" translate="yes" xml:space="preserve">
          <source>This can be fixed easily turning the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; with optional &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; into a Lua script that is send using the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command (only available since Redis version 2.6).</source>
          <target state="translated">Esto se puede solucionar f&amp;aacute;cilmente girando el &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; con la opci&amp;oacute;n de &lt;a href=&quot;expire&quot;&gt;EXPIRA&lt;/a&gt; en un script Lua que se env&amp;iacute;a utilizando el &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; de comandos (s&amp;oacute;lo disponible desde Redis versi&amp;oacute;n 2.6).</target>
        </trans-unit>
        <trans-unit id="72b1b07f3e247301ca1521cd5c3a4e2df6db2967" translate="yes" xml:space="preserve">
          <source>This command accepts one or more SHA1 digests and returns a list of ones or zeros to signal if the scripts are already defined or not inside the script cache. This can be useful before a pipelining operation to ensure that scripts are loaded (and if not, to load them using &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt;) so that the pipelining operation can be performed solely using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; instead of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; to save bandwidth.</source>
          <target state="translated">Este comando acepta uno o m&amp;aacute;s res&amp;uacute;menes SHA1 y devuelve una lista de unos o ceros para se&amp;ntilde;alar si los scripts ya est&amp;aacute;n definidos o no dentro de la cach&amp;eacute; de scripts. Esto puede ser &amp;uacute;til antes de una operaci&amp;oacute;n de canalizaci&amp;oacute;n para asegurar que los scripts est&amp;eacute;n cargados (y si no, para cargarlos usando &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; ) para que la operaci&amp;oacute;n de canalizaci&amp;oacute;n se pueda realizar &amp;uacute;nicamente usando &lt;a href=&quot;evalsha&quot;&gt;EVALSHA en&lt;/a&gt; lugar de &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; para ahorrar ancho de banda.</target>
        </trans-unit>
        <trans-unit id="43467785cd12ce45437b2b4eecb4c3b0671ef615" translate="yes" xml:space="preserve">
          <source>This command blocks the current client until all the previous write commands are successfully transferred and acknowledged by at least the specified number of replicas. If the timeout, specified in milliseconds, is reached, the command returns even if the specified number of replicas were not yet reached.</source>
          <target state="translated">Este comando bloquea el cliente actual hasta que todos los comandos de escritura anteriores se transfieran con éxito y sean reconocidos por al menos el número especificado de réplicas.Si se alcanza el tiempo de espera,especificado en milisegundos,el comando regresa incluso si el número especificado de réplicas no se ha alcanzado todavía.</target>
        </trans-unit>
        <trans-unit id="7a62033f131f44c3fe86c2c4ab2196a020d7e337" translate="yes" xml:space="preserve">
          <source>This command can be called with multiple streams if we want to read at the same time from a number of keys. This is a key feature of &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; because especially when blocking with &lt;strong&gt;BLOCK&lt;/strong&gt;, to be able to listen with a single connection to multiple keys is a vital feature.</source>
          <target state="translated">Este comando se puede llamar con m&amp;uacute;ltiples flujos si queremos leer al mismo tiempo desde varias claves. Esta es una caracter&amp;iacute;stica clave de &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; porque especialmente cuando se bloquea con &lt;strong&gt;BLOCK&lt;/strong&gt; , poder escuchar con una sola conexi&amp;oacute;n a m&amp;uacute;ltiples teclas es una caracter&amp;iacute;stica vital.</target>
        </trans-unit>
        <trans-unit id="ea63b36c2daa60b6b416fb9f70368e117feeda86" translate="yes" xml:space="preserve">
          <source>This command can unblock, from a different connection, a client blocked in a blocking operation, such as for instance &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; or &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">Este comando puede desbloquear, desde una conexi&amp;oacute;n diferente, un cliente bloqueado en una operaci&amp;oacute;n de bloqueo, como por ejemplo &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; o &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; o &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66b31d1c2eb93e0473a8a5492fa02a9c8c2c2d69" translate="yes" xml:space="preserve">
          <source>This command is currently implemented only when using &lt;strong&gt;jemalloc&lt;/strong&gt; as an allocator, and evaluates to a benign NOOP for all others.</source>
          <target state="translated">Este comando se implementa actualmente solo cuando se usa &lt;strong&gt;jemalloc&lt;/strong&gt; como asignador y se eval&amp;uacute;a como un NOOP benigno para todos los dem&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="932344d8190e35db9df40d94e5197fd7c1d13364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Este comando es igual a &lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt; , pero en lugar de devolver el conjunto resultante, se almacena en el &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="507f9a2dec2a09af16c3fc0fe75de6b0370a3364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Este comando es igual a &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; , pero en lugar de devolver el conjunto resultante, se almacena en &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86af64e6b7731ea035f82e2694ba78f231528031" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Este comando es igual a &lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt; , pero en lugar de devolver el conjunto resultante, se almacena en &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e32e7ca3fa8b824bc6b60a666e52d947d9640ed" translate="yes" xml:space="preserve">
          <source>This command is especially useful together with &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; which was introduced also in Redis 5 together with &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;. Check the &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; command page for a pattern involving the two commands.</source>
          <target state="translated">Este comando es especialmente &amp;uacute;til junto con &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK,&lt;/a&gt; que tambi&amp;eacute;n se introdujo en Redis 5 junto con &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; . Consulte la p&amp;aacute;gina de comandos &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; para ver un patr&amp;oacute;n que incluya los dos comandos.</target>
        </trans-unit>
        <trans-unit id="86526f15e70874597af78fb5a748e15addec9fd4" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; with the sole difference that instead of taking, as the center of the area to query, a longitude and latitude value, it takes the name of a member already existing inside the geospatial index represented by the sorted set.</source>
          <target state="translated">Este comando es exactamente como &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; con la &amp;uacute;nica diferencia de que en lugar de tomar, como centro del &amp;aacute;rea a consultar, un valor de longitud y latitud, toma el nombre de un miembro ya existente dentro del &amp;iacute;ndice geoespacial representado por el conjunto ordenado.</target>
        </trans-unit>
        <trans-unit id="20782308b0ebe308769b63e3df355d6efd05d3a3" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, but with the notable difference of returning the entries in reverse order, and also taking the start-end range in reverse order: in &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; you need to state the &lt;em&gt;end&lt;/em&gt; ID and later the &lt;em&gt;start&lt;/em&gt; ID, and the command will produce all the element between (or exactly like) the two IDs, starting from the &lt;em&gt;end&lt;/em&gt; side.</source>
          <target state="translated">Este comando es exactamente como &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; , pero con la notable diferencia de devolver las entradas en orden inverso, y tambi&amp;eacute;n tomar el rango de inicio y fin en orden inverso: en &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; debe indicar el ID &lt;em&gt;final&lt;/em&gt; y luego el ID de &lt;em&gt;inicio&lt;/em&gt; , y el comando producir&amp;aacute; todo el elemento entre (o exactamente igual) los dos ID, comenzando desde el lado &lt;em&gt;final&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f0909cd0cbb5b65dceb56a6821a06b32b029f0ae" translate="yes" xml:space="preserve">
          <source>This command is mainly used in the event a &lt;code&gt;nodes.conf&lt;/code&gt; node state file gets lost / deleted for some reason, and we want to generate it again from scratch. It can also be useful in case of mundane alterations of a node cluster configuration via the &lt;code&gt;CLUSTER&lt;/code&gt; command in order to ensure the new configuration is persisted on disk, however all the commands should normally be able to auto schedule to persist the configuration on disk when it is important to do so for the correctness of the system in the event of a restart.</source>
          <target state="translated">Este comando se utiliza principalmente en el caso de que un archivo de estado de nodo &lt;code&gt;nodes.conf&lt;/code&gt; se pierda / elimine por alguna raz&amp;oacute;n, y queremos generarlo nuevamente desde cero. Tambi&amp;eacute;n puede ser &amp;uacute;til en caso de alteraciones mundanas de la configuraci&amp;oacute;n de un cl&amp;uacute;ster de nodos a trav&amp;eacute;s del comando &lt;code&gt;CLUSTER&lt;/code&gt; para garantizar que la nueva configuraci&amp;oacute;n se mantenga en el disco; sin embargo, todos los comandos normalmente deber&amp;iacute;an poder programar autom&amp;aacute;ticamente para conservar la configuraci&amp;oacute;n en el disco cuando Es importante hacerlo para que el sistema sea correcto en caso de reinicio.</target>
        </trans-unit>
        <trans-unit id="b0d65e64e68abf2d5af87daf134cb637fc1df1f2" translate="yes" xml:space="preserve">
          <source>This command is mainly useful for debugging, when the failure detector of Redis Cluster is not operating as we believe it should.</source>
          <target state="translated">Este comando es principalmente útil para la depuración,cuando el detector de fallas de Redis Cluster no está operando como creemos que debería.</target>
        </trans-unit>
        <trans-unit id="30fc3be6e9d8c6b14224168e93a2ce61a33ebf6a" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to kill a script that is running for too much time(for instance because it entered an infinite loop because of a bug). The script will be killed and the client currently blocked into EVAL will see the command returning with an error.</source>
          <target state="translated">Este comando es principalmente útil para matar un script que se está ejecutando durante demasiado tiempo (por ejemplo,porque entró en un bucle infinito debido a un error).El script se matará y el cliente actualmente bloqueado en EVAL verá que el comando vuelve con un error.</target>
        </trans-unit>
        <trans-unit id="37c2b15b0fd4a88889c5862b221daca96c7ea555" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to re-provision a Redis Cluster node in order to be used in the context of a new, different cluster. The command is also extensively used by the Redis Cluster testing framework in order to reset the state of the cluster every time a new test unit is executed.</source>
          <target state="translated">Este comando es principalmente útil para reaprovisionar un nodo de Redis Cluster para ser usado en el contexto de un nuevo y diferente cluster.El comando también es ampliamente utilizado por el marco de pruebas del Redis Cluster para restablecer el estado del cluster cada vez que se ejecuta una nueva unidad de prueba.</target>
        </trans-unit>
        <trans-unit id="6b9cd1ceade82d616f55d37288e27be4ecc550c1" translate="yes" xml:space="preserve">
          <source>This command is the only way to force Redis to flush the scripts cache. It is most useful in a cloud environment where the same instance can be reassigned to a different user. It is also useful for testing client libraries' implementations of the scripting feature.</source>
          <target state="translated">Este comando es la única manera de obligar a Redis a vaciar el caché de scripts.Es más útil en un entorno de nubes donde la misma instancia puede ser reasignada a un usuario diferente.También es útil para probar las implementaciones de las bibliotecas de clientes de la función de scripts.</target>
        </trans-unit>
        <trans-unit id="8562c28aa29c0aee65ed6fb4a3d690ee24e35388" translate="yes" xml:space="preserve">
          <source>This command is the only way to interrupt a long-running script that reaches the configured maximum execution time for scripts. The SCRIPT KILL command can only be used with scripts that did not modify the dataset during their execution (since stopping a read-only script does not violate the scripting engine's guaranteed atomicity). See the next sections for more information about long running scripts.</source>
          <target state="translated">Este comando es la única manera de interrumpir un guión de larga duración que alcanza el tiempo máximo de ejecución configurado para los guiones.El comando SCRIPT KILL sólo puede utilizarse con scripts que no modificaron el conjunto de datos durante su ejecución (ya que detener un script de sólo lectura no viola la atomicidad garantizada del motor de scripts).Consulte las siguientes secciones para obtener más información sobre los scripts de larga duración.</target>
        </trans-unit>
        <trans-unit id="74540a3a51962d64e542e90991498fda99b11c4b" translate="yes" xml:space="preserve">
          <source>This command is used in order to manage the consumer groups associated with a stream data structure. Using &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; you can:</source>
          <target state="translated">Este comando se utiliza para administrar los grupos de consumidores asociados con una estructura de datos de flujo. Usando &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; puede:</target>
        </trans-unit>
        <trans-unit id="0f3f38de2ae9dc1853425848b341ace4420d82e4" translate="yes" xml:space="preserve">
          <source>This command is used in order to read and reset the Redis slow queries log.</source>
          <target state="translated">Este comando se utiliza para leer y reiniciar el registro de consultas lentas de Redis.</target>
        </trans-unit>
        <trans-unit id="4469a3906600e48388ff32654f41a170c058ed11" translate="yes" xml:space="preserve">
          <source>This command is useful as it makes able to switch clients from a Redis instance to another one in a controlled way. For example during an instance upgrade the system administrator could do the following:</source>
          <target state="translated">Este comando es útil ya que permite cambiar los clientes de una instancia de Redis a otra de forma controlada.Por ejemplo,durante la actualización de una instancia el administrador del sistema podría hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="7716c05ccc0dd7cac30547152d82c808312925c0" translate="yes" xml:space="preserve">
          <source>This command is useful especially when we are monitoring many keys with a limited number of connections. For instance we may want to monitor multiple streams with &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; without using more than N connections. However at some point the consumer process is informed that there is one more stream key to monitor. In order to avoid using more connections, the best behavior would be to stop the blocking command from one of the connections in the pool, add the new key, and issue the blocking command again.</source>
          <target state="translated">Este comando es &amp;uacute;til especialmente cuando estamos monitoreando muchas claves con un n&amp;uacute;mero limitado de conexiones. Por ejemplo, es posible que deseemos monitorear m&amp;uacute;ltiples transmisiones con &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; sin usar m&amp;aacute;s de N conexiones. Sin embargo, en alg&amp;uacute;n momento se informa al proceso del consumidor que hay una clave de flujo m&amp;aacute;s para monitorear. Para evitar el uso de m&amp;aacute;s conexiones, el mejor comportamiento ser&amp;iacute;a detener el comando de bloqueo de una de las conexiones en el grupo, agregar la nueva clave y emitir el comando de bloqueo nuevamente.</target>
        </trans-unit>
        <trans-unit id="59ff8c186eb229a2dac30dbd70e43e24baabed7c" translate="yes" xml:space="preserve">
          <source>This command is useful in order to modify a node's view of the cluster configuration. Specifically it assigns a set of hash slots to the node receiving the command. If the command is successful, the node will map the specified hash slots to itself, and will start broadcasting the new configuration.</source>
          <target state="translated">Este comando es útil para modificar la vista de un nodo de la configuración del clúster.Específicamente asigna un conjunto de ranuras de hash al nodo que recibe el comando.Si el comando tiene éxito,el nodo se asignará a sí mismo las ranuras de hash especificadas y comenzará a emitir la nueva configuración.</target>
        </trans-unit>
        <trans-unit id="afcb99c36c15189824ecdc3091bf486391211187" translate="yes" xml:space="preserve">
          <source>This command is very similar to &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;: it removes the specified keys. Just like &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; is. This is where the command name comes from: the command just &lt;strong&gt;unlinks&lt;/strong&gt; the keys from the keyspace. The actual removal will happen later asynchronously.</source>
          <target state="translated">Este comando es muy similar a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; : elimina las claves especificadas. Al igual que &lt;a href=&quot;del&quot;&gt;DEL,&lt;/a&gt; una clave se ignora si no existe. Sin embargo, el comando realiza la recuperaci&amp;oacute;n de memoria real en un subproceso diferente, por lo que no est&amp;aacute; bloqueando, mientras que &lt;a href=&quot;del&quot;&gt;DEL lo&lt;/a&gt; est&amp;aacute;. Aqu&amp;iacute; es de donde proviene el nombre del comando: el comando simplemente &lt;strong&gt;desvincula&lt;/strong&gt; las claves del espacio de claves. La eliminaci&amp;oacute;n real ocurrir&amp;aacute; m&amp;aacute;s tarde de forma asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="6e7d9161cbb27663ecc1a90a3f6bb05f23dbad84" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and is useful in the following Redis Cluster operations:</source>
          <target state="translated">Este comando sólo funciona en modo clúster y es útil en las siguientes operaciones de Redis Cluster:</target>
        </trans-unit>
        <trans-unit id="ae45a8ae2f8e5aecd7b6912a681c88c74a505274" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and may be useful for debugging and in order to manually orchestrate a cluster configuration when a new cluster is created. It is currently not used by &lt;code&gt;redis-trib&lt;/code&gt;, and mainly exists for API completeness.</source>
          <target state="translated">Este comando solo funciona en modo de cl&amp;uacute;ster y puede ser &amp;uacute;til para depurar y para orquestar manualmente una configuraci&amp;oacute;n de cl&amp;uacute;ster cuando se crea un nuevo cl&amp;uacute;ster. Actualmente no es utilizado por &lt;code&gt;redis-trib&lt;/code&gt; , y existe principalmente para completar API.</target>
        </trans-unit>
        <trans-unit id="a5304131d86dfa25555f9abe5b57dd4ad31bed60" translate="yes" xml:space="preserve">
          <source>This command registers the specified script in the Redis script cache. The command is useful in all the contexts where we want to make sure that &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will not fail (for instance during a pipeline or MULTI/EXEC operation), without the need to actually execute the script.</source>
          <target state="translated">Este comando registra la secuencia de comandos especificada en la cach&amp;eacute; de secuencias de comandos de Redis. El comando es &amp;uacute;til en todos los contextos en los que queremos asegurarnos de que &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; no fallar&amp;aacute; (por ejemplo, durante una canalizaci&amp;oacute;n o una operaci&amp;oacute;n MULTI / EXEC), sin la necesidad de ejecutar realmente el script.</target>
        </trans-unit>
        <trans-unit id="ef7e7424bc09f286d32a4b812efe8253277e59f5" translate="yes" xml:space="preserve">
          <source>This command returns the number of failure reports for the current node which are currently not expired (so received within two times the &lt;em&gt;node timeout&lt;/em&gt; time). The count does not include what the node we are asking this count believes about the node ID we pass as argument, the count &lt;em&gt;only&lt;/em&gt; includes the failure reports the node received from other nodes.</source>
          <target state="translated">Este comando devuelve el n&amp;uacute;mero de informes de fallas para el nodo actual que actualmente no est&amp;aacute;n vencidos (por lo que se reciben dentro de dos veces el &lt;em&gt;tiempo de espera&lt;/em&gt; del &lt;em&gt;nodo&lt;/em&gt; ). El recuento no incluye lo que cree el nodo al que le preguntamos este recuento sobre el ID de nodo que pasamos como argumento, el recuento &lt;em&gt;solo&lt;/em&gt; incluye los informes de falla que el nodo recibi&amp;oacute; de otros nodos.</target>
        </trans-unit>
        <trans-unit id="541223fddf4b501cc96317842ccc50859641cd10" translate="yes" xml:space="preserve">
          <source>This command sets a specific &lt;em&gt;config epoch&lt;/em&gt; in a fresh node. It only works when:</source>
          <target state="translated">Este comando establece una &lt;em&gt;&amp;eacute;poca de configuraci&amp;oacute;n&lt;/em&gt; espec&amp;iacute;fica en un nodo nuevo. Solo funciona cuando:</target>
        </trans-unit>
        <trans-unit id="18e23f892090be38939eafd00c77e503dab8c192" translate="yes" xml:space="preserve">
          <source>This command swaps two Redis databases, so that immediately all the clients connected to a given database will see the data of the other database, and the other way around. Example:</source>
          <target state="translated">Este comando intercambia dos bases de datos Redis,de modo que inmediatamente todos los clientes conectados a una base de datos determinada verán los datos de la otra base,y al revés.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="6adc7a43ee507fff544bbc6adc515bc47ac97ad4" translate="yes" xml:space="preserve">
          <source>This command was introduced in the middle of a Redis stable release, specifically with Redis 2.8.12.</source>
          <target state="translated">Este comando se introdujo en medio de una liberación estable de Redis,específicamente con Redis 2.8.12.</target>
        </trans-unit>
        <trans-unit id="838bb242e39a256bd97fcf68121a5b0ba9ba6cad" translate="yes" xml:space="preserve">
          <source>This command works exactly like &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; but the time to live of the key is specified in milliseconds instead of seconds.</source>
          <target state="translated">Este comando funciona exactamente como &lt;a href=&quot;expire&quot;&gt;EXPIRE,&lt;/a&gt; pero el tiempo de vida de la clave se especifica en milisegundos en lugar de segundos.</target>
        </trans-unit>
        <trans-unit id="7341623725ef962c36ad811614642ab5632c4c2c" translate="yes" xml:space="preserve">
          <source>This command, that can only be sent to a Redis Cluster replica node, forces the replica to start a manual failover of its master instance.</source>
          <target state="translated">Este comando,que sólo puede ser enviado a un nodo de réplica de Redis Cluster,obliga a la réplica a iniciar un failover manual de su instancia maestra.</target>
        </trans-unit>
        <trans-unit id="4da304a4683087def0d8d26eb2c481c6af27db0a" translate="yes" xml:space="preserve">
          <source>This conversion between data types is designed in a way that if a Redis type is converted into a Lua type, and then the result is converted back into a Redis type, the result is the same as the initial value.</source>
          <target state="translated">Esta conversión entre los tipos de datos está diseñada de tal manera que si un tipo Redis se convierte en un tipo Lua,y luego el resultado se convierte de nuevo en un tipo Redis,el resultado es el mismo que el valor inicial.</target>
        </trans-unit>
        <trans-unit id="e18d68145955b4559f3ba803d90954ff94c0dac8" translate="yes" xml:space="preserve">
          <source>This dynamic is clearly explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Stream intro documentation&lt;/a&gt;.</source>
          <target state="translated">Esta din&amp;aacute;mica se explica claramente en la &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;documentaci&amp;oacute;n de introducci&amp;oacute;n de Stream&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19d5d3191e2445ef69de01881bb5939b9f401be6" translate="yes" xml:space="preserve">
          <source>This example shows the application in the context of Redis streams, however the pattern is a general one and can be applied to other cases.</source>
          <target state="translated">Este ejemplo muestra la aplicación en el contexto de las corrientes de Redis,aunque la pauta es general y puede aplicarse a otros casos.</target>
        </trans-unit>
        <trans-unit id="c30a4ad86f29101d3c1fcdfab12485ff0ca6c027" translate="yes" xml:space="preserve">
          <source>This format allows for radius querying by checking the 1+8 areas needed to cover the whole radius, and discarding elements outside the radius. The areas are checked by calculating the range of the box covered removing enough bits from the less significant part of the sorted set score, and computing the score range to query in the sorted set for each area.</source>
          <target state="translated">Este formato permite la consulta del radio comprobando las áreas 1+8 necesarias para cubrir todo el radio,y desechando los elementos fuera del radio.Las áreas se comprueban calculando el rango de la caja cubierta eliminando suficientes bits de la parte menos significativa de la puntuación del conjunto ordenado,y calculando el rango de la puntuación a consultar en el conjunto ordenado para cada área.</target>
        </trans-unit>
        <trans-unit id="5f7d96d3049d4f76efb356668757ef71fbc55342" translate="yes" xml:space="preserve">
          <source>This has the same effect as running &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; with one argument &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Esto tiene el mismo efecto que ejecutar &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; con una &lt;code&gt;key&lt;/code&gt; argumento .</target>
        </trans-unit>
        <trans-unit id="5d0bfed0b5c7c513675b9c26b7ab5ed0c6f3d603" translate="yes" xml:space="preserve">
          <source>This is a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="translated">Esta es una buena descripci&amp;oacute;n general, pero a veces nos interesan los detalles. Para poder ver todos los mensajes pendientes con m&amp;aacute;s informaci&amp;oacute;n asociada necesitamos pasar tambi&amp;eacute;n un rango de IDs, de manera similar lo hacemos con &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; , y un argumento de &lt;em&gt;conteo&lt;/em&gt; no opcional , para limitar la cantidad de mensajes devueltos por llamada:</target>
        </trans-unit>
        <trans-unit id="61b4d531c8516c33061d94d3a8959add03c42f29" translate="yes" xml:space="preserve">
          <source>This is a trivial probabilistic algorithm, basically the assumption is that our sample is representative of the whole key space, and we continue to expire until the percentage of keys that are likely to be expired is under 25%</source>
          <target state="translated">Este es un algoritmo probabilístico trivial,básicamente la suposición es que nuestra muestra es representativa de todo el espacio de claves,y seguimos expirando hasta que el porcentaje de claves que es probable que expiren está por debajo del 25%</target>
        </trans-unit>
        <trans-unit id="c48adb8e8d877ae182110cc1e68d2e6bc1d83311" translate="yes" xml:space="preserve">
          <source>This is an example of blocking invocation, where the command later returns a null reply because the timeout has elapsed without new data arriving:</source>
          <target state="translated">Este es un ejemplo de bloqueo de la invocación,en el que el comando devuelve más tarde una respuesta nula porque el tiempo de espera ha transcurrido sin que lleguen nuevos datos:</target>
        </trans-unit>
        <trans-unit id="622bd341d8dc701d53c24284f457bffb1eb9df29" translate="yes" xml:space="preserve">
          <source>This is an example of iteration using &lt;strong&gt;MATCH&lt;/strong&gt;:</source>
          <target state="translated">Este es un ejemplo de iteraci&amp;oacute;n usando &lt;strong&gt;MATCH&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4d789554ece00f72c77acd57e4f313f31c717e24" translate="yes" xml:space="preserve">
          <source>This is an introspection command used in order to retrieve different information about the streams and associated consumer groups. Three forms are possible:</source>
          <target state="translated">Se trata de un comando de introspección que se utiliza para recuperar diferentes informaciones sobre las corrientes y los grupos de consumidores asociados.Tres formas son posibles:</target>
        </trans-unit>
        <trans-unit id="fa13476351797926204e99a9b54034d28b5780cc" translate="yes" xml:space="preserve">
          <source>This is easy to see intuitively: if the collection grows there is more and more work to do in order to visit all the possible elements, and the ability to terminate the iteration depends on the number of calls to &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; and its COUNT option value compared with the rate at which the collection grows.</source>
          <target state="translated">Esto es f&amp;aacute;cil de ver intuitivamente: si la colecci&amp;oacute;n crece, hay m&amp;aacute;s y m&amp;aacute;s trabajo por hacer para visitar todos los elementos posibles, y la capacidad de terminar la iteraci&amp;oacute;n depende del n&amp;uacute;mero de llamadas a &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; y su valor de opci&amp;oacute;n COUNT en comparaci&amp;oacute;n con la velocidad a la que crece la colecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5ecf6a9694906630d3be8ffa19f791d25178c710" translate="yes" xml:space="preserve">
          <source>This is how a typical &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; call looks like in the first iteration of a consumer willing to consume only new entries:</source>
          <target state="translated">As&amp;iacute; es como se ve una llamada &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; t&amp;iacute;pica en la primera iteraci&amp;oacute;n de un consumidor dispuesto a consumir solo nuevas entradas:</target>
        </trans-unit>
        <trans-unit id="720fb76cbe63b3ee37bb596512afa1691c9ba3f2" translate="yes" xml:space="preserve">
          <source>This is how to understand if you want to use a consumer group or not:</source>
          <target state="translated">Así es como se entiende si se quiere usar un grupo de consumidores o no:</target>
        </trans-unit>
        <trans-unit id="2d94df873adfd43289accd82b71abdee4a8063f4" translate="yes" xml:space="preserve">
          <source>This is how we use this command in order to mount such an algorithm:</source>
          <target state="translated">Así es como usamos este comando para montar tal algoritmo:</target>
        </trans-unit>
        <trans-unit id="b9658590fc318422333085d731b93a7035c7459f" translate="yes" xml:space="preserve">
          <source>This is useful in several ways depending on the use case:</source>
          <target state="translated">Esto es útil de varias maneras dependiendo del caso de uso:</target>
        </trans-unit>
        <trans-unit id="7a58d44535039d5a20b0fa97b3b1ee43b1b6dd46" translate="yes" xml:space="preserve">
          <source>This is usually needed only when the instance is going to be instantiated for another customer or application in a cloud environment.</source>
          <target state="translated">Por lo general,esto sólo es necesario cuando la instancia va a ser instanciada para otro cliente o aplicación en un entorno de nube.</target>
        </trans-unit>
        <trans-unit id="bbfa8fbc11f623748d63d11e9bf5ee03c12ff234" translate="yes" xml:space="preserve">
          <source>This manual page also covers the &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; variants (see the section below for more information).</source>
          <target state="translated">Esta p&amp;aacute;gina de manual tambi&amp;eacute;n cubre las variantes &lt;code&gt;GEORADIUS_RO&lt;/code&gt; y &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; (consulte la secci&amp;oacute;n siguiente para obtener m&amp;aacute;s informaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="d223d35db64e1d19fc9f2926f21b42e4ab2344a9" translate="yes" xml:space="preserve">
          <source>This means that at any given moment the maximum amount of keys already expired that are using memory is at max equal to max amount of write operations per second divided by 4.</source>
          <target state="translated">Esto significa que en un momento dado la cantidad máxima de teclas ya caducadas que están utilizando la memoria es como máximo igual a la cantidad máxima de operaciones de escritura por segundo dividida por 4.</target>
        </trans-unit>
        <trans-unit id="aabcd9a95a39d430c629afa9fad1b539c022ac85" translate="yes" xml:space="preserve">
          <source>This means that if you have two non-empty buckets in the entire hash table, and one has three elements while one has just one, the element that is alone in its bucket will be returned with much higher probability.</source>
          <target state="translated">Esto significa que si se tienen dos cubos no vacíos en toda la mesa de hachís,y uno tiene tres elementos mientras que el otro sólo tiene uno,el elemento que está solo en su cubo será devuelto con una probabilidad mucho mayor.</target>
        </trans-unit>
        <trans-unit id="249f94aa848de22f03290fa35dfb93a51fdb5d7d" translate="yes" xml:space="preserve">
          <source>This means that this command should be used with care only by applications orchestrating Redis Cluster, like &lt;code&gt;redis-trib&lt;/code&gt;, and the command if used out of the right context can leave the cluster in a wrong state or cause data loss.</source>
          <target state="translated">Esto significa que este comando debe usarse con cuidado solo por las aplicaciones que organizan Redis Cluster, como &lt;code&gt;redis-trib&lt;/code&gt; , y el comando, si se usa fuera del contexto correcto, puede dejar el cl&amp;uacute;ster en un estado incorrecto o provocar la p&amp;eacute;rdida de datos.</target>
        </trans-unit>
        <trans-unit id="b4b18f04b9acb83f71f24c60b244188e2d234cce" translate="yes" xml:space="preserve">
          <source>This means that you set:</source>
          <target state="translated">Esto significa que te pones en marcha:</target>
        </trans-unit>
        <trans-unit id="8a0b4cfa314b524daabda36aba34d428f894ef1e" translate="yes" xml:space="preserve">
          <source>This operation is similar to &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, that returns one or more random elements from a set but does not remove it.</source>
          <target state="translated">Esta operaci&amp;oacute;n es similar a &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; , que devuelve uno o m&amp;aacute;s elementos aleatorios de un conjunto pero no los elimina.</target>
        </trans-unit>
        <trans-unit id="b82ae6d609ba5f4bff538ca99ae907087f8e8c97" translate="yes" xml:space="preserve">
          <source>This pair of commands will push a new element on the list, while making sure that the list will not grow larger than 100 elements. This is very useful when using Redis to store logs for example. It is important to note that when used in this way &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; is an O(1) operation because in the average case just one element is removed from the tail of the list.</source>
          <target state="translated">Este par de comandos empujar&amp;aacute; un nuevo elemento en la lista, mientras se asegura de que la lista no supere los 100 elementos. Esto es muy &amp;uacute;til cuando se usa Redis para almacenar registros, por ejemplo. Es importante notar que cuando se usa de esta manera, &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; es una operaci&amp;oacute;n O (1) porque en el caso promedio solo se elimina un elemento de la cola de la lista.</target>
        </trans-unit>
        <trans-unit id="80b9715de053267e5fffa59b0b1112d991e9ba3f" translate="yes" xml:space="preserve">
          <source>This pattern is easily modified to use counters using &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; instead of lists using &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;.</source>
          <target state="translated">Este patr&amp;oacute;n se modifica f&amp;aacute;cilmente para usar contadores usando &lt;a href=&quot;incr&quot;&gt;INCR en&lt;/a&gt; lugar de listas usando &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d386987d572848d3712f1ff810e5567134c02087" translate="yes" xml:space="preserve">
          <source>This simple pattern can be extended in many ways:</source>
          <target state="translated">Este simple patrón puede extenderse de muchas maneras:</target>
        </trans-unit>
        <trans-unit id="92785c4b9f557c4d2558a4fa95a80f3ac27c63a5" translate="yes" xml:space="preserve">
          <source>This subcommand is the reverse of &lt;code&gt;MIGRATING&lt;/code&gt;, and prepares the destination node to import keys from the specified source node. The command only works if the node is not already owner of the specified hash slot.</source>
          <target state="translated">Este subcomando es el reverso de &lt;code&gt;MIGRATING&lt;/code&gt; y prepara el nodo de destino para importar claves desde el nodo de origen especificado. El comando solo funciona si el nodo a&amp;uacute;n no es propietario de la ranura de hash especificada.</target>
        </trans-unit>
        <trans-unit id="3af1b4ceac0630f2f07d73ce38551a82afebcee6" translate="yes" xml:space="preserve">
          <source>This subcommand just clears migrating / importing state from the slot. It is mainly used to fix a cluster stuck in a wrong state by &lt;code&gt;redis-trib fix&lt;/code&gt;. Normally the two states are cleared automatically at the end of the migration using the &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; subcommand as explained in the next section.</source>
          <target state="translated">Este subcomando simplemente borra el estado de migraci&amp;oacute;n / importaci&amp;oacute;n de la ranura. Se utiliza principalmente para reparar un cl&amp;uacute;ster atascado en un estado incorrecto mediante la &lt;code&gt;redis-trib fix&lt;/code&gt; de redistribuci&amp;oacute;n . Normalmente, los dos estados se borran autom&amp;aacute;ticamente al final de la migraci&amp;oacute;n mediante el &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; como se explica en la siguiente secci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9fe3e638e8830d97f18b8e18e7bb1f71a19b5a85" translate="yes" xml:space="preserve">
          <source>This subcommand sets a slot to &lt;em&gt;migrating&lt;/em&gt; state. In order to set a slot in this state, the node receiving the command must be the hash slot owner, otherwise an error is returned.</source>
          <target state="translated">Este subcomando establece una ranura para el estado de &lt;em&gt;migraci&amp;oacute;n&lt;/em&gt; . Para establecer una ranura en este estado, el nodo que recibe el comando debe ser el propietario de la ranura hash; de lo contrario, se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="edb8d5f6aeacab24056a48e5cdeee519f5cf870a" translate="yes" xml:space="preserve">
          <source>This way clients are moved away from the old master to the new master atomically and only when the replica that is turning into the new master has processed all of the replication stream from the old master.</source>
          <target state="translated">De esta manera los clientes son trasladados del antiguo maestro al nuevo maestro atómicamente y sólo cuando la réplica que se está convirtiendo en el nuevo maestro ha procesado todo el flujo de la réplica del antiguo maestro.</target>
        </trans-unit>
        <trans-unit id="eabc7eeeb462a96b3b77723425f464bf9ccbef27" translate="yes" xml:space="preserve">
          <source>This way we have a 60 second window to inform all the nodes in the cluster that we want to remove a node.</source>
          <target state="translated">De esta manera tenemos una ventana de 60 segundos para informar a todos los nodos del cúmulo que queremos eliminar un nodo.</target>
        </trans-unit>
        <trans-unit id="e40460902c1181221678071c434b045c404620fa" translate="yes" xml:space="preserve">
          <source>This will swap database 0 with database 1. All the clients connected with database 0 will immediately see the new data, exactly like all the clients connected with database 1 will see the data that was formerly of database 0.</source>
          <target state="translated">Esto intercambiará la base de datos 0 con la base de datos 1.Todos los clientes conectados con la base de datos 0 verán inmediatamente los nuevos datos,exactamente como todos los clientes conectados con la base de datos 1 verán los datos que antes eran de la base de datos 0.</target>
        </trans-unit>
        <trans-unit id="d5bfb565b7330daf67d56a70b8a026b02f7b8efa" translate="yes" xml:space="preserve">
          <source>Tip: setting names to connections is a good way to debug connection leaks due to bugs in the application using Redis.</source>
          <target state="translated">Consejo:establecer nombres para las conexiones es una buena manera de depurar las fugas de conexión debidas a errores en la aplicación usando Redis.</target>
        </trans-unit>
        <trans-unit id="ff53653923ebddab009510a619b44980ec4c2bad" translate="yes" xml:space="preserve">
          <source>To call the command without elements but just the variable name is valid, this will result into no operation performed if the variable already exists, or just the creation of the data structure if the key does not exist (in the latter case 1 is returned).</source>
          <target state="translated">Llamar el comando sin elementos pero sólo el nombre de la variable es válido,esto resultará en que no se realice ninguna operación si la variable ya existe,o sólo la creación de la estructura de datos si la clave no existe (en este último caso se devuelve 1).</target>
        </trans-unit>
        <trans-unit id="480b89cfe665e37f5248f03df59af64d3763158a" translate="yes" xml:space="preserve">
          <source>To continue iterating the two streams I'll call:</source>
          <target state="translated">Para continuar iterando las dos corrientes llamaré:</target>
        </trans-unit>
        <trans-unit id="0314c05fdc90b76eea71abe37038408de3a97e39" translate="yes" xml:space="preserve">
          <source>To create a new cluster ADDSLOTS is used in order to initially setup master nodes splitting the available hash slots among them.</source>
          <target state="translated">Para crear un nuevo grupo se utiliza ADDSLOTS para configurar inicialmente nodos maestros que dividen las ranuras hash disponibles entre ellos.</target>
        </trans-unit>
        <trans-unit id="44bff97be54184d5c7829a3927adcbbc623cd71d" translate="yes" xml:space="preserve">
          <source>To create a new consumer group, use the following form:</source>
          <target state="translated">Para crear un nuevo grupo de consumidores,utilice el siguiente formulario:</target>
        </trans-unit>
        <trans-unit id="89c4cf93004db2e7ed530c2bd4661a6d909ed66e" translate="yes" xml:space="preserve">
          <source>To do so the web application may simply increment a key every time the user performs a page view, creating the key name concatenating the User ID and a string representing the current date.</source>
          <target state="translated">Para ello,la aplicación web puede simplemente incrementar una tecla cada vez que el usuario realiza una vista de página,creando el nombre de la tecla concatenando el ID de usuario y una cadena que representa la fecha actual.</target>
        </trans-unit>
        <trans-unit id="1cc0b81f89f7a87d177e223efdad1ca176855997" translate="yes" xml:space="preserve">
          <source>To do so, just append the &lt;code&gt;MATCH &amp;lt;pattern&amp;gt;&lt;/code&gt; arguments at the end of the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command (it works with all the SCAN family commands).</source>
          <target state="translated">Para hacerlo, simplemente agregue los argumentos &lt;code&gt;MATCH &amp;lt;pattern&amp;gt;&lt;/code&gt; al final del comando &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; (funciona con todos los comandos de la familia SCAN).</target>
        </trans-unit>
        <trans-unit id="a19429ebadf3a92bbb763ace4b10735d927cdb10" translate="yes" xml:space="preserve">
          <source>To just remove a given consumer from a consumer group, the following form is used:</source>
          <target state="translated">Para eliminar un determinado consumidor de un grupo de consumidores,se utiliza el siguiente formulario:</target>
        </trans-unit>
        <trans-unit id="a1bcfc2be035b8699c327e24a90fc65898548599" translate="yes" xml:space="preserve">
          <source>To obtain this behavior the following pattern is used. The process uses an additional &lt;em&gt;control connection&lt;/em&gt; in order to send the &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; command if needed. In the meantime, before running the blocking operation on the other connections, the process runs &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; in order to get the ID associated with that connection. When a new key should be added, or when a key should no longer be monitored, the relevant connection blocking command is aborted by sending &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; in the control connection. The blocking command will return and can be finally reissued.</source>
          <target state="translated">Para obtener este comportamiento se utiliza el siguiente patr&amp;oacute;n. El proceso utiliza una &lt;em&gt;conexi&amp;oacute;n de control&lt;/em&gt; adicional para enviar el comando &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; si es necesario. Mientras tanto, antes de ejecutar la operaci&amp;oacute;n de bloqueo en las otras conexiones, el proceso ejecuta &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; para obtener la ID asociada con esa conexi&amp;oacute;n. Cuando se debe agregar una nueva clave, o cuando una clave ya no se debe monitorear, el comando de bloqueo de conexi&amp;oacute;n relevante se cancela enviando &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; en la conexi&amp;oacute;n de control. El comando de bloqueo regresar&amp;aacute; y finalmente se podr&amp;aacute; volver a emitir.</target>
        </trans-unit>
        <trans-unit id="e2975d597b626d068bf510d43c804ba49212aa56" translate="yes" xml:space="preserve">
          <source>To read the slow log the &lt;strong&gt;SLOWLOG GET&lt;/strong&gt; command is used, that returns every entry in the slow log. It is possible to return only the N most recent entries passing an additional argument to the command (for instance &lt;strong&gt;SLOWLOG GET 10&lt;/strong&gt;).</source>
          <target state="translated">Para leer el registro lento se utiliza el comando &lt;strong&gt;SLOWLOG GET&lt;/strong&gt; , que devuelve todas las entradas del registro lento. Es posible devolver solo las N entradas m&amp;aacute;s recientes pasando un argumento adicional al comando (por ejemplo, &lt;strong&gt;SLOWLOG GET 10&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6601ee6f116ecbd87e015bd821bbd22f955d142" translate="yes" xml:space="preserve">
          <source>To remove multiple fields from a hash in an atomic fashion in earlier versions, use a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block.</source>
          <target state="translated">Para eliminar varios campos de un hash de forma at&amp;oacute;mica en versiones anteriores, use un bloque &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="954b750d48973ad0a7cb6b706834c084a88ef5a0" translate="yes" xml:space="preserve">
          <source>To see how the command actually replies, please check the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command page.</source>
          <target state="translated">Para ver c&amp;oacute;mo responde realmente el comando, consulte la p&amp;aacute;gina de comandos &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="128d3d57cca208c42b2c4a7b17ae1e6da52f3781" translate="yes" xml:space="preserve">
          <source>To use incomplete IDs is valid, like it is valid for &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;. However here the sequence part of the ID, if missing, is always interpreted as zero, so the command:</source>
          <target state="translated">Usar ID incompletos es v&amp;aacute;lido, como es v&amp;aacute;lido para &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; . Sin embargo, aqu&amp;iacute; la parte de secuencia del ID, si falta, siempre se interpreta como cero, por lo que el comando:</target>
        </trans-unit>
        <trans-unit id="1e3281a962e6db2e54e787f796eb7d2b1582389a" translate="yes" xml:space="preserve">
          <source>Transactions</source>
          <target state="translated">Transactions</target>
        </trans-unit>
        <trans-unit id="05bcd8bf68d0a760a4bed95fc64ae0e72369519e" translate="yes" xml:space="preserve">
          <source>Trim an existing list so that it will contain only the specified range of elements specified. Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, where &lt;code&gt;0&lt;/code&gt; is the first element of the list (the head), &lt;code&gt;1&lt;/code&gt; the next element and so on.</source>
          <target state="translated">Recorte una lista existente para que contenga solo el rango especificado de elementos especificados. Tanto el &lt;code&gt;start&lt;/code&gt; como el &lt;code&gt;stop&lt;/code&gt; son &amp;iacute;ndices de base cero, donde &lt;code&gt;0&lt;/code&gt; es el primer elemento de la lista (el encabezado), &lt;code&gt;1&lt;/code&gt; el siguiente elemento y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="035ea855c35c51b7478a5846f77d5b250b944acd" translate="yes" xml:space="preserve">
          <source>Trimming with &lt;strong&gt;MAXLEN&lt;/strong&gt; can be expensive compared to just adding entries with &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;: streams are represented by macro nodes into a radix tree, in order to be very memory efficient. Altering the single macro node, consisting of a few tens of elements, is not optimal. So it is possible to give the command in the following special form:</source>
          <target state="translated">Recortar con &lt;strong&gt;MAXLEN&lt;/strong&gt; puede ser costoso en comparaci&amp;oacute;n con simplemente agregar entradas con &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; : los flujos se representan mediante nodos macro en un &amp;aacute;rbol de base, para que sean muy eficientes en la memoria. La alteraci&amp;oacute;n del &amp;uacute;nico macro nodo, que consta de unas pocas decenas de elementos, no es &amp;oacute;ptimo. Entonces es posible dar el comando en la siguiente forma especial:</target>
        </trans-unit>
        <trans-unit id="e14a8ad523f56508195364d3cf7777e0aa400ca5" translate="yes" xml:space="preserve">
          <source>Turn one of the replicas into a master.</source>
          <target state="translated">Convierte una de las réplicas en un maestro.</target>
        </trans-unit>
        <trans-unit id="c05d6c7408f8cd968f368264498cc9e596a32ec9" translate="yes" xml:space="preserve">
          <source>Two things:</source>
          <target state="translated">Dos cosas:</target>
        </trans-unit>
        <trans-unit id="e7444026086e72c0a3612ef57f7d1a60a1f2e6bb" translate="yes" xml:space="preserve">
          <source>UNLINK</source>
          <target state="translated">UNLINK</target>
        </trans-unit>
        <trans-unit id="c90213724a9be513b13cfb4a4f22bff2d2366de0" translate="yes" xml:space="preserve">
          <source>UNLINK  key [key ...]   Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking.</source>
          <target state="translated">Tecla UNLINK [tecla ...]Borrar una tecla asincrónicamente en otro hilo.De lo contrario es igual que DEL,pero sin bloqueo.</target>
        </trans-unit>
        <trans-unit id="f6b41ba10fad6aa5959ec7f0a7a19cba96c5b205" translate="yes" xml:space="preserve">
          <source>UNSUBSCRIBE</source>
          <target state="translated">UNSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="95bcaac89f05e07fac3ab702ccda65ff3fc1e70d" translate="yes" xml:space="preserve">
          <source>UNSUBSCRIBE  [channel [channel ...]]   Stop listening for messages posted to the given channels</source>
          <target state="translated">DESCONOCER [canal [canal ...]]Deje de escuchar los mensajes enviados a los canales dados</target>
        </trans-unit>
        <trans-unit id="f482f8bdba29a29d8179cb1c81453caec7cd1cd0" translate="yes" xml:space="preserve">
          <source>UNWATCH</source>
          <target state="translated">UNWATCH</target>
        </trans-unit>
        <trans-unit id="04d3f2f1b1533a531f1567d456dcc57dd3e8aaed" translate="yes" xml:space="preserve">
          <source>UNWATCH   Forget about all watched keys</source>
          <target state="translated">Olvídate de todas las llaves vigiladas</target>
        </trans-unit>
        <trans-unit id="8db41e11411c7ef82cbecef613bce2c5a112c279" translate="yes" xml:space="preserve">
          <source>Understanding the low level details of entries deletion</source>
          <target state="translated">Comprensión de los detalles de bajo nivel de la eliminación de entradas</target>
        </trans-unit>
        <trans-unit id="e045488630d8fa5ceda39515242aa38f638d314d" translate="yes" xml:space="preserve">
          <source>Unsubscribes the client from the given channels, or from all of them if none is given.</source>
          <target state="translated">Anula la suscripción del cliente de los canales dados,o de todos ellos si no se da ninguno.</target>
        </trans-unit>
        <trans-unit id="b42e2582f88c39f70296ce6117ecfbf480cdbabb" translate="yes" xml:space="preserve">
          <source>Unsubscribes the client from the given patterns, or from all of them if none is given.</source>
          <target state="translated">Anula la suscripción del cliente de los patrones dados,o de todos ellos si no se da ninguno.</target>
        </trans-unit>
        <trans-unit id="3439e83eddd9b986dc9a370152a22cf7dcf9b189" translate="yes" xml:space="preserve">
          <source>Usage example</source>
          <target state="translated">Ejemplo de uso</target>
        </trans-unit>
        <trans-unit id="1a1ad8288443501b5ab5a375040a56b505cf57da" translate="yes" xml:space="preserve">
          <source>Usage in Redis Cluster</source>
          <target state="translated">Uso en el grupo Redis</target>
        </trans-unit>
        <trans-unit id="4737cd73c3044761cf7011e37fa5eaf2d8409931" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt; to get the rank of an element with the scores ordered from low to high.</source>
          <target state="translated">Utilice &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt; para obtener el rango de un elemento con las puntuaciones ordenadas de menor a mayor.</target>
        </trans-unit>
        <trans-unit id="3fe98e8f5c8ef5cf83f0f54776afcda9d91790a6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;zrevrank&quot;&gt;ZREVRANK&lt;/a&gt; to get the rank of an element with the scores ordered from high to low.</source>
          <target state="translated">Utilice &lt;a href=&quot;zrevrank&quot;&gt;ZREVRANK&lt;/a&gt; para obtener el rango de un elemento con las puntuaciones ordenadas de mayor a menor .</target>
        </trans-unit>
        <trans-unit id="086b66054cfededa52eff107efd5d5738706c626" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; NODE &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; in the source or destination.</source>
          <target state="translated">Utilice &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; NODE &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; en el origen o destino.</target>
        </trans-unit>
        <trans-unit id="7a0d11b9b3a61f9fb375f27d2f543f0531d6044b" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;SIGINT&lt;/code&gt; (Ctrl-C) to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;redis-cli&lt;/code&gt;.</source>
          <target state="translated">Utilice &lt;code&gt;SIGINT&lt;/code&gt; (Ctrl-C) para detener una secuencia de &lt;a href=&quot;monitor&quot;&gt;MONITOR que se&lt;/a&gt; ejecuta a trav&amp;eacute;s de &lt;code&gt;redis-cli&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc749871acc225f7c2c2f7dbee8f21f52bf5c425" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;\&lt;/code&gt; to escape special characters if you want to match them verbatim.</source>
          <target state="translated">Utilice &lt;code&gt;\&lt;/code&gt; para escapar de los caracteres especiales si desea que coincidan literalmente.</target>
        </trans-unit>
        <trans-unit id="33383091ad79a3073386fcd60506a3674101c465" translate="yes" xml:space="preserve">
          <source>Used in this way &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; works as a range query command to obtain entries in a specified time. This is very handy in order to access the history of past events in a stream.</source>
          <target state="translated">Usado de esta manera, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; funciona como un comando de consulta de rango para obtener entradas en un tiempo espec&amp;iacute;fico. Esto es muy &amp;uacute;til para acceder al historial de eventos pasados ​​en una secuencia.</target>
        </trans-unit>
        <trans-unit id="e27cfe4ed4d7ca1d0aa51aec849d7c03662148e4" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block does not make a lot of sense as it would require blocking the entire server in order to execute the block atomically, which in turn does not allow other clients to perform a push operation. For this reason the behavior of &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; inside &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; when the list is empty is to return a &lt;code&gt;nil&lt;/code&gt; multi-bulk reply, which is the same thing that happens when the timeout is reached.</source>
          <target state="translated">Usar &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; dentro de un bloque &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; no tiene mucho sentido, ya que requerir&amp;iacute;a bloquear todo el servidor para ejecutar el bloque de forma at&amp;oacute;mica, lo que a su vez no permite que otros clientes realicen una operaci&amp;oacute;n push. Por esta raz&amp;oacute;n, el comportamiento de &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; dentro de &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; cuando la lista est&amp;aacute; vac&amp;iacute;a es devolver una respuesta &lt;code&gt;nil&lt;/code&gt; m&amp;uacute;ltiples vol&amp;uacute;menes, que es lo mismo que sucede cuando se alcanza el tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="40451af134cf3b4789965e6b5f83160439077efc" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; with the same source and destination key, a client can visit all the elements of an N-elements list, one after the other, in O(N) without transferring the full list from the server to the client using a single &lt;a href=&quot;lrange&quot;&gt;LRANGE&lt;/a&gt; operation.</source>
          <target state="translated">Al usar &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; con la misma clave de origen y destino, un cliente puede visitar todos los elementos de una lista de N elementos, uno tras otro, en O (N) sin transferir la lista completa del servidor al cliente usando una sola operaci&amp;oacute;n &lt;a href=&quot;lrange&quot;&gt;LRANGE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c46dcc4dc3127a722b902a7f0747724ecf4cc482" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;redis.pcall()&lt;/code&gt; no error is raised, but an error object is returned in the format specified above (as a Lua table with an &lt;code&gt;err&lt;/code&gt; field). The script can pass the exact error to the user by returning the error object returned by &lt;code&gt;redis.pcall()&lt;/code&gt;.</source>
          <target state="translated">Al usar &lt;code&gt;redis.pcall()&lt;/code&gt; no se genera ning&amp;uacute;n error, pero se devuelve un objeto de error en el formato especificado anteriormente (como una tabla Lua con un campo &lt;code&gt;err&lt;/code&gt; ). El script puede pasar el error exacto al usuario devolviendo el objeto de error devuelto por &lt;code&gt;redis.pcall()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7101c402265dd964134e35be47f87be29400b051" translate="yes" xml:space="preserve">
          <source>Using Lua debugging functionality or other approaches like altering the meta table used to implement global protections in order to circumvent globals protection is not hard. However it is difficult to do it accidentally. If the user messes with the Lua global state, the consistency of AOF and replication is not guaranteed: don't do it.</source>
          <target state="translated">Utilizar la funcionalidad de depuración de Lua u otros enfoques como alterar la meta tabla utilizada para implementar las protecciones globales con el fin de eludir la protección global no es difícil.Sin embargo,es difícil hacerlo accidentalmente.Si el usuario se mete con el estado global de Lua,la consistencia de AOF y la replicación no está garantizada:no lo hagas.</target>
        </trans-unit>
        <trans-unit id="c6802aa64b9bbaa359e233fb607bd5d022a67930" translate="yes" xml:space="preserve">
          <source>Using SELECT inside scripts</source>
          <target state="translated">Usando SELECT dentro de los guiones</target>
        </trans-unit>
        <trans-unit id="7b026f033d38658299ef9472bd95714c2913c9fc" translate="yes" xml:space="preserve">
          <source>Using blocking list operations it is possible to mount different blocking primitives. For instance for some application you may need to block waiting for elements into a Redis Set, so that as far as a new element is added to the Set, it is possible to retrieve it without resort to polling. This would require a blocking version of &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; that is not available, but using blocking list operations we can easily accomplish this task.</source>
          <target state="translated">Usando operaciones de lista de bloqueo, es posible montar diferentes primitivas de bloqueo. Por ejemplo, para algunas aplicaciones, es posible que deba bloquear los elementos en espera en un conjunto de Redis, de modo que, en la medida en que se agregue un nuevo elemento al conjunto, sea posible recuperarlo sin recurrir al sondeo. Esto requerir&amp;iacute;a una versi&amp;oacute;n de bloqueo de &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; que no est&amp;aacute; disponible, pero usando operaciones de lista de bloqueo podemos realizar esta tarea f&amp;aacute;cilmente.</target>
        </trans-unit>
        <trans-unit id="2d99f941df6a6943dbe83b1a86f2d0fb5e933eb9" translate="yes" xml:space="preserve">
          <source>Using hashes in &lt;code&gt;BY&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt;</source>
          <target state="translated">Usando hashes en &lt;code&gt;BY&lt;/code&gt; y &lt;code&gt;GET&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caf38fc4664bfd78e28567c17c5866f5546d3c41" translate="yes" xml:space="preserve">
          <source>Using other atomic increment/decrement commands like &lt;a href=&quot;decr&quot;&gt;DECR&lt;/a&gt; or &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; it is possible to handle values that may get bigger or smaller depending on the operations performed by the user. Imagine for instance the score of different users in an online game.</source>
          <target state="translated">Usando otros comandos de incremento / decremento at&amp;oacute;mico como &lt;a href=&quot;decr&quot;&gt;DECR&lt;/a&gt; o &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; es posible manejar valores que pueden aumentar o disminuir dependiendo de las operaciones realizadas por el usuario. Imagine, por ejemplo, la puntuaci&amp;oacute;n de diferentes usuarios en un juego en l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="ae6b3b782e1efd8b08b993d2b183d9c7d1c6acfa" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command this is trivial to accomplish, identifying every day with a small progressive integer. For instance day 0 is the first day the application was put online, day 1 the next day, and so forth.</source>
          <target state="translated">Usando el comando &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; esto es trivial de lograr, identificando todos los d&amp;iacute;as con un peque&amp;ntilde;o entero progresivo. Por ejemplo, el d&amp;iacute;a 0 es el primer d&amp;iacute;a en que se puso en l&amp;iacute;nea la solicitud, el d&amp;iacute;a 1 el d&amp;iacute;a siguiente, y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="16ead6dab8e57eff7f107126c73dd3bc75147baa" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;OVERFLOW&lt;/code&gt; command the user is able to fine-tune the behavior of the increment or decrement overflow (or underflow) by specifying one of the following behaviors:</source>
          <target state="translated">Con el comando &lt;code&gt;OVERFLOW&lt;/code&gt; , el usuario puede ajustar el comportamiento del desbordamiento de incremento o decremento (o subdesbordamiento) especificando uno de los siguientes comportamientos:</target>
        </trans-unit>
        <trans-unit id="3de3ec939c3c7b5414f26935285aeca64861fe17" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;WEIGHTS&lt;/code&gt; option, it is possible to specify a multiplication factor for each input sorted set. This means that the score of every element in every input sorted set is multiplied by this factor before being passed to the aggregation function. When &lt;code&gt;WEIGHTS&lt;/code&gt; is not given, the multiplication factors default to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Con la opci&amp;oacute;n &lt;code&gt;WEIGHTS&lt;/code&gt; , es posible especificar un factor de multiplicaci&amp;oacute;n para cada conjunto ordenado de entrada. Esto significa que la puntuaci&amp;oacute;n de cada elemento en cada conjunto ordenado de entrada se multiplica por este factor antes de pasar a la funci&amp;oacute;n de agregaci&amp;oacute;n. Cuando no se da &lt;code&gt;WEIGHTS&lt;/code&gt; , los factores de multiplicaci&amp;oacute;n se establecen por defecto en &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76a0908eb03a0818dec46ad32670924542b96c7e" translate="yes" xml:space="preserve">
          <source>Using the &lt;strong&gt;COUNT&lt;/strong&gt; option it is possible to reduce the number of entries reported. This is a very important feature even if it may look marginal, because it allows, for instance, to model operations such as &lt;em&gt;give me the entry greater or equal to the following&lt;/em&gt;:</source>
          <target state="translated">Usando la opci&amp;oacute;n &lt;strong&gt;COUNT&lt;/strong&gt; es posible reducir el n&amp;uacute;mero de entradas reportadas. Esta es una caracter&amp;iacute;stica muy importante incluso si puede parecer marginal, porque permite, por ejemplo, modelar operaciones como &lt;em&gt;darme la entrada mayor o igual a la siguiente&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="06fddf3650bd5ee5a6ffaab199db0b1e5871cc0a" translate="yes" xml:space="preserve">
          <source>Usually &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; is a fast command, however note that addressing far bits of currently short strings will trigger an allocation that may be more costly than executing the command on bits already existing.</source>
          <target state="translated">Por &lt;a href=&quot;bitfield&quot;&gt;lo&lt;/a&gt; general, BITFIELD es un comando r&amp;aacute;pido, sin embargo, tenga en cuenta que el direccionamiento de bits lejanos de cadenas cortas actualmente desencadenar&amp;aacute; una asignaci&amp;oacute;n que puede ser m&amp;aacute;s costosa que ejecutar el comando en bits ya existentes.</target>
        </trans-unit>
        <trans-unit id="0f5b11ac939e1d71f8708f6f993a15ee8aabd489" translate="yes" xml:space="preserve">
          <source>Valid &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;stop&lt;/em&gt; must start with &lt;code&gt;(&lt;/code&gt; or &lt;code&gt;[&lt;/code&gt;, in order to specify if the range item is respectively exclusive or inclusive. The special values of &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; for &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;stop&lt;/em&gt; have the special meaning or positively infinite and negatively infinite strings, so for instance the command &lt;strong&gt;ZRANGEBYLEX myzset - +&lt;/strong&gt; is guaranteed to return all the elements in the sorted set, if all the elements have the same score.</source>
          <target state="translated">El &lt;em&gt;inicio&lt;/em&gt; y la &lt;em&gt;parada&lt;/em&gt; v&amp;aacute;lidos deben comenzar con &lt;code&gt;(&lt;/code&gt; o &lt;code&gt;[&lt;/code&gt; , para especificar si el elemento de rango es respectivamente exclusivo o inclusivo. Los valores especiales de &lt;code&gt;+&lt;/code&gt; o &lt;code&gt;-&lt;/code&gt; para &lt;em&gt;inicio&lt;/em&gt; y &lt;em&gt;parada&lt;/em&gt; tienen un significado especial o cadenas positivamente infinitas y negativamente infinitas, por lo que para Por ejemplo, el comando &lt;strong&gt;ZRANGEBYLEX myzset - +&lt;/strong&gt; est&amp;aacute; garantizado para devolver todos los elementos en el conjunto ordenado, si todos los elementos tienen la misma puntuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="739d0c927a5b6bf5de3bf0a0a70f11e8b6605c25" translate="yes" xml:space="preserve">
          <source>Valid latitudes are from -85.05112878 to 85.05112878 degrees.</source>
          <target state="translated">Las latitudes válidas son de -85,05112878 a 85,05112878 grados.</target>
        </trans-unit>
        <trans-unit id="11b0745206ed577a4e0cb0212fa3f795e389324d" translate="yes" xml:space="preserve">
          <source>Valid longitudes are from -180 to 180 degrees.</source>
          <target state="translated">Las longitudes válidas son de -180 a 180 grados.</target>
        </trans-unit>
        <trans-unit id="0a554292c4907e31d57221e167caa8ee4a40b176" translate="yes" xml:space="preserve">
          <source>Values are encoded in the same format used by RDB.</source>
          <target state="translated">Los valores están codificados en el mismo formato utilizado por RDB.</target>
        </trans-unit>
        <trans-unit id="4618a25e91c152415cd438c3e4cfbbbca6e51578" translate="yes" xml:space="preserve">
          <source>Variadic push operations such as &lt;code&gt;LPUSH mylist a b c&lt;/code&gt;.</source>
          <target state="translated">Operaciones de empuje variable como &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c26d74df8890b7f659e90425275e4ff437fc0eeb" translate="yes" xml:space="preserve">
          <source>WAIT</source>
          <target state="translated">WAIT</target>
        </trans-unit>
        <trans-unit id="d18dc269ffeeecfef8bf81895f8bdd22c193582a" translate="yes" xml:space="preserve">
          <source>WAIT  numreplicas timeout   Wait for the synchronous replication of all the write commands sent in the context of the current connection</source>
          <target state="translated">ESPERAR el tiempo de espera de las numreplicas Esperar la réplica síncrona de todos los comandos de escritura enviados en el contexto de la conexión actual</target>
        </trans-unit>
        <trans-unit id="f187dbf97ca89e5c15383b3fa7d810b24a33323e" translate="yes" xml:space="preserve">
          <source>WATCH</source>
          <target state="translated">WATCH</target>
        </trans-unit>
        <trans-unit id="e25bec5041d8fb22a63247724e4a52e81a8ea913" translate="yes" xml:space="preserve">
          <source>WATCH  key [key ...]   Watch the given keys to determine execution of the MULTI/EXEC block</source>
          <target state="translated">Tecla WATCH [tecla ...]Observa las teclas dadas para determinar la ejecución del bloque MULTI/EXEC</target>
        </trans-unit>
        <trans-unit id="56f46978b0612f344f2810a30cecbd3f77aeefb8" translate="yes" xml:space="preserve">
          <source>Wait a few seconds to make sure the replicas processed the latest replication stream from the master.</source>
          <target state="translated">Espera unos segundos para asegurarte de que las réplicas procesaron el último flujo de réplicas del maestro.</target>
        </trans-unit>
        <trans-unit id="b8223ad5f27a7a8a75b46110607ef57167d9c89c" translate="yes" xml:space="preserve">
          <source>We can see the idle time in milliseconds (last field) together with the consumer name and the number of pending messages for this specific consumer.</source>
          <target state="translated">Podemos ver el tiempo de inactividad en milisegundos (último campo)junto con el nombre del consumidor y el número de mensajes pendientes para este consumidor específico.</target>
        </trans-unit>
        <trans-unit id="2ddfe3583c26159af60de3cb1f92817c0ca754e3" translate="yes" xml:space="preserve">
          <source>We contact A, and send &lt;code&gt;CLUSTER FORGET D&lt;/code&gt;.</source>
          <target state="translated">Estamos en contacto con A, y enviar &lt;code&gt;CLUSTER FORGET D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="175f4045524acb2363e7d02e99215c3355819a20" translate="yes" xml:space="preserve">
          <source>We document the old pattern anyway because certain existing implementations link to this page as a reference. Moreover it is an interesting example of how Redis commands can be used in order to mount programming primitives.</source>
          <target state="translated">Documentamos el viejo patrón de todos modos porque ciertas implementaciones existentes enlazan con esta página como referencia.Además es un ejemplo interesante de cómo los comandos de Redis pueden ser usados para montar primitivas de programación.</target>
        </trans-unit>
        <trans-unit id="24ad35b89e9d8d01f0e23d94bc81a67340dbc7fe" translate="yes" xml:space="preserve">
          <source>We expect the pending entries list for the consumer group &lt;code&gt;group55&lt;/code&gt; to have a message right now: consumer named &lt;code&gt;consumer-123&lt;/code&gt; fetched the message without acknowledging its processing. The simples &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; form will give us this information:</source>
          <target state="translated">Esperamos que la lista de entradas pendientes para el grupo de consumidores &lt;code&gt;group55&lt;/code&gt; tenga un mensaje en este momento: el consumidor llamado &lt;code&gt;consumer-123&lt;/code&gt; obtuvo el mensaje sin reconocer su procesamiento. El formulario &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; simple nos dar&amp;aacute; esta informaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="6d01fafe80c584d0f494c7517078342535ee8c39" translate="yes" xml:space="preserve">
          <source>We provide two implementations of this pattern using &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;, where we assume that the problem to solve is limiting the number of API calls to a maximum of &lt;em&gt;ten requests per second per IP address&lt;/em&gt;.</source>
          <target state="translated">Proporcionamos dos implementaciones de este patr&amp;oacute;n usando &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; , donde asumimos que el problema a resolver es limitar el n&amp;uacute;mero de llamadas API a un m&amp;aacute;ximo de &lt;em&gt;diez solicitudes por segundo por direcci&amp;oacute;n IP&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d39cbf389a8217cb67f7dd5d0a50fcf7520d5e84" translate="yes" xml:space="preserve">
          <source>What Earth model does it use?</source>
          <target state="translated">¿Qué modelo de la Tierra utiliza?</target>
        </trans-unit>
        <trans-unit id="d5de6352b29f76f537345f915ed0618a8360f168" translate="yes" xml:space="preserve">
          <source>What happens when a message is delivered to a consumer?</source>
          <target state="translated">¿Qué sucede cuando se entrega un mensaje a un consumidor?</target>
        </trans-unit>
        <trans-unit id="4b828789b0a2fa7b2f683b315ddc274dc28a6251" translate="yes" xml:space="preserve">
          <source>What key is served first? What client? What element? Priority ordering details.</source>
          <target state="translated">¿Qué llave se sirve primero? ¿Qué cliente? ¿Qué elemento? Los detalles de la orden de prioridad.</target>
        </trans-unit>
        <trans-unit id="f499f72f01c19b0e0f365138de1b27353f31d411" translate="yes" xml:space="preserve">
          <source>What we are doing here is sending the seed of the PRNG as one of the arguments. This way the script output will be the same given the same arguments, but we are changing one of the arguments in every invocation, generating the random seed client-side. The seed will be propagated as one of the arguments both in the replication link and in the Append Only File, guaranteeing that the same changes will be generated when the AOF is reloaded or when the replica processes the script.</source>
          <target state="translated">Lo que estamos haciendo aquí es enviar la semilla del PRNG como uno de los argumentos.De esta manera la salida del guión será la misma dado los mismos argumentos,pero estamos cambiando uno de los argumentos en cada invocación,generando la semilla aleatoria del lado del cliente.La semilla se propagará como uno de los argumentos tanto en el enlace de la réplica como en el Append Only File,garantizando que se generen los mismos cambios cuando se recargue el AOF o cuando la réplica procese el script.</target>
        </trans-unit>
        <trans-unit id="e090d8414ebbcd496638a6ff2a198537439a58f0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; causes a client to block and a non-zero timeout is specified, the client will unblock returning a &lt;code&gt;nil&lt;/code&gt; multi-bulk value when the specified timeout has expired without a push operation against at least one of the specified keys.</source>
          <target state="translated">Cuando &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; hace que un cliente se bloquee y se especifica un tiempo de espera distinto de cero, el cliente se desbloquear&amp;aacute; y devolver&amp;aacute; un valor de volumen m&amp;uacute;ltiple &lt;code&gt;nil&lt;/code&gt; cuando el tiempo de espera especificado haya expirado sin una operaci&amp;oacute;n de inserci&amp;oacute;n contra al menos una de las claves especificadas.</target>
        </trans-unit>
        <trans-unit id="0e47f90ed1e7d31987fee0397f45defb59cb883a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; is called, if at least one of the specified keys contains a non-empty list, an element is popped from the head of the list and returned to the caller together with the &lt;code&gt;key&lt;/code&gt; it was popped from.</source>
          <target state="translated">Cuando se llama a &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; , si al menos una de las claves especificadas contiene una lista no vac&amp;iacute;a, se extrae un elemento del encabezado de la lista y se devuelve a la persona que llama junto con la &lt;code&gt;key&lt;/code&gt; que se extrajo.</target>
        </trans-unit>
        <trans-unit id="3ffbe0c44e6e4875a18442896a1a516c63beb5c0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; returns an element to the client, it also removes the element from the list. This means that the element only exists in the context of the client: if the client crashes while processing the returned element, it is lost forever.</source>
          <target state="translated">Cuando &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; devuelve un elemento al cliente, tambi&amp;eacute;n elimina el elemento de la lista. Esto significa que el elemento solo existe en el contexto del cliente: si el cliente falla mientras procesa el elemento devuelto, se pierde para siempre.</target>
        </trans-unit>
        <trans-unit id="3307fa3db89d3a63433cacfb49df9dc54982fc40" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; is called with a single key, performances are excellent even if in theory constant times to process a dense HyperLogLog are high. This is possible because the &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; uses caching in order to remember the cardinality previously computed, that rarely changes because most &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; operations will not update any register. Hundreds of operations per second are possible.</source>
          <target state="translated">Cuando se llama a &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; con una sola clave, el rendimiento es excelente incluso si, en teor&amp;iacute;a, los tiempos constantes para procesar un HyperLogLog denso son altos. Esto es posible porque &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; usa el almacenamiento en cach&amp;eacute; para recordar la cardinalidad calculada previamente, que rara vez cambia porque la mayor&amp;iacute;a de &lt;a href=&quot;pfadd&quot;&gt;las&lt;/a&gt; operaciones de PFADD no actualizar&amp;aacute;n ning&amp;uacute;n registro. Son posibles cientos de operaciones por segundo.</target>
        </trans-unit>
        <trans-unit id="444f34b1316be2c4c966434546394e88b456fb26" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; is called with multiple keys, an on-the-fly merge of the HyperLogLogs is performed, which is slow, moreover the cardinality of the union can't be cached, so when used with multiple keys &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; may take a time in the order of magnitude of the millisecond, and should be not abused.</source>
          <target state="translated">Cuando se llama a &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; con varias claves, se realiza una fusi&amp;oacute;n sobre la marcha de los HyperLogLogs, lo cual es lento; adem&amp;aacute;s, la cardinalidad de la uni&amp;oacute;n no se puede almacenar en cach&amp;eacute;, por lo que cuando se utiliza con varias claves, &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; puede tardar un tiempo en orden de magnitud del milisegundo, y no debe abusarse.</target>
        </trans-unit>
        <trans-unit id="ae40c728758622e3e05b808d2977fa5e75fc7ad7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; returns, all the previous write commands sent in the context of the current connection are guaranteed to be received by the number of replicas returned by &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">Cuando &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; regresa, se garantiza que todos los comandos de escritura anteriores enviados en el contexto de la conexi&amp;oacute;n actual ser&amp;aacute;n recibidos por el n&amp;uacute;mero de r&amp;eacute;plicas devueltas por &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7c1b9d40216023a71c49cec036bd3ade97bf1d5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; is called with just a key name and a consumer group name, it just outputs a summary about the pending messages in a given consumer group. In the following example, we create a consumed group and immediatelycreate a pending message by reading from the group with &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;.</source>
          <target state="translated">Cuando se llama a &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; con solo un nombre de clave y un nombre de grupo de consumidores, solo genera un resumen sobre los mensajes pendientes en un grupo de consumidores determinado. En el siguiente ejemplo, creamos un grupo consumido e inmediatamente creamos un mensaje pendiente leyendo del grupo con &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="959f6691503047ebdaf048475a2e4894baff8e2c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;key&lt;/code&gt; does not exist, it is considered an empty list and no operation is performed.</source>
          <target state="translated">Cuando la &lt;code&gt;key&lt;/code&gt; no existe, se considera una lista vac&amp;iacute;a y no se realiza ninguna operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f26b70cbb6ddaf25fda084b2d1ba7e95d9bf1a10" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mylist&lt;/code&gt; contains string values and you want to sort them lexicographically, use the &lt;code&gt;ALPHA&lt;/code&gt; modifier:</source>
          <target state="translated">Cuando &lt;code&gt;mylist&lt;/code&gt; contiene valores de cadena y desea ordenarlos lexicogr&amp;aacute;ficamente, use el modificador &lt;code&gt;ALPHA&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9d0715abe5491cb122c13f7521d00e6b24a5e5a2" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;offset&lt;/em&gt; is beyond the string length, the string is assumed to be a contiguous space with 0 bits. When &lt;em&gt;key&lt;/em&gt; does not exist it is assumed to be an empty string, so &lt;em&gt;offset&lt;/em&gt; is always out of range and the value is also assumed to be a contiguous space with 0 bits.</source>
          <target state="translated">Cuando el &lt;em&gt;desplazamiento&lt;/em&gt; supera la longitud de la cadena, se supone que la cadena es un espacio contiguo con 0 bits. Cuando la &lt;em&gt;clave&lt;/em&gt; no existe, se supone que es una cadena vac&amp;iacute;a, por lo que el &lt;em&gt;desplazamiento&lt;/em&gt; siempre est&amp;aacute; fuera de rango y tambi&amp;eacute;n se supone que el valor es un espacio contiguo con 0 bits.</target>
        </trans-unit>
        <trans-unit id="f85f9f72f3f17f321115fbc108ebe9d711391d76" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;BLOCK&lt;/strong&gt; is used, on timeout a null reply is returned.</source>
          <target state="translated">Cuando se usa &lt;strong&gt;BLOQUEO&lt;/strong&gt; , en el tiempo de espera se devuelve una respuesta nula.</target>
        </trans-unit>
        <trans-unit id="809ce70a8740c0bdd1b823e923a32b6a4fa01194" translate="yes" xml:space="preserve">
          <source>When Redis frees memory, the memory is given back to the allocator, and the allocator may or may not give the memory back to the system. There may be a discrepancy between the &lt;code&gt;used_memory&lt;/code&gt; value and memory consumption as reported by the operating system. It may be due to the fact memory has been used and released by Redis, but not given back to the system. The &lt;code&gt;used_memory_peak&lt;/code&gt; value is generally useful to check this point.</source>
          <target state="translated">Cuando Redis libera memoria, la memoria se devuelve al asignador y el asignador puede o no devolver la memoria al sistema. Puede haber una discrepancia entre el valor &lt;code&gt;used_memory&lt;/code&gt; y el consumo de memoria seg&amp;uacute;n lo informado por el sistema operativo. Puede deberse al hecho de que Redis ha utilizado y liberado la memoria, pero no la ha devuelto al sistema. El valor &lt;code&gt;used_memory_peak&lt;/code&gt; generalmente es &amp;uacute;til para verificar este punto.</target>
        </trans-unit>
        <trans-unit id="a77ebc9bc339051ab15e8f4d5cee8fc3e151c5ec" translate="yes" xml:space="preserve">
          <source>When a client is blocking for multiple keys at the same time, and elements are available at the same time in multiple keys (because of a transaction or a Lua script added elements to multiple lists), the client will be unblocked using the first key that received a push operation (assuming it has enough elements to serve our client, as there may be other clients as well waiting for this key). Basically after the execution of every command Redis will run a list of all the keys that received data AND that have at least a client blocked. The list is ordered by new element arrival time, from the first key that received data to the last. For every key processed, Redis will serve all the clients waiting for that key in a FIFO fashion, as long as there are elements in this key. When the key is empty or there are no longer clients waiting for this key, the next key that received new data in the previous command / transaction / script is processed, and so forth.</source>
          <target state="translated">Cuando un cliente está bloqueando para varias llaves al mismo tiempo,y hay elementos disponibles al mismo tiempo en varias llaves (debido a una transacción o a que un script de Lua añadió elementos a varias listas),el cliente se desbloqueará usando la primera llave que recibió una operación de empuje (suponiendo que tenga suficientes elementos para servir a nuestro cliente,ya que puede haber otros clientes también esperando esta llave).Básicamente,después de la ejecución de cada comando,Redis ejecutará una lista de todas las llaves que recibieron datos Y que tienen al menos un cliente bloqueado.La lista está ordenada por el tiempo de llegada de los nuevos elementos,desde la primera llave que recibió datos hasta la última.Por cada llave procesada,Redis servirá a todos los clientes que esperan esa llave en forma FIFO,siempre y cuando haya elementos en esa llave.Cuando la llave está vacía o ya no hay clientes esperando esta llave,se procesa la siguiente llave que recibió nuevos datos en el comando/transacción/script anterior,y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="7d23b0c61f873eb2f0adb0d7f8fda251e5e64352" translate="yes" xml:space="preserve">
          <source>When a count argument is passed and is positive, the elements are returned as if every selected element is removed from the set (like the extraction of numbers in the game of Bingo). However elements are &lt;strong&gt;not removed&lt;/strong&gt; from the Set. So basically:</source>
          <target state="translated">Cuando se pasa un argumento de conteo y es positivo, los elementos se devuelven como si todos los elementos seleccionados se eliminaran del conjunto (como la extracci&amp;oacute;n de n&amp;uacute;meros en el juego de Bingo). Sin embargo, los elementos &lt;strong&gt;no se eliminan&lt;/strong&gt; del Conjunto. As&amp;iacute; que b&amp;aacute;sicamente:</target>
        </trans-unit>
        <trans-unit id="a2d1889d163d82c06bb4149e999c017776739656" translate="yes" xml:space="preserve">
          <source>When a given node receives a &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; message, the node specified in the command still does not know the node we sent the command to. So in order for the node to force the receiver to accept it as a trusted node, it sends a &lt;code&gt;MEET&lt;/code&gt; packet instead of a &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt; packet. The two packets have exactly the same format, but the former forces the receiver to acknowledge the node as trusted.</source>
          <target state="translated">Cuando un nodo determinado recibe un mensaje &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; , el nodo especificado en el comando a&amp;uacute;n no conoce el nodo al que enviamos el comando. Entonces, para que el nodo obligue al receptor a aceptarlo como un nodo confiable, env&amp;iacute;a un paquete &lt;code&gt;MEET&lt;/code&gt; en lugar de un paquete &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt; . Los dos paquetes tienen exactamente el mismo formato, pero el primero obliga al receptor a reconocer el nodo como confiable.</target>
        </trans-unit>
        <trans-unit id="f668069a7ed39c5fa2f0a02a85e379414dcc1840" translate="yes" xml:space="preserve">
          <source>When a script reaches the timeout it is not automatically terminated by Redis since this violates the contract Redis has with the scripting engine to ensure that scripts are atomic. Interrupting a script means potentially leaving the dataset with half-written data. For this reasons when a script executes for more than the specified time the following happens:</source>
          <target state="translated">Cuando un script llega al timeout no es automáticamente terminado por Redis ya que esto viola el contrato que Redis tiene con el motor de scripting para asegurar que los scripts son atómicos.Interrumpir un guión significa dejar potencialmente el conjunto de datos con datos a medio escribir.Por esta razón,cuando un script se ejecuta durante más tiempo del especificado,ocurre lo siguiente:</target>
        </trans-unit>
        <trans-unit id="cde95f95d0ec693d9bb8d3a4357b1cf9cddcf9a4" translate="yes" xml:space="preserve">
          <source>When a slot is set in importing state, the node changes behavior in the following way:</source>
          <target state="translated">Cuando una ranura se pone en estado de importación,el nodo cambia su comportamiento de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="1ab4dff88086b32e89a46c83f950f054d0000789" translate="yes" xml:space="preserve">
          <source>When a slot is set in migrating state, the node changes behavior in the following way:</source>
          <target state="translated">Cuando una ranura se pone en estado de migración,el nodo cambia su comportamiento de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="3284f9a656f1f04af61fdd0f810ae8e4e5c1d186" translate="yes" xml:space="preserve">
          <source>When a user specified an explicit ID to &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;, the minimum valid ID is &lt;code&gt;0-1&lt;/code&gt;, and the user &lt;em&gt;must&lt;/em&gt; specify an ID which is greater than any other ID currently inside the stream, otherwise the command will fail. Usually resorting to specific IDs is useful only if you have another system generating unique IDs (for instance an SQL table) and you really want the Redis stream IDs to match the one of this other system.</source>
          <target state="translated">Cuando un usuario especific&amp;oacute; una ID expl&amp;iacute;cita para &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; , la ID m&amp;iacute;nima v&amp;aacute;lida es &lt;code&gt;0-1&lt;/code&gt; , y el usuario &lt;em&gt;debe&lt;/em&gt; especificar una ID que sea mayor que cualquier otra ID actualmente dentro de la secuencia, de lo contrario, el comando fallar&amp;aacute;. Por lo general, recurrir a ID espec&amp;iacute;ficos es &amp;uacute;til solo si tiene otro sistema que genera ID &amp;uacute;nicos (por ejemplo, una tabla SQL) y realmente desea que los ID de transmisi&amp;oacute;n de Redis coincidan con el de este otro sistema.</target>
        </trans-unit>
        <trans-unit id="73e413531f8bf0cf9989059d75854e4e21a7c89c" translate="yes" xml:space="preserve">
          <source>When additional information is returned as an array of arrays for each item, the first item in the sub-array is always the name of the returned item. The other information is returned in the following order as successive elements of the sub-array.</source>
          <target state="translated">Cuando se devuelve información adicional como una matriz de matrices para cada artículo,el primer artículo de la submatriz es siempre el nombre del artículo devuelto.El resto de la información se devuelve en el siguiente orden como elementos sucesivos del subconjunto.</target>
        </trans-unit>
        <trans-unit id="be9afd55a1e1d3fc899a88fd79a4b6ee3fbec378" translate="yes" xml:space="preserve">
          <source>When all the elements in a sorted set are inserted with the same score, in order to force lexicographical ordering, this command removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; between the lexicographical range specified by &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">Cuando todos los elementos de un conjunto ordenado se insertan con la misma puntuaci&amp;oacute;n, para forzar el orden lexicogr&amp;aacute;fico, este comando elimina todos los elementos del conjunto ordenado almacenados en la &lt;code&gt;key&lt;/code&gt; entre el rango lexicogr&amp;aacute;fico especificado por &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd76dd5d921fc34f3442cd7642256fbd8941afbc" translate="yes" xml:space="preserve">
          <source>When all the elements in a sorted set are inserted with the same score, in order to force lexicographical ordering, this command returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a value between &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt;.</source>
          <target state="translated">Cuando todos los elementos de un conjunto ordenado se insertan con la misma puntuaci&amp;oacute;n, para forzar el orden lexicogr&amp;aacute;fico, este comando devuelve todos los elementos del conjunto ordenado en &lt;code&gt;key&lt;/code&gt; con un valor entre &lt;code&gt;max&lt;/code&gt; y &lt;code&gt;min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2590ee8dbf1a775ba21f5b275d103b663a7a9f2" translate="yes" xml:space="preserve">
          <source>When all the elements in a sorted set are inserted with the same score, in order to force lexicographical ordering, this command returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a value between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">Cuando todos los elementos de un conjunto ordenado se insertan con la misma puntuaci&amp;oacute;n, para forzar el orden lexicogr&amp;aacute;fico, este comando devuelve todos los elementos del conjunto ordenado en &lt;code&gt;key&lt;/code&gt; con un valor entre &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f4b1912a39011d1373563dbfdd4b007dbbdbf0f" translate="yes" xml:space="preserve">
          <source>When all the elements in a sorted set are inserted with the same score, in order to force lexicographical ordering, this command returns the number of elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a value between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">Cuando todos los elementos de un conjunto ordenado se insertan con la misma puntuaci&amp;oacute;n, para forzar el orden lexicogr&amp;aacute;fico, este comando devuelve el n&amp;uacute;mero de elementos del conjunto ordenado en &lt;code&gt;key&lt;/code&gt; con un valor entre &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="214d2973a964b620543f0b2c9d61586a0fa471ed" translate="yes" xml:space="preserve">
          <source>When an operation is performed between strings having different lengths, all the strings shorter than the longest string in the set are treated as if they were zero-padded up to the length of the longest string.</source>
          <target state="translated">Cuando se realiza una operación entre cuerdas de diferente longitud,todas las cuerdas más cortas que la más larga del conjunto se tratan como si no tuvieran relleno hasta la longitud de la cuerda más larga.</target>
        </trans-unit>
        <trans-unit id="d8995cfed0f1d150bee751108bcb5c155a2e3543" translate="yes" xml:space="preserve">
          <source>When any other error is returned (starting with &lt;code&gt;ERR&lt;/code&gt;) &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; guarantees that the key is still only present in the originating instance (unless a key with the same name was also &lt;em&gt;already&lt;/em&gt; present on the target instance).</source>
          <target state="translated">Cuando se devuelve cualquier otro error (comenzando con &lt;code&gt;ERR&lt;/code&gt; ), &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; garantiza que la clave todav&amp;iacute;a est&amp;aacute; presente solo en la instancia de origen (a menos que una clave con el mismo nombre &lt;em&gt;ya&lt;/em&gt; estuviera presente en la instancia de destino).</target>
        </trans-unit>
        <trans-unit id="59dce897cfc9b463bf95d80aa9d3607a1c4cfc5b" translate="yes" xml:space="preserve">
          <source>When blocking sometimes we want to receive just entries that are added to the stream via &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; starting from the moment we block. In such a case we are not interested in the history of already added entries. For this use case, we would have to check the stream top element ID, and use such ID in the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command line. This is not clean and requires to call other commands, so instead it is possible to use the special &lt;code&gt;$&lt;/code&gt; ID to signal the stream that we want only the new things.</source>
          <target state="translated">Al bloquear, a veces queremos recibir solo las entradas que se agregan a la transmisi&amp;oacute;n a trav&amp;eacute;s de &lt;a href=&quot;xadd&quot;&gt;XADD a&lt;/a&gt; partir del momento en que bloqueamos. En tal caso, no nos interesa el historial de entradas ya agregadas. Para este caso de uso, tendr&amp;iacute;amos que verificar el ID del elemento superior de la secuencia y usar dicho ID en la l&amp;iacute;nea de comando &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; . Esto no est&amp;aacute; limpio y requiere llamar a otros comandos, por lo que en su lugar es posible usar el &lt;code&gt;$&lt;/code&gt; ID especial para indicarle al flujo que solo queremos las cosas nuevas.</target>
        </trans-unit>
        <trans-unit id="33d7951c442b650c3125b1a271b194606894e7f6" translate="yes" xml:space="preserve">
          <source>When called with a single key, returns the approximated cardinality computed by the HyperLogLog data structure stored at the specified variable, which is 0 if the variable does not exist.</source>
          <target state="translated">Cuando se llama con una sola clave,devuelve la cardinalidad aproximada calculada por la estructura de datos del HyperLogLog almacenada en la variable especificada,que es 0 si la variable no existe.</target>
        </trans-unit>
        <trans-unit id="02d2ede7620c8fbb26280883d152859e2e8b0736" translate="yes" xml:space="preserve">
          <source>When called with either &lt;code&gt;OFF&lt;/code&gt; or &lt;code&gt;SKIP&lt;/code&gt; subcommands, no reply is made. When called with &lt;code&gt;ON&lt;/code&gt;:</source>
          <target state="translated">Cuando se llama con los subcomandos &lt;code&gt;OFF&lt;/code&gt; o &lt;code&gt;SKIP&lt;/code&gt; , no se responde. Cuando se llama con &lt;code&gt;ON&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ee3a6c041867efc13c8b4f83dd382ea7d3060bfe" translate="yes" xml:space="preserve">
          <source>When called with just the &lt;code&gt;key&lt;/code&gt; argument, return a random element from the set value stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">Cuando se llama solo con el argumento &lt;code&gt;key&lt;/code&gt; , devuelve un elemento aleatorio del valor establecido almacenado en &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9933aee5d35c10f2ec0bacf3c455dca3f87eee6" translate="yes" xml:space="preserve">
          <source>When called with just the key argument, the operation is similar to &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;, however while &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; also removes the randomly selected element from the set, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; will just return a random element without altering the original set in any way.</source>
          <target state="translated">Cuando se llama solo con el argumento clave, la operaci&amp;oacute;n es similar a &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; , sin embargo, mientras que &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; tambi&amp;eacute;n elimina el elemento seleccionado al azar del conjunto, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; simplemente devolver&amp;aacute; un elemento aleatorio sin alterar el conjunto original de ninguna manera.</target>
        </trans-unit>
        <trans-unit id="f0a06926536c4bfbb3475ac826ef5e31a277c149" translate="yes" xml:space="preserve">
          <source>When called with multiple keys, returns the approximated cardinality of the union of the HyperLogLogs passed, by internally merging the HyperLogLogs stored at the provided keys into a temporary HyperLogLog.</source>
          <target state="translated">Cuando se llama con múltiples claves,devuelve la cardinalidad aproximada de la unión de los HyperLogLogs pasados,fusionando internamente los HyperLogLogs almacenados en las claves proporcionadas en un HyperLogLog temporal.</target>
        </trans-unit>
        <trans-unit id="c43b199a8b6126e51cae18d313987c74e4d69444" translate="yes" xml:space="preserve">
          <source>When called with the filter / value format:</source>
          <target state="translated">Cuando se llama con el formato de filtro/valor:</target>
        </trans-unit>
        <trans-unit id="a261810e42aa1178ca1783bc300c9115eb921b1b" translate="yes" xml:space="preserve">
          <source>When called with the three arguments format:</source>
          <target state="translated">Cuando se le llama con el formato de tres argumentos:</target>
        </trans-unit>
        <trans-unit id="15ee5d9a35b05e51bf29ade952f93ee29411c4e0" translate="yes" xml:space="preserve">
          <source>When global variable access is attempted the script is terminated and EVAL returns with an error:</source>
          <target state="translated">Cuando se intenta el acceso a la variable global,el guión se termina y EVAL vuelve con un error:</target>
        </trans-unit>
        <trans-unit id="2c2bdb6f636cad91fb2bda4ee23fcc769f080cfa" translate="yes" xml:space="preserve">
          <source>When instead the count is negative, the behavior changes and the extraction happens as if you put the extracted element inside the bag again after every extraction, so repeated elements are possible, and the number of elements requested is always returned as we can repeat the same elements again and again, with the exception of an empty Set (non existing key) that will always produce an empty array as a result.</source>
          <target state="translated">Cuando en cambio el recuento es negativo,el comportamiento cambia y la extracción ocurre como si se volviera a meter el elemento extraído dentro de la bolsa después de cada extracción,por lo que es posible repetir los elementos,y siempre se devuelve el número de elementos solicitados ya que podemos repetir los mismos elementos una y otra vez,con la excepción de un Set vacío (clave no existente)que siempre producirá un array vacío como resultado.</target>
        </trans-unit>
        <trans-unit id="1aba699431bcc9ad54084b96f70dd3cfe9726c45" translate="yes" xml:space="preserve">
          <source>When iterating Sets encoded as intsets (small sets composed of just integers), or Hashes and Sorted Sets encoded as ziplists (small hashes and sets composed of small individual values), usually all the elements are returned in the first &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; call regardless of the COUNT value.</source>
          <target state="translated">Al iterar Sets codificados como intsets (peque&amp;ntilde;os conjuntos compuestos solo de enteros), o Hashes y Conjuntos ordenados codificados como tirolinas (peque&amp;ntilde;os hashes y conjuntos compuestos de peque&amp;ntilde;os valores individuales), generalmente todos los elementos se devuelven en la primera llamada de &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; independientemente del COUNT valor.</target>
        </trans-unit>
        <trans-unit id="09782d2a99fb48b7bc37bf122ec011fdbf6f0ff9" translate="yes" xml:space="preserve">
          <source>When iterating the key space, or a Set, Hash or Sorted Set that is big enough to be represented by a hash table, assuming no &lt;strong&gt;MATCH&lt;/strong&gt; option is used, the server will usually return &lt;em&gt;count&lt;/em&gt; or a bit more than &lt;em&gt;count&lt;/em&gt; elements per call. Please check the &lt;em&gt;why SCAN may return all the elements at once&lt;/em&gt; section later in this document.</source>
          <target state="translated">Cuando se itera el espacio clave, o un Conjunto, Hash o Conjunto ordenado que es lo suficientemente grande como para ser representado por una tabla hash, asumiendo que no se usa la opci&amp;oacute;n &lt;strong&gt;MATCH&lt;/strong&gt; , el servidor generalmente devolver&amp;aacute; el &lt;em&gt;recuento&lt;/em&gt; o un poco m&amp;aacute;s que el &lt;em&gt;recuento de&lt;/em&gt; elementos por llamada. Consulte la secci&amp;oacute;n &lt;em&gt;por qu&amp;eacute; SCAN puede devolver todos los elementos a la vez&lt;/em&gt; m&amp;aacute;s adelante en este documento.</target>
        </trans-unit>
        <trans-unit id="71c7e014fcd0d8cb63ba492ae27d6b928bbde099" translate="yes" xml:space="preserve">
          <source>When left unspecified, the default value for &lt;code&gt;count&lt;/code&gt; is 1. Specifying a &lt;code&gt;count&lt;/code&gt; value that is higher than the sorted set's cardinality will not produce an error. When returning multiple elements, the one with the highest score will be the first, followed by the elements with lower scores.</source>
          <target state="translated">Cuando no se especifica, el valor predeterminado para el &lt;code&gt;count&lt;/code&gt; es 1. Especificar un valor de &lt;code&gt;count&lt;/code&gt; que sea mayor que la cardinalidad del conjunto ordenado no producir&amp;aacute; un error. Al devolver varios elementos, el que tenga la puntuaci&amp;oacute;n m&amp;aacute;s alta ser&amp;aacute; el primero, seguido de los elementos con puntuaciones m&amp;aacute;s bajas.</target>
        </trans-unit>
        <trans-unit id="211482444a8bb15f0419b132f3cc1af74dc280a8" translate="yes" xml:space="preserve">
          <source>When left unspecified, the default value for &lt;code&gt;count&lt;/code&gt; is 1. Specifying a &lt;code&gt;count&lt;/code&gt; value that is higher than the sorted set's cardinality will not produce an error. When returning multiple elements, the one with the lowest score will be the first, followed by the elements with greater scores.</source>
          <target state="translated">Cuando no se especifica, el valor predeterminado para el &lt;code&gt;count&lt;/code&gt; es 1. Especificar un valor de &lt;code&gt;count&lt;/code&gt; que sea mayor que la cardinalidad del conjunto ordenado no producir&amp;aacute; un error. Al devolver m&amp;uacute;ltiples elementos, el que tenga menor puntuaci&amp;oacute;n ser&amp;aacute; el primero, seguido de los elementos con mayor puntuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a7d4595cfb64936d3f6440b45d7a7ed36a43a0a8" translate="yes" xml:space="preserve">
          <source>When multiple elements are pushed inside a list where there are clients blocking, the behavior is different for Redis 2.4 and Redis 2.6 or newer.</source>
          <target state="translated">Cuando se empujan múltiples elementos dentro de una lista en la que hay clientes bloqueados,el comportamiento es diferente para Redis 2.4 y Redis 2.6 o más reciente.</target>
        </trans-unit>
        <trans-unit id="6b90f2527a2bc6b00afd2387c1456694d73ef4d1" translate="yes" xml:space="preserve">
          <source>When no channels are specified, the client is unsubscribed from all the previously subscribed channels. In this case, a message for every unsubscribed channel will be sent to the client.</source>
          <target state="translated">Cuando no se especifica ningún canal,el cliente es dado de baja de todos los canales previamente suscritos.En este caso,se enviará al cliente un mensaje por cada canal desabonado.</target>
        </trans-unit>
        <trans-unit id="fdb6f67d4fc0a3a04f0f7c8957c10a575f322f03" translate="yes" xml:space="preserve">
          <source>When no parameter is provided, the &lt;code&gt;default&lt;/code&gt; option is assumed.</source>
          <target state="translated">Cuando no se proporciona ning&amp;uacute;n par&amp;aacute;metro, se asume la opci&amp;oacute;n &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5d25c83a5c898215219edf46cc2b802cdf3d79b" translate="yes" xml:space="preserve">
          <source>When no patterns are specified, the client is unsubscribed from all the previously subscribed patterns. In this case, a message for every unsubscribed pattern will be sent to the client.</source>
          <target state="translated">Cuando no se especifican patrones,el cliente es dado de baja de todos los patrones previamente suscritos.En este caso,se enviará un mensaje al cliente por cada patrón que se haya dado de baja.</target>
        </trans-unit>
        <trans-unit id="78417cb2a25390c38fe35cd171fb5a5947e744ea" translate="yes" xml:space="preserve">
          <source>When offsets and integer sizes are aligned to bytes boundaries, this is the same as big endian, however when such alignment does not exist, its important to also understand how the bits inside a byte are ordered.</source>
          <target state="translated">Cuando las compensaciones y los tamaños enteros se alinean con los límites de los bytes,esto es lo mismo que el gran endiano,sin embargo cuando tal alineación no existe,es importante también entender cómo se ordenan los bits dentro de un byte.</target>
        </trans-unit>
        <trans-unit id="108666d32b04e9c8120bc0297356b4a75ef38e99" translate="yes" xml:space="preserve">
          <source>When script effects replication is enabled, the controls about non deterministic functions are disabled. You can, for example, use the &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; or &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; commands inside your scripts freely at any place.</source>
          <target state="translated">Cuando la replicaci&amp;oacute;n de efectos de script est&amp;aacute; habilitada, los controles sobre funciones no deterministas est&amp;aacute;n deshabilitados. Puede, por ejemplo, usar los comandos &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; o &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; dentro de sus scripts libremente en cualquier lugar.</target>
        </trans-unit>
        <trans-unit id="c949e2a31dff272184232d48bbed21c53a8ecbce" translate="yes" xml:space="preserve">
          <source>When script effects replication is selected (see the previous section), it is possible to have more control in the way commands are replicated to replicas and AOF. This is a very advanced feature since &lt;strong&gt;a misuse can do damage&lt;/strong&gt; by breaking the contract that the master, replicas, and AOF, all must contain the same logical content.</source>
          <target state="translated">Cuando se selecciona la replicaci&amp;oacute;n de efectos de secuencia de comandos (consulte la secci&amp;oacute;n anterior), es posible tener m&amp;aacute;s control sobre la forma en que los comandos se replican en r&amp;eacute;plicas y AOF. Esta es una caracter&amp;iacute;stica muy avanzada ya que &lt;strong&gt;un mal uso puede hacer da&amp;ntilde;o&lt;/strong&gt; al romper el contrato que el maestro, r&amp;eacute;plicas y AOF, todos deben contener el mismo contenido l&amp;oacute;gico.</target>
        </trans-unit>
        <trans-unit id="7636c8c8a61350c346336fb982c9ef556a189a7d" translate="yes" xml:space="preserve">
          <source>When the &lt;strong&gt;BLOCK&lt;/strong&gt; command is passed, but there is data to return at least in one of the streams passed, the command is executed synchronously &lt;em&gt;exactly like if the BLOCK option would be missing&lt;/em&gt;.</source>
          <target state="translated">Cuando se pasa el comando &lt;strong&gt;BLOQUEAR&lt;/strong&gt; , pero hay datos para devolver al menos en uno de los flujos pasados, el comando se ejecuta sincr&amp;oacute;nicamente &lt;em&gt;exactamente como si faltara la opci&amp;oacute;n BLOQUEAR&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bda61f2869adefc9c91081ddbc477199f8833d60" translate="yes" xml:space="preserve">
          <source>When the Append Only File is enabled the shutdown may fail because the system is in a state that does not allow to safely immediately persist on disk.</source>
          <target state="translated">Cuando se activa el archivo Append Only File,el apagado puede fallar porque el sistema se encuentra en un estado que no permite persistir de forma segura e inmediata en el disco.</target>
        </trans-unit>
        <trans-unit id="a1802236c02270cfae3906700b4014b222477ba8" translate="yes" xml:space="preserve">
          <source>When the bitmap is big, there are two alternatives:</source>
          <target state="translated">Cuando el mapa de bits es grande,hay dos alternativas:</target>
        </trans-unit>
        <trans-unit id="f0fb5ccdd0c31b389289e55b5474996a5274294b" translate="yes" xml:space="preserve">
          <source>When the connection is in readonly mode, the cluster will send a redirection to the client only if the operation involves keys not served by the replica's master node. This may happen because:</source>
          <target state="translated">Cuando la conexión está en modo de sólo lectura,el clúster enviará una redirección al cliente sólo si la operación implica claves no servidas por el nodo maestro de la réplica.Esto puede suceder porque:</target>
        </trans-unit>
        <trans-unit id="0425f335ff3cda3215aa3a176f21d76a5ca6ec24" translate="yes" xml:space="preserve">
          <source>When the new form is used the command no longer returns &lt;code&gt;OK&lt;/code&gt; or an error, but instead the number of killed clients, that may be zero.</source>
          <target state="translated">Cuando se usa el nuevo formulario, el comando ya no devuelve &lt;code&gt;OK&lt;/code&gt; o un error, sino que el n&amp;uacute;mero de clientes eliminados puede ser cero.</target>
        </trans-unit>
        <trans-unit id="2c445805a9e7bf698eb416f881ba6f49bc531d2b" translate="yes" xml:space="preserve">
          <source>When the script is slow to compute, but the effects can be summarized by a few write commands, it is a shame to re-compute the script on the replicas or when reloading the AOF. In this case to replicate just the effect of the script is much better.</source>
          <target state="translated">Cuando el guión es lento de computar,pero los efectos pueden ser resumidos por unos pocos comandos de escritura,es una pena volver a computar el guión en las réplicas o al recargar el AOF.En este caso para replicar sólo el efecto del guión es mucho mejor.</target>
        </trans-unit>
        <trans-unit id="7b1b9ae270926466531ce7bdd9b1a9abbed04ad7" translate="yes" xml:space="preserve">
          <source>When the specified amount of time has elapsed, all the clients are unblocked: this will trigger the processing of all the commands accumulated in the query buffer of every client during the pause.</source>
          <target state="translated">Una vez transcurrido el tiempo especificado,se desbloquean todos los clientes:esto desencadenará el procesamiento de todos los comandos acumulados en la memoria intermedia de consulta de cada cliente durante la pausa.</target>
        </trans-unit>
        <trans-unit id="8eb05f1da75f191f0884c583c801835aa8cd0277" translate="yes" xml:space="preserve">
          <source>When the value at &lt;code&gt;key&lt;/code&gt; is not a list, an error is returned.</source>
          <target state="translated">Cuando el valor de la &lt;code&gt;key&lt;/code&gt; no es una lista, se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="0aba433e5fcdd9ec4a7aaef9936a05505bfb779c" translate="yes" xml:space="preserve">
          <source>When this form is used the &lt;code&gt;NOKEY&lt;/code&gt; status code is only returned when none of the keys is present in the instance, otherwise the command is executed, even if just a single key exists.</source>
          <target state="translated">Cuando se utiliza este formulario, el c&amp;oacute;digo de estado &lt;code&gt;NOKEY&lt;/code&gt; solo se devuelve cuando ninguna de las claves est&amp;aacute; presente en la instancia; de lo contrario, se ejecuta el comando, incluso si solo existe una clave.</target>
        </trans-unit>
        <trans-unit id="71523575e42f8410dc6799c1a7fe4f0075f3bdae" translate="yes" xml:space="preserve">
          <source>When this happens we can't just call &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; against the key to remove the lock and then try to issue a &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, as there is a race condition here, when multiple clients detected an expired lock and are trying to release it.</source>
          <target state="translated">Cuando esto sucede, no podemos simplemente llamar &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; contra la clave para eliminar el bloqueo y luego intentar emitir un &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; , ya que aqu&amp;iacute; hay una condici&amp;oacute;n de carrera, cuando varios clientes detectaron un bloqueo vencido y est&amp;aacute;n tratando de liberarlo.</target>
        </trans-unit>
        <trans-unit id="9369493e521d0f5bfa4b5285118bddaf4c3ed126" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt;, &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; can return a &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt; if the execution was aborted.</source>
          <target state="translated">Cuando se usa &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; , &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; puede devolver una &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;respuesta nula&lt;/a&gt; si se cancel&amp;oacute; la ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="03fb3b3e279fe5941d3058ae5c0bbfd517e2ed4a" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt;, &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; will execute commands only if the watched keys were not modified, allowing for a &lt;a href=&quot;https://redis.io/topics/transactions#cas&quot;&gt;check-and-set mechanism&lt;/a&gt;.</source>
          <target state="translated">Al usar &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; , &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; ejecutar&amp;aacute; comandos solo si las teclas observadas no se modificaron, lo que permite un &lt;a href=&quot;https://redis.io/topics/transactions#cas&quot;&gt;mecanismo de verificaci&amp;oacute;n y configuraci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ff122098db2ca4b2a53bd2c8a430c8385708d04" translate="yes" xml:space="preserve">
          <source>When using Redis Cluster, the &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; command cannot be used, since Redis Cluster only supports database zero. In the case of Redis Cluster, having multiple databases would be useless, and a worthless source of complexity, because anyway commands operating atomically on a single database would not be possible with the Redis Cluster design and goals.</source>
          <target state="translated">Al usar Redis Cluster, el comando &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; no se puede usar, ya que Redis Cluster solo admite la base de datos cero. En el caso de Redis Cluster, tener varias bases de datos ser&amp;iacute;a in&amp;uacute;til y una fuente in&amp;uacute;til de complejidad, porque de todos modos los comandos que operan de forma at&amp;oacute;mica en una sola base de datos no ser&amp;iacute;an posibles con el dise&amp;ntilde;o y los objetivos de Redis Cluster.</target>
        </trans-unit>
        <trans-unit id="91435698deee68490867362db518895697a1efba" translate="yes" xml:space="preserve">
          <source>When you read with &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, the server will &lt;em&gt;remember&lt;/em&gt; that a given message was delivered to you: the message will be stored inside the consumer group in what is called a Pending Entries List (PEL), that is a list of message IDs delivered but not yet acknowledged.</source>
          <target state="translated">Cuando lea con &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; , el servidor &lt;em&gt;recordar&amp;aacute;&lt;/em&gt; que se le entreg&amp;oacute; un mensaje determinado: el mensaje se almacenar&amp;aacute; dentro del grupo de consumidores en lo que se llama Lista de entradas pendientes (PEL), que es una lista de ID de mensajes entregados pero no a&amp;uacute;n reconocido.</target>
        </trans-unit>
        <trans-unit id="6a35b41e1d31b87470e6d1d43bddd43a0e835653" translate="yes" xml:space="preserve">
          <source>Where an integer type is expected, it can be composed by prefixing with &lt;code&gt;i&lt;/code&gt; for signed integers and &lt;code&gt;u&lt;/code&gt; for unsigned integers with the number of bits of our integer type. So for example &lt;code&gt;u8&lt;/code&gt; is an unsigned integer of 8 bits and &lt;code&gt;i16&lt;/code&gt; is a signed integer of 16 bits.</source>
          <target state="translated">Cuando se espera un tipo de entero, se puede componer prefijando &lt;code&gt;i&lt;/code&gt; para enteros con signo &lt;code&gt;u&lt;/code&gt; para enteros sin signo con el n&amp;uacute;mero de bits de nuestro tipo de entero. Entonces, por ejemplo, &lt;code&gt;u8&lt;/code&gt; es un entero sin signo de 8 bits e &lt;code&gt;i16&lt;/code&gt; es un entero con signo de 16 bits.</target>
        </trans-unit>
        <trans-unit id="f02b4c0414a9fc9e1bc6e0376aca02edf648b5bb" translate="yes" xml:space="preserve">
          <source>Where bytes or other quantities are specified, it is not possible to use the &lt;code&gt;redis.conf&lt;/code&gt; abbreviated form (&lt;code&gt;10k&lt;/code&gt;, &lt;code&gt;2gb&lt;/code&gt; ... and so forth), everything should be specified as a well-formed 64-bit integer, in the base unit of the configuration directive.</source>
          <target state="translated">Cuando se especifican bytes u otras cantidades, no es posible utilizar la forma abreviada de &lt;code&gt;redis.conf&lt;/code&gt; ( &lt;code&gt;10k&lt;/code&gt; , &lt;code&gt;2gb&lt;/code&gt; ... y as&amp;iacute; sucesivamente), todo debe especificarse como un entero de 64 bits bien formado, en la unidad base de la directiva de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="21e96c24ad72668a7a4a76394b426e6e4cfd5aa5" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; does not provide guarantees about the number of elements returned at every iteration, it is possible to empirically adjust the behavior of &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; using the &lt;strong&gt;COUNT&lt;/strong&gt; option. Basically with COUNT the user specified the &lt;em&gt;amount of work that should be done at every call in order to retrieve elements from the collection&lt;/em&gt;. This is &lt;strong&gt;just a hint&lt;/strong&gt; for the implementation, however generally speaking this is what you could expect most of the times from the implementation.</source>
          <target state="translated">Si bien &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; no ofrece garant&amp;iacute;as sobre el n&amp;uacute;mero de elementos devueltos en cada iteraci&amp;oacute;n, es posible ajustar emp&amp;iacute;ricamente el comportamiento de &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; utilizando la opci&amp;oacute;n &lt;strong&gt;COUNT&lt;/strong&gt; . B&amp;aacute;sicamente, con COUNT, el usuario especific&amp;oacute; la &lt;em&gt;cantidad de trabajo que se debe realizar en cada llamada para recuperar elementos de la colecci&amp;oacute;n&lt;/em&gt; . Esto es &lt;strong&gt;solo una pista&lt;/strong&gt; para la implementaci&amp;oacute;n, sin embargo, en t&amp;eacute;rminos generales, esto es lo que podr&amp;iacute;a esperar la mayor&amp;iacute;a de las veces de la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fdd3db136923e6b534f552c2d3cf5ff970987981" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; returns items in a range of IDs, &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is more suited in order to consume the stream starting from the first entry which is greater than any other entry we saw so far. So what we pass to &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is, for each stream, the ID of the last element that we received from that stream.</source>
          <target state="translated">Si bien &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; devuelve elementos en un rango de ID, &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; es m&amp;aacute;s adecuado para consumir la transmisi&amp;oacute;n a partir de la primera entrada, que es mayor que cualquier otra entrada que vimos hasta ahora. Entonces, lo que pasamos a &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; es, para cada flujo, el ID del &amp;uacute;ltimo elemento que recibimos de ese flujo.</target>
        </trans-unit>
        <trans-unit id="3bca73c8acea1a652a640a6f60e7689ea8279e95" translate="yes" xml:space="preserve">
          <source>While in the producer side we'll use simply:</source>
          <target state="translated">Mientras que en el lado del productor usaremos simplemente:</target>
        </trans-unit>
        <trans-unit id="7c0e17e27e0496071209fca63c12a067afb89764" translate="yes" xml:space="preserve">
          <source>While the same element can't be repeated in a sorted set since every element is unique, it is possible to add multiple different elements &lt;em&gt;having the same score&lt;/em&gt;. When multiple elements have the same score, they are &lt;em&gt;ordered lexicographically&lt;/em&gt; (they are still ordered by score as a first key, however, locally, all the elements with the same score are relatively ordered lexicographically).</source>
          <target state="translated">Si bien el mismo elemento no se puede repetir en un conjunto ordenado, ya que cada elemento es &amp;uacute;nico, es posible agregar varios elementos diferentes que &lt;em&gt;tengan la misma puntuaci&amp;oacute;n&lt;/em&gt; . Cuando varios elementos tienen la misma puntuaci&amp;oacute;n, se &lt;em&gt;ordenan lexicogr&amp;aacute;ficamente&lt;/em&gt; (todav&amp;iacute;a est&amp;aacute;n ordenados por puntuaci&amp;oacute;n como primera clave, sin embargo, a nivel local, todos los elementos con la misma puntuaci&amp;oacute;n est&amp;aacute;n relativamente ordenados lexicogr&amp;aacute;ficamente).</target>
        </trans-unit>
        <trans-unit id="faa0e8655432999d785846c09a504699c423a816" translate="yes" xml:space="preserve">
          <source>While the time complexity for this operation is O(N), the constant times are fairly low. For example, Redis running on an entry level laptop can scan a 1 million key database in 40 milliseconds.</source>
          <target state="translated">Aunque la complejidad temporal de esta operación es O(N),los tiempos constantes son bastante bajos.Por ejemplo,Redis corriendo en una laptop de nivel de entrada puede escanear una base de datos de 1 millón de claves en 40 milisegundos.</target>
        </trans-unit>
        <trans-unit id="75b48078eb932b5cb40c7aa69416f977a376c34b" translate="yes" xml:space="preserve">
          <source>Why SCAN may return all the items of an aggregate data type in a single call?</source>
          <target state="translated">¿Por qué SCAN puede devolver todos los elementos de un tipo de datos agregados en una sola llamada?</target>
        </trans-unit>
        <trans-unit id="6774ddf6e2ea44a8275c548051410620bab8eba5" translate="yes" xml:space="preserve">
          <source>Will generate the following:</source>
          <target state="translated">generará lo siguiente:</target>
        </trans-unit>
        <trans-unit id="e1fe1e67413d581c991f5221192d9e1d386431de" translate="yes" xml:space="preserve">
          <source>Will return all elements with &lt;code&gt;1 &amp;lt; score &amp;lt;= 5&lt;/code&gt; while:</source>
          <target state="translated">Devolver&amp;aacute; todos los elementos con &lt;code&gt;1 &amp;lt; score &amp;lt;= 5&lt;/code&gt; mientras:</target>
        </trans-unit>
        <trans-unit id="94c4c27cb05eba870b183d02b1a609fe9e1ea895" translate="yes" xml:space="preserve">
          <source>Will return all the elements with &lt;code&gt;5 &amp;lt; score &amp;lt; 10&lt;/code&gt; (5 and 10 excluded).</source>
          <target state="translated">Devolver&amp;aacute; todos los elementos con &lt;code&gt;5 &amp;lt; score &amp;lt; 10&lt;/code&gt; (5 y 10 excluidos).</target>
        </trans-unit>
        <trans-unit id="894d5e0ad9ce405ef4fb756fe8055963159cfadf" translate="yes" xml:space="preserve">
          <source>Will set the first i8 integer at offset 0 and the second at offset 8. This way you don't have to do the math yourself inside your client if what you want is a plain array of integers of a given size.</source>
          <target state="translated">Pondrá el primer entero i8 en el offset 0 y el segundo en el offset 8.De esta manera no tienes que hacer las cuentas tú mismo dentro de tu cliente si lo que quieres es un simple conjunto de números enteros de un tamaño determinado.</target>
        </trans-unit>
        <trans-unit id="cf10ad559647abb5c8bab42f73ec14d7f8af0292" translate="yes" xml:space="preserve">
          <source>With Redis v4.0.1 64-bit and &lt;strong&gt;jemalloc&lt;/strong&gt;, the empty string measures as follows:</source>
          <target state="translated">Con Redis v4.0.1 de 64 bits y &lt;strong&gt;jemalloc&lt;/strong&gt; , la cadena vac&amp;iacute;a mide lo siguiente:</target>
        </trans-unit>
        <trans-unit id="ec661db3a798a1855f025d52c2fe8c0cd35d7515" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;AGGREGATE&lt;/code&gt; option, it is possible to specify how the results of the union are aggregated. This option defaults to &lt;code&gt;SUM&lt;/code&gt;, where the score of an element is summed across the inputs where it exists. When this option is set to either &lt;code&gt;MIN&lt;/code&gt; or &lt;code&gt;MAX&lt;/code&gt;, the resulting set will contain the minimum or maximum score of an element across the inputs where it exists.</source>
          <target state="translated">Con la opci&amp;oacute;n &lt;code&gt;AGGREGATE&lt;/code&gt; , es posible especificar c&amp;oacute;mo se agregan los resultados de la uni&amp;oacute;n. Esta opci&amp;oacute;n tiene como valor predeterminado &lt;code&gt;SUM&lt;/code&gt; , donde la puntuaci&amp;oacute;n de un elemento se suma a trav&amp;eacute;s de las entradas donde existe. Cuando esta opci&amp;oacute;n se establece en &lt;code&gt;MIN&lt;/code&gt; o &lt;code&gt;MAX&lt;/code&gt; , el conjunto resultante contendr&amp;aacute; la puntuaci&amp;oacute;n m&amp;iacute;nima o m&amp;aacute;xima de un elemento en todas las entradas donde existe.</target>
        </trans-unit>
        <trans-unit id="50b1405945945facc69fb20f7d723bfb99db9e44" translate="yes" xml:space="preserve">
          <source>With the new form it is possible to kill clients by different attributes instead of killing just by address. The following filters are available:</source>
          <target state="translated">Con la nueva forma es posible matar a los clientes por diferentes atributos en lugar de matar sólo por la dirección.Los siguientes filtros están disponibles:</target>
        </trans-unit>
        <trans-unit id="0799386d8ece7a29459c32e7790ea42266a228aa" translate="yes" xml:space="preserve">
          <source>Within a consumer group, a given consumer (that is, just a client consuming messages from the stream), has to identify with an unique &lt;em&gt;consumer name&lt;/em&gt;. Which is just a string.</source>
          <target state="translated">Dentro de un grupo de consumidores, un consumidor determinado (es decir, solo un cliente que consume mensajes de la transmisi&amp;oacute;n) tiene que identificarse con un &lt;em&gt;nombre de consumidor&lt;/em&gt; &amp;uacute;nico . Que es solo una cuerda.</target>
        </trans-unit>
        <trans-unit id="0f3e4aaa240c1548a4c9429dbad46917966e880e" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;ASKING&lt;/code&gt; the behavior is the same as usually. This guarantees that clients with a broken hash slots mapping will not write for error in the target node, creating a new version of a key that has yet to be migrated.</source>
          <target state="translated">Sin &lt;code&gt;ASKING&lt;/code&gt; el comportamiento es el mismo de siempre. Esto garantiza que los clientes con una asignaci&amp;oacute;n de ranuras hash rota no escribir&amp;aacute;n por error en el nodo de destino, creando una nueva versi&amp;oacute;n de una clave que a&amp;uacute;n no se ha migrado.</target>
        </trans-unit>
        <trans-unit id="d48a4c4f3594b39719f619245890353a2709bae6" translate="yes" xml:space="preserve">
          <source>Without any &lt;code&gt;WITH&lt;/code&gt; option specified, the command just returns a linear array like [&quot;New York&quot;,&quot;Milan&quot;,&quot;Paris&quot;].</source>
          <target state="translated">Sin ninguna opci&amp;oacute;n &lt;code&gt;WITH&lt;/code&gt; especificada, el comando simplemente devuelve una matriz lineal como [&quot;Nueva York&quot;, &quot;Mil&amp;aacute;n&quot;, &quot;Par&amp;iacute;s&quot;].</target>
        </trans-unit>
        <trans-unit id="400c8adf856e4ac8a8a6ac9b587c616fb64274c1" translate="yes" xml:space="preserve">
          <source>Without consumer groups, just using &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;, all the clients are served with all the entries arriving in a stream. Instead using consumer groups with &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, it is possible to create groups of clients that consume different parts of the messages arriving in a given stream. If, for instance, the stream gets the new entires A, B, and C and there are two consumers reading via a consumer group, one client will get, for instance, the messages A and C, and the other the message B, and so forth.</source>
          <target state="translated">Sin grupos de consumidores, simplemente usando &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; , todos los clientes son atendidos con todas las entradas que llegan en una secuencia. En lugar de utilizar grupos de consumidores con &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; , es posible crear grupos de clientes que consuman diferentes partes de los mensajes que llegan en un flujo determinado. Si, por ejemplo, el flujo obtiene los nuevos enteros A, B y C y hay dos consumidores leyendo a trav&amp;eacute;s de un grupo de consumidores, un cliente recibir&amp;aacute;, por ejemplo, los mensajes A y C, y el otro el mensaje B, y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="5e630a7240130bc3af7f3d25b607f1bbc7d95427" translate="yes" xml:space="preserve">
          <source>XACK</source>
          <target state="translated">XACK</target>
        </trans-unit>
        <trans-unit id="238a60725d880b00a411887e084d414d62068fd4" translate="yes" xml:space="preserve">
          <source>XACK  key group ID [ID ...]   Marks a pending message as correctly processed, effectively removing it from the pending entries list of the consumer group. Return value of the command is the number of messages successfully acknowledged, that is, the IDs we were actually able to resolve in the PEL.</source>
          <target state="translated">ID de grupo de claves XACK [ID ...]Marca un mensaje pendiente como correctamente procesado,eliminándolo efectivamente de la lista de entradas pendientes del grupo de consumidores.El valor de retorno del comando es el número de mensajes reconocidos con éxito,es decir,los ID que realmente pudimos resolver en el PEL.</target>
        </trans-unit>
        <trans-unit id="af6d29b2dcf05d4b2ed23e3102a0a31b6e241bff" translate="yes" xml:space="preserve">
          <source>XADD</source>
          <target state="translated">XADD</target>
        </trans-unit>
        <trans-unit id="e69d374462681c5664a1fcdd09ad239a80dd5647" translate="yes" xml:space="preserve">
          <source>XADD  key ID field string [field string ...]   Appends a new entry to a stream</source>
          <target state="translated">XADD key ID field string [field string ...]Añade una nueva entrada a un flujo</target>
        </trans-unit>
        <trans-unit id="09b8fb22138bc8e941ddecb6458cc91162943a39" translate="yes" xml:space="preserve">
          <source>XCLAIM</source>
          <target state="translated">XCLAIM</target>
        </trans-unit>
        <trans-unit id="69cd30c46b283939fd7c08ea80c2b13ecf4bd239" translate="yes" xml:space="preserve">
          <source>XCLAIM  key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]   Changes (or acquires) ownership of a message in a consumer group, as if the message was delivered to the specified consumer.</source>
          <target state="translated">XCLAIM grupo clave de consumidores min-idle-time ID [ID ...][IDLE ms][TIME ms-unix-time][RETRYCOUNT count][FORCE][JUSTID]Cambia (o adquiere)la propiedad de un mensaje en un grupo de consumidores,como si el mensaje fuera entregado al consumidor especificado.</target>
        </trans-unit>
        <trans-unit id="7c1a89d20036b7688ea139507f1afdc9a29953de" translate="yes" xml:space="preserve">
          <source>XDEL</source>
          <target state="translated">XDEL</target>
        </trans-unit>
        <trans-unit id="ab0fa30c58e1667f7c50bef9c640975c83dbbca6" translate="yes" xml:space="preserve">
          <source>XDEL  key ID [ID ...]   Removes the specified entries from the stream. Returns the number of items actually deleted, that may be different from the number of IDs passed in case certain IDs do not exist.</source>
          <target state="translated">XDEL key ID [ID ...]Elimina las entradas especificadas del flujo.Devuelve el número de elementos realmente eliminados,que puede ser diferente del número de IDs pasados en caso de que ciertos IDs no existan.</target>
        </trans-unit>
        <trans-unit id="bc322d1c9f4b420b88e62a454aedb033f028dab6" translate="yes" xml:space="preserve">
          <source>XGROUP</source>
          <target state="translated">XGROUP</target>
        </trans-unit>
        <trans-unit id="c7698763ddd9e2c448408316d6ce4417dffc8b68" translate="yes" xml:space="preserve">
          <source>XGROUP  [CREATE key groupname id-or-$] [SETID key groupname id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]   Create, destroy, and manage consumer groups.</source>
          <target state="translated">XGROUP [CREAR nombre de grupo clave id-or-$][SETID nombre de grupo clave id-or-$][DESTRUIR nombre de grupo clave][DELCONSUMIDOR nombre de grupo clave nombre de consumidor]Crear,destruir y administrar grupos de consumidores.</target>
        </trans-unit>
        <trans-unit id="c6dad2f9d389a88a2d5423b140bfb5d329380ff9" translate="yes" xml:space="preserve">
          <source>XINFO</source>
          <target state="translated">XINFO</target>
        </trans-unit>
        <trans-unit id="26c4995225a5e2ca6cbd4df2dc968964aa3106e4" translate="yes" xml:space="preserve">
          <source>XINFO  [CONSUMERS key groupname] [GROUPS key] [STREAM key] [HELP]   Get information on streams and consumer groups</source>
          <target state="translated">XINFO [CONSUMIDORES clave nombre de grupo][GRUPOS clave][STREAM clave][AYUDA]Obtener información sobre los flujos y los grupos de consumidores</target>
        </trans-unit>
        <trans-unit id="b6ee4a8b7a891baba7c913a8af31780be7fd39ad" translate="yes" xml:space="preserve">
          <source>XLEN</source>
          <target state="translated">XLEN</target>
        </trans-unit>
        <trans-unit id="5d3643676d949125bc526c23ac7661d998089a21" translate="yes" xml:space="preserve">
          <source>XLEN  key   Return the number of entires in a stream</source>
          <target state="translated">Tecla XLEN Devuelve el número de enteros en un flujo</target>
        </trans-unit>
        <trans-unit id="0b65339f2697b1c699811da74222bbd0da65d870" translate="yes" xml:space="preserve">
          <source>XPENDING</source>
          <target state="translated">XPENDING</target>
        </trans-unit>
        <trans-unit id="3fc1509063ccb300647516e5a0736301ae8f16c4" translate="yes" xml:space="preserve">
          <source>XPENDING  key group [start end count] [consumer]   Return information and entries from a stream consumer group pending entries list, that are messages fetched but never acknowledged.</source>
          <target state="translated">Grupo de teclas XPENDING [inicio y fin del conteo][consumidor]Devuelve la información y las entradas de una lista de entradas pendientes de un grupo de consumidores,que son mensajes recuperados pero nunca reconocidos.</target>
        </trans-unit>
        <trans-unit id="d1e36a585685d1c605bc47363901884a6eaa3ba7" translate="yes" xml:space="preserve">
          <source>XRANGE</source>
          <target state="translated">XRANGE</target>
        </trans-unit>
        <trans-unit id="7e9287af270b58d717c34831e88430ad997da595" translate="yes" xml:space="preserve">
          <source>XRANGE  key start end [COUNT count]   Return a range of elements in a stream, with IDs matching the specified IDs interval</source>
          <target state="translated">XRANGE key start end [COUNT count]Devuelve un rango de elementos en un flujo,con IDs que coinciden con el intervalo de IDs especificado</target>
        </trans-unit>
        <trans-unit id="74d3c0a39e46c4eb449a52d32c8a5abbe1061892" translate="yes" xml:space="preserve">
          <source>XREAD</source>
          <target state="translated">XREAD</target>
        </trans-unit>
        <trans-unit id="17f4903694ccef37d4648c4a5f1ae472dacf86b6" translate="yes" xml:space="preserve">
          <source>XREAD  [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]   Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block.</source>
          <target state="translated">XREAD [conteo][BLOQUEAR milisegundos]Tecla STREAMS [tecla ...]ID [ID ...]Devuelve elementos nunca vistos en múltiples flujos,con IDs mayores que los reportados por el llamante para cada flujo.Puede bloquearse.</target>
        </trans-unit>
        <trans-unit id="846b3a7d4e31a4e9d17286ae266f99e375041028" translate="yes" xml:space="preserve">
          <source>XREADGROUP</source>
          <target state="translated">XREADGROUP</target>
        </trans-unit>
        <trans-unit id="248bac627c2fef68faf3fb58c8565b88ea2fff82" translate="yes" xml:space="preserve">
          <source>XREADGROUP  GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]   Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block.</source>
          <target state="translated">GRUPO XREADGROUP grupo consumidor [CONTEO][BLOQUEO milisegundos][NUEVO]Tecla STREAMS [tecla ...]ID [ID ...]Devolver las nuevas entradas de un flujo utilizando un grupo de consumidores,o acceder al historial de las entradas pendientes de un consumidor determinado.Puede bloquearse.</target>
        </trans-unit>
        <trans-unit id="4997b60ad825263d8b96f62cc9d430670501aee2" translate="yes" xml:space="preserve">
          <source>XREVRANGE</source>
          <target state="translated">XREVRANGE</target>
        </trans-unit>
        <trans-unit id="6acfcd338f4f89c5327717d107164d5f4a0348c2" translate="yes" xml:space="preserve">
          <source>XREVRANGE  key end start [COUNT count]   Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to XRANGE</source>
          <target state="translated">XREVRANGE key end start [COUNT count]Devuelve un rango de elementos en un flujo,con IDs que coinciden con el intervalo de IDs especificado,en orden inverso (de mayor a menor IDs)comparado con XRANGE</target>
        </trans-unit>
        <trans-unit id="07d95fde827764d259d6f7d12828416866a07221" translate="yes" xml:space="preserve">
          <source>XTRIM</source>
          <target state="translated">XTRIM</target>
        </trans-unit>
        <trans-unit id="a44c70bed773dad09049379eb1cede2cc5be55c0" translate="yes" xml:space="preserve">
          <source>XTRIM  key MAXLEN [~] count   Trims the stream to (approximately if '~' is passed) a certain size</source>
          <target state="translated">Tecla XTRIM MAXLEN [~]cuenta Recorta el flujo a (aproximadamente si se pasa el '~')un cierto tamaño</target>
        </trans-unit>
        <trans-unit id="d6a698456d791f29ffc6116a3d8426c7d9bc7f65" translate="yes" xml:space="preserve">
          <source>You almost never want to call &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; in production environments where it will block all the other clients. Instead usually &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; is used. However in case of issues preventing Redis to create the background saving child (for instance errors in the fork(2) system call), the &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; command can be a good last resort to perform the dump of the latest dataset.</source>
          <target state="translated">Casi nunca querr&amp;aacute; llamar a &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; en entornos de producci&amp;oacute;n donde bloquear&amp;aacute; a todos los dem&amp;aacute;s clientes. En su lugar, generalmente se usa &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; . Sin embargo, en caso de problemas que impidan que Redis cree el elemento secundario que salva el fondo (por ejemplo, errores en la llamada al sistema fork (2)), el comando &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; puede ser un buen &amp;uacute;ltimo recurso para realizar el volcado del &amp;uacute;ltimo conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="5206e6d8bc19178c4fcc4166295d67f608c9a03b" translate="yes" xml:space="preserve">
          <source>You can configure the slow log with two parameters: &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; tells Redis what is the execution time, in microseconds, to exceed in order for the command to get logged. Note that a negative number disables the slow log, while a value of zero forces the logging of every command. &lt;em&gt;slowlog-max-len&lt;/em&gt; is the length of the slow log. The minimum value is zero. When a new command is logged and the slow log is already at its maximum length, the oldest one is removed from the queue of logged commands in order to make space.</source>
          <target state="translated">Puede configurar el registro lento con dos par&amp;aacute;metros: &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; le dice a Redis cu&amp;aacute;l es el tiempo de ejecuci&amp;oacute;n, en microsegundos, que debe exceder para que se &lt;em&gt;registre&lt;/em&gt; el comando. Tenga en cuenta que un n&amp;uacute;mero negativo desactiva el registro lento, mientras que un valor de cero fuerza el registro de cada comando. &lt;em&gt;slowlog-max-len&lt;/em&gt; es la longitud del registro lento. El valor m&amp;iacute;nimo es cero. Cuando se registra un nuevo comando y el registro lento ya est&amp;aacute; en su longitud m&amp;aacute;xima, el m&amp;aacute;s antiguo se elimina de la cola de comandos registrados para hacer espacio.</target>
        </trans-unit>
        <trans-unit id="812b7d5893aec06a53b91fb5c4558bfd6d9c305e" translate="yes" xml:space="preserve">
          <source>You can easily model this pattern in Redis using the following strategy: every time the user does a page view you call the following commands:</source>
          <target state="translated">Puedes modelar fácilmente este patrón en Redis usando la siguiente estrategia:cada vez que el usuario hace una vista de página llamas a los siguientes comandos:</target>
        </trans-unit>
        <trans-unit id="a7f62cb7c991c6f7b10c875853c4ea6d4f654b01" translate="yes" xml:space="preserve">
          <source>You can have both the AOF enabled with RDB snapshotting if you want, the two options are not mutually exclusive.</source>
          <target state="translated">Puedes tener ambos AOF habilitados con instantáneas RDB si quieres,las dos opciones no son mutuamente excluyentes.</target>
        </trans-unit>
        <trans-unit id="c7fd0d1aed142d3203e386c1f87bbe8cf271b68e" translate="yes" xml:space="preserve">
          <source>You can obtain a list of all the supported configuration parameters by typing &lt;code&gt;CONFIG GET *&lt;/code&gt; in an open &lt;code&gt;redis-cli&lt;/code&gt; prompt.</source>
          <target state="translated">Puede obtener una lista de todos los par&amp;aacute;metros de configuraci&amp;oacute;n admitidos escribiendo &lt;code&gt;CONFIG GET *&lt;/code&gt; en un &lt;code&gt;redis-cli&lt;/code&gt; abierto de redis-cli .</target>
        </trans-unit>
        <trans-unit id="782a26c287765bb5ada5d53362e1315b8ea70eec" translate="yes" xml:space="preserve">
          <source>You can reset the slow log using the &lt;strong&gt;SLOWLOG RESET&lt;/strong&gt; command. Once deleted the information is lost forever.</source>
          <target state="translated">Puede restablecer el registro lento mediante el comando &lt;strong&gt;SLOWLOG RESET&lt;/strong&gt; . Una vez eliminada la informaci&amp;oacute;n se pierde para siempre.</target>
        </trans-unit>
        <trans-unit id="b9a306bfe06d9d53ff2453f3ae75bb161ca70f68" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; to cache a mapping between commands and key positions for each command to enable exact routing of commands to cluster instances.</source>
          <target state="translated">Puede utilizar &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; para almacenar en cach&amp;eacute; un mapeo entre comandos y posiciones clave para cada comando para permitir el enrutamiento exacto de comandos a instancias de cl&amp;uacute;ster.</target>
        </trans-unit>
        <trans-unit id="982dc809a4b37ef3236c50484f4789927b5791e7" translate="yes" xml:space="preserve">
          <source>ZADD</source>
          <target state="translated">ZADD</target>
        </trans-unit>
        <trans-unit id="6177f313ab1038d1d59d1b66ec9d275cc0cf8ab1" translate="yes" xml:space="preserve">
          <source>ZADD  key [NX|XX] [CH] [INCR] score member [score member ...]   Add one or more members to a sorted set, or update its score if it already exists</source>
          <target state="translated">Tecla ZADD [NX|XX][CH][INCR]miembro de la puntuación [miembro de la puntuación ...]Añadir uno o más miembros a un conjunto ordenado,o actualizar su puntuación si ya existe</target>
        </trans-unit>
        <trans-unit id="4f8afb3eddddde7b33d3416faa0bab41af0d92a8" translate="yes" xml:space="preserve">
          <source>ZADD options (Redis 3.0.2 or greater)</source>
          <target state="translated">Opciones de ZADD (Redis 3.0.2 o mayor)</target>
        </trans-unit>
        <trans-unit id="a7a9fbac3f0c656f3700c863f729a302d743a955" translate="yes" xml:space="preserve">
          <source>ZADD supports a list of options, specified after the name of the key and before the first score argument. Options are:</source>
          <target state="translated">ZADD soporta una lista de opciones,especificadas después del nombre de la clave y antes del primer argumento de puntuación.Las opciones son:</target>
        </trans-unit>
        <trans-unit id="f9f219843e0eb0ba98e20a09e67012582a7ff9ae" translate="yes" xml:space="preserve">
          <source>ZCARD</source>
          <target state="translated">ZCARD</target>
        </trans-unit>
        <trans-unit id="a62da7b8917269eab9d4a5b4830a8b279fcfbdd4" translate="yes" xml:space="preserve">
          <source>ZCARD  key   Get the number of members in a sorted set</source>
          <target state="translated">Tecla ZCARD Obtener el número de miembros en un conjunto ordenado</target>
        </trans-unit>
        <trans-unit id="804c958c7b73b3b648a5e268179bcee1309d8397" translate="yes" xml:space="preserve">
          <source>ZCOUNT</source>
          <target state="translated">ZCOUNT</target>
        </trans-unit>
        <trans-unit id="e7b1de6d30e0d1314b3c3f1cff1a4bd4ee2f0cbe" translate="yes" xml:space="preserve">
          <source>ZCOUNT  key min max   Count the members in a sorted set with scores within the given values</source>
          <target state="translated">ZCOUNT key min max Contar los miembros en un conjunto ordenado con puntuaciones dentro de los valores dados</target>
        </trans-unit>
        <trans-unit id="48eb6f84de3d0a2896cb3c94e2d2ef6356f730bb" translate="yes" xml:space="preserve">
          <source>ZINCRBY</source>
          <target state="translated">ZINCRBY</target>
        </trans-unit>
        <trans-unit id="082214abb531096524452afc40cb936da34a4f6b" translate="yes" xml:space="preserve">
          <source>ZINCRBY  key increment member   Increment the score of a member in a sorted set</source>
          <target state="translated">ZINCRBY key increment member Incrementar la puntuación de un miembro en un conjunto clasificado</target>
        </trans-unit>
        <trans-unit id="84ba546493355b0b49bfc8f962db2ce108f69f84" translate="yes" xml:space="preserve">
          <source>ZINTERSTORE</source>
          <target state="translated">ZINTERSTORE</target>
        </trans-unit>
        <trans-unit id="e6944d941d1e5237d181c2778b08d5deaec8163d" translate="yes" xml:space="preserve">
          <source>ZINTERSTORE  destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]   Intersect multiple sorted sets and store the resulting sorted set in a new key</source>
          <target state="translated">Destino de ZINTERSTORE teclas numéricas tecla [tecla ...][PESO peso [peso ...]][AGREGAR SUMARIO]Intersecta múltiples conjuntos ordenados y almacena el conjunto ordenado resultante en una nueva tecla</target>
        </trans-unit>
        <trans-unit id="6f7c7f93ff22369bc12ca7853301e566ef1d6330" translate="yes" xml:space="preserve">
          <source>ZLEXCOUNT</source>
          <target state="translated">ZLEXCOUNT</target>
        </trans-unit>
        <trans-unit id="69fdddce610cf780982de18264e4a3ec8a4d0cbf" translate="yes" xml:space="preserve">
          <source>ZLEXCOUNT  key min max   Count the number of members in a sorted set between a given lexicographical range</source>
          <target state="translated">ZLEXCOUNT key min max Contar el número de miembros en un conjunto ordenado entre un rango lexicográfico determinado</target>
        </trans-unit>
        <trans-unit id="df6072781ef70d69579c9a9f687049bff57ec171" translate="yes" xml:space="preserve">
          <source>ZPOPMAX</source>
          <target state="translated">ZPOPMAX</target>
        </trans-unit>
        <trans-unit id="c4a7ccc60d50bdf63d3ce3e84bcddd3c73436b7a" translate="yes" xml:space="preserve">
          <source>ZPOPMAX  key [count]   Remove and return members with the highest scores in a sorted set</source>
          <target state="translated">Tecla ZPOPMAX [recuento]Quitar y devolver los miembros con las puntuaciones más altas en un conjunto ordenado</target>
        </trans-unit>
        <trans-unit id="275afe97d970634d3b438a2df7d2597650e176af" translate="yes" xml:space="preserve">
          <source>ZPOPMIN</source>
          <target state="translated">ZPOPMIN</target>
        </trans-unit>
        <trans-unit id="be3c3964166a2f153136364e00fc24d6f225ab55" translate="yes" xml:space="preserve">
          <source>ZPOPMIN  key [count]   Remove and return members with the lowest scores in a sorted set</source>
          <target state="translated">Clave ZPOPMIN [recuento]Quitar y devolver a los miembros con las puntuaciones más bajas en un conjunto ordenado</target>
        </trans-unit>
        <trans-unit id="02622bfb82d4bfd8a5ab07e9f83ced4394aed928" translate="yes" xml:space="preserve">
          <source>ZRANGE</source>
          <target state="translated">ZRANGE</target>
        </trans-unit>
        <trans-unit id="03dad4a4ada2d7d58013533b78248011292b810c" translate="yes" xml:space="preserve">
          <source>ZRANGE  key start stop [WITHSCORES]   Return a range of members in a sorted set, by index</source>
          <target state="translated">ZRANGE key start stop [WITHSCORES]Devuelve un rango de miembros en un conjunto ordenado,por índice</target>
        </trans-unit>
        <trans-unit id="bba4651818ea34d8734b75b5671a21d9220ac1b9" translate="yes" xml:space="preserve">
          <source>ZRANGEBYLEX</source>
          <target state="translated">ZRANGEBYLEX</target>
        </trans-unit>
        <trans-unit id="364664a0fd916084bc6efee334586840847f26d3" translate="yes" xml:space="preserve">
          <source>ZRANGEBYLEX  key min max [LIMIT offset count]   Return a range of members in a sorted set, by lexicographical range</source>
          <target state="translated">Tecla ZRANGEBYLEX mín.máx.[Límite de compensación]Devuelve un rango de miembros en un conjunto ordenado,por rango lexicográfico</target>
        </trans-unit>
        <trans-unit id="c571cee5ee859758a0a48f9ac7f4765d68f01ae8" translate="yes" xml:space="preserve">
          <source>ZRANGEBYSCORE</source>
          <target state="translated">ZRANGEBYSCORE</target>
        </trans-unit>
        <trans-unit id="673cf1d9accf226f0f9e4e818378d95b64fc8bbd" translate="yes" xml:space="preserve">
          <source>ZRANGEBYSCORE  key min max [WITHSCORES] [LIMIT offset count]   Return a range of members in a sorted set, by score</source>
          <target state="translated">ZRANGEBYSCORE tecla min max [PUNTAJE][LÍMITE DE DESPLAZAMIENTO]Devuelve un rango de miembros en un conjunto ordenado,por puntuación</target>
        </trans-unit>
        <trans-unit id="9e9292abec9b8be858e37bb566f832cba106aa55" translate="yes" xml:space="preserve">
          <source>ZRANK</source>
          <target state="translated">ZRANK</target>
        </trans-unit>
        <trans-unit id="b59410720d26d04d6711618b591552b150d8cec0" translate="yes" xml:space="preserve">
          <source>ZRANK  key member   Determine the index of a member in a sorted set</source>
          <target state="translated">ZRANK key member Determinar el índice de un miembro en un conjunto ordenado</target>
        </trans-unit>
        <trans-unit id="62d49b0445d01f6366a124bdb6d14f53816b8411" translate="yes" xml:space="preserve">
          <source>ZREM</source>
          <target state="translated">ZREM</target>
        </trans-unit>
        <trans-unit id="51cc8ecde226c2ed459594cb655dac013638e3d7" translate="yes" xml:space="preserve">
          <source>ZREM  key member [member ...]   Remove one or more members from a sorted set</source>
          <target state="translated">Miembro clave de ZREM [miembro ...]Eliminar uno o más miembros de un conjunto ordenado</target>
        </trans-unit>
        <trans-unit id="ddfd8131e4f4a552bfa5a7b84dd4b52d07f655e9" translate="yes" xml:space="preserve">
          <source>ZREMRANGEBYLEX</source>
          <target state="translated">ZREMRANGEBYLEX</target>
        </trans-unit>
        <trans-unit id="f4800e3831951112ba80954f2b1827cc696db96f" translate="yes" xml:space="preserve">
          <source>ZREMRANGEBYLEX  key min max   Remove all members in a sorted set between the given lexicographical range</source>
          <target state="translated">ZREMRANGEBYLEX clave min max Eliminar todos los miembros en un conjunto ordenado entre el rango lexicográfico dado</target>
        </trans-unit>
        <trans-unit id="73a090151aaf8b520afa0541459a1792f3770d65" translate="yes" xml:space="preserve">
          <source>ZREMRANGEBYRANK</source>
          <target state="translated">ZREMRANGEBYRANK</target>
        </trans-unit>
        <trans-unit id="ce886409d64013690650f17c09223970423c30ea" translate="yes" xml:space="preserve">
          <source>ZREMRANGEBYRANK  key start stop   Remove all members in a sorted set within the given indexes</source>
          <target state="translated">ZREMRANGEBYRANK clave inicio parada Eliminar todos los miembros en un conjunto ordenado dentro de los índices dados</target>
        </trans-unit>
        <trans-unit id="931530552d190d1adb44e3baed061941b99e49d1" translate="yes" xml:space="preserve">
          <source>ZREMRANGEBYSCORE</source>
          <target state="translated">ZREMRANGEBYSCORE</target>
        </trans-unit>
        <trans-unit id="2e5ffa7a59f892be67c275cea48e9dd25a95faad" translate="yes" xml:space="preserve">
          <source>ZREMRANGEBYSCORE  key min max   Remove all members in a sorted set within the given scores</source>
          <target state="translated">ZREMRANGEBYSCORE clave min max Eliminar todos los miembros en un conjunto ordenado dentro de las puntuaciones dadas</target>
        </trans-unit>
        <trans-unit id="4b069fdb8bc0529507b3a762e5a538395040c04e" translate="yes" xml:space="preserve">
          <source>ZREVRANGE</source>
          <target state="translated">ZREVRANGE</target>
        </trans-unit>
        <trans-unit id="88e5008c0f89447cea6090639d24238cf393c483" translate="yes" xml:space="preserve">
          <source>ZREVRANGE  key start stop [WITHSCORES]   Return a range of members in a sorted set, by index, with scores ordered from high to low</source>
          <target state="translated">ZREVRANGE tecla inicio parada [PUNTAJE]Devuelve un rango de miembros en un conjunto ordenado,por índice,con las puntuaciones ordenadas de alto a bajo</target>
        </trans-unit>
        <trans-unit id="d3a185af30bf9fc2dd922952dc1f011d8944f1f6" translate="yes" xml:space="preserve">
          <source>ZREVRANGEBYLEX</source>
          <target state="translated">ZREVRANGEBYLEX</target>
        </trans-unit>
        <trans-unit id="487b7021367b6913a83cf7bca0ebd6dd7abed360" translate="yes" xml:space="preserve">
          <source>ZREVRANGEBYLEX  key max min [LIMIT offset count]   Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.</source>
          <target state="translated">ZREVRANGEBYLEX key max min [LIMITE offset count]Devuelve un rango de miembros en un conjunto ordenado,por rango lexicográfico,ordenado de cuerdas más altas a más bajas.</target>
        </trans-unit>
        <trans-unit id="d77f06d347bf28d692faa21a65a62dfeba0778c7" translate="yes" xml:space="preserve">
          <source>ZREVRANGEBYSCORE</source>
          <target state="translated">ZREVRANGEBYSCORE</target>
        </trans-unit>
        <trans-unit id="0a6ca5efbd36844810b35910dbd06d7ae2620043" translate="yes" xml:space="preserve">
          <source>ZREVRANGEBYSCORE  key max min [WITHSCORES] [LIMIT offset count]   Return a range of members in a sorted set, by score, with scores ordered from high to low</source>
          <target state="translated">ZREVRANGEBYSCORE tecla max min [PUNTAJE][LÍMITE DE DESPLAZAMIENTO]Devuelve un rango de miembros en un conjunto ordenado,por puntuación,con las puntuaciones ordenadas de alto a bajo</target>
        </trans-unit>
        <trans-unit id="72a6a00dce764b5250de9696fec2f9f8782ae2e0" translate="yes" xml:space="preserve">
          <source>ZREVRANK</source>
          <target state="translated">ZREVRANK</target>
        </trans-unit>
        <trans-unit id="7701bc079e1d6ed2096984e7cd8af2ebd28c2baf" translate="yes" xml:space="preserve">
          <source>ZREVRANK  key member   Determine the index of a member in a sorted set, with scores ordered from high to low</source>
          <target state="translated">ZREVRANK miembro clave Determinar el índice de un miembro en un conjunto clasificado,con las puntuaciones ordenadas de alto a bajo</target>
        </trans-unit>
        <trans-unit id="6f5762d24c0d19676a03c0c372ac1c834e87f776" translate="yes" xml:space="preserve">
          <source>ZSCAN</source>
          <target state="translated">ZSCAN</target>
        </trans-unit>
        <trans-unit id="7c4eb07f6f758aee31c0a62929e18d1e96d2005b" translate="yes" xml:space="preserve">
          <source>ZSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate sorted sets elements and associated scores</source>
          <target state="translated">Cursor de la tecla ZSCAN [Patrón de coincidencia][Recuento]iterativo incremental de elementos de conjuntos ordenados y puntuaciones asociadas</target>
        </trans-unit>
        <trans-unit id="85c614c75215d2c232b8b4724626ecc6b4444df5" translate="yes" xml:space="preserve">
          <source>ZSCORE</source>
          <target state="translated">ZSCORE</target>
        </trans-unit>
        <trans-unit id="6cb8dc26a70bb55036029263331e2998e670ff4d" translate="yes" xml:space="preserve">
          <source>ZSCORE  key member   Get the score associated with the given member in a sorted set</source>
          <target state="translated">Miembro clave de ZSCORE Obtener la puntuación asociada con el miembro dado en un conjunto ordenado</target>
        </trans-unit>
        <trans-unit id="3b0cd69f0ee4f0f5cbdddc1a691185b9b3cf2292" translate="yes" xml:space="preserve">
          <source>ZUNIONSTORE</source>
          <target state="translated">ZUNIONSTORE</target>
        </trans-unit>
        <trans-unit id="c40bfc97a4da4b676924dcf67e9bc86b2bd64973" translate="yes" xml:space="preserve">
          <source>ZUNIONSTORE  destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]   Add multiple sorted sets and store the resulting sorted set in a new key</source>
          <target state="translated">Destino de ZUNIONSTORE teclas numéricas tecla [tecla ...][PESO peso [peso ...]][AGREGAR SUMA|MIN|MAX]Agregar varios conjuntos ordenados y almacenar el conjunto ordenado resultante en una nueva tecla</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="66a36e77fd002579809717841f998f4d21cd5913" translate="yes" xml:space="preserve">
          <source>auth</source>
          <target state="translated">auth</target>
        </trans-unit>
        <trans-unit id="d2f7ffda236a4282eaecf1b0bac8e7f60f8bc3d9" translate="yes" xml:space="preserve">
          <source>bgrewriteaof</source>
          <target state="translated">bgrewriteaof</target>
        </trans-unit>
        <trans-unit id="162c92cbd78d3a5882249a5dbd8c3f9cd611ffb6" translate="yes" xml:space="preserve">
          <source>bgsave</source>
          <target state="translated">bgsave</target>
        </trans-unit>
        <trans-unit id="4da764e1824ae57728952e1b0615985ed94f59b9" translate="yes" xml:space="preserve">
          <source>bitcount</source>
          <target state="translated">bitcount</target>
        </trans-unit>
        <trans-unit id="4116f1c32d5697642f6c01c7ac8d142fa62586b8" translate="yes" xml:space="preserve">
          <source>bitfield</source>
          <target state="translated">bitfield</target>
        </trans-unit>
        <trans-unit id="663131996a1f110e30b70f0947ec89eaf1232c6a" translate="yes" xml:space="preserve">
          <source>bitop</source>
          <target state="translated">bitop</target>
        </trans-unit>
        <trans-unit id="8ce3cff1066e4c8190d71db881283f3c41a7d438" translate="yes" xml:space="preserve">
          <source>bitpos</source>
          <target state="translated">bitpos</target>
        </trans-unit>
        <trans-unit id="551b189ef8b4f0e5b241a8535cad8aacf7936bec" translate="yes" xml:space="preserve">
          <source>blpop</source>
          <target state="translated">blpop</target>
        </trans-unit>
        <trans-unit id="2c584f8b7988c47b090f979adf77d8a93b13c6fe" translate="yes" xml:space="preserve">
          <source>brpop</source>
          <target state="translated">brpop</target>
        </trans-unit>
        <trans-unit id="71753c679731a8206add7d892464e306b96f240f" translate="yes" xml:space="preserve">
          <source>brpoplpush</source>
          <target state="translated">brpoplpush</target>
        </trans-unit>
        <trans-unit id="f4d9b92be85f72d89560234ab670f7f0c693e8bc" translate="yes" xml:space="preserve">
          <source>bzpopmax</source>
          <target state="translated">bzpopmax</target>
        </trans-unit>
        <trans-unit id="ca49d94361d803beda2848f47fe89b3685e92e10" translate="yes" xml:space="preserve">
          <source>bzpopmin</source>
          <target state="translated">bzpopmin</target>
        </trans-unit>
        <trans-unit id="3a86539cd55319263f3a19c588b0285effbfb000" translate="yes" xml:space="preserve">
          <source>client getname</source>
          <target state="translated">nombre de pila del cliente</target>
        </trans-unit>
        <trans-unit id="81cf703b98123442eeba253fddb9127d1d84c862" translate="yes" xml:space="preserve">
          <source>client id</source>
          <target state="translated">identificación del cliente</target>
        </trans-unit>
        <trans-unit id="88726cca60ec5c915171c4a420d59a8900387c18" translate="yes" xml:space="preserve">
          <source>client kill</source>
          <target state="translated">cliente matar</target>
        </trans-unit>
        <trans-unit id="987bc4556044f864b76947c83450ff5b10bebfe2" translate="yes" xml:space="preserve">
          <source>client list</source>
          <target state="translated">lista de clientes</target>
        </trans-unit>
        <trans-unit id="a2f654db226666d857b2282c499e0c2b32377dc9" translate="yes" xml:space="preserve">
          <source>client pause</source>
          <target state="translated">cliente de la ruptura</target>
        </trans-unit>
        <trans-unit id="ffb26747154ba2157bb31d208021c581bbe32601" translate="yes" xml:space="preserve">
          <source>client reply</source>
          <target state="translated">cliente de respuesta</target>
        </trans-unit>
        <trans-unit id="1d756097b36df1bebe2bb2fb4902de8c3316c19e" translate="yes" xml:space="preserve">
          <source>client setname</source>
          <target state="translated">setname client</target>
        </trans-unit>
        <trans-unit id="99f2f80036bba41bc398f2813af0b933b7fcde25" translate="yes" xml:space="preserve">
          <source>client unblock</source>
          <target state="translated">desbloquear al cliente</target>
        </trans-unit>
        <trans-unit id="43f0891a860ab378527d43b393484eafc5c7df65" translate="yes" xml:space="preserve">
          <source>cluster addslots</source>
          <target state="translated">grupos de gráficos de adición</target>
        </trans-unit>
        <trans-unit id="19478cb96b68d0728a218e76348a6fd4e4a96337" translate="yes" xml:space="preserve">
          <source>cluster count failure reports</source>
          <target state="translated">informes de fallos en el recuento de grupos</target>
        </trans-unit>
        <trans-unit id="2db020ffd4f2a845d340a5ad10901c35f818ba8d" translate="yes" xml:space="preserve">
          <source>cluster countkeysinslot</source>
          <target state="translated">cluster countkeysinslot</target>
        </trans-unit>
        <trans-unit id="489a6acb0ff69cf01acd32da20608bfa0277c6c6" translate="yes" xml:space="preserve">
          <source>cluster delslots</source>
          <target state="translated">cluster delslots</target>
        </trans-unit>
        <trans-unit id="407156e9dd303b8d4ce5e0165cb27f26ed949a6a" translate="yes" xml:space="preserve">
          <source>cluster failover</source>
          <target state="translated">falla del grupo</target>
        </trans-unit>
        <trans-unit id="ce1869c36223c8c6329dbf77306bbf492681bcbf" translate="yes" xml:space="preserve">
          <source>cluster forget</source>
          <target state="translated">Olvídese de los grupos</target>
        </trans-unit>
        <trans-unit id="c6fe721552461ae597503d49076efe4974e2b171" translate="yes" xml:space="preserve">
          <source>cluster getkeysinslot</source>
          <target state="translated">bloqueo del teclado de grupo</target>
        </trans-unit>
        <trans-unit id="3aacda588fa9e3bcda9b4a90c5dcab259c6425e7" translate="yes" xml:space="preserve">
          <source>cluster info</source>
          <target state="translated">información del grupo</target>
        </trans-unit>
        <trans-unit id="d8b32dd9fcb82d4ecea8f7f928b2b8c576a2e897" translate="yes" xml:space="preserve">
          <source>cluster keyslot</source>
          <target state="translated">ranura de claves de clústeres</target>
        </trans-unit>
        <trans-unit id="684f13185ba4589d99a16b3daccb4e90c9585f15" translate="yes" xml:space="preserve">
          <source>cluster meet</source>
          <target state="translated">medición de cúmulos</target>
        </trans-unit>
        <trans-unit id="b1911a5f60aad1060e23305729b01ebfdd56e7d0" translate="yes" xml:space="preserve">
          <source>cluster nodes</source>
          <target state="translated">nodos de cúmulo</target>
        </trans-unit>
        <trans-unit id="2cf65c6c6fe6bbce45825770e26027da0efcd0c1" translate="yes" xml:space="preserve">
          <source>cluster replicas</source>
          <target state="translated">réplicas de cúmulos</target>
        </trans-unit>
        <trans-unit id="442f81c0f4970ce91726953447fb971c9c2ad776" translate="yes" xml:space="preserve">
          <source>cluster replicate</source>
          <target state="translated">replicarse en grupo</target>
        </trans-unit>
        <trans-unit id="395b418e96d2f96ec16bd3bf8c50cd6789494dbf" translate="yes" xml:space="preserve">
          <source>cluster reset</source>
          <target state="translated">reajuste del grupo</target>
        </trans-unit>
        <trans-unit id="05e2dbd82dc573205585c712e03aeaee7926a065" translate="yes" xml:space="preserve">
          <source>cluster saveconfig</source>
          <target state="translated">saveconfig cluster</target>
        </trans-unit>
        <trans-unit id="bceff60fbd877d85d8ebab25ec27a6a5d71969f4" translate="yes" xml:space="preserve">
          <source>cluster set config epoch</source>
          <target state="translated">cluster set config epoca</target>
        </trans-unit>
        <trans-unit id="8ce0fc728ba93e75e4ce70260bc4c0cb0a0267a8" translate="yes" xml:space="preserve">
          <source>cluster setslot</source>
          <target state="translated">ranura de grupo</target>
        </trans-unit>
        <trans-unit id="853f2313018039eeb3271a901d5fe6a4521e1b7e" translate="yes" xml:space="preserve">
          <source>cluster slaves</source>
          <target state="translated">esclavos en racimo</target>
        </trans-unit>
        <trans-unit id="0877a0e38bf8420a09cac6d93ab059dcba8f6efa" translate="yes" xml:space="preserve">
          <source>cluster slots</source>
          <target state="translated">ranuras de cúmulo</target>
        </trans-unit>
        <trans-unit id="571f8a022f4350d29c7bb85cd07863200d7a6569" translate="yes" xml:space="preserve">
          <source>cmsgpack</source>
          <target state="translated">cmsgpack</target>
        </trans-unit>
        <trans-unit id="1925f793093581c47a5c6b2e414506b1cbae280d" translate="yes" xml:space="preserve">
          <source>command</source>
          <target state="translated">command</target>
        </trans-unit>
        <trans-unit id="5c789a928708dc57106493f3a30f343d43f1dd84" translate="yes" xml:space="preserve">
          <source>command arity specification</source>
          <target state="translated">especificación de la aridez del comando</target>
        </trans-unit>
        <trans-unit id="aadb4afdbc1dedd8ecc857b71881d35b7637a9f2" translate="yes" xml:space="preserve">
          <source>command count</source>
          <target state="translated">cuenta de comando</target>
        </trans-unit>
        <trans-unit id="7454889839f3de80212539102236bf42aa8c973e" translate="yes" xml:space="preserve">
          <source>command getkeys</source>
          <target state="translated">llaves de mando</target>
        </trans-unit>
        <trans-unit id="6042ca09cffc5a5aaaaa8113c902b46b7e0c2c1e" translate="yes" xml:space="preserve">
          <source>command info</source>
          <target state="translated">información del comando</target>
        </trans-unit>
        <trans-unit id="ecaf24f591fc3d7ae531589de304494df415517b" translate="yes" xml:space="preserve">
          <source>command name</source>
          <target state="translated">nombre del comando</target>
        </trans-unit>
        <trans-unit id="fa1b2e09003258d2892b88b9898ff5fa5ee8743b" translate="yes" xml:space="preserve">
          <source>config get</source>
          <target state="translated">config configúrense</target>
        </trans-unit>
        <trans-unit id="bf2c88801f916f8d4285be683516972f04952be9" translate="yes" xml:space="preserve">
          <source>config resetstat</source>
          <target state="translated">Configurar el estado de restablecimiento</target>
        </trans-unit>
        <trans-unit id="c1939713a6322995f901d8c083725370856a140a" translate="yes" xml:space="preserve">
          <source>config rewrite</source>
          <target state="translated">configurar reescribir</target>
        </trans-unit>
        <trans-unit id="14a46d436e3d2d18e697522bfd72be6e705f84e1" translate="yes" xml:space="preserve">
          <source>config set</source>
          <target state="translated">set de configuración</target>
        </trans-unit>
        <trans-unit id="dac92f73ee69bfb9fb2f827e8b4621c3941f2061" translate="yes" xml:space="preserve">
          <source>dbsize</source>
          <target state="translated">dbsize</target>
        </trans-unit>
        <trans-unit id="106977a7f15c4f2bed5d076f04cb405ddd9ad19a" translate="yes" xml:space="preserve">
          <source>debug object</source>
          <target state="translated">objeto de depuración</target>
        </trans-unit>
        <trans-unit id="89bfa476c3240daabd7cdf8d211878ead7c26cdb" translate="yes" xml:space="preserve">
          <source>debug segfault</source>
          <target state="translated">depurar el fallo de segmento</target>
        </trans-unit>
        <trans-unit id="11d16d7147770b76fc7b6992a8de8f21048a0773" translate="yes" xml:space="preserve">
          <source>decr</source>
          <target state="translated">decr</target>
        </trans-unit>
        <trans-unit id="6f9465483f68b26e75ca54393520b0fd717577e0" translate="yes" xml:space="preserve">
          <source>decrby</source>
          <target state="translated">decrby</target>
        </trans-unit>
        <trans-unit id="fea453f853c8645b085126e6517eab38dfaa022f" translate="yes" xml:space="preserve">
          <source>del</source>
          <target state="translated">del</target>
        </trans-unit>
        <trans-unit id="f57e38069445fdec820e61935325ba944c1c8fe4" translate="yes" xml:space="preserve">
          <source>discard</source>
          <target state="translated">discard</target>
        </trans-unit>
        <trans-unit id="9567d1547e105470e4e53c1568f07a209e82a161" translate="yes" xml:space="preserve">
          <source>dump</source>
          <target state="translated">dump</target>
        </trans-unit>
        <trans-unit id="b2d21e771d9f86865c5eff193663574dd1796c8f" translate="yes" xml:space="preserve">
          <source>echo</source>
          <target state="translated">echo</target>
        </trans-unit>
        <trans-unit id="822bc13e2d55b402eb4233cb23c9d414a7a03bc1" translate="yes" xml:space="preserve">
          <source>eval</source>
          <target state="translated">eval</target>
        </trans-unit>
        <trans-unit id="3803c2b7cbdf45e93c59ce2b7549e1ea3d9b2dfd" translate="yes" xml:space="preserve">
          <source>evalsha</source>
          <target state="translated">evalsha</target>
        </trans-unit>
        <trans-unit id="be62562725d30894d1641b11d5106adde66f0d79" translate="yes" xml:space="preserve">
          <source>exec</source>
          <target state="translated">exec</target>
        </trans-unit>
        <trans-unit id="4d68c8f13459c0edb40504de5003ec2a6b74e613" translate="yes" xml:space="preserve">
          <source>exists</source>
          <target state="translated">exists</target>
        </trans-unit>
        <trans-unit id="20dda04ba85cc1d159e6c80f0473186d495ab0ca" translate="yes" xml:space="preserve">
          <source>expire</source>
          <target state="translated">expire</target>
        </trans-unit>
        <trans-unit id="7226fd219a87d93b2f0b2ca89a6d3a3c278f9bc7" translate="yes" xml:space="preserve">
          <source>expireat</source>
          <target state="translated">expireat</target>
        </trans-unit>
        <trans-unit id="ae9f9cc9d4997b668f7b5b3c3ea576aa20aa1683" translate="yes" xml:space="preserve">
          <source>flushall</source>
          <target state="translated">flushall</target>
        </trans-unit>
        <trans-unit id="d353b700f6ff37ded1726231acdcbb224744d6f2" translate="yes" xml:space="preserve">
          <source>flushdb</source>
          <target state="translated">flushdb</target>
        </trans-unit>
        <trans-unit id="09e0e28eee16aec03f0b1c28a341590be881ddfb" translate="yes" xml:space="preserve">
          <source>geoadd</source>
          <target state="translated">geoadd</target>
        </trans-unit>
        <trans-unit id="68afe824679e16d128ba81a79ba54b75c90e1a43" translate="yes" xml:space="preserve">
          <source>geodist</source>
          <target state="translated">geodist</target>
        </trans-unit>
        <trans-unit id="776fd947b10434bc0aebf706ed99b396161ce1bf" translate="yes" xml:space="preserve">
          <source>geohash</source>
          <target state="translated">geohash</target>
        </trans-unit>
        <trans-unit id="6ad8c5871971fc93ef8607efe29d93df354d0f73" translate="yes" xml:space="preserve">
          <source>geopos</source>
          <target state="translated">geopos</target>
        </trans-unit>
        <trans-unit id="ca76e452ae9157cb5b550a7af40a27ee239d231f" translate="yes" xml:space="preserve">
          <source>georadius</source>
          <target state="translated">georadius</target>
        </trans-unit>
        <trans-unit id="340cc747269051874e991833be48cf2e8dc71eb1" translate="yes" xml:space="preserve">
          <source>georadiusbymember</source>
          <target state="translated">georadiusbymember</target>
        </trans-unit>
        <trans-unit id="783923e57ba5e8f1044632c31fd806ee24814bb5" translate="yes" xml:space="preserve">
          <source>get</source>
          <target state="translated">get</target>
        </trans-unit>
        <trans-unit id="ca6fcc29bd59a424c199f7bc78e4b08c64a4ce44" translate="yes" xml:space="preserve">
          <source>getbit</source>
          <target state="translated">getbit</target>
        </trans-unit>
        <trans-unit id="e1dd04bfc57be1394d76171d3fab84ab0adc60b9" translate="yes" xml:space="preserve">
          <source>getrange</source>
          <target state="translated">getrange</target>
        </trans-unit>
        <trans-unit id="1f90d8ff0d9f154dd86fcc470f9734222d99b2de" translate="yes" xml:space="preserve">
          <source>getset</source>
          <target state="translated">getset</target>
        </trans-unit>
        <trans-unit id="f371e20371066319ebfb0ed44f5369dd63aa8148" translate="yes" xml:space="preserve">
          <source>hdel</source>
          <target state="translated">hdel</target>
        </trans-unit>
        <trans-unit id="48dd8f5e67fcee366a64b82bbe4bd1e016ba4fb5" translate="yes" xml:space="preserve">
          <source>hexists</source>
          <target state="translated">hexists</target>
        </trans-unit>
        <trans-unit id="58f1fe06294f78478f896ad446c2d95d270189de" translate="yes" xml:space="preserve">
          <source>hget</source>
          <target state="translated">hget</target>
        </trans-unit>
        <trans-unit id="1b75497379ef6f664d175ff6a0359e22cc81acc7" translate="yes" xml:space="preserve">
          <source>hgetall</source>
          <target state="translated">hgetall</target>
        </trans-unit>
        <trans-unit id="fefa3a7ad3a712f132fb5f749245e169d235e3aa" translate="yes" xml:space="preserve">
          <source>hincrby</source>
          <target state="translated">hincrby</target>
        </trans-unit>
        <trans-unit id="0a69c73b2f7da8a5b1f6bdcaef66175f7bd4f618" translate="yes" xml:space="preserve">
          <source>hincrbyfloat</source>
          <target state="translated">hincrbyfloat</target>
        </trans-unit>
        <trans-unit id="4c08cd3399b4dc23ec850d998d71dfcbc1c63086" translate="yes" xml:space="preserve">
          <source>hkeys</source>
          <target state="translated">hkeys</target>
        </trans-unit>
        <trans-unit id="005adca130ac1314233f3bfee7c1e52507702766" translate="yes" xml:space="preserve">
          <source>hlen</source>
          <target state="translated">hlen</target>
        </trans-unit>
        <trans-unit id="c40c03a625269eb67b808649e85aa25383bae16a" translate="yes" xml:space="preserve">
          <source>hmget</source>
          <target state="translated">hmget</target>
        </trans-unit>
        <trans-unit id="1105eff3a6bffe84f6f00b7c4354f38e617b305a" translate="yes" xml:space="preserve">
          <source>hmset</source>
          <target state="translated">hmset</target>
        </trans-unit>
        <trans-unit id="0b44733aab04ffe53c69466a41f6e13ecea1d287" translate="yes" xml:space="preserve">
          <source>hscan</source>
          <target state="translated">hscan</target>
        </trans-unit>
        <trans-unit id="629040408fd7e7bd0e42e4a99f251c859ede5c2b" translate="yes" xml:space="preserve">
          <source>hset</source>
          <target state="translated">hset</target>
        </trans-unit>
        <trans-unit id="8b852fd008c3882df9db9a1c2a2bb0e05886b1b7" translate="yes" xml:space="preserve">
          <source>hsetnx</source>
          <target state="translated">hsetnx</target>
        </trans-unit>
        <trans-unit id="d677897242b8dd05e700c36696d0e910d0ca21e5" translate="yes" xml:space="preserve">
          <source>hstrlen</source>
          <target state="translated">hstrlen</target>
        </trans-unit>
        <trans-unit id="eac1e4b98eca5770635f00bec992aa33ff7b283b" translate="yes" xml:space="preserve">
          <source>hvals</source>
          <target state="translated">hvals</target>
        </trans-unit>
        <trans-unit id="58086838f67374476c0a7d5d55c207529a620fa4" translate="yes" xml:space="preserve">
          <source>incr</source>
          <target state="translated">incr</target>
        </trans-unit>
        <trans-unit id="f7a069b6026bb00f44b51804fcb3d2908cb9381b" translate="yes" xml:space="preserve">
          <source>incrby</source>
          <target state="translated">incrby</target>
        </trans-unit>
        <trans-unit id="2e4bcf022a203f0fc749c50887cf61c5ae2b4c1f" translate="yes" xml:space="preserve">
          <source>incrbyfloat</source>
          <target state="translated">incrbyfloat</target>
        </trans-unit>
        <trans-unit id="59bd0a3ff43b32849b319e645d4798d8a5d1e889" translate="yes" xml:space="preserve">
          <source>info</source>
          <target state="translated">info</target>
        </trans-unit>
        <trans-unit id="304cd7bde8c8a066e9ddc11f5d17d8c69ab28cfc" translate="yes" xml:space="preserve">
          <source>is exactly equivalent to</source>
          <target state="translated">es exactamente equivalente a</target>
        </trans-unit>
        <trans-unit id="5a378fc0bcf211349c534e75bcde1ab24207890e" translate="yes" xml:space="preserve">
          <source>is valid and will kill only a pubsub client with the specified address. This format containing multiple filters is rarely useful currently.</source>
          <target state="translated">es válido y sólo matará a un cliente del pubsub con la dirección especificada.Este formato que contiene múltiples filtros no suele ser útil en la actualidad.</target>
        </trans-unit>
        <trans-unit id="5944ae25418ceabcf285dca1d721b77888dac89b" translate="yes" xml:space="preserve">
          <source>keys</source>
          <target state="translated">keys</target>
        </trans-unit>
        <trans-unit id="e8c88bf1d7b13f4f56f0a03e0ade21e63b2e7b27" translate="yes" xml:space="preserve">
          <source>lastsave</source>
          <target state="translated">lastsave</target>
        </trans-unit>
        <trans-unit id="f4719088a81084b19ee1fa4b504bab9fa6094134" translate="yes" xml:space="preserve">
          <source>lindex</source>
          <target state="translated">lindex</target>
        </trans-unit>
        <trans-unit id="e1073c766b90be7724d21e19ac7d7c52e174421f" translate="yes" xml:space="preserve">
          <source>linsert</source>
          <target state="translated">linsert</target>
        </trans-unit>
        <trans-unit id="91b9502eb092996269765f5bfe2a69619ddabfd6" translate="yes" xml:space="preserve">
          <source>llen</source>
          <target state="translated">llen</target>
        </trans-unit>
        <trans-unit id="fe18c7670939044a3501dd836416694756301df1" translate="yes" xml:space="preserve">
          <source>lpop</source>
          <target state="translated">lpop</target>
        </trans-unit>
        <trans-unit id="6fc389b36b7fa594ae026992fad6543dfe453bb9" translate="yes" xml:space="preserve">
          <source>lpush</source>
          <target state="translated">lpush</target>
        </trans-unit>
        <trans-unit id="bf7c7291589b397b8220833074fecad056be8e67" translate="yes" xml:space="preserve">
          <source>lpushx</source>
          <target state="translated">lpushx</target>
        </trans-unit>
        <trans-unit id="3f6e620052a9a240605886c2db02d4c147979f62" translate="yes" xml:space="preserve">
          <source>lrange</source>
          <target state="translated">lrange</target>
        </trans-unit>
        <trans-unit id="e5b44e883b57f154819e832a306df9b43c0c8a56" translate="yes" xml:space="preserve">
          <source>lrem</source>
          <target state="translated">lrem</target>
        </trans-unit>
        <trans-unit id="d98f09dafe5e0b7799611cf986aedf32fbfbdb33" translate="yes" xml:space="preserve">
          <source>lset</source>
          <target state="translated">lset</target>
        </trans-unit>
        <trans-unit id="369e0af3a96afe3c044ba2f9a38657ab79015863" translate="yes" xml:space="preserve">
          <source>ltrim</source>
          <target state="translated">ltrim</target>
        </trans-unit>
        <trans-unit id="c8d47f6bdab977e053ed75b58aba1e26b070dc2b" translate="yes" xml:space="preserve">
          <source>memory doctor</source>
          <target state="translated">El doctor de la memoria</target>
        </trans-unit>
        <trans-unit id="4c44f28c5f5fd4361bca5aa133cda2ecd06f69e0" translate="yes" xml:space="preserve">
          <source>memory help</source>
          <target state="translated">ayuda de memoria</target>
        </trans-unit>
        <trans-unit id="b57fc8596e36d4e789b7065d2a7a6013c4c630a1" translate="yes" xml:space="preserve">
          <source>memory malloc stats</source>
          <target state="translated">estadísticas del mal de la memoria</target>
        </trans-unit>
        <trans-unit id="45a4491e32971ae5968368f21e0ad4a988c2a71c" translate="yes" xml:space="preserve">
          <source>memory purge</source>
          <target state="translated">purga de la memoria</target>
        </trans-unit>
        <trans-unit id="69af74870769cf27e53dde832baf0b4f28ad5e75" translate="yes" xml:space="preserve">
          <source>memory stats</source>
          <target state="translated">estadísticas de la memoria</target>
        </trans-unit>
        <trans-unit id="ec712513f0f6207344ef66ff495df84a9832d61b" translate="yes" xml:space="preserve">
          <source>memory usage</source>
          <target state="translated">uso de la memoria</target>
        </trans-unit>
        <trans-unit id="1a7b943a3557d4ed6fd3f584b19127ce2953a332" translate="yes" xml:space="preserve">
          <source>mget</source>
          <target state="translated">mget</target>
        </trans-unit>
        <trans-unit id="15efc140fd20187528013120d17653825a3b96d9" translate="yes" xml:space="preserve">
          <source>microseconds.</source>
          <target state="translated">microseconds.</target>
        </trans-unit>
        <trans-unit id="ce5070ef8a0cf3e595ae4cf3f73f6a0eca87e346" translate="yes" xml:space="preserve">
          <source>migrate</source>
          <target state="translated">migrate</target>
        </trans-unit>
        <trans-unit id="9796809f7dae482d3123c16585f2b60f97407796" translate="yes" xml:space="preserve">
          <source>monitor</source>
          <target state="translated">monitor</target>
        </trans-unit>
        <trans-unit id="379d6ce99a8a95a7096ab579d454784c82a994d8" translate="yes" xml:space="preserve">
          <source>move</source>
          <target state="translated">move</target>
        </trans-unit>
        <trans-unit id="10c7cf018400e6d5b16e841bff3630db202cf519" translate="yes" xml:space="preserve">
          <source>mset</source>
          <target state="translated">mset</target>
        </trans-unit>
        <trans-unit id="a507b3db048b0bfa03746472364ff61a3b1f1b35" translate="yes" xml:space="preserve">
          <source>msetnx</source>
          <target state="translated">msetnx</target>
        </trans-unit>
        <trans-unit id="fa119f8dd2bd5910063d13016a3ad5909aebf2d8" translate="yes" xml:space="preserve">
          <source>multi</source>
          <target state="translated">multi</target>
        </trans-unit>
        <trans-unit id="1693ee6d54365e811c504a8a36fe92ee198e25b3" translate="yes" xml:space="preserve">
          <source>negative if command has minimum number of required arguments, but may have more.</source>
          <target state="translated">negativo si el comando tiene un mínimo de argumentos requeridos,pero puede tener más.</target>
        </trans-unit>
        <trans-unit id="cf93eb5e6c60df1fd9b8b4d4ef25051ad76a67fe" translate="yes" xml:space="preserve">
          <source>nested &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of command flags</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Respuesta&lt;/a&gt; de matriz anidada de banderas de comando</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="f11f3d182c74d39e2a231a05aad8915f1947f57c" translate="yes" xml:space="preserve">
          <source>persist</source>
          <target state="translated">persist</target>
        </trans-unit>
        <trans-unit id="754a228d6ed6e7d0e2546447cf2601588adab5c5" translate="yes" xml:space="preserve">
          <source>pexpire</source>
          <target state="translated">pexpire</target>
        </trans-unit>
        <trans-unit id="14549a19873b2736ee69ae3cd6aea62fb01616be" translate="yes" xml:space="preserve">
          <source>pexpireat</source>
          <target state="translated">pexpireat</target>
        </trans-unit>
        <trans-unit id="3a4aae4e2c26350aa9134520c58c7f0c1350842e" translate="yes" xml:space="preserve">
          <source>pfadd</source>
          <target state="translated">pfadd</target>
        </trans-unit>
        <trans-unit id="79a95e87e2a9ce00c5ac5283a6cc2658210106d0" translate="yes" xml:space="preserve">
          <source>pfcount</source>
          <target state="translated">pfcount</target>
        </trans-unit>
        <trans-unit id="49362f11a4c8d1fb9e46bd72945a5995ea59d3db" translate="yes" xml:space="preserve">
          <source>pfmerge</source>
          <target state="translated">pfmerge</target>
        </trans-unit>
        <trans-unit id="572982bbc4f29ee92ae2d65a9edc2453d2c9170c" translate="yes" xml:space="preserve">
          <source>ping</source>
          <target state="translated">ping</target>
        </trans-unit>
        <trans-unit id="3119b2f091b97f2b66415e7e47c8f73fe86b0b1c" translate="yes" xml:space="preserve">
          <source>position of first key in argument list</source>
          <target state="translated">posición de la primera llave en la lista de argumentos</target>
        </trans-unit>
        <trans-unit id="6fc93d74b0d18ddc082516bd797c50ca82652853" translate="yes" xml:space="preserve">
          <source>position of last key in argument list</source>
          <target state="translated">posición de la última llave en la lista de argumentos</target>
        </trans-unit>
        <trans-unit id="bed610f7d2f072fab266aa357355edd3a0a7185a" translate="yes" xml:space="preserve">
          <source>positive if command has fixed number of required arguments.</source>
          <target state="translated">positivo si el comando tiene un número fijo de argumentos requeridos.</target>
        </trans-unit>
        <trans-unit id="4a3a047a6403d2d3bacb986b7f6151cdb6833cb0" translate="yes" xml:space="preserve">
          <source>psetex</source>
          <target state="translated">psetex</target>
        </trans-unit>
        <trans-unit id="e44e04acda8ed9383787796472c212994366ee63" translate="yes" xml:space="preserve">
          <source>psubscribe</source>
          <target state="translated">psubscribe</target>
        </trans-unit>
        <trans-unit id="a0ca7d4429b67bf5c0e197976ae39b2a20e007bb" translate="yes" xml:space="preserve">
          <source>pttl</source>
          <target state="translated">pttl</target>
        </trans-unit>
        <trans-unit id="5e2fb0c2c59448e1dec5df0f70ec85fcad1ca7b6" translate="yes" xml:space="preserve">
          <source>publish</source>
          <target state="translated">publish</target>
        </trans-unit>
        <trans-unit id="1982b5a745a1c88fef26d98eeabdacb9994ec98a" translate="yes" xml:space="preserve">
          <source>pubsub</source>
          <target state="translated">pubsub</target>
        </trans-unit>
        <trans-unit id="651b795728b6bdb24290db4e183de42624b603f5" translate="yes" xml:space="preserve">
          <source>punsubscribe</source>
          <target state="translated">punsubscribe</target>
        </trans-unit>
        <trans-unit id="f59118712ff45e3f8132cdd3ecfcfc6d3d2fa490" translate="yes" xml:space="preserve">
          <source>quit</source>
          <target state="translated">quit</target>
        </trans-unit>
        <trans-unit id="5a8e9d7284cd1a25846606e62c44cee49802c4fd" translate="yes" xml:space="preserve">
          <source>randomkey</source>
          <target state="translated">randomkey</target>
        </trans-unit>
        <trans-unit id="9a27718297218c3757c365d357d13f49d0fa3065" translate="yes" xml:space="preserve">
          <source>readonly</source>
          <target state="translated">readonly</target>
        </trans-unit>
        <trans-unit id="accf881e821ed62ca842d34164426a7d9215a948" translate="yes" xml:space="preserve">
          <source>readwrite</source>
          <target state="translated">readwrite</target>
        </trans-unit>
        <trans-unit id="a2043ee98940bcb4cbec6e32e5ec4120e9a20360" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; APPEND ts &quot;0043&quot;&lt;code&gt;(integer) 4&lt;/code&gt;redis&amp;gt; APPEND ts &quot;0035&quot;&lt;code&gt;(integer) 8&lt;/code&gt;redis&amp;gt; GETRANGE ts 0 3&lt;code&gt;&quot;0043&quot;&lt;/code&gt;redis&amp;gt; GETRANGE ts 4 7&lt;code&gt;&quot;0035&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; APPEND ts &quot;0043&quot; &lt;code&gt;(integer) 4&lt;/code&gt; redis&amp;gt; APPEND ts &quot;0035&quot; &lt;code&gt;(integer) 8&lt;/code&gt; redis&amp;gt; GETRANGE ts 0 3 &lt;code&gt;&quot;0043&quot;&lt;/code&gt; redis&amp;gt; GETRANGE ts 4 7 &lt;code&gt;&quot;0035&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bedc4c1bbf08d7ca909f592f5658389c9d3cb967" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; CLIENT ID&lt;code&gt;ERR Unknown or disabled command 'CLIENT'&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; CLIENT ID &lt;code&gt;ERR Unknown or disabled command 'CLIENT'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fc76afaba6e4fb16db71ac87c8fe387cdc59f90" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; COMMAND COUNT&lt;code&gt;(integer) 197&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; CONTEO DE COMANDOS &lt;code&gt;(integer) 197&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce45f3980afeecdaf0a0170bf8b760b841dadd33" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; COMMAND GETKEYS MSET a b c d e f&lt;code&gt;1) &quot;a&quot;
2) &quot;c&quot;
3) &quot;e&quot;&lt;/code&gt;redis&amp;gt; COMMAND GETKEYS EVAL &quot;not consulted&quot; 3 key1 key2 key3 arg1 arg2 arg3 argN&lt;code&gt;1) &quot;key1&quot;
2) &quot;key2&quot;
3) &quot;key3&quot;&lt;/code&gt;redis&amp;gt; COMMAND GETKEYS SORT mylist ALPHA STORE outlist&lt;code&gt;1) &quot;mylist&quot;
2) &quot;outlist&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; COMMAND GETKEYS MSET abcdef &lt;code&gt;1) &quot;a&quot; 2) &quot;c&quot; 3) &quot;e&quot;&lt;/code&gt; redis&amp;gt; COMMAND GETKEYS EVAL &quot;no consultado&quot; 3 tecla1 tecla2 tecla3 arg1 arg2 arg3 argN &lt;code&gt;1) &quot;key1&quot; 2) &quot;key2&quot; 3) &quot;key3&quot;&lt;/code&gt; redis&amp;gt; COMMAND GETKEYS CLASIFICAR mylist ALPHA STORE outlist &lt;code&gt;1) &quot;mylist&quot; 2) &quot;outlist&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="baff33c5ab3a0d322c68de3a9493f0692ae31ac0" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; COMMAND INFO get set eval&lt;code&gt;1) 1) &quot;get&quot;
   2) (integer) 2
   3) 1) &quot;readonly&quot;
      2) &quot;fast&quot;
   4) (integer) 1
   5) (integer) 1
   6) (integer) 1
2) 1) &quot;set&quot;
   2) (integer) -3
   3) 1) &quot;write&quot;
      2) &quot;denyoom&quot;
   4) (integer) 1
   5) (integer) 1
   6) (integer) 1
3) 1) &quot;eval&quot;
   2) (integer) -3
   3) 1) &quot;noscript&quot;
      2) &quot;movablekeys&quot;
   4) (integer) 0
   5) (integer) 0
   6) (integer) 0&lt;/code&gt;redis&amp;gt; COMMAND INFO foo evalsha config bar&lt;code&gt;1) (nil)
2) 1) &quot;evalsha&quot;
   2) (integer) -3
   3) 1) &quot;noscript&quot;
      2) &quot;movablekeys&quot;
   4) (integer) 0
   5) (integer) 0
   6) (integer) 0
3) 1) &quot;config&quot;
   2) (integer) -2
   3) 1) &quot;admin&quot;
      2) &quot;loading&quot;
      3) &quot;stale&quot;
   4) (integer) 0
   5) (integer) 0
   6) (integer) 0
4) (nil)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; COMMAND INFO get set eval &lt;code&gt;1) 1) &quot;get&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 2) 1) &quot;set&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 3) 1) &quot;eval&quot; 2) (integer) -3 3) 1) &quot;noscript&quot; 2) &quot;movablekeys&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0&lt;/code&gt; redis&amp;gt; COMMAND INFO foo evalsha config bar &lt;code&gt;1) (nil) 2) 1) &quot;evalsha&quot; 2) (integer) -3 3) 1) &quot;noscript&quot; 2) &quot;movablekeys&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 3) 1) &quot;config&quot; 2) (integer) -2 3) 1) &quot;admin&quot; 2) &quot;loading&quot; 3) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 4) (nil)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b271024fdd4aa24987dd42d3bdb176d9765851c" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; COMMAND&lt;code&gt;1) 1) &quot;sadd&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
  2) 1) &quot;lrange&quot;
     2) (integer) 4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
  3) 1) &quot;time&quot;
     2) (integer) 1
     3) 1) &quot;random&quot;
        2) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
  4) 1) &quot;spop&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;random&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
  5) 1) &quot;hvals&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;sort_for_script&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
  6) 1) &quot;debug&quot;
     2) (integer) -2
     3) 1) &quot;admin&quot;
        2) &quot;noscript&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
  7) 1) &quot;georadius_ro&quot;
     2) (integer) -6
     3) 1) &quot;readonly&quot;
        2) &quot;movablekeys&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
  8) 1) &quot;select&quot;
     2) (integer) 2
     3) 1) &quot;loading&quot;
        2) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
  9) 1) &quot;auth&quot;
     2) (integer) 2
     3) 1) &quot;noscript&quot;
        2) &quot;loading&quot;
        3) &quot;stale&quot;
        4) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 10) 1) &quot;mset&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 2
 11) 1) &quot;zremrangebylex&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 12) 1) &quot;rename&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
     4) (integer) 1
     5) (integer) 2
     6) (integer) 1
 13) 1) &quot;xreadgroup&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;noscript&quot;
        3) &quot;movablekeys&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 14) 1) &quot;xrange&quot;
     2) (integer) -4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 15) 1) &quot;georadiusbymember_ro&quot;
     2) (integer) -5
     3) 1) &quot;readonly&quot;
        2) &quot;movablekeys&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 16) 1) &quot;xadd&quot;
     2) (integer) -5
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 17) 1) &quot;srem&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 18) 1) &quot;punsubscribe&quot;
     2) (integer) -1
     3) 1) &quot;pubsub&quot;
        2) &quot;noscript&quot;
        3) &quot;loading&quot;
        4) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 19) 1) &quot;hmget&quot;
     2) (integer) -3
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 20) 1) &quot;sinterstore&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
 21) 1) &quot;xdel&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 22) 1) &quot;blpop&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;noscript&quot;
     4) (integer) 1
     5) (integer) -2
     6) (integer) 1
 23) 1) &quot;zrangebyscore&quot;
     2) (integer) -4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 24) 1) &quot;decr&quot;
     2) (integer) 2
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 25) 1) &quot;touch&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 26) 1) &quot;sismember&quot;
     2) (integer) 3
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 27) 1) &quot;object&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
     4) (integer) 2
     5) (integer) 2
     6) (integer) 1
 28) 1) &quot;sunion&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
        2) &quot;sort_for_script&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
 29) 1) &quot;type&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 30) 1) &quot;persist&quot;
     2) (integer) 2
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 31) 1) &quot;xack&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 32) 1) &quot;asking&quot;
     2) (integer) 1
     3) 1) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 33) 1) &quot;randomkey&quot;
     2) (integer) 1
     3) 1) &quot;readonly&quot;
        2) &quot;random&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 34) 1) &quot;sync&quot;
     2) (integer) 1
     3) 1) &quot;readonly&quot;
        2) &quot;admin&quot;
        3) &quot;noscript&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 35) 1) &quot;incr&quot;
     2) (integer) 2
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 36) 1) &quot;slaveof&quot;
     2) (integer) 3
     3) 1) &quot;admin&quot;
        2) &quot;noscript&quot;
        3) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 37) 1) &quot;zadd&quot;
     2) (integer) -4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 38) 1) &quot;bitfield&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 39) 1) &quot;module&quot;
     2) (integer) -2
     3) 1) &quot;admin&quot;
        2) &quot;noscript&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 40) 1) &quot;psubscribe&quot;
     2) (integer) -2
     3) 1) &quot;pubsub&quot;
        2) &quot;noscript&quot;
        3) &quot;loading&quot;
        4) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 41) 1) &quot;getrange&quot;
     2) (integer) 4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 42) 1) &quot;bzpopmin&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;noscript&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) -2
     6) (integer) 1
 43) 1) &quot;lpush&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 44) 1) &quot;bgrewriteaof&quot;
     2) (integer) 1
     3) 1) &quot;admin&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 45) 1) &quot;replconf&quot;
     2) (integer) -1
     3) 1) &quot;admin&quot;
        2) &quot;noscript&quot;
        3) &quot;loading&quot;
        4) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 46) 1) &quot;eval&quot;
     2) (integer) -3
     3) 1) &quot;noscript&quot;
        2) &quot;movablekeys&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 47) 1) &quot;pfmerge&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
 48) 1) &quot;incrby&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 49) 1) &quot;zincrby&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 50) 1) &quot;sscan&quot;
     2) (integer) -3
     3) 1) &quot;readonly&quot;
        2) &quot;random&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 51) 1) &quot;substr&quot;
     2) (integer) 4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 52) 1) &quot;zremrangebyrank&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 53) 1) &quot;append&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 54) 1) &quot;zpopmax&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
 55) 1) &quot;bitpos&quot;
     2) (integer) -3
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 56) 1) &quot;hstrlen&quot;
     2) (integer) 3
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 57) 1) &quot;monitor&quot;
     2) (integer) 1
     3) 1) &quot;admin&quot;
        2) &quot;noscript&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 58) 1) &quot;post&quot;
     2) (integer) -1
     3) 1) &quot;loading&quot;
        2) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 59) 1) &quot;lset&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 60) 1) &quot;set&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 61) 1) &quot;brpop&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;noscript&quot;
     4) (integer) 1
     5) (integer) -2
     6) (integer) 1
 62) 1) &quot;zrevrank&quot;
     2) (integer) 3
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 63) 1) &quot;georadius&quot;
     2) (integer) -6
     3) 1) &quot;write&quot;
        2) &quot;movablekeys&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 64) 1) &quot;sdiffstore&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
 65) 1) &quot;lpop&quot;
     2) (integer) 2
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 66) 1) &quot;ping&quot;
     2) (integer) -1
     3) 1) &quot;stale&quot;
        2) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 67) 1) &quot;pfcount&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
 68) 1) &quot;zrangebylex&quot;
     2) (integer) -4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 69) 1) &quot;zrevrangebyscore&quot;
     2) (integer) -4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 70) 1) &quot;flushdb&quot;
     2) (integer) -1
     3) 1) &quot;write&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 71) 1) &quot;sort&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;movablekeys&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 72) 1) &quot;bzpopmax&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;noscript&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) -2
     6) (integer) 1
 73) 1) &quot;move&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 74) 1) &quot;georadiusbymember&quot;
     2) (integer) -5
     3) 1) &quot;write&quot;
        2) &quot;movablekeys&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 75) 1) &quot;config&quot;
     2) (integer) -2
     3) 1) &quot;admin&quot;
        2) &quot;loading&quot;
        3) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 76) 1) &quot;xrevrange&quot;
     2) (integer) -4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 77) 1) &quot;zunionstore&quot;
     2) (integer) -4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;movablekeys&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 78) 1) &quot;geopos&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 79) 1) &quot;hdel&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 80) 1) &quot;hincrby&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 81) 1) &quot;cluster&quot;
     2) (integer) -2
     3) 1) &quot;admin&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 82) 1) &quot;geodist&quot;
     2) (integer) -4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 83) 1) &quot;bgsave&quot;
     2) (integer) -1
     3) 1) &quot;admin&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 84) 1) &quot;unsubscribe&quot;
     2) (integer) -1
     3) 1) &quot;pubsub&quot;
        2) &quot;noscript&quot;
        3) &quot;loading&quot;
        4) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 85) 1) &quot;renamenx&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 2
     6) (integer) 1
 86) 1) &quot;unwatch&quot;
     2) (integer) 1
     3) 1) &quot;noscript&quot;
        2) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 87) 1) &quot;echo&quot;
     2) (integer) 2
     3) 1) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 88) 1) &quot;flushall&quot;
     2) (integer) -1
     3) 1) &quot;write&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 89) 1) &quot;host:&quot;
     2) (integer) -1
     3) 1) &quot;loading&quot;
        2) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 90) 1) &quot;hkeys&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;sort_for_script&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 91) 1) &quot;zlexcount&quot;
     2) (integer) 4
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 92) 1) &quot;xpending&quot;
     2) (integer) -3
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 93) 1) &quot;hscan&quot;
     2) (integer) -3
     3) 1) &quot;readonly&quot;
        2) &quot;random&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 94) 1) &quot;setnx&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 95) 1) &quot;lastsave&quot;
     2) (integer) 1
     3) 1) &quot;random&quot;
        2) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 96) 1) &quot;memory&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 97) 1) &quot;getbit&quot;
     2) (integer) 3
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
 98) 1) &quot;keys&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;sort_for_script&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
 99) 1) &quot;hexists&quot;
     2) (integer) 3
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
100) 1) &quot;migrate&quot;
     2) (integer) -6
     3) 1) &quot;write&quot;
        2) &quot;movablekeys&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
101) 1) &quot;expire&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
102) 1) &quot;geohash&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
103) 1) &quot;role&quot;
     2) (integer) 1
     3) 1) &quot;noscript&quot;
        2) &quot;loading&quot;
        3) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
104) 1) &quot;unlink&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
105) 1) &quot;zcard&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
106) 1) &quot;save&quot;
     2) (integer) 1
     3) 1) &quot;admin&quot;
        2) &quot;noscript&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
107) 1) &quot;script&quot;
     2) (integer) -2
     3) 1) &quot;noscript&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
108) 1) &quot;hsetnx&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
109) 1) &quot;rpush&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
110) 1) &quot;xclaim&quot;
     2) (integer) -5
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
111) 1) &quot;rpushx&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
112) 1) &quot;hset&quot;
     2) (integer) -4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
113) 1) &quot;setrange&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
114) 1) &quot;zscore&quot;
     2) (integer) 3
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
115) 1) &quot;hget&quot;
     2) (integer) 3
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
116) 1) &quot;lpushx&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
117) 1) &quot;linsert&quot;
     2) (integer) 5
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
118) 1) &quot;multi&quot;
     2) (integer) 1
     3) 1) &quot;noscript&quot;
        2) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
119) 1) &quot;pfadd&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
120) 1) &quot;scan&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
        2) &quot;random&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
121) 1) &quot;latency&quot;
     2) (integer) -2
     3) 1) &quot;admin&quot;
        2) &quot;noscript&quot;
        3) &quot;loading&quot;
        4) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
122) 1) &quot;xread&quot;
     2) (integer) -3
     3) 1) &quot;readonly&quot;
        2) &quot;noscript&quot;
        3) &quot;movablekeys&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
123) 1) &quot;ltrim&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
124) 1) &quot;ttl&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
125) 1) &quot;psync&quot;
     2) (integer) 3
     3) 1) &quot;readonly&quot;
        2) &quot;admin&quot;
        3) &quot;noscript&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
126) 1) &quot;msetnx&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 2
127) 1) &quot;sinter&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
        2) &quot;sort_for_script&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
128) 1) &quot;zcount&quot;
     2) (integer) 4
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
129) 1) &quot;zrevrange&quot;
     2) (integer) -4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
130) 1) &quot;rpop&quot;
     2) (integer) 2
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
131) 1) &quot;dump&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
132) 1) &quot;pttl&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
133) 1) &quot;bitcount&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
134) 1) &quot;decrby&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
135) 1) &quot;xgroup&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 2
     5) (integer) 2
     6) (integer) 1
136) 1) &quot;hincrbyfloat&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
137) 1) &quot;lindex&quot;
     2) (integer) 3
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
138) 1) &quot;client&quot;
     2) (integer) -2
     3) 1) &quot;admin&quot;
        2) &quot;noscript&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
139) 1) &quot;pexpireat&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
140) 1) &quot;xinfo&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
     4) (integer) 2
     5) (integer) 2
     6) (integer) 1
141) 1) &quot;zpopmin&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
142) 1) &quot;hmset&quot;
     2) (integer) -4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
143) 1) &quot;pfdebug&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
144) 1) &quot;brpoplpush&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;noscript&quot;
     4) (integer) 1
     5) (integer) 2
     6) (integer) 1
145) 1) &quot;sdiff&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
        2) &quot;sort_for_script&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
146) 1) &quot;zrem&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
147) 1) &quot;command&quot;
     2) (integer) 0
     3) 1) &quot;loading&quot;
        2) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
148) 1) &quot;publish&quot;
     2) (integer) 3
     3) 1) &quot;pubsub&quot;
        2) &quot;loading&quot;
        3) &quot;stale&quot;
        4) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
149) 1) &quot;exists&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
150) 1) &quot;swapdb&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
151) 1) &quot;del&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
152) 1) &quot;getset&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
153) 1) &quot;rpoplpush&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 2
     6) (integer) 1
154) 1) &quot;setbit&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
155) 1) &quot;hlen&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
156) 1) &quot;incrbyfloat&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
157) 1) &quot;zrange&quot;
     2) (integer) -4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
158) 1) &quot;setex&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
159) 1) &quot;psetex&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
160) 1) &quot;shutdown&quot;
     2) (integer) -1
     3) 1) &quot;admin&quot;
        2) &quot;loading&quot;
        3) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
161) 1) &quot;evalsha&quot;
     2) (integer) -3
     3) 1) &quot;noscript&quot;
        2) &quot;movablekeys&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
162) 1) &quot;scard&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
163) 1) &quot;restore-asking&quot;
     2) (integer) -4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;asking&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
164) 1) &quot;srandmember&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
        2) &quot;random&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
165) 1) &quot;hgetall&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
166) 1) &quot;strlen&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
167) 1) &quot;wait&quot;
     2) (integer) 3
     3) 1) &quot;noscript&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
168) 1) &quot;watch&quot;
     2) (integer) -2
     3) 1) &quot;noscript&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
169) 1) &quot;get&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
170) 1) &quot;pubsub&quot;
     2) (integer) -2
     3) 1) &quot;pubsub&quot;
        2) &quot;random&quot;
        3) &quot;loading&quot;
        4) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
171) 1) &quot;dbsize&quot;
     2) (integer) 1
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
172) 1) &quot;smembers&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;sort_for_script&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
173) 1) &quot;zrevrangebylex&quot;
     2) (integer) -4
     3) 1) &quot;readonly&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
174) 1) &quot;subscribe&quot;
     2) (integer) -2
     3) 1) &quot;pubsub&quot;
        2) &quot;noscript&quot;
        3) &quot;loading&quot;
        4) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
175) 1) &quot;zinterstore&quot;
     2) (integer) -4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
        3) &quot;movablekeys&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
176) 1) &quot;smove&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 2
     6) (integer) 1
177) 1) &quot;readonly&quot;
     2) (integer) 1
     3) 1) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
178) 1) &quot;zremrangebyscore&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
179) 1) &quot;sunionstore&quot;
     2) (integer) -3
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
180) 1) &quot;llen&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
181) 1) &quot;discard&quot;
     2) (integer) 1
     3) 1) &quot;noscript&quot;
        2) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
182) 1) &quot;info&quot;
     2) (integer) -1
     3) 1) &quot;loading&quot;
        2) &quot;stale&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
183) 1) &quot;pfselftest&quot;
     2) (integer) 1
     3) 1) &quot;admin&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
184) 1) &quot;bitop&quot;
     2) (integer) -4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 2
     5) (integer) -1
     6) (integer) 1
185) 1) &quot;pexpire&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
186) 1) &quot;xlen&quot;
     2) (integer) 2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
187) 1) &quot;mget&quot;
     2) (integer) -2
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) -1
     6) (integer) 1
188) 1) &quot;xtrim&quot;
     2) (integer) -2
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
189) 1) &quot;exec&quot;
     2) (integer) 1
     3) 1) &quot;noscript&quot;
        2) &quot;skip_monitor&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
190) 1) &quot;zscan&quot;
     2) (integer) -3
     3) 1) &quot;readonly&quot;
        2) &quot;random&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
191) 1) &quot;zrank&quot;
     2) (integer) 3
     3) 1) &quot;readonly&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
192) 1) &quot;geoadd&quot;
     2) (integer) -5
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
193) 1) &quot;expireat&quot;
     2) (integer) 3
     3) 1) &quot;write&quot;
        2) &quot;fast&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
194) 1) &quot;slowlog&quot;
     2) (integer) -2
     3) 1) &quot;admin&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
195) 1) &quot;readwrite&quot;
     2) (integer) 1
     3) 1) &quot;fast&quot;
     4) (integer) 0
     5) (integer) 0
     6) (integer) 0
196) 1) &quot;lrem&quot;
     2) (integer) 4
     3) 1) &quot;write&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1
197) 1) &quot;restore&quot;
     2) (integer) -4
     3) 1) &quot;write&quot;
        2) &quot;denyoom&quot;
     4) (integer) 1
     5) (integer) 1
     6) (integer) 1&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; COMANDO &lt;code&gt;1) 1) &quot;sadd&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 2) 1) &quot;lrange&quot; 2) (integer) 4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 3) 1) &quot;time&quot; 2) (integer) 1 3) 1) &quot;random&quot; 2) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 4) 1) &quot;spop&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;random&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 5) 1) &quot;hvals&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;sort_for_script&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 6) 1) &quot;debug&quot; 2) (integer) -2 3) 1) &quot;admin&quot; 2) &quot;noscript&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 7) 1) &quot;georadius_ro&quot; 2) (integer) -6 3) 1) &quot;readonly&quot; 2) &quot;movablekeys&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 8) 1) &quot;select&quot; 2) (integer) 2 3) 1) &quot;loading&quot; 2) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 9) 1) &quot;auth&quot; 2) (integer) 2 3) 1) &quot;noscript&quot; 2) &quot;loading&quot; 3) &quot;stale&quot; 4) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 10) 1) &quot;mset&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 2 11) 1) &quot;zremrangebylex&quot; 2) (integer) 4 3) 1) &quot;write&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 12) 1) &quot;rename&quot; 2) (integer) 3 3) 1) &quot;write&quot; 4) (integer) 1 5) (integer) 2 6) (integer) 1 13) 1) &quot;xreadgroup&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;noscript&quot; 3) &quot;movablekeys&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 14) 1) &quot;xrange&quot; 2) (integer) -4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 15) 1) &quot;georadiusbymember_ro&quot; 2) (integer) -5 3) 1) &quot;readonly&quot; 2) &quot;movablekeys&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 16) 1) &quot;xadd&quot; 2) (integer) -5 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 17) 1) &quot;srem&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 18) 1) &quot;punsubscribe&quot; 2) (integer) -1 3) 1) &quot;pubsub&quot; 2) &quot;noscript&quot; 3) &quot;loading&quot; 4) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 19) 1) &quot;hmget&quot; 2) (integer) -3 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 20) 1) &quot;sinterstore&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 21) 1) &quot;xdel&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 22) 1) &quot;blpop&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;noscript&quot; 4) (integer) 1 5) (integer) -2 6) (integer) 1 23) 1) &quot;zrangebyscore&quot; 2) (integer) -4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 24) 1) &quot;decr&quot; 2) (integer) 2 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 25) 1) &quot;touch&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 26) 1) &quot;sismember&quot; 2) (integer) 3 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 27) 1) &quot;object&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 4) (integer) 2 5) (integer) 2 6) (integer) 1 28) 1) &quot;sunion&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 2) &quot;sort_for_script&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 29) 1) &quot;type&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 30) 1) &quot;persist&quot; 2) (integer) 2 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 31) 1) &quot;xack&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 32) 1) &quot;asking&quot; 2) (integer) 1 3) 1) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 33) 1) &quot;randomkey&quot; 2) (integer) 1 3) 1) &quot;readonly&quot; 2) &quot;random&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 34) 1) &quot;sync&quot; 2) (integer) 1 3) 1) &quot;readonly&quot; 2) &quot;admin&quot; 3) &quot;noscript&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 35) 1) &quot;incr&quot; 2) (integer) 2 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 36) 1) &quot;slaveof&quot; 2) (integer) 3 3) 1) &quot;admin&quot; 2) &quot;noscript&quot; 3) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 37) 1) &quot;zadd&quot; 2) (integer) -4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 38) 1) &quot;bitfield&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 39) 1) &quot;module&quot; 2) (integer) -2 3) 1) &quot;admin&quot; 2) &quot;noscript&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 40) 1) &quot;psubscribe&quot; 2) (integer) -2 3) 1) &quot;pubsub&quot; 2) &quot;noscript&quot; 3) &quot;loading&quot; 4) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 41) 1) &quot;getrange&quot; 2) (integer) 4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 42) 1) &quot;bzpopmin&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;noscript&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) -2 6) (integer) 1 43) 1) &quot;lpush&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 44) 1) &quot;bgrewriteaof&quot; 2) (integer) 1 3) 1) &quot;admin&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 45) 1) &quot;replconf&quot; 2) (integer) -1 3) 1) &quot;admin&quot; 2) &quot;noscript&quot; 3) &quot;loading&quot; 4) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 46) 1) &quot;eval&quot; 2) (integer) -3 3) 1) &quot;noscript&quot; 2) &quot;movablekeys&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 47) 1) &quot;pfmerge&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 48) 1) &quot;incrby&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 49) 1) &quot;zincrby&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 50) 1) &quot;sscan&quot; 2) (integer) -3 3) 1) &quot;readonly&quot; 2) &quot;random&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 51) 1) &quot;substr&quot; 2) (integer) 4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 52) 1) &quot;zremrangebyrank&quot; 2) (integer) 4 3) 1) &quot;write&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 53) 1) &quot;append&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 54) 1) &quot;zpopmax&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 55) 1) &quot;bitpos&quot; 2) (integer) -3 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 56) 1) &quot;hstrlen&quot; 2) (integer) 3 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 57) 1) &quot;monitor&quot; 2) (integer) 1 3) 1) &quot;admin&quot; 2) &quot;noscript&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 58) 1) &quot;post&quot; 2) (integer) -1 3) 1) &quot;loading&quot; 2) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 59) 1) &quot;lset&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 60) 1) &quot;set&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 61) 1) &quot;brpop&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;noscript&quot; 4) (integer) 1 5) (integer) -2 6) (integer) 1 62) 1) &quot;zrevrank&quot; 2) (integer) 3 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 63) 1) &quot;georadius&quot; 2) (integer) -6 3) 1) &quot;write&quot; 2) &quot;movablekeys&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 64) 1) &quot;sdiffstore&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 65) 1) &quot;lpop&quot; 2) (integer) 2 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 66) 1) &quot;ping&quot; 2) (integer) -1 3) 1) &quot;stale&quot; 2) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 67) 1) &quot;pfcount&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 68) 1) &quot;zrangebylex&quot; 2) (integer) -4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 69) 1) &quot;zrevrangebyscore&quot; 2) (integer) -4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 70) 1) &quot;flushdb&quot; 2) (integer) -1 3) 1) &quot;write&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 71) 1) &quot;sort&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;movablekeys&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 72) 1) &quot;bzpopmax&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;noscript&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) -2 6) (integer) 1 73) 1) &quot;move&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 74) 1) &quot;georadiusbymember&quot; 2) (integer) -5 3) 1) &quot;write&quot; 2) &quot;movablekeys&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 75) 1) &quot;config&quot; 2) (integer) -2 3) 1) &quot;admin&quot; 2) &quot;loading&quot; 3) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 76) 1) &quot;xrevrange&quot; 2) (integer) -4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 77) 1) &quot;zunionstore&quot; 2) (integer) -4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;movablekeys&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 78) 1) &quot;geopos&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 79) 1) &quot;hdel&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 80) 1) &quot;hincrby&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 81) 1) &quot;cluster&quot; 2) (integer) -2 3) 1) &quot;admin&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 82) 1) &quot;geodist&quot; 2) (integer) -4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 83) 1) &quot;bgsave&quot; 2) (integer) -1 3) 1) &quot;admin&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 84) 1) &quot;unsubscribe&quot; 2) (integer) -1 3) 1) &quot;pubsub&quot; 2) &quot;noscript&quot; 3) &quot;loading&quot; 4) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 85) 1) &quot;renamenx&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 2 6) (integer) 1 86) 1) &quot;unwatch&quot; 2) (integer) 1 3) 1) &quot;noscript&quot; 2) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 87) 1) &quot;echo&quot; 2) (integer) 2 3) 1) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 88) 1) &quot;flushall&quot; 2) (integer) -1 3) 1) &quot;write&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 89) 1) &quot;host:&quot; 2) (integer) -1 3) 1) &quot;loading&quot; 2) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 90) 1) &quot;hkeys&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;sort_for_script&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 91) 1) &quot;zlexcount&quot; 2) (integer) 4 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 92) 1) &quot;xpending&quot; 2) (integer) -3 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 93) 1) &quot;hscan&quot; 2) (integer) -3 3) 1) &quot;readonly&quot; 2) &quot;random&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 94) 1) &quot;setnx&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 95) 1) &quot;lastsave&quot; 2) (integer) 1 3) 1) &quot;random&quot; 2) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 96) 1) &quot;memory&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 97) 1) &quot;getbit&quot; 2) (integer) 3 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 98) 1) &quot;keys&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;sort_for_script&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 99) 1) &quot;hexists&quot; 2) (integer) 3 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 100) 1) &quot;migrate&quot; 2) (integer) -6 3) 1) &quot;write&quot; 2) &quot;movablekeys&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 101) 1) &quot;expire&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 102) 1) &quot;geohash&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 103) 1) &quot;role&quot; 2) (integer) 1 3) 1) &quot;noscript&quot; 2) &quot;loading&quot; 3) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 104) 1) &quot;unlink&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 105) 1) &quot;zcard&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 106) 1) &quot;save&quot; 2) (integer) 1 3) 1) &quot;admin&quot; 2) &quot;noscript&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 107) 1) &quot;script&quot; 2) (integer) -2 3) 1) &quot;noscript&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 108) 1) &quot;hsetnx&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 109) 1) &quot;rpush&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 110) 1) &quot;xclaim&quot; 2) (integer) -5 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 111) 1) &quot;rpushx&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 112) 1) &quot;hset&quot; 2) (integer) -4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 113) 1) &quot;setrange&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 114) 1) &quot;zscore&quot; 2) (integer) 3 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 115) 1) &quot;hget&quot; 2) (integer) 3 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 116) 1) &quot;lpushx&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 117) 1) &quot;linsert&quot; 2) (integer) 5 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 118) 1) &quot;multi&quot; 2) (integer) 1 3) 1) &quot;noscript&quot; 2) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 119) 1) &quot;pfadd&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 120) 1) &quot;scan&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 2) &quot;random&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 121) 1) &quot;latency&quot; 2) (integer) -2 3) 1) &quot;admin&quot; 2) &quot;noscript&quot; 3) &quot;loading&quot; 4) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 122) 1) &quot;xread&quot; 2) (integer) -3 3) 1) &quot;readonly&quot; 2) &quot;noscript&quot; 3) &quot;movablekeys&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 123) 1) &quot;ltrim&quot; 2) (integer) 4 3) 1) &quot;write&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 124) 1) &quot;ttl&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 125) 1) &quot;psync&quot; 2) (integer) 3 3) 1) &quot;readonly&quot; 2) &quot;admin&quot; 3) &quot;noscript&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 126) 1) &quot;msetnx&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 2 127) 1) &quot;sinter&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 2) &quot;sort_for_script&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 128) 1) &quot;zcount&quot; 2) (integer) 4 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 129) 1) &quot;zrevrange&quot; 2) (integer) -4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 130) 1) &quot;rpop&quot; 2) (integer) 2 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 131) 1) &quot;dump&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 132) 1) &quot;pttl&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 133) 1) &quot;bitcount&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 134) 1) &quot;decrby&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 135) 1) &quot;xgroup&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 2 5) (integer) 2 6) (integer) 1 136) 1) &quot;hincrbyfloat&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 137) 1) &quot;lindex&quot; 2) (integer) 3 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 138) 1) &quot;client&quot; 2) (integer) -2 3) 1) &quot;admin&quot; 2) &quot;noscript&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 139) 1) &quot;pexpireat&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 140) 1) &quot;xinfo&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 4) (integer) 2 5) (integer) 2 6) (integer) 1 141) 1) &quot;zpopmin&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 142) 1) &quot;hmset&quot; 2) (integer) -4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 143) 1) &quot;pfdebug&quot; 2) (integer) -3 3) 1) &quot;write&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 144) 1) &quot;brpoplpush&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;noscript&quot; 4) (integer) 1 5) (integer) 2 6) (integer) 1 145) 1) &quot;sdiff&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 2) &quot;sort_for_script&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 146) 1) &quot;zrem&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 147) 1) &quot;command&quot; 2) (integer) 0 3) 1) &quot;loading&quot; 2) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 148) 1) &quot;publish&quot; 2) (integer) 3 3) 1) &quot;pubsub&quot; 2) &quot;loading&quot; 3) &quot;stale&quot; 4) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 149) 1) &quot;exists&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 150) 1) &quot;swapdb&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 151) 1) &quot;del&quot; 2) (integer) -2 3) 1) &quot;write&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 152) 1) &quot;getset&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 153) 1) &quot;rpoplpush&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 2 6) (integer) 1 154) 1) &quot;setbit&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 155) 1) &quot;hlen&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 156) 1) &quot;incrbyfloat&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 157) 1) &quot;zrange&quot; 2) (integer) -4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 158) 1) &quot;setex&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 159) 1) &quot;psetex&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 160) 1) &quot;shutdown&quot; 2) (integer) -1 3) 1) &quot;admin&quot; 2) &quot;loading&quot; 3) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 161) 1) &quot;evalsha&quot; 2) (integer) -3 3) 1) &quot;noscript&quot; 2) &quot;movablekeys&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 162) 1) &quot;scard&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 163) 1) &quot;restore-asking&quot; 2) (integer) -4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;asking&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 164) 1) &quot;srandmember&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 2) &quot;random&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 165) 1) &quot;hgetall&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 166) 1) &quot;strlen&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 167) 1) &quot;wait&quot; 2) (integer) 3 3) 1) &quot;noscript&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 168) 1) &quot;watch&quot; 2) (integer) -2 3) 1) &quot;noscript&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 169) 1) &quot;get&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 170) 1) &quot;pubsub&quot; 2) (integer) -2 3) 1) &quot;pubsub&quot; 2) &quot;random&quot; 3) &quot;loading&quot; 4) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 171) 1) &quot;dbsize&quot; 2) (integer) 1 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 172) 1) &quot;smembers&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;sort_for_script&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 173) 1) &quot;zrevrangebylex&quot; 2) (integer) -4 3) 1) &quot;readonly&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 174) 1) &quot;subscribe&quot; 2) (integer) -2 3) 1) &quot;pubsub&quot; 2) &quot;noscript&quot; 3) &quot;loading&quot; 4) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 175) 1) &quot;zinterstore&quot; 2) (integer) -4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 3) &quot;movablekeys&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 176) 1) &quot;smove&quot; 2) (integer) 4 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 2 6) (integer) 1 177) 1) &quot;readonly&quot; 2) (integer) 1 3) 1) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 178) 1) &quot;zremrangebyscore&quot; 2) (integer) 4 3) 1) &quot;write&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 179) 1) &quot;sunionstore&quot; 2) (integer) -3 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 180) 1) &quot;llen&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 181) 1) &quot;discard&quot; 2) (integer) 1 3) 1) &quot;noscript&quot; 2) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 182) 1) &quot;info&quot; 2) (integer) -1 3) 1) &quot;loading&quot; 2) &quot;stale&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 183) 1) &quot;pfselftest&quot; 2) (integer) 1 3) 1) &quot;admin&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 184) 1) &quot;bitop&quot; 2) (integer) -4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 2 5) (integer) -1 6) (integer) 1 185) 1) &quot;pexpire&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 186) 1) &quot;xlen&quot; 2) (integer) 2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 187) 1) &quot;mget&quot; 2) (integer) -2 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) -1 6) (integer) 1 188) 1) &quot;xtrim&quot; 2) (integer) -2 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 189) 1) &quot;exec&quot; 2) (integer) 1 3) 1) &quot;noscript&quot; 2) &quot;skip_monitor&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 190) 1) &quot;zscan&quot; 2) (integer) -3 3) 1) &quot;readonly&quot; 2) &quot;random&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 191) 1) &quot;zrank&quot; 2) (integer) 3 3) 1) &quot;readonly&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 192) 1) &quot;geoadd&quot; 2) (integer) -5 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 193) 1) &quot;expireat&quot; 2) (integer) 3 3) 1) &quot;write&quot; 2) &quot;fast&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 194) 1) &quot;slowlog&quot; 2) (integer) -2 3) 1) &quot;admin&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 195) 1) &quot;readwrite&quot; 2) (integer) 1 3) 1) &quot;fast&quot; 4) (integer) 0 5) (integer) 0 6) (integer) 0 196) 1) &quot;lrem&quot; 2) (integer) 4 3) 1) &quot;write&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1 197) 1) &quot;restore&quot; 2) (integer) -4 3) 1) &quot;write&quot; 2) &quot;denyoom&quot; 4) (integer) 1 5) (integer) 1 6) (integer) 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e875a6fbb8c8d598d461225c1ac9c28ce770d65" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ECHO &quot;Hello World!&quot;&lt;code&gt;&quot;Hello World!&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ECHO &quot;&amp;iexcl;Hola mundo!&quot; &lt;code&gt;&quot;Hello World!&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50fb53433123975104cd119e2dc4fe834f3bb8fc" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; EXISTS mykey&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; APPEND mykey &quot;Hello&quot;&lt;code&gt;(integer) 5&lt;/code&gt;redis&amp;gt; APPEND mykey &quot; World&quot;&lt;code&gt;(integer) 11&lt;/code&gt;redis&amp;gt; GET mykey&lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; EXISTS mykey &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; APPEND mykey &quot;Hola&quot; &lt;code&gt;(integer) 5&lt;/code&gt; redis&amp;gt; APPEND mykey &quot;World&quot; &lt;code&gt;(integer) 11&lt;/code&gt; redis&amp;gt; GET mykey &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbc8d301e1fc39a29883d5fc6a994a924e2f9184" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; GEODIST Sicily Palermo Catania&lt;code&gt;&quot;166274.1516&quot;&lt;/code&gt;redis&amp;gt; GEODIST Sicily Palermo Catania km&lt;code&gt;&quot;166.2742&quot;&lt;/code&gt;redis&amp;gt; GEODIST Sicily Palermo Catania mi&lt;code&gt;&quot;103.3182&quot;&lt;/code&gt;redis&amp;gt; GEODIST Sicily Foo Bar&lt;code&gt;(nil)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; GEOADD Sicilia 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; GEODIST Sicilia Palermo Catania &lt;code&gt;&quot;166274.1516&quot;&lt;/code&gt; redis&amp;gt; GEODIST Sicilia Palermo Catania km &lt;code&gt;&quot;166.2742&quot;&lt;/code&gt; redis&amp;gt; GEODIST Sicilia Palermo Catania &lt;code&gt;&quot;103.3182&quot;&lt;/code&gt; mi &quot; 103.3182 Sicily Foo Bar &lt;code&gt;(nil)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad50178e42c9983278764570e1fdff0f0b029ae2" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; GEODIST Sicily Palermo Catania&lt;code&gt;&quot;166274.1516&quot;&lt;/code&gt;redis&amp;gt; GEORADIUS Sicily 15 37 100 km&lt;code&gt;1) &quot;Catania&quot;&lt;/code&gt;redis&amp;gt; GEORADIUS Sicily 15 37 200 km&lt;code&gt;1) &quot;Palermo&quot;
2) &quot;Catania&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; GEOADD Sicilia 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; GEODIST Sicilia Palermo Catania &lt;code&gt;&quot;166274.1516&quot;&lt;/code&gt; redis&amp;gt; GEORADIUS Sicilia 15 37100 km &lt;code&gt;1) &quot;Catania&quot;&lt;/code&gt; redis&amp;gt; GEORADIUS Sicilia 15 37200 km &lt;code&gt;1) &quot;Palermo&quot; 2) &quot;Catania&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c6c3f90e1268b6f3adcbb2da785a9a4a13772d9" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; GEOHASH Sicily Palermo Catania&lt;code&gt;1) &quot;sqc8b49rny0&quot;
2) &quot;sqdtr74hyu0&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; GEOADD Sicilia 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; GEOHASH Sicilia Palermo Catania &lt;code&gt;1) &quot;sqc8b49rny0&quot; 2) &quot;sqdtr74hyu0&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4c4686303bbe8f151be0ee3d05598fc9f8f9aaf" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; GEOPOS Sicily Palermo Catania NonExisting&lt;code&gt;1) 1) &quot;13.36138933897018433&quot;
   2) &quot;38.11555639549629859&quot;
2) 1) &quot;15.08726745843887329&quot;
   2) &quot;37.50266842333162032&quot;
3) (nil)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; GEOADD Sicilia 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; GEOPOS Sicilia Palermo Catania No existente &lt;code&gt;1) 1) &quot;13.36138933897018433&quot; 2) &quot;38.11555639549629859&quot; 2) 1) &quot;15.08726745843887329&quot; 2) &quot;37.50266842333162032&quot; 3) (nil)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fe6c22d030862b7644bc9f4ef122f5e4d762033" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; GEORADIUS Sicily 15 37 200 km WITHDIST&lt;code&gt;1) 1) &quot;Palermo&quot;
   2) &quot;190.4424&quot;
2) 1) &quot;Catania&quot;
   2) &quot;56.4413&quot;&lt;/code&gt;redis&amp;gt; GEORADIUS Sicily 15 37 200 km WITHCOORD&lt;code&gt;1) 1) &quot;Palermo&quot;
   2) 1) &quot;13.36138933897018433&quot;
      2) &quot;38.11555639549629859&quot;
2) 1) &quot;Catania&quot;
   2) 1) &quot;15.08726745843887329&quot;
      2) &quot;37.50266842333162032&quot;&lt;/code&gt;redis&amp;gt; GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD&lt;code&gt;1) 1) &quot;Palermo&quot;
   2) &quot;190.4424&quot;
   3) 1) &quot;13.36138933897018433&quot;
      2) &quot;38.11555639549629859&quot;
2) 1) &quot;Catania&quot;
   2) &quot;56.4413&quot;
   3) 1) &quot;15.08726745843887329&quot;
      2) &quot;37.50266842333162032&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; GEOADD Sicilia 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; GEORADIUS Sicilia 15 37200 km WITHDIST &lt;code&gt;1) 1) &quot;Palermo&quot; 2) &quot;190.4424&quot; 2) 1) &quot;Catania&quot; 2) &quot;56.4413&quot;&lt;/code&gt; redis&amp;gt; GEORADIUS Sicilia 15 37200 km CON COORDENADA &lt;code&gt;1) 1) &quot;Palermo&quot; 2) 1) &quot;13.36138933897018433&quot; 2) &quot;38.11555639549629859&quot; 2) 1) &quot;Catania&quot; 2) 1) &quot;15.08726745843887329&quot; 2) &quot;37.50266842333162032&quot;&lt;/code&gt; 42333162032 GEORADIUS Sicilia 15 37200 km RETENCI&amp;Oacute;N DE COORDENADAS &lt;code&gt;1) 1) &quot;Palermo&quot; 2) &quot;190.4424&quot; 3) 1) &quot;13.36138933897018433&quot; 2) &quot;38.11555639549629859&quot; 2) 1) &quot;Catania&quot; 2) &quot;56.4413&quot; 3) 1) &quot;15.08726745843887329&quot; 2) &quot;37.50266842333162032&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0839a9a9473e28a247416fece4100d8b87c61431" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; GEOADD Sicily 13.583333 37.316667 &quot;Agrigento&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km&lt;code&gt;1) &quot;Agrigento&quot;
2) &quot;Palermo&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; GEOADD Sicilia 13.583333 37.316667 &quot;Agrigento&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; GEOADD Sicilia 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; GEORADIUSBYMEMBER Sicilia Agrigento 100 km &lt;code&gt;1) &quot;Agrigento&quot; 2) &quot;Palermo&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e522ae950c3630c28bdd3e034c20286f426d9448" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; GET nonexisting&lt;code&gt;(nil)&lt;/code&gt;redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; GET mykey&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; GET inexistente &lt;code&gt;(nil)&lt;/code&gt; redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; GET mykey &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb52045e34094bc55ca18b19c949f60e017246fd" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HMSET myhash f1 HelloWorld f2 99 f3 -256&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; HSTRLEN myhash f1&lt;code&gt;(integer) 10&lt;/code&gt;redis&amp;gt; HSTRLEN myhash f2&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; HSTRLEN myhash f3&lt;code&gt;(integer) 4&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HMSET myhash f1 HelloWorld f2 99 f3 -256 &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; HSTRLEN myhash f1 &lt;code&gt;(integer) 10&lt;/code&gt; redis&amp;gt; HSTRLEN myhash f2 &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; HSTRLEN myhash f3 &lt;code&gt;(integer) 4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43ed1e8ef108cffcf7ae63d880484471ebfbdc2b" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HMSET myhash field1 &quot;Hello&quot; field2 &quot;World&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; HGET myhash field1&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;redis&amp;gt; HGET myhash field2&lt;code&gt;&quot;World&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HMSET myhash campo1 &quot;Hola&quot; campo2 &quot;Mundo&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; HGET myhash campo1 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; redis&amp;gt; HGET myhash campo2 &lt;code&gt;&quot;World&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea840aaaffb0ac9ff765fb8ac3e846bc3baa9cdb" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET myhash field 5&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HINCRBY myhash field 1&lt;code&gt;(integer) 6&lt;/code&gt;redis&amp;gt; HINCRBY myhash field -1&lt;code&gt;(integer) 5&lt;/code&gt;redis&amp;gt; HINCRBY myhash field -10&lt;code&gt;(integer) -5&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET campo myhash 5 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HINCRBY campo myhash 1 &lt;code&gt;(integer) 6&lt;/code&gt; redis&amp;gt; HINCRBY campo myhash -1 &lt;code&gt;(integer) 5&lt;/code&gt; redis&amp;gt; HINCRBY campo myhash -10 &lt;code&gt;(integer) -5&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ac1f9abc5c1ca9cc73e9cffcfb61fe3aa056954" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET myhash field1 &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HGET myhash field1&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET myhash field1 &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HGET myhash field1 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43a93a6f880a2a3c7a73621d05d74bf91dcddaa1" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET myhash field1 &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HSET myhash field2 &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HGETALL myhash&lt;code&gt;1) &quot;field1&quot;
2) &quot;Hello&quot;
3) &quot;field2&quot;
4) &quot;World&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET myhash campo1 &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HSET myhash campo2 &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HGETALL myhash &lt;code&gt;1) &quot;field1&quot; 2) &quot;Hello&quot; 3) &quot;field2&quot; 4) &quot;World&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f68e7f17522905fae14a6a1a90746136608a56f0" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET myhash field1 &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HSET myhash field2 &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HKEYS myhash&lt;code&gt;1) &quot;field1&quot;
2) &quot;field2&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET myhash campo1 &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HSET myhash campo2 &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HKEYS myhash &lt;code&gt;1) &quot;field1&quot; 2) &quot;field2&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59d05cda0a91cf837a564c23ff6b28c0e44abac2" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET myhash field1 &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HSET myhash field2 &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HLEN myhash&lt;code&gt;(integer) 2&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET myhash campo1 &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HSET myhash campo2 &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HLEN myhash &lt;code&gt;(integer) 2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b201aea64fbeeb56aa8d2004e7fb724a05f835fd" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET myhash field1 &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HSET myhash field2 &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HMGET myhash field1 field2 nofield&lt;code&gt;1) &quot;Hello&quot;
2) &quot;World&quot;
3) (nil)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET myhash campo1 &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HSET myhash campo2 &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HMGET myhash campo1 campo2 nofield &lt;code&gt;1) &quot;Hello&quot; 2) &quot;World&quot; 3) (nil)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f2561241583dfd692dc8e63d9e291b0f002da4a" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET myhash field1 &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HSET myhash field2 &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HVALS myhash&lt;code&gt;1) &quot;Hello&quot;
2) &quot;World&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET myhash campo1 &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HSET myhash campo2 &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HVALS myhash &lt;code&gt;1) &quot;Hello&quot; 2) &quot;World&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eccecadb17c6b6995c3a46683240e0a5a7e62413" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET myhash field1 &quot;foo&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HDEL myhash field1&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HDEL myhash field2&lt;code&gt;(integer) 0&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET myhash field1 &quot;foo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HDEL myhash field1 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HDEL myhash field2 &lt;code&gt;(integer) 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9399352497abc639e7f5ccd7d1bf9d5e2bbca3e" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET myhash field1 &quot;foo&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HEXISTS myhash field1&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HEXISTS myhash field2&lt;code&gt;(integer) 0&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET myhash campo1 &quot;foo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HEXISTAS myhash campo1 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HEXISTAS myhash campo2 &lt;code&gt;(integer) 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5e800d40dddd1db6ddeb42d08d3a24f479a6e23" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET myhash field1 &quot;foo&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HGET myhash field1&lt;code&gt;&quot;foo&quot;&lt;/code&gt;redis&amp;gt; HGET myhash field2&lt;code&gt;(nil)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET myhash field1 &quot;foo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HGET myhash field1 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; redis&amp;gt; HGET myhash field2 &lt;code&gt;(nil)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc33df72256afd82fdcaec24597d65ff398a191f" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSET mykey field 10.50&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HINCRBYFLOAT mykey field 0.1&lt;code&gt;&quot;10.6&quot;&lt;/code&gt;redis&amp;gt; HINCRBYFLOAT mykey field -5&lt;code&gt;&quot;5.6&quot;&lt;/code&gt;redis&amp;gt; HSET mykey field 5.0e3&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; HINCRBYFLOAT mykey field 2.0e2&lt;code&gt;&quot;5200&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSET mykey campo 10.50 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HINCRBYFLOAT mykey campo 0.1 &lt;code&gt;&quot;10.6&quot;&lt;/code&gt; redis&amp;gt; HINCRBYFLOAT mykey campo -5 &lt;code&gt;&quot;5.6&quot;&lt;/code&gt; redis&amp;gt; HSET mykey campo 5.0e3 &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; HINCRBYFLOAT mykey campo 2.0e2 &lt;code&gt;&quot;5200&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d0fffb92ea19a2f574258eac7e5c338857f0ee4" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; HSETNX myhash field &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; HSETNX myhash field &quot;World&quot;&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; HGET myhash field&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HSETNX campo myhash &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; HSETNX campo myhash &quot;Mundo&quot; &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; HGET campo myhash &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0730d7542a5efadfd40fe70a1449d4b6c2babffa" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; INCR mycounter&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; GETSET mycounter &quot;0&quot;&lt;code&gt;&quot;1&quot;&lt;/code&gt;redis&amp;gt; GET mycounter&lt;code&gt;&quot;0&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; INCR mycounter &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; GETSET mycounter &quot;0&quot; &lt;code&gt;&quot;1&quot;&lt;/code&gt; redis&amp;gt; GET mycounter &lt;code&gt;&quot;0&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6ca39cccfa652053f9b9d970b08d5089bb96411" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; INFO&lt;code&gt;# Server
redis_version:999.999.999
redis_git_sha1:3c968ff0
redis_git_dirty:0
redis_build_id:51089de051945df4
redis_mode:standalone
os:Linux 4.8.0-1-amd64 x86_64
arch_bits:64
multiplexing_api:epoll
atomicvar_api:atomic-builtin
gcc_version:6.3.0
process_id:25508
run_id:39240fffc9d38736f9b96bdf6f7d942232fddef0
tcp_port:6379
uptime_in_seconds:6603544
uptime_in_days:76
hz:10
lru_clock:14647828
executable:/usr/local/bin/redis-server
config_file:

# Clients
connected_clients:4
client_longest_output_list:0
client_biggest_input_buf:0
blocked_clients:0

# Memory
used_memory:623615688
used_memory_human:594.73M
used_memory_rss:641335296
used_memory_rss_human:611.62M
used_memory_peak:623615688
used_memory_peak_human:594.73M
used_memory_peak_perc:100.00%
used_memory_overhead:180205608
used_memory_startup:510704
used_memory_dataset:443410080
used_memory_dataset_perc:71.16%
allocator_allocated:623690112
allocator_active:623996928
allocator_resident:640716800
total_system_memory:1044770816
total_system_memory_human:996.37M
used_memory_lua:37888
used_memory_lua_human:37.00K
maxmemory:0
maxmemory_human:0B
maxmemory_policy:noeviction
allocator_frag_ratio:1.00
allocator_frag_bytes:306816
allocator_rss_ratio:1.03
allocator_rss_bytes:16719872
rss_overhead_ratio:1.00
rss_overhead_bytes:618496
mem_fragmentation_ratio:1.03
mem_fragmentation_bytes:17720384
mem_allocator:jemalloc-4.0.3
active_defrag_running:0
lazyfree_pending_objects:0

# Persistence
loading:0
rdb_changes_since_last_save:17982283
rdb_bgsave_in_progress:0
rdb_last_save_time:1534770940
rdb_last_bgsave_status:ok
rdb_last_bgsave_time_sec:-1
rdb_current_bgsave_time_sec:-1
rdb_last_cow_size:0
aof_enabled:0
aof_rewrite_in_progress:0
aof_rewrite_scheduled:0
aof_last_rewrite_time_sec:-1
aof_current_rewrite_time_sec:-1
aof_last_bgrewrite_status:ok
aof_last_write_status:ok
aof_last_cow_size:0

# Stats
total_connections_received:188
total_commands_processed:44454030
instantaneous_ops_per_sec:663
total_net_input_bytes:3670293956
total_net_output_bytes:618934664
instantaneous_input_kbps:53.33
instantaneous_output_kbps:13.45
rejected_connections:0
sync_full:0
sync_partial_ok:0
sync_partial_err:0
expired_keys:56335
expired_stale_perc:0.00
expired_time_cap_reached_count:0
evicted_keys:0
keyspace_hits:10364361
keyspace_misses:4366710
pubsub_channels:0
pubsub_patterns:0
latest_fork_usec:0
migrate_cached_sockets:0
slave_expires_tracked_keys:0
active_defrag_hits:0
active_defrag_misses:0
active_defrag_key_hits:0
active_defrag_key_misses:0

# Replication
role:master
connected_slaves:0
master_replid:e06cc8078080966de939fa81fa64259a5bd9408f
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0

# CPU
used_cpu_sys:5227.78
used_cpu_user:92420.12
used_cpu_sys_children:0.00
used_cpu_user_children:0.00

# Cluster
cluster_enabled:0

# Keyspace
db0:keys=3647016,expires=1864,avg_ttl=4481659497279&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; INFO &lt;code&gt;# Server redis_version:999.999.999 redis_git_sha1:3c968ff0 redis_git_dirty:0 redis_build_id:51089de051945df4 redis_mode:standalone os:Linux 4.8.0-1-amd64 x86_64 arch_bits:64 multiplexing_api:epoll atomicvar_api:atomic-builtin gcc_version:6.3.0 process_id:25508 run_id:39240fffc9d38736f9b96bdf6f7d942232fddef0 tcp_port:6379 uptime_in_seconds:6603544 uptime_in_days:76 hz:10 lru_clock:14647828 executable:/usr/local/bin/redis-server config_file: # Clients connected_clients:4 client_longest_output_list:0 client_biggest_input_buf:0 blocked_clients:0 # Memory used_memory:623615688 used_memory_human:594.73M used_memory_rss:641335296 used_memory_rss_human:611.62M used_memory_peak:623615688 used_memory_peak_human:594.73M used_memory_peak_perc:100.00% used_memory_overhead:180205608 used_memory_startup:510704 used_memory_dataset:443410080 used_memory_dataset_perc:71.16% allocator_allocated:623690112 allocator_active:623996928 allocator_resident:640716800 total_system_memory:1044770816 total_system_memory_human:996.37M used_memory_lua:37888 used_memory_lua_human:37.00K maxmemory:0 maxmemory_human:0B maxmemory_policy:noeviction allocator_frag_ratio:1.00 allocator_frag_bytes:306816 allocator_rss_ratio:1.03 allocator_rss_bytes:16719872 rss_overhead_ratio:1.00 rss_overhead_bytes:618496 mem_fragmentation_ratio:1.03 mem_fragmentation_bytes:17720384 mem_allocator:jemalloc-4.0.3 active_defrag_running:0 lazyfree_pending_objects:0 # Persistence loading:0 rdb_changes_since_last_save:17982283 rdb_bgsave_in_progress:0 rdb_last_save_time:1534770940 rdb_last_bgsave_status:ok rdb_last_bgsave_time_sec:-1 rdb_current_bgsave_time_sec:-1 rdb_last_cow_size:0 aof_enabled:0 aof_rewrite_in_progress:0 aof_rewrite_scheduled:0 aof_last_rewrite_time_sec:-1 aof_current_rewrite_time_sec:-1 aof_last_bgrewrite_status:ok aof_last_write_status:ok aof_last_cow_size:0 # Stats total_connections_received:188 total_commands_processed:44454030 instantaneous_ops_per_sec:663 total_net_input_bytes:3670293956 total_net_output_bytes:618934664 instantaneous_input_kbps:53.33 instantaneous_output_kbps:13.45 rejected_connections:0 sync_full:0 sync_partial_ok:0 sync_partial_err:0 expired_keys:56335 expired_stale_perc:0.00 expired_time_cap_reached_count:0 evicted_keys:0 keyspace_hits:10364361 keyspace_misses:4366710 pubsub_channels:0 pubsub_patterns:0 latest_fork_usec:0 migrate_cached_sockets:0 slave_expires_tracked_keys:0 active_defrag_hits:0 active_defrag_misses:0 active_defrag_key_hits:0 active_defrag_key_misses:0 # Replication role:master connected_slaves:0 master_replid:e06cc8078080966de939fa81fa64259a5bd9408f master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 # CPU used_cpu_sys:5227.78 used_cpu_user:92420.12 used_cpu_sys_children:0.00 used_cpu_user_children:0.00 # Cluster cluster_enabled:0 # Keyspace db0:keys=3647016,expires=1864,avg_ttl=4481659497279&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6096e970e5c42ed21982f9ca5dd897f455d73bbe" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; LPUSH mylist &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; LPUSH mylist &quot;Hello&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; LINDEX mylist 0&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;redis&amp;gt; LINDEX mylist -1&lt;code&gt;&quot;World&quot;&lt;/code&gt;redis&amp;gt; LINDEX mylist 3&lt;code&gt;(nil)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; LPUSH mylist &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; LPUSH mylist &quot;Hola&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; LINDEX mylist 0 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; redis&amp;gt; LINDEX mylist -1 &lt;code&gt;&quot;World&quot;&lt;/code&gt; redis&amp;gt; LINDEX mylist 3 &lt;code&gt;(nil)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe9d3d033a627ad900caf25a35cb5ccfbeaba67c" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; LPUSH mylist &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; LPUSH mylist &quot;Hello&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; LLEN mylist&lt;code&gt;(integer) 2&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; LPUSH mylist &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; LPUSH mylist &quot;Hola&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; LLEN mylist &lt;code&gt;(integer) 2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34764d27e1af57967344ee22d151c5d50bda551b" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; LPUSH mylist &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; LPUSHX mylist &quot;Hello&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; LPUSHX myotherlist &quot;Hello&quot;&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;Hello&quot;
2) &quot;World&quot;&lt;/code&gt;redis&amp;gt; LRANGE myotherlist 0 -1&lt;code&gt;(empty list or set)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; LPUSH mylist &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; LPUSHX mylist &quot;Hola&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; LPUSHX myotherlist &quot;Hola&quot; &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 -1 &lt;code&gt;1) &quot;Hello&quot; 2) &quot;World&quot;&lt;/code&gt; redis&amp;gt; LRANGE myotherlist 0 -1 &lt;code&gt;(empty list or set)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9503beafc96da1b70d5176e2528a6e8d087cd3a" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; LPUSH mylist &quot;world&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; LPUSH mylist &quot;hello&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;hello&quot;
2) &quot;world&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; LPUSH mylist &quot;mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; LPUSH mylist &quot;hola&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 -1 &lt;code&gt;1) &quot;hello&quot; 2) &quot;world&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8bd697fde9f00b28be2a0476d0768147a8e6599" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; MSET firstname Jack lastname Stuntman age 35&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; KEYS *name*&lt;code&gt;1) &quot;firstname&quot;
2) &quot;lastname&quot;&lt;/code&gt;redis&amp;gt; KEYS a??&lt;code&gt;1) &quot;age&quot;&lt;/code&gt;redis&amp;gt; KEYS *&lt;code&gt;1) &quot;firstname&quot;
2) &quot;lastname&quot;
3) &quot;age&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; MSET nombre Jack apellido Stuntman edad 35 &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; CLAVES * nombre * &lt;code&gt;1) &quot;firstname&quot; 2) &quot;lastname&quot;&lt;/code&gt; redis&amp;gt; CLAVES a ?? &lt;code&gt;1) &quot;age&quot;&lt;/code&gt; redis&amp;gt; CLAVES * &lt;code&gt;1) &quot;firstname&quot; 2) &quot;lastname&quot; 3) &quot;age&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e773c16f9ffd29a6f4da93dc8bfd0d1c6f2e03bb" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; MSET key1 &quot;Hello&quot; key2 &quot;World&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; GET key1&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;redis&amp;gt; GET key2&lt;code&gt;&quot;World&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; tecla MSET1 &quot;Hola&quot; tecla2 &quot;Mundo&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; GET tecla1 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; redis&amp;gt; GET tecla2 &lt;code&gt;&quot;World&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b47bde41e28af46588d98143b67b70540477927b" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; MSETNX key1 &quot;Hello&quot; key2 &quot;there&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; MSETNX key2 &quot;there&quot; key3 &quot;world&quot;&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; MGET key1 key2 key3&lt;code&gt;1) &quot;Hello&quot;
2) &quot;there&quot;
3) (nil)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; MSETNX key1 &quot;Hola&quot; key2 &quot;there&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; MSETNX key2 &quot;there&quot; key3 &quot;world&quot; &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; MGET key1 key2 key3 &lt;code&gt;1) &quot;Hello&quot; 2) &quot;there&quot; 3) (nil)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f97a2803dc94d88f16aea386ac46a3330977c1c" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; PFADD hll a b c d e f g&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; PFCOUNT hll&lt;code&gt;(integer) 7&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; PFADD hll abcdefg &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; PFCOUNT hll &lt;code&gt;(integer) 7&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a68e99f888c2fd600a520da5f4b390434b366cce" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; PFADD hll foo bar zap&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; PFADD hll zap zap zap&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; PFADD hll foo bar&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; PFCOUNT hll&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; PFADD some-other-hll 1 2 3&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; PFCOUNT hll some-other-hll&lt;code&gt;(integer) 6&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; PFADD hll foo bar zap &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; PFADD hll zap zap zap &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; PFADD hll foo bar &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; PFCOUNT hll &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; PFADD some-other-hll 1 2 3 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; PFCOUNT hll alg&amp;uacute;n-otro-hll &lt;code&gt;(integer) 6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70818ef443d4ee46b3b5e147a47b4fb7b9fce78c" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; PFADD hll1 foo bar zap a&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; PFADD hll2 a b c foo&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; PFMERGE hll3 hll1 hll2&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; PFCOUNT hll3&lt;code&gt;(integer) 6&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; PFADD hll1 foo bar zap a &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; PFADD hll2 abc foo &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; PFMERGE hll3 hll1 hll2 &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; PFCOUNT hll3 &lt;code&gt;(integer) 6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca3ce6899ce2b28cdf3c48cbd3ba7107424eb6c6" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; PING&lt;code&gt;&quot;PONG&quot;&lt;/code&gt;redis&amp;gt; PING &quot;hello world&quot;&lt;code&gt;&quot;hello world&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; PING &lt;code&gt;&quot;PONG&quot;&lt;/code&gt; redis&amp;gt; PING &quot;hola mundo&quot; &lt;code&gt;&quot;hello world&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="acd5481077b7969a5710a4f74018f86f6c20dd67" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; PSETEX mykey 1000 &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; PTTL mykey&lt;code&gt;(integer) 999&lt;/code&gt;redis&amp;gt; GET mykey&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; PSETEX mykey 1000 &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; PTTL mykey &lt;code&gt;(integer) 999&lt;/code&gt; redis&amp;gt; GET mykey &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c78faa3420315a2281d113e9fef456e70657b2df" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ROLE&lt;code&gt;1) &quot;master&quot;
2) (integer) 0
3) (empty list or set)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ROLE &lt;code&gt;1) &quot;master&quot; 2) (integer) 0 3) (empty list or set)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d28a07d2ce9498a72c1b14b88637e4a80e8ab00" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; RPUSH mylist &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;World&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; LINSERT mylist BEFORE &quot;World&quot; &quot;There&quot;&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;Hello&quot;
2) &quot;There&quot;
3) &quot;World&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; RPUSH mylist &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;Mundo&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; LINSERT mylist ANTES de &quot;Mundo&quot; &quot;All&amp;iacute;&quot; &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 -1 &lt;code&gt;1) &quot;Hello&quot; 2) &quot;There&quot; 3) &quot;World&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adc2c8c91aecad44813fd929d390b0247f98a7de" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; RPUSH mylist &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; RPUSHX mylist &quot;World&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; RPUSHX myotherlist &quot;World&quot;&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;Hello&quot;
2) &quot;World&quot;&lt;/code&gt;redis&amp;gt; LRANGE myotherlist 0 -1&lt;code&gt;(empty list or set)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; RPUSH mylist &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; RPUSHX mylist &quot;Mundo&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; RPUSHX myotherlist &quot;Mundo&quot; &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 -1 &lt;code&gt;1) &quot;Hello&quot; 2) &quot;World&quot;&lt;/code&gt; redis&amp;gt; LRANGE myotherlist 0 -1 &lt;code&gt;(empty list or set)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea219d7dfe0bac8b5ed1b327921a0c5341c714e" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; RPUSH mylist &quot;hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;hello&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;foo&quot;&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;hello&quot;&lt;code&gt;(integer) 4&lt;/code&gt;redis&amp;gt; LREM mylist -2 &quot;hello&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;hello&quot;
2) &quot;foo&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; RPUSH mylist &quot;hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;hola&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;foo&quot; &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;hola&quot; &lt;code&gt;(integer) 4&lt;/code&gt; redis&amp;gt; LREM mylist -2 &quot;hola&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 -1 &lt;code&gt;1) &quot;hello&quot; 2) &quot;foo&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a52b8e0b9003fd0dafa30d465ed3cbbb1ad5736" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; RPUSH mylist &quot;hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;world&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;hello&quot;
2) &quot;world&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; RPUSH mylist &quot;hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;mundo&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 -1 &lt;code&gt;1) &quot;hello&quot; 2) &quot;world&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7c7f134659f1fe412c135f8c178af76cfb73b7f" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; RPUSH mylist &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;two&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;three&quot;&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; LPOP mylist&lt;code&gt;&quot;one&quot;&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;two&quot;
2) &quot;three&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; RPUSH mylist &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;dos&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;tres&quot; &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; LPOP mylist &lt;code&gt;&quot;one&quot;&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 -1 &lt;code&gt;1) &quot;two&quot; 2) &quot;three&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25323c3198faa6b1be4197c8fc362245084ac8df" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; RPUSH mylist &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;two&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;three&quot;&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 0&lt;code&gt;1) &quot;one&quot;&lt;/code&gt;redis&amp;gt; LRANGE mylist -3 2&lt;code&gt;1) &quot;one&quot;
2) &quot;two&quot;
3) &quot;three&quot;&lt;/code&gt;redis&amp;gt; LRANGE mylist -100 100&lt;code&gt;1) &quot;one&quot;
2) &quot;two&quot;
3) &quot;three&quot;&lt;/code&gt;redis&amp;gt; LRANGE mylist 5 10&lt;code&gt;(empty list or set)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; RPUSH mylist &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;dos&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;tres&quot; &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 0 &lt;code&gt;1) &quot;one&quot;&lt;/code&gt; redis&amp;gt; LRANGE mylist -3 2 &lt;code&gt;1) &quot;one&quot; 2) &quot;two&quot; 3) &quot;three&quot;&lt;/code&gt; redis&amp;gt; LRANGE mylist -100100 &lt;code&gt;1) &quot;one&quot; 2) &quot;two&quot; 3) &quot;three&quot;&lt;/code&gt; redis&amp;gt; LRANGE mylist 5 10 &lt;code&gt;(empty list or set)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78837b0e2341286eaf4f40bea03af6db1ce777c0" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; RPUSH mylist &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;two&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;three&quot;&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; LSET mylist 0 &quot;four&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; LSET mylist -2 &quot;five&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;four&quot;
2) &quot;five&quot;
3) &quot;three&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; RPUSH mylist &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;dos&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;tres&quot; &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; LSET mylist 0 &quot;cuatro&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; LSET mylist -2 &quot;cinco&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 -1 &lt;code&gt;1) &quot;four&quot; 2) &quot;five&quot; 3) &quot;three&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17322faab1449e24e7adf2165c3956aa37ba2d04" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; RPUSH mylist &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;two&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;three&quot;&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; LTRIM mylist 1 -1&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;two&quot;
2) &quot;three&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; RPUSH mylist &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;dos&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;tres&quot; &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; LTRIM mylist 1 -1 &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 -1 &lt;code&gt;1) &quot;two&quot; 2) &quot;three&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="629e48794cf28a17fb70994bce9056b213bbf0d2" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; RPUSH mylist &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;two&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;three&quot;&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; RPOP mylist&lt;code&gt;&quot;three&quot;&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;one&quot;
2) &quot;two&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; RPUSH mylist &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;dos&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;tres&quot; &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; RPOP mylist &lt;code&gt;&quot;three&quot;&lt;/code&gt; redis&amp;gt; LRANGE mylist 0 -1 &lt;code&gt;1) &quot;one&quot; 2) &quot;two&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9a85c4542c22b60c3f147274d4c2c57f448d50d" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; RPUSH mylist &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;two&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; RPUSH mylist &quot;three&quot;&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; RPOPLPUSH mylist myotherlist&lt;code&gt;&quot;three&quot;&lt;/code&gt;redis&amp;gt; LRANGE mylist 0 -1&lt;code&gt;1) &quot;one&quot;
2) &quot;two&quot;&lt;/code&gt;redis&amp;gt; LRANGE myotherlist 0 -1&lt;code&gt;1) &quot;three&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; RPUSH mylist &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;dos&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; RPUSH mylist &quot;tres&quot; &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; RPOPLPUSH mylist myotherlist &lt;code&gt;&quot;three&quot;&lt;/code&gt; redis&amp;gt; LRANGE mylist 0-1 &lt;code&gt;1) &quot;one&quot; 2) &quot;two&quot;&lt;/code&gt; redis&amp;gt; LRANGE myotherlist 0 -1 &lt;code&gt;1) &quot;three&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2acb5374c39d61f45e4f4959becd7097740843b5" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD key1 &quot;a&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;b&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;d&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;e&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SDIFF key1 key2&lt;code&gt;1) &quot;b&quot;
2) &quot;a&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; tecla SADD1 &quot;a&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;b&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;d &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2&quot; e &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SDIFF1 tecla2 &lt;code&gt;1) &quot;b&quot; 2) &quot;a&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32d0c65538e08157fb1e6ea41e8e7f6d9c950166" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD key1 &quot;a&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;b&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;d&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;e&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SDIFFSTORE key key1 key2&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; SMEMBERS key&lt;code&gt;1) &quot;b&quot;
2) &quot;a&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; tecla SADD1 &quot;a&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;b&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;d &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2&quot; e &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SDIFFSTORE tecla1 tecla2 &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; tecla SMEMBERS &lt;code&gt;1) &quot;b&quot; 2) &quot;a&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c783c99b2e33d659bf0b7fd5e5b71e12c046375" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD key1 &quot;a&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;b&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;d&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;e&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SINTER key1 key2&lt;code&gt;1) &quot;c&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; tecla SADD1 &quot;a&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;b&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;d &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2&quot; e &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SINTER1 tecla2 &lt;code&gt;1) &quot;c&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7a3a74680d314d8d2c81f7ab13a1c84669355e9" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD key1 &quot;a&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;b&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;d&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;e&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SINTERSTORE key key1 key2&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SMEMBERS key&lt;code&gt;1) &quot;c&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; tecla SADD1 &quot;a&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;b&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;d &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2&quot; e &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SINTERSTORE tecla1 tecla2 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SMEMBERS &lt;code&gt;1) &quot;c&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d70a488aa218a7211996e107aadfedcb9bde6565" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD key1 &quot;a&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;b&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;d&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;e&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SUNION key1 key2&lt;code&gt;1) &quot;b&quot;
2) &quot;c&quot;
3) &quot;a&quot;
4) &quot;e&quot;
5) &quot;d&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; tecla SADD1 &quot;a&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;b&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;d &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2&quot; e &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SUNION1 tecla2 &lt;code&gt;1) &quot;b&quot; 2) &quot;c&quot; 3) &quot;a&quot; 4) &quot;e&quot; 5) &quot;d&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a01d3129ee5c2cdcc8a346a858bcb5f1fff0a766" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD key1 &quot;a&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;b&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key1 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;c&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;d&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key2 &quot;e&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SUNIONSTORE key key1 key2&lt;code&gt;(integer) 5&lt;/code&gt;redis&amp;gt; SMEMBERS key&lt;code&gt;1) &quot;b&quot;
2) &quot;c&quot;
3) &quot;a&quot;
4) &quot;e&quot;
5) &quot;d&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; tecla SADD1 &quot;a&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;b&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD1 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;c&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2 &quot;d &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SADD2&quot; e &quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; tecla SUNIONSTORE tecla1 tecla2 &lt;code&gt;(integer) 5&lt;/code&gt; redis&amp;gt; tecla SMEMBERS &lt;code&gt;1) &quot;b&quot; 2) &quot;c&quot; 3) &quot;a&quot; 4) &quot;e&quot; 5) &quot;d&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73e41a762fa91a9e58e1660d47f0add64a4029a1" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD myset &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myset &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myset &quot;World&quot;&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; SMEMBERS myset&lt;code&gt;1) &quot;Hello&quot;
2) &quot;World&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SADD myset &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myset &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myset &quot;Mundo&quot; &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; SMEMBERS myset &lt;code&gt;1) &quot;Hello&quot; 2) &quot;World&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0e8f402998b296befac50a90905d60ae1dfb01e" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD myset &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myset &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SCARD myset&lt;code&gt;(integer) 2&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SADD myset &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myset &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SCARD myset &lt;code&gt;(integer) 2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0be84d79c9fd19e9f397f5e167e5997a82af597" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD myset &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myset &quot;World&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SMEMBERS myset&lt;code&gt;1) &quot;Hello&quot;
2) &quot;World&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SADD myset &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myset &quot;Mundo&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SMEMBERS myset &lt;code&gt;1) &quot;Hello&quot; 2) &quot;World&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85c0a4d017c07852ba27cfafbd379e063180c576" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD myset &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myset &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myotherset &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SMOVE myset myotherset &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SMEMBERS myset&lt;code&gt;1) &quot;one&quot;&lt;/code&gt;redis&amp;gt; SMEMBERS myotherset&lt;code&gt;1) &quot;two&quot;
2) &quot;three&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SADD myset &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myset &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myotherset &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SMOVE myset myotherset &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SMEMBERS myset &lt;code&gt;1) &quot;one&quot;&lt;/code&gt; redis&amp;gt; SMEMBERS myotherset &lt;code&gt;1) &quot;two&quot; 2) &quot;three&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db568f7fccabcff5800185476d98f2a479128bb6" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD myset &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myset &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myset &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SPOP myset&lt;code&gt;&quot;two&quot;&lt;/code&gt;redis&amp;gt; SMEMBERS myset&lt;code&gt;1) &quot;one&quot;
2) &quot;three&quot;&lt;/code&gt;redis&amp;gt; SADD myset &quot;four&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myset &quot;five&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SPOP myset 3&lt;code&gt;1) &quot;four&quot;
2) &quot;five&quot;
3) &quot;one&quot;&lt;/code&gt;redis&amp;gt; SMEMBERS myset&lt;code&gt;1) &quot;three&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SADD myset &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myset &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myset &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SPOP myset &lt;code&gt;&quot;two&quot;&lt;/code&gt; redis&amp;gt; SMEMBERS myset &lt;code&gt;1) &quot;one&quot; 2) &quot;three&quot;&lt;/code&gt; redis&amp;gt; SADD myset &quot;cuatro&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myset &quot;cinco&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SPOP myset 3 &lt;code&gt;1) &quot;four&quot; 2) &quot;five&quot; 3) &quot;one&quot;&lt;/code&gt; redis&amp;gt; SMEMBERS myset &lt;code&gt;1) &quot;three&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2f83ad1499dd841302d21ef582f1dae218da1be" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD myset &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myset &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD myset &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SREM myset &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SREM myset &quot;four&quot;&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; SMEMBERS myset&lt;code&gt;1) &quot;three&quot;
2) &quot;two&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SADD myset &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myset &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD myset &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SREM myset &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SREM myset &quot;cuatro &quot; &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; SMEMBERS myset &lt;code&gt;1) &quot;three&quot; 2) &quot;two&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a51fb153204bbc5502e09c2a8c51759d9e80979" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD myset &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SISMEMBER myset &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SISMEMBER myset &quot;two&quot;&lt;code&gt;(integer) 0&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SADD myset &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SISMEMBER myset &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SISMEMBER myset &quot;dos&quot; &lt;code&gt;(integer) 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="573178b5a2337e96e9cbd4e841c2894466e3ad24" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SADD myset one two three&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; SRANDMEMBER myset&lt;code&gt;&quot;one&quot;&lt;/code&gt;redis&amp;gt; SRANDMEMBER myset 2&lt;code&gt;1) &quot;one&quot;
2) &quot;three&quot;&lt;/code&gt;redis&amp;gt; SRANDMEMBER myset -5&lt;code&gt;1) &quot;one&quot;
2) &quot;two&quot;
3) &quot;three&quot;
4) &quot;one&quot;
5) &quot;three&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SADD myset uno dos tres &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; SRANDMEMBER myset &lt;code&gt;&quot;one&quot;&lt;/code&gt; redis&amp;gt; SRANDMEMBER myset 2 &lt;code&gt;1) &quot;one&quot; 2) &quot;three&quot;&lt;/code&gt; redis&amp;gt; SRANDMEMBER myset -5 &lt;code&gt;1) &quot;one&quot; 2) &quot;two&quot; 3) &quot;three&quot; 4) &quot;one&quot; 5) &quot;three&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660e771f43faff83806b46223db662d0e2061b52" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET key1 &quot;Hello World&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; SETRANGE key1 6 &quot;Redis&quot;&lt;code&gt;(integer) 11&lt;/code&gt;redis&amp;gt; GET key1&lt;code&gt;&quot;Hello Redis&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; tecla SET1 &quot;Hola mundo&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; tecla SETRANGE1 6 &quot;Redis&quot; &lt;code&gt;(integer) 11&lt;/code&gt; redis&amp;gt; tecla GET1 &lt;code&gt;&quot;Hello Redis&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="693791038b41e9803d45a4bb2bda7df464233de9" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET key1 &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; EXISTS key1&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; EXISTS nosuchkey&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; SET key2 &quot;World&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; EXISTS key1 key2 nosuchkey&lt;code&gt;(integer) 2&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET key1 &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; EXISTS key1 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; EXISTS nosuchkey &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; SET key2 &quot;World&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; EXISTS key1 key2 nosuchkey &lt;code&gt;(integer) 2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb60babc2e208f22411f8d2d14cd586e2ae82ae9" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET key1 &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; SET key2 &quot;World&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; DEL key1 key2 key3&lt;code&gt;(integer) 2&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; Tecla SET1 &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; Tecla SET2 &quot;Mundo&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; Tecla DEL1 Tecla2 Tecla3 &lt;code&gt;(integer) 2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf72bbcc451fdce734ee330e7f49b42f84d1e4eb" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET key1 &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; SET key2 &quot;World&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; MGET key1 key2 nonexisting&lt;code&gt;1) &quot;Hello&quot;
2) &quot;World&quot;
3) (nil)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; Tecla SET1 &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; Tecla SET2 &quot;Mundo&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; Tecla MGET1 Tecla2 inexistente &lt;code&gt;1) &quot;Hello&quot; 2) &quot;World&quot; 3) (nil)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74072a9618516d818bb6b2de485fc24f5240e6ce" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET key1 &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; SET key2 &quot;World&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; TOUCH key1 key2&lt;code&gt;(integer) 2&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; Tecla SET1 &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; Tecla SET2 &quot;Mundo&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; Tecla TOUCH1 Tecla2 &lt;code&gt;(integer) 2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90e86a20b776b5452608ec4464d39def4dbc16b5" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET key1 &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; SET key2 &quot;World&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; UNLINK key1 key2 key3&lt;code&gt;(integer) 2&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; tecla SET1 &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; tecla SET2 &quot;Mundo&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; DESLINK tecla1 tecla2 tecla3 &lt;code&gt;(integer) 2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76627fa25b7d40499ed2e3790985956dd7da71f9" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET key1 &quot;foobar&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; SET key2 &quot;abcdef&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; BITOP AND dest key1 key2&lt;code&gt;(integer) 6&lt;/code&gt;redis&amp;gt; GET dest&lt;code&gt;&quot;`bc`ab&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET key1 &quot;foobar&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; SET key2 &quot;abcdef&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; BITOP Y dest key1 key2 &lt;code&gt;(integer) 6&lt;/code&gt; redis&amp;gt; GET dest &lt;code&gt;&quot;`bc`ab&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8dfe48f5edc1733c08f1dd7fe1a7330b27a2be6d" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET key1 &quot;value&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; LPUSH key2 &quot;value&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SADD key3 &quot;value&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; TYPE key1&lt;code&gt;&quot;string&quot;&lt;/code&gt;redis&amp;gt; TYPE key2&lt;code&gt;&quot;list&quot;&lt;/code&gt;redis&amp;gt; TYPE key3&lt;code&gt;&quot;set&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET key1 &quot;valor&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; LPUSH key2 &quot;value&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SADD key3 &quot;value&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; TYPE key1 &lt;code&gt;&quot;string&quot;&lt;/code&gt; redis&amp;gt; TYPE key2 &lt;code&gt;&quot;list&quot;&lt;/code&gt; redis&amp;gt; TYPE key3 &lt;code&gt;&quot;set&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="549fd12b48dbbc9d9c20b90ed2f2f04abd2e7701" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;10&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; DECR mykey&lt;code&gt;(integer) 9&lt;/code&gt;redis&amp;gt; SET mykey &quot;234293482390480948029348230948&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; DECR mykey&lt;code&gt;ERR ERR value is not an integer or out of range&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;10&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; DECR mykey &lt;code&gt;(integer) 9&lt;/code&gt; redis&amp;gt; SET mykey &quot;234293482390480948029348230948&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; DECR mykey &lt;code&gt;ERR ERR value is not an integer or out of range&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7109916c2f650a91d5605d3cc66d6ed27da504b3" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;10&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; DECRBY mykey 3&lt;code&gt;(integer) 7&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;10&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; DECRBY mykey 3 &lt;code&gt;(integer) 7&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="903449ba0eb2a758c3fe8fdc06309c998b20bcf4" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;10&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; INCR mykey&lt;code&gt;(integer) 11&lt;/code&gt;redis&amp;gt; GET mykey&lt;code&gt;&quot;11&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;10&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; INCR mykey &lt;code&gt;(integer) 11&lt;/code&gt; redis&amp;gt; GET mykey &lt;code&gt;&quot;11&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce7b1f6f45763fd7dad8459530b17a1ed18db1ea" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;10&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; INCRBY mykey 5&lt;code&gt;(integer) 15&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;10&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; INCRBY mykey 5 &lt;code&gt;(integer) 15&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d610677adbb082092d8396567c6fbc097646cabc" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello world&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; STRLEN mykey&lt;code&gt;(integer) 11&lt;/code&gt;redis&amp;gt; STRLEN nonexisting&lt;code&gt;(integer) 0&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola mundo&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; STRLEN mykey &lt;code&gt;(integer) 11&lt;/code&gt; redis&amp;gt; STRLEN inexistente &lt;code&gt;(integer) 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b86594b620b83cfe21697e03f203d91f11a5f77" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; EXISTS mykey&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; EXPIREAT mykey 1293840000&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; EXISTS mykey&lt;code&gt;(integer) 0&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; EXISTS mykey &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; EXPIREAT mykey 1293840000 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; EXISTS mykey &lt;code&gt;(integer) 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="559cf2b5cc55ec35aaa61b3eb1e011946ac5e515" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; EXPIRE mykey 10&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; TTL mykey&lt;code&gt;(integer) 10&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; EXPIRE mykey 10 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; TTL mykey &lt;code&gt;(integer) 10&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36c1a7d13c3e73259feb14c72b5d5a2185ce0926" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; EXPIRE mykey 10&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; TTL mykey&lt;code&gt;(integer) 10&lt;/code&gt;redis&amp;gt; PERSIST mykey&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; TTL mykey&lt;code&gt;(integer) -1&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; EXPIRE mykey 10 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; TTL mykey &lt;code&gt;(integer) 10&lt;/code&gt; redis&amp;gt; PERSIST mykey &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; TTL mykey &lt;code&gt;(integer) -1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="009a6bbd7bb994fc0911e4fd0a1e20838b94011c" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; EXPIRE mykey 10&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; TTL mykey&lt;code&gt;(integer) 10&lt;/code&gt;redis&amp;gt; SET mykey &quot;Hello World&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; TTL mykey&lt;code&gt;(integer) -1&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; EXPIRE mykey 10 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; TTL mykey &lt;code&gt;(integer) 10&lt;/code&gt; redis&amp;gt; SET mykey &quot;Hello World&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; TTL mykey &lt;code&gt;(integer) -1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72695899800522ca2226ae99811c8620e6bd9db5" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; EXPIRE mykey 1&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; PTTL mykey&lt;code&gt;(integer) 999&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; EXPIRE mykey 1 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; PTTL mykey &lt;code&gt;(integer) 999&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2586b1984f3a7f730b590535cc71e63527ac1df" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; GET mykey&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; GET mykey &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a92efd32d3502f0b9e43419ef8941fd4652d3ab" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; GETSET mykey &quot;World&quot;&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;redis&amp;gt; GET mykey&lt;code&gt;&quot;World&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; GETSET mykey &quot;Mundo&quot; &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; redis&amp;gt; GET mykey &lt;code&gt;&quot;World&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd312ae9f5c1e81b4803abd4ee94d102bac90fdb" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; PEXPIRE mykey 1500&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; TTL mykey&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; PTTL mykey&lt;code&gt;(integer) 1498&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; PEXPIRE mykey 1500 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; TTL mykey &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; PTTL mykey &lt;code&gt;(integer) 1498&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f239adbe827a2d01d8482691ec845130f3fa7874" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; PEXPIREAT mykey 1555555555005&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; TTL mykey&lt;code&gt;(integer) 14181068&lt;/code&gt;redis&amp;gt; PTTL mykey&lt;code&gt;(integer) 14181067817&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; PEXPIREAT mykey 1555555555005 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; TTL mykey &lt;code&gt;(integer) 14181068&lt;/code&gt; redis&amp;gt; PTTL mykey &lt;code&gt;(integer) 14181067817&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37a35707996fd6997bca69c8eae61257d585ca1f" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; RENAME mykey myotherkey&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; GET myotherkey&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; CAMBIAR EL NOMBRE mykey myotherkey &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; GET myotherkey &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d91131ec37ba67a1449f29b8cbe40f52d1b0d49" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; SET myotherkey &quot;World&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; RENAMENX mykey myotherkey&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; GET myotherkey&lt;code&gt;&quot;World&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; SET myotherkey &quot;World&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; RENAMENX mykey myotherkey &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; GET myotherkey &lt;code&gt;&quot;World&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96955706032ef9d34e2008b2ca41bdcfdb740e83" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;This is a string&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; GETRANGE mykey 0 3&lt;code&gt;&quot;This&quot;&lt;/code&gt;redis&amp;gt; GETRANGE mykey -3 -1&lt;code&gt;&quot;ing&quot;&lt;/code&gt;redis&amp;gt; GETRANGE mykey 0 -1&lt;code&gt;&quot;This is a string&quot;&lt;/code&gt;redis&amp;gt; GETRANGE mykey 10 100&lt;code&gt;&quot;string&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;Esto es una cadena&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; GETRANGE mykey 0 3 &lt;code&gt;&quot;This&quot;&lt;/code&gt; redis&amp;gt; GETRANGE mykey -3 -1 &lt;code&gt;&quot;ing&quot;&lt;/code&gt; redis&amp;gt; GETRANGE mykey 0 -1 &lt;code&gt;&quot;This is a string&quot;&lt;/code&gt; redis&amp;gt; GETRANGE mykey 10 100 &lt;code&gt;&quot;string&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af3af68565146756f9417f890aa43b26b336730a" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;\xff\xf0\x00&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; BITPOS mykey 0&lt;code&gt;(integer) 12&lt;/code&gt;redis&amp;gt; SET mykey &quot;\x00\xff\xf0&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; BITPOS mykey 1 0&lt;code&gt;(integer) 8&lt;/code&gt;redis&amp;gt; BITPOS mykey 1 2&lt;code&gt;(integer) 16&lt;/code&gt;redis&amp;gt; set mykey &quot;\x00\x00\x00&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; BITPOS mykey 1&lt;code&gt;(integer) -1&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;\ xff \ xf0 \ x00&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; BITPOS mykey 0 &lt;code&gt;(integer) 12&lt;/code&gt; redis&amp;gt; SET mykey &quot;\ x00 \ xff \ xf0&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; BITPOS mykey 1 0 &lt;code&gt;(integer) 8&lt;/code&gt; redis &amp;gt; BITPOS mykey 1 2 &lt;code&gt;(integer) 16&lt;/code&gt; redis&amp;gt; set mykey &quot;\ x00 \ x00 \ x00&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; BITPOS mykey 1 &lt;code&gt;(integer) -1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="696433601ee89780b53a327f8499846cc1b2ac95" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey &quot;foobar&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; BITCOUNT mykey&lt;code&gt;(integer) 26&lt;/code&gt;redis&amp;gt; BITCOUNT mykey 0 0&lt;code&gt;(integer) 4&lt;/code&gt;redis&amp;gt; BITCOUNT mykey 1 1&lt;code&gt;(integer) 6&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey &quot;foobar&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; BITCOUNT mykey &lt;code&gt;(integer) 26&lt;/code&gt; redis&amp;gt; BITCOUNT mykey 0 0 &lt;code&gt;(integer) 4&lt;/code&gt; redis&amp;gt; BITCOUNT mykey 1 1 &lt;code&gt;(integer) 6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c7b0b9a6a518cdbf1f2d23b83e3b00cc41add33" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey 10.50&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; INCRBYFLOAT mykey 0.1&lt;code&gt;&quot;10.6&quot;&lt;/code&gt;redis&amp;gt; INCRBYFLOAT mykey -5&lt;code&gt;&quot;5.6&quot;&lt;/code&gt;redis&amp;gt; SET mykey 5.0e3&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; INCRBYFLOAT mykey 2.0e2&lt;code&gt;&quot;5200&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey 10.50 &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; INCRBYFLOAT mykey 0.1 &lt;code&gt;&quot;10.6&quot;&lt;/code&gt; redis&amp;gt; INCRBYFLOAT mykey -5 &lt;code&gt;&quot;5.6&quot;&lt;/code&gt; redis&amp;gt; SET mykey 5.0e3 &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; INCRBYFLOAT mykey 2.0e2 &lt;code&gt;&quot;5200&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="786509db3f46d8746a9afb386be4bb7435606c63" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SET mykey 10&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; DUMP mykey&lt;code&gt;&quot;\u0000\xC0\n\t\u0000\xBEm\u0006\x89Z(\u0000\n&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SET mykey 10 &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; DUMP mykey &lt;code&gt;&quot;\u0000\xC0\n\t\u0000\xBEm\u0006\x89Z(\u0000\n&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71b72f9da2f6edf30a6053d18ff86de1508cd010" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SETBIT mykey 7 1&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; GETBIT mykey 0&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; GETBIT mykey 7&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; GETBIT mykey 100&lt;code&gt;(integer) 0&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SETBIT mykey 7 1 &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; GETBIT mykey 0 &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; GETBIT mykey 7 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; GETBIT mykey 100 &lt;code&gt;(integer) 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6478080851123d002a9efec3f501cb73047f43cb" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SETBIT mykey 7 1&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; SETBIT mykey 7 0&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; GET mykey&lt;code&gt;&quot;\u0000&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SETBIT mykey 7 1 &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; SETBIT mykey 7 0 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; GET mykey &lt;code&gt;&quot;\u0000&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bae3fe71580252af9e95ff41cb4865fbba38cb6" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SETEX mykey 10 &quot;Hello&quot;&lt;code&gt;&quot;OK&quot;&lt;/code&gt;redis&amp;gt; TTL mykey&lt;code&gt;(integer) 10&lt;/code&gt;redis&amp;gt; GET mykey&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SETEX mykey 10 &quot;Hola&quot; &lt;code&gt;&quot;OK&quot;&lt;/code&gt; redis&amp;gt; TTL mykey &lt;code&gt;(integer) 10&lt;/code&gt; redis&amp;gt; GET mykey &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd0f3994ae7aeda7b5d80f11008e3132b48c7226" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SETNX mykey &quot;Hello&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; SETNX mykey &quot;World&quot;&lt;code&gt;(integer) 0&lt;/code&gt;redis&amp;gt; GET mykey&lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SETNX mykey &quot;Hola&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; SETNX mykey &quot;Mundo&quot; &lt;code&gt;(integer) 0&lt;/code&gt; redis&amp;gt; GET mykey &lt;code&gt;&quot;Hello&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5046a53e763b7d1920459be23c762fdddcf4af9d" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; SETRANGE key2 6 &quot;Redis&quot;&lt;code&gt;(integer) 11&lt;/code&gt;redis&amp;gt; GET key2&lt;code&gt;&quot;\u0000\u0000\u0000\u0000\u0000\u0000Redis&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; SETRANGE key2 6 &quot;Redis&quot; &lt;code&gt;(integer) 11&lt;/code&gt; redis&amp;gt; GET key2 &lt;code&gt;&quot;\u0000\u0000\u0000\u0000\u0000\u0000Redis&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b387f340d28b8cf37eabcb6ffb667e1d2bb6205f" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; TIME&lt;code&gt;1) &quot;1541374488&quot;
2) &quot;39268&quot;&lt;/code&gt;redis&amp;gt; TIME&lt;code&gt;1) &quot;1541374488&quot;
2) &quot;40008&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; HORA &lt;code&gt;1) &quot;1541374488&quot; 2) &quot;39268&quot;&lt;/code&gt; redis&amp;gt; HORA &lt;code&gt;1) &quot;1541374488&quot; 2) &quot;40008&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a37c3a6019cf8b931c5ac2a6b4808c99720e191" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; XACK mystream mygroup 1526569495631-0&lt;code&gt;ERR Unknown or disabled command 'XACK'&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; XACK mystream mygroup 1526569495631-0 &lt;code&gt;ERR Unknown or disabled command 'XACK'&lt;/code&gt; Comando desconocido o desactivado 'XACK'</target>
        </trans-unit>
        <trans-unit id="f35de6deeea5f8712c66ffd36c74870ab890a4b6" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; XADD mystream * field1 A field2 B field3 C field4 D&lt;code&gt;&quot;1541374488502-0&quot;&lt;/code&gt;redis&amp;gt; XTRIM mystream MAXLEN 2&lt;code&gt;ERR Unknown or disabled command 'XTRIM'&lt;/code&gt;redis&amp;gt; XRANGE mystream - +&lt;code&gt;1) 1) &quot;1541374488502-0&quot;
   2) 1) &quot;field1&quot;
      2) &quot;A&quot;
      3) &quot;field2&quot;
      4) &quot;B&quot;
      5) &quot;field3&quot;
      6) &quot;C&quot;
      7) &quot;field4&quot;
      8) &quot;D&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; XADD mystream * campo1 A campo2 B campo3 C campo4 D &lt;code&gt;&quot;1541374488502-0&quot;&lt;/code&gt; redis&amp;gt; XTRIM mystream MAXLEN 2 &lt;code&gt;ERR Unknown or disabled command 'XTRIM'&lt;/code&gt; Comando desconocido o desactivado 'XTRIM' redis&amp;gt; XRANGE mystream - + &lt;code&gt;1) 1) &quot;1541374488502-0&quot; 2) 1) &quot;field1&quot; 2) &quot;A&quot; 3) &quot;field2&quot; 4) &quot;B&quot; 5) &quot;field3&quot; 6) &quot;C&quot; 7) &quot;field4&quot; 8) &quot;D&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30c2161e6190455c8d054d56758f8209f4a42cfa" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; XADD mystream * item 1&lt;code&gt;&quot;1541374488587-0&quot;&lt;/code&gt;redis&amp;gt; XADD mystream * item 2&lt;code&gt;&quot;1541374488588-0&quot;&lt;/code&gt;redis&amp;gt; XADD mystream * item 3&lt;code&gt;&quot;1541374488590-0&quot;&lt;/code&gt;redis&amp;gt; XLEN mystream&lt;code&gt;(integer) 3&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; XADD mystream * elemento 1 &lt;code&gt;&quot;1541374488587-0&quot;&lt;/code&gt; redis&amp;gt; XADD mystream * elemento 2 &lt;code&gt;&quot;1541374488588-0&quot;&lt;/code&gt; redis&amp;gt; XADD mystream * elemento 3 &lt;code&gt;&quot;1541374488590-0&quot;&lt;/code&gt; redis&amp;gt; XLEN mystream &lt;code&gt;(integer) 3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7c1752762dcd9f80c91cf7732260d66f593e3f5" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; XADD mystream * name Sara surname OConnor&lt;code&gt;&quot;1541374488490-0&quot;&lt;/code&gt;redis&amp;gt; XADD mystream * field1 value1 field2 value2 field3 value3&lt;code&gt;&quot;1541374488491-0&quot;&lt;/code&gt;redis&amp;gt; XLEN mystream&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; XRANGE mystream - +&lt;code&gt;1) 1) &quot;1541374488490-0&quot;
   2) 1) &quot;name&quot;
      2) &quot;Sara&quot;
      3) &quot;surname&quot;
      4) &quot;OConnor&quot;
2) 1) &quot;1541374488491-0&quot;
   2) 1) &quot;field1&quot;
      2) &quot;value1&quot;
      3) &quot;field2&quot;
      4) &quot;value2&quot;
      5) &quot;field3&quot;
      6) &quot;value3&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; XADD mystream * nombre Sara apellido OConnor &lt;code&gt;&quot;1541374488490-0&quot;&lt;/code&gt; redis&amp;gt; XADD mystream * campo1 &lt;code&gt;&quot;1541374488491-0&quot;&lt;/code&gt; campo2 valor2 campo3 valor3 &quot;1541374488491-0&quot; redis&amp;gt; XLEN mystream &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; XRANGE mystream - + &lt;code&gt;1) 1) &quot;1541374488490-0&quot; 2) 1) &quot;name&quot; 2) &quot;Sara&quot; 3) &quot;surname&quot; 4) &quot;OConnor&quot; 2) 1) &quot;1541374488491-0&quot; 2) 1) &quot;field1&quot; 2) &quot;value1&quot; 3) &quot;field2&quot; 4) &quot;value2&quot; 5) &quot;field3&quot; 6) &quot;value3&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6228e53cfa47058ef8feb70a6a679119bfa20f69" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; XADD writers * name Virginia surname Woolf&lt;code&gt;&quot;1541374488566-0&quot;&lt;/code&gt;redis&amp;gt; XADD writers * name Jane surname Austen&lt;code&gt;&quot;1541374488567-0&quot;&lt;/code&gt;redis&amp;gt; XADD writers * name Toni surname Morris&lt;code&gt;&quot;1541374488568-0&quot;&lt;/code&gt;redis&amp;gt; XADD writers * name Agatha surname Christie&lt;code&gt;&quot;1541374488572-0&quot;&lt;/code&gt;redis&amp;gt; XADD writers * name Ngozi surname Adichie&lt;code&gt;&quot;1541374488572-1&quot;&lt;/code&gt;redis&amp;gt; XLEN writers&lt;code&gt;(integer) 5&lt;/code&gt;redis&amp;gt; XRANGE writers - + COUNT 2&lt;code&gt;1) 1) &quot;1541374488566-0&quot;
   2) 1) &quot;name&quot;
      2) &quot;Virginia&quot;
      3) &quot;surname&quot;
      4) &quot;Woolf&quot;
2) 1) &quot;1541374488567-0&quot;
   2) 1) &quot;name&quot;
      2) &quot;Jane&quot;
      3) &quot;surname&quot;
      4) &quot;Austen&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; escritores XADD * nombre Virginia apellido Woolf &lt;code&gt;&quot;1541374488566-0&quot;&lt;/code&gt; redis&amp;gt; escritores XADD * nombre Jane apellido Austen &lt;code&gt;&quot;1541374488567-0&quot;&lt;/code&gt; redis&amp;gt; escritores XADD * nombre Toni apellido Morris &lt;code&gt;&quot;1541374488568-0&quot;&lt;/code&gt; redis&amp;gt; escritores XADD * nombre Agatha apellido Christie &lt;code&gt;&quot;1541374488572-0&quot;&lt;/code&gt; redis&amp;gt; escritores XADD * nombre Ngozi apellido Adichie &lt;code&gt;&quot;1541374488572-1&quot;&lt;/code&gt; redis&amp;gt; escritores XLEN &lt;code&gt;(integer) 5&lt;/code&gt; redis&amp;gt; escritores XRANGE - + COUNT 2 &lt;code&gt;1) 1) &quot;1541374488566-0&quot; 2) 1) &quot;name&quot; 2) &quot;Virginia&quot; 3) &quot;surname&quot; 4) &quot;Woolf&quot; 2) 1) &quot;1541374488567-0&quot; 2) 1) &quot;name&quot; 2) &quot;Jane&quot; 3) &quot;surname&quot; 4) &quot;Austen&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7dab1e02f5c14190ec342b2ba939021fec44dc02" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; XADD writers * name Virginia surname Woolf&lt;code&gt;&quot;1541374488582-0&quot;&lt;/code&gt;redis&amp;gt; XADD writers * name Jane surname Austen&lt;code&gt;&quot;1541374488583-0&quot;&lt;/code&gt;redis&amp;gt; XADD writers * name Toni surname Morris&lt;code&gt;&quot;1541374488584-0&quot;&lt;/code&gt;redis&amp;gt; XADD writers * name Agatha surname Christie&lt;code&gt;&quot;1541374488586-0&quot;&lt;/code&gt;redis&amp;gt; XADD writers * name Ngozi surname Adichie&lt;code&gt;&quot;1541374488588-0&quot;&lt;/code&gt;redis&amp;gt; XLEN writers&lt;code&gt;(integer) 5&lt;/code&gt;redis&amp;gt; XREVRANGE writers + - COUNT 1&lt;code&gt;1) 1) &quot;1541374488588-0&quot;
   2) 1) &quot;name&quot;
      2) &quot;Ngozi&quot;
      3) &quot;surname&quot;
      4) &quot;Adichie&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; escritores XADD * nombre Virginia apellido Woolf &lt;code&gt;&quot;1541374488582-0&quot;&lt;/code&gt; redis&amp;gt; escritores XADD * nombre Jane apellido Austen &lt;code&gt;&quot;1541374488583-0&quot;&lt;/code&gt; redis&amp;gt; escritores XADD * nombre Toni apellido Morris &lt;code&gt;&quot;1541374488584-0&quot;&lt;/code&gt; redis&amp;gt; escritores XADD * nombre Agatha apellido Christie &lt;code&gt;&quot;1541374488586-0&quot;&lt;/code&gt; redis&amp;gt; escritores XADD * nombre Ngozi apellido Adichie &lt;code&gt;&quot;1541374488588-0&quot;&lt;/code&gt; redis&amp;gt; escritores XLEN &lt;code&gt;(integer) 5&lt;/code&gt; redis&amp;gt; escritores XREVRANGE + - COUNT 1 &lt;code&gt;1) 1) &quot;1541374488588-0&quot; 2) 1) &quot;name&quot; 2) &quot;Ngozi&quot; 3) &quot;surname&quot; 4) &quot;Adichie&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04c10fcf036c58ea2dd4d7101f9158f7381ec1f1" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g&lt;code&gt;(integer) 7&lt;/code&gt;redis&amp;gt; ZRANGEBYLEX myzset - [c&lt;code&gt;1) &quot;a&quot;
2) &quot;b&quot;
3) &quot;c&quot;&lt;/code&gt;redis&amp;gt; ZRANGEBYLEX myzset - (c&lt;code&gt;1) &quot;a&quot;
2) &quot;b&quot;&lt;/code&gt;redis&amp;gt; ZRANGEBYLEX myzset [aaa (g&lt;code&gt;1) &quot;b&quot;
2) &quot;c&quot;
3) &quot;d&quot;
4) &quot;e&quot;
5) &quot;f&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g &lt;code&gt;(integer) 7&lt;/code&gt; redis&amp;gt; ZRANGEBYLEX myzset - [c &lt;code&gt;1) &quot;a&quot; 2) &quot;b&quot; 3) &quot;c&quot;&lt;/code&gt; redis&amp;gt; ZRANGEBYLEX myzset - ( c &lt;code&gt;1) &quot;a&quot; 2) &quot;b&quot;&lt;/code&gt; redis&amp;gt; ZRANGEBYLEX myzset [aaa (g &lt;code&gt;1) &quot;b&quot; 2) &quot;c&quot; 3) &quot;d&quot; 4) &quot;e&quot; 5) &quot;f&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58b06a233fb1ea2d4ab25929fa76c0594193cc20" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g&lt;code&gt;(integer) 7&lt;/code&gt;redis&amp;gt; ZREVRANGEBYLEX myzset [c -&lt;code&gt;1) &quot;c&quot;
2) &quot;b&quot;
3) &quot;a&quot;&lt;/code&gt;redis&amp;gt; ZREVRANGEBYLEX myzset (c -&lt;code&gt;1) &quot;b&quot;
2) &quot;a&quot;&lt;/code&gt;redis&amp;gt; ZREVRANGEBYLEX myzset (g [aaa&lt;code&gt;1) &quot;f&quot;
2) &quot;e&quot;
3) &quot;d&quot;
4) &quot;c&quot;
5) &quot;b&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g &lt;code&gt;(integer) 7&lt;/code&gt; redis&amp;gt; ZREVRANGEBYLEX myzset [c - &lt;code&gt;1) &quot;c&quot; 2) &quot;b&quot; 3) &quot;a&quot;&lt;/code&gt; redis&amp;gt; ZREVRANGEBYLEX myzset (c - &lt;code&gt;1) &quot;b&quot; 2) &quot;a&quot;&lt;/code&gt; redis&amp;gt; ZREVRANGEBYLEX myzset (g [aaa &lt;code&gt;1) &quot;f&quot; 2) &quot;e&quot; 3) &quot;d&quot; 4) &quot;c&quot; 5) &quot;b&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33b5530deea57fece957aff9db45b5735e774866" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e&lt;code&gt;(integer) 5&lt;/code&gt;redis&amp;gt; ZADD myzset 0 f 0 g&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; ZLEXCOUNT myzset - +&lt;code&gt;(integer) 7&lt;/code&gt;redis&amp;gt; ZLEXCOUNT myzset [b [f&lt;code&gt;(integer) 5&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e &lt;code&gt;(integer) 5&lt;/code&gt; redis&amp;gt; ZADD myzset 0 f 0 g &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; ZLEXCOUNT myzset - + &lt;code&gt;(integer) 7&lt;/code&gt; redis&amp;gt; ZLEXCOUNT myzset [b [f &lt;code&gt;(integer) 5&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="250821297bab91fcd59d664bbc964c7280c106f3" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 0 aaaa 0 b 0 c 0 d 0 e&lt;code&gt;(integer) 5&lt;/code&gt;redis&amp;gt; ZADD myzset 0 foo 0 zap 0 zip 0 ALPHA 0 alpha&lt;code&gt;(integer) 5&lt;/code&gt;redis&amp;gt; ZRANGE myzset 0 -1&lt;code&gt;1) &quot;ALPHA&quot;
 2) &quot;aaaa&quot;
 3) &quot;alpha&quot;
 4) &quot;b&quot;
 5) &quot;c&quot;
 6) &quot;d&quot;
 7) &quot;e&quot;
 8) &quot;foo&quot;
 9) &quot;zap&quot;
10) &quot;zip&quot;&lt;/code&gt;redis&amp;gt; ZREMRANGEBYLEX myzset [alpha [omega&lt;code&gt;(integer) 6&lt;/code&gt;redis&amp;gt; ZRANGE myzset 0 -1&lt;code&gt;1) &quot;ALPHA&quot;
2) &quot;aaaa&quot;
3) &quot;zap&quot;
4) &quot;zip&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 0 aaaa 0 b 0 c 0 d 0 e &lt;code&gt;(integer) 5&lt;/code&gt; redis&amp;gt; ZADD myzset 0 foo 0 zap 0 zip 0 ALPHA 0 alfa &lt;code&gt;(integer) 5&lt;/code&gt; redis&amp;gt; ZRANGE myzset 0-1 &lt;code&gt;1) &quot;ALPHA&quot; 2) &quot;aaaa&quot; 3) &quot;alpha&quot; 4) &quot;b&quot; 5) &quot;c&quot; 6) &quot;d&quot; 7) &quot;e&quot; 8) &quot;foo&quot; 9) &quot;zap&quot; 10) &quot;zip&quot;&lt;/code&gt; redis&amp;gt; ZREMRANGEBYLEX myzset [alpha [ omega &lt;code&gt;(integer) 6&lt;/code&gt; redis&amp;gt; ZRANGE myzset 0 -1 &lt;code&gt;1) &quot;ALPHA&quot; 2) &quot;aaaa&quot; 3) &quot;zap&quot; 4) &quot;zip&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="701e38261e9de337e28f77c9e0e41981e74d5b6f" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 1 &quot;uno&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot; 3 &quot;three&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; ZRANGE myzset 0 -1 WITHSCORES&lt;code&gt;1) &quot;one&quot;
2) &quot;1&quot;
3) &quot;uno&quot;
4) &quot;1&quot;
5) &quot;two&quot;
6) &quot;2&quot;
7) &quot;three&quot;
8) &quot;3&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; 3 &quot;tres&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; ZRANGE myzset 0 -1 SIN PUNTOS &lt;code&gt;1) &quot;one&quot; 2) &quot;1&quot; 3) &quot;uno&quot; 4) &quot;1&quot; 5) &quot;two&quot; 6) &quot;2&quot; 7) &quot;three&quot; 8) &quot;3&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f6200b04b9836c8b0a344680d7c0061a0c64fef" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZCOUNT myzset -inf +inf&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; ZCOUNT myzset (1 3&lt;code&gt;(integer) 2&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZCOUNT myzset -inf + inf &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; ZCOUNT myzset (1 3 &lt;code&gt;(integer) 2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4413c8a1370c55d8e5ac627d43987347642ac493" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZPOPMAX myzset&lt;code&gt;1) &quot;3&quot;
2) &quot;three&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZPOPMAX myzset &lt;code&gt;1) &quot;3&quot; 2) &quot;three&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e658803fffff59eac37a7d43825508f41181db14" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZPOPMIN myzset&lt;code&gt;1) &quot;1&quot;
2) &quot;one&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZPOPMIN myzset &lt;code&gt;1) &quot;1&quot; 2) &quot;one&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2835b61bc71bc5ff92f54502dd803027caf1383d" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZRANGE myzset 0 -1&lt;code&gt;1) &quot;one&quot;
2) &quot;two&quot;
3) &quot;three&quot;&lt;/code&gt;redis&amp;gt; ZRANGE myzset 2 3&lt;code&gt;1) &quot;three&quot;&lt;/code&gt;redis&amp;gt; ZRANGE myzset -2 -1&lt;code&gt;1) &quot;two&quot;
2) &quot;three&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZRANGE myzset 0-1 &lt;code&gt;1) &quot;one&quot; 2) &quot;two&quot; 3) &quot;three&quot;&lt;/code&gt; redis&amp;gt; ZRANGE myzset 2 3 &lt;code&gt;1) &quot;three&quot;&lt;/code&gt; redis&amp;gt; ZRANGE myzset -2 -1 &lt;code&gt;1) &quot;two&quot; 2) &quot;three&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe3753a6e5886e3f509181dd470503dd7952dc0c" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZRANGEBYSCORE myzset -inf +inf&lt;code&gt;1) &quot;one&quot;
2) &quot;two&quot;
3) &quot;three&quot;&lt;/code&gt;redis&amp;gt; ZRANGEBYSCORE myzset 1 2&lt;code&gt;1) &quot;one&quot;
2) &quot;two&quot;&lt;/code&gt;redis&amp;gt; ZRANGEBYSCORE myzset (1 2&lt;code&gt;1) &quot;two&quot;&lt;/code&gt;redis&amp;gt; ZRANGEBYSCORE myzset (1 (2&lt;code&gt;(empty list or set)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZRANGEBYSCORE myzset -inf + inf &lt;code&gt;1) &quot;one&quot; 2) &quot;two&quot; 3) &quot;three&quot;&lt;/code&gt; redis&amp;gt; ZRANGEBYSCORE myzset 1 2 &lt;code&gt;1) &quot;one&quot; 2) &quot;two&quot;&lt;/code&gt; redis&amp;gt; ZRANGEBYSCORE myzset (1 2 &lt;code&gt;1) &quot;two&quot;&lt;/code&gt; redis&amp;gt; ZRANGEBYSCORE myzset (1 (2 &lt;code&gt;(empty list or set)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b24b486ea295edf27d1ece3aa5e2b4112185093" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZRANK myzset &quot;three&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; ZRANK myzset &quot;four&quot;&lt;code&gt;(nil)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZRANK myzset &quot;tres&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; ZRANK myzset &quot;cuatro&quot; &lt;code&gt;(nil)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc71dd63d1a93ef68a53263d7ecc122e22bbbd2d" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZREM myzset &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZRANGE myzset 0 -1 WITHSCORES&lt;code&gt;1) &quot;one&quot;
2) &quot;1&quot;
3) &quot;three&quot;
4) &quot;3&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZREM myzset &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZRANGE myzset 0 -1 SIN PUNTOS &lt;code&gt;1) &quot;one&quot; 2) &quot;1&quot; 3) &quot;three&quot; 4) &quot;3&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8c20110716c0d25f411d6aa650b90b9cbd6ff79" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZREMRANGEBYRANK myzset 0 1&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; ZRANGE myzset 0 -1 WITHSCORES&lt;code&gt;1) &quot;three&quot;
2) &quot;3&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZREMRANGEBYRANK myzset 0 1 &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; ZRANGE myzset 0 -1 SIN PUNTOS &lt;code&gt;1) &quot;three&quot; 2) &quot;3&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe1b277e0b51f66f5ca31d67ea0f09bad5ce0d1b" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZREMRANGEBYSCORE myzset -inf (2&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZRANGE myzset 0 -1 WITHSCORES&lt;code&gt;1) &quot;two&quot;
2) &quot;2&quot;
3) &quot;three&quot;
4) &quot;3&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZREMRANGEBYSCORE myzset -inf (2 &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZRANGE myzset 0 -1 SIN PUNTOS &lt;code&gt;1) &quot;two&quot; 2) &quot;2&quot; 3) &quot;three&quot; 4) &quot;3&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="362c7cb7dcbde7f35a7a9571b7b6ef3bcfbc4787" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZREVRANGE myzset 0 -1&lt;code&gt;1) &quot;three&quot;
2) &quot;two&quot;
3) &quot;one&quot;&lt;/code&gt;redis&amp;gt; ZREVRANGE myzset 2 3&lt;code&gt;1) &quot;one&quot;&lt;/code&gt;redis&amp;gt; ZREVRANGE myzset -2 -1&lt;code&gt;1) &quot;two&quot;
2) &quot;one&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZREVRANGE myzset 0-1 &lt;code&gt;1) &quot;three&quot; 2) &quot;two&quot; 3) &quot;one&quot;&lt;/code&gt; redis&amp;gt; ZREVRANGE myzset 2 3 &lt;code&gt;1) &quot;one&quot;&lt;/code&gt; redis&amp;gt; ZREVRANGE myzset -2 -1 &lt;code&gt;1) &quot;two&quot; 2) &quot;one&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="647bdb4460fcdbc71bb708e0a14f86ad25072022" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZREVRANGEBYSCORE myzset +inf -inf&lt;code&gt;1) &quot;three&quot;
2) &quot;two&quot;
3) &quot;one&quot;&lt;/code&gt;redis&amp;gt; ZREVRANGEBYSCORE myzset 2 1&lt;code&gt;1) &quot;two&quot;
2) &quot;one&quot;&lt;/code&gt;redis&amp;gt; ZREVRANGEBYSCORE myzset 2 (1&lt;code&gt;1) &quot;two&quot;&lt;/code&gt;redis&amp;gt; ZREVRANGEBYSCORE myzset (2 (1&lt;code&gt;(empty list or set)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZREVRANGEBYSCORE myzset + inf -inf &lt;code&gt;1) &quot;three&quot; 2) &quot;two&quot; 3) &quot;one&quot;&lt;/code&gt; redis&amp;gt; ZREVRANGEBYSCORE myzset 2 1 &lt;code&gt;1) &quot;two&quot; 2) &quot;one&quot;&lt;/code&gt; redis&amp;gt; ZREVRANGEBYSCORE myzset 2 (1 &lt;code&gt;1) &quot;two&quot;&lt;/code&gt; redis&amp;gt; ZREVRANGEBYSCORE myzset (2 (1 &lt;code&gt;(empty list or set)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8418f54d94ff02a22dae975a40bd1ca49b2708b2" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZREVRANK myzset &quot;one&quot;&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; ZREVRANK myzset &quot;four&quot;&lt;code&gt;(nil)&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZREVRANK myzset &quot;uno&quot; &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; ZREVRANK myzset &quot;cuatro&quot; &lt;code&gt;(nil)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b5420e3faf4bd7f23d0b57f9b3e38c53326b605" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZCARD myzset&lt;code&gt;(integer) 2&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZCARD myzset &lt;code&gt;(integer) 2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cfb3794f028916a550fe5dc59beb6b13896b00cc" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD myzset 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZINCRBY myzset 2 &quot;one&quot;&lt;code&gt;&quot;3&quot;&lt;/code&gt;redis&amp;gt; ZRANGE myzset 0 -1 WITHSCORES&lt;code&gt;1) &quot;two&quot;
2) &quot;2&quot;
3) &quot;one&quot;
4) &quot;3&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD myzset 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZINCRBY myzset 2 &quot;uno&quot; &lt;code&gt;&quot;3&quot;&lt;/code&gt; redis&amp;gt; ZRANGE myzset 0 -1 SIN PUNTOS &lt;code&gt;1) &quot;two&quot; 2) &quot;2&quot; 3) &quot;one&quot; 4) &quot;3&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4110310886b0d43ff9cc879a1c8b9fd27210c655" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD myzset 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZSCORE myzset &quot;one&quot;&lt;code&gt;&quot;1&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD myzset 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZSCORE myzset &quot;uno&quot; &lt;code&gt;&quot;1&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24b1d505a22963c8609d0c494e1b67f80d864acb" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD zset1 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD zset1 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD zset2 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD zset2 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD zset2 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3&lt;code&gt;(integer) 2&lt;/code&gt;redis&amp;gt; ZRANGE out 0 -1 WITHSCORES&lt;code&gt;1) &quot;one&quot;
2) &quot;5&quot;
3) &quot;two&quot;
4) &quot;10&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD zset1 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD zset1 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD zset2 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD zset2 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD zset2 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3 &lt;code&gt;(integer) 2&lt;/code&gt; redis&amp;gt; ZRANGE out 0 -1 WITHSCORES &lt;code&gt;1) &quot;one&quot; 2) &quot;5&quot; 3) &quot;two&quot; 4) &quot;10&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca8c2e9c8c47d51e49d61fe2c2f11f4ca63b9120" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZADD zset1 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD zset1 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD zset2 1 &quot;one&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD zset2 2 &quot;two&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZADD zset2 3 &quot;three&quot;&lt;code&gt;(integer) 1&lt;/code&gt;redis&amp;gt; ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3&lt;code&gt;(integer) 3&lt;/code&gt;redis&amp;gt; ZRANGE out 0 -1 WITHSCORES&lt;code&gt;1) &quot;one&quot;
2) &quot;5&quot;
3) &quot;three&quot;
4) &quot;9&quot;
5) &quot;two&quot;
6) &quot;10&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZADD zset1 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD zset1 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD zset2 1 &quot;uno&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD zset2 2 &quot;dos&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZADD zset2 3 &quot;tres&quot; &lt;code&gt;(integer) 1&lt;/code&gt; redis&amp;gt; ZUNIONSTORE out 2 zset1 zset2 WEIGHTS 2 3 &lt;code&gt;(integer) 3&lt;/code&gt; redis&amp;gt; ZRANGE out 0 -1 WITHSCORES &lt;code&gt;1) &quot;one&quot; 2) &quot;5&quot; 3) &quot;three&quot; 4) &quot;9&quot; 5) &quot;two&quot; 6) &quot;10&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a243af7d4791e5aee02c100f810fbfe9cca85e8d" translate="yes" xml:space="preserve">
          <source>redis&amp;gt; ZRANGE myzset 0 1 WITHSCORES&lt;code&gt;1) &quot;one&quot;
2) &quot;1&quot;
3) &quot;two&quot;
4) &quot;2&quot;&lt;/code&gt;</source>
          <target state="translated">redis&amp;gt; ZRANGE myzset 0 1 SIN PUNTUACIONES &lt;code&gt;1) &quot;one&quot; 2) &quot;1&quot; 3) &quot;two&quot; 4) &quot;2&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04a26d6f4aab9bc632ef3b0b244135354c76f93c" translate="yes" xml:space="preserve">
          <source>rename</source>
          <target state="translated">rename</target>
        </trans-unit>
        <trans-unit id="0a3381001ee727ea2c7e03268eda67ee92327011" translate="yes" xml:space="preserve">
          <source>renamenx</source>
          <target state="translated">renamenx</target>
        </trans-unit>
        <trans-unit id="4aa4f40d13aa2f1d2c2004bce6b401a561019bb3" translate="yes" xml:space="preserve">
          <source>replicaof</source>
          <target state="translated">replicaof</target>
        </trans-unit>
        <trans-unit id="e08e84916fb42ae1b61b75eb6fccf8a6eb98045e" translate="yes" xml:space="preserve">
          <source>restore</source>
          <target state="translated">restore</target>
        </trans-unit>
        <trans-unit id="8dca46428d005a2f4c2e039fb250964d6139a8b2" translate="yes" xml:space="preserve">
          <source>role</source>
          <target state="translated">role</target>
        </trans-unit>
        <trans-unit id="2e2150107692512f7a1d8703bd9368d6c9448503" translate="yes" xml:space="preserve">
          <source>rpop</source>
          <target state="translated">rpop</target>
        </trans-unit>
        <trans-unit id="fe2610c1688c2330ebd6b91861fd4eab93c1d392" translate="yes" xml:space="preserve">
          <source>rpoplpush</source>
          <target state="translated">rpoplpush</target>
        </trans-unit>
        <trans-unit id="728495c88661a13dbac017f8d0b278ab6c2ef895" translate="yes" xml:space="preserve">
          <source>rpush</source>
          <target state="translated">rpush</target>
        </trans-unit>
        <trans-unit id="f213c1161e49868fea511099a0d457611e07e47f" translate="yes" xml:space="preserve">
          <source>rpushx</source>
          <target state="translated">rpushx</target>
        </trans-unit>
        <trans-unit id="5e1e922c39d8ee3b603194f5215d7614e68dbff4" translate="yes" xml:space="preserve">
          <source>sadd</source>
          <target state="translated">sadd</target>
        </trans-unit>
        <trans-unit id="13a4a11319d31c1b323d5774f44240a9ffc984d0" translate="yes" xml:space="preserve">
          <source>save</source>
          <target state="translated">save</target>
        </trans-unit>
        <trans-unit id="ffa9c24c6823e27f40d9a2965a5e88da185579c1" translate="yes" xml:space="preserve">
          <source>scan</source>
          <target state="translated">scan</target>
        </trans-unit>
        <trans-unit id="97d85d068084cf5681ec00e34fce06470c9c0a16" translate="yes" xml:space="preserve">
          <source>scard</source>
          <target state="translated">scard</target>
        </trans-unit>
        <trans-unit id="bed520854d572c6017bb1c1ac0349104d3e46540" translate="yes" xml:space="preserve">
          <source>script debug</source>
          <target state="translated">depuración de guiones</target>
        </trans-unit>
        <trans-unit id="8d28fe47db916649f723154ffb78cbb93c1e615b" translate="yes" xml:space="preserve">
          <source>script exists</source>
          <target state="translated">El guión existe</target>
        </trans-unit>
        <trans-unit id="8d2a6455adaab38dd7b4a7f7cda46f5ab2aea4f5" translate="yes" xml:space="preserve">
          <source>script flush</source>
          <target state="translated">la limpieza de la escritura.</target>
        </trans-unit>
        <trans-unit id="cb64954b2aaa15a2020efbbb8944f2a9298e11b2" translate="yes" xml:space="preserve">
          <source>script kill</source>
          <target state="translated">script kill</target>
        </trans-unit>
        <trans-unit id="d83ef9ed89ffef946e57319e249afd8ab1a9c51b" translate="yes" xml:space="preserve">
          <source>script load</source>
          <target state="translated">carga de la secuencia de comandos</target>
        </trans-unit>
        <trans-unit id="5bf22606441635632564b8d0ff6b08f48998dab4" translate="yes" xml:space="preserve">
          <source>sdiff</source>
          <target state="translated">sdiff</target>
        </trans-unit>
        <trans-unit id="2073214603f420494c2b3af338e8686b2913cb9b" translate="yes" xml:space="preserve">
          <source>sdiffstore</source>
          <target state="translated">sdiffstore</target>
        </trans-unit>
        <trans-unit id="81448fe273247b533b9f018e96c158cab7901247" translate="yes" xml:space="preserve">
          <source>select</source>
          <target state="translated">select</target>
        </trans-unit>
        <trans-unit id="65c10dc3549fe07424148a8a4790a3341ecbc253" translate="yes" xml:space="preserve">
          <source>set</source>
          <target state="translated">set</target>
        </trans-unit>
        <trans-unit id="789b98203669a2fd6bb85bb22cf60b50fac4a135" translate="yes" xml:space="preserve">
          <source>setbit</source>
          <target state="translated">setbit</target>
        </trans-unit>
        <trans-unit id="f7584136460d63f661af1310a703574f6ab99c93" translate="yes" xml:space="preserve">
          <source>setex</source>
          <target state="translated">setex</target>
        </trans-unit>
        <trans-unit id="ee01e92a5f4c3880ed9f9f8e4bad9345328270c7" translate="yes" xml:space="preserve">
          <source>setnx</source>
          <target state="translated">setnx</target>
        </trans-unit>
        <trans-unit id="1d1da9a6ed4202931e81ab29f85ae5add0aff30b" translate="yes" xml:space="preserve">
          <source>setrange</source>
          <target state="translated">setrange</target>
        </trans-unit>
        <trans-unit id="53669f193b2174641c72654b5c3e5b67950334ae" translate="yes" xml:space="preserve">
          <source>shutdown</source>
          <target state="translated">shutdown</target>
        </trans-unit>
        <trans-unit id="e7f9e982bff1f9e456e4e092cfa95629a3d7da50" translate="yes" xml:space="preserve">
          <source>sinter</source>
          <target state="translated">sinter</target>
        </trans-unit>
        <trans-unit id="fd971667f5b9edaf0221039d3684ca34cf123145" translate="yes" xml:space="preserve">
          <source>sinterstore</source>
          <target state="translated">sinterstore</target>
        </trans-unit>
        <trans-unit id="3b075df6244376761988cf73d2ed735ee23246f8" translate="yes" xml:space="preserve">
          <source>sismember</source>
          <target state="translated">sismember</target>
        </trans-unit>
        <trans-unit id="9a96e223690b2a08504cf0ff9f2963af3d99a856" translate="yes" xml:space="preserve">
          <source>slaveof</source>
          <target state="translated">slaveof</target>
        </trans-unit>
        <trans-unit id="70102a99861930f02362a194e933ca1092cce0ba" translate="yes" xml:space="preserve">
          <source>slowlog</source>
          <target state="translated">slowlog</target>
        </trans-unit>
        <trans-unit id="ffb91ef78a5f826d7ef42ab85272dddc69ae36d4" translate="yes" xml:space="preserve">
          <source>smembers</source>
          <target state="translated">smembers</target>
        </trans-unit>
        <trans-unit id="21b89da60f9458244068c8f6272736ab52bd7f4a" translate="yes" xml:space="preserve">
          <source>smove</source>
          <target state="translated">smove</target>
        </trans-unit>
        <trans-unit id="98c4b8f6e2d770a0f2b54233669d65ff6eddc472" translate="yes" xml:space="preserve">
          <source>sort</source>
          <target state="translated">sort</target>
        </trans-unit>
        <trans-unit id="33f1a7060bcef3c55dda13ba08815fa832fe481a" translate="yes" xml:space="preserve">
          <source>spop</source>
          <target state="translated">spop</target>
        </trans-unit>
        <trans-unit id="33813dbb5a8c8aae01ab68d81ac2fd9e1302cad9" translate="yes" xml:space="preserve">
          <source>srandmember</source>
          <target state="translated">srandmember</target>
        </trans-unit>
        <trans-unit id="32fd72239acefb3982116bef7b1d1aa6ffa6f08f" translate="yes" xml:space="preserve">
          <source>srem</source>
          <target state="translated">srem</target>
        </trans-unit>
        <trans-unit id="75619e4294ea9c6c059b5ef5e6be5f457f10fffb" translate="yes" xml:space="preserve">
          <source>sscan</source>
          <target state="translated">sscan</target>
        </trans-unit>
        <trans-unit id="3fd48287b529384a966df6444259424207d1e92c" translate="yes" xml:space="preserve">
          <source>step count for locating repeating keys</source>
          <target state="translated">cuenta de pasos para localizar las teclas de repetición</target>
        </trans-unit>
        <trans-unit id="6c19df52f4536474beeb594b4c186a34750bfbba" translate="yes" xml:space="preserve">
          <source>strlen</source>
          <target state="translated">strlen</target>
        </trans-unit>
        <trans-unit id="d118e5a3cc15b182d1286373a60c787e58d3166f" translate="yes" xml:space="preserve">
          <source>struct</source>
          <target state="translated">struct</target>
        </trans-unit>
        <trans-unit id="8f42e46f1655c0b42efbc3b0131b2265b3e8faf1" translate="yes" xml:space="preserve">
          <source>struct is a library for packing/unpacking structures within Lua.</source>
          <target state="translated">La estructura es una biblioteca para empaquetar/desempaquetar estructuras dentro de Lua.</target>
        </trans-unit>
        <trans-unit id="b3b4058b20bb871664fe47ba281947938ff04602" translate="yes" xml:space="preserve">
          <source>struct, CJSON and cmsgpack are external libraries, all the other libraries are standard Lua libraries.</source>
          <target state="translated">struct,CJSON y cmsgpack son bibliotecas externas,todas las demás son bibliotecas estándar de Lua.</target>
        </trans-unit>
        <trans-unit id="4c91330c57b1f26f16a92bbcb0653bc2a60a5b88" translate="yes" xml:space="preserve">
          <source>subscribe</source>
          <target state="translated">subscribe</target>
        </trans-unit>
        <trans-unit id="1da3a67d5909f5362da54045b8c32bbbe665177b" translate="yes" xml:space="preserve">
          <source>sunion</source>
          <target state="translated">sunion</target>
        </trans-unit>
        <trans-unit id="9daa335c5dd5dc0f78f78ceeabd4660c4d5cbdb8" translate="yes" xml:space="preserve">
          <source>sunionstore</source>
          <target state="translated">sunionstore</target>
        </trans-unit>
        <trans-unit id="33860ed04b31175b539364820efafd70870afcbf" translate="yes" xml:space="preserve">
          <source>swapdb</source>
          <target state="translated">swapdb</target>
        </trans-unit>
        <trans-unit id="6b387ced110858dcbcda36edb044dc18f91a0894" translate="yes" xml:space="preserve">
          <source>sync</source>
          <target state="translated">sync</target>
        </trans-unit>
        <trans-unit id="3039438ea7284451f5dd37a8079397a483dac870" translate="yes" xml:space="preserve">
          <source>that means, save after 900 seconds if there is at least 1 change to the dataset, and after 300 seconds if there are at least 10 changes to the dataset, should be set using &lt;code&gt;CONFIG SET SAVE &quot;900 1 300 10&quot;&lt;/code&gt;.</source>
          <target state="translated">es decir, guardar despu&amp;eacute;s de 900 segundos si hay al menos 1 cambio en el conjunto de datos, y despu&amp;eacute;s de 300 segundos si hay al menos 10 cambios en el conjunto de datos, debe establecerse usando &lt;code&gt;CONFIG SET SAVE &quot;900 1 300 10&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcf90dd90b25f395be97e38fa75002e16f185d17" translate="yes" xml:space="preserve">
          <source>that means, save after 900 seconds if there is at least 1 change to the dataset, and after 300 seconds if there are at least 10 changes to the dataset, will be reported by &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; as &quot;900 1 300 10&quot;.</source>
          <target state="translated">es decir, guardar despu&amp;eacute;s de 900 segundos si hay al menos 1 cambio en el conjunto de datos, y despu&amp;eacute;s de 300 segundos si hay al menos 10 cambios en el conjunto de datos, &lt;a href=&quot;config-get&quot;&gt;CONFIG GET lo&lt;/a&gt; informar&amp;aacute; como &quot;900 1 300 10&quot;.</target>
        </trans-unit>
        <trans-unit id="b0c386a4240bc38d9a30258724de6b30631d3012" translate="yes" xml:space="preserve">
          <source>the new score of &lt;code&gt;member&lt;/code&gt; (a double precision floating point number), represented as string.</source>
          <target state="translated">la nueva puntuaci&amp;oacute;n de &lt;code&gt;member&lt;/code&gt; (un n&amp;uacute;mero de coma flotante de doble precisi&amp;oacute;n), representada como una cadena.</target>
        </trans-unit>
        <trans-unit id="714eea0f4c980736bde0065fe73f573487f08e3a" translate="yes" xml:space="preserve">
          <source>time</source>
          <target state="translated">time</target>
        </trans-unit>
        <trans-unit id="f4d1f0193879cba82d65c5752c4ba5cbb43a7188" translate="yes" xml:space="preserve">
          <source>touch</source>
          <target state="translated">touch</target>
        </trans-unit>
        <trans-unit id="2e33266830e76602baef9cc3b70445f3e0fe8b3f" translate="yes" xml:space="preserve">
          <source>ttl</source>
          <target state="translated">ttl</target>
        </trans-unit>
        <trans-unit id="d0a3e7f81a9885e99049d1cae0336d269d5e47a9" translate="yes" xml:space="preserve">
          <source>type</source>
          <target state="translated">type</target>
        </trans-unit>
        <trans-unit id="5c36d76b02d96d1c5567c6fe9fec05bb7d5fb0c1" translate="yes" xml:space="preserve">
          <source>unix time in seconds.</source>
          <target state="translated">tiempo de unix en segundos.</target>
        </trans-unit>
        <trans-unit id="7b91025887687e8951f32135d89cf33a54553e45" translate="yes" xml:space="preserve">
          <source>unlink</source>
          <target state="translated">unlink</target>
        </trans-unit>
        <trans-unit id="fa64642003487da379238275904d5b1add52aba4" translate="yes" xml:space="preserve">
          <source>unsubscribe</source>
          <target state="translated">unsubscribe</target>
        </trans-unit>
        <trans-unit id="f6f282e9efe8a40065c955ff13301becb96131be" translate="yes" xml:space="preserve">
          <source>unwatch</source>
          <target state="translated">unwatch</target>
        </trans-unit>
        <trans-unit id="daaad336276d15594d0e765f96c17cd746bf4971" translate="yes" xml:space="preserve">
          <source>wait</source>
          <target state="translated">wait</target>
        </trans-unit>
        <trans-unit id="292b0901993f7e9d9a0d9b80542f9e59505ba5be" translate="yes" xml:space="preserve">
          <source>watch</source>
          <target state="translated">watch</target>
        </trans-unit>
        <trans-unit id="4253882055f98c453c8ee12d3cb8c5838897b21e" translate="yes" xml:space="preserve">
          <source>xack</source>
          <target state="translated">xack</target>
        </trans-unit>
        <trans-unit id="2931786b110798f58f36fa6b845f13cf55b6d3b5" translate="yes" xml:space="preserve">
          <source>xadd</source>
          <target state="translated">xadd</target>
        </trans-unit>
        <trans-unit id="1e89c5ff91a48f2affffe83da0d30a19bbfa8c6b" translate="yes" xml:space="preserve">
          <source>xclaim</source>
          <target state="translated">xclaim</target>
        </trans-unit>
        <trans-unit id="0b9501a716533c912b9ba332b64abc480410e75d" translate="yes" xml:space="preserve">
          <source>xdel</source>
          <target state="translated">xdel</target>
        </trans-unit>
        <trans-unit id="155c4b396686c8f326bbdccd2ff2791e3b42de46" translate="yes" xml:space="preserve">
          <source>xgroup</source>
          <target state="translated">xgroup</target>
        </trans-unit>
        <trans-unit id="38cd635ccdae095417578ecb60d0dab482d2f671" translate="yes" xml:space="preserve">
          <source>xinfo</source>
          <target state="translated">xinfo</target>
        </trans-unit>
        <trans-unit id="f32b97ff9b948e52cfb974eb02c93a5793ab8cf5" translate="yes" xml:space="preserve">
          <source>xlen</source>
          <target state="translated">xlen</target>
        </trans-unit>
        <trans-unit id="ff72036772c52009350591b848d7c65b667831c2" translate="yes" xml:space="preserve">
          <source>xpending</source>
          <target state="translated">xpending</target>
        </trans-unit>
        <trans-unit id="42813ada5f3e6b9da843c99bba38c8de775d1684" translate="yes" xml:space="preserve">
          <source>xrange</source>
          <target state="translated">xrange</target>
        </trans-unit>
        <trans-unit id="05a5cc7defe678ad32dee9f10871f2abb06c006e" translate="yes" xml:space="preserve">
          <source>xread</source>
          <target state="translated">xread</target>
        </trans-unit>
        <trans-unit id="f9d49063ed9d3e143941358daa98e237eb68dc9d" translate="yes" xml:space="preserve">
          <source>xreadgroup</source>
          <target state="translated">xreadgroup</target>
        </trans-unit>
        <trans-unit id="4551eeab5874f41f194d9573e3f2819df39841a1" translate="yes" xml:space="preserve">
          <source>xrevrange</source>
          <target state="translated">xrevrange</target>
        </trans-unit>
        <trans-unit id="b5a56af11259c9757a0bded2eb5e5bd6d7a163f6" translate="yes" xml:space="preserve">
          <source>xtrim</source>
          <target state="translated">xtrim</target>
        </trans-unit>
        <trans-unit id="efe207c7d10049f17ed67d799efa5cdc3f0d9533" translate="yes" xml:space="preserve">
          <source>zadd</source>
          <target state="translated">zadd</target>
        </trans-unit>
        <trans-unit id="eb2953441f104f4be4468568f332bd8bc94a4d06" translate="yes" xml:space="preserve">
          <source>zcard</source>
          <target state="translated">zcard</target>
        </trans-unit>
        <trans-unit id="94b39677045ff3149e5cf913962dfac515be9d35" translate="yes" xml:space="preserve">
          <source>zcount</source>
          <target state="translated">zcount</target>
        </trans-unit>
        <trans-unit id="23db2ba0a19faa444952f557396cde8368538808" translate="yes" xml:space="preserve">
          <source>zincrby</source>
          <target state="translated">zincrby</target>
        </trans-unit>
        <trans-unit id="8a50cee4017361f3186b3a40dffed064672c4e26" translate="yes" xml:space="preserve">
          <source>zinterstore</source>
          <target state="translated">zinterstore</target>
        </trans-unit>
        <trans-unit id="eeab294aaab0f1aaa588da75665acf2039a1f747" translate="yes" xml:space="preserve">
          <source>zlexcount</source>
          <target state="translated">zlexcount</target>
        </trans-unit>
        <trans-unit id="5f42857b00e83b564f2411e2424fa3a52ab69abf" translate="yes" xml:space="preserve">
          <source>zpopmax</source>
          <target state="translated">zpopmax</target>
        </trans-unit>
        <trans-unit id="b0bf6b20912c6a31fb3ac394cb911a61a2b6ebe9" translate="yes" xml:space="preserve">
          <source>zpopmin</source>
          <target state="translated">zpopmin</target>
        </trans-unit>
        <trans-unit id="9c0992d3de5d72545c2ae338bd60db69dc3d1acc" translate="yes" xml:space="preserve">
          <source>zrange</source>
          <target state="translated">zrange</target>
        </trans-unit>
        <trans-unit id="a63f4842d6c48483ada536f3b666880859a221dc" translate="yes" xml:space="preserve">
          <source>zrangebylex</source>
          <target state="translated">zrangebylex</target>
        </trans-unit>
        <trans-unit id="71fbfa2bd46d14bf4052bc684a293dc11ee9e6be" translate="yes" xml:space="preserve">
          <source>zrangebyscore</source>
          <target state="translated">zrangebyscore</target>
        </trans-unit>
        <trans-unit id="ee334862c1fd4cb175a839fcdef0a45901891689" translate="yes" xml:space="preserve">
          <source>zrank</source>
          <target state="translated">zrank</target>
        </trans-unit>
        <trans-unit id="6b2d900a03e16536dc6e64583cd49da143f1e03b" translate="yes" xml:space="preserve">
          <source>zrem</source>
          <target state="translated">zrem</target>
        </trans-unit>
        <trans-unit id="538b23fc004c2fce40b8ebe31dc627c218ed3d65" translate="yes" xml:space="preserve">
          <source>zremrangebylex</source>
          <target state="translated">zremrangebylex</target>
        </trans-unit>
        <trans-unit id="51cc6a6a37f2558d037b390949132005b2e76f74" translate="yes" xml:space="preserve">
          <source>zremrangebyrank</source>
          <target state="translated">zremrangebyrank</target>
        </trans-unit>
        <trans-unit id="862b6762f29b1735257f614dc46035871c886f45" translate="yes" xml:space="preserve">
          <source>zremrangebyscore</source>
          <target state="translated">zremrangebyscore</target>
        </trans-unit>
        <trans-unit id="cb0c27c8f1c6f98dba433c742758a1b94c998bf5" translate="yes" xml:space="preserve">
          <source>zrevrange</source>
          <target state="translated">zrevrange</target>
        </trans-unit>
        <trans-unit id="a36260f833ca29f6cd6df4c473ce1cbe1b1f0618" translate="yes" xml:space="preserve">
          <source>zrevrangebylex</source>
          <target state="translated">zrevrangebylex</target>
        </trans-unit>
        <trans-unit id="254d23f8fc4dc3f6dae6f2104b203fbe1634a5ab" translate="yes" xml:space="preserve">
          <source>zrevrangebyscore</source>
          <target state="translated">zrevrangebyscore</target>
        </trans-unit>
        <trans-unit id="9868d0a88f2542fa1d2ff72eb6b7b549d2ed08a5" translate="yes" xml:space="preserve">
          <source>zrevrank</source>
          <target state="translated">zrevrank</target>
        </trans-unit>
        <trans-unit id="340e8fb8b070acc7fd7333ec7aea99d0bd5d9a3d" translate="yes" xml:space="preserve">
          <source>zscan</source>
          <target state="translated">zscan</target>
        </trans-unit>
        <trans-unit id="2e2b919b76068f41528e1b3962e2d9f8b2cc8d35" translate="yes" xml:space="preserve">
          <source>zscore</source>
          <target state="translated">zscore</target>
        </trans-unit>
        <trans-unit id="0c0eb378a4b9253415c4fd6ea550625395ab0dcd" translate="yes" xml:space="preserve">
          <source>zunionstore</source>
          <target state="translated">zunionstore</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
