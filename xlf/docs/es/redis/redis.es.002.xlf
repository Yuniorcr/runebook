<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="75d00cd00e1f2b13a890f0d28b95cf6fbe73de9c" translate="yes" xml:space="preserve">
          <source>An error is returned for out of range indexes.</source>
          <target state="translated">Se devuelve un error para los índices fuera de rango.</target>
        </trans-unit>
        <trans-unit id="e1e52880ba8cd5516094695a791c7cb25bb9cf75" translate="yes" xml:space="preserve">
          <source>An error is returned if &lt;code&gt;source&lt;/code&gt; or &lt;code&gt;destination&lt;/code&gt; does not hold a set value.</source>
          <target state="translated">Se devuelve un error si la &lt;code&gt;source&lt;/code&gt; o el &lt;code&gt;destination&lt;/code&gt; no tienen un valor establecido.</target>
        </trans-unit>
        <trans-unit id="c6dddcbd9570408a2bf9a7b091594de5d13db0b1" translate="yes" xml:space="preserve">
          <source>An error is returned if there is already a background save running or if there is another non-background-save process running, specifically an in-progress AOF rewrite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f347bee22b5d2cb10d2901659685fcd72a034c77" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists and does not hold a sorted set.</source>
          <target state="translated">Se devuelve un error cuando la &lt;code&gt;key&lt;/code&gt; existe y no contiene un conjunto ordenado.</target>
        </trans-unit>
        <trans-unit id="e231fa35664a84f1e5009d81e7f6bba1d485eec3" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a list value.</source>
          <target state="translated">Se devuelve un error cuando la &lt;code&gt;key&lt;/code&gt; existe pero no contiene un valor de lista.</target>
        </trans-unit>
        <trans-unit id="6bdfaaedacc744e822937a491c0aa265faa0a3c9" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a sorted set.</source>
          <target state="translated">Se devuelve un error cuando la &lt;code&gt;key&lt;/code&gt; existe pero no contiene un conjunto ordenado.</target>
        </trans-unit>
        <trans-unit id="cafd7db432cc1bfe0eb095227c59268bb7b93c9e" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;seconds&lt;/code&gt; is invalid.</source>
          <target state="translated">Se devuelve un error cuando los &lt;code&gt;seconds&lt;/code&gt; no son v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="8e9136354e1045681dd2f7a86b9527fc481d91cd" translate="yes" xml:space="preserve">
          <source>An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a set.</source>
          <target state="translated">Se devuelve un error cuando el valor almacenado en la &lt;code&gt;key&lt;/code&gt; no es un conjunto.</target>
        </trans-unit>
        <trans-unit id="b4eb1a0965c235064ac8aba79722ddaff3491eef" translate="yes" xml:space="preserve">
          <source>An example of Sentinel output:</source>
          <target state="translated">Un ejemplo de la producción de Sentinel:</target>
        </trans-unit>
        <trans-unit id="e3a2b833146840fa4cd410d9b71d1f7b478f823c" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a master instance:</source>
          <target state="translated">Un ejemplo de salida cuando se llama a &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; en una instancia maestra:</target>
        </trans-unit>
        <trans-unit id="579d469e7cac2523515437d9b8d6112fe3d93c9e" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a replica instance:</source>
          <target state="translated">Un ejemplo de salida cuando se llama a &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; en una instancia de r&amp;eacute;plica:</target>
        </trans-unit>
        <trans-unit id="1d6f1c424d50ab94243fe38cbdfeabffd674d66c" translate="yes" xml:space="preserve">
          <source>An example of unlock script would be similar to the following:</source>
          <target state="translated">Un ejemplo de guión de desbloqueo sería similar al siguiente:</target>
        </trans-unit>
        <trans-unit id="89fe7da248c22605a4e15750b1f9beb107181168" translate="yes" xml:space="preserve">
          <source>An example sampling the temperature of a sensor using fixed-size strings (using a binary format is better in real implementations).</source>
          <target state="translated">Un ejemplo de muestreo de la temperatura de un sensor utilizando cadenas de tamaño fijo (el uso de un formato binario es mejor en las implementaciones reales).</target>
        </trans-unit>
        <trans-unit id="4eae947ad09e05cad458fca2075b30ae1b15869c" translate="yes" xml:space="preserve">
          <source>An interesting pattern using &lt;code&gt;SORT ... STORE&lt;/code&gt; consists in associating an &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; timeout to the resulting key so that in applications where the result of a &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; operation can be cached for some time. Other clients will use the cached list instead of calling &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; for every request. When the key will timeout, an updated version of the cache can be created by calling &lt;code&gt;SORT ... STORE&lt;/code&gt; again.</source>
          <target state="translated">Un patr&amp;oacute;n interesante usando &lt;code&gt;SORT ... STORE&lt;/code&gt; consiste en asociar un timeout &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; a la clave resultante para que en aplicaciones donde el resultado de una operaci&amp;oacute;n &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; pueda ser cacheado por alg&amp;uacute;n tiempo. Otros clientes usar&amp;aacute;n la lista en cach&amp;eacute; en lugar de llamar a &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; para cada solicitud. Cuando se agote el tiempo de espera de la clave, se puede crear una versi&amp;oacute;n actualizada de la cach&amp;eacute; llamando a &lt;code&gt;SORT ... STORE&lt;/code&gt; nuevamente.</target>
        </trans-unit>
        <trans-unit id="c296bdf9668142740fec726611d45d470138dafa" translate="yes" xml:space="preserve">
          <source>An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0. The following is an example of SCAN iteration:</source>
          <target state="translated">Una iteración comienza cuando el cursor se pone a 0,y termina cuando el cursor devuelto por el servidor es 0.El siguiente es un ejemplo de iteración de SCAN:</target>
        </trans-unit>
        <trans-unit id="060444849d7b2e77c482c80d4ddc007637e5e3e9" translate="yes" xml:space="preserve">
          <source>And so for until the iteration is complete and no result is returned. See the &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; page about iterating for more information.</source>
          <target state="translated">Y as&amp;iacute; hasta que se complete la iteraci&amp;oacute;n y no se devuelva ning&amp;uacute;n resultado. Consulte la p&amp;aacute;gina &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; sobre iteraci&amp;oacute;n para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="abbabebfac6efc7292e2eb1b2e18a22fb8f0b07b" translate="yes" xml:space="preserve">
          <source>And so forth.</source>
          <target state="translated">Y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="4c3a5cf2099eac6b70d3351f9f2b307f8576cbfe" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually this will allow to visit all the entries in the stream. Obviously, we can start the iteration from any ID, or even from a specific time, by providing a given incomplete start ID. Moreover, we can limit the iteration to a given ID or time, by providing an end ID or incomplete ID instead of &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">Etc&amp;eacute;tera. Eventualmente, esto permitir&amp;aacute; visitar todas las entradas en la secuencia. Obviamente, podemos iniciar la iteraci&amp;oacute;n desde cualquier ID, o incluso desde un momento espec&amp;iacute;fico, proporcionando un ID de inicio incompleto dado. Adem&amp;aacute;s, podemos limitar la iteraci&amp;oacute;n a un ID o tiempo determinado, proporcionando un ID final o un ID incompleto en lugar de &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd50a85c7e0471c36280c42d04f369b2283aaee5" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually, the call will not return any item, but just an empty array, then we know that there is nothing more to fetch from our stream (and we would have to retry the operation, hence this command also supports a blocking mode).</source>
          <target state="translated">Y así sucesivamente.Eventualmente,la llamada no devolverá ningún elemento,sino sólo una matriz vacía,entonces sabremos que no hay nada más que sacar de nuestro flujo (y tendríamos que volver a intentar la operación,por lo que este comando también soporta un modo de bloqueo).</target>
        </trans-unit>
        <trans-unit id="087d39ee1a0310d3323a4cfd02c6576b584cb468" translate="yes" xml:space="preserve">
          <source>Another example: if we imagine a cluster formed of the following four nodes called A, B, C and D, we may send just the following set of commands to A:</source>
          <target state="translated">Otro ejemplo:si imaginamos un cúmulo formado por los siguientes cuatro nodos llamados A,B,C y D,podemos enviar sólo el siguiente conjunto de comandos a A:</target>
        </trans-unit>
        <trans-unit id="852a8d39c81588746b082fd9f4167b5bb251bb69" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command with IDs greater than the one provided. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: messages delivered to it, but not yet acknowledged. Note that in this case, both &lt;code&gt;BLOCK&lt;/code&gt; and &lt;code&gt;NOACK&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0eff051adefea749add42d4d6cb2b879ab75ce" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: delivered to it, but not yet acknowledged.</source>
          <target state="translated">Cualquier otra identificaci&amp;oacute;n, es decir, 0 o cualquier otra identificaci&amp;oacute;n v&amp;aacute;lida o incompleta (solo la parte de tiempo de milisegundos), tendr&amp;aacute; el efecto de devolver las entradas que est&amp;aacute;n pendientes para el consumidor que env&amp;iacute;a el comando. Entonces, b&amp;aacute;sicamente, si el ID no es &lt;code&gt;&amp;gt;&lt;/code&gt; , entonces el comando simplemente permitir&amp;aacute; que el cliente acceda a sus entradas pendientes: entregado, pero a&amp;uacute;n no reconocido.</target>
        </trans-unit>
        <trans-unit id="bf48c58a252cd0f11f754a6235c3bf6580ab92b5" translate="yes" xml:space="preserve">
          <source>Anyway even assuming a single-instance locking primitive, starting with 2.6.12 it is possible to create a much simpler locking primitive, equivalent to the one discussed here, using the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to acquire the lock, and a simple Lua script to release the lock. The pattern is documented in the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command page.</source>
          <target state="translated">De todos modos, incluso asumiendo una primitiva de bloqueo de instancia &amp;uacute;nica, comenzando con 2.6.12 es posible crear una primitiva de bloqueo mucho m&amp;aacute;s simple, equivalente a la que se discuti&amp;oacute; aqu&amp;iacute;, usando el comando &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; para adquirir el bloqueo, y un script Lua simple para liberar el bloquear. El patr&amp;oacute;n est&amp;aacute; documentado en la p&amp;aacute;gina de comandos &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="274153f2cd2566cd42de1da9ffc1b6d3d2cf50ae" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; is similar to &lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt;.</source>
          <target state="translated">Aparte del orden inverso, &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; es similar a &lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dae9346322df90f8b168ba54317fbcb22d67c378" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX&lt;/a&gt; is similar to &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">Aparte del orden inverso, &lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX&lt;/a&gt; es similar a &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5c43ee3f0eb54ffe03d2d092f2d6166614a936e" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE&lt;/a&gt; is similar to &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">Aparte del orden inverso, &lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE&lt;/a&gt; es similar a &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5abab69f4dc0a66b2f4a79cd40ada74327713efb" translate="yes" xml:space="preserve">
          <source>Appendix: Redis expires</source>
          <target state="translated">Apéndice:Redis expira</target>
        </trans-unit>
        <trans-unit id="9ff199315ef371177323189f4cb9355c80a5471f" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value.</source>
          <target state="translated">Añade la entrada de la corriente especificada a la corriente en la tecla especificada.Si la clave no existe,como efecto secundario de la ejecución de este comando la clave se crea con un valor de flujo.</target>
        </trans-unit>
        <trans-unit id="32f650d6228cf15fb1f6755ed7de0b1329f744eb" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value. The creation of stream's key can be disabled with the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a442180dde4ebe00bdaaebef087550dde9ed275" translate="yes" xml:space="preserve">
          <source>As a side effect a pending message entry is created in the pending entries list (PEL) of the consumer group: it means the message was delivered to a given consumer, but it was not yet acknowledged via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;.</source>
          <target state="translated">Como efecto secundario, se crea una entrada de mensaje pendiente en la lista de entradas pendientes (PEL) del grupo de consumidores: significa que el mensaje se entreg&amp;oacute; a un consumidor determinado, pero a&amp;uacute;n no se reconoci&amp;oacute; a trav&amp;eacute;s de &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8d3a747f6516b67780fd78990e06b49b5087892" translate="yes" xml:space="preserve">
          <source>As a side effect of &lt;code&gt;A&lt;/code&gt; knowing and being known by all the other nodes, it will send gossip sections in the heartbeat packets that will allow each other node to create a link with each other one, forming a full mesh in a matter of seconds, even if the cluster is large.</source>
          <target state="translated">Como efecto secundario de que &lt;code&gt;A&lt;/code&gt; conozca y sea conocido por todos los dem&amp;aacute;s nodos, enviar&amp;aacute; secciones de chismes en los paquetes de latidos que permitir&amp;aacute;n a cada uno de los otros nodos crear un enlace entre s&amp;iacute;, formando una malla completa en cuesti&amp;oacute;n de segundos, incluso si el grupo es grande.</target>
        </trans-unit>
        <trans-unit id="90aa44b5c0b6d562f721575257b4845fb2c1994d" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, if a slot among the ones specified as argument is set as &lt;code&gt;importing&lt;/code&gt;, this state gets cleared once the node assigns the (previously unbound) slot to itself.</source>
          <target state="translated">Como efecto secundario de la ejecuci&amp;oacute;n del comando, si una ranura entre las especificadas como argumento se establece como de &lt;code&gt;importing&lt;/code&gt; , este estado se borra una vez que el nodo se asigna la ranura (anteriormente no vinculada) a s&amp;iacute; mismo.</target>
        </trans-unit>
        <trans-unit id="a31cef2ee08d5e8239d818737dfa96674f437698" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, the node may go into &lt;em&gt;down&lt;/em&gt; state because not all hash slots are covered.</source>
          <target state="translated">Como efecto secundario de la ejecuci&amp;oacute;n del comando, el nodo puede entrar en estado &lt;em&gt;inactivo&lt;/em&gt; porque no todas las ranuras hash est&amp;aacute;n cubiertas.</target>
        </trans-unit>
        <trans-unit id="fdfda2f0f0a65c5c9350447421bdbd24d0c16cd7" translate="yes" xml:space="preserve">
          <source>As a side effect of this command the HyperLogLog internals may be updated to reflect a different estimation of the number of unique items added so far (the cardinality of the set).</source>
          <target state="translated">Como efecto secundario de este comando,los internos del HyperLogLog pueden ser actualizados para reflejar una estimación diferente del número de elementos únicos añadidos hasta ahora (la cardinalidad del conjunto).</target>
        </trans-unit>
        <trans-unit id="e3b0ef422a5105dd7a168f1bd22deb9e931a8ad3" translate="yes" xml:space="preserve">
          <source>As already stated, calls to &lt;code&gt;redis.call()&lt;/code&gt; resulting in a Redis command error will stop the execution of the script and return an error, in a way that makes it obvious that the error was generated by a script:</source>
          <target state="translated">Como ya se dijo, las llamadas a &lt;code&gt;redis.call()&lt;/code&gt; resulten en un error de comando de Redis detendr&amp;aacute;n la ejecuci&amp;oacute;n del script y devolver&amp;aacute;n un error, de manera que sea obvio que el error fue generado por un script:</target>
        </trans-unit>
        <trans-unit id="09ac6956fbf7cebafd273a67f1e1e0cc18c9d7d7" translate="yes" xml:space="preserve">
          <source>As of Redis 4.0.0, HSET is variadic and allows for multiple &lt;code&gt;field&lt;/code&gt;/&lt;code&gt;value&lt;/code&gt; pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824fabdff9eac7426b269cefa6ab8cb7c6a7fa7e" translate="yes" xml:space="preserve">
          <source>As of v5.0, the optional &lt;code&gt;TYPE type&lt;/code&gt; subcommand can be used to filter the list by clients' type, where &lt;em&gt;type&lt;/em&gt; is one of &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;replica&lt;/code&gt; and &lt;code&gt;pubsub&lt;/code&gt;. Note that clients blocked into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; command are considered to belong to the &lt;code&gt;normal&lt;/code&gt; class.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 5.0, el subcomando de &lt;code&gt;TYPE type&lt;/code&gt; opcional se puede utilizar para filtrar la lista por tipo de cliente, donde el &lt;em&gt;tipo&lt;/em&gt; es uno de &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;replica&lt;/code&gt; y &lt;code&gt;pubsub&lt;/code&gt; . Tenga en cuenta que se considera que los clientes bloqueados en el comando &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; pertenecen a la clase &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7fd0e1ced5f80a8c1942174a609b55088d136aa" translate="yes" xml:space="preserve">
          <source>As of version 6.0 you can use this option to ask &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to only return objects that match a given &lt;code&gt;type&lt;/code&gt;, allowing you to iterate through the database looking for keys of a specific type. The &lt;strong&gt;TYPE&lt;/strong&gt; option is only available on the whole-database &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, not &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; or &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f512cd2f467fc007a16339b78f3f8bd4aa4ddc3" translate="yes" xml:space="preserve">
          <source>As per Redis 4.0.0, HMSET is considered deprecated. Please use &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e2ff1f75cd0a86ae75552c78ee5cbb2c5d2636" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2, GETSET is considered deprecated. Please use &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; parameter in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca69203d6944d9aedfa83b1745a14df6f143d34" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2.0, BRPOPLPUSH is considered deprecated. Please use &lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50625700b094276571780430ad92d3906e72fb6e" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2.0, RPOPLPUSH is considered deprecated. Please use &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; in new code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf598b1b6e40341f8808136a0a46e1f4d5d8d97" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, &lt;em&gt;somekey&lt;/em&gt; is excluded, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20dcd69a8805b2228dfb60a21cf7d97acd5f67c" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="translated">Como puede ver, 3.333 se convierte en 3, y la cadena de &lt;em&gt;comp&amp;aacute;s&lt;/em&gt; nunca se devuelve, ya que antes hay un nulo.</target>
        </trans-unit>
        <trans-unit id="ec8e8f706055fbdba6360cfb1b417dae6427300e" translate="yes" xml:space="preserve">
          <source>As you can see &lt;strong&gt;NOT&lt;/strong&gt; is special as it only takes an input key, because it performs inversion of bits so it only makes sense as an unary operator.</source>
          <target state="translated">Como puede ver, &lt;strong&gt;NOT&lt;/strong&gt; es especial ya que solo requiere una clave de entrada, ya que realiza la inversi&amp;oacute;n de bits, por lo que solo tiene sentido como operador unario.</target>
        </trans-unit>
        <trans-unit id="a732d9b394f216e3ee5501e430e6cf1a3865a69a" translate="yes" xml:space="preserve">
          <source>As you can see in this way removing a node is fragile, we need to send &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; commands to all the nodes ASAP hoping there are no gossip sections processing in the meantime. Because of this problem the command implements a ban-list with an expire time for each entry.</source>
          <target state="translated">Como puede ver de esta manera, eliminar un nodo es fr&amp;aacute;gil, necesitamos enviar comandos &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; a todos los nodos lo antes posible con la esperanza de que no se procesen secciones de chismes mientras tanto. Debido a este problema, el comando implementa una lista de prohibici&amp;oacute;n con un tiempo de vencimiento para cada entrada.</target>
        </trans-unit>
        <trans-unit id="aeec0e9426a0a0a54fbf363e2b26ff697ce52419" translate="yes" xml:space="preserve">
          <source>As you can see most of the calls returned zero elements, but the last call where a COUNT of 1000 was used in order to force the command to do more scanning for that iteration.</source>
          <target state="translated">Como pueden ver,la mayoría de las llamadas devolvieron cero elementos,pero la última llamada en la que se usó una cuenta de 1000 para forzar al comando a hacer más exploraciones para esa iteración.</target>
        </trans-unit>
        <trans-unit id="f1947772b8e632184927e0616393e7edcce03ca1" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;strong&gt;SCAN return value&lt;/strong&gt; is an array of two values: the first value is the new cursor to use in the next call, the second value is an array of elements.</source>
          <target state="translated">Como puede ver, el &lt;strong&gt;valor de retorno de SCAN&lt;/strong&gt; es una matriz de dos valores: el primer valor es el nuevo cursor que se usar&amp;aacute; en la siguiente llamada, el segundo valor es una matriz de elementos.</target>
        </trans-unit>
        <trans-unit id="53b31465005a9966a63fe8728e23f94c240abdb1" translate="yes" xml:space="preserve">
          <source>Ask the server to close the connection. The connection is closed as soon as all pending replies have been written to the client.</source>
          <target state="translated">Pídele al servidor que cierre la conexión.La conexión se cerrará tan pronto como todas las respuestas pendientes hayan sido escritas al cliente.</target>
        </trans-unit>
        <trans-unit id="14070ea7474a205db9d3fb81cc4d13bc90f1f1d9" translate="yes" xml:space="preserve">
          <source>Assign itself all the hash slots of its master, and propagate the new configuration to every node which is reachable ASAP, and eventually to every other node.</source>
          <target state="translated">Asignarse a sí mismo todas las ranuras de hachís de su maestro,y propagar la nueva configuración a cada nodo que sea accesible lo antes posible,y eventualmente a todos los demás nodos.</target>
        </trans-unit>
        <trans-unit id="dad88cac85a84619b71e6377f7daff4cceaf9449" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;mylist&lt;/code&gt; is a list of numbers, this command will return the same list with the elements sorted from small to large. In order to sort the numbers from large to small, use the &lt;code&gt;DESC&lt;/code&gt; modifier:</source>
          <target state="translated">Suponiendo que &lt;code&gt;mylist&lt;/code&gt; es una lista de n&amp;uacute;meros, este comando devolver&amp;aacute; la misma lista con los elementos ordenados de peque&amp;ntilde;os a grandes. Para ordenar los n&amp;uacute;meros de grandes a peque&amp;ntilde;os, use el modificador &lt;code&gt;DESC&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="010bc7ebc048785c84f0ef161a24878d38afdc74" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; commands only delete keys that were present at the time the command was invoked. Keys created during an asynchronous flush will be unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917fb2b280881b904605b028a37696fbc08e07d1" translate="yes" xml:space="preserve">
          <source>At this point the new conversions are available, specifically:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f85fbfa8d38f4d4fc4368e61ca47c40b831995" translate="yes" xml:space="preserve">
          <source>At this point you add all the elements into a sorted set using this algorithm:</source>
          <target state="translated">En este punto se agregan todos los elementos en un conjunto ordenado usando este algoritmo:</target>
        </trans-unit>
        <trans-unit id="7f922bf277a422b7aa1b3e6b1ecb1c33f7f356b4" translate="yes" xml:space="preserve">
          <source>At this point, each time you want to get a weighted random element, just compute a random number between 0 and 1 (which is like calling &lt;code&gt;rand()&lt;/code&gt; in most languages), so you can just do:</source>
          <target state="translated">En este punto, cada vez que desee obtener un elemento aleatorio ponderado, simplemente calcule un n&amp;uacute;mero aleatorio entre 0 y 1 (que es como llamar a &lt;code&gt;rand()&lt;/code&gt; en la mayor&amp;iacute;a de los idiomas), por lo que puede hacer:</target>
        </trans-unit>
        <trans-unit id="eeda06eb4e4b735e9051a2d2f05c160b9b8289f8" translate="yes" xml:space="preserve">
          <source>Atomic rewrite process</source>
          <target state="translated">El proceso de reescritura atómica</target>
        </trans-unit>
        <trans-unit id="9081c20623d6921cb283f837b5ab328f068f4ee0" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the first/last element (head/tail depending on the &lt;code&gt;wherefrom&lt;/code&gt; argument) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first/last element (head/tail depending on the &lt;code&gt;whereto&lt;/code&gt; argument) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74a4fa429114feaddb20d28202c0f4085635272" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the last element (tail) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first element (head) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">Devuelve y elimina at&amp;oacute;micamente el &amp;uacute;ltimo elemento (cola) de la lista almacenada en la &lt;code&gt;source&lt;/code&gt; y empuja el elemento al primer elemento (cabeza) de la lista almacenada en el &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6a41c1878a1c7a7b99d6378b8645723ed06556f" translate="yes" xml:space="preserve">
          <source>Atomically sets &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt; and returns the old value stored at &lt;code&gt;key&lt;/code&gt;. Returns an error when &lt;code&gt;key&lt;/code&gt; exists but does not hold a string value.</source>
          <target state="translated">At&amp;oacute;micamente establece la &lt;code&gt;key&lt;/code&gt; al &lt;code&gt;value&lt;/code&gt; y devuelve el valor anterior almacenado en la &lt;code&gt;key&lt;/code&gt; . Devuelve un error cuando la &lt;code&gt;key&lt;/code&gt; existe pero no contiene un valor de cadena.</target>
        </trans-unit>
        <trans-unit id="8b11c68f40fb668f25d5ebde4e4f0d736514c197" translate="yes" xml:space="preserve">
          <source>Atomically transfer a key from a source Redis instance to a destination Redis instance. On success the key is deleted from the original instance and is guaranteed to exist in the target instance.</source>
          <target state="translated">Transferir atómicamente una clave de una instancia de Redis de origen a una instancia de Redis de destino.En caso de éxito,la clave se borra de la instancia original y se garantiza su existencia en la instancia de destino.</target>
        </trans-unit>
        <trans-unit id="120b36c4fdcd059217cbe9ce714cea19b13fd52a" translate="yes" xml:space="preserve">
          <source>Atomicity of scripts</source>
          <target state="translated">La atomicidad de los guiones</target>
        </trans-unit>
        <trans-unit id="6a7f6b699ae2620127572c6b19a3962b68ea30ba" translate="yes" xml:space="preserve">
          <source>Available libraries</source>
          <target state="translated">Bibliotecas disponibles</target>
        </trans-unit>
        <trans-unit id="fc1c7e083bc573df54c3a610bc7a64ef713879e0" translate="yes" xml:space="preserve">
          <source>B sends node A a heartbeat packet, where node D is listed.</source>
          <target state="translated">B envía al nodo A un paquete de latidos,donde el nodo D está listado.</target>
        </trans-unit>
        <trans-unit id="7729f6e6ec6ba874a64709376383726e87372daa" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF</source>
          <target state="translated">BGREWRITEAOF</target>
        </trans-unit>
        <trans-unit id="458f7ff8a0210a97fe946685d4c3eaec2c4d3268" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF   Asynchronously rewrite the append-only file</source>
          <target state="translated">BGREWRITEAOF Reescribir asincrónicamente el archivo de sólo aplicación</target>
        </trans-unit>
        <trans-unit id="a27e9a0dccc378a573407c1d809762f71f913c63" translate="yes" xml:space="preserve">
          <source>BGSAVE</source>
          <target state="translated">BGSAVE</target>
        </trans-unit>
        <trans-unit id="7faf716555dfc6c9000f52854e242ef60d56665d" translate="yes" xml:space="preserve">
          <source>BGSAVE   Asynchronously save the dataset to disk</source>
          <target state="translated">BGSAVE Guardar asincrónicamente el conjunto de datos en el disco</target>
        </trans-unit>
        <trans-unit id="ab695def32445abd5af69c89b4fc9a578a6be30c" translate="yes" xml:space="preserve">
          <source>BGSAVE  [SCHEDULE]   Asynchronously save the dataset to disk</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa73037de86a35867f756331811a0b553f9a4512" translate="yes" xml:space="preserve">
          <source>BITCOUNT</source>
          <target state="translated">BITCOUNT</target>
        </trans-unit>
        <trans-unit id="558065aa2007c718ef4867af43bb99fd2d71d712" translate="yes" xml:space="preserve">
          <source>BITCOUNT  key [start end]   Count set bits in a string</source>
          <target state="translated">Clave BITCOUNT [inicio y final]Contar los bits establecidos en una cadena</target>
        </trans-unit>
        <trans-unit id="4648876b3aec23fc361c9cc8f6b361de8992e75b" translate="yes" xml:space="preserve">
          <source>BITFIELD</source>
          <target state="translated">BITFIELD</target>
        </trans-unit>
        <trans-unit id="4e856b858022af2e0acd6b68544eced1b0992122" translate="yes" xml:space="preserve">
          <source>BITFIELD  key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]   Perform arbitrary bitfield integer operations on strings</source>
          <target state="translated">Tecla BITFIELD [GET type offset][SET type offset value][INCRBY type offset increment][OVERFLOW WRAP|SAT|FAIL]Realizar operaciones arbitrarias de enteros de campo de bits en cadenas</target>
        </trans-unit>
        <trans-unit id="a5aaf403ca55d3d64f12bde81881e9c02072728a" translate="yes" xml:space="preserve">
          <source>BITOP</source>
          <target state="translated">BITOP</target>
        </trans-unit>
        <trans-unit id="fbf06b661d51c935ecb7a0e541d91fa350da1c52" translate="yes" xml:space="preserve">
          <source>BITOP  operation destkey key [key ...]   Perform bitwise operations between strings</source>
          <target state="translated">Operación BITOP tecla de destino [tecla ...]Realizar operaciones de bits entre cadenas</target>
        </trans-unit>
        <trans-unit id="6429405be50a33193090d8d4c0a4575b80d167fc" translate="yes" xml:space="preserve">
          <source>BITPOS</source>
          <target state="translated">BITPOS</target>
        </trans-unit>
        <trans-unit id="3eedfee8a6aaf27b486a0a74ef694737767592c5" translate="yes" xml:space="preserve">
          <source>BITPOS  key bit [start] [end]   Find first bit set or clear in a string</source>
          <target state="translated">BITPOS key bit [inicio][final]Encontrar el primer bit establecido o despejado en una cadena</target>
        </trans-unit>
        <trans-unit id="fc2dfb0c3d9a6c59a7ce67610ea5adaf29a615be" translate="yes" xml:space="preserve">
          <source>BLMOVE</source>
          <target state="translated">BLMOVE</target>
        </trans-unit>
        <trans-unit id="db9a7aeda5f34e5b6dc6bfc16ff9ad89a6ecbdee" translate="yes" xml:space="preserve">
          <source>BLMOVE  source destination LEFT|RIGHT LEFT|RIGHT timeout   Pop an element from a list, push it to another list and return it; or block until one is available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05499a7141cb9854f00176880caa9ac423867f3" translate="yes" xml:space="preserve">
          <source>BLPOP</source>
          <target state="translated">BLPOP</target>
        </trans-unit>
        <trans-unit id="0412d709e7cedab62c94968e19cc0014d112f86b" translate="yes" xml:space="preserve">
          <source>BLPOP  key [key ...] timeout   Remove and get the first element in a list, or block until one is available</source>
          <target state="translated">Tecla BLPOP [tecla ...]timeout Quitar y obtener el primer elemento de una lista,o bloquear hasta que uno esté disponible</target>
        </trans-unit>
        <trans-unit id="5fa06c19410e8a659911506832eca92eaf0050d6" translate="yes" xml:space="preserve">
          <source>BRPOP</source>
          <target state="translated">BRPOP</target>
        </trans-unit>
        <trans-unit id="30c26bc19b012eb7d9f5f55b03c3f9d84b9cf9c5" translate="yes" xml:space="preserve">
          <source>BRPOP  key [key ...] timeout   Remove and get the last element in a list, or block until one is available</source>
          <target state="translated">Tecla BRPOP [tecla ...]timeout Eliminar y obtener el último elemento de una lista,o bloquear hasta que uno esté disponible</target>
        </trans-unit>
        <trans-unit id="c32cdb6143356d21802163582eddef7653863e06" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH</source>
          <target state="translated">BRPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="74721eebf76b2ddc61de86b46cc0aec39763409c" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop a value from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BRPOPLPUSH source destination timeout Sacar un valor de una lista,empujarlo a otra lista y devolverlo;o bloquearlo hasta que haya uno disponible</target>
        </trans-unit>
        <trans-unit id="06a6c1ed02823440cc121edde6eb065e5de27fb8" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop an element from a list, push it to another list and return it; or block until one is available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7a2ea791972d134e771e602c9bb77407df350d" translate="yes" xml:space="preserve">
          <source>BZPOPMAX</source>
          <target state="translated">BZPOPMAX</target>
        </trans-unit>
        <trans-unit id="b6758ab6d65fab9e15ff22d76094622028d82dec" translate="yes" xml:space="preserve">
          <source>BZPOPMAX  key [key ...] timeout   Remove and return the member with the highest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">Tecla BZPOPMAX [tecla ...]tiempo de espera Quitar y devolver el miembro con la mayor puntuación de uno o más conjuntos ordenados,o bloquear hasta que uno esté disponible</target>
        </trans-unit>
        <trans-unit id="cc5c70cba5a0768ab8e3b521a15ca38c10af43e5" translate="yes" xml:space="preserve">
          <source>BZPOPMIN</source>
          <target state="translated">BZPOPMIN</target>
        </trans-unit>
        <trans-unit id="34934a39c9faa59399a1c05af5d02cc1bce19590" translate="yes" xml:space="preserve">
          <source>BZPOPMIN  key [key ...] timeout   Remove and return the member with the lowest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">Tecla BZPOPMIN [tecla ...]tiempo de espera Quitar y devolver el miembro con la puntuación más baja de uno o más conjuntos ordenados,o bloquear hasta que uno esté disponible</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="baab43179123dd499c2cc2c83ab2bfdd9cbd1aec" translate="yes" xml:space="preserve">
          <source>Bandwidth and EVALSHA</source>
          <target state="translated">El ancho de banda y EVALSHA</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">Uso básico:</target>
        </trans-unit>
        <trans-unit id="7df3c519fe73f3ffe3f8fb928955ded445b7f85e" translate="yes" xml:space="preserve">
          <source>Basically the command sets a state in the connection, that is valid only for the next command execution, that will modify the behavior of client tracking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e09074a5a31051e466bb25ea4c7f7009a10585" translate="yes" xml:space="preserve">
          <source>Basically we have a counter for every IP, for every different second. But this counters are always incremented setting an expire of 10 seconds so that they'll be removed by Redis automatically when the current second is a different one.</source>
          <target state="translated">Básicamente tenemos un contador para cada IP,para cada segundo diferente.Pero estos contadores siempre se incrementan estableciendo un vencimiento de 10 segundos para que sean eliminados por Redis automáticamente cuando el segundo actual sea diferente.</target>
        </trans-unit>
        <trans-unit id="3bc673f7ca5e59c74c138e173d60ace2cc7f15b0" translate="yes" xml:space="preserve">
          <source>Basically, the function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the &lt;em&gt;start&lt;/em&gt; argument &lt;strong&gt;only&lt;/strong&gt;.</source>
          <target state="translated">B&amp;aacute;sicamente, la funci&amp;oacute;n considera que el derecho de la cadena se completa con ceros si busca bits claros y no especifica ning&amp;uacute;n rango o &lt;strong&gt;solo el&lt;/strong&gt; argumento de &lt;em&gt;inicio&lt;/em&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="14b677b3a5e36da0c5dac8a200bd5400f84443e8" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; streams back &lt;strong&gt;all&lt;/strong&gt; commands, its use comes at a cost. The following (totally unscientific) benchmark numbers illustrate what the cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; can be.</source>
          <target state="translated">Debido a que &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; transmite &lt;strong&gt;todos los&lt;/strong&gt; comandos, su uso tiene un costo. Los siguientes n&amp;uacute;meros de referencia (totalmente no cient&amp;iacute;ficos) ilustran cu&amp;aacute;l puede ser el costo de ejecutar &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="168e98970df56293fbc42baf15adc634cb88819b" translate="yes" xml:space="preserve">
          <source>Because Redis does not have control over how its allocations are mapped to memory pages, high &lt;code&gt;used_memory_rss&lt;/code&gt; is often the result of a spike in memory usage.</source>
          <target state="translated">Debido a que Redis no tiene control sobre c&amp;oacute;mo se asignan sus asignaciones a las p&amp;aacute;ginas de memoria, un &lt;code&gt;used_memory_rss&lt;/code&gt; alto de used_memory_rss suele ser el resultado de un aumento en el uso de la memoria.</target>
        </trans-unit>
        <trans-unit id="9157dfb92d6b10926d702b4d13ee089e71af6988" translate="yes" xml:space="preserve">
          <source>Because Redis' strings are binary-safe, a bitmap is trivially encoded as a bytes stream. The first byte of the string corresponds to offsets 0..7 of the bitmap, the second byte to the 8..15 range, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba14992feb507791cf455ac84d4bc0c1654fa142" translate="yes" xml:space="preserve">
          <source>Because of security concerns, all administrative commands are not logged by &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;'s output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c7ae78faec3383e9f506c3f0134610891480461" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; semantic, C4 can check if the old value stored at &lt;code&gt;key&lt;/code&gt; is still an expired timestamp. If it is, the lock was acquired.</source>
          <target state="translated">Debido a la sem&amp;aacute;ntica &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; , C4 puede verificar si el valor anterior almacenado en la &lt;code&gt;key&lt;/code&gt; sigue siendo una marca de tiempo vencida. Si es as&amp;iacute;, se adquiri&amp;oacute; el bloqueo.</target>
        </trans-unit>
        <trans-unit id="02e8504630183a9016b44fe68aa220f28cac8de4" translate="yes" xml:space="preserve">
          <source>Because of the first &lt;em&gt;normalized&lt;/em&gt; part in every element (before the colon character), we are forcing a given comparison, however after the range is queries using &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; the application can display to the user the second part of the string, after the colon.</source>
          <target state="translated">Debido a la primera parte &lt;em&gt;normalizada&lt;/em&gt; en cada elemento (antes del car&amp;aacute;cter de dos puntos), estamos forzando una comparaci&amp;oacute;n determinada, sin embargo, despu&amp;eacute;s de que el rango se consulta utilizando &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX,&lt;/a&gt; la aplicaci&amp;oacute;n puede mostrar al usuario la segunda parte de la cadena, despu&amp;eacute;s de los dos puntos.</target>
        </trans-unit>
        <trans-unit id="7d59e94adcd8272e3572e2454feb728deea07f9f" translate="yes" xml:space="preserve">
          <source>Because of the high performance nature of Redis, it is possible to try a lot of passwords in parallel in very short time, so make sure to generate a strong and very long password so that this attack is infeasible. A good way to generate strong passwords is via the &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dcf4c78858f10b7a1c629d42f2c28c91d50489" translate="yes" xml:space="preserve">
          <source>Because of this semantic &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; can be used in order to set different keys representing different fields of an unique logic object in a way that ensures that either all the fields or none at all are set.</source>
          <target state="translated">Debido a esta sem&amp;aacute;ntica, &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; se puede usar para establecer diferentes claves que representen diferentes campos de un objeto l&amp;oacute;gico &amp;uacute;nico de una manera que garantice que se establezcan todos los campos o ninguno.</target>
        </trans-unit>
        <trans-unit id="5743095da9632a185291117b22aab7a1ce272b02" translate="yes" xml:space="preserve">
          <source>Because of this the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option should be used with care.</source>
          <target state="translated">Debido a esto, la opci&amp;oacute;n &lt;strong&gt;TAKEOVER&lt;/strong&gt; debe usarse con cuidado.</target>
        </trans-unit>
        <trans-unit id="409eae8dc6d494086fe4746042f7a180a489be81" translate="yes" xml:space="preserve">
          <source>Because when a given node is part of the cluster, all the other nodes participating in the cluster knows about it, in order for a node to be completely removed from a cluster, the &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; command must be sent to all the remaining nodes, regardless of the fact they are masters or replicas.</source>
          <target state="translated">Debido a que cuando un nodo determinado es parte del cl&amp;uacute;ster, todos los dem&amp;aacute;s nodos que participan en el cl&amp;uacute;ster lo saben, para que un nodo se elimine por completo de un cl&amp;uacute;ster, el comando &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; debe enviarse a todos los nodos restantes, independientemente del hecho de que son maestros o r&amp;eacute;plicas.</target>
        </trans-unit>
        <trans-unit id="b69310332fe10ffd788fd56a9c44b252e49e79dc" translate="yes" xml:space="preserve">
          <source>Behavior of &lt;code&gt;BLPOP&lt;/code&gt; when multiple elements are pushed inside a list.</source>
          <target state="translated">Comportamiento de &lt;code&gt;BLPOP&lt;/code&gt; cuando se insertan varios elementos dentro de una lista.</target>
        </trans-unit>
        <trans-unit id="ece0bd32123faa73ffba96af59789eb1a4470a5d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;with&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running (&lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt;):</source>
          <target state="translated">Resultado de la evaluaci&amp;oacute;n comparativa &lt;strong&gt;con &lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR en&lt;/a&gt; ejecuci&amp;oacute;n ( &lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="e3f9de77c51bcc4c2a59cae3df6e39530202793d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;without&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running:</source>
          <target state="translated">Resultado de referencia &lt;strong&gt;sin &lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR en&lt;/a&gt; ejecuci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a0cee838302dd7dccb0ba96b0e4f12c473f5ce1f" translate="yes" xml:space="preserve">
          <source>Bitmaps are a very space-efficient representation of certain kinds of information. One example is a Web application that needs the history of user visits, so that for instance it is possible to determine what users are good targets of beta features.</source>
          <target state="translated">Los mapas de bits son una representación muy eficiente en el espacio de ciertos tipos de información.Un ejemplo es una aplicación web que necesita el historial de visitas de los usuarios,de modo que,por ejemplo,es posible determinar qué usuarios son buenos objetivos de las características beta.</target>
        </trans-unit>
        <trans-unit id="927448b58910f0636586793360308442afd14b22" translate="yes" xml:space="preserve">
          <source>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type (for more information refer to the &lt;a href=&quot;https://redis.io/topics/data-types-intro#bitmaps&quot;&gt;Bitmaps section of the Data Types Introduction page&lt;/a&gt;). This means that bitmaps can be used with string commands, and most importantly with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; and &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c5f7ddc4fdd4c0470d5c822a63678ca6ac8364" translate="yes" xml:space="preserve">
          <source>Bits and positional offsets</source>
          <target state="translated">Bits y compensaciones posicionales</target>
        </trans-unit>
        <trans-unit id="01b1462f91bf6adae4924e41a337cd3105d30fba" translate="yes" xml:space="preserve">
          <source>Blocking behavior</source>
          <target state="translated">Bloqueo de la conducta</target>
        </trans-unit>
        <trans-unit id="0138f8dd5046866e565b72d9550fe5224c0fb4c2" translate="yes" xml:space="preserve">
          <source>Blocking for data</source>
          <target state="translated">Bloqueo de datos</target>
        </trans-unit>
        <trans-unit id="b9cbba32c11fb20d3cd9b4d8a8851ece3dbdac10" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Bascially, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="translated">Las operaciones de lista de bloqueo en listas o conjuntos ordenados tienen un comportamiento &lt;em&gt;emergente&lt;/em&gt; . B&amp;aacute;sicamente, el elemento se elimina de la lista o se ordena el conjunto para ser devuelto al cliente. En este escenario, desea que los art&amp;iacute;culos se consuman de manera justa, seg&amp;uacute;n el momento en que llegaron los clientes bloqueados en una clave determinada. Normalmente, Redis usa la sem&amp;aacute;ntica FIFO en estos casos de uso.</target>
        </trans-unit>
        <trans-unit id="c7b48b477a47bc528502abd2750eaf8176a42526" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Basically, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83af529ff0234ebb19ae9fc92954913ed20af976" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, where &lt;code&gt;0&lt;/code&gt; is the first element, &lt;code&gt;1&lt;/code&gt; is the next element and so on. They can also be negative numbers indicating offsets from the end of the sorted set, with &lt;code&gt;-1&lt;/code&gt; being the last element of the sorted set, &lt;code&gt;-2&lt;/code&gt; the penultimate element and so on.</source>
          <target state="translated">Tanto el &lt;code&gt;start&lt;/code&gt; como el &lt;code&gt;stop&lt;/code&gt; son &amp;iacute;ndices de base cero, donde &lt;code&gt;0&lt;/code&gt; es el primer elemento, &lt;code&gt;1&lt;/code&gt; es el siguiente elemento y as&amp;iacute; sucesivamente. Tambi&amp;eacute;n pueden ser n&amp;uacute;meros negativos que indican compensaciones desde el final del conjunto ordenado, siendo &lt;code&gt;-1&lt;/code&gt; el &amp;uacute;ltimo elemento del conjunto ordenado, &lt;code&gt;-2&lt;/code&gt; el pen&amp;uacute;ltimo elemento y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="23a10624171d72fb4e9f07612b39ccbc04699493" translate="yes" xml:space="preserve">
          <source>Both commands were introduced in Redis 3.2.10 and Redis 4.0.0 respectively.</source>
          <target state="translated">Ambos comandos fueron introducidos en Redis 3.2.10 y Redis 4.0.0 respectivamente.</target>
        </trans-unit>
        <trans-unit id="3146bb227c4234d6267f94725155f23545044b63" translate="yes" xml:space="preserve">
          <source>Both quantities are 64-bit numbers. When an ID is auto-generated, the first part is the Unix time in milliseconds of the Redis instance generating the ID. The second part is just a sequence number and is used in order to distinguish IDs generated in the same millisecond.</source>
          <target state="translated">Ambas cantidades son números de 64 bits.Cuando un ID se auto-genera,la primera parte es el tiempo Unix en milisegundos de la instancia Redis que genera el ID.La segunda parte es sólo un número de secuencia y se utiliza para distinguir los ID generados en el mismo milisegundo.</target>
        </trans-unit>
        <trans-unit id="4a1f2ae398c91bf9d6a2b34bf5c23ed87585d341" translate="yes" xml:space="preserve">
          <source>Both representations are prefixed with a 16 bytes header, that includes a magic, an encoding / version field, and the cached cardinality estimation computed, stored in little endian format (the most significant bit is 1 if the estimation is invalid since the HyperLogLog was updated since the cardinality was computed).</source>
          <target state="translated">Ambas representaciones se prefijan con un encabezado de 16 bytes,que incluye un campo mágico,un campo de codificación/versión,y la estimación de la cardinalidad en caché computada,almacenada en formato little endian (el bit más significativo es 1 si la estimación no es válida desde que se actualizó el HyperLogLog desde que se computó la cardinalidad).</target>
        </trans-unit>
        <trans-unit id="c7a36cc87678ec27033bceb0e99f2d1deac9e434" translate="yes" xml:space="preserve">
          <source>Both the value already contained in the string key and the increment argument can be optionally provided in exponential notation, however the value computed after the increment is stored consistently in the same format, that is, an integer number followed (if needed) by a dot, and a variable number of digits representing the decimal part of the number. Trailing zeroes are always removed.</source>
          <target state="translated">Tanto el valor ya contenido en la clave de la cadena como el argumento del incremento pueden proporcionarse opcionalmente en notación exponencial,sin embargo el valor calculado después del incremento se almacena sistemáticamente en el mismo formato,es decir,un número entero seguido (si es necesario)por un punto,y un número variable de dígitos que representan la parte decimal del número.Los ceros finales siempre se eliminan.</target>
        </trans-unit>
        <trans-unit id="046892586ee04199d779966b3fd711b935a2c4ee" translate="yes" xml:space="preserve">
          <source>Breaking the compatibility with the past was considered but rejected, at least for Redis 4.0, so instead two read only variants of the commands were added. They are exactly like the original commands but refuse the &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; options. The two variants are called &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt;, and can safely be used in replicas.</source>
          <target state="translated">Se consider&amp;oacute; romper la compatibilidad con el pasado, pero se rechaz&amp;oacute;, al menos para Redis 4.0, por lo que en su lugar se agregaron dos variantes de solo lectura de los comandos. Son exactamente como los comandos originales, pero rechazan las opciones &lt;code&gt;STORE&lt;/code&gt; y &lt;code&gt;STOREDIST&lt;/code&gt; . Las dos variantes se denominan &lt;code&gt;GEORADIUS_RO&lt;/code&gt; y &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; y se pueden utilizar de forma segura en r&amp;eacute;plicas.</target>
        </trans-unit>
        <trans-unit id="11d2a59be0a7424e67e9c632e3f055f99238638f" translate="yes" xml:space="preserve">
          <source>Bulk string reply</source>
          <target state="translated">Respuesta de la cadena de suministro</target>
        </trans-unit>
        <trans-unit id="3e53e1d484c0afdd9ee478c43d641e56563db80a" translate="yes" xml:space="preserve">
          <source>But in the above case the output would be the same, since we have pending messages only for a single consumer. However what is important to keep in mind is that this operation, filtering by a specific consumer, is not inefficient even when there are many pending messages from many consumers: we have a pending entries list data structure both globally, and for every consumer, so we can very efficiently show just messages pending for a single consumer.</source>
          <target state="translated">Pero en el caso anterior la salida sería la misma,ya que tenemos mensajes pendientes sólo para un único consumidor.Sin embargo,lo que es importante tener en cuenta es que esta operación,filtrada por un consumidor específico,no es ineficiente incluso cuando hay muchos mensajes pendientes de muchos consumidores:tenemos una estructura de datos de lista de entradas pendientes tanto a nivel global,como para cada consumidor,por lo que podemos mostrar de forma muy eficiente sólo los mensajes pendientes para un único consumidor.</target>
        </trans-unit>
        <trans-unit id="9fb6518aff837e3fbb56cbdada4b700f62c1931e" translate="yes" xml:space="preserve">
          <source>By default (if /dev/urandom is available) the password is strong and can be used for other uses in the context of a Redis application, for instance in order to create unique session identifiers or other kind of unguessable and not colliding IDs. The password generation is also very cheap because we don't really ask /dev/urandom for bits at every execution. At startup Redis creates a seed using /dev/urandom, then it will use SHA256 in counter mode, with HMAC-SHA256(seed,counter) as primitive, in order to create more random bytes as needed. This means that the application developer should be feel free to abuse &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; to create as many secure pseudorandom strings as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8217506d8ebbaa0e107de581511ee5f509b818" translate="yes" xml:space="preserve">
          <source>By default all the bytes contained in the string are examined. It is possible to specify the counting operation only in an interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt;.</source>
          <target state="translated">De forma predeterminada, se examinan todos los bytes contenidos en la cadena. Es posible especificar la operaci&amp;oacute;n de conteo solo en un intervalo pasando los argumentos adicionales &lt;em&gt;start&lt;/em&gt; y &lt;em&gt;end&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9840a0fb9a28f465bc984e84fdef1e46818881" translate="yes" xml:space="preserve">
          <source>By default all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="translated">De forma predeterminada, se devuelven todos los elementos coincidentes. Es posible limitar los resultados a los primeros N elementos coincidentes usando la opci&amp;oacute;n &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; &lt;/strong&gt; . Sin embargo, tenga en cuenta que internamente el comando debe realizar un esfuerzo proporcional al n&amp;uacute;mero de elementos que coinciden con el &amp;aacute;rea especificada, por lo que consultar &amp;aacute;reas muy grandes con una opci&amp;oacute;n &lt;code&gt;COUNT&lt;/code&gt; muy peque&amp;ntilde;a puede ser lento incluso si solo se devuelven unos pocos resultados. Por otro lado, &lt;code&gt;COUNT&lt;/code&gt; puede ser una forma muy eficaz de reducir el uso de ancho de banda si normalmente solo se utilizan los primeros resultados.</target>
        </trans-unit>
        <trans-unit id="38a3d7ce77609a064a8c66435e5a2ddef01589e2" translate="yes" xml:space="preserve">
          <source>By default the &lt;a href=&quot;lolwut&quot;&gt;LOLWUT&lt;/a&gt; command will display the piece corresponding to the current Redis version, however it is possible to display a specific version using the following form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9b368afa2761dde4363a1630f17429f8bc58b2" translate="yes" xml:space="preserve">
          <source>By default the client is unblocked as if the timeout of the command was reached, however if an additional (and optional) argument is passed, it is possible to specify the unblocking behavior, that can be &lt;strong&gt;TIMEOUT&lt;/strong&gt; (the default) or &lt;strong&gt;ERROR&lt;/strong&gt;. If &lt;strong&gt;ERROR&lt;/strong&gt; is specified, the behavior is to unblock the client returning as error the fact that the client was force-unblocked. Specifically the client will receive the following error:</source>
          <target state="translated">De forma predeterminada, el cliente se desbloquea como si se alcanzara el tiempo de espera del comando, sin embargo, si se pasa un argumento adicional (y opcional), es posible especificar el comportamiento de desbloqueo, que puede ser &lt;strong&gt;TIMEOUT&lt;/strong&gt; (el predeterminado) o &lt;strong&gt;ERROR&lt;/strong&gt; . Si se especifica &lt;strong&gt;ERROR&lt;/strong&gt; , el comportamiento es desbloquear al cliente devolviendo como error el hecho de que el cliente fue desbloqueado a la fuerza. Espec&amp;iacute;ficamente, el cliente recibir&amp;aacute; el siguiente error:</target>
        </trans-unit>
        <trans-unit id="876aa0f6c00a7c0060c29d93b8e069bbd151098c" translate="yes" xml:space="preserve">
          <source>By default the command returns the items to the client. It is possible to store the results with one of these options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91bf3b958012756b0a4a417df15abcf41ceea42c" translate="yes" xml:space="preserve">
          <source>By default the scripting engine is always set to &lt;code&gt;REPL_ALL&lt;/code&gt;. By calling this function the user can switch on/off AOF and or replicas propagation, and turn them back later at her/his wish.</source>
          <target state="translated">De forma predeterminada, el motor de secuencias de comandos siempre se establece en &lt;code&gt;REPL_ALL&lt;/code&gt; . Al llamar a esta funci&amp;oacute;n, el usuario puede activar / desactivar AOF y / o la propagaci&amp;oacute;n de r&amp;eacute;plicas, y devolverlas m&amp;aacute;s tarde cuando lo desee.</target>
        </trans-unit>
        <trans-unit id="d3714f33148cc538954cff3b58af732446c5cd76" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; returns the sorted elements to the client. With the &lt;code&gt;STORE&lt;/code&gt; option, the result will be stored as a list at the specified key instead of being returned to the client.</source>
          <target state="translated">De forma predeterminada, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; devuelve los elementos ordenados al cliente. Con la opci&amp;oacute;n &lt;code&gt;STORE&lt;/code&gt; , el resultado se almacenar&amp;aacute; como una lista en la clave especificada en lugar de devolverse al cliente.</target>
        </trans-unit>
        <trans-unit id="2ee8f070e37dc92ade46a57ac677a11708d8c9aa" translate="yes" xml:space="preserve">
          <source>By default, &lt;strong&gt;WRAP&lt;/strong&gt; is used if not otherwise specified.</source>
          <target state="translated">De forma predeterminada, se utiliza &lt;strong&gt;WRAP&lt;/strong&gt; si no se especifica lo contrario.</target>
        </trans-unit>
        <trans-unit id="f7b1d35e79bbf2da51d0b5f48b7d7d355bd0c2fd" translate="yes" xml:space="preserve">
          <source>By default, all the bytes contained in the string are examined. It is possible to look for bits only in a specified interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; (it is possible to just pass &lt;em&gt;start&lt;/em&gt;, the operation will assume that the end is the last byte of the string. However there are semantic differences as explained later). The range is interpreted as a range of bytes and not a range of bits, so &lt;code&gt;start=0&lt;/code&gt; and &lt;code&gt;end=2&lt;/code&gt; means to look at the first three bytes.</source>
          <target state="translated">De forma predeterminada, se examinan todos los bytes contenidos en la cadena. Es posible buscar bits solo en un intervalo especificado pasando los argumentos adicionales &lt;em&gt;start&lt;/em&gt; y &lt;em&gt;end&lt;/em&gt; (es posible simplemente pasar &lt;em&gt;start&lt;/em&gt; , la operaci&amp;oacute;n asumir&amp;aacute; que el final es el &amp;uacute;ltimo byte de la cadena. Sin embargo, existen diferencias sem&amp;aacute;nticas como se explic&amp;oacute; luego). El rango se interpreta como un rango de bytes y no como un rango de bits, por lo que &lt;code&gt;start=0&lt;/code&gt; y &lt;code&gt;end=2&lt;/code&gt; significa mirar los primeros tres bytes.</target>
        </trans-unit>
        <trans-unit id="ac56e3917c99c4ddfa64494c6e26b8240c053966" translate="yes" xml:space="preserve">
          <source>By default, all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f97c897415a76335a4f3d3db770776a7a0ccedc3" translate="yes" xml:space="preserve">
          <source>By default, it stores the results in the &lt;code&gt;destintion&lt;/code&gt; sorted set with their geospatial information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcfb1fa8d4e16c5703f601d9b874b8021ef089f" translate="yes" xml:space="preserve">
          <source>By default, or when provided with the optional &lt;code&gt;=&lt;/code&gt; argument, the command performs exact trimming. That means that the trimmed stream's length will be exactly the minimum between its original length and the specified maximum length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfdd218a8c7dcfad82b579c16fc98a90e0423ca" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;destination&lt;/code&gt; key is created in the logical database used by the connection. The &lt;code&gt;DB&lt;/code&gt; option allows specifying an alternative logical database index for the destination key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf8d58c1f5391dbccf4f7678d43b4f133487bae" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single element from the beginning of the list. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; elements, depending on the list's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fecef221e5ae822414f939e112035853e985bf7" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single element from the end of the list. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; elements, depending on the list's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7bd3b6d4bf2d2679ef9988f3c531b70e60e21c" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single member from the set. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; members, depending on the set's cardinality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877bdcad724a6306efbd3a664f11efc0ec0b6fe6" translate="yes" xml:space="preserve">
          <source>By default, the command returns unsorted items. Two different sorting methods can be invoked using one of the following two options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5529ebf0aa9355a448e5873d36ba97d16befd8bf" translate="yes" xml:space="preserve">
          <source>By default, the interval specified by &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; is closed (inclusive). It is possible to specify an open interval (exclusive) by prefixing the score with the character &lt;code&gt;(&lt;/code&gt;. For example:</source>
          <target state="translated">De forma predeterminada, el intervalo especificado por &lt;code&gt;min&lt;/code&gt; y &lt;code&gt;max&lt;/code&gt; est&amp;aacute; cerrado (inclusive). Es posible especificar un intervalo abierto (exclusivo) prefijando la partitura con el car&amp;aacute;cter &lt;code&gt;(&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b8a1843f4f52d23022ae70457e87a2bbc0c8ed29" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists.</source>
          <target state="translated">Por defecto,la puntuación resultante de un elemento es la suma de sus puntuaciones en los conjuntos ordenados donde existe.</target>
        </trans-unit>
        <trans-unit id="4665873e5c58037455475bf4706b458811098286" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists. Because intersection requires an element to be a member of every given sorted set, this results in the score of every element in the resulting sorted set to be equal to the number of input sorted sets.</source>
          <target state="translated">Por defecto,la puntuación resultante de un elemento es la suma de sus puntuaciones en los conjuntos ordenados donde existe.Debido a que la intersección requiere que un elemento sea un miembro de cada conjunto ordenado dado,esto resulta en que la puntuación de cada elemento en el conjunto ordenado resultante sea igual al número de conjuntos ordenados de entrada.</target>
        </trans-unit>
        <trans-unit id="9bd72014f313a48aa376a2f9743fd29947ddbfa2" translate="yes" xml:space="preserve">
          <source>By getting the string representation of a bitmap, the client can then parse the response's bytes by extracting the bit values using native bit operations in its native programming language. Symmetrically, it is also possible to set an entire bitmap by performing the bits-to-bytes encoding in the client and calling &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; with the resultant string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855731f4a53411098556da94791141678c87de9e" translate="yes" xml:space="preserve">
          <source>C1 and C2 read &lt;code&gt;lock.foo&lt;/code&gt; to check the timestamp, because they both received &lt;code&gt;0&lt;/code&gt; after executing &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, as the lock is still held by C3 that crashed after holding the lock.</source>
          <target state="translated">C1 y C2 leen &lt;code&gt;lock.foo&lt;/code&gt; para verificar la marca de tiempo, porque ambos recibieron &lt;code&gt;0&lt;/code&gt; despu&amp;eacute;s de ejecutar &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; , ya que el bloqueo a&amp;uacute;n lo mantiene C3 que se bloque&amp;oacute; despu&amp;eacute;s de mantener el bloqueo.</target>
        </trans-unit>
        <trans-unit id="2d7ad86157ffa8a81154afc21adf4e9506f4075d" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C1 env&amp;iacute;a &lt;code&gt;DEL lock.foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59e76a6cffa5164edb0398cd905358d159247029" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C1 env&amp;iacute;a &lt;code&gt;SETNX lock.foo&lt;/code&gt; y tiene &amp;eacute;xito</target>
        </trans-unit>
        <trans-unit id="4f7c62ca261230ba7bd6b9233369caaf27e7f01d" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C2 env&amp;iacute;a &lt;code&gt;DEL lock.foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="193179deba47ad9e120a60484e3cc95253ac5a6a" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C2 env&amp;iacute;a &lt;code&gt;SETNX lock.foo&lt;/code&gt; y tiene &amp;eacute;xito</target>
        </trans-unit>
        <trans-unit id="151ee6de467b9561ff1e9f5ec7724e1aafaaa74e" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;GET lock.foo&lt;/code&gt; to check if the lock expired. If it is not, it will sleep for some time and retry from the start.</source>
          <target state="translated">C4 env&amp;iacute;a &lt;code&gt;GET lock.foo&lt;/code&gt; para verificar si el bloqueo expir&amp;oacute;. Si no es as&amp;iacute;, dormir&amp;aacute; durante alg&amp;uacute;n tiempo y volver&amp;aacute; a intentarlo desde el principio.</target>
        </trans-unit>
        <trans-unit id="80d7499d35c9d242f43ac8ad8f3d435904ce4b07" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; in order to acquire the lock</source>
          <target state="translated">C4 env&amp;iacute;a &lt;code&gt;SETNX lock.foo&lt;/code&gt; para adquirir el bloqueo</target>
        </trans-unit>
        <trans-unit id="810aa98e90b76fd25ebaacd1fecaebbe5cca1fd8" translate="yes" xml:space="preserve">
          <source>CJSON</source>
          <target state="translated">CJSON</target>
        </trans-unit>
        <trans-unit id="289fd6dd86c78fc18484670bd5337ffc1457b23f" translate="yes" xml:space="preserve">
          <source>CLIENT</source>
          <target state="translated">CLIENT</target>
        </trans-unit>
        <trans-unit id="63a953234a4a4b23595b8f5c3d66ad8e228bb360" translate="yes" xml:space="preserve">
          <source>CLIENT CACHING  YES|NO   Instruct the server about tracking or not keys in the next request</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a086feff67c072f67169a1a10544440c06a27bb" translate="yes" xml:space="preserve">
          <source>CLIENT GETNAME   Get the current connection name</source>
          <target state="translated">NOMBRE DEL CLIENTE Obtener el nombre de la conexión actual</target>
        </trans-unit>
        <trans-unit id="4c39ac03d0deadf47c0778e94147170cfe5cc290" translate="yes" xml:space="preserve">
          <source>CLIENT GETREDIR   Get tracking notifications redirection client ID if any</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f043bd4293df18cf326994e345f63d6a607a715" translate="yes" xml:space="preserve">
          <source>CLIENT ID   Returns the client ID for the current connection</source>
          <target state="translated">ID DE CLIENTE Devuelve el ID de cliente para la conexión actual</target>
        </trans-unit>
        <trans-unit id="2cc6c98e277f7b4b6dd7682b2772443f1b2745eb" translate="yes" xml:space="preserve">
          <source>CLIENT INFO   Returns information about the current client connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a606744e377765ead3bebe7af7be75bec984bac6" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="translated">CLIENTE MATAR [ip:port][ID cliente-id][TIPO normal|maestro|esclavo|pub][ADDR ip:port][SKIPME si/no]Matar la conexión de un cliente</target>
        </trans-unit>
        <trans-unit id="0962c4ff7046d5e0349aa07792ed564b6ac58b3e" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [USER username] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f78df8d4251b437ca6d0591e3d79df9db9a668" translate="yes" xml:space="preserve">
          <source>CLIENT KILL and Redis Sentinel</source>
          <target state="translated">CLIENTE MATAR y Redis Sentinel</target>
        </trans-unit>
        <trans-unit id="5abdfb863c66ad1708626a5caaaa3f3ae356f31e" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub]   Get the list of client connections</source>
          <target state="translated">LISTA DE CLIENTES [TIPO normal|master|replica|pub]Obtener la lista de conexiones de clientes</target>
        </trans-unit>
        <trans-unit id="0f9e74e993d542e852824191d195f334f18cdbad" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub] [ID client-id [client-id ...]]   Get the list of client connections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdde82d80a6c631c41a96bc80027350e01ff9d66" translate="yes" xml:space="preserve">
          <source>CLIENT PAUSE  timeout   Stop processing commands from clients for some time</source>
          <target state="translated">PAUSA DE CLIENTES Tiempo de espera Detener el procesamiento de los comandos de los clientes por algún tiempo</target>
        </trans-unit>
        <trans-unit id="cdc920d32af4c13e5383224eaafad4a5e97a22e0" translate="yes" xml:space="preserve">
          <source>CLIENT REPLY  ON|OFF|SKIP   Instruct the server whether to reply to commands</source>
          <target state="translated">CLIENTE RESPUESTA ON|OFF|SKIP Instruye al servidor si debe responder a los comandos</target>
        </trans-unit>
        <trans-unit id="5de18cdee05387ac2edf2c59d640ef325da93c25" translate="yes" xml:space="preserve">
          <source>CLIENT SETNAME  connection-name   Set the current connection name</source>
          <target state="translated">NOMBRE DE CONEXIÓN DEL CLIENTE Nombre de la conexión Establecer el nombre de la conexión actual</target>
        </trans-unit>
        <trans-unit id="95279f3b4d86b3dc0268ddf4db1feb274847cc8c" translate="yes" xml:space="preserve">
          <source>CLIENT TRACKING  ON|OFF [REDIRECT client-id] [PREFIX prefix [PREFIX prefix ...]] [BCAST] [OPTIN] [OPTOUT] [NOLOOP]   Enable or disable server assisted client side caching support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd550a8d7b9512156ea1471fdd3b700157d0ab6e" translate="yes" xml:space="preserve">
          <source>CLIENT TRACKINGINFO   Return information about server assisted client side caching for the current connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326b6f4d4510070631ac4ab9eaf85a825c42c2a7" translate="yes" xml:space="preserve">
          <source>CLIENT UNBLOCK  client-id [TIMEOUT|ERROR]   Unblock a client blocked in a blocking command from a different connection</source>
          <target state="translated">CLIENTE DESBLOQUEAR CLIENTE ID [TIMEOUT|ERROR]Desbloquear un cliente bloqueado en un comando de bloqueo de una conexión diferente</target>
        </trans-unit>
        <trans-unit id="e3b9b52696ca51803a72a1787b8689b560877e3b" translate="yes" xml:space="preserve">
          <source>CLUSTER</source>
          <target state="translated">CLUSTER</target>
        </trans-unit>
        <trans-unit id="89c0d390cdc52475692a036944dfe3e1af10aa52" translate="yes" xml:space="preserve">
          <source>CLUSTER ADDSLOTS  slot [slot ...]   Assign new hash slots to receiving node</source>
          <target state="translated">CLUSTER ANUNCIA ranura [ranura ...]Asigna nuevas ranuras hash al nodo receptor</target>
        </trans-unit>
        <trans-unit id="00fb8c41d977c173c87d67428daf985f10049f97" translate="yes" xml:space="preserve">
          <source>CLUSTER BUMPEPOCH   Advance the cluster config epoch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc6a3f907637996a1389e46617de4c73581acb5f" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNT-FAILURE-REPORTS  node-id   Return the number of failure reports active for a given node</source>
          <target state="translated">CLUSTER COUNT-FAILURE-REPORTS node-id Devuelve el número de informes de fallos activos para un nodo dado</target>
        </trans-unit>
        <trans-unit id="8de0ad0623c7725bc7b50d19dfafe919652d9ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNTKEYSINSLOT  slot   Return the number of local keys in the specified hash slot</source>
          <target state="translated">CLUSTER COUNTKEYSINSLOT slot Devuelve el número de llaves locales en la ranura de hash especificada</target>
        </trans-unit>
        <trans-unit id="a291825c5518befaa628dbca584ac74adfdd3dc0" translate="yes" xml:space="preserve">
          <source>CLUSTER DELSLOTS  slot [slot ...]   Set hash slots as unbound in receiving node</source>
          <target state="translated">CLUSTER DELSLOTS ranura [ranura ...]Ponga las ranuras hash como no ligadas en el nodo de recepción</target>
        </trans-unit>
        <trans-unit id="9b2690b6fa91e96bd2f73d5972dcb19de160e151" translate="yes" xml:space="preserve">
          <source>CLUSTER FAILOVER  [FORCE|TAKEOVER]   Forces a replica to perform a manual failover of its master.</source>
          <target state="translated">Fuerza a una réplica a realizar un failover manual de su maestro.</target>
        </trans-unit>
        <trans-unit id="94cefd9c3cfc8c0aca11125b97d7b0fd362d0d4a" translate="yes" xml:space="preserve">
          <source>CLUSTER FLUSHSLOTS   Delete a node's own slots information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e739c9ee11fd419a688da991d447a266021c6ef0" translate="yes" xml:space="preserve">
          <source>CLUSTER FORGET  node-id   Remove a node from the nodes table</source>
          <target state="translated">CLUSTER FORGET node-id Eliminar un nodo de la tabla de nodos</target>
        </trans-unit>
        <trans-unit id="63b393dc8cc3734128967f68eb934005c0c5a24f" translate="yes" xml:space="preserve">
          <source>CLUSTER GETKEYSINSLOT  slot count   Return local key names in the specified hash slot</source>
          <target state="translated">CLUSTER GETKEYSINSLOT recuento de ranuras Devuelve los nombres de las llaves locales en la ranura de hash especificada</target>
        </trans-unit>
        <trans-unit id="96ff44fb1ff41b2047e38a9dd4b9b91ab3a48e50" translate="yes" xml:space="preserve">
          <source>CLUSTER INFO   Provides info about Redis Cluster node state</source>
          <target state="translated">CLUSTER INFO Proporciona información sobre el estado del nodo Redis Cluster</target>
        </trans-unit>
        <trans-unit id="bceb7d0f89d15cad163cf00743841fee0d54ad57" translate="yes" xml:space="preserve">
          <source>CLUSTER KEYSLOT  key   Returns the hash slot of the specified key</source>
          <target state="translated">Llave CLUSTER KEYSLOT Devuelve la ranura de la llave especificada</target>
        </trans-unit>
        <trans-unit id="db6dfe9195f872c1e24e77eca06229e51f545369" translate="yes" xml:space="preserve">
          <source>CLUSTER MEET  ip port   Force a node cluster to handshake with another node</source>
          <target state="translated">CLUSTER MEET ip port Forzar a un nodo cluster a dar la mano a otro nodo</target>
        </trans-unit>
        <trans-unit id="4c0ca20cada3909d25d2d4e2035e56d2e9daba1b" translate="yes" xml:space="preserve">
          <source>CLUSTER MYID   Return the node id</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45bb4b8fb75be9f6506f8df1b5feecc8fcb42818" translate="yes" xml:space="preserve">
          <source>CLUSTER NODES   Get Cluster config for the node</source>
          <target state="translated">NODOS DE CLUSTER Obtener configuración de Cluster para el nodo</target>
        </trans-unit>
        <trans-unit id="cb1b81c97abbdb844bd68109bd5c641a604ec477" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICAS  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER REPLICAS node-id Lista de nodos réplica del nodo maestro especificado</target>
        </trans-unit>
        <trans-unit id="0c1d4ab714df1ed96b53ecea55f9b15118926ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICATE  node-id   Reconfigure a node as a replica of the specified master node</source>
          <target state="translated">CLUSTER REPLICATE node-id Reconfigurar un nodo como una réplica del nodo maestro especificado</target>
        </trans-unit>
        <trans-unit id="fdd669bf0a4695d61100d82b95672d6f0265fa98" translate="yes" xml:space="preserve">
          <source>CLUSTER RESET  [HARD|SOFT]   Reset a Redis Cluster node</source>
          <target state="translated">REAJUSTE DE CLÚSTER [DURO|SOFT]Reajuste un nodo de Clúster Redis</target>
        </trans-unit>
        <trans-unit id="4452e5582d47e8dfe0990f92ac43fa0dcf4415d8" translate="yes" xml:space="preserve">
          <source>CLUSTER SAVECONFIG   Forces the node to save cluster state on disk</source>
          <target state="translated">CLUSTER SAVECONFIG Fuerza al nodo a guardar el estado del cluster en el disco</target>
        </trans-unit>
        <trans-unit id="0352d198b3e3c3480eec41371b3ead5bc1188b13" translate="yes" xml:space="preserve">
          <source>CLUSTER SET-CONFIG-EPOCH  config-epoch   Set the configuration epoch in a new node</source>
          <target state="translated">CLUSTER SET-CONFIG-EPOCH config-epoch Establecer la época de configuración en un nuevo nodo</target>
        </trans-unit>
        <trans-unit id="717b30894068edcc566f30c183079158fcd2ebb3" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT  slot IMPORTING|MIGRATING|STABLE|NODE [node-id]   Bind a hash slot to a specific node</source>
          <target state="translated">CLUSTER SETSLOT slot IMPORTING|MIGRATING|STABLE|NODE [node-id]Vincula una ranura hash a un nodo específico</target>
        </trans-unit>
        <trans-unit id="6998d43f245cd331b3038d9db49ce51e5fbe657b" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; IMPORTING &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; IMPORTANDO &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df0cda76712dac386672dd77ffb08df9386d4ded" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; MIGRATING &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; MIGRANDO &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87c55a08cdeb007d9466cda6f41bd3aa8b0b08f" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; NODE &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; NODE &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8050d05e7c830b724efadb1fb19908cbba0c3b12" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; STABLE</source>
          <target state="translated">CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; ESTABLE</target>
        </trans-unit>
        <trans-unit id="87d7c95e3334e2c65e594f6606b11d6fa033b8e3" translate="yes" xml:space="preserve">
          <source>CLUSTER SLAVES  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER SLAVES node-id Lista de nodos réplica del nodo maestro especificado</target>
        </trans-unit>
        <trans-unit id="0b83235580afb6dcdbb5aaae9069030836332846" translate="yes" xml:space="preserve">
          <source>CLUSTER SLOTS   Get array of Cluster slot to node mappings</source>
          <target state="translated">RANURAS DE CLÚSTER Obtener una serie de ranuras de clúster para mapeo de nodos.</target>
        </trans-unit>
        <trans-unit id="2e4854d8dd31ab3a1bd0bbce1a9b8c73da88c413" translate="yes" xml:space="preserve">
          <source>COMMAND</source>
          <target state="translated">COMMAND</target>
        </trans-unit>
        <trans-unit id="5d475d3ae2a090a5dd4fb9bcb4834f2b0f5e8e36" translate="yes" xml:space="preserve">
          <source>COMMAND   Get array of Redis command details</source>
          <target state="translated">COMANDO Obtener una serie de detalles del comando Redis</target>
        </trans-unit>
        <trans-unit id="243f2ac950baaf718523fe42c2f35baa4d002daa" translate="yes" xml:space="preserve">
          <source>COMMAND COUNT   Get total number of Redis commands</source>
          <target state="translated">CUENTA DE COMANDOS Obtener el número total de comandos de Redis</target>
        </trans-unit>
        <trans-unit id="b5c43f716c4692946b372734d13302625935ddef" translate="yes" xml:space="preserve">
          <source>COMMAND GETKEYS   Extract keys given a full Redis command</source>
          <target state="translated">Extraer las llaves dándoles un comando completo de Redis.</target>
        </trans-unit>
        <trans-unit id="e4f0ee016bdc14d304548515037906095d7beb51" translate="yes" xml:space="preserve">
          <source>COMMAND INFO  command-name [command-name ...]   Get array of specific Redis command details</source>
          <target state="translated">INFORMACIÓN DE COMANDO Nombre de comando [nombre de comando...]Obtener una serie de detalles específicos del comando Redis</target>
        </trans-unit>
        <trans-unit id="2fb60054b43a25d7a958d3d19bdb1aa7809577a8" translate="yes" xml:space="preserve">
          <source>CONFIG</source>
          <target state="translated">CONFIG</target>
        </trans-unit>
        <trans-unit id="d3f495884e312ef94089cef1025f98afac649a7f" translate="yes" xml:space="preserve">
          <source>CONFIG GET  parameter   Get the value of a configuration parameter</source>
          <target state="translated">CONFIG GET parameter Obtener el valor de un parámetro de configuración</target>
        </trans-unit>
        <trans-unit id="d6c004f361be600273602c08f69569c9b929d35b" translate="yes" xml:space="preserve">
          <source>CONFIG RESETSTAT   Reset the stats returned by INFO</source>
          <target state="translated">CONFIG RESETSAT Restablecer las estadísticas devueltas por INFO</target>
        </trans-unit>
        <trans-unit id="07fd8b85f66f97280cb2ad55982da60cacbe7682" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE   Rewrite the configuration file with the in memory configuration</source>
          <target state="translated">CONFIG REWRITE Reescriba el archivo de configuración con la configuración en memoria</target>
        </trans-unit>
        <trans-unit id="d27538b14c1ebc5ce34011e7bb5ef99fff52c53d" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE is also able to rewrite the configuration file from scratch if the original one no longer exists for some reason. However if the server was started without a configuration file at all, the CONFIG REWRITE will just return an error.</source>
          <target state="translated">CONFIG REWRITE también es capaz de reescribir el archivo de configuración desde cero si el original ya no existe por alguna razón.Sin embargo,si el servidor se inició sin un archivo de configuración en absoluto,el CONFIG REWRITE sólo devolverá un error.</target>
        </trans-unit>
        <trans-unit id="bcdc354e91b58a18cc7f424a767e01c256e6b42b" translate="yes" xml:space="preserve">
          <source>CONFIG SET  parameter value   Set a configuration parameter to the given value</source>
          <target state="translated">CONFIGURAR EL VALOR DEL PARÁMETRO DE CONFIGURACIÓN Ajustar un parámetro de configuración al valor dado</target>
        </trans-unit>
        <trans-unit id="aecf0292da85cb2048d8b648567127d024d4074f" translate="yes" xml:space="preserve">
          <source>COPY</source>
          <target state="translated">COPY</target>
        </trans-unit>
        <trans-unit id="b3729b7bb933c36d809f0e8ba9d3228341d27148" translate="yes" xml:space="preserve">
          <source>COPY  source destination [DB destination-db] [REPLACE]   Copy a key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba6c24ce4497d078be48b670ad16cc43d57f929" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; with a broken, negative, out of range, or otherwise invalid cursor, will result into undefined behavior but never into a crash. What will be undefined is that the guarantees about the returned elements can no longer be ensured by the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; implementation.</source>
          <target state="translated">Llamar a &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; con un cursor roto, negativo, fuera de rango o inv&amp;aacute;lido de otra manera resultar&amp;aacute; en un comportamiento indefinido pero nunca en un bloqueo. Lo que no estar&amp;aacute; definido es que las garant&amp;iacute;as sobre los elementos devueltos ya no pueden ser garantizadas por la implementaci&amp;oacute;n de &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f46be6632e20880fa3190f308734a7c2debc935" translate="yes" xml:space="preserve">
          <source>Calling SCAN with a corrupted cursor</source>
          <target state="translated">Llamando a SCAN con un cursor corrupto</target>
        </trans-unit>
        <trans-unit id="1e0b7fe9d077c2aa9a5144f650dffdcf03fa241c" translate="yes" xml:space="preserve">
          <source>Capped streams</source>
          <target state="translated">Corrientes cubiertas</target>
        </trans-unit>
        <trans-unit id="677509e3c92011eb7431eb950f99423de593897c" translate="yes" xml:space="preserve">
          <source>Care should be taken when executing &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; in the context of a pipelined request, since even in a pipeline the order of execution of commands must be guaranteed. If &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will return a &lt;code&gt;NOSCRIPT&lt;/code&gt; error the command can not be reissued later otherwise the order of execution is violated.</source>
          <target state="translated">Se debe tener cuidado al ejecutar &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; en el contexto de una solicitud canalizada, ya que incluso en una canalizaci&amp;oacute;n se debe garantizar el orden de ejecuci&amp;oacute;n de los comandos. Si &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; devuelve un error &lt;code&gt;NOSCRIPT&lt;/code&gt; , el comando no se puede volver a emitir m&amp;aacute;s tarde, de lo contrario se infringe el orden de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3c95b0aba9bde834d03663b5e6a82abbc6926a9f" translate="yes" xml:space="preserve">
          <source>Checking for all the available categories is as simple as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eaf1e254fa69f8ab1d24e1e39a78203c7080474" translate="yes" xml:space="preserve">
          <source>Client IP address and port (4.0 only).</source>
          <target state="translated">Dirección IP y puerto del cliente (sólo 4.0).</target>
        </trans-unit>
        <trans-unit id="5cf75075a191bc11d161c66570997946e05f966f" translate="yes" xml:space="preserve">
          <source>Client libraries may use Redis in order to test their own hashing algorithm, generating random keys and hashing them with both their local implementation and using Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt; command, then checking if the result is the same.</source>
          <target state="translated">Las bibliotecas cliente pueden usar Redis para probar su propio algoritmo de hash, generando claves aleatorias y hash con su implementaci&amp;oacute;n local y usando el comando Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt; , luego verificando si el resultado es el mismo.</target>
        </trans-unit>
        <trans-unit id="5993bbb849b531146b7a95269c1882c6ff8a9ed3" translate="yes" xml:space="preserve">
          <source>Client name if set via the &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command (4.0 only).</source>
          <target state="translated">El nombre del cliente si se establece mediante el comando &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; (solo 4.0).</target>
        </trans-unit>
        <trans-unit id="d75dc68bbdd56c9cbd58d4bbdabda84bcca2c47f" translate="yes" xml:space="preserve">
          <source>Cluster</source>
          <target state="translated">Cluster</target>
        </trans-unit>
        <trans-unit id="4a4e6b60b2ae77bbe874af6a70cdbaba6049e713" translate="yes" xml:space="preserve">
          <source>Cluster clients must be aware of key positions in commands so commands can go to matching instances, but Redis commands vary between accepting one key, multiple keys, or even multiple keys separated by other data.</source>
          <target state="translated">Los clientes del clúster deben ser conscientes de las posiciones de las teclas en los comandos para que éstos puedan ir a las instancias correspondientes,pero los comandos de Redis varían entre aceptar una tecla,varias teclas o incluso varias teclas separadas por otros datos.</target>
        </trans-unit>
        <trans-unit id="13fb8a1716343d8d81faf3b82f500e80a846e807" translate="yes" xml:space="preserve">
          <source>Cluster note: in a Redis Cluster clients can subscribe to every node, and can also publish to every other node. The cluster will make sure that published messages are forwarded as needed. That said, &lt;a href=&quot;pubsub&quot;&gt;PUBSUB&lt;/a&gt;'s replies in a cluster only report information from the node's Pub/Sub context, rather than the entire cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c356fac15c94ebf5b7447ee6cfaeb09fa342b3" translate="yes" xml:space="preserve">
          <source>Command Arity</source>
          <target state="translated">Comando Arity</target>
        </trans-unit>
        <trans-unit id="b25b9ea512e65182e9de25869fda9886e798f471" translate="yes" xml:space="preserve">
          <source>Command Name</source>
          <target state="translated">Nombre del comando</target>
        </trans-unit>
        <trans-unit id="72da5b475c49e9d5cba38602d80b0de205cc6bb7" translate="yes" xml:space="preserve">
          <source>Command arity &lt;em&gt;includes&lt;/em&gt; counting the command name itself.</source>
          <target state="translated">El comando arity &lt;em&gt;incluye&lt;/em&gt; contar el nombre del comando en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="7b7be4b904754c3884cb0bf72bfeb125fc2e6d02" translate="yes" xml:space="preserve">
          <source>Command arity follows a simple pattern:</source>
          <target state="translated">La aridad de mando sigue un patrón simple:</target>
        </trans-unit>
        <trans-unit id="da09292eaa6e23b8b1b1824949fffe53ca537116" translate="yes" xml:space="preserve">
          <source>Command flags is &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; containing one or more status replies:</source>
          <target state="translated">Los indicadores de comando son &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;respuestas de matriz que&lt;/a&gt; contienen una o m&amp;aacute;s respuestas de estado:</target>
        </trans-unit>
        <trans-unit id="d8fdc321243166f52a9f1732c47f181f168fb6cd" translate="yes" xml:space="preserve">
          <source>Command name is the command returned as a lowercase string.</source>
          <target state="translated">El nombre del comando es el comando devuelto como una cadena de minúsculas.</target>
        </trans-unit>
        <trans-unit id="c03350e2365b375b5bb4ce53303074533ba05e9e" translate="yes" xml:space="preserve">
          <source>Command options</source>
          <target state="translated">Opciones de mando</target>
        </trans-unit>
        <trans-unit id="a4618f4b2f49e68da5c5eab1cb65f4e2cbae4e8c" translate="yes" xml:space="preserve">
          <source>Commands about keys already migrated are correctly processed in the context of the node which is the target of the migration, the new hash slot owner, in order to guarantee consistency.</source>
          <target state="translated">Los comandos sobre las claves ya migradas se procesan correctamente en el contexto del nodo que es el objetivo de la migración,el nuevo propietario de la ranura de hash,a fin de garantizar la coherencia.</target>
        </trans-unit>
        <trans-unit id="b7c78328ebde5dad6a0b828ac630676fb4437227" translate="yes" xml:space="preserve">
          <source>Commands about this hash slot are refused and a &lt;code&gt;MOVED&lt;/code&gt; redirection is generated as usually, but in the case the command follows an &lt;code&gt;ASKING&lt;/code&gt; command, in this case the command is executed.</source>
          <target state="translated">Los comandos sobre esta ranura hash se rechazan y se genera una redirecci&amp;oacute;n &lt;code&gt;MOVED&lt;/code&gt; como de costumbre, pero en el caso de que el comando siga a un comando &lt;code&gt;ASKING&lt;/code&gt; , en este caso se ejecuta el comando.</target>
        </trans-unit>
        <trans-unit id="aa013f0386471baba0b09b24b999134de43d82e4" translate="yes" xml:space="preserve">
          <source>Commands denied because accessing keys not allowed in the current ACL rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aef01612894a7eb8b7ac8feeb71f973dac67ca6" translate="yes" xml:space="preserve">
          <source>Commands denied because against the current ACL rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5080f3f78852fa61575aea2ee4cbd726a5e4c31e" translate="yes" xml:space="preserve">
          <source>Commands not logged by MONITOR</source>
          <target state="translated">Comandos no registrados por el MONITOR</target>
        </trans-unit>
        <trans-unit id="b16b78407a41c93dd4cb4577acb6af8003abc8f6" translate="yes" xml:space="preserve">
          <source>Comments and the overall structure of the original redis.conf are preserved as much as possible.</source>
          <target state="translated">Los comentarios y la estructura general del redis.conf original se conservan en la medida de lo posible.</target>
        </trans-unit>
        <trans-unit id="b2729f5c12d7e85d14c701273c4956c936eacdf5" translate="yes" xml:space="preserve">
          <source>Complete list of commands currently requiring key location parsing:</source>
          <target state="translated">Lista completa de comandos que actualmente requieren análisis de localización de claves:</target>
        </trans-unit>
        <trans-unit id="85cf1af73ea4830e4844b1efcacdc1968badce3f" translate="yes" xml:space="preserve">
          <source>Computes the difference between the first and all successive input sorted sets and stores the result in &lt;code&gt;destination&lt;/code&gt;. The total number of input keys is specified by &lt;code&gt;numkeys&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc6213bb38f415f44656ea01a54b34f86489a7e" translate="yes" xml:space="preserve">
          <source>Computes the intersection of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">Calcula la intersecci&amp;oacute;n de &lt;code&gt;numkeys&lt;/code&gt; ordenados numkeys dados por las claves especificadas y almacena el resultado en el &lt;code&gt;destination&lt;/code&gt; . Es obligatorio proporcionar el n&amp;uacute;mero de claves de entrada ( &lt;code&gt;numkeys&lt;/code&gt; ) antes de pasar las claves de entrada y los otros argumentos (opcionales).</target>
        </trans-unit>
        <trans-unit id="9e0628d44bd94fff2a05cbf6e7329ac8c1542b4c" translate="yes" xml:space="preserve">
          <source>Computes the union of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">Calcula la uni&amp;oacute;n de &lt;code&gt;numkeys&lt;/code&gt; ordenados numkeys dados por las claves especificadas y almacena el resultado en el &lt;code&gt;destination&lt;/code&gt; . Es obligatorio proporcionar el n&amp;uacute;mero de claves de entrada ( &lt;code&gt;numkeys&lt;/code&gt; ) antes de pasar las claves de entrada y los otros argumentos (opcionales).</target>
        </trans-unit>
        <trans-unit id="1ac361d8a1971640b6145bcc2b23471d096806f1" translate="yes" xml:space="preserve">
          <source>Conditions where a SHUTDOWN fails</source>
          <target state="translated">Las condiciones en las que falla un SHUTDOWN</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="ce5886d8502f58f63f333861b5077fd91e99a286" translate="yes" xml:space="preserve">
          <source>Consistency and WAIT</source>
          <target state="translated">Consistencia y ESPERA</target>
        </trans-unit>
        <trans-unit id="5f2f16b6f5d5be95f9b3876b338cd86be1794d28" translate="yes" xml:space="preserve">
          <source>Consistency with range functions in various programming languages</source>
          <target state="translated">Coherencia con las funciones de rango en varios lenguajes de programación</target>
        </trans-unit>
        <trans-unit id="b36b2f89bb23664788c6f3dd35338c638ba28a39" translate="yes" xml:space="preserve">
          <source>Consumer groups in 30 seconds</source>
          <target state="translated">Grupos de consumidores en 30 segundos</target>
        </trans-unit>
        <trans-unit id="bd58f13135bb4a18278653a136394b666aadff83" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. However sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="translated">Los consumidores de un grupo de consumidores se autocrean cada vez que un nuevo nombre de consumidor es mencionado por algún comando.Sin embargo,a veces puede ser útil eliminar los antiguos consumidores ya que ya no se utilizan.Este formulario devuelve el número de mensajes pendientes que el consumidor tenía antes de ser eliminado.</target>
        </trans-unit>
        <trans-unit id="93fee3ae260963d2ed888e760affe7075d85b781" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. They can also be explicitly created by using the following form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04bdc35bafea7cf8c81eec69e12b57349af7a26" translate="yes" xml:space="preserve">
          <source>Conversion between Lua and Redis data types</source>
          <target state="translated">Conversión entre los tipos de datos Lua y Redis</target>
        </trans-unit>
        <trans-unit id="c74388ea06d766117ef931f93cf1e85e7c07bf21" translate="yes" xml:space="preserve">
          <source>Cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;</source>
          <target state="translated">Costo de ejecutar &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f43fec16935ea429ca6c4332ec8b80a51c3b6c5e" translate="yes" xml:space="preserve">
          <source>Cost of running MONITOR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55d91fd97c87e8a34c622a7e4794ffcc51bd61d" translate="yes" xml:space="preserve">
          <source>Count argument extension</source>
          <target state="translated">Extensión del argumento del recuento</target>
        </trans-unit>
        <trans-unit id="ed6fd4dc25ec3bdb3875f3c7192bde09b87a5801" translate="yes" xml:space="preserve">
          <source>Count the number of set bits (population counting) in a string.</source>
          <target state="translated">Contar el número de bits fijos (recuento de población)en una cadena.</target>
        </trans-unit>
        <trans-unit id="852a7b974be96bbc7c6036398114250aedbb0dca" translate="yes" xml:space="preserve">
          <source>Create a key associated with a value that is obtained by deserializing the provided serialized value (obtained via &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt;).</source>
          <target state="translated">Cree una clave asociada con un valor que se obtiene deserializando el valor serializado proporcionado (obtenido a trav&amp;eacute;s de &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1b9548967da77ce66eb092905a2179716e7c9d5d" translate="yes" xml:space="preserve">
          <source>Create a new consumer group associated with a stream.</source>
          <target state="translated">Crear un nuevo grupo de consumidores asociado a un arroyo.</target>
        </trans-unit>
        <trans-unit id="5c0f29bb78fb88abe065ad6df1e2bc2b5123eed8" translate="yes" xml:space="preserve">
          <source>Create an ACL user with the specified rules or modify the rules of an existing user. This is the main interface in order to manipulate Redis ACL users interactively: if the username does not exist, the command creates the username without any privilege, then reads from left to right all the rules provided as successive arguments, setting the user ACL rules as specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8db62ea4abea13f4e50ca9316893c361ba8afd9" translate="yes" xml:space="preserve">
          <source>D ends re-added in the nodes table of A.</source>
          <target state="translated">Los extremos de la D se vuelven a añadir en la tabla de nodos de la A.</target>
        </trans-unit>
        <trans-unit id="d6ddfbac6ec07c32e2eb043cdffc4a0b7cf14714" translate="yes" xml:space="preserve">
          <source>D is now empty, but still listed in the nodes table of A, B and C.</source>
          <target state="translated">D está ahora vacía,pero sigue figurando en la tabla de nodos de A,B y C.</target>
        </trans-unit>
        <trans-unit id="5231dbf5c92399c707fd162111bff340755773aa" translate="yes" xml:space="preserve">
          <source>DBSIZE</source>
          <target state="translated">DBSIZE</target>
        </trans-unit>
        <trans-unit id="cd67c53a53d3f0097d3c5a23561287ae0d9fb415" translate="yes" xml:space="preserve">
          <source>DBSIZE   Return the number of keys in the selected database</source>
          <target state="translated">DBSIZE Devuelve el número de claves en la base de datos seleccionada</target>
        </trans-unit>
        <trans-unit id="3f67e8f4eecf241b91f4cc8c976a487ade34d09d" translate="yes" xml:space="preserve">
          <source>DEBUG</source>
          <target state="translated">DEBUG</target>
        </trans-unit>
        <trans-unit id="64d12201fd531f0183ba8e8b6982cd30fb3885db" translate="yes" xml:space="preserve">
          <source>DEBUG OBJECT  key   Get debugging information about a key</source>
          <target state="translated">DEBUG OBJECT key Obtener información de depuración sobre una clave</target>
        </trans-unit>
        <trans-unit id="a9e1eb844a55b579a65a4c4467b589dca48f8f1a" translate="yes" xml:space="preserve">
          <source>DEBUG SEGFAULT   Make the server crash</source>
          <target state="translated">DEBUG SEGFAULT Hacer que el servidor se caiga</target>
        </trans-unit>
        <trans-unit id="d05cdacee2c153d405a26e62250727ce77ea0892" translate="yes" xml:space="preserve">
          <source>DECR</source>
          <target state="translated">DECR</target>
        </trans-unit>
        <trans-unit id="60ab4c3e9133d30eaf0ded676cadb4c538c56082" translate="yes" xml:space="preserve">
          <source>DECR  key   Decrement the integer value of a key by one</source>
          <target state="translated">Tecla DECR Disminuye el valor entero de una clave en uno</target>
        </trans-unit>
        <trans-unit id="dd8d57c1b1a5522fa21a54d374912c18ca797f47" translate="yes" xml:space="preserve">
          <source>DECRBY</source>
          <target state="translated">DECRBY</target>
        </trans-unit>
        <trans-unit id="8c2782a79fd11dffe9a2c86222797cdb763ac992" translate="yes" xml:space="preserve">
          <source>DECRBY  key decrement   Decrement the integer value of a key by the given number</source>
          <target state="translated">Disminución de la clave de DECRBY Disminuir el valor entero de una clave por el número dado</target>
        </trans-unit>
        <trans-unit id="4d017cb3dcf43d965d38a31c9ad97cefabc893fb" translate="yes" xml:space="preserve">
          <source>DEL</source>
          <target state="translated">DEL</target>
        </trans-unit>
        <trans-unit id="85fb2865a5ba87d91f28447addbf73c6630fa434" translate="yes" xml:space="preserve">
          <source>DEL  key [key ...]   Delete a key</source>
          <target state="translated">Tecla DEL [tecla ...]Borrar una tecla</target>
        </trans-unit>
        <trans-unit id="f70fbda4bf2a0042e1d9cc7f61715651b43106d6" translate="yes" xml:space="preserve">
          <source>DISCARD</source>
          <target state="translated">DISCARD</target>
        </trans-unit>
        <trans-unit id="7bb67c7109691456662bb20fddb311696e25ac95" translate="yes" xml:space="preserve">
          <source>DISCARD   Discard all commands issued after MULTI</source>
          <target state="translated">Descarte todos los comandos emitidos después de MULTI</target>
        </trans-unit>
        <trans-unit id="fac3a6812b938bfbdd2af221e2fba7ec856f466e" translate="yes" xml:space="preserve">
          <source>DUMP</source>
          <target state="translated">DUMP</target>
        </trans-unit>
        <trans-unit id="88b9c1225fe8ce252d48041c949b9e8d2d7b90b3" translate="yes" xml:space="preserve">
          <source>DUMP  key   Return a serialized version of the value stored at the specified key.</source>
          <target state="translated">Tecla DUMP Devuelve una versión serializada del valor almacenado en la tecla especificada.</target>
        </trans-unit>
        <trans-unit id="4220ea2836e7841048c2cdb7caf3ef474641deb4" translate="yes" xml:space="preserve">
          <source>Debugging Lua scripts</source>
          <target state="translated">Depuración de los guiones de Lua</target>
        </trans-unit>
        <trans-unit id="f34ef3d0e6d55088a63bbe9a7135854f8a4a3c06" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;decrement&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">Disminuye el n&amp;uacute;mero almacenado en la &lt;code&gt;key&lt;/code&gt; por &lt;code&gt;decrement&lt;/code&gt; o . Si la clave no existe, se establece en &lt;code&gt;0&lt;/code&gt; antes de realizar la operaci&amp;oacute;n. Se devuelve un error si la clave contiene un valor del tipo incorrecto o contiene una cadena que no se puede representar como un n&amp;uacute;mero entero. Esta operaci&amp;oacute;n est&amp;aacute; limitada a enteros de 64 bits con signo.</target>
        </trans-unit>
        <trans-unit id="eabc98dcb44b2f848dc2b5fd749cc1976767b1ef" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to &lt;strong&gt;64 bit signed integers&lt;/strong&gt;.</source>
          <target state="translated">Disminuye el n&amp;uacute;mero almacenado en la &lt;code&gt;key&lt;/code&gt; en uno. Si la clave no existe, se establece en &lt;code&gt;0&lt;/code&gt; antes de realizar la operaci&amp;oacute;n. Se devuelve un error si la clave contiene un valor del tipo incorrecto o contiene una cadena que no se puede representar como un n&amp;uacute;mero entero. Esta operaci&amp;oacute;n est&amp;aacute; limitada a &lt;strong&gt;enteros de 64 bits con signo&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="543341d8d409be4e8e87f012a0d71ed9115a00c9" translate="yes" xml:space="preserve">
          <source>Delete all the keys found expired.</source>
          <target state="translated">Borre todas las llaves encontradas caducadas.</target>
        </trans-unit>
        <trans-unit id="093f69205f9dd67871820195d9a0ab6b921ee71c" translate="yes" xml:space="preserve">
          <source>Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.</source>
          <target state="translated">Borrar todas las claves de todas las bases de datos existentes,no sólo la seleccionada actualmente.Este comando nunca falla.</target>
        </trans-unit>
        <trans-unit id="1a8bf3d0326f070451b1d5d0c69c59a369de9555" translate="yes" xml:space="preserve">
          <source>Delete all the keys of the currently selected DB. This command never fails.</source>
          <target state="translated">Borrar todas las teclas de la BD seleccionada actualmente.Este comando nunca falla.</target>
        </trans-unit>
        <trans-unit id="26c0e71676fb555cdd0bb73d03160139913dfe07" translate="yes" xml:space="preserve">
          <source>Delete all the specified ACL users and terminate all the connections that are authenticated with such users. Note: the special &lt;code&gt;default&lt;/code&gt; user cannot be removed from the system, this is the default user that every new connection is authenticated with. The list of users may include usernames that do not exist, in such case no operation is performed for the non existing users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5165f9fa25a0905a85123f97b0428c87e1a5bb61" translate="yes" xml:space="preserve">
          <source>Deletes all slots from a node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a85a3d0c778d43ae904d63695fe309c4c3c24d" translate="yes" xml:space="preserve">
          <source>Deployment is hard if we have to make sure all instances contain a given command, especially in a distributed environment.</source>
          <target state="translated">El despliegue es difícil si tenemos que asegurarnos de que todas las instancias contienen un comando determinado,especialmente en un entorno distribuido.</target>
        </trans-unit>
        <trans-unit id="5ff30b622ac74ad50b3a17678781b111c2a76d5c" translate="yes" xml:space="preserve">
          <source>Design pattern</source>
          <target state="translated">Patrón de diseño</target>
        </trans-unit>
        <trans-unit id="21a2deb58a8a8547be11baa26a8458026dc5e0be" translate="yes" xml:space="preserve">
          <source>Design pattern: Locking with &lt;code&gt;SETNX&lt;/code&gt;</source>
          <target state="translated">Patr&amp;oacute;n de dise&amp;ntilde;o: bloqueo con &lt;code&gt;SETNX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa7fb27a452f3b56f97bc25556a2c1c23541060b" translate="yes" xml:space="preserve">
          <source>Destroy a consumer group.</source>
          <target state="translated">Destruir un grupo de consumidores.</target>
        </trans-unit>
        <trans-unit id="2a999a830e915e0d76daa09bf5db1dee24489f35" translate="yes" xml:space="preserve">
          <source>Details on strings comparison</source>
          <target state="translated">Detalles de la comparación de las cuerdas</target>
        </trans-unit>
        <trans-unit id="b5cf1dd7b9908b60a915b47bdf1a512163a4abd6" translate="yes" xml:space="preserve">
          <source>Details on why the ban-list is needed</source>
          <target state="translated">Los detalles de por qué se necesita la lista de prohibición</target>
        </trans-unit>
        <trans-unit id="e861bf6485a8747057af520bff1e2bd98ca908ee" translate="yes" xml:space="preserve">
          <source>Detect timed out replicas.</source>
          <target state="translated">Detectar réplicas cronometradas.</target>
        </trans-unit>
        <trans-unit id="c1a87c7e48f6afb9828d520eaa5085ecfdb87723" translate="yes" xml:space="preserve">
          <source>Differences between XREAD and XREADGROUP</source>
          <target state="translated">Diferencias entre XREAD y XREADGROUP</target>
        </trans-unit>
        <trans-unit id="954c7e91bbe922ce8d0679c169669338d8457c3c" translate="yes" xml:space="preserve">
          <source>Differences in Redis prior 2.1.3</source>
          <target state="translated">Diferencias en Redis anterior 2.1.3</target>
        </trans-unit>
        <trans-unit id="d60417fd68044b5a922b2a39105c16f898e592ce" translate="yes" xml:space="preserve">
          <source>Different instances may have different implementations of a command.</source>
          <target state="translated">Diferentes instancias pueden tener diferentes implementaciones de un comando.</target>
        </trans-unit>
        <trans-unit id="0e666a0e590c18bbb2775c33bdd4b4b2755c4fd8" translate="yes" xml:space="preserve">
          <source>Different return values are used for different subcommands.</source>
          <target state="translated">Se utilizan diferentes valores de retorno para diferentes subcomandos.</target>
        </trans-unit>
        <trans-unit id="8519d2a89e19a4522b7059222e7d87dd5565a1b3" translate="yes" xml:space="preserve">
          <source>Disables read queries for a connection to a Redis Cluster slave node.</source>
          <target state="translated">Desactiva las consultas de lectura para una conexión con un nodo esclavo de Redis Cluster.</target>
        </trans-unit>
        <trans-unit id="3c9664e573a114e8272bfbfb19ccbd51925d8d78" translate="yes" xml:space="preserve">
          <source>Distribution of returned elements</source>
          <target state="translated">Distribución de los elementos devueltos</target>
        </trans-unit>
        <trans-unit id="7ccde4db71eed2460dfb04d6817e8c9f76a501f5" translate="yes" xml:space="preserve">
          <source>Due to the single-threaded nature of Redis, it is not possible to kill a client connection while it is executing a command. From the client point of view, the connection can never be closed in the middle of the execution of a command. However, the client will notice the connection has been closed only when the next command is sent (and results in network error).</source>
          <target state="translated">Debido a la naturaleza de un solo hilo de Redis,no es posible matar la conexión de un cliente mientras está ejecutando un comando.Desde el punto de vista del cliente,la conexión nunca puede cerrarse en medio de la ejecución de un comando.Sin embargo,el cliente notará que la conexión se ha cerrado sólo cuando se envíe el siguiente comando (y se produzca un error de red).</target>
        </trans-unit>
        <trans-unit id="6781cfc8284296eb70ba05270579b9deac096a80" translate="yes" xml:space="preserve">
          <source>ECHO</source>
          <target state="translated">ECHO</target>
        </trans-unit>
        <trans-unit id="e7ec2091f33799c975a8d7a6ea9bc9b6bc50c88f" translate="yes" xml:space="preserve">
          <source>ECHO  message   Echo the given string</source>
          <target state="translated">Mensaje ECHO Echo la cuerda dada</target>
        </trans-unit>
        <trans-unit id="225a586b70502eff079ebfff31adfbc6e0bf2d35" translate="yes" xml:space="preserve">
          <source>EVAL</source>
          <target state="translated">EVAL</target>
        </trans-unit>
        <trans-unit id="ea1523936796cac657906bcb4392d72c0f622a53" translate="yes" xml:space="preserve">
          <source>EVAL  script numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVAL script numkeys key [key ...]arg [arg ...]Ejecutar un script Lua lado servidor</target>
        </trans-unit>
        <trans-unit id="8b8522c1abed78aca4ba0ae5b2f9d4375bf6841d" translate="yes" xml:space="preserve">
          <source>EVALSHA</source>
          <target state="translated">EVALSHA</target>
        </trans-unit>
        <trans-unit id="9ca231b5b5f90e450c680cb2bea30ab1800479a3" translate="yes" xml:space="preserve">
          <source>EVALSHA  sha1 numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVALSHA sha1 numkeys key [key ...]arg [arg ...]Ejecutar un script Lua lado servidor</target>
        </trans-unit>
        <trans-unit id="e29c908995e16002c05ec47ec36aaf34a1bd4b78" translate="yes" xml:space="preserve">
          <source>EVALSHA in the context of pipelining</source>
          <target state="translated">EVALSHA en el contexto de la canalización</target>
        </trans-unit>
        <trans-unit id="ea837e81db8c2bd7fcea29a56cd54086382f1f43" translate="yes" xml:space="preserve">
          <source>EXEC</source>
          <target state="translated">EXEC</target>
        </trans-unit>
        <trans-unit id="2b1156bdd8031e124d3a9ae093559b5a4386e538" translate="yes" xml:space="preserve">
          <source>EXEC   Execute all commands issued after MULTI</source>
          <target state="translated">EJECUTAR Ejecutar todos los comandos emitidos después de MULTI</target>
        </trans-unit>
        <trans-unit id="644b5806e118fe0af3936c64572a1496ddda7507" translate="yes" xml:space="preserve">
          <source>EXISTS</source>
          <target state="translated">EXISTS</target>
        </trans-unit>
        <trans-unit id="08807aa77041e8b29bbcefa207328a0789129027" translate="yes" xml:space="preserve">
          <source>EXISTS  key [key ...]   Determine if a key exists</source>
          <target state="translated">EXISTE tecla [tecla ...]Determinar si existe una tecla</target>
        </trans-unit>
        <trans-unit id="1215753c2320bb44b6a871baac293e5bf276e781" translate="yes" xml:space="preserve">
          <source>EXPIRE</source>
          <target state="translated">EXPIRE</target>
        </trans-unit>
        <trans-unit id="436d86e478f5d801c08f118762eb43ed84923c39" translate="yes" xml:space="preserve">
          <source>EXPIRE  key seconds   Set a key's time to live in seconds</source>
          <target state="translated">EXPIRAR los segundos de la tecla Establecer el tiempo de vida de una tecla en segundos</target>
        </trans-unit>
        <trans-unit id="ce90cafacba153e381a002cc83387fcbd4d6f68f" translate="yes" xml:space="preserve">
          <source>EXPIREAT</source>
          <target state="translated">EXPIREAT</target>
        </trans-unit>
        <trans-unit id="34c23f46d63812eec7d4e21acb84ed6214c2b5cc" translate="yes" xml:space="preserve">
          <source>EXPIREAT  key timestamp   Set the expiration for a key as a UNIX timestamp</source>
          <target state="translated">EXPIREAT key timestampmpmpmpmp de la clave Establecer la expiración de una clave como una marca de tiempo de UNIX</target>
        </trans-unit>
        <trans-unit id="1f423012c27396dae7aa028cc182a29eea955b66" translate="yes" xml:space="preserve">
          <source>Each failure report has a time to live of two times the &lt;em&gt;node timeout&lt;/em&gt; time.</source>
          <target state="translated">Cada informe de falla tiene un tiempo de vida de dos veces el &lt;em&gt;tiempo de espera&lt;/em&gt; del &lt;em&gt;nodo&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e89059e939f6644b3364536eb50a1abdc89a1613" translate="yes" xml:space="preserve">
          <source>Each line is composed of a succession of &lt;code&gt;property=value&lt;/code&gt; fields separated by a space character.</source>
          <target state="translated">Cada l&amp;iacute;nea est&amp;aacute; compuesta por una sucesi&amp;oacute;n de campos &lt;code&gt;property=value&lt;/code&gt; separados por un car&amp;aacute;cter de espacio.</target>
        </trans-unit>
        <trans-unit id="4918aff92ee02999f29bacd99ab30d0a000253c7" translate="yes" xml:space="preserve">
          <source>Each line is composed of the following fields:</source>
          <target state="translated">Cada línea está compuesta por los siguientes campos:</target>
        </trans-unit>
        <trans-unit id="853014cc58f5042914b68be7e44d86291316a8d3" translate="yes" xml:space="preserve">
          <source>Each nested result is:</source>
          <target state="translated">Cada resultado anidado es:</target>
        </trans-unit>
        <trans-unit id="001afdca6677847da08247ab1ec58a7506cae0eb" translate="yes" xml:space="preserve">
          <source>Each node in a Redis Cluster has its view of the current cluster configuration, given by the set of known nodes, the state of the connection we have with such nodes, their flags, properties and assigned slots, and so forth.</source>
          <target state="translated">Cada nodo de un cúmulo Redis tiene su vista de la configuración actual del cúmulo,dada por el conjunto de nodos conocidos,el estado de la conexión que tenemos con tales nodos,sus banderas,propiedades y ranuras asignadas,y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="ebe29cd1a064ec2dc6312d2e8c8e3c40f46f1f35" translate="yes" xml:space="preserve">
          <source>Each reported event has the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4031491a0a21d3efcb1ae0e642e160153ab9452c" translate="yes" xml:space="preserve">
          <source>Each result includes all active replicas of the master instance for the listed slot range. Failed replicas are not returned.</source>
          <target state="translated">Cada resultado incluye todas las réplicas activas de la instancia maestra para el rango de ranuras enumeradas.Las réplicas fallidas no se devuelven.</target>
        </trans-unit>
        <trans-unit id="39a5a1ac33abf7ccbf42de1a62abad74d800f2a8" translate="yes" xml:space="preserve">
          <source>Each subcommand is documented below. At the end you'll find a description of how live resharding is performed using this command and other related commands.</source>
          <target state="translated">Cada subcomando está documentado a continuación.Al final encontrará una descripción de cómo se realiza la remodelación en vivo usando este comando y otros comandos relacionados.</target>
        </trans-unit>
        <trans-unit id="2d0820e2ed028ade2f8d73ff5b41f73cd289b4e1" translate="yes" xml:space="preserve">
          <source>Each top-level result contains six nested results. Each nested result is:</source>
          <target state="translated">Cada resultado de nivel superior contiene seis resultados anidados.Cada resultado anidado es:</target>
        </trans-unit>
        <trans-unit id="b5f7d21b9ba2cb092f0980b7560e9cd91a246461" translate="yes" xml:space="preserve">
          <source>Effects on the node:</source>
          <target state="translated">Efectos en el nodo:</target>
        </trans-unit>
        <trans-unit id="1940e8677e72b823aadf3f1babad911e272f4f7b" translate="yes" xml:space="preserve">
          <source>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</source>
          <target state="translated">Los elementos que no estaban constantemente presentes en la colección durante una iteración completa,pueden ser devueltos o no:es indefinido.</target>
        </trans-unit>
        <trans-unit id="fa43f0d9868a88416f82c35ed64e1745c1e56215" translate="yes" xml:space="preserve">
          <source>Elements with the same score</source>
          <target state="translated">Elementos con la misma puntuación</target>
        </trans-unit>
        <trans-unit id="127cfef1e8e010cbd37725ea8863aa38e5d50815" translate="yes" xml:space="preserve">
          <source>Emitting Redis logs from scripts</source>
          <target state="translated">Emitir los registros de Redis de los guiones</target>
        </trans-unit>
        <trans-unit id="1f733b322f80ecf7300735b8315383e95cf78665" translate="yes" xml:space="preserve">
          <source>Enables read queries for a connection to a Redis Cluster replica node.</source>
          <target state="translated">Permite leer consultas para una conexión con un nodo réplica del Cluster Redis.</target>
        </trans-unit>
        <trans-unit id="6fb65c66a66392a71ca206846f2ac13ca3b45368" translate="yes" xml:space="preserve">
          <source>End slot range</source>
          <target state="translated">Finalizar el rango de la ranura</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">Manejo de errores...</target>
        </trans-unit>
        <trans-unit id="6ad4930b258ad43ab07d5ba00c43530ba3b62093" translate="yes" xml:space="preserve">
          <source>Evaluates a script cached on the server side by its SHA1 digest. Scripts are cached on the server side using the &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; command. The command is otherwise identical to &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">Eval&amp;uacute;a un script almacenado en cach&amp;eacute; en el lado del servidor por su resumen SHA1. Los scripts se almacenan en cach&amp;eacute; en el lado del servidor mediante el comando &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; . Por lo dem&amp;aacute;s, el comando es id&amp;eacute;ntico a &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3784064b237e9150f97da5ef4677aaab4b0c6d07" translate="yes" xml:space="preserve">
          <source>Even if other clients are actively pushing new items at the end of the list.</source>
          <target state="translated">Incluso si otros clientes están empujando activamente nuevos artículos al final de la lista.</target>
        </trans-unit>
        <trans-unit id="7dd20b200cf466b9bb17c87ac888deb51e1a343f" translate="yes" xml:space="preserve">
          <source>Even running instances will always check the computer clock, so for instance if you set a key with a time to live of 1000 seconds, and then set your computer time 2000 seconds in the future, the key will be expired immediately, instead of lasting for 1000 seconds.</source>
          <target state="translated">Incluso las instancias de ejecución siempre comprobarán el reloj de la computadora,así que,por ejemplo,si se establece una clave con un tiempo de vida de 1000 segundos,y luego se establece el tiempo de la computadora 2000 segundos en el futuro,la clave expirará inmediatamente,en lugar de durar 1000 segundos.</target>
        </trans-unit>
        <trans-unit id="d27fcdec12658758c11ddcfe5132a9543098333e" translate="yes" xml:space="preserve">
          <source>Event name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad3a7a35d62cd7230213de79ba4b1043488e12a" translate="yes" xml:space="preserve">
          <source>Eventually if all the entries in a macro-node are marked as deleted, the whole node is destroyed and the memory reclaimed. This means that if you delete a large amount of entries from a stream, for instance more than 50% of the entries appended to the stream, the memory usage per entry may increment, since what happens is that the stream will start to be fragmented. However the stream performances will remain the same.</source>
          <target state="translated">Eventualmente,si todas las entradas de un macro-nodo son marcadas como borradas,el nodo entero es destruido y la memoria recuperada.Esto significa que si se borra una gran cantidad de entradas de un flujo,por ejemplo más del 50% de las entradas añadidas al flujo,el uso de memoria por entrada puede incrementarse,ya que lo que ocurre es que el flujo comenzará a fragmentarse.Sin embargo,las prestaciones del stream seguirán siendo las mismas.</target>
        </trans-unit>
        <trans-unit id="792161cf042fd5babb68da92f1bbb2902dc3526e" translate="yes" xml:space="preserve">
          <source>Every Redis instance is &lt;em&gt;guaranteed&lt;/em&gt; to have all the above libraries so you can be sure that the environment for your Redis scripts is always the same.</source>
          <target state="translated">Se &lt;em&gt;garantiza&lt;/em&gt; que cada instancia de Redis tiene todas las bibliotecas anteriores, por lo que puede estar seguro de que el entorno para sus scripts de Redis es siempre el mismo.</target>
        </trans-unit>
        <trans-unit id="ff1000733402cd15305f0a4763cbc390865561a4" translate="yes" xml:space="preserve">
          <source>Every entry is composed of four (or six starting with Redis 4.0) fields:</source>
          <target state="translated">Cada entrada se compone de cuatro (o seis empezando por Redis 4.0)campos:</target>
        </trans-unit>
        <trans-unit id="c3f1325124fc7f8408e9843db0ab98baea3e119b" translate="yes" xml:space="preserve">
          <source>Every new connection starts without an assigned name.</source>
          <target state="translated">Cada nueva conexión comienza sin un nombre asignado.</target>
        </trans-unit>
        <trans-unit id="51df853590a285fd9b12bc8e0d4650ccb232f700" translate="yes" xml:space="preserve">
          <source>Every time a node processes gossip packets from other nodes, it creates (and refreshes the TTL if needed) &lt;strong&gt;failure reports&lt;/strong&gt;, remembering that a given node said another given node is in &lt;code&gt;PFAIL&lt;/code&gt; condition.</source>
          <target state="translated">Cada vez que un nodo procesa paquetes de chismes de otros nodos, crea (y actualiza el TTL si es necesario) &lt;strong&gt;informes de fallas&lt;/strong&gt; , recordando que un nodo dado dijo que otro nodo dado est&amp;aacute; en &lt;code&gt;PFAIL&lt;/code&gt; condici&amp;oacute;n PFAIL .</target>
        </trans-unit>
        <trans-unit id="c8f9b9897ccaf6988795d0fa2e49d6b67f29b456" translate="yes" xml:space="preserve">
          <source>Every time a user performs a page view, the application can register that in the current day the user visited the web site using the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command setting the bit corresponding to the current day.</source>
          <target state="translated">Cada vez que un usuario realiza una vista de p&amp;aacute;gina, la aplicaci&amp;oacute;n puede registrar que en el d&amp;iacute;a actual el usuario visit&amp;oacute; el sitio web usando el comando &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; configurando el bit correspondiente al d&amp;iacute;a actual.</target>
        </trans-unit>
        <trans-unit id="434360186a18d9c330717a5f17d631c11575acb2" translate="yes" xml:space="preserve">
          <source>Every time this script executed the resulting list will have exactly the following elements:</source>
          <target state="translated">Cada vez que este guión se ejecute,la lista resultante tendrá exactamente los siguientes elementos:</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="815030c996b00efbe374a3c45d7121d3e9fc4929" translate="yes" xml:space="preserve">
          <source>Example of zero padding:</source>
          <target state="translated">Ejemplo de acolchado cero:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="c687d1b70c080536289366ba8155bc643fc72076" translate="yes" xml:space="preserve">
          <source>Exclusive intervals and infinity</source>
          <target state="translated">Intervalos exclusivos e infinito</target>
        </trans-unit>
        <trans-unit id="114f30848cb8a83d62c97a5a6476b435a78150bd" translate="yes" xml:space="preserve">
          <source>Exclusive ranges</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55912897a10d768ac59806e69e2501c331778457" translate="yes" xml:space="preserve">
          <source>Exclusive ranges and iterating the PEL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e788d736a6e3a42271b3b6edc6a324f07e11667" translate="yes" xml:space="preserve">
          <source>Executed scripts are guaranteed to be in the script cache of a given execution of a Redis instance forever. This means that if an &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is performed against a Redis instance all the subsequent &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; calls will succeed.</source>
          <target state="translated">Se garantiza que los scripts ejecutados estar&amp;aacute;n en el cach&amp;eacute; de scripts de una ejecuci&amp;oacute;n determinada de una instancia de Redis para siempre. Esto significa que si se realiza una &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; en una instancia de Redis, todas las llamadas &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; posteriores se realizar&amp;aacute;n correctamente.</target>
        </trans-unit>
        <trans-unit id="446763d77e17832a47ad829663f2f4ba29ce76f7" translate="yes" xml:space="preserve">
          <source>Executes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">Ejecuta todos los comandos previamente puestos en cola en una &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transacci&amp;oacute;n&lt;/a&gt; y restaura el estado de conexi&amp;oacute;n a normal.</target>
        </trans-unit>
        <trans-unit id="d80b1a46f6734fb75c0119610c9901aef0c08607" translate="yes" xml:space="preserve">
          <source>Executing a Lua Script with Redis 2.6 or newer.</source>
          <target state="translated">Ejecutando un guión de Lua con Redis 2.6 o más reciente.</target>
        </trans-unit>
        <trans-unit id="e1a9d983dc0912bcd36f098a1b8c4b6851a2ccbc" translate="yes" xml:space="preserve">
          <source>Expire accuracy</source>
          <target state="translated">Expirar la precisión</target>
        </trans-unit>
        <trans-unit id="5bbbfc0dcb3f1ea6203152c364bf711f30071354" translate="yes" xml:space="preserve">
          <source>Expires and persistence</source>
          <target state="translated">Caducidad y persistencia</target>
        </trans-unit>
        <trans-unit id="a4432b0943d588c17ab5d7e63d136bb9786a862c" translate="yes" xml:space="preserve">
          <source>Extended form of XPENDING</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceae3e065a822da58b9dd577a4a2215264628a2c" translate="yes" xml:space="preserve">
          <source>FLUSHALL</source>
          <target state="translated">FLUSHALL</target>
        </trans-unit>
        <trans-unit id="a1dc7fedbb3161c8d2db024cd3ee46e2af26f812" translate="yes" xml:space="preserve">
          <source>FLUSHALL  [ASYNC]   Remove all keys from all databases</source>
          <target state="translated">FLUSHALL [ASYNC]Eliminar todas las claves de todas las bases de datos</target>
        </trans-unit>
        <trans-unit id="10bb3c2c2d36018ba538d533264f2171634a8d95" translate="yes" xml:space="preserve">
          <source>FLUSHDB</source>
          <target state="translated">FLUSHDB</target>
        </trans-unit>
        <trans-unit id="b40b961b1c26ac58fbd9ac2f12f0c446fb2897d9" translate="yes" xml:space="preserve">
          <source>FLUSHDB  [ASYNC]   Remove all keys from the current database</source>
          <target state="translated">FLUSHDB [ASYNC]Eliminar todas las claves de la base de datos actual</target>
        </trans-unit>
        <trans-unit id="a5f0b2c20a29e7587597abea3e79fa609ca01e4c" translate="yes" xml:space="preserve">
          <source>FORCE option: manual failover when the master is down</source>
          <target state="translated">Opción FUERZA:conmutación manual cuando el maestro está caído</target>
        </trans-unit>
        <trans-unit id="f9c28b26fa472599864dea91ca5f8cd92a5475d7" translate="yes" xml:space="preserve">
          <source>Failures to authenticate their connections with &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; or &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0878bdd16e36ba72b474afe51ae9c582fef6d5" translate="yes" xml:space="preserve">
          <source>Fetching a single entry from a stream, providing the ID of the entry to fetch two times: as start and end of the query interval.</source>
          <target state="translated">Obtención de una única entrada de un flujo,proporcionando la identificación de la entrada para obtener dos veces:como inicio y fin del intervalo de consulta.</target>
        </trans-unit>
        <trans-unit id="d11485369737f36370f75a3ff43b46d72effc624" translate="yes" xml:space="preserve">
          <source>Fetching data from a stream via a consumer group, and not acknowledging such data, has the effect of creating &lt;em&gt;pending entries&lt;/em&gt;. This is well explained in the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command, and even better in our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command will immediately remove the pending entry from the Pending Entry List (PEL) since once a message is successfully processed, there is no longer need for the consumer group to track it and to remember the current owner of the message.</source>
          <target state="translated">Obtener datos de un flujo a trav&amp;eacute;s de un grupo de consumidores y no reconocer dichos datos tiene el efecto de crear &lt;em&gt;entradas pendientes&lt;/em&gt; . Esto est&amp;aacute; bien explicado en el comando &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; y a&amp;uacute;n mejor en nuestra &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introducci&amp;oacute;n a Redis Streams&lt;/a&gt; . El &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; comando eliminar&amp;aacute; inmediatamente la entrada pendiente de la Lista de entradas pendientes (PEL), ya que una vez que un mensaje se procesa con &amp;eacute;xito, ya no es necesario que el grupo de consumidores lo rastree y recuerde al propietario actual del mensaje.</target>
        </trans-unit>
        <trans-unit id="13b9c9d38a4b96f103ca63910ffc56743e00fd12" translate="yes" xml:space="preserve">
          <source>Fetching single items</source>
          <target state="translated">Buscar artículos sueltos</target>
        </trans-unit>
        <trans-unit id="894f8f81f5445488b186c9a058eccf6bacfbb0db" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommand:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8330be22b4e169fe5141dfbcacb82dc81724e13f" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommnad:</source>
          <target state="translated">Finalmente, es posible obtener ayuda del comando, en caso de que el usuario no recuerde la sintaxis exacta, usando &lt;code&gt;HELP&lt;/code&gt; subcommnad :</target>
        </trans-unit>
        <trans-unit id="5388f4a7abea666722d4311743c9d3e1d5bfc3b1" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get the list of every consumer in a specific consumer group:</source>
          <target state="translated">Por último,es posible obtener la lista de todos los consumidores de un grupo de consumidores específico:</target>
        </trans-unit>
        <trans-unit id="7cbe1b741345fc3839fb4d58149e9dd7af6c272a" translate="yes" xml:space="preserve">
          <source>Finally it is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">Por último,es posible pasar un argumento adicional al comando,para ver los mensajes que tienen un propietario específico:</target>
        </trans-unit>
        <trans-unit id="58b2c6378bac42febc100a9e0341d2094c29e52e" translate="yes" xml:space="preserve">
          <source>Finally it possible to set the next message to deliver using the &lt;code&gt;SETID&lt;/code&gt; subcommand. Normally the next ID is set when the consumer is created, as the last argument of &lt;code&gt;XGROUP CREATE&lt;/code&gt;. However using this form the next ID can be modified later without deleting and creating the consumer group again. For instance if you want the consumers in a consumer group to re-process all the messages in a stream, you may want to set its next ID to 0:</source>
          <target state="translated">Finalmente, es posible configurar el siguiente mensaje para entregar usando el subcomando &lt;code&gt;SETID&lt;/code&gt; . Normalmente, la siguiente ID se establece cuando se crea el consumidor, como &amp;uacute;ltimo argumento de &lt;code&gt;XGROUP CREATE&lt;/code&gt; . Sin embargo, al usar este formulario, la siguiente ID se puede modificar m&amp;aacute;s tarde sin eliminar y volver a crear el grupo de consumidores. Por ejemplo, si desea que los consumidores de un grupo de consumidores vuelvan a procesar todos los mensajes en una secuencia, es posible que desee establecer su siguiente ID en 0:</target>
        </trans-unit>
        <trans-unit id="53e0098dbba7db3bdb2ae206e024574f2dd74ced" translate="yes" xml:space="preserve">
          <source>Finally to also have the match len:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8081b937f79256e42e7fd856b20cf39a90419c3e" translate="yes" xml:space="preserve">
          <source>Finally to get some help if you don't remember the syntax, use the HELP subcommand:</source>
          <target state="translated">Por último,si no recuerdas la sintaxis,usa el subcomando HELP:</target>
        </trans-unit>
        <trans-unit id="4827d8054bd5c8af82f3e09e291390e27412f49f" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;MAXLEN&lt;/code&gt; option tells the command to compare the provided element only with a given maximum number of list items. So for instance specifying &lt;code&gt;MAXLEN 1000&lt;/code&gt; will make sure that the command performs only 1000 comparisons, effectively running the algorithm on a subset of the list (the first part or the last part depending on the fact we use a positive or negative rank). This is useful to limit the maximum complexity of the command. It is also useful when we expect the match to be found very early, but want to be sure that in case this is not true, the command does not take too much time to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc63c9b0ba92886f08fc9cdd2dca430983266b7e" translate="yes" xml:space="preserve">
          <source>First Key in Argument List</source>
          <target state="translated">Primera clave de la lista de argumentos</target>
        </trans-unit>
        <trans-unit id="a8e315abf463cfb1c344b54fca5c387403cc9c5a" translate="yes" xml:space="preserve">
          <source>First replica of master for slot range</source>
          <target state="translated">La primera réplica del maestro para el rango de las tragaperras</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="4e0b6894626b05a7f879581f17814069cc8b9e6d" translate="yes" xml:space="preserve">
          <source>Flush the Append Only File if AOF is enabled.</source>
          <target state="translated">Limpie el archivo &quot;Append Only&quot; si el AOF está activado.</target>
        </trans-unit>
        <trans-unit id="3b424754326ab3315277697bc94804652181fadd" translate="yes" xml:space="preserve">
          <source>Flush the Lua scripts cache.</source>
          <target state="translated">Limpia el caché de los guiones de Lua.</target>
        </trans-unit>
        <trans-unit id="f6bb844e2e06d69091cb567be5df64888a2d1098" translate="yes" xml:space="preserve">
          <source>Flushes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">Vac&amp;iacute;a todos los comandos previamente puestos en cola en una &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transacci&amp;oacute;n&lt;/a&gt; y restaura el estado de conexi&amp;oacute;n a normal.</target>
        </trans-unit>
        <trans-unit id="8c64c01f5213c6c086d3f83c900e781d98a8b4d5" translate="yes" xml:space="preserve">
          <source>Flushes all the previously watched keys for a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">Descarga todas las claves previamente observadas para una &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transacci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e859a22c051906372e6ed21806faadd4fdf27b1c" translate="yes" xml:space="preserve">
          <source>For Redis 2.6 what happens is that the command performing multiple pushes is executed, and &lt;em&gt;only after&lt;/em&gt; the execution of the command the blocked clients are served. Consider this sequence of commands.</source>
          <target state="translated">Para Redis 2.6, lo que sucede es que el comando que realiza m&amp;uacute;ltiples empujes se ejecuta, y &lt;em&gt;solo despu&amp;eacute;s&lt;/em&gt; la ejecuci&amp;oacute;n del comando se atienden los clientes bloqueados. Considere esta secuencia de comandos.</target>
        </trans-unit>
        <trans-unit id="c9543ba9d8e4550fc68513216cde163b99c314dc" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;WEIGHTS&lt;/code&gt; and &lt;code&gt;AGGREGATE&lt;/code&gt; options, see &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;.</source>
          <target state="translated">Para una descripci&amp;oacute;n de las &lt;code&gt;WEIGHTS&lt;/code&gt; y &lt;code&gt;AGGREGATE&lt;/code&gt; opciones, consulte &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9618151d729f751e6074523159514ecdfdb57ef1" translate="yes" xml:space="preserve">
          <source>For an introduction to HyperLogLog data structure check the &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; command page.</source>
          <target state="translated">Para obtener una introducci&amp;oacute;n a la estructura de datos de HyperLogLog, consulte la p&amp;aacute;gina de comandos &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6fcc6360d01cc6597619a76bd12e34dfa8c068d5" translate="yes" xml:space="preserve">
          <source>For an introduction to sorted sets, see the data types page on &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted sets&lt;/a&gt;.</source>
          <target state="translated">Para obtener una introducci&amp;oacute;n a los conjuntos ordenados, consulte la p&amp;aacute;gina de tipos de datos sobre &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;conjuntos ordenados&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e36005d4ed916277f75df55af354619d0ef5d5b" translate="yes" xml:space="preserve">
          <source>For each command type, the following line is added:</source>
          <target state="translated">Para cada tipo de comando,se añade la siguiente línea:</target>
        </trans-unit>
        <trans-unit id="e6d8b4b7b9b4f1b118134e1b85eed9b0b1555262" translate="yes" xml:space="preserve">
          <source>For each consumer group listed the command also shows the number of consumers known in that group and the pending messages (delivered but not yet acknowledged) in that group.</source>
          <target state="translated">Para cada grupo de consumidores enumerados,el comando muestra también el número de consumidores conocidos en ese grupo y los mensajes pendientes (entregados pero aún no reconocidos)en ese grupo.</target>
        </trans-unit>
        <trans-unit id="2f01796f139a1dd83db65e8858f0ea9b62d77fdf" translate="yes" xml:space="preserve">
          <source>For each database, the following line is added:</source>
          <target state="translated">Para cada base de datos,se añade la siguiente línea:</target>
        </trans-unit>
        <trans-unit id="0553e67e4dc3e5df5405dbaf017a41c48cd92358" translate="yes" xml:space="preserve">
          <source>For each replica, the following line is added:</source>
          <target state="translated">Para cada réplica,se añade la siguiente línea:</target>
        </trans-unit>
        <trans-unit id="4121db15148ef3ce1e89f4557d512e7c05a4cd89" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;field&lt;/code&gt; that does not exist in the hash, a &lt;code&gt;nil&lt;/code&gt; value is returned. Because non-existing keys are treated as empty hashes, running &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; against a non-existing &lt;code&gt;key&lt;/code&gt; will return a list of &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">Por cada &lt;code&gt;field&lt;/code&gt; que no existe en el hash, se devuelve un valor &lt;code&gt;nil&lt;/code&gt; . Debido a que las claves no existentes se tratan como hashes vac&amp;iacute;os, ejecutar &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; contra una &lt;code&gt;key&lt;/code&gt; no existente devolver&amp;aacute; una lista de valores &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdc0b5372eb98dde6f0761af59221e15f0a9f9e" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;member&lt;/code&gt; that does not exist in the sorted set, a &lt;code&gt;nil&lt;/code&gt; value is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4313528e119e8db789aa6be23b8a03a247c203b4" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;member&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; is returned if the value is a member of the set, or &lt;code&gt;0&lt;/code&gt; if the element is not a member of the set or if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b69fc5b2026538496f23b6b8fb03889d7e1936d3" translate="yes" xml:space="preserve">
          <source>For eviction purposes, you may use the &lt;code&gt;IDLETIME&lt;/code&gt; or &lt;code&gt;FREQ&lt;/code&gt; modifiers. See &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; for more information (Redis 5.0 or greater).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="910c18521d782016253b4584c3c1718149e1c25d" translate="yes" xml:space="preserve">
          <source>For example a common problem when implementing Markov chains and other algorithms is to select an element at random from a set, but different elements may have different weights that change how likely it is they are picked.</source>
          <target state="translated">Por ejemplo,un problema común al aplicar las cadenas de Markov y otros algoritmos es seleccionar un elemento al azar de un conjunto,pero los diferentes elementos pueden tener diferentes pesos que cambian la probabilidad de que sean elegidos.</target>
        </trans-unit>
        <trans-unit id="00e8032c1c0863c866e402146d15139ddaca7eea" translate="yes" xml:space="preserve">
          <source>For example in order to take the count of all the unique search queries performed in a day, a program needs to call &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; every time a query is processed. The estimated number of unique queries can be retrieved with &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; at any time.</source>
          <target state="translated">Por ejemplo, para contar todas las consultas de b&amp;uacute;squeda &amp;uacute;nicas realizadas en un d&amp;iacute;a, un programa debe llamar a &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; cada vez que se procesa una consulta. El n&amp;uacute;mero estimado de consultas &amp;uacute;nicas se puede recuperar con &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; en cualquier momento.</target>
        </trans-unit>
        <trans-unit id="862ca7fa622c308433f665edc841f44e39e5d232" translate="yes" xml:space="preserve">
          <source>For example the following command assigns slots 1 2 3 to the node receiving the command:</source>
          <target state="translated">Por ejemplo,el siguiente comando asigna las ranuras 1 2 3 al nodo que recibe el comando:</target>
        </trans-unit>
        <trans-unit id="49606e7b6de7a4d4946192e9ed0aa5fb1d49ac0b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 5 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b525686b0a28b28e11781b09afa87dd48c9db63b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 8 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">Por ejemplo,el siguiente comando incrementa un entero con signo de 8 bits en el offset de bits 100,y obtiene el valor del entero sin signo de 4 bits en el offset de bits 0:</target>
        </trans-unit>
        <trans-unit id="a97e5209e5c4a8fe8fdeedf84b0123aa8fa78b8b" translate="yes" xml:space="preserve">
          <source>For example the following command will trim the stream to exactly the latest 1000 items:</source>
          <target state="translated">Por ejemplo,el siguiente comando recortará la corriente a exactamente los últimos 1000 artículos:</target>
        </trans-unit>
        <trans-unit id="bb5422e2190f7f64ad2cf5faf5279a8730064c02" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; will remove the last two occurrences of &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in the list stored at &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; eliminar&amp;aacute; las dos &amp;uacute;ltimas apariciones de &lt;code&gt;&quot;hello&quot;&lt;/code&gt; en la lista almacenada en &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="806b6380a574787b8a29a883731b6c80cdcdcc0d" translate="yes" xml:space="preserve">
          <source>For example, after setting a few bits, getting the string value of the bitmap would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b555dc3155500027017fa2a4b40d9e13b0289813" translate="yes" xml:space="preserve">
          <source>For example, if I have two streams &lt;code&gt;mystream&lt;/code&gt; and &lt;code&gt;writers&lt;/code&gt;, and I want to read data from both the streams starting from the first element they contain, I could call &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; like in the following example.</source>
          <target state="translated">Por ejemplo, si tengo dos flujos &lt;code&gt;mystream&lt;/code&gt; y &lt;code&gt;writers&lt;/code&gt; , y quiero leer datos de ambos flujos comenzando desde el primer elemento que contienen, podr&amp;iacute;a llamar a &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; como en el siguiente ejemplo.</target>
        </trans-unit>
        <trans-unit id="cd44de0983e01c60e504cf2bf01e0f7c36d85e53" translate="yes" xml:space="preserve">
          <source>For example, the example above could be replaced by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d36a4d27e7c4e26652f2b3ff43e697bb99cdbe49" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; will modify the list stored at &lt;code&gt;foobar&lt;/code&gt; so that only the first three elements of the list will remain.</source>
          <target state="translated">Por ejemplo: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; modificar&amp;aacute; la lista almacenada en &lt;code&gt;foobar&lt;/code&gt; para que solo queden los primeros tres elementos de la lista.</target>
        </trans-unit>
        <trans-unit id="aac3daaf191be281b6ccb464e390234af5058fcd" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo: considere la &lt;code&gt;source&lt;/code&gt; con la lista &lt;code&gt;a,b,c&lt;/code&gt; , y el &lt;code&gt;destination&lt;/code&gt; con la lista &lt;code&gt;x,y,z&lt;/code&gt; . Ejecuci&amp;oacute;n &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; resultados en &lt;code&gt;source&lt;/code&gt; que sostienen &lt;code&gt;a,b&lt;/code&gt; y &lt;code&gt;destination&lt;/code&gt; de sujeci&amp;oacute;n &lt;code&gt;c,x,y,z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58bac03f69d7fb418a6dae21d7a1d10de406cdc5" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;code&gt;LMOVE source destination RIGHT LEFT&lt;/code&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a6b3077ebbc22869bdfb44c11c89f9170d1471" translate="yes" xml:space="preserve">
          <source>For expires to work well, the computer time must be taken stable. If you move an RDB file from two computers with a big desync in their clocks, funny things may happen (like all the keys loaded to be expired at loading time).</source>
          <target state="translated">Para que los cadáveres funcionen bien,el tiempo de la computadora debe tomarse estable.Si mueves un archivo RDB de dos ordenadores con un gran desincronizador en sus relojes,pueden ocurrir cosas divertidas (como que todas las llaves cargadas caduquen a la hora de cargar).</target>
        </trans-unit>
        <trans-unit id="f28bf0b4c581b256fa3b954009c5dc47ca8cc986" translate="yes" xml:space="preserve">
          <source>For further information about Redis streams please check our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams document&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las transmisiones de Redis, consulte nuestro documento de &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introducci&amp;oacute;n a las&lt;/a&gt; transmisiones de Redis .</target>
        </trans-unit>
        <trans-unit id="9419f194b12efba96ec9e9a8a47640ef77051d15" translate="yes" xml:space="preserve">
          <source>For instance an application with a persistent connection to Redis can be sure that if a script was sent once it is still in memory, so EVALSHA can be used against those scripts in a pipeline without the chance of an error being generated due to an unknown script (we'll see this problem in detail later).</source>
          <target state="translated">Por ejemplo,una aplicación con una conexión persistente a Redis puede estar segura de que si un script fue enviado una vez que todavía está en memoria,entonces EVALSHA puede utilizarse contra esos scripts en un pipeline sin la posibilidad de que se genere un error debido a un script desconocido (veremos este problema en detalle más adelante).</target>
        </trans-unit>
        <trans-unit id="dc915bb7cfa9bbec54b9f20262e4f69d0c2936e5" translate="yes" xml:space="preserve">
          <source>For instance in the above example, the last items that we received for the stream &lt;code&gt;mystream&lt;/code&gt; has ID &lt;code&gt;1526999352406-0&lt;/code&gt;, while for the stream &lt;code&gt;writers&lt;/code&gt; has the ID &lt;code&gt;1526985685298-0&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, en el ejemplo anterior, los &amp;uacute;ltimos elementos que recibimos para el flujo &lt;code&gt;mystream&lt;/code&gt; tienen el ID &lt;code&gt;1526999352406-0&lt;/code&gt; , mientras que para los &lt;code&gt;writers&lt;/code&gt; flujo tienen el ID &lt;code&gt;1526985685298-0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12e98a029b908a48582debab0c6f730b78e90807" translate="yes" xml:space="preserve">
          <source>For instance the LCS between &quot;foo&quot; and &quot;fao&quot; is &quot;fo&quot;, since scanning the two strings from left to right, the longest common set of characters is composed of the first &quot;f&quot; and then the &quot;o&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abfec42c58b79c70de1796787342d5de058e9f11" translate="yes" xml:space="preserve">
          <source>For instance what in &lt;code&gt;redis.conf&lt;/code&gt; looks like:</source>
          <target state="translated">Por ejemplo, c&amp;oacute;mo se ve en &lt;code&gt;redis.conf&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="310775bb715bff8a1231237bf82d220b152e2252" translate="yes" xml:space="preserve">
          <source>For instance when Redis is used in order to implement a queue, producers and consumers of messages may want to set the name of the connection according to their role.</source>
          <target state="translated">Por ejemplo,cuando se utiliza Redis para poner en marcha una cola,los productores y consumidores de mensajes pueden querer establecer el nombre de la conexión según su función.</target>
        </trans-unit>
        <trans-unit id="de61480f11e8a3010955bfd7cae332ac3deef0b2" translate="yes" xml:space="preserve">
          <source>For instance, in the above example the element &quot;c&quot; is present multiple times, if I want the index of the second match, I'll write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42fe68157034ba62944abb2ee31fe519ec8ceb83" translate="yes" xml:space="preserve">
          <source>For more information about replication in Redis please check the &lt;a href=&quot;https://redis.io/topics/replication&quot;&gt;replication page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14c631da3e9eabaf78a7f5c398db9fc1eb1c9a2" translate="yes" xml:space="preserve">
          <source>For more information refer to the &lt;a href=&quot;https://redis.io/topics/latency-monitor&quot;&gt;Latency Monitoring Framework page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1d2a650d31219d2da12b4e4c6aaa52db811850" translate="yes" xml:space="preserve">
          <source>For most commands the first key is position 1. Position 0 is always the command name itself.</source>
          <target state="translated">Para la mayoría de los comandos la primera tecla es la posición 1.La posición 0 es siempre el nombre del comando en sí.</target>
        </trans-unit>
        <trans-unit id="f3b735d69f1d53bb920c323089af35c7960cd5bc" translate="yes" xml:space="preserve">
          <source>For nested data types, the optional &lt;code&gt;SAMPLES&lt;/code&gt; option can be provided, where &lt;code&gt;count&lt;/code&gt; is the number of sampled nested values. By default, this option is set to &lt;code&gt;5&lt;/code&gt;. To sample the all of the nested values, use &lt;code&gt;SAMPLES 0&lt;/code&gt;.</source>
          <target state="translated">Para los tipos de datos anidados, se puede proporcionar la opci&amp;oacute;n &lt;code&gt;SAMPLES&lt;/code&gt; opcional , donde el &lt;code&gt;count&lt;/code&gt; es el n&amp;uacute;mero de valores anidados muestreados. De forma predeterminada, esta opci&amp;oacute;n est&amp;aacute; establecida en &lt;code&gt;5&lt;/code&gt; . Para muestrear todos los valores anidados, use &lt;code&gt;SAMPLES 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29cc98c67031f5feb4c8c0734d6bcf119180ebd0" translate="yes" xml:space="preserve">
          <source>For real-time metrics and statistics involving large inputs a good approach is to use a replica (with read-only option disabled) where the bit-wise operations are performed to avoid blocking the master instance.</source>
          <target state="translated">Para las métricas y estadísticas en tiempo real que implican grandes entradas,un buen enfoque es utilizar una réplica (con la opción de sólo lectura desactivada)en la que se realicen las operaciones de bits para evitar el bloqueo de la instancia maestra.</target>
        </trans-unit>
        <trans-unit id="86c11a7ed67c320eacf7f860ba9da8b316757034" translate="yes" xml:space="preserve">
          <source>For security concerns, certain special administration commands like &lt;code&gt;CONFIG&lt;/code&gt; are not logged into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; output.</source>
          <target state="translated">Por cuestiones de seguridad, ciertos comandos de administraci&amp;oacute;n especiales como &lt;code&gt;CONFIG&lt;/code&gt; no se registran en la salida de &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="906c5a5f8c50388c930df8c6fdc394c6fc2a805e" translate="yes" xml:space="preserve">
          <source>For the LCS algorithm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c60647d6f0b610c394981eaeb8a9621bab7be5" translate="yes" xml:space="preserve">
          <source>For the subsequent calls, you'll need to programmatically advance the last entry's ID returned. Most Redis client should abstract this detail, but the implementation can also be in the application if needed. In the example above, this means incrementing the sequence of &lt;code&gt;1526985685298-0&lt;/code&gt; by one, from 0 to 1. The second call would, therefore, be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4a1b4aeeb486fd399846319b2294f91ddedb8b" translate="yes" xml:space="preserve">
          <source>For this reason, Redis 3.2 introduces a new command that only works when script effects replication is enabled, and is able to control the scripting replication engine. The command is called &lt;code&gt;redis.set_repl()&lt;/code&gt; and fails raising an error if called when script effects replication is disabled.</source>
          <target state="translated">Por esta raz&amp;oacute;n, Redis 3.2 presenta un nuevo comando que solo funciona cuando la replicaci&amp;oacute;n de efectos de secuencia de comandos est&amp;aacute; habilitada y puede controlar el motor de replicaci&amp;oacute;n de secuencias de comandos. El comando se llama &lt;code&gt;redis.set_repl()&lt;/code&gt; y no genera un error si se llama cuando la replicaci&amp;oacute;n de efectos de script est&amp;aacute; deshabilitada.</target>
        </trans-unit>
        <trans-unit id="51865baeeba9dd27720c605912d3014b8edbbb78" translate="yes" xml:space="preserve">
          <source>Forces a node to save the &lt;code&gt;nodes.conf&lt;/code&gt; configuration on disk. Before to return the command calls &lt;code&gt;fsync(2)&lt;/code&gt; in order to make sure the configuration is flushed on the computer disk.</source>
          <target state="translated">Obliga a un nodo a guardar la configuraci&amp;oacute;n de &lt;code&gt;nodes.conf&lt;/code&gt; en el disco. Antes de devolver, el comando llama a &lt;code&gt;fsync(2)&lt;/code&gt; para asegurarse de que la configuraci&amp;oacute;n se vac&amp;iacute;e en el disco de la computadora.</target>
        </trans-unit>
        <trans-unit id="620cbfd5798a03238a582c36dc6180b1d68a8181" translate="yes" xml:space="preserve">
          <source>Fortunately, it's possible to avoid this issue using the following algorithm. Let's see how C4, our sane client, uses the good algorithm:</source>
          <target state="translated">Afortunadamente,es posible evitar este problema usando el siguiente algoritmo.Veamos cómo C4,nuestro cliente cuerdo,utiliza el buen algoritmo:</target>
        </trans-unit>
        <trans-unit id="e02d5afefc425c600d8eecdd85f79d3604e46010" translate="yes" xml:space="preserve">
          <source>From the point of view of the syntax, the commands are almost the same, however &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;&lt;em&gt;requires&lt;/em&gt; a special and mandatory option:</source>
          <target state="translated">Desde el punto de vista de la sintaxis, los comandos son casi los mismos, sin embargo &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP &lt;/a&gt;&lt;em&gt;requiere&lt;/em&gt; una opci&amp;oacute;n especial y obligatoria:</target>
        </trans-unit>
        <trans-unit id="86f3ae974780a50a7664a8c324379a24cfdab877" translate="yes" xml:space="preserve">
          <source>Fun fact: Reddit's 2017 April fools' project &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r/place&lt;/a&gt; was &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;built using the Redis BITFIELD command&lt;/a&gt; in order to take an in-memory representation of the collaborative canvas.</source>
          <target state="translated">Dato curioso: el proyecto &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r / place de &lt;/a&gt;&lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;los inocentes de&lt;/a&gt; Reddit de 2017 se cre&amp;oacute; utilizando el comando Redis BITFIELD para tomar una representaci&amp;oacute;n en memoria del lienzo colaborativo.</target>
        </trans-unit>
        <trans-unit id="53eb3603814482cd94f53dcb8dd480c97fb7a365" translate="yes" xml:space="preserve">
          <source>Furthermore, the following commands are also not logged:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ad85263278e1f788abee93dcd93c6b5f400940" translate="yes" xml:space="preserve">
          <source>GEOADD</source>
          <target state="translated">GEOADD</target>
        </trans-unit>
        <trans-unit id="fe36dd170b2d009a6fb9b3209da995c6be0a8014" translate="yes" xml:space="preserve">
          <source>GEOADD  key longitude latitude member [longitude latitude member ...]   Add one or more geospatial items in the geospatial index represented using a sorted set</source>
          <target state="translated">GEOADD key longitude latitude member [miembro de longitud y latitud ...]Añadir uno o más elementos geoespaciales en el índice geoespacial representado mediante un conjunto ordenado</target>
        </trans-unit>
        <trans-unit id="9aee98cec79ef9607b17d14a98e26344f2559e24" translate="yes" xml:space="preserve">
          <source>GEODIST</source>
          <target state="translated">GEODIST</target>
        </trans-unit>
        <trans-unit id="d87009d6893410d7c22a72e0781ff862c94b8508" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [m|km|ft|mi]   Returns the distance between two members of a geospatial index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a8e4fd28c6ceedcd2cf757094650298262be7f7" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [unit]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">GEODISTA miembro clave1 miembro2 [unidad]Devuelve la distancia entre dos miembros de un índice geoespacial</target>
        </trans-unit>
        <trans-unit id="d944f228d17ba584e232ef6b37a2330565210913" translate="yes" xml:space="preserve">
          <source>GEOHASH</source>
          <target state="translated">GEOHASH</target>
        </trans-unit>
        <trans-unit id="15d5ff901e592f20465c4a81d62cdf535660ac71" translate="yes" xml:space="preserve">
          <source>GEOHASH  key member [member ...]   Returns members of a geospatial index as standard geohash strings</source>
          <target state="translated">GEOHASH key member [member ...]Devuelve los miembros de un índice geoespacial como cadenas estándar de geohash</target>
        </trans-unit>
        <trans-unit id="567f488d82e3265931365c2760b37b40e268471e" translate="yes" xml:space="preserve">
          <source>GEOPOS</source>
          <target state="translated">GEOPOS</target>
        </trans-unit>
        <trans-unit id="681795a057130a9988e5c024a1915dc60c2ecb58" translate="yes" xml:space="preserve">
          <source>GEOPOS  key member [member ...]   Returns longitude and latitude of members of a geospatial index</source>
          <target state="translated">Miembro clave del GEOPOS [miembro ...]Devuelve la longitud y la latitud de los miembros de un índice geoespacial</target>
        </trans-unit>
        <trans-unit id="f883ad1ea5b9628a7c035af52696e8e216f48428" translate="yes" xml:space="preserve">
          <source>GEORADIUS</source>
          <target state="translated">GEORADIUS</target>
        </trans-unit>
        <trans-unit id="78a8e700f33e02c64280e94efe97493736549c5c" translate="yes" xml:space="preserve">
          <source>GEORADIUS  key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point</source>
          <target state="translated">Clave de GEORADIO longitud latitud radio m|km|ft|mi [CON CÓDIGO][DESHACER][CUENTA][ASC|DESC][ALMACENAR][ALMACENAR]Consulta un conjunto clasificado que representa un índice geoespacial para buscar miembros que coincidan con una distancia máxima dada de un punto</target>
        </trans-unit>
        <trans-unit id="ae4c6b87ec31f7b6af274155550a43bc379afb42" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER</source>
          <target state="translated">GEORADIUSBYMEMBER</target>
        </trans-unit>
        <trans-unit id="cf98dab16a680969ed5a7c59dd91c064dd5ffd22" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER  key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member</source>
          <target state="translated">Radio del miembro clave GEORADIUSBYMEMBER m|km|ft|mi [CON CÓDIGO][DESCARGAR][CUENTA][ASC|DESC][ALMACENAR][ALMACENAR]Consulta un conjunto clasificado que representa un índice geoespacial para buscar miembros que coincidan con una distancia máxima dada de un miembro</target>
        </trans-unit>
        <trans-unit id="8c656e42e400e0e0513de5eb5312afe50a9bf1f5" translate="yes" xml:space="preserve">
          <source>GEOSEARCH</source>
          <target state="translated">GEOSEARCH</target>
        </trans-unit>
        <trans-unit id="3f9c1bdbc9920ba8577c53041094c05d6b105844" translate="yes" xml:space="preserve">
          <source>GEOSEARCH  key [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count] [WITHCOORD] [WITHDIST] [WITHHASH]   Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6122a14306dc58653c28237fae16723377d12d" translate="yes" xml:space="preserve">
          <source>GEOSEARCHSTORE</source>
          <target state="translated">GEOSEARCHSTORE</target>
        </trans-unit>
        <trans-unit id="8ad42c0130aa6e2dd8ebab61f847d23ba5e52254" translate="yes" xml:space="preserve">
          <source>GEOSEARCHSTORE  destination source [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count] [WITHCOORD] [WITHDIST] [WITHHASH] [STOREDIST]   Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="7d7f9a21ff2fe871d6f138989249c29532bb7fdc" translate="yes" xml:space="preserve">
          <source>GET  key   Get the value of a key</source>
          <target state="translated">GET key Obtener el valor de una llave</target>
        </trans-unit>
        <trans-unit id="ef9841e66f1ceb2a8ca3c4b61209bfb1ccb07d46" translate="yes" xml:space="preserve">
          <source>GETBIT</source>
          <target state="translated">GETBIT</target>
        </trans-unit>
        <trans-unit id="c67560b598b48f8d8597f643fcac2a09acec11dd" translate="yes" xml:space="preserve">
          <source>GETBIT  key offset   Returns the bit value at offset in the string value stored at key</source>
          <target state="translated">Desplazamiento de la clave GETBIT Devuelve el valor de los bits con desplazamiento en el valor de la cadena almacenado en la clave</target>
        </trans-unit>
        <trans-unit id="171dc01acd21b14b16885f344959333f303f7868" translate="yes" xml:space="preserve">
          <source>GETRANGE</source>
          <target state="translated">GETRANGE</target>
        </trans-unit>
        <trans-unit id="120d6e3c8bea25d9ffe941d0b9d148464db210c6" translate="yes" xml:space="preserve">
          <source>GETRANGE  key start end   Get a substring of the string stored at a key</source>
          <target state="translated">GETRANGE clave inicio final Obtener una subcadena de la cadena almacenada en una clave</target>
        </trans-unit>
        <trans-unit id="6a4472582074006f8a0d04a695a91bfb64d3f211" translate="yes" xml:space="preserve">
          <source>GETSET</source>
          <target state="translated">GETSET</target>
        </trans-unit>
        <trans-unit id="ea14ecdc443c7b2197bfb8f599d84d9e3ddc91a9" translate="yes" xml:space="preserve">
          <source>GETSET  key value   Set the string value of a key and return its old value</source>
          <target state="translated">GETSET valor de la clave Establecer el valor de la cadena de una clave y devolver su antiguo valor</target>
        </trans-unit>
        <trans-unit id="0f33bfb55b7c38358e7fef810b5a8c3a19e508c9" translate="yes" xml:space="preserve">
          <source>Generate a new &lt;code&gt;configEpoch&lt;/code&gt; unilaterally, just taking the current greatest epoch available and incrementing it if its local configuration epoch is not already the greatest.</source>
          <target state="translated">Genere un nuevo &lt;code&gt;configEpoch&lt;/code&gt; unilateralmente, simplemente tomando la mayor &amp;eacute;poca actual disponible e increment&amp;aacute;ndola si su &amp;eacute;poca de configuraci&amp;oacute;n local no es ya la mayor.</target>
        </trans-unit>
        <trans-unit id="8770e1d00765da154add27070eb66b76abb639e9" translate="yes" xml:space="preserve">
          <source>Geo</source>
          <target state="translated">Geo</target>
        </trans-unit>
        <trans-unit id="00754e7ec718eca2346352874423afcfcd99de6c" translate="yes" xml:space="preserve">
          <source>Geohash string properties</source>
          <target state="translated">Propiedades de la cadena de Geohash</target>
        </trans-unit>
        <trans-unit id="fcba9fe6c6b3ee7a7679d8a80f01c177efafb91f" translate="yes" xml:space="preserve">
          <source>Get keys from the source node with &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; command and move them into the destination node using the &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; command.</source>
          <target state="translated">Obtenga claves del nodo de origen con el comando &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; y mu&amp;eacute;valas al nodo de destino mediante el comando &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09aec2d48c2bf33e9f4de1efe0b69e4c3361c2f6" translate="yes" xml:space="preserve">
          <source>Get the value of &lt;code&gt;key&lt;/code&gt;. If the key does not exist the special value &lt;code&gt;nil&lt;/code&gt; is returned. An error is returned if the value stored at &lt;code&gt;key&lt;/code&gt; is not a string, because &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; only handles string values.</source>
          <target state="translated">Obtenga el valor de la &lt;code&gt;key&lt;/code&gt; . Si la clave no existe, se devuelve el valor especial &lt;code&gt;nil&lt;/code&gt; . Se devuelve un error si el valor almacenado en la &lt;code&gt;key&lt;/code&gt; no es una cadena, porque &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; solo maneja valores de cadena.</target>
        </trans-unit>
        <trans-unit id="4f07c68cfde1cce4484071399ec3dcac10ef3226" translate="yes" xml:space="preserve">
          <source>Given a list of SHA1 digests as arguments this command returns an array of 1 or 0, where 1 means the specific SHA1 is recognized as a script already present in the scripting cache, while 0 means that a script with this SHA1 was never seen before (or at least never seen after the latest SCRIPT FLUSH command).</source>
          <target state="translated">Dada una lista de digestores SHA1 como argumentos,este comando devuelve una matriz de 1 o 0,donde 1 significa que el SHA1 específico se reconoce como un script ya presente en la caché de scripts,mientras que 0 significa que un script con este SHA1 no se ha visto nunca antes (o al menos nunca se ha visto después del último comando SCRIPT FLUSH).</target>
        </trans-unit>
        <trans-unit id="5e47705fe8d80f510ddf59025f5bedac0bd2d833" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, it is often useful to obtain back the coordinates of specified members. When the geospatial index is populated via &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; the coordinates are converted into a 52 bit geohash, so the coordinates returned may not be exactly the ones used in order to add the elements, but small errors may be introduced.</source>
          <target state="translated">Dado un conjunto ordenado que representa un &amp;iacute;ndice geoespacial, poblado con el comando &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; , a menudo es &amp;uacute;til recuperar las coordenadas de miembros especificados. Cuando el &amp;iacute;ndice geoespacial se completa a trav&amp;eacute;s de &lt;a href=&quot;geoadd&quot;&gt;GEOADD,&lt;/a&gt; las coordenadas se convierten en un geohash de 52 bits, por lo que las coordenadas devueltas pueden no ser exactamente las utilizadas para agregar los elementos, pero pueden introducirse peque&amp;ntilde;os errores.</target>
        </trans-unit>
        <trans-unit id="1a98977aea8887ddd5a1edb60251e403b53795ab" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, the command returns the distance between the two specified members in the specified unit.</source>
          <target state="translated">Dado un conjunto ordenado que representa un &amp;iacute;ndice geoespacial, poblado con el comando &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; , el comando devuelve la distancia entre los dos miembros especificados en la unidad especificada.</target>
        </trans-unit>
        <trans-unit id="f45f257965d0c26e93bb5789953aca2dc751ef9e" translate="yes" xml:space="preserve">
          <source>Global variables protection</source>
          <target state="translated">Protección de las variables globales</target>
        </trans-unit>
        <trans-unit id="107625e2c3bcf140428d9df7e4e1066049947d81" translate="yes" xml:space="preserve">
          <source>Groups, consumers and PELs are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d1555c45e5fc58578080840f0c6368a6d6cb11" translate="yes" xml:space="preserve">
          <source>Guarantee of termination</source>
          <target state="translated">Garantía de terminación</target>
        </trans-unit>
        <trans-unit id="5205aa5d3ee9c438b38044d5999ac4ba4201f832" translate="yes" xml:space="preserve">
          <source>HDEL</source>
          <target state="translated">HDEL</target>
        </trans-unit>
        <trans-unit id="f0d9eb5c49197bfd6feeb0c9d7b482f5e211f201" translate="yes" xml:space="preserve">
          <source>HDEL  key field [field ...]   Delete one or more hash fields</source>
          <target state="translated">Campo clave HDEL [campo ...]Borrar uno o más campos de hachís</target>
        </trans-unit>
        <trans-unit id="c65f99f8c5376adadddc46d5cbcf5762f9e55eb7" translate="yes" xml:space="preserve">
          <source>HELLO</source>
          <target state="translated">HELLO</target>
        </trans-unit>
        <trans-unit id="194f965f233e82e8b705df8610029d9234df6a34" translate="yes" xml:space="preserve">
          <source>HELLO  protover [AUTH username password] [SETNAME clientname]   switch Redis protocol</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48dcfbcf4eca1611582a1cc8baa82d9d2fa2960" translate="yes" xml:space="preserve">
          <source>HEXISTS</source>
          <target state="translated">HEXISTS</target>
        </trans-unit>
        <trans-unit id="a807653048c48da53e448a2b285039ef0573aae8" translate="yes" xml:space="preserve">
          <source>HEXISTS  key field   Determine if a hash field exists</source>
          <target state="translated">Campo clave HEXISTAS Determinar si existe un campo hash</target>
        </trans-unit>
        <trans-unit id="2aa481a50927484124964b6f73bac3881de47ff3" translate="yes" xml:space="preserve">
          <source>HGET</source>
          <target state="translated">HGET</target>
        </trans-unit>
        <trans-unit id="53e1681d3979ea38127102b70459b3a4ea647f65" translate="yes" xml:space="preserve">
          <source>HGET  key field   Get the value of a hash field</source>
          <target state="translated">Campo clave HGET Obtener el valor de un campo de hachís</target>
        </trans-unit>
        <trans-unit id="0949fe15e4d07355cc1f8bdf2d7d0a3bc27e0498" translate="yes" xml:space="preserve">
          <source>HGETALL</source>
          <target state="translated">HGETALL</target>
        </trans-unit>
        <trans-unit id="a9f2d8c36ab9a92512a3abf304cf22c78a10d32a" translate="yes" xml:space="preserve">
          <source>HGETALL  key   Get all the fields and values in a hash</source>
          <target state="translated">Clave HGETALL Obtener todos los campos y valores en un hash</target>
        </trans-unit>
        <trans-unit id="bec3f40ebfc071338931e9ec346c383954f688e2" translate="yes" xml:space="preserve">
          <source>HINCRBY</source>
          <target state="translated">HINCRBY</target>
        </trans-unit>
        <trans-unit id="85ba7d4ce6a861db6587eaef82d0c559a1acad5a" translate="yes" xml:space="preserve">
          <source>HINCRBY  key field increment   Increment the integer value of a hash field by the given number</source>
          <target state="translated">Incremento del campo clave HINCRBY Incrementar el valor entero de un campo hash por el número dado</target>
        </trans-unit>
        <trans-unit id="a93522c3800a73e9eb332f7f840625aacdc296f3" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT</source>
          <target state="translated">HINCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="b074f9cd10320d76be5375524c56b4c4f5083f25" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT  key field increment   Increment the float value of a hash field by the given amount</source>
          <target state="translated">Incremento del campo clave HINCRBYFLOAT Incrementar el valor de flotación de un campo de hachís en la cantidad dada</target>
        </trans-unit>
        <trans-unit id="a857392e173da21b13e4d3e033f1d7d6aadde58a" translate="yes" xml:space="preserve">
          <source>HKEYS</source>
          <target state="translated">HKEYS</target>
        </trans-unit>
        <trans-unit id="4880894873a3e4a3dcf54bf74bebf960afb44a7c" translate="yes" xml:space="preserve">
          <source>HKEYS  key   Get all the fields in a hash</source>
          <target state="translated">Llave HKEYS Consigue todos los campos en un hash</target>
        </trans-unit>
        <trans-unit id="4d36dfb03a6ecdea21a171dc0c30adebe8d01184" translate="yes" xml:space="preserve">
          <source>HLEN</source>
          <target state="translated">HLEN</target>
        </trans-unit>
        <trans-unit id="bcfcea9d003f5af07b2bb8099e2b496b1e9e832a" translate="yes" xml:space="preserve">
          <source>HLEN  key   Get the number of fields in a hash</source>
          <target state="translated">Tecla HLEN Obtener el número de campos en un hash</target>
        </trans-unit>
        <trans-unit id="480987a6e9c4e7cd1d65f5ffad4b88a1132f2c6f" translate="yes" xml:space="preserve">
          <source>HMGET</source>
          <target state="translated">HMGET</target>
        </trans-unit>
        <trans-unit id="5b7367a8f047e6e2ad4600495794ba1f6c7d8f47" translate="yes" xml:space="preserve">
          <source>HMGET  key field [field ...]   Get the values of all the given hash fields</source>
          <target state="translated">Campo clave HMGET [campo ...]Obtener los valores de todos los campos de hachís dados</target>
        </trans-unit>
        <trans-unit id="fb5089ab3a0516d344f9de817ed332775e142279" translate="yes" xml:space="preserve">
          <source>HMSET</source>
          <target state="translated">HMSET</target>
        </trans-unit>
        <trans-unit id="b9ce7bb49b575eba9a143cb12bd3a727345953bd" translate="yes" xml:space="preserve">
          <source>HMSET  key field value [field value ...]   Set multiple hash fields to multiple values</source>
          <target state="translated">Valor del campo clave HMSET [valor del campo ...]Establecer múltiples campos hash a múltiples valores</target>
        </trans-unit>
        <trans-unit id="f36a969e90bd023793807636ddb180dde5956fd7" translate="yes" xml:space="preserve">
          <source>HSCAN</source>
          <target state="translated">HSCAN</target>
        </trans-unit>
        <trans-unit id="1f717593e9570c814ba25178e664e1d1c164122d" translate="yes" xml:space="preserve">
          <source>HSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate hash fields and associated values</source>
          <target state="translated">Cursor de la tecla HSCAN [Patrón de coincidencia][Recuento]Campos de hachís iterativos incrementales y valores asociados</target>
        </trans-unit>
        <trans-unit id="00cee6cf2b7799f7538096724dbd92d41cec6aeb" translate="yes" xml:space="preserve">
          <source>HSET</source>
          <target state="translated">HSET</target>
        </trans-unit>
        <trans-unit id="665396b991835984fc7e3e34cd2fe5312ecf417d" translate="yes" xml:space="preserve">
          <source>HSET  key field value   Set the string value of a hash field</source>
          <target state="translated">Valor del campo clave HSET Establecer el valor de la cadena de un campo hash</target>
        </trans-unit>
        <trans-unit id="bc6fdaa755b1bfae0ec78315f5fb3674c528f4e4" translate="yes" xml:space="preserve">
          <source>HSET  key field value [field value ...]   Set the string value of a hash field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f08f81142bc45f390db40acaf0af8de40d5f8df0" translate="yes" xml:space="preserve">
          <source>HSETNX</source>
          <target state="translated">HSETNX</target>
        </trans-unit>
        <trans-unit id="8f0805bb5892aca6c147d761f188dcc8c135168b" translate="yes" xml:space="preserve">
          <source>HSETNX  key field value   Set the value of a hash field, only if the field does not exist</source>
          <target state="translated">Valor del campo clave HSETNX Establecer el valor de un campo hash,sólo si el campo no existe</target>
        </trans-unit>
        <trans-unit id="653e2c00767d7da99a4ad249e0220683a0f21927" translate="yes" xml:space="preserve">
          <source>HSTRLEN</source>
          <target state="translated">HSTRLEN</target>
        </trans-unit>
        <trans-unit id="bb8103389cfdcecf46656f06573ed3513c20d29d" translate="yes" xml:space="preserve">
          <source>HSTRLEN  key field   Get the length of the value of a hash field</source>
          <target state="translated">Campo clave HSTRLEN Obtener la longitud del valor de un campo de hachís</target>
        </trans-unit>
        <trans-unit id="75c2a102095c5cfb3745c7635997fd6d46e1ed99" translate="yes" xml:space="preserve">
          <source>HVALS</source>
          <target state="translated">HVALS</target>
        </trans-unit>
        <trans-unit id="2cf3758bf2c3fcb0cf4699e1fad2c529e7f60c18" translate="yes" xml:space="preserve">
          <source>HVALS  key   Get all the values in a hash</source>
          <target state="translated">Clave HVALS Obtener todos los valores en un hash</target>
        </trans-unit>
        <trans-unit id="1679a916ecf39377920740d5654170e7e20f04f9" translate="yes" xml:space="preserve">
          <source>Handling deadlocks</source>
          <target state="translated">Manejar los puntos muertos</target>
        </trans-unit>
        <trans-unit id="17348a159bc90f6828002f9fa69a3bdc1006ad33" translate="yes" xml:space="preserve">
          <source>Handling of strings with different lengths</source>
          <target state="translated">Manejo de cuerdas con diferentes longitudes</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="abef659c43351c90fc57bd2f1f2ca21c74a56b5c" translate="yes" xml:space="preserve">
          <source>Hashes can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is a special encoding used for small hashes.</source>
          <target state="translated">Hashes pueden ser codificados como &lt;code&gt;ziplist&lt;/code&gt; o &lt;code&gt;hashtable&lt;/code&gt; . La lista &lt;code&gt;ziplist&lt;/code&gt; es una codificaci&amp;oacute;n especial que se utiliza para peque&amp;ntilde;os hashes.</target>
        </trans-unit>
        <trans-unit id="a9f98aceea4b6640fde4f0db2b67c8b62670525a" translate="yes" xml:space="preserve">
          <source>Helper functions to return Redis types</source>
          <target state="translated">Funciones de ayuda para devolver los tipos de Redis</target>
        </trans-unit>
        <trans-unit id="71f2a2c44b12e8d025ffdb0ba44d167f2eb32dc5" translate="yes" xml:space="preserve">
          <source>Here are a few conversion examples:</source>
          <target state="translated">Aquí hay algunos ejemplos de conversión:</target>
        </trans-unit>
        <trans-unit id="bd16d98ee220a06318e7c2f0edf89d89e391fb27" translate="yes" xml:space="preserve">
          <source>Here is the description of fields for Redis &amp;gt;= 2.4.</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la descripci&amp;oacute;n de los campos para Redis&amp;gt; = 2.4.</target>
        </trans-unit>
        <trans-unit id="1953d7d107ad4ade79603b02cdb1e8adc699e514" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;clients&lt;/strong&gt; section:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el significado de todos los campos en la secci&amp;oacute;n de &lt;strong&gt;clientes&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="aa545dc398491c6907d2041f2ded31d190284a9f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;cpu&lt;/strong&gt; section:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el significado de todos los campos en la secci&amp;oacute;n de la &lt;strong&gt;CPU&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d3d5c7888fb0526434ccb545db7ed9e893e48b61" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;memory&lt;/strong&gt; section:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el significado de todos los campos en la secci&amp;oacute;n de &lt;strong&gt;memoria&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="d1e56b526c805770cba7347f8a39b9426d10e67e" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;persistence&lt;/strong&gt; section:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el significado de todos los campos en la secci&amp;oacute;n de &lt;strong&gt;persistencia&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="799881fdedd2437b9e8155aa33f7576cc6d468a1" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;replication&lt;/strong&gt; section:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el significado de todos los campos en la secci&amp;oacute;n de &lt;strong&gt;replicaci&amp;oacute;n&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="0d613b28b44d140ea4afd266be689c2f86ce192d" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;server&lt;/strong&gt; section:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el significado de todos los campos en la secci&amp;oacute;n del &lt;strong&gt;servidor&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="9700349259df5577664d69e8579a5af99e65c52f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;stats&lt;/strong&gt; section:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el significado de todos los campos en la secci&amp;oacute;n de &lt;strong&gt;estad&amp;iacute;sticas&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4bd3033708ea4b8a6d1fbb504db04260b3b5e786" translate="yes" xml:space="preserve">
          <source>Here is the meaning of the fields:</source>
          <target state="translated">Aquí está el significado de los campos:</target>
        </trans-unit>
        <trans-unit id="e97f41ad39a769cdba126aa050e98bd0bf28b8b9" translate="yes" xml:space="preserve">
          <source>Here's the default configuration for the default user:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d96106a2b4866d88034cf3cbc99a16013a0e36c" translate="yes" xml:space="preserve">
          <source>Hint: it is possible to switch to a different key based on the current Unix time, in this way it is possible to have just a relatively small amount of samples per key, to avoid dealing with very big keys, and to make this pattern more friendly to be distributed across many Redis instances.</source>
          <target state="translated">Sugerencia:es posible cambiar a una clave diferente en base a la hora actual de Unix,de esta manera es posible tener sólo una cantidad relativamente pequeña de muestras por clave,para evitar tener que lidiar con claves muy grandes,y hacer este patrón más amigable para ser distribuido a través de muchas instancias de Redis.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="b51e386256184dc34229a5ca92a34accb7024327" translate="yes" xml:space="preserve">
          <source>How Redis expires keys</source>
          <target state="translated">Cómo Redis expira las llaves</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">¿Cómo funciona?</target>
        </trans-unit>
        <trans-unit id="88559343d1f8627b05ed905092ec3f856b6418a7" translate="yes" xml:space="preserve">
          <source>How expires are handled in the replication link and AOF file</source>
          <target state="translated">La forma en que se manejan los vencimientos en el enlace de replicación y el archivo AOF</target>
        </trans-unit>
        <trans-unit id="a8dbfaf95083e1d6e63da157f09e95d8c10fa20f" translate="yes" xml:space="preserve">
          <source>How multiple clients blocked on a single stream are served</source>
          <target state="translated">Cómo se atiende a varios clientes bloqueados en un solo flujo</target>
        </trans-unit>
        <trans-unit id="d5868df09b7eeb0561970a8e423e96c9ad849dbe" translate="yes" xml:space="preserve">
          <source>How to specify intervals</source>
          <target state="translated">Cómo especificar los intervalos</target>
        </trans-unit>
        <trans-unit id="d7cd6ea4777d91cd4768a12501593a68c032c01e" translate="yes" xml:space="preserve">
          <source>However Lua scripts running in Redis 6 or greater, are able to switch to RESP3 mode, and get the replies using the new available types. Similarly Lua scripts are able to reply to clients using the new types. Please make sure to understand &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;the capabilities for RESP3&lt;/a&gt; before continuing reading this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a00a1128dbff721f5566b479531909bd1900b68" translate="yes" xml:space="preserve">
          <source>However because &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has very little state associated (just the cursor) it has the following drawbacks:</source>
          <target state="translated">Sin embargo, debido a que &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; tiene muy poco estado asociado (solo el cursor), tiene los siguientes inconvenientes:</target>
        </trans-unit>
        <trans-unit id="d5314787731edc5f7c64fb20d0e8d7d8aa980d1c" translate="yes" xml:space="preserve">
          <source>However if the offset is prefixed with a &lt;code&gt;#&lt;/code&gt; character, the specified offset is multiplied by the integer type width, so for example:</source>
          <target state="translated">Sin embargo, si el desplazamiento tiene como prefijo un car&amp;aacute;cter &lt;code&gt;#&lt;/code&gt; , el desplazamiento especificado se multiplica por el ancho del tipo entero, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f5cfa667464e115c28334f27e6f622c0e6fc2a1c" translate="yes" xml:space="preserve">
          <source>However in this context the obtained queue is not &lt;em&gt;reliable&lt;/em&gt; as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</source>
          <target state="translated">Sin embargo, en este contexto, la cola obtenida no es &lt;em&gt;confiable&lt;/em&gt; ya que los mensajes se pueden perder, por ejemplo, en el caso de que haya un problema de red o si el consumidor se bloquea justo despu&amp;eacute;s de recibir el mensaje, pero a&amp;uacute;n est&amp;aacute; por procesar.</target>
        </trans-unit>
        <trans-unit id="32db1099030ce3f6b2493101785b95bdd63b63e3" translate="yes" xml:space="preserve">
          <source>However it returns OK to the caller ASAP, so the &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; command execution is not paused by itself.</source>
          <target state="translated">Sin embargo, devuelve OK a la persona que llama lo antes posible, por lo que la ejecuci&amp;oacute;n del comando &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; no se detiene por s&amp;iacute; sola.</target>
        </trans-unit>
        <trans-unit id="5ebc54eeb70e7c4776f4ca626c28b6528713adcd" translate="yes" xml:space="preserve">
          <source>However node hash slots can be in a special state, used in order to communicate errors after a node restart (mismatch between the keys in the AOF/RDB file, and the node hash slots configuration), or when there is a resharding operation in progress. This two states are &lt;strong&gt;importing&lt;/strong&gt; and &lt;strong&gt;migrating&lt;/strong&gt;.</source>
          <target state="translated">Sin embargo, las ranuras de hash de nodo pueden estar en un estado especial, utilizado para comunicar errores despu&amp;eacute;s de un reinicio de nodo (falta de coincidencia entre las claves en el archivo AOF / RDB y la configuraci&amp;oacute;n de las ranuras de hash de nodo), o cuando hay una operaci&amp;oacute;n de fragmentaci&amp;oacute;n en curso . Estos dos estados est&amp;aacute;n &lt;strong&gt;importando&lt;/strong&gt; y &lt;strong&gt;migrando&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="74506a394d8d9a9db887f0b3d8806ba4f46848f4" translate="yes" xml:space="preserve">
          <source>However note that with streams this is not a problem: stream entries are not removed from the stream when clients are served, so every client waiting will be served as soon as an &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command provides data to the stream.</source>
          <target state="translated">Sin embargo, tenga en cuenta que con las transmisiones esto no es un problema: las entradas de la transmisi&amp;oacute;n no se eliminan de la transmisi&amp;oacute;n cuando se atienden a los clientes, por lo que todos los clientes en espera ser&amp;aacute;n atendidos tan pronto como un comando &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; proporcione datos a la transmisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5d5d9fa16c29cdab06e0b69ea5b8063d64e64fa1" translate="yes" xml:space="preserve">
          <source>However note that:</source>
          <target state="translated">Sin embargo,tenga en cuenta que:</target>
        </trans-unit>
        <trans-unit id="c2edee6acbd228e132336d8defe53364f46f07e4" translate="yes" xml:space="preserve">
          <source>However once the data structures are bigger and are promoted to use real hash tables, the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of commands will resort to the normal behavior. Note that since this special behavior of returning all the elements is true only for small aggregates, it has no effects on the command complexity or latency. However the exact limits to get converted into real hash tables are &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;user configurable&lt;/a&gt;, so the maximum number of elements you can see returned in a single call depends on how big an aggregate data type could be and still use the packed representation.</source>
          <target state="translated">Sin embargo, una vez que las estructuras de datos sean m&amp;aacute;s grandes y se promuevan para usar tablas hash reales, la familia de comandos &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; recurrir&amp;aacute; al comportamiento normal. Tenga en cuenta que dado que este comportamiento especial de devolver todos los elementos es cierto solo para agregados peque&amp;ntilde;os, no tiene ning&amp;uacute;n efecto sobre la complejidad o latencia del comando. Sin embargo, los l&amp;iacute;mites exactos para convertirse en tablas hash reales son &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;configurables&lt;/a&gt; por el usuario , por lo que la cantidad m&amp;aacute;xima de elementos que puede ver devueltos en una sola llamada depende de qu&amp;eacute; tan grande podr&amp;iacute;a ser un tipo de datos agregados y a&amp;uacute;n usar la representaci&amp;oacute;n empaquetada.</target>
        </trans-unit>
        <trans-unit id="b21c3d5072091035e19308ba188163eb9b4582ee" translate="yes" xml:space="preserve">
          <source>However starting with Redis 2.8.12 or greater, the command accepts the following form:</source>
          <target state="translated">Sin embargo,a partir de Redis 2.8.12 o superior,el comando acepta la siguiente forma:</target>
        </trans-unit>
        <trans-unit id="3d9349e56b3bf2d47d692509fd1873664bc86e71" translate="yes" xml:space="preserve">
          <source>However the command cannot simply drop the node from the internal node table of the node receiving the command, it also implements a ban-list, not allowing the same node to be added again as a side effect of processing the &lt;em&gt;gossip section&lt;/em&gt; of the heartbeat packets received from other nodes.</source>
          <target state="translated">Sin embargo, el comando no puede simplemente eliminar el nodo de la tabla de nodos internos del nodo que recibe el comando, sino que tambi&amp;eacute;n implementa una lista de prohibici&amp;oacute;n, lo que no permite que el mismo nodo se agregue nuevamente como efecto secundario del procesamiento de la &lt;em&gt;secci&amp;oacute;n&lt;/em&gt; de &lt;em&gt;chismes&lt;/em&gt; de los paquetes de latidos. recibidos de otros nodos.</target>
        </trans-unit>
        <trans-unit id="77d71597c94f649040209c65345b9adb784d1ada" translate="yes" xml:space="preserve">
          <source>However the number of returned elements is reasonable, that is, in practical terms SCAN may return a maximum number of elements in the order of a few tens of elements when iterating a large collection, or may return all the elements of the collection in a single call when the iterated collection is small enough to be internally represented as an encoded data structure (this happens for small sets, hashes and sorted sets).</source>
          <target state="translated">Sin embargo,el número de elementos devueltos es razonable,es decir,en términos prácticos,SCAN puede devolver un número máximo de elementos del orden de unas pocas decenas de elementos cuando itera una gran colección,o puede devolver todos los elementos de la colección en una sola llamada cuando la colección iterada es lo suficientemente pequeña como para ser representada internamente como una estructura de datos codificados (esto sucede para conjuntos pequeños,hashes y conjuntos ordenados).</target>
        </trans-unit>
        <trans-unit id="4a9bd4d796e3f1d19b335cd4b8d1d2f3544974af" translate="yes" xml:space="preserve">
          <source>However the user can apply a transformation to the encoded string so that the first part of the element inserted in the sorted set will compare as the user requires for the specific application. For example if I want to add strings that will be compared in a case-insensitive way, but I still want to retrieve the real case when querying, I can add strings in the following way:</source>
          <target state="translated">Sin embargo,el usuario puede aplicar una transformación a la cadena codificada para que la primera parte del elemento insertado en el conjunto clasificado se compare según lo requiera el usuario para la aplicación específica.Por ejemplo,si quiero añadir cadenas que se compararán sin tener en cuenta las mayúsculas y minúsculas,pero sigo queriendo recuperar el caso real al hacer la consulta,puedo añadir cadenas de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="794f44a2bce77c8dc3d6e6888d73f15fd3089fde" translate="yes" xml:space="preserve">
          <source>However the user is still able to write commands with random behavior using the following simple trick. Imagine I want to write a Redis script that will populate a list with N random integers.</source>
          <target state="translated">Sin embargo,el usuario todavía es capaz de escribir comandos con un comportamiento aleatorio usando el siguiente truco simple.Imagina que quiero escribir un guión de Redis que llenará una lista con N números enteros aleatorios.</target>
        </trans-unit>
        <trans-unit id="fb5b52cca56c4cdd87edf1dfc660cd981c3a9505" translate="yes" xml:space="preserve">
          <source>However there is a way for the user to tune the order of magnitude of the number of returned elements per call using the &lt;strong&gt;COUNT&lt;/strong&gt; option.</source>
          <target state="translated">Sin embargo, existe una forma para que el usuario ajuste el orden de magnitud del n&amp;uacute;mero de elementos devueltos por llamada utilizando la opci&amp;oacute;n &lt;strong&gt;COUNT&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8f1c30670b30342c4d809208def1afc1fbfd2c" translate="yes" xml:space="preserve">
          <source>However there is an exception to this rule, and it is when a new cluster is created from scratch. Redis Cluster &lt;em&gt;config epoch collision resolution&lt;/em&gt; algorithm can deal with new nodes all configured with the same configuration at startup, but this process is slow and should be the exception, only to make sure that whatever happens, two more nodes eventually always move away from the state of having the same configuration epoch.</source>
          <target state="translated">Sin embargo, hay una excepci&amp;oacute;n a esta regla, y es cuando se crea un nuevo cl&amp;uacute;ster desde cero. El algoritmo de &lt;em&gt;resoluci&amp;oacute;n de colisiones de &amp;eacute;poca de configuraci&amp;oacute;n de&lt;/em&gt; Redis Cluster puede tratar con nuevos nodos todos configurados con la misma configuraci&amp;oacute;n al inicio, pero este proceso es lento y deber&amp;iacute;a ser la excepci&amp;oacute;n, solo para asegurarse de que pase lo que pase, dos nodos m&amp;aacute;s eventualmente siempre se alejan del estado de tener la misma configuraci&amp;oacute;n de &amp;eacute;poca.</target>
        </trans-unit>
        <trans-unit id="142631746a79e235cfed163ccdfe702d6be0326c" translate="yes" xml:space="preserve">
          <source>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</source>
          <target state="translated">Sin embargo,esto también significa que la ejecución de guiones lentos no es una buena idea.No es difícil crear guiones rápidos,ya que la sobrecarga de los mismos es muy baja,pero si vas a usar guiones lentos debes tener en cuenta que mientras el guión se esté ejecutando ningún otro cliente puede ejecutar comandos.</target>
        </trans-unit>
        <trans-unit id="0a33083c754611907b7f894af6eb43aadc3e4c17" translate="yes" xml:space="preserve">
          <source>However this is a useful feature since, sometimes, we need to execute certain commands only in the master in order to create, for example, intermediate values.</source>
          <target state="translated">Sin embargo,esta es una característica útil ya que,a veces,necesitamos ejecutar ciertos comandos sólo en el maestro para crear,por ejemplo,valores intermedios.</target>
        </trans-unit>
        <trans-unit id="d0af8abe6ce309a54e5c3abb2294351b6406b863" translate="yes" xml:space="preserve">
          <source>However this is just a best-effort attempt so it is possible to still lose a write synchronously replicated to multiple replicas.</source>
          <target state="translated">Sin embargo,esto es sólo un intento de mejor esfuerzo,por lo que es posible perder una escritura sincrónicamente replicada a múltiples réplicas.</target>
        </trans-unit>
        <trans-unit id="ddd90e4937b6a5514534f2c76508301017283476" translate="yes" xml:space="preserve">
          <source>However trying to execute it again results into an error since the slots are already assigned:</source>
          <target state="translated">Sin embargo,tratar de ejecutarlo de nuevo resulta en un error ya que las ranuras ya están asignadas:</target>
        </trans-unit>
        <trans-unit id="8abb1412bd4f6007eadde6067935f55706c8b96f" translate="yes" xml:space="preserve">
          <source>However using &lt;strong&gt;FORCE&lt;/strong&gt; we still need the majority of masters to be available in order to authorize the failover and generate a new configuration epoch for the replica that is going to become master.</source>
          <target state="translated">Sin embargo, al usar &lt;strong&gt;FORCE&lt;/strong&gt; , todav&amp;iacute;a necesitamos que la mayor&amp;iacute;a de los maestros est&amp;eacute;n disponibles para autorizar la conmutaci&amp;oacute;n por error y generar una nueva &amp;eacute;poca de configuraci&amp;oacute;n para la r&amp;eacute;plica que se convertir&amp;aacute; en maestro.</target>
        </trans-unit>
        <trans-unit id="c681766630e9b93da85df642b31ac53297dab87b" translate="yes" xml:space="preserve">
          <source>However what is often very useful, is to know the match position in each strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7eb54420a392ba9d9fb195f48555b2f9849c4e4" translate="yes" xml:space="preserve">
          <source>However while blocking commands like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; are able to provide all the elements that are part of a Set in a given moment, The SCAN family of commands only offer limited guarantees about the returned elements since the collection that we incrementally iterate can change during the iteration process.</source>
          <target state="translated">Sin embargo, mientras que los comandos de bloqueo como &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; pueden proporcionar todos los elementos que forman parte de un Conjunto en un momento dado, la familia de comandos SCAN solo ofrece garant&amp;iacute;as limitadas sobre los elementos devueltos, ya que la colecci&amp;oacute;n que iteramos de forma incremental puede cambiar durante el proceso de iteraci&amp;oacute;n. .</target>
        </trans-unit>
        <trans-unit id="8368348c7a15aab35b99bad0b61100388ed947ac" translate="yes" xml:space="preserve">
          <source>However while the replicas connected to a master will not expire keys independently (but will wait for the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; coming from the master), they'll still take the full state of the expires existing in the dataset, so when a replica is elected to master it will be able to expire the keys independently, fully acting as a master.</source>
          <target state="translated">Sin embargo, aunque las r&amp;eacute;plicas conectadas a un maestro no caducar&amp;aacute;n las claves de forma independiente (sino que esperar&amp;aacute;n a que el &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; provenga del maestro), seguir&amp;aacute;n tomando el estado completo de los caducos existentes en el conjunto de datos, por lo que cuando se elige una r&amp;eacute;plica como maestra podr&amp;aacute; caducar las claves de forma independiente, actuando plenamente como maestro.</target>
        </trans-unit>
        <trans-unit id="e7564bd1b123b79267215f60720a7ba2c7d0f2a4" translate="yes" xml:space="preserve">
          <source>However, note that:</source>
          <target state="translated">Sin embargo,tenga en cuenta que:</target>
        </trans-unit>
        <trans-unit id="ae8b2a13bc4ae56dbd4d97a2490048eefaa8824d" translate="yes" xml:space="preserve">
          <source>However, this behavior changes if you are looking for clear bits and specify a range with both &lt;strong&gt;start&lt;/strong&gt; and &lt;strong&gt;end&lt;/strong&gt;. If no clear bit is found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.</source>
          <target state="translated">Sin embargo, este comportamiento cambia si busca bits claros y especifica un rango con &lt;strong&gt;inicio&lt;/strong&gt; y &lt;strong&gt;fin&lt;/strong&gt; . Si no se encuentra ning&amp;uacute;n bit de borrado en el rango especificado, la funci&amp;oacute;n devuelve -1 cuando el usuario especific&amp;oacute; un rango de borrado y no hay 0 bits en ese rango.</target>
        </trans-unit>
        <trans-unit id="078d1434700af53deba94cb889757980e4b68051" translate="yes" xml:space="preserve">
          <source>Humans may use this command in order to check what is the hash slot, and then the associated Redis Cluster node, responsible for a given key.</source>
          <target state="translated">Los humanos pueden usar este comando para comprobar cuál es la ranura de hash,y luego el nodo asociado Redis Cluster,responsable de una clave determinada.</target>
        </trans-unit>
        <trans-unit id="d68bb5655889a7436b2eff6315d03293170f63d0" translate="yes" xml:space="preserve">
          <source>HyperLogLog</source>
          <target state="translated">HyperLogLog</target>
        </trans-unit>
        <trans-unit id="58b5c100f0d44808f0dbfcc3722f78c2d81f1aaf" translate="yes" xml:space="preserve">
          <source>HyperLogLog representation</source>
          <target state="translated">Representación de HyperLogLog</target>
        </trans-unit>
        <trans-unit id="28c10e9d5a5781ed8d9e57c706ceb5a1dd97ff5f" translate="yes" xml:space="preserve">
          <source>I can start with this small Ruby program:</source>
          <target state="translated">Puedo empezar con este pequeño programa de Rubí:</target>
        </trans-unit>
        <trans-unit id="5188851d79e499077ff8c17718081d6a2d5d7980" translate="yes" xml:space="preserve">
          <source>IDs are guaranteed to be always incremental: If you compare the ID of the entry just inserted it will be greater than any other past ID, so entries are totally ordered inside a stream. In order to guarantee this property, if the current top ID in the stream has a time greater than the current local time of the instance, the top entry time will be used instead, and the sequence part of the ID incremented. This may happen when, for instance, the local clock jumps backward, or if after a failover the new master has a different absolute time.</source>
          <target state="translated">Las identificaciones están garantizadas para ser siempre incrementales:Si comparas la identificación de la entrada que acabas de insertar será mayor que cualquier otra identificación anterior,por lo que las entradas están totalmente ordenadas dentro de un flujo.Para garantizar esta propiedad,si el ID superior actual en la corriente tiene una hora mayor que la hora local actual de la instancia,se utilizará en su lugar la hora de entrada superior,y se incrementará la parte de la secuencia del ID.Esto puede ocurrir cuando,por ejemplo,el reloj local salta hacia atrás,o si después de una conmutación por error el nuevo maestro tiene una hora absoluta diferente.</target>
        </trans-unit>
        <trans-unit id="c0f8745b1bebe7ddae3a87f4efc1207e5b87a40b" translate="yes" xml:space="preserve">
          <source>IDs are specified by two numbers separated by a &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">Los ID se especifican mediante dos n&amp;uacute;meros separados por un car&amp;aacute;cter &lt;code&gt;-&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="70aab9650acd50b2b8e1776f69b86b88bbbe99e5" translate="yes" xml:space="preserve">
          <source>INCR</source>
          <target state="translated">INCR</target>
        </trans-unit>
        <trans-unit id="c59620ba3e9207aaf8fb1bf70e412a9caa358cb2" translate="yes" xml:space="preserve">
          <source>INCR  key   Increment the integer value of a key by one</source>
          <target state="translated">Clave INCR Incrementa el valor entero de una clave en uno</target>
        </trans-unit>
        <trans-unit id="af14b6096425a1f909b7628ce8491716c2d581ba" translate="yes" xml:space="preserve">
          <source>INCRBY</source>
          <target state="translated">INCRBY</target>
        </trans-unit>
        <trans-unit id="9ab1bc6a3a0563b50a9e4bcb930106db12e2ae4e" translate="yes" xml:space="preserve">
          <source>INCRBY  key increment   Increment the integer value of a key by the given amount</source>
          <target state="translated">Incremento de clave INCRBY Incrementa el valor entero de una clave por la cantidad dada</target>
        </trans-unit>
        <trans-unit id="769650b0192d046cb68b526ab27d41d927ea5cc8" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT</source>
          <target state="translated">INCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="2e3bba4aaf8bd64291b4999ea2633e1cde536fe3" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT  key increment   Increment the float value of a key by the given amount</source>
          <target state="translated">Incremento de la clave INCRBYFLOAT Incrementa el valor de flotación de una clave por la cantidad dada</target>
        </trans-unit>
        <trans-unit id="9c9cf999829193894067bbd9e1484756ab736ac0" translate="yes" xml:space="preserve">
          <source>INFO</source>
          <target state="translated">INFO</target>
        </trans-unit>
        <trans-unit id="42089cfb2067d721afeae473b5079898e863248e" translate="yes" xml:space="preserve">
          <source>INFO  [section]   Get information and statistics about the server</source>
          <target state="translated">INFO [sección]Obtener información y estadísticas sobre el servidor</target>
        </trans-unit>
        <trans-unit id="fc967bd2cc1b3485f1ee6c3bccb3832c0009ded5" translate="yes" xml:space="preserve">
          <source>Ideally, the &lt;code&gt;used_memory_rss&lt;/code&gt; value should be only slightly higher than &lt;code&gt;used_memory&lt;/code&gt;. When rss &amp;gt;&amp;gt; used, a large difference means there is memory fragmentation (internal or external), which can be evaluated by checking &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;. When used &amp;gt;&amp;gt; rss, it means part of Redis memory has been swapped off by the operating system: expect some significant latencies.</source>
          <target state="translated">Idealmente, el valor &lt;code&gt;used_memory_rss&lt;/code&gt; deber&amp;iacute;a ser solo un poco m&amp;aacute;s alto que &lt;code&gt;used_memory&lt;/code&gt; . Cuando se usa rss &amp;gt;&amp;gt;, una gran diferencia significa que hay fragmentaci&amp;oacute;n de la memoria (interna o externa), que puede evaluarse verificando &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; . Cuando se usa &amp;gt;&amp;gt; rss, significa que parte de la memoria de Redis ha sido intercambiada por el sistema operativo: espere algunas latencias significativas.</target>
        </trans-unit>
        <trans-unit id="73b4eda93b2219c5cea27cedcc70f71581e15c99" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; fails, no data gets lost as the old AOF will be untouched.</source>
          <target state="translated">Si &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; falla, no se pierde ning&amp;uacute;n dato ya que la antigua AOF no se modificar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="1d20f361447b1eebe4e4808ffc994e347a4065d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;0&lt;/code&gt; the key is already locked by some other client. We can either return to the caller if it's a non blocking lock, or enter a loop retrying to hold the lock until we succeed or some kind of timeout expires.</source>
          <target state="translated">Si &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; devuelve &lt;code&gt;0&lt;/code&gt; , la clave ya est&amp;aacute; bloqueada por alg&amp;uacute;n otro cliente. Podemos volver a la persona que llama si se trata de un bloqueo sin bloqueo, o ingresar a un bucle y volver a intentar mantener el bloqueo hasta que tengamos &amp;eacute;xito o hasta que expire alg&amp;uacute;n tipo de tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="b2860996021d578f69065139684f5cafa8d2519b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;1&lt;/code&gt; the client acquired the lock, setting the &lt;code&gt;lock.foo&lt;/code&gt; key to the Unix time at which the lock should no longer be considered valid. The client will later use &lt;code&gt;DEL lock.foo&lt;/code&gt; in order to release the lock.</source>
          <target state="translated">Si &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; devuelve &lt;code&gt;1&lt;/code&gt; , el cliente adquiri&amp;oacute; el bloqueo, configurando la clave &lt;code&gt;lock.foo&lt;/code&gt; a la hora Unix en la que el bloqueo ya no deber&amp;iacute;a considerarse v&amp;aacute;lido. Posteriormente, el cliente utilizar&amp;aacute; &lt;code&gt;DEL lock.foo&lt;/code&gt; para liberar el bloqueo.</target>
        </trans-unit>
        <trans-unit id="a5eee6810815d94e86b03260de66be0feb7ce88c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; was used, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches all keys watched by the connection.</source>
          <target state="translated">Si &lt;a href=&quot;watch&quot;&gt;RELOJ&lt;/a&gt; se utiliz&amp;oacute;, &lt;a href=&quot;discard&quot;&gt;DESCARTAR&lt;/a&gt; unwatches todas las claves vigiladas por la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="db30f622717bd53f660e926c446f65281d373325" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BGSAVE SCHEDULE&lt;/code&gt; is used, the command will immediately return &lt;code&gt;OK&lt;/code&gt; when an AOF rewrite is in progress and schedule the background save to run at the next opportunity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ed44b2bda4227d511c46587683f47a00d993b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITHCOORD&lt;/code&gt;, &lt;code&gt;WITHDIST&lt;/code&gt; or &lt;code&gt;WITHHASH&lt;/code&gt; options are specified, the command returns an array of arrays, where each sub-array represents a single item.</source>
          <target state="translated">Si se especifican las opciones &lt;code&gt;WITHCOORD&lt;/code&gt; , &lt;code&gt;WITHDIST&lt;/code&gt; o &lt;code&gt;WITHHASH&lt;/code&gt; , el comando devuelve una matriz de matrices, donde cada submatriz representa un solo elemento.</target>
        </trans-unit>
        <trans-unit id="73dfe5f15062ceece61a6acc3449e57743eeff88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten.</source>
          <target state="translated">Si el &lt;code&gt;destination&lt;/code&gt; ya existe, se sobrescribe.</target>
        </trans-unit>
        <trans-unit id="ec00a71247f51a83461ff727be4fdc2a9b8eef53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; already exists and is a string, this command appends the &lt;code&gt;value&lt;/code&gt; at the end of the string. If &lt;code&gt;key&lt;/code&gt; does not exist it is created and set as an empty string, so &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; will be similar to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; in this special case.</source>
          <target state="translated">Si la &lt;code&gt;key&lt;/code&gt; ya existe y es una cadena, este comando agrega el &lt;code&gt;value&lt;/code&gt; al final de la cadena. Si la &lt;code&gt;key&lt;/code&gt; no existe, se crea y se establece como una cadena vac&amp;iacute;a, por lo que &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; ser&amp;aacute; similar a &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; en este caso especial.</target>
        </trans-unit>
        <trans-unit id="f65de86e658742c07d7bc6102da39df199a9b701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist a nil bulk reply is returned.</source>
          <target state="translated">Si la &lt;code&gt;key&lt;/code&gt; no existe, se devuelve una respuesta masiva nula.</target>
        </trans-unit>
        <trans-unit id="bd4417fe5a7c2042f71015b09d46b92838be30fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.</source>
          <target state="translated">Si la &lt;code&gt;key&lt;/code&gt; no existe, se crea un nuevo conjunto ordenado con los miembros especificados como miembros &amp;uacute;nicos, como si el conjunto ordenado estuviera vac&amp;iacute;o. Si la clave existe pero no contiene un conjunto ordenado, se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="e64662be889ce64c17aaa1cc9189ce3256310f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">Si el &lt;code&gt;member&lt;/code&gt; no existe en el conjunto ordenado o la &lt;code&gt;key&lt;/code&gt; no existe, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;respuesta de cadena masiva&lt;/a&gt; : &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f23ea3c8266e3f5959aed27b93602e9cafb796f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">Si el &lt;code&gt;member&lt;/code&gt; no existe en el conjunto ordenado o la &lt;code&gt;key&lt;/code&gt; no existe, se devuelve &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3e9eec1dfb85dde46f12f033df8c95cb570dc1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; exists in the sorted set, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the rank of &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">Si el &lt;code&gt;member&lt;/code&gt; existe en el conjunto ordenado, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Respuesta entera&lt;/a&gt; : el rango del &lt;code&gt;member&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0602d8252b35c86b3177857f428ef2b6ebe2844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;password&lt;/code&gt; matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">Si la &lt;code&gt;password&lt;/code&gt; coincide con la contrase&amp;ntilde;a en el archivo de configuraci&amp;oacute;n, el servidor responde con el c&amp;oacute;digo de estado &lt;code&gt;OK&lt;/code&gt; y comienza a aceptar comandos. De lo contrario, se devuelve un error y los clientes deben probar una nueva contrase&amp;ntilde;a.</target>
        </trans-unit>
        <trans-unit id="25efaee0f3cfe5471248ed210126224686506e29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the first/last element from the list and pushing it as first/last element of the list, so it can be considered as a list rotation command (or a no-op if &lt;code&gt;wherefrom&lt;/code&gt; is the same as &lt;code&gt;whereto&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a36f67086d264992352bae73959a976d08f592" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</source>
          <target state="translated">Si la &lt;code&gt;source&lt;/code&gt; no existe, se devuelve el valor &lt;code&gt;nil&lt;/code&gt; y no se realiza ninguna operaci&amp;oacute;n. Si la &lt;code&gt;source&lt;/code&gt; y el &lt;code&gt;destination&lt;/code&gt; son iguales, la operaci&amp;oacute;n equivale a eliminar el &amp;uacute;ltimo elemento de la lista y empujarlo como primer elemento de la lista, por lo que puede considerarse como un comando de rotaci&amp;oacute;n de lista.</target>
        </trans-unit>
        <trans-unit id="5b26bcfdadbb106d42a10a68f68adf4977b43380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ttl&lt;/code&gt; is 0 the key is created without any expire, otherwise the specified expire time (in milliseconds) is set.</source>
          <target state="translated">Si &lt;code&gt;ttl&lt;/code&gt; es 0, la clave se crea sin caducidad; de lo contrario, se establece el tiempo de caducidad especificado (en milisegundos).</target>
        </trans-unit>
        <trans-unit id="2c1e9f5fc6b657f9746f093601d0e06e3be8a993" translate="yes" xml:space="preserve">
          <source>If AOF is activated, these additional fields will be added:</source>
          <target state="translated">Si se activa el AOF,se añadirán estos campos adicionales:</target>
        </trans-unit>
        <trans-unit id="3a074c9af49d118ca170e19c962a9318fe91cfe4" translate="yes" xml:space="preserve">
          <source>If a Redis 6.0 instance, or greater, is using the &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;Redis ACL system&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52fb5f5179b2d79edc8c3b551f845f186e716372" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an OK code, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6.</source>
          <target state="translated">Si un hijo de Redis est&amp;aacute; creando una instant&amp;aacute;nea en el disco, la reescritura de AOF est&amp;aacute; &lt;em&gt;programada,&lt;/em&gt; pero no se inicia hasta que finaliza el hijo que lo salv&amp;oacute; y que produjo el archivo RDB. En este caso, &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; seguir&amp;aacute; devolviendo un c&amp;oacute;digo OK, pero con un mensaje apropiado. Puede verificar si una reescritura de AOF est&amp;aacute; programada mirando el comando &lt;a href=&quot;info&quot;&gt;INFO a&lt;/a&gt; partir de Redis 2.6.</target>
        </trans-unit>
        <trans-unit id="a26aac34716b82962d62dd7eb321e26db471b019" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an positive status reply, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6 or successive versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fab76e64c7a99cf5ff09d3faf8bcf4e7b29c3b9" translate="yes" xml:space="preserve">
          <source>If a Redis server is already acting as replica, the command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">Si un servidor Redis ya est&amp;aacute; actuando como r&amp;eacute;plica, el comando &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NADIE apagar&amp;aacute; la r&amp;eacute;plica, convirtiendo el servidor Redis en un MAESTRO. En la forma adecuada, &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port har&amp;aacute; que el servidor sea una r&amp;eacute;plica de otro servidor que escucha en el nombre de host y puerto especificados.</target>
        </trans-unit>
        <trans-unit id="6bba5cc9a8544de84799044ff9489eaddadc2beb" translate="yes" xml:space="preserve">
          <source>If a SYNC operation is on-going, these additional fields are provided:</source>
          <target state="translated">Si se está llevando a cabo una operación SYNC,se proporcionan estos campos adicionales:</target>
        </trans-unit>
        <trans-unit id="b39dab88e7088d47355746e00cd5a3b16aea36b7" translate="yes" xml:space="preserve">
          <source>If a cluster instance has non-contiguous slots (e.g. 1-400,900,1800-6000) then master and replica IP/Port results will be duplicated for each top-level slot range reply.</source>
          <target state="translated">Si una instancia de cúmulo tiene ranuras no contiguas (por ejemplo,1-400,900,1800-6000)entonces los resultados de IP/puerto maestro y réplica se duplicarán para cada respuesta de rango de ranura de nivel superior.</target>
        </trans-unit>
        <trans-unit id="59220272c64271f85f1f97cc7691835ad64c2de3" translate="yes" xml:space="preserve">
          <source>If a command accepts an unlimited number of keys, the last key position is -1.</source>
          <target state="translated">Si un comando acepta un número ilimitado de teclas,la última posición de la tecla es -1.</target>
        </trans-unit>
        <trans-unit id="140a2742270e0d194dfebacb6a9c7a4820592aff" translate="yes" xml:space="preserve">
          <source>If a command accepts one key, the first key and last key positions is 1.</source>
          <target state="translated">Si un comando acepta una tecla,la primera y la última posición de la tecla es 1.</target>
        </trans-unit>
        <trans-unit id="c31655fb4face26cd02e88dd6486f34dd31bb51e" translate="yes" xml:space="preserve">
          <source>If a command accepts two keys (e.g. &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;, &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, ...) then the last key position is the location of the last key in the argument list.</source>
          <target state="translated">Si un comando acepta dos claves (por ejemplo , &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; , &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt; , &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; , ...) entonces la &amp;uacute;ltima posici&amp;oacute;n de clave es la ubicaci&amp;oacute;n de la &amp;uacute;ltima clave en la lista de argumentos.</target>
        </trans-unit>
        <trans-unit id="610d9883b3ed9e5bbf61e781dfb38f2ca5532e85" translate="yes" xml:space="preserve">
          <source>If a command is received about a key that does not exists, an &lt;code&gt;ASK&lt;/code&gt; redirection is emitted by the node, asking the client to retry only that specific query into &lt;code&gt;destination-node&lt;/code&gt;. In this case the client should not update its hash slot to node mapping.</source>
          <target state="translated">Si se recibe un comando sobre una clave que no existe, el nodo emite una redirecci&amp;oacute;n &lt;code&gt;ASK&lt;/code&gt; , pidiendo al cliente que vuelva a intentar solo esa consulta espec&amp;iacute;fica en &lt;code&gt;destination-node&lt;/code&gt; . En este caso, el cliente no deber&amp;iacute;a actualizar su ranura hash a la asignaci&amp;oacute;n de nodos.</target>
        </trans-unit>
        <trans-unit id="adc3a75aac4d6b35ed7b12ce05235e4cc640c05b" translate="yes" xml:space="preserve">
          <source>If a command is received about an existing key, the command is processed as usually.</source>
          <target state="translated">Si se recibe un comando sobre una clave existente,el comando se procesa como de costumbre.</target>
        </trans-unit>
        <trans-unit id="a64d2ec3bb10e34eb579070274923657d7138a2a" translate="yes" xml:space="preserve">
          <source>If a key is overwritten by &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, like in the case of an existing key &lt;code&gt;Key_A&lt;/code&gt; that is overwritten by a call like &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt;, it does not matter if the original &lt;code&gt;Key_A&lt;/code&gt; had a timeout associated or not, the new key &lt;code&gt;Key_A&lt;/code&gt; will inherit all the characteristics of &lt;code&gt;Key_B&lt;/code&gt;.</source>
          <target state="translated">Si una clave se sobrescribe con &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; , como en el caso de una clave existente &lt;code&gt;Key_A&lt;/code&gt; que se sobrescribe con una llamada como &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt; , no importa si la &lt;code&gt;Key_A&lt;/code&gt; original ten&amp;iacute;a un tiempo de espera asociado o no, la nueva clave &lt;code&gt;Key_A&lt;/code&gt; heredar&amp;aacute; todos las caracter&amp;iacute;sticas de &lt;code&gt;Key_B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0360f4a1e3e37b28bbc1c81856843472bd113d44" translate="yes" xml:space="preserve">
          <source>If a key is renamed with &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, the associated time to live is transferred to the new key name.</source>
          <target state="translated">Si se cambia el nombre de una clave con &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; , el tiempo de vida asociado se transfiere al nuevo nombre de la clave.</target>
        </trans-unit>
        <trans-unit id="dba073505eef52f13e35c2d2b072e15bc497f1c3" translate="yes" xml:space="preserve">
          <source>If a load operation is on-going, these additional fields will be added:</source>
          <target state="translated">Si una operación de carga está en curso,estos campos adicionales se añadirán:</target>
        </trans-unit>
        <trans-unit id="a8036cb18b462f0b09c70d787c53e11501cfbc97" translate="yes" xml:space="preserve">
          <source>If a node with unbound hash slots receives a heartbeat packet from another node that claims to be the owner of some of those hash slots, the association is established instantly. Moreover, if a heartbeat or update message is received with a configuration epoch greater than the node's own, the association is re-established.</source>
          <target state="translated">Si un nodo con ranuras de hachís no ligadas recibe un paquete de latidos de corazón de otro nodo que afirma ser el propietario de algunas de esas ranuras de hachís,la asociación se establece instantáneamente.Además,si se recibe un latido o un mensaje de actualización con una época de configuración mayor que la del propio nodo,la asociación se restablece.</target>
        </trans-unit>
        <trans-unit id="e6947348d36ca3b7d6ec64b0d3d493bff74f2cca" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">Si un servidor ya es una r&amp;eacute;plica de alg&amp;uacute;n maestro, el puerto de nombre de host &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; detendr&amp;aacute; la replicaci&amp;oacute;n contra el servidor antiguo e iniciar&amp;aacute; la sincronizaci&amp;oacute;n contra el nuevo, descartando el conjunto de datos antiguo.</target>
        </trans-unit>
        <trans-unit id="8355cef42438c57bf29e119daff3edf69a2eafac" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">Si un servidor ya es una r&amp;eacute;plica de alg&amp;uacute;n maestro, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port detendr&amp;aacute; la replicaci&amp;oacute;n contra el servidor antiguo e iniciar&amp;aacute; la sincronizaci&amp;oacute;n contra el nuevo, descartando el conjunto de datos antiguo.</target>
        </trans-unit>
        <trans-unit id="796f8c82d2cb3bc6674d519060d62df76a47b5cf" translate="yes" xml:space="preserve">
          <source>If an AOF rewrite is already in progress the command returns an error and no AOF rewrite will be scheduled for a later time.</source>
          <target state="translated">Si la reescritura del AOF ya está en marcha,el comando devuelve un error y no se programará ninguna reescritura del AOF para más adelante.</target>
        </trans-unit>
        <trans-unit id="aa95f2ff011f2ee3af55365c22aa9caf33f28db8" translate="yes" xml:space="preserve">
          <source>If an option already exists in the old redis.conf file, it will be rewritten at the same position (line number).</source>
          <target state="translated">Si ya existe una opción en el antiguo archivo redis.conf,se reescribirá en la misma posición (número de línea).</target>
        </trans-unit>
        <trans-unit id="4658daabd5c918d6c9d2de1223a7f5eb6d9fd842" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to a non-default value, it is appended at the end of the file.</source>
          <target state="translated">Si una opción no estaba ya presente,pero está configurada con un valor no predeterminado,se añade al final del archivo.</target>
        </trans-unit>
        <trans-unit id="e4228aca6b611c430e003ee894c91eb30a1b6cd7" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to its default value, it is not added by the rewrite process.</source>
          <target state="translated">Si una opción no estaba ya presente,pero está fijada en su valor por defecto,no se añade por el proceso de reescritura.</target>
        </trans-unit>
        <trans-unit id="b63f671253761bdf3174af266654497deb63ef4b" translate="yes" xml:space="preserve">
          <source>If another client, for instance C5, was faster than C4 and acquired the lock with the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation, the C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation will return a non expired timestamp. C4 will simply restart from the first step. Note that even if C4 set the key a bit a few seconds in the future this is not a problem.</source>
          <target state="translated">Si otro cliente, por ejemplo C5, fue m&amp;aacute;s r&amp;aacute;pido que C4 y adquiri&amp;oacute; el bloqueo con la operaci&amp;oacute;n &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; , la operaci&amp;oacute;n C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; devolver&amp;aacute; una marca de tiempo no vencida. C4 simplemente se reiniciar&amp;aacute; desde el primer paso. Tenga en cuenta que incluso si C4 establece la clave unos segundos en el futuro, esto no es un problema.</target>
        </trans-unit>
        <trans-unit id="37cf40db32d54ae3579f3237037ff5c92145f193" translate="yes" xml:space="preserve">
          <source>If at a given time a node has another node flagged with &lt;code&gt;PFAIL&lt;/code&gt;, and at the same time collected the majority of other master nodes &lt;em&gt;failure reports&lt;/em&gt; about this node (including itself if it is a master), then it elevates the failure state of the node from &lt;code&gt;PFAIL&lt;/code&gt; to &lt;code&gt;FAIL&lt;/code&gt;, and broadcasts a message forcing all the nodes that can be reached to flag the node as &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">Si en un momento dado un nodo tiene otro nodo marcado con &lt;code&gt;PFAIL&lt;/code&gt; , y al mismo tiempo recopil&amp;oacute; la mayor&amp;iacute;a de los &lt;em&gt;informes de falla&lt;/em&gt; de otros nodos maestros sobre este nodo (incluido &amp;eacute;l mismo si es un maestro), entonces eleva el estado de falla del nodo. de &lt;code&gt;PFAIL&lt;/code&gt; a &lt;code&gt;FAIL&lt;/code&gt; , y transmite un mensaje que obliga a todos los nodos a los que se puede acceder a marcar el nodo como &lt;code&gt;FAIL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5470ee8997d2330c4f1d3cb52035e4a73f57ce" translate="yes" xml:space="preserve">
          <source>If count is bigger than the number of elements inside the Set, the command will only return the whole set without additional elements.</source>
          <target state="translated">Si la cuenta es mayor que el número de elementos dentro del conjunto,el comando sólo devolverá el conjunto completo sin elementos adicionales.</target>
        </trans-unit>
        <trans-unit id="b7b84ded8883c2f1d689aced4377969210247451" translate="yes" xml:space="preserve">
          <source>If every line in the file is valid, all the ACLs are loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7166a4c2e9e0a7b189fdf30ab0234c6d47986ab4" translate="yes" xml:space="preserve">
          <source>If instead the message was already delivered to this consumer, and it is just re-fetching the same message again, then the &lt;em&gt;last delivery counter&lt;/em&gt; is updated to the current time, and the &lt;em&gt;number of deliveries&lt;/em&gt; is incremented by one. You can access those message properties using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">Si, en cambio, el mensaje ya se entreg&amp;oacute; a este consumidor, y simplemente est&amp;aacute; recuperando el mismo mensaje nuevamente, entonces el &lt;em&gt;&amp;uacute;ltimo contador de entrega&lt;/em&gt; se actualiza a la hora actual y el &lt;em&gt;n&amp;uacute;mero de entregas&lt;/em&gt; se incrementa en uno. Puede acceder a esas propiedades de mensaje utilizando el comando &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb7b53c8c56d77ba922276fcf8d6fc9a5555deb" translate="yes" xml:space="preserve">
          <source>If instead you want consumers to fetch the whole stream history, use zero as the starting ID for the consumer group:</source>
          <target state="translated">Si en cambio quieres que los consumidores obtengan todo el historial de la corriente,usa el cero como identificación inicial para el grupo de consumidores:</target>
        </trans-unit>
        <trans-unit id="766551fe9e9ea8009a726c50e78e04cbf000fc57" translate="yes" xml:space="preserve">
          <source>If more than 25% of keys were expired, start again from step 1.</source>
          <target state="translated">Si más del 25% de las llaves han caducado,empiece de nuevo desde el paso 1.</target>
        </trans-unit>
        <trans-unit id="18ba579c412c6a80f5484abbbc6da80390ec5935" translate="yes" xml:space="preserve">
          <source>If multiple clients are blocked for the same key, the first client to be served is the one that was waiting for more time (the first that blocked for the key). Once a client is unblocked it does not retain any priority, when it blocks again with the next call to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; it will be served accordingly to the number of clients already blocked for the same key, that will all be served before it (from the first to the last that blocked).</source>
          <target state="translated">Si se bloquean varios clientes para la misma clave, el primer cliente que se atiende es el que estuvo esperando m&amp;aacute;s tiempo (el primero que bloque&amp;oacute; la clave). Una vez que un cliente es desbloqueado no retiene ninguna prioridad, cuando se vuelve a bloquear con la pr&amp;oacute;xima llamada a &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; ser&amp;aacute; atendido de acuerdo a la cantidad de clientes ya bloqueados para la misma clave, que ser&amp;aacute;n atendidos todos antes que &amp;eacute;l (desde la primera hasta el &amp;uacute;ltimo que bloque&amp;oacute;).</target>
        </trans-unit>
        <trans-unit id="2d45448e42846cf1223f90529d7153a4f2ea7d57" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;pattern&lt;/code&gt; is specified, all the channels are listed, otherwise if pattern is specified only channels matching the specified glob-style pattern are listed.</source>
          <target state="translated">Si no se especifica ning&amp;uacute;n &lt;code&gt;pattern&lt;/code&gt; , se enumeran todos los canales; de lo contrario, si se especifica un patr&amp;oacute;n, solo se enumeran los canales que coinciden con el patr&amp;oacute;n de estilo global especificado.</target>
        </trans-unit>
        <trans-unit id="ea2697ae6fd039b4a66dbcb2f98b8550bd0df116" translate="yes" xml:space="preserve">
          <source>If no reset type is specified, the default is &lt;strong&gt;soft&lt;/strong&gt;.</source>
          <target state="translated">Si no se especifica ning&amp;uacute;n tipo de reinicio, el valor predeterminado es &lt;strong&gt;suave&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5e1cf1e0228d3ddab066d68bd268b73f915f6a" translate="yes" xml:space="preserve">
          <source>If none of the specified keys exist, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; blocks the connection until another client performs an &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; or &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; operation against one of the keys.</source>
          <target state="translated">Si no existe ninguna de las claves especificadas, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; bloquea la conexi&amp;oacute;n hasta que otro cliente realiza una operaci&amp;oacute;n &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; o &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; contra una de las claves.</target>
        </trans-unit>
        <trans-unit id="dfae9157f2f024976d442ab776949fdf1b2e1598" translate="yes" xml:space="preserve">
          <source>If one or both the members are missing, the command returns NULL.</source>
          <target state="translated">Si falta uno o ambos miembros,el comando regresa NULL.</target>
        </trans-unit>
        <trans-unit id="65c7882ecd3026e90538dbca3412ed2c9efa54bf" translate="yes" xml:space="preserve">
          <source>If one or more line in the file is not valid, nothing is loaded, and the old ACL rules defined in the server memory continue to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eccea0e4c99dbf5582f258e7eec112ee8e36e5c" translate="yes" xml:space="preserve">
          <source>If persistence is enabled this commands makes sure that Redis is switched off without the lost of any data. This is not guaranteed if the client uses simply &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; and then &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; because other clients may alter the DB data between the two commands.</source>
          <target state="translated">Si la persistencia est&amp;aacute; habilitada, estos comandos aseguran que Redis est&amp;eacute; apagado sin perder ning&amp;uacute;n dato. Esto no est&amp;aacute; garantizado si el cliente usa simplemente &lt;a href=&quot;save&quot;&gt;GUARDAR&lt;/a&gt; y luego &lt;a href=&quot;quit&quot;&gt;SALIR&lt;/a&gt; porque otros clientes pueden alterar los datos de la base de datos entre los dos comandos.</target>
        </trans-unit>
        <trans-unit id="3c4893d742c042232e8b2da1b66fa8109b95fc06" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; option is specified, the return value will be &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;:</source>
          <target state="translated">Si se especifica la opci&amp;oacute;n &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; , el valor de retorno ser&amp;aacute; &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Respuesta de cadena masiva&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5342c7f917832f9f61b997cae89d595cc203017d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ABSTTL&lt;/code&gt; modifier was used, &lt;code&gt;ttl&lt;/code&gt; should represent an absolute &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix timestamp&lt;/a&gt; (in milliseconds) in which the key will expire. (Redis 5.0 or greater).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0a958c78e44fc13ec8f13707e023532ae594ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ABSTTL&lt;/code&gt; modifier was used, &lt;code&gt;ttl&lt;/code&gt; should represent an absolute &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix timestamp&lt;/a&gt; (in milliseconds) in which the key will expire. (Redis 5.0 or greater).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c94188363158a9ff98bf015f1ddfb2076ba94d" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;BLOCK&lt;/strong&gt; option is not used, the command is synchronous, and can be considered somewhat related to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;: it will return a range of items inside streams, however it has two fundamental differences compared to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; even if we just consider the synchronous usage:</source>
          <target state="translated">Si no se usa la opci&amp;oacute;n &lt;strong&gt;BLOCK&lt;/strong&gt; , el comando es s&amp;iacute;ncrono y puede considerarse algo relacionado con &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; : devolver&amp;aacute; un rango de elementos dentro de las transmisiones, sin embargo, tiene dos diferencias fundamentales en comparaci&amp;oacute;n con &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; incluso si solo consideramos el uso sincr&amp;oacute;nico:</target>
        </trans-unit>
        <trans-unit id="2a8ebc8cb8dd39729bf6fdaaa9469b8e9dd31c5f" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;FORCE&lt;/strong&gt; option is given, the replica does not perform any handshake with the master, that may be not reachable, but instead just starts a failover ASAP starting from point 4. This is useful when we want to start a manual failover while the master is no longer reachable.</source>
          <target state="translated">Si se da la opci&amp;oacute;n &lt;strong&gt;FORCE&lt;/strong&gt; , la r&amp;eacute;plica no realiza ning&amp;uacute;n apret&amp;oacute;n de manos con el maestro, que puede no ser accesible, sino que solo inicia una conmutaci&amp;oacute;n por error lo antes posible a partir del punto 4. Esto es &amp;uacute;til cuando queremos iniciar una conmutaci&amp;oacute;n por error manual mientras el maestro ya no es accesible.</target>
        </trans-unit>
        <trans-unit id="41e165a8913dade3e9bd91924016ff8d6cab273f" translate="yes" xml:space="preserve">
          <source>If the AOF rewrite could start, but the attempt at starting it fails (for instance because of an error in creating the child process), an error is returned to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32dde384b66bbd79b525259d52aa9797e8b17bb3" translate="yes" xml:space="preserve">
          <source>If the Redis server is password protected via the &lt;code&gt;requirepass&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fded77f647c95a1a86355a7eafad08fd193bd854" translate="yes" xml:space="preserve">
          <source>If the above condition happens using a Redis 2.6 server or greater, Client &lt;strong&gt;A&lt;/strong&gt; will be served with the &lt;code&gt;c&lt;/code&gt; element, because after the &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; command the list contains &lt;code&gt;c,b,a&lt;/code&gt;, so taking an element from the left means to return &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Si la condici&amp;oacute;n anterior ocurre usando un servidor Redis 2.6 o superior, el Cliente &lt;strong&gt;A&lt;/strong&gt; recibir&amp;aacute; el elemento &lt;code&gt;c&lt;/code&gt; , porque despu&amp;eacute;s del comando &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; la lista contiene &lt;code&gt;c,b,a&lt;/code&gt; , por lo que tomar un elemento de la izquierda significa devolver &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc531ff7f9715b58415dfa6813dab3cc7b073afd" translate="yes" xml:space="preserve">
          <source>If the approximated cardinality estimated by the HyperLogLog changed after executing the command, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; returns 1, otherwise 0 is returned. The command automatically creates an empty HyperLogLog structure (that is, a Redis String of a specified length and with a given encoding) if the specified key does not exist.</source>
          <target state="translated">Si la cardinalidad aproximada estimada por HyperLogLog cambi&amp;oacute; despu&amp;eacute;s de ejecutar el comando, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; devuelve 1; de lo contrario, devuelve 0. El comando crea autom&amp;aacute;ticamente una estructura HyperLogLog vac&amp;iacute;a (es decir, una cadena Redis de una longitud especificada y con una codificaci&amp;oacute;n determinada) si la clave especificada no existe.</target>
        </trans-unit>
        <trans-unit id="2a7df869ee4ed74778e5142a4cec6fc019c36dbe" translate="yes" xml:space="preserve">
          <source>If the client is subscribed to a channel or a pattern, it will instead return a multi-bulk with a &quot;pong&quot; in the first position and an empty bulk in the second position, unless an argument is provided in which case it returns a copy of the argument.</source>
          <target state="translated">Si el cliente está suscrito a un canal o a un patrón,devolverá en cambio un multi-bulto con un &quot;pong&quot; en la primera posición y un bulto vacío en la segunda,a menos que se proporcione un argumento,en cuyo caso devolverá una copia del mismo.</target>
        </trans-unit>
        <trans-unit id="1e3b4ecb886491d18a97620613800a70a1d78a2c" translate="yes" xml:space="preserve">
          <source>If the client tries to blocks for multiple keys, but at least one key contains elements, the returned key / element pair is the first key from left to right that has one or more elements. In this case the client is not blocked. So for instance &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt;, assuming that both &lt;code&gt;key2&lt;/code&gt; and &lt;code&gt;key4&lt;/code&gt; are non-empty, will always return an element from &lt;code&gt;key2&lt;/code&gt;.</source>
          <target state="translated">Si el cliente intenta bloquear varias claves, pero al menos una clave contiene elementos, el par clave / elemento devuelto es la primera clave de izquierda a derecha que tiene uno o m&amp;aacute;s elementos. En este caso, el cliente no est&amp;aacute; bloqueado. Entonces, por ejemplo, &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt; , asumiendo que tanto &lt;code&gt;key2&lt;/code&gt; como &lt;code&gt;key4&lt;/code&gt; no est&amp;aacute;n vac&amp;iacute;os, siempre devolver&amp;aacute; un elemento de &lt;code&gt;key2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4c4a551c5294109d275f4efb02ba586ea39cd4b" translate="yes" xml:space="preserve">
          <source>If the command contains multiple keys, in case none exist, the behavior is the same as point 2, if all exist, it is the same as point 1, however if only a partial number of keys exist, the command emits a &lt;code&gt;TRYAGAIN&lt;/code&gt; error in order for the keys interested to finish being migrated to the target node, so that the multi keys command can be executed.</source>
          <target state="translated">Si el comando contiene m&amp;uacute;ltiples claves, en caso de que no exista ninguna, el comportamiento es el mismo que en el punto 2, si todas existen, es el mismo que el punto 1, sin embargo si solo existe un n&amp;uacute;mero parcial de claves, el comando emite un error &lt;code&gt;TRYAGAIN&lt;/code&gt; en orden para que las claves interesadas terminen de ser migradas al nodo de destino, para que se pueda ejecutar el comando multi keys.</target>
        </trans-unit>
        <trans-unit id="b47c13f341545793a768bad91b706c8230117dd6" translate="yes" xml:space="preserve">
          <source>If the command is sent as part of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; transaction, the command does not block but instead just return ASAP the number of replicas that acknowledged the previous write commands.</source>
          <target state="translated">Si el comando se env&amp;iacute;a como parte de una transacci&amp;oacute;n &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; , el comando no bloquea, sino que simplemente devuelve lo antes posible la cantidad de r&amp;eacute;plicas que reconocieron los comandos de escritura anteriores.</target>
        </trans-unit>
        <trans-unit id="b2647b206316067e60c5c58ad3dabbd5311d10db" translate="yes" xml:space="preserve">
          <source>If the command is successful the new incremented value is stored as the new value of the key (replacing the old one), and returned to the caller as a string.</source>
          <target state="translated">Si el comando tiene éxito,el nuevo valor incrementado se almacena como el nuevo valor de la clave (sustituyendo al antiguo),y se devuelve al llamante como una cadena.</target>
        </trans-unit>
        <trans-unit id="e13c77b4e4b0cd6a39fdb6c6dd3019929d6f047e" translate="yes" xml:space="preserve">
          <source>If the command succeeds the new replica will immediately try to contact its master in order to replicate from it.</source>
          <target state="translated">Si el comando tiene éxito,la nueva réplica intentará inmediatamente contactar con su maestro para replicar desde él.</target>
        </trans-unit>
        <trans-unit id="58e50abae2f1a6949ff81b62d232f71c48c7e358" translate="yes" xml:space="preserve">
          <source>If the current hash slot owner is the node receiving the command, but for effect of the command the slot would be assigned to a different node, the command will return an error if there are still keys for that hash slot in the node receiving the command.</source>
          <target state="translated">Si el propietario actual del hash slot es el nodo que recibe el comando,pero por efecto del comando el slot se asignaría a un nodo diferente,el comando devolverá un error si todavía hay claves para ese hash slot en el nodo que recibe el comando.</target>
        </trans-unit>
        <trans-unit id="8bdc0729f7e8e3e8d69c4bf5f17ea02031eef1ea" translate="yes" xml:space="preserve">
          <source>If the destination variable exists, it is treated as one of the source sets and its cardinality will be included in the cardinality of the computed HyperLogLog.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16a9421e847dd28010cba3e62963f9099073a99" translate="yes" xml:space="preserve">
          <source>If the elements in the sorted set have different scores, the returned elements are unspecified.</source>
          <target state="translated">Si los elementos del conjunto clasificado tienen diferentes puntuaciones,los elementos devueltos no se especifican.</target>
        </trans-unit>
        <trans-unit id="3481b2e7b6d800470df672a8874ad9a04f6afdca" translate="yes" xml:space="preserve">
          <source>If the instance is a replica, these additional fields are provided:</source>
          <target state="translated">Si la instancia es una réplica,se proporcionan estos campos adicionales:</target>
        </trans-unit>
        <trans-unit id="a39168a871f5b0b2ac68a8345a687deba4b95089" translate="yes" xml:space="preserve">
          <source>If the link between master and replica is down, an additional field is provided:</source>
          <target state="translated">Si el enlace entre el maestro y la réplica no funciona,se proporciona un campo adicional:</target>
        </trans-unit>
        <trans-unit id="5d43590cf68cfd82fc6f591b087a5f138a1a7c3f" translate="yes" xml:space="preserve">
          <source>If the message was never delivered to anyone, that is, if we are talking about a new message, then a PEL (Pending Entry List) is created.</source>
          <target state="translated">Si el mensaje nunca fue entregado a nadie,es decir,si estamos hablando de un nuevo mensaje,entonces se crea una PEL (Lista de Entradas Pendientes).</target>
        </trans-unit>
        <trans-unit id="638ffe7f713cb2cff80e46aae12ead14d0ec33c3" translate="yes" xml:space="preserve">
          <source>If the node is a replica it is turned into an (empty) master. Its dataset is flushed, so at the end the node will be an empty master.</source>
          <target state="translated">Si el nodo es una réplica se convierte en un maestro (vacío).Su conjunto de datos se elimina,así que al final el nodo será un maestro vacío.</target>
        </trans-unit>
        <trans-unit id="1785c288c16b021950b10d9d886a7eae6f023094" translate="yes" xml:space="preserve">
          <source>If the node receiving the command is not already a replica, but is a master, the command will only succeed, and the node will be converted into a replica, only if the following additional conditions are met:</source>
          <target state="translated">Si el nodo que recibe el comando no es ya una réplica,sino un maestro,el comando sólo tendrá éxito,y el nodo se convertirá en una réplica,sólo si se cumplen las siguientes condiciones adicionales:</target>
        </trans-unit>
        <trans-unit id="0d7f2602b57e25d3482f6de95a393b6a52d114e4" translate="yes" xml:space="preserve">
          <source>If the object you try to inspect is missing, a null bulk reply is returned.</source>
          <target state="translated">Si el objeto que intenta inspeccionar falta,se devuelve una respuesta de volumen nulo.</target>
        </trans-unit>
        <trans-unit id="502f345996f0414bbb8039bdf0ba7a24bdfc3f8f" translate="yes" xml:space="preserve">
          <source>If the password provided via AUTH matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8069378ad909326b9b791fda111aafbf70922eb2" translate="yes" xml:space="preserve">
          <source>If the rules contain errors, the error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8b33783f226cf240802124131a6b3112f200a2" translate="yes" xml:space="preserve">
          <source>If the script already called write commands the only allowed command becomes &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; that stops the server without saving the current data set on disk (basically the server is aborted).</source>
          <target state="translated">Si el script ya se llama comandos de escritura, el &amp;uacute;nico comando permitido se convierte en &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; que detiene el servidor sin guardar el conjunto de datos actual en el disco (b&amp;aacute;sicamente, el servidor se aborta).</target>
        </trans-unit>
        <trans-unit id="7d7312df2553f6628fdfae5411ba0776826d8dfb" translate="yes" xml:space="preserve">
          <source>If the script already performed write operations it can not be killed in this way because it would violate Lua script atomicity contract. In such a case only &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; is able to kill the script, killing the Redis process in an hard way preventing it to persist with half-written information.</source>
          <target state="translated">Si el script ya realiz&amp;oacute; operaciones de escritura, no se puede eliminar de esta manera porque violar&amp;iacute;a el contrato de atomicidad del script Lua. En tal caso, solo &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; es capaz de matar el script, matando el proceso de Redis de una manera dif&amp;iacute;cil evitando que persista con informaci&amp;oacute;n a medio escribir.</target>
        </trans-unit>
        <trans-unit id="5aeedf1a85f8e143cfd4057ccfb92d5e01611feb" translate="yes" xml:space="preserve">
          <source>If the server does not remember a script with this SHA1 digest, a special error is returned telling the client to use &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; instead.</source>
          <target state="translated">Si el servidor no recuerda un script con este resumen SHA1, se devuelve un error especial que le indica al cliente que use &lt;a href=&quot;eval&quot;&gt;EVAL en su&lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="8c526024cc2b0adff52463eae82153b3e7035275" translate="yes" xml:space="preserve">
          <source>If the server is configured with the &lt;code&gt;min-slaves-to-write&lt;/code&gt; (or starting with Redis 5 with the &lt;code&gt;min-replicas-to-write&lt;/code&gt;) directive, an additional field is provided:</source>
          <target state="translated">Si el servidor est&amp;aacute; configurado con la directiva &lt;code&gt;min-slaves-to-write&lt;/code&gt; (o comenzando con Redis 5 con la directiva &lt;code&gt;min-replicas-to-write&lt;/code&gt; ), se proporciona un campo adicional:</target>
        </trans-unit>
        <trans-unit id="160c785d0bbfa994844826d34af71d6ba78bcac0" translate="yes" xml:space="preserve">
          <source>If the server still remembers a script with a matching SHA1 digest, the script is executed.</source>
          <target state="translated">Si el servidor todavía recuerda un script con un resumen SHA1 correspondiente,el script se ejecuta.</target>
        </trans-unit>
        <trans-unit id="a73ff8adff60cf3faa9396c7d82031cce8e1eee5" translate="yes" xml:space="preserve">
          <source>If the slot is in &lt;em&gt;migrating&lt;/em&gt; state, the state gets cleared when the slot is assigned to another node.</source>
          <target state="translated">Si la ranura est&amp;aacute; en estado de &lt;em&gt;migraci&amp;oacute;n&lt;/em&gt; , el estado se borra cuando la ranura se asigna a otro nodo.</target>
        </trans-unit>
        <trans-unit id="4fb7824817ed0173726151921ede13e72a5a9bcf" translate="yes" xml:space="preserve">
          <source>If the slot was in &lt;em&gt;importing&lt;/em&gt; state in the node receiving the command, and the command assigns the slot to this node (which happens in the target node at the end of the resharding of a hash slot from one node to another), the command has the following side effects: A) the &lt;em&gt;importing&lt;/em&gt; state is cleared. B) If the node config epoch is not already the greatest of the cluster, it generates a new one and assigns the new config epoch to itself. This way its new hash slot ownership will win over any past configuration created by previous failovers or slot migrations.</source>
          <target state="translated">Si la ranura estaba en estado de &lt;em&gt;importaci&amp;oacute;n&lt;/em&gt; en el nodo que recibe el comando, y el comando asigna la ranura a este nodo (lo que ocurre en el nodo de destino al final de la compartici&amp;oacute;n de una ranura hash de un nodo a otro), el comando tiene los siguientes efectos secundarios: A) se borra el estado de &lt;em&gt;importaci&amp;oacute;n&lt;/em&gt; . B) Si la &amp;eacute;poca de configuraci&amp;oacute;n del nodo a&amp;uacute;n no es la mayor del cl&amp;uacute;ster, genera una nueva y se asigna a s&amp;iacute; mismo la nueva &amp;eacute;poca de configuraci&amp;oacute;n. De esta manera, su nueva propiedad de ranura hash ganar&amp;aacute; cualquier configuraci&amp;oacute;n pasada creada por conmutaciones por error o migraciones de ranuras anteriores.</target>
        </trans-unit>
        <trans-unit id="e8cd47d9356aab972b5f2bd3e87e1b06b6cacf48" translate="yes" xml:space="preserve">
          <source>If the source set does not exist or does not contain the specified element, no operation is performed and &lt;code&gt;0&lt;/code&gt; is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</source>
          <target state="translated">Si el conjunto fuente no existe o no contiene el elemento especificado, no se realiza ninguna operaci&amp;oacute;n y se devuelve &lt;code&gt;0&lt;/code&gt; . De lo contrario, el elemento se elimina del conjunto de origen y se agrega al conjunto de destino. Cuando el elemento especificado ya existe en el conjunto de destino, solo se elimina del conjunto de origen.</target>
        </trans-unit>
        <trans-unit id="3ca48297ca2c9df85be826386d88391801b54916" translate="yes" xml:space="preserve">
          <source>If the specified stream doesn't exist when creating a group, an error will be returned. You can use the optional &lt;code&gt;MKSTREAM&lt;/code&gt; subcommand as the last argument after the &lt;code&gt;ID&lt;/code&gt; to automatically create the stream, if it doesn't exist. Note that if the stream is created in this way it will have a length of 0:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a65b6aeeded425b23af7e95965a0f641dbdc37" translate="yes" xml:space="preserve">
          <source>If the user already exists, the provided ACL rules are simply applied &lt;em&gt;in addition&lt;/em&gt; to the rules already set. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da52acca0f5817a572a7d2dfec4d48663d8d1b71" translate="yes" xml:space="preserve">
          <source>If the user inserts all the elements in a sorted set with the same score (for example 0), all the elements of the sorted set are sorted lexicographically, and range queries on elements are possible using the command &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Note: it is also possible to query sorted sets by range of scores using &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;).</source>
          <target state="translated">Si el usuario inserta todos los elementos en un conjunto ordenado con la misma puntuaci&amp;oacute;n (por ejemplo, 0), todos los elementos del conjunto ordenado se ordenan lexicogr&amp;aacute;ficamente, y las consultas de rango sobre elementos son posibles usando el comando &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Nota: tambi&amp;eacute;n es posible para consultar conjuntos ordenados por rango de puntajes usando &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bb5f5ae1336c1db943d20a454954235747a6d64e" translate="yes" xml:space="preserve">
          <source>If the user will be idle more than 60 seconds, the key will be deleted and only subsequent page views that have less than 60 seconds of difference will be recorded.</source>
          <target state="translated">Si el usuario está inactivo más de 60 segundos,la tecla se borrará y sólo se registrarán las siguientes visitas a la página que tengan menos de 60 segundos de diferencia.</target>
        </trans-unit>
        <trans-unit id="dca107e1698238aa60bfb450d46b8e949be6578e" translate="yes" xml:space="preserve">
          <source>If there are no keys to migrate in the source instance &lt;code&gt;NOKEY&lt;/code&gt; is returned. Because missing keys are possible in normal conditions, from expiry for example, &lt;code&gt;NOKEY&lt;/code&gt; isn't an error.</source>
          <target state="translated">Si no hay claves para migrar en la instancia de &lt;code&gt;NOKEY&lt;/code&gt; se devuelve NOKEY . Debido a que es posible que falten claves en condiciones normales, por ejemplo, desde el vencimiento, &lt;code&gt;NOKEY&lt;/code&gt; no es un error.</target>
        </trans-unit>
        <trans-unit id="65645be10cc140f75bd2c8251142687f4fa78461" translate="yes" xml:space="preserve">
          <source>If we generate a configuration epoch which happens to collide with another instance, eventually our configuration epoch, or the one of another instance with our same epoch, will be moved away using the &lt;em&gt;configuration epoch collision resolution algorithm&lt;/em&gt;.</source>
          <target state="translated">Si generamos una &amp;eacute;poca de configuraci&amp;oacute;n que colisiona con otra instancia, eventualmente nuestra &amp;eacute;poca de configuraci&amp;oacute;n, o la de otra instancia con nuestra misma &amp;eacute;poca, se mover&amp;aacute; usando el &lt;em&gt;algoritmo de resoluci&amp;oacute;n de colisiones de &amp;eacute;poca de configuraci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f79d56180a9ad1d3aeb8220feacf255be61da4" translate="yes" xml:space="preserve">
          <source>If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value &lt;code&gt;0xff&lt;/code&gt; the command &lt;code&gt;BITPOS key 0&lt;/code&gt; will return 24, since up to bit 23 all the bits are 1.</source>
          <target state="translated">Si buscamos bits claros (el argumento de bit es 0) y la cadena solo contiene el bit establecido en 1, la funci&amp;oacute;n devuelve el primer bit que no forma parte de la cadena de la derecha. Entonces, si la cadena tiene tres bytes establecidos en el valor &lt;code&gt;0xff&lt;/code&gt; , el comando &lt;code&gt;BITPOS key 0&lt;/code&gt; devolver&amp;aacute; 24, ya que hasta el bit 23 todos los bits son 1.</target>
        </trans-unit>
        <trans-unit id="44b33ba5659f824ae39b000fc70d2cf7d6138c7b" translate="yes" xml:space="preserve">
          <source>If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.</source>
          <target state="translated">Si buscamos bits fijos (el argumento de los bits es 1)y la cadena está vacía o compuesta sólo de cero bytes,se devuelve -1.</target>
        </trans-unit>
        <trans-unit id="2012c008377fbb50737408462ade88dce859c2ba" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; or &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;, there's no need to manually call &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;.</source>
          <target state="translated">Si llama a &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; o &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; , no es necesario llamar manualmente a &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7adf0ee2bf057d6e4f3261ad571f6a13a6962d80" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want all the clients to get all the messages, you do not need a consumer group.</source>
          <target state="translated">Si tienes un flujo y múltiples clientes,y quieres que todos los clientes reciban todos los mensajes,no necesitas un grupo de consumidores.</target>
        </trans-unit>
        <trans-unit id="7914b0ae2e05e8d2f74a0d7390601ab548d893de" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;sharded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560057ad39d223339741232ee3fcc91b0feb1edf" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;shareded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">Si tiene una secuencia y varios clientes, y desea que la secuencia se &lt;em&gt;particione&lt;/em&gt; o se &lt;em&gt;comparta&lt;/em&gt; entre sus clientes, de modo que cada cliente obtenga un subconjunto de los mensajes que llegan en una secuencia, necesita un grupo de consumidores.</target>
        </trans-unit>
        <trans-unit id="b31dd57013b909fbb7b7346c7faa280640e4841b" translate="yes" xml:space="preserve">
          <source>If you like science fiction, think of time flowing at infinite speed inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block...</source>
          <target state="translated">Si te gusta la ciencia ficci&amp;oacute;n, piensa en el tiempo que fluye a una velocidad infinita dentro de un bloque &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="c010cb9076ea01e47bb02d7ca64129ac264912a3" translate="yes" xml:space="preserve">
          <source>If you look for an &lt;code&gt;XGET&lt;/code&gt; command you'll be disappointed because &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; is effectively the way to go in order to fetch a single entry from a stream. All you have to do is to specify the ID two times in the arguments of XRANGE:</source>
          <target state="translated">Si busca un comando &lt;code&gt;XGET&lt;/code&gt; , se sentir&amp;aacute; decepcionado porque &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; es efectivamente el camino a seguir para obtener una sola entrada de una secuencia. Todo lo que tiene que hacer es especificar el ID dos veces en los argumentos de XRANGE:</target>
        </trans-unit>
        <trans-unit id="9b173c7e7e26659d2dc21433cf73d902805a206a" translate="yes" xml:space="preserve">
          <source>If you request details about non-existing commands, their return position will be nil.</source>
          <target state="translated">Si pide detalles sobre comandos inexistentes,su posición de retorno será nula.</target>
        </trans-unit>
        <trans-unit id="12acfb0048a8a9bf03f38f7e388902128cc410f3" translate="yes" xml:space="preserve">
          <source>Imagine you have a web service and you are interested in the latest N pages &lt;em&gt;recently&lt;/em&gt; visited by your users, such that each adjacent page view was not performed more than 60 seconds after the previous. Conceptually you may consider this set of page views as a &lt;em&gt;Navigation session&lt;/em&gt; of your user, that may contain interesting information about what kind of products he or she is looking for currently, so that you can recommend related products.</source>
          <target state="translated">Imagine que tiene un servicio web y est&amp;aacute; interesado en las &amp;uacute;ltimas N p&amp;aacute;ginas visitadas &lt;em&gt;recientemente&lt;/em&gt; por sus usuarios, de modo que cada vista de p&amp;aacute;gina adyacente no se realiz&amp;oacute; m&amp;aacute;s de 60 segundos despu&amp;eacute;s de la anterior. Conceptualmente, puede considerar este conjunto de p&amp;aacute;ginas vistas como una &lt;em&gt;sesi&amp;oacute;n&lt;/em&gt; de &lt;em&gt;navegaci&amp;oacute;n&lt;/em&gt; de su usuario, que puede contener informaci&amp;oacute;n interesante sobre qu&amp;eacute; tipo de productos est&amp;aacute; buscando actualmente, para que pueda recomendar productos relacionados.</target>
        </trans-unit>
        <trans-unit id="3fb9a33bf9d1d9a11eb463de937edd8bbe41eff8" translate="yes" xml:space="preserve">
          <source>Imagine you have elements A, B and C with weights 1, 2 and 3. You compute the sum of the weights, which is 1+2+3 = 6</source>
          <target state="translated">Imagina que tienes los elementos A,B y C con los pesos 1,2 y 3.Calculas la suma de los pesos,que es 1+2+3=6</target>
        </trans-unit>
        <trans-unit id="28adac3b6124834ed39c280b45702edaf27ac85d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">Implemente &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Detalles de la implementación</target>
        </trans-unit>
        <trans-unit id="11672e7162d8cdc131bd8b02c509dcb60a9d776d" translate="yes" xml:space="preserve">
          <source>Implementation details and notes</source>
          <target state="translated">Detalles de la aplicación y notas</target>
        </trans-unit>
        <trans-unit id="cc7649d9b862b15149646b67450f76a9d95f07c8" translate="yes" xml:space="preserve">
          <source>Implementation details: MEET and PING packets</source>
          <target state="translated">Detalles de la implementación:Paquetes MEET y PING</target>
        </trans-unit>
        <trans-unit id="c5a3d437892d8fb38c145f676153ba0009f546b9" translate="yes" xml:space="preserve">
          <source>Important: &lt;strong&gt;there is no need to use the same COUNT value&lt;/strong&gt; for every iteration. The caller is free to change the count from one iteration to the other as required, as long as the cursor passed in the next call is the one obtained in the previous call to the command.</source>
          <target state="translated">Importante: &lt;strong&gt;no es necesario utilizar el mismo valor COUNT&lt;/strong&gt; para cada iteraci&amp;oacute;n. La persona que llama es libre de cambiar el recuento de una iteraci&amp;oacute;n a la otra seg&amp;uacute;n sea necesario, siempre que el cursor pasado en la siguiente llamada sea el obtenido en la llamada anterior al comando.</target>
        </trans-unit>
        <trans-unit id="b6980584e557c93bab34f4259447d38dd3a9c928" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are emitted in the &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output as follows:</source>
          <target state="translated">La importaci&amp;oacute;n y migraci&amp;oacute;n de ranuras se emiten en la salida de &lt;a href=&quot;cluster-nodes&quot;&gt;NODOS DE CLUSTER de la&lt;/a&gt; siguiente manera:</target>
        </trans-unit>
        <trans-unit id="50ac60eae9cbac9b1534be93c64ff4eb8e05e3df" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are provided as &lt;strong&gt;additional info&lt;/strong&gt;. If the node has a given hash slot assigned, it will be also a plain number in the list of hash slots, so clients that don't have a clue about hash slots migrations can just skip this special fields.</source>
          <target state="translated">Las ranuras de importaci&amp;oacute;n y migraci&amp;oacute;n se proporcionan como &lt;strong&gt;informaci&amp;oacute;n adicional&lt;/strong&gt; . Si el nodo tiene asignada una ranura de hash determinada, tambi&amp;eacute;n ser&amp;aacute; un n&amp;uacute;mero simple en la lista de ranuras de hash, por lo que los clientes que no tienen ni idea de las migraciones de ranuras de hash pueden simplemente omitir estos campos especiales.</target>
        </trans-unit>
        <trans-unit id="779e3f1f46c82af5ed6e618104fadfbd8c5eb506" translate="yes" xml:space="preserve">
          <source>In Cluster mode, both &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;newkey&lt;/code&gt; must be in the same &lt;strong&gt;hash slot&lt;/strong&gt;, meaning that in practice only keys that have the same hash tag can be reliably renamed in cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69ceca772f34d784aadd1c27595fdabe97b5262" translate="yes" xml:space="preserve">
          <source>In Redis 2.4 the expire might not be pin-point accurate, and it could be between zero to one seconds out.</source>
          <target state="translated">En Redis 2.4 la caducidad podría no ser exacta,y podría estar entre cero y un segundo.</target>
        </trans-unit>
        <trans-unit id="404f7b7c02b7867c0901ee21294f6e2f5fef0d3c" translate="yes" xml:space="preserve">
          <source>In Redis 2.6 or older the command returns &lt;code&gt;-1&lt;/code&gt; if the key does not exist or if the key exist but has no associated expire.</source>
          <target state="translated">En Redis 2.6 o anterior, el comando devuelve &lt;code&gt;-1&lt;/code&gt; si la clave no existe o si la clave existe pero no tiene caducidad asociada.</target>
        </trans-unit>
        <trans-unit id="8b69e0b775a7565070cf9c5f2db4bd807c015a5f" translate="yes" xml:space="preserve">
          <source>In Redis Cluster, each node keeps track of which master is serving a particular hash slot.</source>
          <target state="translated">En el cúmulo de Redis,cada nodo lleva un registro de qué maestro está sirviendo un determinado espacio de hachís.</target>
        </trans-unit>
        <trans-unit id="d172f4fd77faed8def89fa030ed71bc01d833ea7" translate="yes" xml:space="preserve">
          <source>In Redis version 4, commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements. However starting with Redis 5 there is no longer such ordering step, because Redis 5 replicates scripts in a way that no longer needs non-deterministic commands to be converted into deterministic ones. In general, even when developing for Redis 4, never assume that certain commands in Lua will be ordered, but instead rely on the documentation of the original command you call to see the properties it provides.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0bdbf698aa8eaf887d7877ad1c2d9ea20b7520a" translate="yes" xml:space="preserve">
          <source>In Redis versions prior &lt;strong&gt;2.1.3&lt;/strong&gt; altering a key with an expire set using a command altering its value had the effect of removing the key entirely. This semantics was needed because of limitations in the replication layer that are now fixed.</source>
          <target state="translated">En las versiones de Redis anteriores a &lt;strong&gt;2.1.3,&lt;/strong&gt; alterar una clave con un vencimiento establecido mediante un comando que modificaba su valor ten&amp;iacute;a el efecto de eliminar la clave por completo. Esta sem&amp;aacute;ntica era necesaria debido a las limitaciones en la capa de replicaci&amp;oacute;n que ahora est&amp;aacute;n arregladas.</target>
        </trans-unit>
        <trans-unit id="532b5a4c8c089bdea2a3dcd755e5c2d0a78f31ac" translate="yes" xml:space="preserve">
          <source>In a Redis Cluster clients can publish to every node. The cluster makes sure that published messages are forwarded as needed, so clients can subscribe to any channel by connecting to any one of the nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f272b3296928896a7fa9c51b4f28ffa23b9540" translate="yes" xml:space="preserve">
          <source>In future versions of Redis it is possible that we'll trigger a node garbage collection in case a given macro-node reaches a given amount of deleted entries. Currently with the usage we anticipate for this data structure, it is not a good idea to add such complexity.</source>
          <target state="translated">En futuras versiones de Redis es posible que activemos un nodo de recogida de basura en caso de que un macro-nodo dado alcance una cantidad determinada de entradas borradas.Actualmente con el uso que anticipamos para esta estructura de datos,no es una buena idea añadir tal complejidad.</target>
        </trans-unit>
        <trans-unit id="420ffa2728e82649ac426218fc502611ceb5c012" translate="yes" xml:space="preserve">
          <source>In general what you should know is that setting the &lt;code&gt;appendonly&lt;/code&gt; parameter to &lt;code&gt;yes&lt;/code&gt; will start a background process to save the initial append-only file (obtained from the in memory data set), and will append all the subsequent commands on the append-only file, thus obtaining exactly the same effect of a Redis server that started with AOF turned on since the start.</source>
          <target state="translated">En general, lo que debe saber es que si establece el par&amp;aacute;metro &lt;code&gt;appendonly&lt;/code&gt; en &lt;code&gt;yes&lt;/code&gt; , se iniciar&amp;aacute; un proceso en segundo plano para guardar el archivo inicial de solo agregar (obtenido del conjunto de datos en la memoria), y agregar&amp;aacute; todos los comandos subsiguientes en el archivo de solo agregar , obteniendo as&amp;iacute; exactamente el mismo efecto de un servidor Redis que empez&amp;oacute; con AOF activado desde el principio.</target>
        </trans-unit>
        <trans-unit id="464e556758431df2768b0136fb61ecadb0a9af07" translate="yes" xml:space="preserve">
          <source>In its synchronous form, the command can get new data as long as there are more items available. However, at some point, we'll have to wait for producers of data to use &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; to push new entries inside the streams we are consuming. In order to avoid polling at a fixed or adaptive interval the command is able to block if it could not return any data, according to the specified streams and IDs, and automatically unblock once one of the requested keys accept data.</source>
          <target state="translated">En su forma s&amp;iacute;ncrona, el comando puede obtener nuevos datos siempre que haya m&amp;aacute;s elementos disponibles. Sin embargo, en alg&amp;uacute;n momento, tendremos que esperar a que los productores de datos usen &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; para impulsar nuevas entradas dentro de los flujos que estamos consumiendo. Para evitar el sondeo en un intervalo fijo o adaptativo, el comando puede bloquear si no puede devolver ning&amp;uacute;n dato, de acuerdo con los flujos e ID especificados, y desbloquear autom&amp;aacute;ticamente una vez que una de las claves solicitadas acepta datos.</target>
        </trans-unit>
        <trans-unit id="f71d43ee55e218973fa1e5cb6ebd10de6f4de1c3" translate="yes" xml:space="preserve">
          <source>In options where bytes or other quantities are specified, it is not possible to use the &lt;code&gt;redis.conf&lt;/code&gt; abbreviated form (&lt;code&gt;10k&lt;/code&gt;, &lt;code&gt;2gb&lt;/code&gt; ... and so forth), everything should be specified as a well-formed 64-bit integer, in the base unit of the configuration directive. However since Redis version 3.0 or greater, it is possible to use &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; with memory units for &lt;code&gt;maxmemory&lt;/code&gt;, client output buffers, and replication backlog size.</source>
          <target state="translated">En las opciones donde se especifican bytes u otras cantidades, no es posible usar la forma abreviada de &lt;code&gt;redis.conf&lt;/code&gt; ( &lt;code&gt;10k&lt;/code&gt; , &lt;code&gt;2gb&lt;/code&gt; ... y as&amp;iacute; sucesivamente), todo debe especificarse como un entero de 64 bits bien formado, en la unidad base de la directiva de configuraci&amp;oacute;n. Sin embargo, desde la versi&amp;oacute;n 3.0 o superior de Redis, es posible utilizar &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; con unidades de memoria para memoria &lt;code&gt;maxmemory&lt;/code&gt; , b&amp;uacute;feres de salida del cliente y tama&amp;ntilde;o del registro de replicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a7b5d3135e15286cfdbe38c07d4aa01f9fe0988a" translate="yes" xml:space="preserve">
          <source>In order to authenticate the current connection with one of the connections defined in the ACL list (see &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt;) and the official &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL guide&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74befe185bf5845d0b7429c8d4ecaac4587e1561" translate="yes" xml:space="preserve">
          <source>In order to avoid these problems while avoiding the bandwidth penalty, Redis implements the &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command.</source>
          <target state="translated">Para evitar estos problemas y evitar la penalizaci&amp;oacute;n del ancho de banda, Redis implementa el comando &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e60382da8db79c78bf47f321f4d7ec3aa869b88" translate="yes" xml:space="preserve">
          <source>In order to block, the &lt;strong&gt;BLOCK&lt;/strong&gt; option is used, together with the number of milliseconds we want to block before timing out. Normally Redis blocking commands take timeouts in seconds, however this command takes a millisecond timeout, even if normally the server will have a timeout resolution near to 0.1 seconds. This time it is possible to block for a shorter time in certain use cases, and if the server internals will improve over time, it is possible that the resolution of timeouts will improve.</source>
          <target state="translated">Para bloquear se usa la opci&amp;oacute;n &lt;strong&gt;BLOQUEAR&lt;/strong&gt; , junto con la cantidad de milisegundos que queremos bloquear antes de que se agote el tiempo. Normalmente, los comandos de bloqueo de Redis toman tiempos de espera en segundos, sin embargo, este comando toma un tiempo de espera de milisegundos, incluso si normalmente el servidor tendr&amp;aacute; una resoluci&amp;oacute;n de tiempo de espera cercana a 0.1 segundos. Esta vez es posible bloquear por un tiempo m&amp;aacute;s corto en ciertos casos de uso, y si los internos del servidor mejoran con el tiempo, es posible que mejore la resoluci&amp;oacute;n de tiempos de espera.</target>
        </trans-unit>
        <trans-unit id="0040f93cb8c4b8bdab630ff12697ba1b0160ca64" translate="yes" xml:space="preserve">
          <source>In order to enable script effects replication, you need to issue the following Lua command before any write operated by the script:</source>
          <target state="translated">Para permitir la réplica de los efectos del guión,es necesario emitir el siguiente comando Lua antes de cualquier escritura operada por el guión:</target>
        </trans-unit>
        <trans-unit id="013756f6d564f805aee9f75f0b5914a1c30d7b5d" translate="yes" xml:space="preserve">
          <source>In order to enable this form, the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option is used, and the normal &lt;em&gt;key&lt;/em&gt; argument is set to an empty string. The actual key names will be provided after the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; argument itself, like in the following example:</source>
          <target state="translated">Para habilitar este formulario, se usa la opci&amp;oacute;n &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; y el argumento de &lt;em&gt;clave&lt;/em&gt; normal se establece en una cadena vac&amp;iacute;a. Los nombres de las claves reales se proporcionar&amp;aacute;n despu&amp;eacute;s del argumento &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; en s&amp;iacute;, como en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="ae1f75fb4769a06b17ea6f198ef59cd43ba00d55" translate="yes" xml:space="preserve">
          <source>In order to enable tracking, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7cf3fffb86f4198755cdccfe390f7daca4376b" translate="yes" xml:space="preserve">
          <source>In order to enforce this behavior in scripts Redis does the following:</source>
          <target state="translated">Para hacer cumplir este comportamiento en los guiones,Redis hace lo siguiente:</target>
        </trans-unit>
        <trans-unit id="4210ec3e973c5d5ac271cc1ab7ffcffaa3f2c4da" translate="yes" xml:space="preserve">
          <source>In order to fix a broken cluster where certain slots are unassigned.</source>
          <target state="translated">Con el fin de arreglar un cúmulo roto donde ciertas ranuras no están asignadas.</target>
        </trans-unit>
        <trans-unit id="4708216948f38c6f376d2b00aef53c77bfc810bd" translate="yes" xml:space="preserve">
          <source>In order to iterate a stream, we can proceed as follows. Let's assume that we want two elements per iteration. We start fetching the first two elements, which is trivial:</source>
          <target state="translated">Para iterar una corriente,podemos proceder de la siguiente manera.Supongamos que queremos dos elementos por iteración.Empezamos a buscar los dos primeros elementos,lo cual es trivial:</target>
        </trans-unit>
        <trans-unit id="93f82278196654b93d4f14013ea15fe416b7d299" translate="yes" xml:space="preserve">
          <source>In order to make it a pure function, but still be sure that every invocation of the script will result in different random elements, we can simply add an additional argument to the script that will be used in order to seed the Lua pseudo-random number generator. The new script is as follows:</source>
          <target state="translated">Para que sea una función pura,pero aún así estar seguros de que cada invocación del guión resultará en diferentes elementos aleatorios,podemos simplemente añadir un argumento adicional al guión que se utilizará para sembrar el generador de números pseudoaleatorios Lua.El nuevo guión es el siguiente:</target>
        </trans-unit>
        <trans-unit id="5e754dbb6b6073549994be57928409b8a9518fbf" translate="yes" xml:space="preserve">
          <source>In order to make sure the redis.conf file is always consistent, that is, on errors or crashes you always end with the old file, or the new one, the rewrite is performed with a single &lt;code&gt;write(2)&lt;/code&gt; call that has enough content to be at least as big as the old file. Sometimes additional padding in the form of comments is added in order to make sure the resulting file is big enough, and later the file gets truncated to remove the padding at the end.</source>
          <target state="translated">Para asegurarse de que el archivo redis.conf sea siempre consistente, es decir, en caso de errores o fallas, siempre termina con el archivo antiguo o el nuevo, la reescritura se realiza con una sola llamada &lt;code&gt;write(2)&lt;/code&gt; que tiene suficiente contenido ser al menos tan grande como el archivo anterior. A veces, se agrega un relleno adicional en forma de comentarios para asegurarse de que el archivo resultante sea lo suficientemente grande, y luego el archivo se trunca para eliminar el relleno al final.</target>
        </trans-unit>
        <trans-unit id="45b71d9b591350682c94742bdef7ff99466f0e92" translate="yes" xml:space="preserve">
          <source>In order to make this locking algorithm more robust, a client holding a lock should always check the timeout didn't expire before unlocking the key with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; because client failures can be complex, not just crashing but also blocking a lot of time against some operations and trying to issue &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; after a lot of time (when the LOCK is already held by another client).</source>
          <target state="translated">Para hacer que este algoritmo de bloqueo sea m&amp;aacute;s robusto, un cliente que tiene un bloqueo siempre debe verificar que el tiempo de espera no haya expirado antes de desbloquear la clave con &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; porque las fallas del cliente pueden ser complejas, no solo fallar sino tambi&amp;eacute;n bloquear mucho tiempo en algunas operaciones e intentando emitir &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; despu&amp;eacute;s de mucho tiempo (cuando el LOCK ya est&amp;aacute; en manos de otro cliente).</target>
        </trans-unit>
        <trans-unit id="26d3078f4ebbdf0701299addb5fed6bbed540a2c" translate="yes" xml:space="preserve">
          <source>In order to obtain a correct behavior without sacrificing consistency, when a key expires, a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation is synthesized in both the AOF file and gains all the attached replicas nodes. This way the expiration process is centralized in the master instance, and there is no chance of consistency errors.</source>
          <target state="translated">Para obtener un comportamiento correcto sin sacrificar la coherencia, cuando una clave caduca, se sintetiza una operaci&amp;oacute;n &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; tanto en el archivo AOF y se obtienen todos los nodos de r&amp;eacute;plicas adjuntas. De esta manera, el proceso de caducidad se centraliza en la instancia maestra y no hay posibilidad de errores de coherencia.</target>
        </trans-unit>
        <trans-unit id="a4d1c1dcdd2afe763b414a4824111916d472be49" translate="yes" xml:space="preserve">
          <source>In order to switch to RESP3 a script should call this function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40403839cd4ec5549ce4c8b0b88fe76bd596deee" translate="yes" xml:space="preserve">
          <source>In other words there is a one-to-one conversion between Lua and Redis types. The following table shows you all the conversions rules:</source>
          <target state="translated">En otras palabras,hay una conversión de uno a uno entre los tipos Lua y Redis.La siguiente tabla muestra todas las reglas de conversión:</target>
        </trans-unit>
        <trans-unit id="b63d884600898ba55bb1960529b41996e05a6f02" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should be used to separate different keys belonging to the same application (if needed), and not to use a single Redis instance for multiple unrelated applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73283192b40f30e6bf23bca973e203da21ec7a06" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should mainly used in order to, if needed, separate different keys belonging to the same application, and not in order to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">En términos prácticos,las bases de datos de Redis deberían utilizarse principalmente para,de ser necesario,separar diferentes claves pertenecientes a la misma aplicación,y no para utilizar una sola instancia de Redis para múltiples aplicaciones no relacionadas entre sí.</target>
        </trans-unit>
        <trans-unit id="1cb1bb56f86e93948082da017865db052e971cd7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COUNT&lt;/code&gt; option documentation, we state that sometimes this family of commands may return all the elements of a Set, Hash or Sorted Set at once in a single call, regardless of the &lt;code&gt;COUNT&lt;/code&gt; option value. The reason why this happens is that the cursor-based iterator can be implemented, and is useful, only when the aggregate data type that we are scanning is represented as an hash table. However Redis uses a &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;memory optimization&lt;/a&gt; where small aggregate data types, until they reach a given amount of items or a given max size of single elements, are represented using a compact single-allocation packed encoding. When this is the case, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has no meaningful cursor to return, and must iterate the whole data structure at once, so the only sane behavior it has is to return everything in a call.</source>
          <target state="translated">En la documentaci&amp;oacute;n de la opci&amp;oacute;n &lt;code&gt;COUNT&lt;/code&gt; , indicamos que a veces esta familia de comandos puede devolver todos los elementos de un Set, Hash o Sorted Set a la vez en una sola llamada, independientemente del valor de la opci&amp;oacute;n &lt;code&gt;COUNT&lt;/code&gt; . La raz&amp;oacute;n por la que esto sucede es que el iterador basado en cursor se puede implementar, y es &amp;uacute;til, solo cuando el tipo de datos agregados que estamos escaneando se representa como una tabla hash. Sin embargo, Redis utiliza una &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;optimizaci&amp;oacute;n de memoria&lt;/a&gt; en la que los tipos de datos agregados peque&amp;ntilde;os, hasta que alcanzan una cantidad determinada de elementos o un tama&amp;ntilde;o m&amp;aacute;ximo determinado de elementos individuales, se representan mediante una codificaci&amp;oacute;n compacta empaquetada de asignaci&amp;oacute;n &amp;uacute;nica. Cuando este es el caso, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; no tiene un cursor significativo para devolver y debe iterar toda la estructura de datos a la vez, por lo que el &amp;uacute;nico comportamiento sensato que tiene es devolver todo en una llamada.</target>
        </trans-unit>
        <trans-unit id="8c0e05b70b67e4b92ac3373b78b09162115732be" translate="yes" xml:space="preserve">
          <source>In the above case the entry &lt;code&gt;1526985054069-0&lt;/code&gt; exists, otherwise the server would have sent us the next one. Using &lt;code&gt;COUNT&lt;/code&gt; is also the base in order to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; as an iterator.</source>
          <target state="translated">En el caso anterior existe la entrada &lt;code&gt;1526985054069-0&lt;/code&gt; , de lo contrario el servidor nos hubiera enviado la siguiente. Usar &lt;code&gt;COUNT&lt;/code&gt; es tambi&amp;eacute;n la base para usar &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; como iterador.</target>
        </trans-unit>
        <trans-unit id="f40be215733bf9374d8b827188eeddff85363cc0" translate="yes" xml:space="preserve">
          <source>In the above example of counting days, even after 10 years the application is online we still have just &lt;code&gt;365*10&lt;/code&gt; bits of data per user, that is just 456 bytes per user. With this amount of data &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; is still as fast as any other O(1) Redis command like &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; or &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;.</source>
          <target state="translated">En el ejemplo anterior de contar d&amp;iacute;as, incluso despu&amp;eacute;s de 10 a&amp;ntilde;os la aplicaci&amp;oacute;n est&amp;aacute; en l&amp;iacute;nea, todav&amp;iacute;a tenemos solo &lt;code&gt;365*10&lt;/code&gt; bits de datos por usuario, es decir, solo 456 bytes por usuario. Con esta cantidad de datos, &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; sigue siendo tan r&amp;aacute;pido como cualquier otro comando de O (1) Redis como &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; o &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76a0365bc0972ed4321b2f354ddf621810b8b004" translate="yes" xml:space="preserve">
          <source>In the above example we claim the message with ID &lt;code&gt;1526569498055-0&lt;/code&gt;, only if the message is idle for at least one hour without the original consumer or some other consumer making progresses (acknowledging or claiming it), and assigns the ownership to the consumer &lt;code&gt;Alice&lt;/code&gt;.</source>
          <target state="translated">En el ejemplo anterior, reclamamos el mensaje con ID &lt;code&gt;1526569498055-0&lt;/code&gt; , solo si el mensaje est&amp;aacute; inactivo durante al menos una hora sin que el consumidor original o alg&amp;uacute;n otro consumidor progrese (reconociendo o reclamando), y asigna la propiedad al consumidor &lt;code&gt;Alice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bef89cf285951fc9b88c842b027336864d10794" translate="yes" xml:space="preserve">
          <source>In the above example you can see that the reported information are the number of elements of the stream, details about the radix tree representing the stream mostly useful for optimization and debugging tasks, the number of consumer groups associated with the stream, the last generated ID that may not be the same as the last entry ID in case some entry was deleted. Finally the full first and last entry in the stream are shown, in order to give some sense about what is the stream content.</source>
          <target state="translated">En el ejemplo anterior se puede ver que la información comunicada es el número de elementos de la corriente,detalles sobre el árbol de radix que representa la corriente más útil para las tareas de optimización y depuración,el número de grupos de consumidores asociados con la corriente,la última identificación generada que puede no ser la misma que la última identificación de entrada en caso de que se haya eliminado alguna entrada.Finalmente,se muestran la primera y la última entrada completa del flujo,para dar una idea del contenido del flujo.</target>
        </trans-unit>
        <trans-unit id="5e1f5dbd04f5dc1db0a038c0d0e6f0ff4a4acd34" translate="yes" xml:space="preserve">
          <source>In the above locking algorithm there is a problem: what happens if a client fails, crashes, or is otherwise not able to release the lock? It's possible to detect this condition because the lock key contains a UNIX timestamp. If such a timestamp is equal to the current Unix time the lock is no longer valid.</source>
          <target state="translated">En el algoritmo de bloqueo anterior hay un problema:¿qué sucede si un cliente falla,se cae o no es capaz de liberar el bloqueo? Es posible detectar esta condición porque la llave del candado contiene una marca de tiempo UNIX.Si dicha marca de tiempo es igual a la hora actual de Unix,el bloqueo ya no es válido.</target>
        </trans-unit>
        <trans-unit id="7063c49f04f76f5d83a38b2826e82b8706b19e78" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;, keys are every other position so the step value is 2. Compare with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; above where the step value is just 1.</source>
          <target state="translated">En el caso de &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; , las teclas est&amp;aacute;n en cualquier otra posici&amp;oacute;n, por lo que el valor del paso es 2. Compare con &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; anterior, donde el valor del paso es solo 1.</target>
        </trans-unit>
        <trans-unit id="51cf6b9278dbdee20c8485961f1e557cd7119742" translate="yes" xml:space="preserve">
          <source>In the context of a node that has received a &lt;code&gt;DELSLOTS&lt;/code&gt; command and has consequently removed the associations for the passed hash slots, we say those hash slots are &lt;em&gt;unbound&lt;/em&gt;. Note that the existence of unbound hash slots occurs naturally when a node has not been configured to handle them (something that can be done with the &lt;code&gt;ADDSLOTS&lt;/code&gt; command) and if it has not received any information about who owns those hash slots (something that it can learn from heartbeat or update messages).</source>
          <target state="translated">En el contexto de un nodo que ha recibido un comando &lt;code&gt;DELSLOTS&lt;/code&gt; y, en consecuencia, ha eliminado las asociaciones para las ranuras hash pasadas, decimos que esas ranuras hash &lt;em&gt;no&lt;/em&gt; est&amp;aacute;n &lt;em&gt;vinculadas&lt;/em&gt; . Tenga en cuenta que la existencia de ranuras hash independientes se produce de forma natural cuando un nodo no ha sido configurado para manejarlas (algo que se puede hacer con el comando &lt;code&gt;ADDSLOTS&lt;/code&gt; ) y si no ha recibido ninguna informaci&amp;oacute;n sobre qui&amp;eacute;n es el propietario de esas ranuras hash (algo que puede aprender de los latidos del coraz&amp;oacute;n o actualizar mensajes).</target>
        </trans-unit>
        <trans-unit id="0c3893e92cc9396f13c9f99b5e7ad611d2ac46c2" translate="yes" xml:space="preserve">
          <source>In the context of a stream consumer group, this command changes the ownership of a pending message, so that the new owner is the consumer specified as the command argument. Normally this is what happens:</source>
          <target state="translated">En el contexto de un grupo de consumidores de corriente,este comando cambia la propiedad de un mensaje pendiente,de modo que el nuevo propietario es el consumidor especificado como argumento del comando.Normalmente esto es lo que sucede:</target>
        </trans-unit>
        <trans-unit id="57bf1b4701a5c94880ee6e46bfe56ac8c7000db8" translate="yes" xml:space="preserve">
          <source>In the example above, the first call uses zero as a cursor, to start the iteration. The second call uses the cursor returned by the previous call as the first element of the reply, that is, 17.</source>
          <target state="translated">En el ejemplo anterior,la primera llamada utiliza el cero como cursor,para iniciar la iteración.La segunda llamada utiliza el cursor devuelto por la llamada anterior como primer elemento de la respuesta,es decir,17.</target>
        </trans-unit>
        <trans-unit id="64f37e2cb3f5829eb3ba5c3a4f7f3eea2d872acc" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there are detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">En la forma ampliada ya no vemos la información resumida,sino que hay información detallada para cada mensaje en la lista de entradas pendientes.Para cada mensaje se devuelven cuatro atributos:</target>
        </trans-unit>
        <trans-unit id="611f148b8dfb6f6978d2aeb35216b9ff55929cae" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there is detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec3c889a89e0a9bff423ca26bc6e8f597b12b82" translate="yes" xml:space="preserve">
          <source>In the following example the first call to &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not use a timeout and asks for the write to reach 1 replica. It returns with success. In the second attempt instead we put a timeout, and ask for the replication of the write to two replicas. Since there is a single replica available, after one second &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; unblocks and returns 1, the number of replicas reached.</source>
          <target state="translated">En el siguiente ejemplo, la primera llamada a &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; no usa un tiempo de espera y solicita que la escritura alcance 1 r&amp;eacute;plica. Vuelve con &amp;eacute;xito. En el segundo intento, en cambio, ponemos un tiempo de espera y solicitamos la replicaci&amp;oacute;n de la escritura en dos r&amp;eacute;plicas. Dado que hay una &amp;uacute;nica r&amp;eacute;plica disponible, despu&amp;eacute;s de un segundo, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; desbloquea y devuelve 1, el n&amp;uacute;mero de r&amp;eacute;plicas alcanzado.</target>
        </trans-unit>
        <trans-unit id="8e23d6a61281506fa3e98f414bcf348728e15107" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays containing nils and keys are handled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275502ca7bb30b2b024cd13d4001c3a1615096d6" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays with nils are handled:</source>
          <target state="translated">En el siguiente ejemplo podemos ver cómo se manejan los flotadores y las matrices con nulos:</target>
        </trans-unit>
        <trans-unit id="67aa25f5afe2285456ce925944008c892a8bde6a" translate="yes" xml:space="preserve">
          <source>In the following example we'll show why the command must not just remove a given node from the nodes table, but also prevent it for being re-inserted again for some time.</source>
          <target state="translated">En el siguiente ejemplo mostraremos por qué el comando no sólo debe eliminar un nodo dado de la tabla de nodos,sino también evitar que se vuelva a insertar durante algún tiempo.</target>
        </trans-unit>
        <trans-unit id="1b27ba03d8db2c5155774200622adb0e3f3e2724" translate="yes" xml:space="preserve">
          <source>In the following example you can see how the encoding changes once Redis is no longer able to use the space saving encoding.</source>
          <target state="translated">En el siguiente ejemplo se puede ver cómo cambia la codificación una vez que Redis ya no puede utilizar la codificación de ahorro de espacio.</target>
        </trans-unit>
        <trans-unit id="d52481dfbaf58234ade345bdada825c509d89e9a" translate="yes" xml:space="preserve">
          <source>In the specific case of the implementation of &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;, Redis remembers, for each client, the replication offset of the produced replication stream when a given write command was executed in the context of a given client. When &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; is called Redis checks if the specified number of replicas already acknowledged this offset or a greater one.</source>
          <target state="translated">En el caso espec&amp;iacute;fico de la implementaci&amp;oacute;n de &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; , Redis recuerda, para cada cliente, el desplazamiento de replicaci&amp;oacute;n del flujo de replicaci&amp;oacute;n producido cuando se ejecut&amp;oacute; un comando de escritura dado en el contexto de un cliente dado. Cuando se llama a &lt;a href=&quot;wait&quot;&gt;WAIT,&lt;/a&gt; Redis comprueba si el n&amp;uacute;mero especificado de r&amp;eacute;plicas ya reconoci&amp;oacute; este desplazamiento o uno mayor.</target>
        </trans-unit>
        <trans-unit id="903ead95cd2a4a5b9cbb852a8e750aedc79fee51" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; will auto-complete the start interval with &lt;code&gt;-0&lt;/code&gt; and end interval with &lt;code&gt;-18446744073709551615&lt;/code&gt;, in order to return all the entries that were generated between a given millisecond and the end of the other specified millisecond. This also means that repeating the same millisecond two times, we get all the entries within such millisecond, because the sequence number range will be from zero to the maximum.</source>
          <target state="translated">En este caso, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; completar&amp;aacute; autom&amp;aacute;ticamente el intervalo de inicio con &lt;code&gt;-0&lt;/code&gt; y el intervalo de finalizaci&amp;oacute;n con &lt;code&gt;-18446744073709551615&lt;/code&gt; , para devolver todas las entradas que se generaron entre un milisegundo dado y el final del otro milisegundo especificado. Esto tambi&amp;eacute;n significa que repitiendo el mismo milisegundo dos veces, obtenemos todas las entradas dentro de ese milisegundo, porque el rango del n&amp;uacute;mero de secuencia ser&amp;aacute; de cero al m&amp;aacute;ximo.</target>
        </trans-unit>
        <trans-unit id="9a9dd8640d5d9c354f3497144f8f471bfe5130bf" translate="yes" xml:space="preserve">
          <source>In this form the command returns general information about the stream stored at the specified key.</source>
          <target state="translated">De esta forma el comando devuelve información general sobre el flujo almacenado en la tecla especificada.</target>
        </trans-unit>
        <trans-unit id="fb6df0247f8ef1848f5f3284e1802dec98219082" translate="yes" xml:space="preserve">
          <source>In this form the command returns the entire state of the stream, including entries, groups, consumers and PELs. This form is available since Redis 6.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9dc316159e0ab75070b1301d7b7adb86e569cda" translate="yes" xml:space="preserve">
          <source>In this form we just get as output all the consumer groups associated with the stream:</source>
          <target state="translated">En esta forma sólo obtenemos como salida todos los grupos de consumidores asociados con la corriente:</target>
        </trans-unit>
        <trans-unit id="ddaa9f098110e2f5ed979aa965f072762268f6b4" translate="yes" xml:space="preserve">
          <source>In this form, the command outputs the total number of pending messages for this consumer group, which is one, followed by the smallest and greatest ID among the pending messages, and then list every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</source>
          <target state="translated">En esta forma,el comando da salida al número total de mensajes pendientes para este grupo de consumidores,que es uno,seguido de la identificación más pequeña y más grande entre los mensajes pendientes,y luego enumera a cada consumidor del grupo de consumidores con al menos un mensaje pendiente,y el número de mensajes pendientes que tiene.</target>
        </trans-unit>
        <trans-unit id="7449f50cc271410bffecdb508cde8a6a6c5d9a68" translate="yes" xml:space="preserve">
          <source>In this particular case, running a single &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; client can reduce the throughput by more than 50%. Running more &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; clients will reduce throughput even more.</source>
          <target state="translated">En este caso particular, ejecutar un solo cliente &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; puede reducir el rendimiento en m&amp;aacute;s del 50%. Ejecutar m&amp;aacute;s clientes &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; reducir&amp;aacute; a&amp;uacute;n m&amp;aacute;s el rendimiento.</target>
        </trans-unit>
        <trans-unit id="9499b337b96eb666a58f2a5ab4a4329e2007a622" translate="yes" xml:space="preserve">
          <source>In this replication mode, while Lua scripts are executed, Redis collects all the commands executed by the Lua scripting engine that actually modify the dataset. When the script execution finishes, the sequence of commands that the script generated are wrapped into a MULTI / EXEC transaction and are sent to replicas and AOF.</source>
          <target state="translated">En este modo de replicación,mientras se ejecutan las secuencias de comandos de Lua,Redis recoge todos los comandos ejecutados por el motor de secuencias de comandos de Lua que realmente modifican el conjunto de datos.Cuando la ejecución del script termina,la secuencia de comandos que el script generó se envuelven en una transacción MULTI/EXEC y se envían a las réplicas y al AOF.</target>
        </trans-unit>
        <trans-unit id="9c59d992fdad2d2103f7862e5997a95c45fa8f53" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing an ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef44dcb3d65131c01d1f4f06af638521f8511b76" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing and ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">De esta manera, el c&amp;oacute;digo de consumidor de ejemplo solo obtendr&amp;aacute; mensajes nuevos, los procesar&amp;aacute; y reconocer&amp;aacute; a trav&amp;eacute;s de &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; . Sin embargo, el c&amp;oacute;digo de ejemplo anterior no est&amp;aacute; completo, porque no maneja la recuperaci&amp;oacute;n despu&amp;eacute;s de un bloqueo. Lo que suceder&amp;aacute; si fallamos en medio del procesamiento de mensajes, es que nuestros mensajes permanecer&amp;aacute;n en la lista de entradas pendientes, por lo que podemos acceder a nuestro historial dando a &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; inicialmente un ID de 0 y realizando el mismo ciclo. Una vez que proporcionamos un ID de 0, la respuesta es un conjunto vac&amp;iacute;o de mensajes, sabemos que procesamos y reconocemos todos los mensajes pendientes: podemos comenzar a usar &lt;code&gt;&amp;gt;&lt;/code&gt; como ID, para obtener los nuevos mensajes y reincorporarnos a los consumidores que est&amp;aacute;n procesando cosas nuevas.</target>
        </trans-unit>
        <trans-unit id="0c6aff080ab580caca11c078c7c0fd0c074cc4b5" translate="yes" xml:space="preserve">
          <source>In this way when a node in migrating state generates an &lt;code&gt;ASK&lt;/code&gt; redirection, the client contacts the target node, sends &lt;code&gt;ASKING&lt;/code&gt;, and immediately after sends the command. This way commands about non-existing keys in the old node or keys already migrated to the target node are executed in the target node, so that:</source>
          <target state="translated">De esta manera, cuando un nodo en estado de migraci&amp;oacute;n genera una redirecci&amp;oacute;n &lt;code&gt;ASK&lt;/code&gt; , el cliente contacta con el nodo objetivo, env&amp;iacute;a &lt;code&gt;ASKING&lt;/code&gt; e inmediatamente despu&amp;eacute;s env&amp;iacute;a el comando. De esta forma, los comandos sobre claves no existentes en el nodo antiguo o claves ya migradas al nodo de destino se ejecutan en el nodo de destino, de modo que:</target>
        </trans-unit>
        <trans-unit id="8a4976fd385ad81414ef5f0b5eb1d542ebee200c" translate="yes" xml:space="preserve">
          <source>Incomplete IDs</source>
          <target state="translated">Identificaciones incompletas</target>
        </trans-unit>
        <trans-unit id="d076531fdc3e2f8747b11778603627c7ff4c3c03" translate="yes" xml:space="preserve">
          <source>Increment the specified &lt;code&gt;field&lt;/code&gt; of a hash stored at &lt;code&gt;key&lt;/code&gt;, and representing a floating point number, by the specified &lt;code&gt;increment&lt;/code&gt;. If the increment value is negative, the result is to have the hash field value &lt;strong&gt;decremented&lt;/strong&gt; instead of incremented. If the field does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">Incrementar el &lt;code&gt;field&lt;/code&gt; especificado de un hash almacenado en la &lt;code&gt;key&lt;/code&gt; , y que representa un n&amp;uacute;mero de punto flotante, por el &lt;code&gt;increment&lt;/code&gt; o especificado . Si el valor de incremento es negativo, el resultado es que el valor del campo hash &lt;strong&gt;disminuya en&lt;/strong&gt; lugar de incrementarse. Si el campo no existe, se establece en &lt;code&gt;0&lt;/code&gt; antes de realizar la operaci&amp;oacute;n. Se devuelve un error si ocurre una de las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="0b2569a3073ebcb62549ecb7ec5a99e5e6f20a57" translate="yes" xml:space="preserve">
          <source>Increment the string representing a floating point number stored at &lt;code&gt;key&lt;/code&gt; by the specified &lt;code&gt;increment&lt;/code&gt;. By using a negative &lt;code&gt;increment&lt;/code&gt; value, the result is that the value stored at the key is decremented (by the obvious properties of addition). If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">Incrementar la cadena que representa un n&amp;uacute;mero de punto flotante almacenado en la &lt;code&gt;key&lt;/code&gt; por el &lt;code&gt;increment&lt;/code&gt; o especificado . Al usar un valor de &lt;code&gt;increment&lt;/code&gt; o negativo , el resultado es que el valor almacenado en la tecla se reduce (por las propiedades obvias de la suma). Si la clave no existe, se establece en &lt;code&gt;0&lt;/code&gt; antes de realizar la operaci&amp;oacute;n. Se devuelve un error si ocurre una de las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="b0ab00f78f69567a82e2e724fbf2c011708c66b2" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; does not exist the value is set to &lt;code&gt;0&lt;/code&gt; before the operation is performed.</source>
          <target state="translated">Incrementa el n&amp;uacute;mero almacenado en el &lt;code&gt;field&lt;/code&gt; en el hash almacenado en la &lt;code&gt;key&lt;/code&gt; por &lt;code&gt;increment&lt;/code&gt; o . Si la &lt;code&gt;key&lt;/code&gt; no existe, se crea una nueva clave que contiene un hash. Si el &lt;code&gt;field&lt;/code&gt; no existe, el valor se establece en &lt;code&gt;0&lt;/code&gt; antes de que se realice la operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="05fa8f17b5cc5360627e65f0e1bfbcb74f909616" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">Incrementa el n&amp;uacute;mero almacenado en la &lt;code&gt;key&lt;/code&gt; por &lt;code&gt;increment&lt;/code&gt; o . Si la clave no existe, se establece en &lt;code&gt;0&lt;/code&gt; antes de realizar la operaci&amp;oacute;n. Se devuelve un error si la clave contiene un valor del tipo incorrecto o contiene una cadena que no se puede representar como un n&amp;uacute;mero entero. Esta operaci&amp;oacute;n est&amp;aacute; limitada a enteros de 64 bits con signo.</target>
        </trans-unit>
        <trans-unit id="f9bd9898aaa3a2048914100ede9b89ccf7adc73a" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">Incrementa en uno el n&amp;uacute;mero almacenado en la &lt;code&gt;key&lt;/code&gt; . Si la clave no existe, se establece en &lt;code&gt;0&lt;/code&gt; antes de realizar la operaci&amp;oacute;n. Se devuelve un error si la clave contiene un valor del tipo incorrecto o contiene una cadena que no se puede representar como un n&amp;uacute;mero entero. Esta operaci&amp;oacute;n est&amp;aacute; limitada a enteros de 64 bits con signo.</target>
        </trans-unit>
        <trans-unit id="b3b4497f3f9f641c1f07a98ba2294810e7c1c3a5" translate="yes" xml:space="preserve">
          <source>Increments the score of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, it is added with &lt;code&gt;increment&lt;/code&gt; as its score (as if its previous score was &lt;code&gt;0.0&lt;/code&gt;). If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified &lt;code&gt;member&lt;/code&gt; as its sole member is created.</source>
          <target state="translated">Incrementa la puntuaci&amp;oacute;n del &lt;code&gt;member&lt;/code&gt; en el conjunto ordenado almacenado en &lt;code&gt;key&lt;/code&gt; por &lt;code&gt;increment&lt;/code&gt; o . Si el &lt;code&gt;member&lt;/code&gt; no existe en el conjunto ordenado, se agrega con un &lt;code&gt;increment&lt;/code&gt; o como su puntaje (como si su puntaje anterior fuera &lt;code&gt;0.0&lt;/code&gt; ). Si la &lt;code&gt;key&lt;/code&gt; no existe, se crea un nuevo conjunto ordenado con el &lt;code&gt;member&lt;/code&gt; especificado como &amp;uacute;nico miembro.</target>
        </trans-unit>
        <trans-unit id="b9e98de9b6972c3697024196bb1cf498f5df1583" translate="yes" xml:space="preserve">
          <source>Information about slots propagation and warnings</source>
          <target state="translated">Información sobre la propagación de las franjas horarias y las advertencias</target>
        </trans-unit>
        <trans-unit id="2adcb9298d658f855997a0893baf52120d4879fe" translate="yes" xml:space="preserve">
          <source>Initiates a replication stream from the master.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df92aa3b0e06eb79bf7c8f7098db769523ac9333" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operations. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">Inserte todos los valores especificados al principio de la lista almacenada en &lt;code&gt;key&lt;/code&gt; . Si la &lt;code&gt;key&lt;/code&gt; no existe, se crea como una lista vac&amp;iacute;a antes de realizar las operaciones de inserci&amp;oacute;n. Cuando la &lt;code&gt;key&lt;/code&gt; contiene un valor que no es una lista, se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="d56f1eeeec0b6889ab12fc76a629d9cf4f377993" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operation. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">Inserte todos los valores especificados al final de la lista almacenada en &lt;code&gt;key&lt;/code&gt; . Si la &lt;code&gt;key&lt;/code&gt; no existe, se crea como una lista vac&amp;iacute;a antes de realizar la operaci&amp;oacute;n de inserci&amp;oacute;n. Cuando la &lt;code&gt;key&lt;/code&gt; contiene un valor que no es una lista, se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="76405c7e5205b84962c7bcad1e955500c9c01bf2" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;element&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41914bb38b36cf790ad6dea5c850ff4f739bdf2f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">Inserta un &lt;code&gt;value&lt;/code&gt; al principio de la lista almacenada en la &lt;code&gt;key&lt;/code&gt; , solo si la &lt;code&gt;key&lt;/code&gt; ya existe y contiene una lista. A diferencia de &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; , no se realizar&amp;aacute; ninguna operaci&amp;oacute;n cuando la &lt;code&gt;key&lt;/code&gt; a&amp;uacute;n no exista.</target>
        </trans-unit>
        <trans-unit id="483c4cdd37e1303cef072b494af9c173f5ba1e3a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">Inserta un &lt;code&gt;value&lt;/code&gt; al final de la lista almacenada en la &lt;code&gt;key&lt;/code&gt; , solo si la &lt;code&gt;key&lt;/code&gt; ya existe y contiene una lista. A diferencia de &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; , no se realizar&amp;aacute; ninguna operaci&amp;oacute;n cuando la &lt;code&gt;key&lt;/code&gt; a&amp;uacute;n no exista.</target>
        </trans-unit>
        <trans-unit id="d817081530a979658954b262ec5b27debd913f6b" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">Inserta un &lt;code&gt;value&lt;/code&gt; en la lista almacenada en la &lt;code&gt;key&lt;/code&gt; antes o despu&amp;eacute;s del &lt;code&gt;pivot&lt;/code&gt; e del valor de referencia .</target>
        </trans-unit>
        <trans-unit id="5796a562198c08a1669595d2cc6b1a7851ecca7f" translate="yes" xml:space="preserve">
          <source>Inserts specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea8b02564feb5003f96c3e70699d8d56ef9971fc" translate="yes" xml:space="preserve">
          <source>Inserts specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2cd21b122572712ccbe21dcfb324c039d60a6f" translate="yes" xml:space="preserve">
          <source>Instead Redis 2.4 works in a different way: clients are served &lt;em&gt;in the context&lt;/em&gt; of the push operation, so as long as &lt;code&gt;LPUSH foo a b c&lt;/code&gt; starts pushing the first element to the list, it will be delivered to the Client &lt;strong&gt;A&lt;/strong&gt;, that will receive &lt;code&gt;a&lt;/code&gt; (the first element pushed).</source>
          <target state="translated">En cambio, Redis 2.4 funciona de una manera diferente: los clientes se atienden &lt;em&gt;en el contexto&lt;/em&gt; de la operaci&amp;oacute;n push, por lo que siempre que &lt;code&gt;LPUSH foo a b c&lt;/code&gt; comience a empujar el primer elemento a la lista, se entregar&amp;aacute; al Cliente &lt;strong&gt;A&lt;/strong&gt; , que recibir&amp;aacute; &lt;code&gt;a&lt;/code&gt; ( el primer elemento empujado).</target>
        </trans-unit>
        <trans-unit id="895d5878b1e7aebe2b652bf4030490cc648a385d" translate="yes" xml:space="preserve">
          <source>Instead of releasing the lock with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, send a script that only removes the key if the value matches.</source>
          <target state="translated">En lugar de liberar el bloqueo con &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; , env&amp;iacute;e un script que solo elimine la clave si el valor coincide.</target>
        </trans-unit>
        <trans-unit id="e1fb6600644f1089e2f02671b1d169470ef167d3" translate="yes" xml:space="preserve">
          <source>Instead of setting a fixed string, set a non-guessable large random string, called token.</source>
          <target state="translated">En lugar de fijar una cadena fija,fija una gran cadena aleatoria no adivinable,llamada token.</target>
        </trans-unit>
        <trans-unit id="7e8138295a5156481cc0eb58921ff5f1b45d907b" translate="yes" xml:space="preserve">
          <source>Instead, if the lock is expired because the Unix time at &lt;code&gt;lock.foo&lt;/code&gt; is older than the current Unix time, C4 tries to perform:</source>
          <target state="translated">En cambio, si el bloqueo expira porque la hora de Unix en &lt;code&gt;lock.foo&lt;/code&gt; es m&amp;aacute;s antigua que la hora de Unix actual, C4 intenta realizar:</target>
        </trans-unit>
        <trans-unit id="9e41d77e11789212e3a04485592bea0019722472" translate="yes" xml:space="preserve">
          <source>Instruct Redis to start an &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; rewrite process. The rewrite will create a small optimized version of the current Append Only File.</source>
          <target state="translated">Indique a Redis que inicie un proceso de reescritura de &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;solo archivo&lt;/a&gt; adjunto. La reescritura crear&amp;aacute; una peque&amp;ntilde;a versi&amp;oacute;n optimizada del archivo de solo anexar actual.</target>
        </trans-unit>
        <trans-unit id="5d3a484e0575c563f1fd55a805b93fd40c42e60d" translate="yes" xml:space="preserve">
          <source>Integer reply</source>
          <target state="translated">Respuesta entera</target>
        </trans-unit>
        <trans-unit id="b78aed63c34c1be3f06c6bc59978ffe5ffe055ac" translate="yes" xml:space="preserve">
          <source>Introduction to EVAL</source>
          <target state="translated">Introducción a EVAL</target>
        </trans-unit>
        <trans-unit id="698c191721344bee0279a531fba2023586cfe9e4" translate="yes" xml:space="preserve">
          <source>It can also take the following values:</source>
          <target state="translated">También puede tomar los siguientes valores:</target>
        </trans-unit>
        <trans-unit id="35178e7f69534d7802151005b608f5f33b33d650" translate="yes" xml:space="preserve">
          <source>It contains a 64-bit checksum that is used to make sure errors will be detected. The &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command makes sure to check the checksum before synthesizing a key using the serialized value.</source>
          <target state="translated">Contiene una suma de comprobaci&amp;oacute;n de 64 bits que se utiliza para asegurarse de que se detecten errores. El comando &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; se asegura de verificar la suma de verificaci&amp;oacute;n antes de sintetizar una clave usando el valor serializado.</target>
        </trans-unit>
        <trans-unit id="d3cca1eb042dc5b5456d254387aa0bc9411f0e98" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to understand that you should use the &lt;code&gt;$&lt;/code&gt; ID only for the first call to &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;. Later the ID should be the one of the last reported item in the stream, otherwise you could miss all the entries that are added in between.</source>
          <target state="translated">Es &lt;strong&gt;muy importante&lt;/strong&gt; comprender que debe usar &lt;code&gt;$&lt;/code&gt; ID solo para la primera llamada a &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; . Posteriormente, el ID deber&amp;iacute;a ser el del &amp;uacute;ltimo elemento informado en la secuencia; de lo contrario, podr&amp;iacute;a perder todas las entradas que se agregan en el medio.</target>
        </trans-unit>
        <trans-unit id="80e58a0abe147b5052a4b292609ed6e990761a9f" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;GET&lt;/code&gt; the element itself using the special pattern &lt;code&gt;#&lt;/code&gt;:</source>
          <target state="translated">Tambi&amp;eacute;n es posible &lt;code&gt;GET&lt;/code&gt; el elemento en s&amp;iacute; usando el patr&amp;oacute;n especial &lt;code&gt;#&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="98ad7fac6612120c355f6682c4b1a531c848bd30" translate="yes" xml:space="preserve">
          <source>It is also possible to compute the LCS between the content of two keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33a1c4c42a6d6feaa0bef4f81f6ace9278b22e9" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; and &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; string commands to efficiently access a range of bit offsets in a bitmap. Below is a sample implementation in idiomatic Redis Lua scripting that can be run with the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344f6904cadbf67817bc580b98a14096a5ecb81b" translate="yes" xml:space="preserve">
          <source>It is important to note that step 3 is the only time when a Redis Cluster node will create a new config epoch without agreement from other nodes. This only happens when a manual configuration is operated. However it is impossible that this creates a non-transient setup where two nodes have the same config epoch, since Redis Cluster uses a config epoch collision resolution algorithm.</source>
          <target state="translated">Es importante señalar que el paso 3 es la única vez que un nodo Redis Cluster creará una nueva época de configuración sin el acuerdo de los otros nodos.Esto sólo ocurre cuando se opera una configuración manual.Sin embargo,es imposible que esto cree una configuración no transitoria donde dos nodos tengan la misma config epoch,ya que Redis Cluster usa un algoritmo de resolución de colisiones config epoch.</target>
        </trans-unit>
        <trans-unit id="75e2007346bb90c5a30dbb62b43b72fa8d6f2346" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;MATCH&lt;/strong&gt; filter is applied after elements are retrieved from the collection, just before returning data to the client. This means that if the pattern matches very little elements inside the collection, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; will likely return no elements in most iterations. An example is shown below:</source>
          <target state="translated">Es importante tener en cuenta que el filtro &lt;strong&gt;COINCIDIR&lt;/strong&gt; se aplica despu&amp;eacute;s de que se recuperan los elementos de la colecci&amp;oacute;n, justo antes de devolver los datos al cliente. Esto significa que si el patr&amp;oacute;n coincide con muy pocos elementos dentro de la colecci&amp;oacute;n, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; probablemente no devolver&amp;aacute; ning&amp;uacute;n elemento en la mayor&amp;iacute;a de las iteraciones. A continuaci&amp;oacute;n se muestra un ejemplo:</target>
        </trans-unit>
        <trans-unit id="05004148ae7826284b52ac4960264eb06c78f9cd" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;TYPE&lt;/strong&gt; filter is also applied after elements are retrieved from the database, so the option does not reduce the amount of work the server has to do to complete a full iteration, and for rare types you may receive no elements in many iterations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a489978b872ba9db6fad974b8d4112fa3f8ddea" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bd66f1e8688cc2dae7b39af1276712b3930256" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command is &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">Es importante entender que este comando se &lt;em&gt;distribuye&lt;/em&gt; a todos los clientes que esperan el mismo rango de ID, por lo que cada consumidor obtendr&amp;aacute; una copia de los datos, a diferencia de lo que sucede cuando se utilizan operaciones de bloqueo de listas emergentes.</target>
        </trans-unit>
        <trans-unit id="c855a69b0dba328dc98ac3bd3b714e220d6e64d4" translate="yes" xml:space="preserve">
          <source>It is never repeated, so if &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; returns the same number, the caller can be sure that the underlying client did not disconnect and reconnect the connection, but it is still the same connection.</source>
          <target state="translated">Nunca se repite, por lo que si &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; devuelve el mismo n&amp;uacute;mero, la persona que llama puede estar segura de que el cliente subyacente no se desconect&amp;oacute; y reconect&amp;oacute; la conexi&amp;oacute;n, pero sigue siendo la misma conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="18c6232a5064b912687168695e794e952ea903ef" translate="yes" xml:space="preserve">
          <source>It is not possible for the key to get lost in the event of a timeout, but the client calling &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;, in the event of a timeout error, should check if the key is &lt;em&gt;also&lt;/em&gt; present in the target instance and act accordingly.</source>
          <target state="translated">No es posible que la clave se pierda en caso de un tiempo de espera, pero el cliente que llama a &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; , en caso de un error de tiempo de espera, debe comprobar si la clave &lt;em&gt;tambi&amp;eacute;n&lt;/em&gt; est&amp;aacute; presente en la instancia de destino y actuar en consecuencia.</target>
        </trans-unit>
        <trans-unit id="7a383107db035b97cc0f3e4c5c6844b9b02c255f" translate="yes" xml:space="preserve">
          <source>It is possible for an infinite number of clients to iterate the same collection at the same time, as the full state of the iterator is in the cursor, that is obtained and returned to the client at every call. Server side no state is taken at all.</source>
          <target state="translated">Es posible que un número infinito de clientes iteren la misma colección al mismo tiempo,ya que el estado completo del iterador está en el cursor,que se obtiene y se devuelve al cliente en cada llamada.Del lado del servidor no se toma ningún estado.</target>
        </trans-unit>
        <trans-unit id="a485e395caaea14094a0b8ec68e5e3e0a8915e73" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; using as argument a key that already has an existing expire set. In this case the time to live of a key is &lt;em&gt;updated&lt;/em&gt; to the new value. There are many useful applications for this, an example is documented in the &lt;em&gt;Navigation session&lt;/em&gt; pattern section below.</source>
          <target state="translated">Es posible llamar a &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; usando como argumento una clave que ya tiene un conjunto de expiraci&amp;oacute;n existente. En este caso, el tiempo de vida de una clave se &lt;em&gt;actualiza&lt;/em&gt; al nuevo valor. Hay muchas aplicaciones &amp;uacute;tiles para esto, se documenta un ejemplo en la secci&amp;oacute;n Patr&amp;oacute;n de &lt;em&gt;sesi&amp;oacute;n de navegaci&amp;oacute;n a&lt;/em&gt; continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a7f5fb81c26b1abadccf00465e65f7fa65dea140" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; inside Lua scripts like with normal clients, However one subtle aspect of the behavior changes between Redis 2.8.11 and Redis 2.8.12. Before the 2.8.12 release the database selected by the Lua script was &lt;em&gt;transferred&lt;/em&gt; to the calling script as current database. Starting from Redis 2.8.12 the database selected by the Lua script only affects the execution of the script itself, but does not modify the database selected by the client calling the script.</source>
          <target state="translated">Es posible llamar a &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; dentro de los scripts de Lua como con los clientes normales. Sin embargo, un aspecto sutil del comportamiento cambia entre Redis 2.8.11 y Redis 2.8.12. Antes de la versi&amp;oacute;n 2.8.12, la base de datos seleccionada por el script Lua se &lt;em&gt;transfiri&amp;oacute;&lt;/em&gt; al script de llamada como base de datos actual. A partir de Redis 2.8.12, la base de datos seleccionada por el script Lua solo afecta la ejecuci&amp;oacute;n del propio script, pero no modifica la base de datos seleccionada por el cliente que llama al script.</target>
        </trans-unit>
        <trans-unit id="0958a04d7552830b3684f48a6c436807896935c0" translate="yes" xml:space="preserve">
          <source>It is possible to call Redis commands from a Lua script using two different Lua functions:</source>
          <target state="translated">Es posible llamar a los comandos Redis desde un script Lua usando dos funciones Lua diferentes:</target>
        </trans-unit>
        <trans-unit id="b0a209f43840d7a1f6f04e02663cf8a792cab884" translate="yes" xml:space="preserve">
          <source>It is possible to entirely remove the connection name setting it to the empty string, that is not a valid connection name since it serves to this specific purpose.</source>
          <target state="translated">Es posible eliminar por completo el nombre de la conexión poniéndolo en la cadena vacía,que no es un nombre de conexión válido ya que sirve para este propósito específico.</target>
        </trans-unit>
        <trans-unit id="db23050fd5ba19a3417f8b624df748886d949634" translate="yes" xml:space="preserve">
          <source>It is possible to get just the length of the slow log using the command &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;.</source>
          <target state="translated">Es posible obtener solo la longitud del registro lento usando el comando &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="db19130f0bd00fca33ef9a77ffc0a1ce2466b31d" translate="yes" xml:space="preserve">
          <source>It is possible to give the command in the following special form in order to make it more efficient:</source>
          <target state="translated">Es posible dar la orden en la siguiente forma especial para hacerla más eficiente:</target>
        </trans-unit>
        <trans-unit id="e24f1bfbfced0e2fc3e90a67dd138360e0226aa2" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option.</source>
          <target state="translated">Es posible limitar el tama&amp;ntilde;o de la secuencia a un n&amp;uacute;mero m&amp;aacute;ximo de elementos usando la opci&amp;oacute;n &lt;strong&gt;MAXLEN&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="712b25407c86c3da9193a8517aa1f28826626087" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option. By default, or when used with the &lt;code&gt;=&lt;/code&gt; argument, the &lt;strong&gt;MAXLEN&lt;/strong&gt; option performs an exact trimming. That means that the trimmed stream's length will be exactly the minimum between its original length and the specified maximum length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2ff105ab5c2c719dd08acac18181138935047b" translate="yes" xml:space="preserve">
          <source>It is possible to make this system more robust modifying the unlock schema as follows:</source>
          <target state="translated">Es posible hacer este sistema más robusto modificando el esquema de desbloqueo de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="493e108b328a9e96e14d97d5ac7db908da18cbb1" translate="yes" xml:space="preserve">
          <source>It is possible to modify the maximum time a script can be executed with millisecond precision, either via &lt;code&gt;redis.conf&lt;/code&gt; or using the CONFIG GET / CONFIG SET command. The configuration parameter affecting max execution time is called &lt;code&gt;lua-time-limit&lt;/code&gt;.</source>
          <target state="translated">Es posible modificar el tiempo m&amp;aacute;ximo que se puede ejecutar un script con precisi&amp;oacute;n de milisegundos, ya sea a trav&amp;eacute;s de &lt;code&gt;redis.conf&lt;/code&gt; o usando el comando CONFIG GET / CONFIG SET. El par&amp;aacute;metro de configuraci&amp;oacute;n que afecta al tiempo m&amp;aacute;ximo de ejecuci&amp;oacute;n se llama &lt;code&gt;lua-time-limit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16570d1ed8c0ba499d85c4796bacd5587bfbf468" translate="yes" xml:space="preserve">
          <source>It is possible to only iterate elements matching a given glob-style pattern, similarly to the behavior of the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; command that takes a pattern as only argument.</source>
          <target state="translated">Es posible solo iterar elementos que coincidan con un patr&amp;oacute;n de estilo glob dado, de manera similar al comportamiento del comando &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; que toma un patr&amp;oacute;n como &amp;uacute;nico argumento.</target>
        </trans-unit>
        <trans-unit id="1b6a2609bc05ff6f008c837f6095456b47106ecb" translate="yes" xml:space="preserve">
          <source>It is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c90a5608f4fab2983bbd179b23cb40526ff6f3e" translate="yes" xml:space="preserve">
          <source>It is possible to pass the &lt;code&gt;WITHSCORES&lt;/code&gt; option in order to return the scores of the elements together with the elements. The returned list will contain &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; instead of &lt;code&gt;value1,...,valueN&lt;/code&gt;. Client libraries are free to return a more appropriate data type (suggestion: an array with (value, score) arrays/tuples).</source>
          <target state="translated">Es posible pasar la opci&amp;oacute;n &lt;code&gt;WITHSCORES&lt;/code&gt; para devolver las puntuaciones de los elementos junto con los elementos. La lista devuelta contendr&amp;aacute; &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; en lugar de &lt;code&gt;value1,...,valueN&lt;/code&gt; . Las bibliotecas cliente son libres de devolver un tipo de datos m&amp;aacute;s apropiado (sugerencia: una matriz con (valor, puntuaci&amp;oacute;n) matrices / tuplas).</target>
        </trans-unit>
        <trans-unit id="5fd91c3878c3497da37709cc86d8056d11e4d945" translate="yes" xml:space="preserve">
          <source>It is possible to provide multiple filters at the same time. The command will handle multiple filters via logical AND. For example:</source>
          <target state="translated">Es posible proporcionar varios filtros al mismo tiempo.El comando manejará múltiples filtros a través del AND lógico.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="1c3121b308c1fd1777b057f001ac070f1a4f6932" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;c&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;a&lt;/code&gt; as third element.</source>
          <target state="translated">Es posible empujar varios elementos usando una sola llamada de comando simplemente especificando m&amp;uacute;ltiples argumentos al final del comando. Los elementos se insertan uno tras otro en el encabezado de la lista, desde el elemento m&amp;aacute;s a la izquierda hasta el elemento m&amp;aacute;s a la derecha. Entonces, por ejemplo, el comando &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; resultar&amp;aacute; en una lista que contiene &lt;code&gt;c&lt;/code&gt; como primer elemento, &lt;code&gt;b&lt;/code&gt; como segundo elemento y &lt;code&gt;a&lt;/code&gt; como tercer elemento.</target>
        </trans-unit>
        <trans-unit id="f7c76d9bc80fdf12c410c3b35eb8ad68df167802" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;a&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;c&lt;/code&gt; as third element.</source>
          <target state="translated">Es posible empujar varios elementos usando una sola llamada de comando simplemente especificando m&amp;uacute;ltiples argumentos al final del comando. Los elementos se insertan uno tras otro al final de la lista, desde el elemento m&amp;aacute;s a la izquierda hasta el elemento m&amp;aacute;s a la derecha. Entonces, por ejemplo, el comando &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; resultar&amp;aacute; en una lista que contiene &lt;code&gt;a&lt;/code&gt; como primer elemento, &lt;code&gt;b&lt;/code&gt; como segundo elemento y &lt;code&gt;c&lt;/code&gt; como tercer elemento.</target>
        </trans-unit>
        <trans-unit id="6156ba53b9a2d5fcb6563a933eb7f9a8915352ac" translate="yes" xml:space="preserve">
          <source>It is possible to reset only specific events by providing the &lt;code&gt;event&lt;/code&gt; names as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b01178931bb71c8630b481c710157203df1e465" translate="yes" xml:space="preserve">
          <source>It is possible to send &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; in a MULTI/EXEC block together with the &lt;code&gt;INFO replication&lt;/code&gt; command in order to get the current master offset at the time the clients are blocked. This way it is possible to wait for a specific offset in the replica side in order to make sure all the replication stream was processed.</source>
          <target state="translated">Es posible enviar &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; en un bloque MULTI / EXEC junto con el comando de &lt;code&gt;INFO replication&lt;/code&gt; para obtener el desplazamiento maestro actual en el momento en que los clientes est&amp;aacute;n bloqueados. De esta forma, es posible esperar un desplazamiento espec&amp;iacute;fico en el lado de la r&amp;eacute;plica para asegurarse de que se proces&amp;oacute; todo el flujo de r&amp;eacute;plica.</target>
        </trans-unit>
        <trans-unit id="0ec5055f100665a2489124e5d7125126bd09824c" translate="yes" xml:space="preserve">
          <source>It is possible to specify an optional modifier to alter the behavior of the command. Specifically:</source>
          <target state="translated">Es posible especificar un modificador opcional para alterar el comportamiento del comando.Específicamente:</target>
        </trans-unit>
        <trans-unit id="45f8f96397f97e0b1f0e90886760fbff08204ef1" translate="yes" xml:space="preserve">
          <source>It is possible to switch persistence from RDB snapshotting to append-only file (and the other way around) using the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command. For more information about how to do that please check the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence page&lt;/a&gt;.</source>
          <target state="translated">Es posible cambiar la persistencia de la instant&amp;aacute;nea RDB a un archivo de solo anexi&amp;oacute;n (y al rev&amp;eacute;s) usando el comando &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo hacerlo, consulte la &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;p&amp;aacute;gina de persistencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2a6138f902bc8b4bcfbc90caefbe979c90132a" translate="yes" xml:space="preserve">
          <source>It is possible to terminate a script that executes only read-only commands using the &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; command. This does not violate the scripting semantic as no data was yet written to the dataset by the script.</source>
          <target state="translated">Es posible terminar una secuencia de comandos que ejecuta solo comandos de solo lectura utilizando el comando &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; . Esto no viola la sem&amp;aacute;ntica de la secuencia de comandos, ya que la secuencia de comandos a&amp;uacute;n no ha escrito datos en el conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="e71c9ce4c62f0cde3cb804acf308d1e98fe95b09" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; and &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; together at every page view to have a counter counting only the latest N page views separated by less than the specified amount of seconds.</source>
          <target state="translated">Es posible usar &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; y &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; juntos en cada vista de p&amp;aacute;gina para tener un contador que cuente solo las &amp;uacute;ltimas N vistas de p&amp;aacute;gina separadas por menos de la cantidad de segundos especificada.</target>
        </trans-unit>
        <trans-unit id="2dd681e578f9014910b8ac5ae0c3612f0ad14944" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;BY&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; options against hash fields with the following syntax:</source>
          <target state="translated">Es posible usar las opciones &lt;code&gt;BY&lt;/code&gt; y &lt;code&gt;GET&lt;/code&gt; contra campos hash con la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="b7c843f5e285c955a784fb3560240c16b6f9efa9" translate="yes" xml:space="preserve">
          <source>It is possible to use them in &lt;code&gt;geohash.org&lt;/code&gt; URLs such as &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt;. This is an &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;example of such URL&lt;/a&gt;.</source>
          <target state="translated">Es posible usarlos en URL de &lt;code&gt;geohash.org&lt;/code&gt; como &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt; . Este es un &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;ejemplo de dicha URL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b30cb831388a0a49ee8acf0fd13e74a7abc3ab8f" translate="yes" xml:space="preserve">
          <source>It is possible to write to the Redis log file from Lua scripts using the &lt;code&gt;redis.log&lt;/code&gt; function.</source>
          <target state="translated">Es posible escribir en el archivo de registro de Redis desde los scripts de Lua usando la funci&amp;oacute;n &lt;code&gt;redis.log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dee99c37f02de301ed26c2711bf105931901e4b7" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the highest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">Es la versión de bloqueo porque bloquea la conexión cuando no hay miembros que salten de cualquiera de los conjuntos ordenados dados.El miembro con la puntuación más alta se salta desde el primer conjunto ordenado que no está vacío,con las teclas dadas siendo comprobadas en el orden en que son dadas.</target>
        </trans-unit>
        <trans-unit id="b7063c25aabd8a7e88f52a969b68eec3fd17473b" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the lowest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">Es la versión de bloqueo porque bloquea la conexión cuando no hay miembros que salten de cualquiera de los conjuntos ordenados dados.El miembro con la puntuación más baja salta desde el primer conjunto ordenado que no esté vacío,y las teclas dadas se comprueban en el orden en que se dan.</target>
        </trans-unit>
        <trans-unit id="164013c6ace79ff08b57e9e952d3d8fc12045787" translate="yes" xml:space="preserve">
          <source>It just assumes that the Earth is a sphere, since the used distance formula is the Haversine formula. This formula is only an approximation when applied to the Earth, which is not a perfect sphere. The introduced errors are not an issue when used in the context of social network sites that need to query by radius and most other applications. However in the worst case the error may be up to 0.5%, so you may want to consider other systems for error-critical applications.</source>
          <target state="translated">Sólo asume que la Tierra es una esfera,ya que la fórmula de distancia usada es la fórmula de Haversine.Esta fórmula es sólo una aproximación cuando se aplica a la Tierra,que no es una esfera perfecta.Los errores introducidos no son un problema cuando se utilizan en el contexto de los sitios de redes sociales que necesitan hacer consultas por radio y la mayoría de las otras aplicaciones.Sin embargo,en el peor de los casos el error puede ser de hasta el 0,5%,por lo que es posible que desee considerar otros sistemas para aplicaciones críticas para el error.</target>
        </trans-unit>
        <trans-unit id="78cca099dcd0e67e0e370e606d28021ee24c5299" translate="yes" xml:space="preserve">
          <source>It should display some computer art. There are no limits as long as the output works well in a normal terminal display. However the output should not be limited to graphics (like LOLWUT 5 and 6 actually do), but can be generative poetry and other non graphical things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886b0ba44681d142ee0340c1b1c340fb49ca65a9" translate="yes" xml:space="preserve">
          <source>It starts accepting commands again from other clients, but will reply with a BUSY error to all the clients sending normal commands. The only allowed commands in this status are &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; and &lt;code&gt;SHUTDOWN
NOSAVE&lt;/code&gt;.</source>
          <target state="translated">Comienza a aceptar comandos nuevamente de otros clientes, pero responder&amp;aacute; con un error BUSY a todos los clientes que env&amp;iacute;an comandos normales. Los &amp;uacute;nicos comandos permitidos en este estado son &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; y &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9c449f7e951338dc4ce45209e7239b6180f2387" translate="yes" xml:space="preserve">
          <source>It stops processing all the pending commands from normal and pub/sub clients. However interactions with replicas will continue normally.</source>
          <target state="translated">Deja de procesar todos los comandos pendientes de los clientes normales y de los clientes del pub/sub.Sin embargo,las interacciones con las réplicas continuarán normalmente.</target>
        </trans-unit>
        <trans-unit id="de49d1f951abef9774a1080b68edfd084cab6b36" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="translated">Admite varias otras funciones: &lt;code&gt;bit.tobit&lt;/code&gt; , &lt;code&gt;bit.tohex&lt;/code&gt; , &lt;code&gt;bit.bnot&lt;/code&gt; , &lt;code&gt;bit.band&lt;/code&gt; , &lt;code&gt;bit.bor&lt;/code&gt; , &lt;code&gt;bit.bxor&lt;/code&gt; , &lt;code&gt;bit.lshift&lt;/code&gt; , &lt;code&gt;bit.rshift&lt;/code&gt; , &lt;code&gt;bit.arshift&lt;/code&gt; , &lt;code&gt;bit.rol&lt;/code&gt; , &lt;code&gt;bit.ror&lt;/code&gt; , &lt;code&gt;bit.bswap&lt;/code&gt; . Todas las funciones disponibles est&amp;aacute;n documentadas en la documentaci&amp;oacute;n de &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49c10040c2d176504fa4270533a1f6d22770dff5" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;https://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6a033ac7293343a89e1b83064df26de033f26b" translate="yes" xml:space="preserve">
          <source>Iteratating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">Iterando una secuencia de forma incremental, devolviendo solo algunos elementos en cada iteraci&amp;oacute;n. Sin embargo, es sem&amp;aacute;nticamente mucho m&amp;aacute;s robusto que la familia de funciones &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa52c04afc758e80cafb88b8a1109903b053dfb" translate="yes" xml:space="preserve">
          <source>Iterating a stream</source>
          <target state="translated">Iterar una corriente</target>
        </trans-unit>
        <trans-unit id="51c1f7544778c11ca5b79e2c5f951971fc09700a" translate="yes" xml:space="preserve">
          <source>Iterating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb66fccc1c9fe8583ef2426d5ce548dc6f7ff69" translate="yes" xml:space="preserve">
          <source>Iterating with XREVRANGE</source>
          <target state="translated">Iterar con XREVRANGE</target>
        </trans-unit>
        <trans-unit id="ac745b350ec3c8d6357a81e49fd4c8b3f51fac37" translate="yes" xml:space="preserve">
          <source>Iterating with earlier versions of Redis</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4794d4e58656f4a052385045d3fd4b0331ebddea" translate="yes" xml:space="preserve">
          <source>Iteration of a Hash value.</source>
          <target state="translated">Iteración de un valor de Hash.</target>
        </trans-unit>
        <trans-unit id="ac97fd8044e211b8965191abd3e1372d4a6075d6" translate="yes" xml:space="preserve">
          <source>KEYS</source>
          <target state="translated">KEYS</target>
        </trans-unit>
        <trans-unit id="d4d3343d1b4f35172b9d4fabff52e12ab9514f83" translate="yes" xml:space="preserve">
          <source>KEYS  pattern   Find all keys matching the given pattern</source>
          <target state="translated">Patrón de teclas Encuentra todas las teclas que coincidan con el patrón dado</target>
        </trans-unit>
        <trans-unit id="8001eeb819fd035ff21dae0c64b60f000bfc9daa" translate="yes" xml:space="preserve">
          <source>Key step count allows us to find key positions in commands like &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; where the format is &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt;.</source>
          <target state="translated">Recuento de claves de paso nos permite encontrar posiciones clave en comandos como &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; donde el formato es &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="5e0969e73b8800b103eeedd8f6bcdbbbf0f4fa78" translate="yes" xml:space="preserve">
          <source>Keys are checked in the order that they are given. Let's say that the key &lt;code&gt;list1&lt;/code&gt; doesn't exist and &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; hold non-empty lists. Consider the following command:</source>
          <target state="translated">Las claves se verifican en el orden en que se dan. Digamos que la clave &lt;code&gt;list1&lt;/code&gt; no existe y &lt;code&gt;list2&lt;/code&gt; y &lt;code&gt;list3&lt;/code&gt; mantener listas no vac&amp;iacute;as. Considere el siguiente comando:</target>
        </trans-unit>
        <trans-unit id="393be168e99116be87234133e2763b06336c48c1" translate="yes" xml:space="preserve">
          <source>Keys expiring information is stored as absolute Unix timestamps (in milliseconds in case of Redis version 2.6 or greater). This means that the time is flowing even when the Redis instance is not active.</source>
          <target state="translated">La información sobre la caducidad de las claves se almacena en forma de sellos de tiempo absolutos de Unix (en milisegundos en el caso de la versión 2.6 o superior de Redis).Esto significa que el tiempo fluye incluso cuando la instancia de Redis no está activa.</target>
        </trans-unit>
        <trans-unit id="d3023dfa16df6ad208cc7d5460854b58da1edb26" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets.</source>
          <target state="translated">Las llaves que no existen se consideran conjuntos vacíos.</target>
        </trans-unit>
        <trans-unit id="d71481abd644158f5a9fbc5c9cecdf74dc0540c6" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets. With one of the keys being an empty set, the resulting set is also empty (since set intersection with an empty set always results in an empty set).</source>
          <target state="translated">Las llaves que no existen se consideran conjuntos vacíos.Si una de las claves es un conjunto vacío,el conjunto resultante también está vacío (ya que la intersección de un conjunto con un conjunto vacío siempre da como resultado un conjunto vacío).</target>
        </trans-unit>
        <trans-unit id="a78a3a71051e865654da3b71a5c55513e9449b8a" translate="yes" xml:space="preserve">
          <source>Keys with an expire</source>
          <target state="translated">Las llaves con un vencimiento</target>
        </trans-unit>
        <trans-unit id="7bcef127a442604057181ff7e89e6774cfcbdec1" translate="yes" xml:space="preserve">
          <source>Keyspace hits</source>
          <target state="translated">Golpes en el espacio clave</target>
        </trans-unit>
        <trans-unit id="0ecc36a9eabb580bee92d3334fc963c0e285c8f2" translate="yes" xml:space="preserve">
          <source>Keyspace misses</source>
          <target state="translated">Keyspace falla</target>
        </trans-unit>
        <trans-unit id="18937f1c4a4cfb92babe800429a63d572cde1150" translate="yes" xml:space="preserve">
          <source>Kills the currently executing Lua script, assuming no write operation was yet performed by the script.</source>
          <target state="translated">Mata el guión de Lua que se está ejecutando actualmente,suponiendo que el guión no haya realizado todavía ninguna operación de escritura.</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a452e11c491a60de5436b1999a469cdaa66c0c00" translate="yes" xml:space="preserve">
          <source>LASTSAVE</source>
          <target state="translated">LASTSAVE</target>
        </trans-unit>
        <trans-unit id="fb2ee42881d40ddc3d3aec1d41500b08e5d25e19" translate="yes" xml:space="preserve">
          <source>LASTSAVE   Get the UNIX time stamp of the last successful save to disk</source>
          <target state="translated">LASTSAVE Obtener la marca de tiempo UNIX de la última vez que se guardó con éxito en el disco.</target>
        </trans-unit>
        <trans-unit id="49d6c10ecea9234f6d1697a89998efd2571a5a9d" translate="yes" xml:space="preserve">
          <source>LATENCY</source>
          <target state="translated">LATENCY</target>
        </trans-unit>
        <trans-unit id="0501d335a5299cb1743cbb10c7b8477444d0a1c2" translate="yes" xml:space="preserve">
          <source>LATENCY DOCTOR   Return a human readable latency analysis report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186301f764b22cd2877e1aabbbb1538d6d5f7100" translate="yes" xml:space="preserve">
          <source>LATENCY GRAPH  event   Return a latency graph for the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd2b2b9b61f8de610b1da572e4c2d464408238b" translate="yes" xml:space="preserve">
          <source>LATENCY HELP   Show helpful text about the different subcommands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4448a36c961ebd2847369404270a681d688d37d" translate="yes" xml:space="preserve">
          <source>LATENCY HISTORY  event   Return timestamp-latency samples for the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40376256cb5363f7be31b5131fdde6f208ad798b" translate="yes" xml:space="preserve">
          <source>LATENCY LATEST   Return the latest latency samples for all events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46ae60e5ee406730f6e4d649edcf9436c10620d" translate="yes" xml:space="preserve">
          <source>LATENCY RESET  [event [event ...]]   Reset latency data for one or more events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6fdb30d112715d0c3b5d8a01834e5fa3472abec" translate="yes" xml:space="preserve">
          <source>LCS algorithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89288dff0eca7e3500efaf0b7acd0c70cae1edc4" translate="yes" xml:space="preserve">
          <source>LCS is very useful in order to evaluate how similar two strings are. Strings can represent many things. For instance if two strings are DNA sequences, the LCS will provide a measure of similarity between the two DNA sequences. If the strings represent some text edited by some user, the LCS could represent how different the new text is compared to the old one, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ffd63c8ba805a842d4d3d2465da47916360545" translate="yes" xml:space="preserve">
          <source>LDB can be enabled in one of two modes: asynchronous or synchronous. In asynchronous mode the server creates a forked debugging session that does not block and all changes to the data are &lt;strong&gt;rolled back&lt;/strong&gt; after the session finishes, so debugging can be restarted using the same initial state. The alternative synchronous debug mode blocks the server while the debugging session is active and retains all changes to the data set once it ends.</source>
          <target state="translated">LDB se puede habilitar en uno de dos modos: as&amp;iacute;ncrono o s&amp;iacute;ncrono. En el modo asincr&amp;oacute;nico, el servidor crea una sesi&amp;oacute;n de depuraci&amp;oacute;n bifurcada que no se bloquea y todos los cambios en los datos se &lt;strong&gt;revierten una vez&lt;/strong&gt; finalizada la sesi&amp;oacute;n, por lo que la depuraci&amp;oacute;n se puede reiniciar utilizando el mismo estado inicial. El modo de depuraci&amp;oacute;n s&amp;iacute;ncrono alternativo bloquea el servidor mientras la sesi&amp;oacute;n de depuraci&amp;oacute;n est&amp;aacute; activa y retiene todos los cambios en el conjunto de datos una vez que finaliza.</target>
        </trans-unit>
        <trans-unit id="14d2c13614325f3af7fa95efeb5dd818bb2ab0d1" translate="yes" xml:space="preserve">
          <source>LINDEX</source>
          <target state="translated">LINDEX</target>
        </trans-unit>
        <trans-unit id="a2dedc00417f0b7b29562ddaa4e03af088097cdb" translate="yes" xml:space="preserve">
          <source>LINDEX  key index   Get an element from a list by its index</source>
          <target state="translated">Índice de claves LINDEX Obtener un elemento de una lista por su índice</target>
        </trans-unit>
        <trans-unit id="40088c47225008784271c2935753b4ae98fd6ec7" translate="yes" xml:space="preserve">
          <source>LINSERT</source>
          <target state="translated">LINSERT</target>
        </trans-unit>
        <trans-unit id="b2f2247f94ae9fe4fba40fd22b1b94acb748b154" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot element   Insert an element before or after another element in a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca09700aae0c450ed6c327c789e3e1e3fef9f931" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot value   Insert an element before or after another element in a list</source>
          <target state="translated">Tecla LINSERT ANTES o DESPUÉS del valor del pivote Insertar un elemento antes o después de otro elemento de una lista</target>
        </trans-unit>
        <trans-unit id="19ce1639e2d6248a60334eca45396c2f1f706007" translate="yes" xml:space="preserve">
          <source>LLEN</source>
          <target state="translated">LLEN</target>
        </trans-unit>
        <trans-unit id="defc92ee8b39130b63cdf033e9edada00210e4f3" translate="yes" xml:space="preserve">
          <source>LLEN  key   Get the length of a list</source>
          <target state="translated">Tecla LLEN Obtener la longitud de una lista</target>
        </trans-unit>
        <trans-unit id="cb98d0989512bc7d03fd0083653a3d72b76da663" translate="yes" xml:space="preserve">
          <source>LMOVE</source>
          <target state="translated">LMOVE</target>
        </trans-unit>
        <trans-unit id="78baeb2f5149c1548b47f47678b64129f94c3043" translate="yes" xml:space="preserve">
          <source>LMOVE  source destination LEFT|RIGHT LEFT|RIGHT   Pop an element from a list, push it to another list and return it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd49a9c6357f14037353e324dbbd426c30c77ff" translate="yes" xml:space="preserve">
          <source>LOLWUT</source>
          <target state="translated">LOLWUT</target>
        </trans-unit>
        <trans-unit id="91989e8620d79bb9a73795ebf9495785796e20eb" translate="yes" xml:space="preserve">
          <source>LOLWUT  [VERSION version]   Display some computer art and the Redis version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e5b9325998311e1bd0cdebf30f7c4698bea549" translate="yes" xml:space="preserve">
          <source>LOLWUT implementations should be safe and carefully checked for security, and resist to untrusted inputs if they take arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b789d56cc69b68e8cc9454d61b8f6bcb54c00bd" translate="yes" xml:space="preserve">
          <source>LOLWUT must always display the Redis version at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7fd4a8e75c582938a820d5ac113cfb69399cf55" translate="yes" xml:space="preserve">
          <source>LOLWUT output should be completely useless. Displaying some useful Redis internal metrics does not count as a valid LOLWUT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93af8b70d5c9191d5ace878da62d412c38ce8b2" translate="yes" xml:space="preserve">
          <source>LOLWUT output should be fast to generate so that the command can be called in production instances without issues. It should remain fast even when the user experiments with odd parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f982fb7857c5b2bb4e69ef661e4d5d07a8ccdf1" translate="yes" xml:space="preserve">
          <source>LOLWUT wants to be a reminder that there is more in programming than just putting some code together in order to create something useful. Every LOLWUT version should have the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f58be63c72a45daadb6f09041398ad98c6ac9a7" translate="yes" xml:space="preserve">
          <source>LPOP</source>
          <target state="translated">LPOP</target>
        </trans-unit>
        <trans-unit id="c0a0f50764c15280585040d66db05c7ea7d4701a" translate="yes" xml:space="preserve">
          <source>LPOP  key   Remove and get the first element in a list</source>
          <target state="translated">Tecla LPOP Eliminar y obtener el primer elemento de una lista</target>
        </trans-unit>
        <trans-unit id="75ee742440d0263541b4bf6b56f59ba72ebbd18e" translate="yes" xml:space="preserve">
          <source>LPOP  key [count]   Remove and get the first elements in a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8692b4b41c5b80f3fc1b6efeb4604f7278100aec" translate="yes" xml:space="preserve">
          <source>LPOS</source>
          <target state="translated">LPOS</target>
        </trans-unit>
        <trans-unit id="2f8be8617cbb634559fc59c4d3862bfd42f75d83" translate="yes" xml:space="preserve">
          <source>LPOS  key element [RANK rank] [COUNT num-matches] [MAXLEN len]   Return the index of matching elements on a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f49fc76e42ddd892d0dbf761cab7456fba6707a" translate="yes" xml:space="preserve">
          <source>LPUSH</source>
          <target state="translated">LPUSH</target>
        </trans-unit>
        <trans-unit id="5005b933581b136ea08ec907be2cf03efef61621" translate="yes" xml:space="preserve">
          <source>LPUSH  key element [element ...]   Prepend one or multiple elements to a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3260ebe55f682088cc638c2329d0a5d2a5f9c43" translate="yes" xml:space="preserve">
          <source>LPUSH  key value [value ...]   Prepend one or multiple values to a list</source>
          <target state="translated">Valor de la tecla LPUSH [valor ...]Prepárese para uno o varios valores de una lista</target>
        </trans-unit>
        <trans-unit id="73023347f78efa6f33e2849831f260102f26f9dc" translate="yes" xml:space="preserve">
          <source>LPUSHX</source>
          <target state="translated">LPUSHX</target>
        </trans-unit>
        <trans-unit id="ed89f101b9e76dd34f817063ee39924d1d879b9e" translate="yes" xml:space="preserve">
          <source>LPUSHX  key element [element ...]   Prepend an element to a list, only if the list exists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11960d83f4ba3a64c1274bec7eeaf405b1c4abbe" translate="yes" xml:space="preserve">
          <source>LPUSHX  key value   Prepend a value to a list, only if the list exists</source>
          <target state="translated">Valor de la clave LPUSHX Prepárese un valor para una lista,sólo si la lista existe</target>
        </trans-unit>
        <trans-unit id="3b47c23e3107b92100b9303bb9ab3d1a9ccc56bd" translate="yes" xml:space="preserve">
          <source>LRANGE</source>
          <target state="translated">LRANGE</target>
        </trans-unit>
        <trans-unit id="326594fa342712e825205a5b864121b10bd2f5cf" translate="yes" xml:space="preserve">
          <source>LRANGE  key start stop   Get a range of elements from a list</source>
          <target state="translated">LRANGE tecla inicio parada Obtener una serie de elementos de una lista</target>
        </trans-unit>
        <trans-unit id="abfc25d80dc9a80384bd4c9697b510b323ecc45b" translate="yes" xml:space="preserve">
          <source>LREM</source>
          <target state="translated">LREM</target>
        </trans-unit>
        <trans-unit id="254b612ba99c38d18c49c669440c641123e2f3a7" translate="yes" xml:space="preserve">
          <source>LREM  key count element   Remove elements from a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0b649e2191175bc6abf8bc7b2d0b6ec6fbf904d" translate="yes" xml:space="preserve">
          <source>LREM  key count value   Remove elements from a list</source>
          <target state="translated">Valor de recuento de la clave LREM Eliminar elementos de una lista</target>
        </trans-unit>
        <trans-unit id="70e8f03d6f4f36a9430ac8c4d4a1515597b0b252" translate="yes" xml:space="preserve">
          <source>LSET</source>
          <target state="translated">LSET</target>
        </trans-unit>
        <trans-unit id="67b8e37be9910fff9bc7142f035eae99cc3cc4f5" translate="yes" xml:space="preserve">
          <source>LSET  key index element   Set the value of an element in a list by its index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f03203283df161a2d6f2abf4d29626d32823249" translate="yes" xml:space="preserve">
          <source>LSET  key index value   Set the value of an element in a list by its index</source>
          <target state="translated">Valor del índice de la clave LSET Establecer el valor de un elemento de una lista por su índice</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="6c5b375830efe50dd05881b52f80e2aa747afced" translate="yes" xml:space="preserve">
          <source>LTRIM  key start stop   Trim a list to the specified range</source>
          <target state="translated">Tecla LTRIM inicio parada Recortar una lista al rango especificado</target>
        </trans-unit>
        <trans-unit id="de6a27da313b316346ea7dcf9f866c5fcdaff765" translate="yes" xml:space="preserve">
          <source>Last Key in Argument List</source>
          <target state="translated">Última clave en la lista de argumentos</target>
        </trans-unit>
        <trans-unit id="65fe7d4d518c0668f04d8585ccfbc20334e6fd38" translate="yes" xml:space="preserve">
          <source>Lastly, there are three important rules to note:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e1040fdde9172717ea80a7cdcb3b316461fb75" translate="yes" xml:space="preserve">
          <source>Later it will be trivial to know the number of single days the user visited the web site simply calling the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command against the bitmap.</source>
          <target state="translated">M&amp;aacute;s adelante ser&amp;aacute; trivial saber la cantidad de d&amp;iacute;as que el usuario visit&amp;oacute; el sitio web simplemente llamando al comando &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; contra el mapa de bits.</target>
        </trans-unit>
        <trans-unit id="78d7ed93f503a940a73a89268b71f5daa31c6b65" translate="yes" xml:space="preserve">
          <source>Latest event latency in millisecond.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6167261c71ec337f0f15b900208ad184a4f7b0c9" translate="yes" xml:space="preserve">
          <source>Latest fork(2) time</source>
          <target state="translated">Última hora de la horquilla (2)</target>
        </trans-unit>
        <trans-unit id="0122f9d36a5bc7edfbaa17dc0a7b017882cfb3ae" translate="yes" xml:space="preserve">
          <source>Let's assume we have four nodes, A, B, C and D. In order to end with just a three nodes cluster A, B, C we may follow these steps:</source>
          <target state="translated">Supongamos que tenemos cuatro nodos,A,B,C y D.Para terminar con sólo tres nodos del grupo A,B,C podemos seguir estos pasos:</target>
        </trans-unit>
        <trans-unit id="2f5c5e27076a7756eeef955cec8a1510af3fb9c4" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.</source>
          <target state="translated">Licenciado bajo la Creative Commons Attribution-ShareAlike License 4.0.</target>
        </trans-unit>
        <trans-unit id="98cf5d780c53575d17f1d32cf3823650dcaa6c52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; this command returns the remaining time to live of a key that has an expire set, with the sole difference that &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; returns the amount of remaining time in seconds while &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; returns it in milliseconds.</source>
          <target state="translated">Al igual que &lt;a href=&quot;ttl&quot;&gt;TTL,&lt;/a&gt; este comando devuelve el tiempo de vida restante de una clave que tiene un vencimiento establecido, con la &amp;uacute;nica diferencia de que &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; devuelve la cantidad de tiempo restante en segundos, mientras que &lt;a href=&quot;pttl&quot;&gt;PTTL lo&lt;/a&gt; devuelve en milisegundos.</target>
        </trans-unit>
        <trans-unit id="199ff2ec8051414c46a22a354ba2c4bf9f64de93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; this command can be used in order to iterate the whole stream content, however note that in this case, the next command calls should use the ID of the last entry, with the sequence number decremneted by one. However if the sequence number is already 0, the time part of the ID should be decremented by 1, and the sequence part should be set to the maxium possible sequence number, that is, 18446744073709551615, or could be omitted at all, and the command will automatically assume it to be such a number (see &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; for more info about incomplete IDs).</source>
          <target state="translated">Al igual que &lt;a href=&quot;xrange&quot;&gt;XRANGE,&lt;/a&gt; este comando se puede usar para iterar todo el contenido de la secuencia, sin embargo, tenga en cuenta que, en este caso, las siguientes llamadas de comando deben usar el ID de la &amp;uacute;ltima entrada, con el n&amp;uacute;mero de secuencia disminuido en uno. Sin embargo, si el n&amp;uacute;mero de secuencia ya es 0, la parte de tiempo de la ID debe reducirse en 1 y la parte de secuencia debe establecerse en el n&amp;uacute;mero de secuencia m&amp;aacute;ximo posible, es decir, 18446744073709551615, o podr&amp;iacute;a omitirse en absoluto, y el comando asumir&amp;aacute; autom&amp;aacute;ticamente que es ese n&amp;uacute;mero (consulte &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las ID incompletas).</target>
        </trans-unit>
        <trans-unit id="7a5a0a2011829340fa32a8f044e479cef542a701" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command can be used in a blocking way. There are no differences in this regard.</source>
          <target state="translated">Al igual que &lt;a href=&quot;xread&quot;&gt;XREAD,&lt;/a&gt; el comando &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; se puede utilizar de forma bloqueante. No hay diferencias al respecto.</target>
        </trans-unit>
        <trans-unit id="964c6e379f4b517ab54346bbc59cea679f55f58d" translate="yes" xml:space="preserve">
          <source>Like for the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; command start and end can contain negative values in order to index bytes starting from the end of the string, where -1 is the last byte, -2 is the penultimate, and so forth.</source>
          <target state="translated">Al igual que para el comando &lt;a href=&quot;getrange&quot;&gt;GETRANGE, el&lt;/a&gt; inicio y el final pueden contener valores negativos para indexar bytes comenzando desde el final de la cadena, donde -1 es el &amp;uacute;ltimo byte, -2 es el pen&amp;uacute;ltimo, y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="ce45b8148c6f69841bc195d50623329ea61f3da8" translate="yes" xml:space="preserve">
          <source>Lines can contain a section name (starting with a # character) or a property. All the properties are in the form of &lt;code&gt;field:value&lt;/code&gt; terminated by &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">Las l&amp;iacute;neas pueden contener un nombre de secci&amp;oacute;n (comenzando con un car&amp;aacute;cter #) o una propiedad. Todas las propiedades est&amp;aacute;n en forma de &lt;code&gt;field:value&lt;/code&gt; terminado por &lt;code&gt;\r\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39de9fe457bd2e361245f87b008646c82403b58e" translate="yes" xml:space="preserve">
          <source>List of rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="899acbf6050de7813479a962bcb80b73089f0f38" translate="yes" xml:space="preserve">
          <source>Lists can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;linkedlist&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is the special representation that is used to save space for small lists.</source>
          <target state="translated">Las listas se pueden codificar como &lt;code&gt;ziplist&lt;/code&gt; o &lt;code&gt;linkedlist&lt;/code&gt; . La lista &lt;code&gt;ziplist&lt;/code&gt; es la representaci&amp;oacute;n especial que se utiliza para ahorrar espacio para listas peque&amp;ntilde;as.</target>
        </trans-unit>
        <trans-unit id="db5be7f471516f84344dd104ba9b8aa174ce8d02" translate="yes" xml:space="preserve">
          <source>Lists the currently &lt;em&gt;active channels&lt;/em&gt;. An active channel is a Pub/Sub channel with one or more subscribers (not including clients subscribed to patterns).</source>
          <target state="translated">Muestra los &lt;em&gt;canales activos&lt;/em&gt; actualmente . Un canal activo es un canal Pub / Sub con uno o m&amp;aacute;s suscriptores (sin incluir los clientes suscritos a patrones).</target>
        </trans-unit>
        <trans-unit id="dcea1d44bcfef24039b8c1d6348290fc06d43c9a" translate="yes" xml:space="preserve">
          <source>Load a script into the scripts cache, without executing it. After the specified command is loaded into the script cache it will be callable using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; with the correct SHA1 digest of the script, exactly like after the first successful invocation of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">Cargue un script en la cach&amp;eacute; de scripts, sin ejecutarlo. Despu&amp;eacute;s de que el comando especificado se cargue en la cach&amp;eacute; del script, se podr&amp;aacute; &lt;a href=&quot;evalsha&quot;&gt;llamar&lt;/a&gt; mediante EVALSHA con el resumen SHA1 correcto del script, exactamente como despu&amp;eacute;s de la primera invocaci&amp;oacute;n exitosa de &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="735c2e48480d01f1dceaeb55af3cf36dcdd6249a" translate="yes" xml:space="preserve">
          <source>Loads a module from a dynamic library at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694b70e7b053ef29ce888020d6a15ef0d17437e5" translate="yes" xml:space="preserve">
          <source>Lua boolean -&amp;gt; Redis boolean true or false. &lt;strong&gt;Note that this is a change compared to the RESP2 mode&lt;/strong&gt;, where returning true from Lua returned the number 1 to the Redis client, and returning false used to return NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd47c9d2232eb759e90bf52905602d787217e6e" translate="yes" xml:space="preserve">
          <source>Lua boolean false -&amp;gt; Redis Nil bulk reply.</source>
          <target state="translated">Lua boolean false -&amp;gt; Respuesta masiva de Redis Nil.</target>
        </trans-unit>
        <trans-unit id="197815ca05866b7c30c1048b9d86321ee4ce6238" translate="yes" xml:space="preserve">
          <source>Lua boolean true -&amp;gt; Redis integer reply with value of 1.</source>
          <target state="translated">Lua boolean true -&amp;gt; Redis respuesta entera con valor de 1.</target>
        </trans-unit>
        <trans-unit id="02dda41ef75370280dc992551fadb03b88d21b1f" translate="yes" xml:space="preserve">
          <source>Lua does not export commands to access the system time or other external state.</source>
          <target state="translated">Lua no exporta comandos para acceder a la hora del sistema u otro estado externo.</target>
        </trans-unit>
        <trans-unit id="738b234f859993680828647d652f6de5655b0815" translate="yes" xml:space="preserve">
          <source>Lua has a single numerical type, Lua numbers. There is no distinction between integers and floats. So we always convert Lua numbers into integer replies, removing the decimal part of the number if any. &lt;strong&gt;If you want to return a float from Lua you should return it as a string&lt;/strong&gt;, exactly like Redis itself does (see for instance the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command).</source>
          <target state="translated">Lua tiene un solo tipo num&amp;eacute;rico, n&amp;uacute;meros Lua. No hay distinci&amp;oacute;n entre n&amp;uacute;meros enteros y flotantes. Por lo tanto, siempre convertimos los n&amp;uacute;meros Lua en respuestas enteras, eliminando la parte decimal del n&amp;uacute;mero, si corresponde. &lt;strong&gt;Si desea devolver un flotante de Lua, debe devolverlo como una cadena&lt;/strong&gt; , exactamente como lo hace el propio Redis (consulte, por ejemplo, el comando &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8a5d229484ee19b076e60e7fc0d0b8345579dcc1" translate="yes" xml:space="preserve">
          <source>Lua null -&amp;gt; Redis RESP3 new null reply (protocol &lt;code&gt;&quot;_\r\n&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c212b1d165a2bdadf01bf8c01c306a9c3e780aa" translate="yes" xml:space="preserve">
          <source>Lua number -&amp;gt; Redis integer reply (the number is converted into an integer)</source>
          <target state="translated">N&amp;uacute;mero Lua -&amp;gt; Respuesta de entero de Redis (el n&amp;uacute;mero se convierte en un entero)</target>
        </trans-unit>
        <trans-unit id="0fcb79bd3680efc38fab49be15ad5a556da29a6c" translate="yes" xml:space="preserve">
          <source>Lua pseudo random number generation functions &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; are modified in order to always have the same seed every time a new script is executed. This means that calling &lt;code&gt;math.random&lt;/code&gt; will always generate the same sequence of numbers every time a script is executed if &lt;code&gt;math.randomseed&lt;/code&gt; is not used.</source>
          <target state="translated">Las funciones de generaci&amp;oacute;n de n&amp;uacute;meros pseudoaleatorios de Lua, &lt;code&gt;math.random&lt;/code&gt; y &lt;code&gt;math.randomseed&lt;/code&gt; , se modifican para tener siempre la misma semilla cada vez que se ejecuta un nuevo script. Esto significa que llamar a &lt;code&gt;math.random&lt;/code&gt; siempre generar&amp;aacute; la misma secuencia de n&amp;uacute;meros cada vez que se ejecute un script si no se usa &lt;code&gt;math.randomseed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e026038d7a23da497563d39bf562be4e8b076af8" translate="yes" xml:space="preserve">
          <source>Lua scripts can return a value that is converted from the Lua type to the Redis protocol using a set of conversion rules.</source>
          <target state="translated">Las escrituras Lua pueden devolver un valor que se convierte del tipo Lua al protocolo Redis usando un conjunto de reglas de conversión.</target>
        </trans-unit>
        <trans-unit id="eec8779958c6af77259f2bed4f2206965d44330b" translate="yes" xml:space="preserve">
          <source>Lua string -&amp;gt; Redis bulk reply</source>
          <target state="translated">Cadena Lua -&amp;gt; Respuesta masiva de Redis</target>
        </trans-unit>
        <trans-unit id="0b78d29489185b7463559dbd5991d9b98e6ea241" translate="yes" xml:space="preserve">
          <source>Lua table (array) -&amp;gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any)</source>
          <target state="translated">Tabla Lua (matriz) -&amp;gt; Redis respuesta en masa m&amp;uacute;ltiple (truncada al primer nulo dentro de la matriz Lua, si corresponde)</target>
        </trans-unit>
        <trans-unit id="011559d094bdd466ae90420b82cf3259960bb378" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;double&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis double reply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92dffb8e404af7ee6cc40117a693313890548b7f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;err&lt;/code&gt; field -&amp;gt; Redis error reply</source>
          <target state="translated">Tabla Lua con un solo campo de &lt;code&gt;err&lt;/code&gt; or -&amp;gt; Respuesta de error de Redis</target>
        </trans-unit>
        <trans-unit id="31b3bac91c4fbeb254b85ca62a253ad709c8a47f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;map&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis map reply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860f10116eaffeabf918bd97496952f6a8568b86" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;ok&lt;/code&gt; field -&amp;gt; Redis status reply</source>
          <target state="translated">Tabla Lua con un solo campo &lt;code&gt;ok&lt;/code&gt; -&amp;gt; Respuesta de estado de Redis</target>
        </trans-unit>
        <trans-unit id="c86e8370e8448b07f033d118ba308f34fc561150" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;set&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis set reply, the values are discarded and can be anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="5f530d724793deebbb2b735aad30cfb0c16904b5" translate="yes" xml:space="preserve">
          <source>MEMORY DOCTOR   Outputs memory problems report</source>
          <target state="translated">DOCTOR DE MEMORIA Informe de problemas de memoria de salida</target>
        </trans-unit>
        <trans-unit id="f41c78df06ee10a6b220b355855965b8d5802f0d" translate="yes" xml:space="preserve">
          <source>MEMORY HELP   Show helpful text about the different subcommands</source>
          <target state="translated">AYUDA DE MEMORIA Mostrar texto útil sobre los diferentes subcomandos</target>
        </trans-unit>
        <trans-unit id="c46a26bce66617f3cb9ccdc83db737a6115fdc5d" translate="yes" xml:space="preserve">
          <source>MEMORY MALLOC-STATS   Show allocator internal stats</source>
          <target state="translated">MEMORIA MALLOC-STATS Muestra las estadísticas internas del asignador</target>
        </trans-unit>
        <trans-unit id="eb96d4965b5bb6522ee6573db44c8a6e1ce6edba" translate="yes" xml:space="preserve">
          <source>MEMORY PURGE   Ask the allocator to release memory</source>
          <target state="translated">PURGA DE MEMORIA Pedir al asignador que libere la memoria</target>
        </trans-unit>
        <trans-unit id="d3303c80cf9ee1aa6f783b72419ffa190e2a905d" translate="yes" xml:space="preserve">
          <source>MEMORY STATS   Show memory usage details</source>
          <target state="translated">ESTADOS DE MEMORIA Mostrar detalles de uso de la memoria</target>
        </trans-unit>
        <trans-unit id="de9aed5605340cafa3f173e741e4bc7253d17f99" translate="yes" xml:space="preserve">
          <source>MEMORY USAGE  key [SAMPLES count]   Estimate the memory usage of a key</source>
          <target state="translated">USO DE MEMORIA de una llave [recuento de muestras]Estimación del uso de memoria de una llave</target>
        </trans-unit>
        <trans-unit id="eb4b445b699787b561e4b67d4f6b08a7ef32cf55" translate="yes" xml:space="preserve">
          <source>MGET</source>
          <target state="translated">MGET</target>
        </trans-unit>
        <trans-unit id="ffbcf2b819692d7b52978ca1ef1e227536a082fe" translate="yes" xml:space="preserve">
          <source>MGET  key [key ...]   Get the values of all the given keys</source>
          <target state="translated">Tecla MGET [tecla ...]Obtener los valores de todas las teclas dadas</target>
        </trans-unit>
        <trans-unit id="883beaf0f91aca7f9ebc4802e0bab2501cbbc8ea" translate="yes" xml:space="preserve">
          <source>MIGRATE</source>
          <target state="translated">MIGRATE</target>
        </trans-unit>
        <trans-unit id="c26be640f072695430c6befbdaab1be7da9a4af0" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [AUTH password] [AUTH2 username password] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f0b2cdf3b3d88df6ed56ef5576fa5ec1a8aa5b1" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">MIGRAR puerto host tecla|&quot;&quot; destino-db tiempo de espera [COPIA][REEMPLAZO][TECLAS tecla ...]]Transferir atómicamente una tecla de una instancia de Redis a otra.</target>
        </trans-unit>
        <trans-unit id="66bffe2295ae671e5d45439c77216938c792414b" translate="yes" xml:space="preserve">
          <source>MODULE</source>
          <target state="translated">MODULE</target>
        </trans-unit>
        <trans-unit id="43ac8ce01de13f2da2af292daa0522a8dce0815f" translate="yes" xml:space="preserve">
          <source>MODULE LIST   List all modules loaded by the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead5dec077ff0d8c33078bffc3edb3a161d0c8b1" translate="yes" xml:space="preserve">
          <source>MODULE LOAD  path [ arg [arg ...]]   Load a module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d0e227668f65977f974daf28058d755a01a58f" translate="yes" xml:space="preserve">
          <source>MODULE UNLOAD  name   Unload a module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da5b5979c630adef5abc39370410d7de4a1b8ef" translate="yes" xml:space="preserve">
          <source>MONITOR</source>
          <target state="translated">MONITOR</target>
        </trans-unit>
        <trans-unit id="55d4d86d6d24375e297cf38db11a4bacd4febc84" translate="yes" xml:space="preserve">
          <source>MONITOR   Listen for all requests received by the server in real time</source>
          <target state="translated">MONITOR Escuche todas las solicitudes recibidas por el servidor en tiempo real</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="001d5d6407276cba944eda42b69684ebbbae5d55" translate="yes" xml:space="preserve">
          <source>MOVE  key db   Move a key to another database</source>
          <target state="translated">Mover una clave db Mover una clave a otra base de datos</target>
        </trans-unit>
        <trans-unit id="4a4d41a590643b6020afed2c32a7fa4d49b49601" translate="yes" xml:space="preserve">
          <source>MSET</source>
          <target state="translated">MSET</target>
        </trans-unit>
        <trans-unit id="9a5861cd64b36ffe83c01382e80e50105a256980" translate="yes" xml:space="preserve">
          <source>MSET  key value [key value ...]   Set multiple keys to multiple values</source>
          <target state="translated">Valor de la tecla MSET [valor de la tecla ...]Ajustar varias teclas a varios valores</target>
        </trans-unit>
        <trans-unit id="f7daca0dd0ee4f7979861ac9b4fb059852d07494" translate="yes" xml:space="preserve">
          <source>MSETNX</source>
          <target state="translated">MSETNX</target>
        </trans-unit>
        <trans-unit id="48498dbffef6df5e6474fe5db88a9722de54676a" translate="yes" xml:space="preserve">
          <source>MSETNX  key value [key value ...]   Set multiple keys to multiple values, only if none of the keys exist</source>
          <target state="translated">Valor de la tecla MSETNX [valor de la tecla ...]Ajustar varias teclas a varios valores,sólo si no existe ninguna de las teclas</target>
        </trans-unit>
        <trans-unit id="73cadb41b45514de9061a72461b466eafd7a01b0" translate="yes" xml:space="preserve">
          <source>MULTI</source>
          <target state="translated">MULTI</target>
        </trans-unit>
        <trans-unit id="bb76d99632737ac9f4ecd1c2218ac5cae7373df0" translate="yes" xml:space="preserve">
          <source>MULTI   Mark the start of a transaction block</source>
          <target state="translated">MULTI Marcar el inicio de un bloqueo de transacción</target>
        </trans-unit>
        <trans-unit id="5162c1f5fa963969d600908fd5531f9515bcd0ad" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; command to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">Emita manualmente el comando &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; para detener una secuencia de &lt;a href=&quot;monitor&quot;&gt;MONITOR que se&lt;/a&gt; ejecuta a trav&amp;eacute;s de &lt;code&gt;telnet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ab2b333d1a4eb7dc9f5b2c393ae0acfe6aa0aa8" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; commands to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195fbe53b32ee6173d85e3798809ae2267b7bfce" translate="yes" xml:space="preserve">
          <source>Marks the given keys to be watched for conditional execution of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">Marca las claves dadas que se vigilar&amp;aacute;n para la ejecuci&amp;oacute;n condicional de una &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transacci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8683729a7a727945cae9baf35f4c55f1439a9ae" translate="yes" xml:space="preserve">
          <source>Marks the start of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; block. Subsequent commands will be queued for atomic execution using &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;.</source>
          <target state="translated">Marca el inicio de un bloque de &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transacciones&lt;/a&gt; . Los comandos posteriores se pondr&amp;aacute;n en cola para su ejecuci&amp;oacute;n at&amp;oacute;mica mediante &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f713e2ee906af8b74a13e92b2e0d07f7715b2d2e" translate="yes" xml:space="preserve">
          <source>Master for slot range represented as nested IP/Port array</source>
          <target state="translated">El maestro para el rango de ranuras representado como IP anidado/Matriz de puertos</target>
        </trans-unit>
        <trans-unit id="826539552e055ad1bd8dd2263cef37308d024f80" translate="yes" xml:space="preserve">
          <source>Master output</source>
          <target state="translated">Salida maestra</target>
        </trans-unit>
        <trans-unit id="221cc49f520f042d2c8db1934cf7365d8019893a" translate="yes" xml:space="preserve">
          <source>Matches are produced from the last one to the first one, since this is how the algorithm works, and it more efficient to emit things in the same order. The above array means that the first match (second element of the array) is between positions 2-3 of the first string and 0-1 of the second. Then there is another match between 4-7 and 5-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a00e4f9797b4c734ae7a585f001ffa257119f27" translate="yes" xml:space="preserve">
          <source>Meaning of the flags (field number 3):</source>
          <target state="translated">Significado de las banderas (campo número 3):</target>
        </trans-unit>
        <trans-unit id="716383f923909d0c089205fcba00d4705b3601a5" translate="yes" xml:space="preserve">
          <source>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of the observed Sets of the source HyperLogLog structures.</source>
          <target state="translated">Fusionar múltiples valores de HyperLogLog en un valor único que se aproxime a la cardinalidad de la unión de los conjuntos observados de las estructuras HyperLogLog de origen.</target>
        </trans-unit>
        <trans-unit id="d48699ea9bf170ea49610c0892198d522150833b" translate="yes" xml:space="preserve">
          <source>Migrating multiple keys with a single command call</source>
          <target state="translated">Migrando múltiples teclas con una sola llamada de comando</target>
        </trans-unit>
        <trans-unit id="1dc9fdcdad40a742a94a677f3b78a05f4ed5e6b5" translate="yes" xml:space="preserve">
          <source>Migration and importing slots are only added to the node flagged as &lt;code&gt;myself&lt;/code&gt;. This information is local to a node, for its own slots.</source>
          <target state="translated">Las ranuras de migraci&amp;oacute;n e importaci&amp;oacute;n solo se agregan al nodo marcado como &lt;code&gt;myself&lt;/code&gt; . Esta informaci&amp;oacute;n es local para un nodo, para sus propias ranuras.</target>
        </trans-unit>
        <trans-unit id="b39875ef4297a449c400e22ef1b7f5a9df1b0b1a" translate="yes" xml:space="preserve">
          <source>Modules that register custom data types can not be unloaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf4ac897fe1476ddf0632fbae3fd4061b3a77806" translate="yes" xml:space="preserve">
          <source>More details about the Redis HyperLogLog implementation can be found in &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;this blog post&lt;/a&gt;. The source code of the implementation in the &lt;code&gt;hyperloglog.c&lt;/code&gt; file is also easy to read and understand, and includes a full specification for the exact encoding used for the sparse and dense representations.</source>
          <target state="translated">Puede encontrar m&amp;aacute;s detalles sobre la implementaci&amp;oacute;n de Redis HyperLogLog en &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;esta publicaci&amp;oacute;n de blog&lt;/a&gt; . El c&amp;oacute;digo fuente de la implementaci&amp;oacute;n en el archivo &lt;code&gt;hyperloglog.c&lt;/code&gt; tambi&amp;eacute;n es f&amp;aacute;cil de leer y comprender, e incluye una especificaci&amp;oacute;n completa para la codificaci&amp;oacute;n exacta utilizada para las representaciones dispersas y densas.</target>
        </trans-unit>
        <trans-unit id="66fbce4faebab20f5ca1d3b33c08e967f22406cb" translate="yes" xml:space="preserve">
          <source>More information about the Current Epoch and Config Epoch variables are available in the Redis Cluster specification document.</source>
          <target state="translated">Más información sobre las variables Época Actual y Época de Configuración están disponibles en el documento de especificación de Redis Cluster.</target>
        </trans-unit>
        <trans-unit id="76f5a5481231f7dff85e48d6a0993bd209662a44" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; does not need to be reciprocal. If I send the command to A in order to join B, I don't need to also send it to B in order to join A.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; no necesita ser rec&amp;iacute;proco. Si env&amp;iacute;o el comando a A para unirme a B, no necesito enviarlo tambi&amp;eacute;n a B para unirme a A.</target>
        </trans-unit>
        <trans-unit id="9e46ae1b67b3a95c0efb340b998c24643ca486fb" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message unless the &lt;code&gt;JUSTID&lt;/code&gt; option has been specified (which only delivers the message ID, not the message itself). In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8993f2e40360ac488b5303cad3bacad41d3a08f1" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message. In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">Adem&amp;aacute;s, como efecto secundario, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; incrementar&amp;aacute; el recuento de intentos de entrega del mensaje. De esta manera, los mensajes que no se pueden procesar por alguna raz&amp;oacute;n, por ejemplo, porque los consumidores se bloquean al intentar procesarlos, comenzar&amp;aacute;n a tener un contador m&amp;aacute;s grande y podr&amp;aacute;n detectarse dentro del sistema.</target>
        </trans-unit>
        <trans-unit id="6330fc6bbcd49c1766a676116e26172a91d38595" translate="yes" xml:space="preserve">
          <source>Moreover, if you are new to streams, we recommend to read our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. Make sure to understand the concept of consumer group in the introduction so that following how this command works will be simpler.</source>
          <target state="translated">Adem&amp;aacute;s, si es nuevo en las transmisiones, le recomendamos que lea nuestra &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introducci&amp;oacute;n a Redis Streams&lt;/a&gt; . Aseg&amp;uacute;rese de comprender el concepto de grupo de consumidores en la introducci&amp;oacute;n para que seguir c&amp;oacute;mo funciona este comando sea m&amp;aacute;s sencillo.</target>
        </trans-unit>
        <trans-unit id="fde66fa86f8517d887e54616bf1fb31656fc7f81" translate="yes" xml:space="preserve">
          <source>Motivations</source>
          <target state="translated">Motivations</target>
        </trans-unit>
        <trans-unit id="eaf7a15ddfb6c5c306f486c8bf293512f163a845" translate="yes" xml:space="preserve">
          <source>Movable Keys</source>
          <target state="translated">Llaves móviles</target>
        </trans-unit>
        <trans-unit id="f77b47b8d13d94af9785e089c536b9963ca2c823" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;key&lt;/code&gt; from the currently selected database (see &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;) to the specified destination database. When &lt;code&gt;key&lt;/code&gt; already exists in the destination database, or it does not exist in the source database, it does nothing. It is possible to use &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; as a locking primitive because of this.</source>
          <target state="translated">Mueva la &lt;code&gt;key&lt;/code&gt; de la base de datos actualmente seleccionada (ver &lt;a href=&quot;select&quot;&gt;SELECCIONAR&lt;/a&gt; ) a la base de datos de destino especificada. Cuando la &lt;code&gt;key&lt;/code&gt; ya existe en la base de datos de destino, o no existe en la base de datos de origen, no hace nada. Es posible utilizar &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; como una primitiva de bloqueo debido a esto.</target>
        </trans-unit>
        <trans-unit id="17c083c9f9d68a5d0169cd11d9c0c04115759b24" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;member&lt;/code&gt; from the set at &lt;code&gt;source&lt;/code&gt; to the set at &lt;code&gt;destination&lt;/code&gt;. This operation is atomic. In every given moment the element will appear to be a member of &lt;code&gt;source&lt;/code&gt;&lt;strong&gt;or&lt;/strong&gt;&lt;code&gt;destination&lt;/code&gt; for other clients.</source>
          <target state="translated">Mueva el &lt;code&gt;member&lt;/code&gt; del conjunto en &lt;code&gt;source&lt;/code&gt; al conjunto en &lt;code&gt;destination&lt;/code&gt; . Esta operaci&amp;oacute;n es at&amp;oacute;mica. En cada momento dado, el elemento parecer&amp;aacute; ser un miembro de &lt;code&gt;source&lt;/code&gt; &lt;strong&gt;o &lt;/strong&gt; &lt;code&gt;destination&lt;/code&gt; para otros clientes.</target>
        </trans-unit>
        <trans-unit id="95a91b78dd0ce912aadce361711a043cae9a887e" translate="yes" xml:space="preserve">
          <source>Multiple parallel iterations</source>
          <target state="translated">Múltiples iteraciones paralelas</target>
        </trans-unit>
        <trans-unit id="f492964822aab7cec6aa84fefaffe8fba8b6cd36" translate="yes" xml:space="preserve">
          <source>Nested Result Array</source>
          <target state="translated">Matriz de resultados anidados</target>
        </trans-unit>
        <trans-unit id="fdc70576104b358de95d88f0255666aac631aff0" translate="yes" xml:space="preserve">
          <source>New fields are regularly added for debugging purpose. Some could be removed in the future. A version safe Redis client using this command should parse the output accordingly (i.e. handling gracefully missing fields, skipping unknown fields).</source>
          <target state="translated">Regularmente se añaden nuevos campos para la depuración.Algunos podrían ser eliminados en el futuro.Una versión segura del cliente de Redis que utilice este comando debería analizar la salida en consecuencia (es decir,manejar con gracia los campos que faltan,saltarse los campos desconocidos).</target>
        </trans-unit>
        <trans-unit id="861e51e24f78632f52937df883ebeed5a0766d52" translate="yes" xml:space="preserve">
          <source>New keys are always created in the target node. During a hash slot migration we'll have to move only old keys, not new ones.</source>
          <target state="translated">Siempre se crean nuevas claves en el nodo objetivo.Durante una migración de ranura hash tendremos que mover sólo las claves antiguas,no las nuevas.</target>
        </trans-unit>
        <trans-unit id="97bfa87b383568ddb64d92c09cf59316bbb313bd" translate="yes" xml:space="preserve">
          <source>No repeated elements are returned.</source>
          <target state="translated">No se devuelven elementos repetidos.</target>
        </trans-unit>
        <trans-unit id="75e932f04e490ddd2c64a4420d419573bd058eac" translate="yes" xml:space="preserve">
          <source>Nodes in &lt;code&gt;PFAIL&lt;/code&gt; state are provided in gossip sections of heartbeat packets.</source>
          <target state="translated">Los nodos en estado &lt;code&gt;PFAIL&lt;/code&gt; se proporcionan en las secciones de chismes de los paquetes de latidos.</target>
        </trans-unit>
        <trans-unit id="c02697f1f51c2f137246d46e8911c8e7f53e6636" translate="yes" xml:space="preserve">
          <source>Non existing elements are reported as NULL elements of the array.</source>
          <target state="translated">Los elementos no existentes se reportan como elementos NULL de la matriz.</target>
        </trans-unit>
        <trans-unit id="5dfb2fbf84cf8de01a0c2542d485d2207dc976ae" translate="yes" xml:space="preserve">
          <source>Non used lines are blanked. For instance if you used to have multiple &lt;code&gt;save&lt;/code&gt; directives, but the current configuration has fewer or none as you disabled RDB persistence, all the lines will be blanked.</source>
          <target state="translated">Las l&amp;iacute;neas no utilizadas est&amp;aacute;n en blanco. Por ejemplo, si sol&amp;iacute;a tener varias directivas de &lt;code&gt;save&lt;/code&gt; , pero la configuraci&amp;oacute;n actual tiene menos o ninguna al deshabilitar la persistencia RDB, todas las l&amp;iacute;neas estar&amp;aacute;n en blanco.</target>
        </trans-unit>
        <trans-unit id="de44f50198c0734dcccb5b1c5d4825eb72c13aba" translate="yes" xml:space="preserve">
          <source>Non-blocking behavior</source>
          <target state="translated">Comportamiento sin bloqueo</target>
        </trans-unit>
        <trans-unit id="5cbfa62b0d0a8a33923d06127db99370a393ad0d" translate="yes" xml:space="preserve">
          <source>Non-blocking usage</source>
          <target state="translated">Uso sin bloqueo</target>
        </trans-unit>
        <trans-unit id="bcbbb0c35f64190eb100cd6befa838fbd5037874" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings, so the command will return zero.</source>
          <target state="translated">Las claves inexistentes se tratan como cadenas vacías,por lo que el comando devolverá cero.</target>
        </trans-unit>
        <trans-unit id="46b493cea7b65b3003ea2e423707591849b0ee78" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings.</source>
          <target state="translated">Las claves inexistentes son tratadas como cadenas vacías.</target>
        </trans-unit>
        <trans-unit id="9a60acaa61d5a344489afdd9e5311dbf8888aa00" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; is simply used in order to get range of items where the score is the indexed integer key, however it is possible to do less obvious things with the command.</source>
          <target state="translated">Normalmente, &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; se usa simplemente para obtener un rango de elementos donde el puntaje es la clave entera indexada, sin embargo, es posible hacer cosas menos obvias con el comando.</target>
        </trans-unit>
        <trans-unit id="4dba9f7be4e65fcc1fd8d86533e96e912932e110" translate="yes" xml:space="preserve">
          <source>Normally Redis keys are created without an associated time to live. The key will simply live forever, unless it is removed by the user in an explicit way, for instance using the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; command.</source>
          <target state="translated">Normalmente, las claves de Redis se crean sin un tiempo de vida asociado. La clave simplemente vivir&amp;aacute; para siempre, a menos que el usuario la elimine de manera expl&amp;iacute;cita, por ejemplo, usando el comando &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="488e099ce2d3130dde9348d7a491fea120dffc25" translate="yes" xml:space="preserve">
          <source>Normally Redis represents positions of elements using a variation of the Geohash technique where positions are encoded using 52 bit integers. The encoding is also different compared to the standard because the initial min and max coordinates used during the encoding and decoding process are different. This command however &lt;strong&gt;returns a standard Geohash&lt;/strong&gt; in the form of a string as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia article&lt;/a&gt; and compatible with the &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; web site.</source>
          <target state="translated">Normalmente, Redis representa posiciones de elementos utilizando una variaci&amp;oacute;n de la t&amp;eacute;cnica Geohash donde las posiciones se codifican utilizando n&amp;uacute;meros enteros de 52 bits. La codificaci&amp;oacute;n tambi&amp;eacute;n es diferente en comparaci&amp;oacute;n con el est&amp;aacute;ndar porque las coordenadas iniciales m&amp;iacute;nimas y m&amp;aacute;ximas utilizadas durante el proceso de codificaci&amp;oacute;n y decodificaci&amp;oacute;n son diferentes. Sin embargo, este comando &lt;strong&gt;devuelve un Geohash est&amp;aacute;ndar&lt;/strong&gt; en forma de cadena como se describe en el &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;art&amp;iacute;culo de Wikipedia&lt;/a&gt; y es compatible con el sitio web &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48fbc2c3360b2ccdab702dc73f1af3fdad88932d" translate="yes" xml:space="preserve">
          <source>Normally hash slots associated to a given node are in one of the following formats, as already explained above:</source>
          <target state="translated">Normalmente,las ranuras de hash asociadas a un nodo determinado se encuentran en uno de los siguientes formatos,como ya se ha explicado anteriormente:</target>
        </trans-unit>
        <trans-unit id="20da22f8d3c73a214f41394b1c9a9c08c0230154" translate="yes" xml:space="preserve">
          <source>Normally if there is an AOF child process performing an AOF rewrite, Redis will simply kill it and exit. However there are two conditions where it is unsafe to do so, and the &lt;strong&gt;SHUTDOWN&lt;/strong&gt; command will be refused with an error instead. This happens when:</source>
          <target state="translated">Normalmente, si hay un proceso secundario AOF que realiza una reescritura de AOF, Redis simplemente lo matar&amp;aacute; y saldr&amp;aacute;. Sin embargo, existen dos condiciones en las que no es seguro hacerlo y, en su lugar , se rechazar&amp;aacute; el comando &lt;strong&gt;SHUTDOWN&lt;/strong&gt; con un error. Esto sucede cuando:</target>
        </trans-unit>
        <trans-unit id="f552eaf00c55408f0aa996335bcd91c4da8dcdb7" translate="yes" xml:space="preserve">
          <source>Normally replica nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use replicas in order to scale reads using the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command.</source>
          <target state="translated">Normalmente, los nodos de r&amp;eacute;plica redirigir&amp;aacute;n a los clientes al maestro autorizado para la ranura de hash involucrada en un comando dado, sin embargo, los clientes pueden usar r&amp;eacute;plicas para escalar las lecturas usando el comando &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b040d0fd81d55e920e28d6b8b43687a96fedfb9" translate="yes" xml:space="preserve">
          <source>Normally replicating scripts instead of the effects of the scripts makes sense, however not in all the cases. So starting with Redis 3.2, the scripting engine is able to, alternatively, replicate the sequence of write commands resulting from the script execution, instead of replication the script itself. See the next section for more information. In this section we'll assume that scripts are replicated by sending the whole script. Let's call this replication mode &lt;strong&gt;whole scripts replication&lt;/strong&gt;.</source>
          <target state="translated">Normalmente, la replicaci&amp;oacute;n de scripts en lugar de los efectos de los scripts tiene sentido, pero no en todos los casos. Entonces, a partir de Redis 3.2, el motor de secuencias de comandos puede, alternativamente, replicar la secuencia de comandos de escritura resultante de la ejecuci&amp;oacute;n de la secuencia de comandos, en lugar de replicar la secuencia de comandos en s&amp;iacute;. Mira la siguiente secci&amp;oacute;n para mas informaci&amp;oacute;n. En esta secci&amp;oacute;n asumiremos que los scripts se replican enviando el script completo. Llamemos a este modo de replicaci&amp;oacute;n &lt;strong&gt;replicaci&amp;oacute;n de scripts completos&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="632bc7f3cbfc39c1e051fc94bc2f5127d08b095a" translate="yes" xml:space="preserve">
          <source>Normally the OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2018dd71c22fe4b55fd2f381e3bcbd8ea7b844" translate="yes" xml:space="preserve">
          <source>Normally you may think at a Redis stream as an append-only data structure, however Redis streams are represented in memory, so we are able to also delete entries. This may be useful, for instance, in order to comply with certain privacy policies.</source>
          <target state="translated">Normalmente se puede pensar en una corriente de Redis como una estructura de datos de sólo aplicación,sin embargo las corrientes de Redis están representadas en la memoria,por lo que también podemos borrar las entradas.Esto puede ser útil,por ejemplo,para cumplir con ciertas políticas de privacidad.</target>
        </trans-unit>
        <trans-unit id="675cc42aab3b45855f7e4f48b1a8a2f9ea1abcdc" translate="yes" xml:space="preserve">
          <source>Normally you use the command like that in order to get new messages and process them. In pseudo-code:</source>
          <target state="translated">Normalmente se usa el comando así para obtener nuevos mensajes y procesarlos.En pseudo-código:</target>
        </trans-unit>
        <trans-unit id="92faf092f64b7750013de7ad70293bed4c22e467" translate="yes" xml:space="preserve">
          <source>Note for Lua newbies: in order to avoid using global variables in your scripts simply declare every variable you are going to use using the &lt;em&gt;local&lt;/em&gt; keyword.</source>
          <target state="translated">Nota para los principiantes de Lua: para evitar el uso de variables globales en sus scripts, simplemente declare cada variable que va a usar usando la palabra clave &lt;em&gt;local&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="386ff54d1c33b65d55947a3bc043df349ed6b50a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; all work very similarly, so this documentation covers all the four commands. However an obvious difference is that in the case of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; the first argument is the name of the key holding the Set, Hash or Sorted Set value. The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command does not need any key name argument as it iterates keys in the current database, so the iterated object is the database itself.</source>
          <target state="translated">Tenga en cuenta que &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; , &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; y &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; funcionan de manera muy similar, por lo que esta documentaci&amp;oacute;n cubre los cuatro comandos. Sin embargo, una diferencia obvia es que en el caso de &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; y &lt;a href=&quot;zscan&quot;&gt;ZSCAN,&lt;/a&gt; el primer argumento es el nombre de la clave que contiene el valor Set, Hash o Sorted Set. El comando &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; no necesita ning&amp;uacute;n argumento de nombre de clave, ya que itera claves en la base de datos actual, por lo que el objeto iterado es la base de datos misma.</target>
        </trans-unit>
        <trans-unit id="b8af6b6330cf6687e8cc50e67b81c7d7beffd113" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not make Redis a strongly consistent store: while synchronous replication is part of a replicated state machine, it is not the only thing needed. However in the context of Sentinel or Redis Cluster failover, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; improves the real world data safety.</source>
          <target state="translated">Tenga en cuenta que &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; no convierte a Redis en un almac&amp;eacute;n muy consistente: si bien la replicaci&amp;oacute;n sincr&amp;oacute;nica es parte de una m&amp;aacute;quina de estado replicada, no es lo &amp;uacute;nico que se necesita. Sin embargo, en el contexto de la conmutaci&amp;oacute;n por error de Sentinel o Redis Cluster, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; mejora la seguridad de los datos en el mundo real.</target>
        </trans-unit>
        <trans-unit id="196f50bc6a6ac776d1991175d0001fae97125b81" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; is also available since Redis 3.2.10 and Redis 4.0.0 in order to provide a read-only command that can be used in replicas. See the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; page for more information.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; tambi&amp;eacute;n est&amp;aacute; disponible desde Redis 3.2.10 y Redis 4.0.0 para proporcionar un comando de solo lectura que se puede usar en r&amp;eacute;plicas. Consulte la p&amp;aacute;gina de &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7f4713a8dfe3582f9f0fc3ed836bf0396dfbd617" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;TAKEOVER violates the last-failover-wins principle&lt;/strong&gt; of Redis Cluster, since the configuration epoch generated by the replica violates the normal generation of configuration epochs in several ways:</source>
          <target state="translated">Tenga en cuenta que &lt;strong&gt;TAKEOVER viola el principio&lt;/strong&gt; de &lt;strong&gt;&amp;uacute;ltima conmutaci&amp;oacute;n por error&lt;/strong&gt; de Redis Cluster, ya que la &amp;eacute;poca de configuraci&amp;oacute;n generada por la r&amp;eacute;plica viola la generaci&amp;oacute;n normal de &amp;eacute;pocas de configuraci&amp;oacute;n de varias formas:</target>
        </trans-unit>
        <trans-unit id="b1e5f99b4ded8ce6be23a9f6f9872d3e5595ab46" translate="yes" xml:space="preserve">
          <source>Note that Redis Cluster needs to form a full mesh (each node is connected with each other node), but in order to create a cluster, there is no need to send all the &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; commands needed to form the full mesh. What matter is to send enough &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; messages so that each node can reach each other node through a &lt;em&gt;chain of known nodes&lt;/em&gt;. Thanks to the exchange of gossip information in heartbeat packets, the missing links will be created.</source>
          <target state="translated">Tenga en cuenta que Redis Cluster necesita formar una malla completa (cada nodo est&amp;aacute; conectado entre s&amp;iacute;), pero para crear un cl&amp;uacute;ster, no es necesario enviar todos los comandos &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; necesarios para formar la malla completa. Lo que importa es enviar suficientes mensajes &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; para que cada nodo pueda llegar a los dem&amp;aacute;s a trav&amp;eacute;s de una &lt;em&gt;cadena de nodos conocidos&lt;/em&gt; . Gracias al intercambio de informaci&amp;oacute;n de chismes en paquetes de latidos, se crear&amp;aacute;n los enlaces que faltan.</target>
        </trans-unit>
        <trans-unit id="2d97296cb1d6030b84b67b56dc33de3881c08256" translate="yes" xml:space="preserve">
          <source>Note that a script can switch back and forth from RESP3 and RESP2 by calling the function with the argument '3' or '2'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17fc5decb8a235b9d4881b1185aa05ef897a69aa" translate="yes" xml:space="preserve">
          <source>Note that bit positions are returned always as absolute values starting from bit zero even when &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are used to specify a range.</source>
          <target state="translated">Tenga en cuenta que las posiciones de los bits se devuelven siempre como valores absolutos a partir del bit cero, incluso cuando se utilizan el &lt;em&gt;inicio&lt;/em&gt; y el &lt;em&gt;final&lt;/em&gt; para especificar un rango.</target>
        </trans-unit>
        <trans-unit id="d47127e4277fb6af8f1ec3e041d7aadf84ff3fe6" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;/&lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; with a non-positive timeout or &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;/&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; with a time in the past will result in the key being &lt;a href=&quot;del&quot;&gt;deleted&lt;/a&gt; rather than expired (accordingly, the emitted &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;key event&lt;/a&gt; will be &lt;code&gt;del&lt;/code&gt;, not &lt;code&gt;expired&lt;/code&gt;).</source>
          <target state="translated">Tenga en cuenta que llamar &lt;a href=&quot;expire&quot;&gt;EXPIRA&lt;/a&gt; / &lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; con un tiempo de espera no positiva o &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; / &lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; con un tiempo en el pasado se traducir&amp;aacute; en el ser clave &lt;a href=&quot;del&quot;&gt;elimina&lt;/a&gt; en lugar de expirado (en consecuencia, la emitida &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;evento clave&lt;/a&gt; ser&amp;aacute; &lt;code&gt;del&lt;/code&gt; , no &lt;code&gt;expired&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="134cdffcc8cc8242a1731baa707e6b6f212bd203" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;OVERFLOW&lt;/code&gt; statement only affects the &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; commands that follow it in the list of subcommands, up to the next &lt;code&gt;OVERFLOW&lt;/code&gt; statement.</source>
          <target state="translated">Tenga en cuenta que cada &lt;code&gt;OVERFLOW&lt;/code&gt; declaraci&amp;oacute;n s&amp;oacute;lo afecta a los &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; comandos que le siguen en la lista de subcomandos, hasta la pr&amp;oacute;xima &lt;code&gt;OVERFLOW&lt;/code&gt; comunicado.</target>
        </trans-unit>
        <trans-unit id="c59e6cb007a017cde6a0590f3fe3a6903d02fdbc" translate="yes" xml:space="preserve">
          <source>Note that for correctly implementing this pattern it is important to avoid multiple clients rebuilding the cache at the same time. Some kind of locking is needed here (for instance using &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;).</source>
          <target state="translated">Tenga en cuenta que para implementar correctamente este patr&amp;oacute;n, es importante evitar que varios clientes reconstruyan la cach&amp;eacute; al mismo tiempo. Aqu&amp;iacute; se necesita alg&amp;uacute;n tipo de bloqueo (por ejemplo, usando &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab5932614de576b14cea0fbf3d424f67389687d0" translate="yes" xml:space="preserve">
          <source>Note that for the same reason a Lua script or a &lt;code&gt;MULTI/EXEC&lt;/code&gt; block may push elements into a list and afterward &lt;strong&gt;delete the list&lt;/strong&gt;. In this case the blocked clients will not be served at all and will continue to be blocked as long as no data is present on the list after the execution of a single command, transaction, or script.</source>
          <target state="translated">Tenga en cuenta que, por la misma raz&amp;oacute;n, un script Lua o un bloque &lt;code&gt;MULTI/EXEC&lt;/code&gt; pueden insertar elementos en una lista y luego &lt;strong&gt;eliminar la lista&lt;/strong&gt; . En este caso, los clientes bloqueados no recibir&amp;aacute;n ning&amp;uacute;n servicio y continuar&amp;aacute;n bloqueados mientras no haya datos en la lista despu&amp;eacute;s de la ejecuci&amp;oacute;n de un solo comando, transacci&amp;oacute;n o script.</target>
        </trans-unit>
        <trans-unit id="fcc828a00ba6196c133772751828406df7944657" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">Tenga en cuenta que si se agrega, mueve o elimina una r&amp;eacute;plica de un nodo maestro determinado, y le pedimos &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; a un nodo que a&amp;uacute;n no ha recibido la actualizaci&amp;oacute;n de configuraci&amp;oacute;n, puede mostrar informaci&amp;oacute;n obsoleta. Sin embargo, eventualmente (en cuesti&amp;oacute;n de segundos si no hay particiones de red) todos los nodos estar&amp;aacute;n de acuerdo sobre el conjunto de nodos asociados con un maestro dado.</target>
        </trans-unit>
        <trans-unit id="21094e1f69e7fc1828b555fe35532f052b5ac245" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">Tenga en cuenta que si se agrega, mueve o elimina una r&amp;eacute;plica de un nodo maestro dado, y le pedimos &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; a un nodo que a&amp;uacute;n no ha recibido la actualizaci&amp;oacute;n de configuraci&amp;oacute;n, puede mostrar informaci&amp;oacute;n obsoleta. Sin embargo, eventualmente (en cuesti&amp;oacute;n de segundos si no hay particiones de red) todos los nodos estar&amp;aacute;n de acuerdo sobre el conjunto de nodos asociados con un maestro dado.</target>
        </trans-unit>
        <trans-unit id="92bc3cdf3318fb930ded8c852b6a00267accad1a" translate="yes" xml:space="preserve">
          <source>Note that if you have a list of numbers from 0 to 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; will return 11 elements, that is, the rightmost item is included. This &lt;strong&gt;may or may not&lt;/strong&gt; be consistent with behavior of range-related functions in your programming language of choice (think Ruby's &lt;code&gt;Range.new&lt;/code&gt;, &lt;code&gt;Array#slice&lt;/code&gt; or Python's &lt;code&gt;range()&lt;/code&gt; function).</source>
          <target state="translated">Tenga en cuenta que si tiene una lista de n&amp;uacute;meros del 0 al 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; devolver&amp;aacute; 11 elementos, es decir, se incluye el elemento situado m&amp;aacute;s a la derecha. Esto &lt;strong&gt;puede o no&lt;/strong&gt; ser consistente con el comportamiento de las funciones relacionadas con el rango en su lenguaje de programaci&amp;oacute;n de elecci&amp;oacute;n (piense en la funci&amp;oacute;n &lt;code&gt;Range.new&lt;/code&gt; de Ruby , &lt;code&gt;Array#slice&lt;/code&gt; o &lt;code&gt;range()&lt;/code&gt; Python ).</target>
        </trans-unit>
        <trans-unit id="b145f3c9b171e7c40ecd23d7161660cea0ebde1c" translate="yes" xml:space="preserve">
          <source>Note that it is valid to call this command without channels. In this case it will just return an empty list.</source>
          <target state="translated">Tenga en cuenta que es válido para llamar a este comando sin canales.En este caso sólo devolverá una lista vacía.</target>
        </trans-unit>
        <trans-unit id="7cbc0087feeeb4b8394154849c8ec33aeb518c13" translate="yes" xml:space="preserve">
          <source>Note that non-existing keys are treated like empty lists, so when &lt;code&gt;key&lt;/code&gt; does not exist, the command will always return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que las claves que no existen se tratan como listas vac&amp;iacute;as, por lo que cuando la &lt;code&gt;key&lt;/code&gt; no existe, el comando siempre devolver&amp;aacute; &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e83de8fca6610aa183e7aad22115791cd55bc9fb" translate="yes" xml:space="preserve">
          <source>Note that normally clients willing to fetch the map between Cluster hash slots and node addresses should use &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; instead. &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;, that provides more information, should be used for administrative tasks, debugging, and configuration inspections. It is also used by &lt;code&gt;redis-trib&lt;/code&gt; in order to manage a cluster.</source>
          <target state="translated">Tenga en cuenta que, normalmente, los clientes que deseen obtener el mapa entre las ranuras de hash del cl&amp;uacute;ster y las direcciones de nodo deben utilizar &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; . &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; , que proporciona m&amp;aacute;s informaci&amp;oacute;n, debe usarse para tareas administrativas, depuraci&amp;oacute;n e inspecciones de configuraci&amp;oacute;n. Tambi&amp;eacute;n lo utiliza &lt;code&gt;redis-trib&lt;/code&gt; para gestionar un cl&amp;uacute;ster.</target>
        </trans-unit>
        <trans-unit id="1f6b2fdffdf326f5f641aa170f10beb1a26d5924" translate="yes" xml:space="preserve">
          <source>Note that once a node assigns a set of slots to itself, it will start propagating this information in heartbeat packet headers. However the other nodes will accept the information only if they have the slot as not already bound with another node, or if the configuration epoch of the node advertising the new hash slot, is greater than the node currently listed in the table.</source>
          <target state="translated">Tenga en cuenta que una vez que un nodo se asigna un conjunto de ranuras a sí mismo,comenzará a propagar esta información en los encabezados de los paquetes de latidos.Sin embargo,los demás nodos aceptarán la información sólo si tienen la ranura como no ya unida a otro nodo,o si la época de configuración del nodo que anuncia la nueva ranura de hash,es mayor que el nodo que figura actualmente en la tabla.</target>
        </trans-unit>
        <trans-unit id="34efcb15ecc544550f9bd4f238eeb1c37bfe6eb5" translate="yes" xml:space="preserve">
          <source>Note that the command implements the full hashing algorithm, including support for &lt;strong&gt;hash tags&lt;/strong&gt;, that is the special property of Redis Cluster key hashing algorithm, of hashing just what is between &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; if such a pattern is found inside the key name, in order to force multiple keys to be handled by the same node.</source>
          <target state="translated">Tenga en cuenta que el comando implementa el algoritmo de hash completo, incluida la compatibilidad con &lt;strong&gt;etiquetas hash&lt;/strong&gt; , que es la propiedad especial del algoritmo de hash de clave de Redis Cluster, de hash solo lo que est&amp;aacute; entre &lt;code&gt;{&lt;/code&gt; y &lt;code&gt;}&lt;/code&gt; si dicho patr&amp;oacute;n se encuentra dentro del nombre de la clave, en orden para forzar que varias claves sean manejadas por el mismo nodo.</target>
        </trans-unit>
        <trans-unit id="44319adff6c7cf60df65ef2f592ee1b07d9db575" translate="yes" xml:space="preserve">
          <source>Note that the format does not have any space, so &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output format is plain CSV with space as separator even when this special slots are emitted. However a complete parser for the format should be able to handle them.</source>
          <target state="translated">Tenga en cuenta que el formato no tiene ning&amp;uacute;n espacio, por lo que el formato de salida de &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; es CSV simple con espacio como separador incluso cuando se emiten estas ranuras especiales. Sin embargo, un analizador completo del formato deber&amp;iacute;a poder manejarlos.</target>
        </trans-unit>
        <trans-unit id="277c523b6a84e71c0289aa21eae881f107096f52" translate="yes" xml:space="preserve">
          <source>Note that the indexes are still reported in the &quot;natural&quot; way, that is, considering the first element starting from the head of the list at index 0, the next element at index 1, and so forth. This basically means that the returned indexes are stable whatever the rank is positive or negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf3d39f27c1b799248d5e59a73b1a5b0f086afd" translate="yes" xml:space="preserve">
          <source>Note that the maximum offset that you can set is 2&lt;sup&gt;29&lt;/sup&gt; -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.</source>
          <target state="translated">Tenga en cuenta que el desplazamiento m&amp;aacute;ximo que se puede establecer es de 2 &lt;sup&gt;29&lt;/sup&gt; -1 (536870911), como Redis Las cadenas se limita a 512 megabytes. Si necesita crecer m&amp;aacute;s all&amp;aacute; de este tama&amp;ntilde;o, puede utilizar varias claves.</target>
        </trans-unit>
        <trans-unit id="365b9132d09f3318597589e9536ca42a38461cb4" translate="yes" xml:space="preserve">
          <source>Note that the message is claimed only if its idle time is greater the minimum idle time we specify when calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. Because as a side effect &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will also reset the idle time (since this is a new attempt at processing the message), two consumers trying to claim a message at the same time will never both succeed: only one will successfully claim the message. This avoids that we process a given message multiple times in a trivial way (yet multiple processing is possible and unavoidable in the general case).</source>
          <target state="translated">Tenga en cuenta que el mensaje se reclama solo si su tiempo de inactividad es mayor que el tiempo de inactividad m&amp;iacute;nimo que especificamos al llamar a &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; . Debido a que, como efecto secundario, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; tambi&amp;eacute;n restablecer&amp;aacute; el tiempo de inactividad (ya que este es un nuevo intento de procesar el mensaje), dos consumidores que intenten reclamar un mensaje al mismo tiempo nunca tendr&amp;aacute;n &amp;eacute;xito: solo uno reclamar&amp;aacute; el mensaje con &amp;eacute;xito. Esto evita que procesemos un mensaje determinado varias veces de una manera trivial (sin embargo, el procesamiento m&amp;uacute;ltiple es posible e inevitable en el caso general).</target>
        </trans-unit>
        <trans-unit id="dbbe3c8e1b4fe3c7e220f023943635e1ebf82c17" translate="yes" xml:space="preserve">
          <source>Note that this algorithm runs in &lt;code&gt;O(N*M)&lt;/code&gt; time, where N is the length of the first string and M is the length of the second string. So either spin a different Redis instance in order to run this algorithm, or make sure to run it against very small strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900544e94991ba5defea5df80a0dccc1aa474e00" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581b6da11286a19b84f5dbf7d26c9c4e1e18433c" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for SPOP, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">Tenga en cuenta que este comando no es adecuado cuando se necesita una distribución uniforme garantizada de los elementos devueltos.Para más información sobre los algoritmos usados para SPOP,busque los algoritmos de muestreo Knuth y Floyd.</target>
        </trans-unit>
        <trans-unit id="7aae41763fe9b0bc6731024cb063283c77ec4608" translate="yes" xml:space="preserve">
          <source>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</source>
          <target state="translated">Tenga en cuenta que esta implementación de los trabajadores es trivialmente escalable y fiable,porque incluso si se pierde un mensaje el artículo sigue en la cola y se procesará en la siguiente iteración.</target>
        </trans-unit>
        <trans-unit id="de6800f82ca82bf510c822b7935a67d6ca2bf21c" translate="yes" xml:space="preserve">
          <source>Note that we have a race here, but it is not a problem: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; may return false but the key may be created by another client before we create it inside the &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. However this race will just miss an API call under rare conditions, so the rate limiting will still work correctly.</source>
          <target state="translated">Tenga en cuenta que tenemos una carrera aqu&amp;iacute;, pero no es un problema: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; puede devolver falso, pero la clave puede ser creada por otro cliente antes de que la creemos dentro del bloque &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; . Sin embargo, esta carrera simplemente perder&amp;aacute; una llamada a la API en raras condiciones, por lo que la limitaci&amp;oacute;n de velocidad seguir&amp;aacute; funcionando correctamente.</target>
        </trans-unit>
        <trans-unit id="290162572eb7adbad822a4117dca945c127babde" translate="yes" xml:space="preserve">
          <source>Note that you need a recent version of redis-cli in order to read the slow log output, since it uses some features of the protocol that were not formerly implemented in redis-cli (deeply nested multi bulk replies).</source>
          <target state="translated">Obsérvese que se necesita una versión reciente de redis-cli para poder leer la salida del registro lento,ya que utiliza algunas características del protocolo que no se habían implementado anteriormente en redis-cli (respuestas multi-bulto profundamente anidadas).</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">Fíjese en eso:</target>
        </trans-unit>
        <trans-unit id="851be398fabf2219f9c3aa64609a72f0559cc785" translate="yes" xml:space="preserve">
          <source>Note the used of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; in order to make sure that we'll both increment and set the expire at every API call.</source>
          <target state="translated">Tenga en cuenta el uso de &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; y &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; para asegurarnos de que incrementaremos y estableceremos el vencimiento en cada llamada a la API.</target>
        </trans-unit>
        <trans-unit id="0ab5850865b49bbe39f155ec6e364488933508f0" translate="yes" xml:space="preserve">
          <source>Note this rule is not enforced in order to provide the user with opportunities to abuse the Redis single instance configuration, at the cost of writing scripts not compatible with Redis Cluster.</source>
          <target state="translated">Tenga en cuenta que esta regla no se aplica para dar al usuario la oportunidad de abusar de la configuración de instancia única de Redis,a costa de escribir scripts no compatibles con Redis Cluster.</target>
        </trans-unit>
        <trans-unit id="9dfbcfbbaf119bccc3c44b098de0573996677b97" translate="yes" xml:space="preserve">
          <source>Note: A Redis instance that is configured for not persisting on disk (no AOF configured, nor &quot;save&quot; directive) will not dump the RDB file on &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;, as usually you don't want Redis instances used only for caching to block on when shutting down.</source>
          <target state="translated">Nota: Una instancia de Redis que est&amp;aacute; configurada para no persistir en el disco (sin AOF configurada, ni directiva de &quot;guardar&quot;) no volcar&amp;aacute; el archivo RDB en &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt; , ya que generalmente no desea que las instancias de Redis se usen solo para el almacenamiento en cach&amp;eacute; para bloquear cuando Apagando.</target>
        </trans-unit>
        <trans-unit id="4ffe4a3dcb4982dba6203770d54b7b49b3ebdb4a" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e3fa9c72775db4fd05d5cf7a3a493e93afca05" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">Nota: Dado que las opciones del comando &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; pueden reemplazar a &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; , &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; , &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt; , es posible que en futuras versiones de Redis estos tres comandos est&amp;eacute;n obsoletos y finalmente eliminados.</target>
        </trans-unit>
        <trans-unit id="81129f6603906deb00ee7e872ec230ada40b4ee1" translate="yes" xml:space="preserve">
          <source>Note: The &lt;strong&gt;GT&lt;/strong&gt;, &lt;strong&gt;LT&lt;/strong&gt; and &lt;strong&gt;NX&lt;/strong&gt; options are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
