<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="lua">
    <body>
      <group id="lua">
        <trans-unit id="962252ddf2da6f341f061e8a04594ebb79b0e228" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;L&lt;/code&gt;&quot;:  reads the next line keeping the end-of-line character (if present), returning &lt;b&gt;fail&lt;/b&gt; on end of file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ee1dce4e7f426747bd89aef5bd47aa20d38aad" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;L&lt;/code&gt;&quot;:  reads the next line keeping the end-of-line character (if present), returning &lt;b&gt;nil&lt;/b&gt; on end of file.</source>
          <target state="translated">&quot; &lt;code&gt;L&lt;/code&gt; &quot;: lee la l&amp;iacute;nea siguiente manteniendo el car&amp;aacute;cter de final de l&amp;iacute;nea (si est&amp;aacute; presente), devolviendo &lt;b&gt;nulo&lt;/b&gt; al final del archivo.</target>
        </trans-unit>
        <trans-unit id="e0c82711681d3851f13f59346546cd0a034bb77a" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a+&lt;/code&gt;&quot;:  append update mode, previous data is preserved, writing is only allowed at the end of file.</source>
          <target state="translated">&quot; &lt;code&gt;a+&lt;/code&gt; &quot;: a&amp;ntilde;adir modo de actualizaci&amp;oacute;n, se conservan los datos anteriores, solo se permite escribir al final del archivo.</target>
        </trans-unit>
        <trans-unit id="68f6a1b79e4ab4f973b74b712a8ec0055442f0ec" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a&lt;/code&gt;&quot;:  append mode;</source>
          <target state="translated">&quot; &lt;code&gt;a&lt;/code&gt; &quot;: modo de adici&amp;oacute;n;</target>
        </trans-unit>
        <trans-unit id="da2c3d0b3051b286b1d0b50590784dedf845e53c" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a&lt;/code&gt;&quot;:  reads the whole file, starting at the current position. On end of file, it returns the empty string.</source>
          <target state="translated">&quot; &lt;code&gt;a&lt;/code&gt; &quot;: lee el archivo completo, comenzando en la posici&amp;oacute;n actual. Al final del archivo, devuelve la cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="afa896669590f5a6fa8647e9bdc254423566d75e" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a&lt;/code&gt;&quot;:  reads the whole file, starting at the current position. On end of file, it returns the empty string; this format never fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e057ca0bba66f85f9ffafede8baeccd9363b90a0" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;collect&lt;/code&gt;&quot;:  Performs a full garbage-collection cycle. This is the default option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa0969179f03d1f39ed55770cfc19ab243badc2" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;collect&lt;/code&gt;&quot;:  performs a full garbage-collection cycle. This is the default option.</source>
          <target state="translated">&quot; &lt;code&gt;collect&lt;/code&gt; &quot;: realiza un ciclo completo de recolecci&amp;oacute;n de basura. Esta es la opci&amp;oacute;n por defecto.</target>
        </trans-unit>
        <trans-unit id="be11cc3d76417207ed08705e3fec7858f2adec01" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;count&lt;/code&gt;&quot;:  Returns the total memory in use by Lua in Kbytes. The value has a fractional part, so that it multiplied by 1024 gives the exact number of bytes in use by Lua.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2df6eb922319bf606a86a89e2fc83230795af9" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;count&lt;/code&gt;&quot;:  returns the total memory in use by Lua in Kbytes. The value has a fractional part, so that it multiplied by 1024 gives the exact number of bytes in use by Lua (except for overflows).</source>
          <target state="translated">&quot; &lt;code&gt;count&lt;/code&gt; &quot;: devuelve la memoria total en uso por Lua en Kbytes. El valor tiene una parte fraccionaria, por lo que multiplicado por 1024 da el n&amp;uacute;mero exacto de bytes que utiliza Lua (excepto para los desbordamientos).</target>
        </trans-unit>
        <trans-unit id="ef21751d9473020b9e5da0603526fbc16553da86" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;cur&lt;/code&gt;&quot;:  base is current position;</source>
          <target state="translated">&quot; &lt;code&gt;cur&lt;/code&gt; &quot;: la base es la posici&amp;oacute;n actual;</target>
        </trans-unit>
        <trans-unit id="45f4427c05fe67a6aadc962320833307f03356f2" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;end&lt;/code&gt;&quot;:  base is end of file;</source>
          <target state="translated">&quot; &lt;code&gt;end&lt;/code&gt; &quot;: la base es el final del archivo;</target>
        </trans-unit>
        <trans-unit id="b6883b7ef8179370d3a9ce57af44e1806db3b5d3" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;exit&lt;/code&gt;&quot;:  the command terminated normally; the following number is the exit status of the command.</source>
          <target state="translated">&quot; &lt;code&gt;exit&lt;/code&gt; &quot;: el comando termin&amp;oacute; normalmente; el siguiente n&amp;uacute;mero es el estado de salida del comando.</target>
        </trans-unit>
        <trans-unit id="2f1aeda330bb1f1509a0be53bac132c6ce713fe2" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;full&lt;/code&gt;&quot;:  full buffering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86582b43c224b125fce8af4c1bd39d83c959584" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;full&lt;/code&gt;&quot;:  full buffering; output operation is performed only when the buffer is full or when you explicitly &lt;code&gt;flush&lt;/code&gt; the file (see &lt;a href=&quot;#pdf-io.flush&quot;&gt;&lt;code&gt;io.flush&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&quot; &lt;code&gt;full&lt;/code&gt; &quot;: almacenamiento en b&amp;uacute;fer completo; operaci&amp;oacute;n de salida se realiza s&amp;oacute;lo cuando el b&amp;uacute;fer est&amp;aacute; lleno o cuando expresamente &lt;code&gt;flush&lt;/code&gt; el archivo (ver &lt;a href=&quot;#pdf-io.flush&quot;&gt; &lt;code&gt;io.flush&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9dcb26eb8ae721950ef23e61c194fec0b65ee51e" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;generational&lt;/code&gt;&quot;:  Change the collector mode to generational. This option can be followed by two numbers: the garbage-collector minor multiplier and the major multiplier (see &lt;a href=&quot;#2.5.2&quot;&gt;&amp;sect;2.5.2&lt;/a&gt;). A zero means to not change that value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0312cfc47027ea4cfae9f3ba8f855264d8be0b" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;incremental&lt;/code&gt;&quot;:  Change the collector mode to incremental. This option can be followed by three numbers: the garbage-collector pause, the step multiplier, and the step size (see &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt;). A zero means to not change that value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49828278a7296be12d3b4c9fa911cd509b08185" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;isrunning&lt;/code&gt;&quot;:  Returns a boolean that tells whether the collector is running (i.e., not stopped).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b36390a21d74199c7097e386abdc8966f9f3141" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;isrunning&lt;/code&gt;&quot;:  returns a boolean that tells whether the collector is running (i.e., not stopped).</source>
          <target state="translated">&quot; &lt;code&gt;isrunning&lt;/code&gt; &quot;: devuelve un booleano que indica si el recopilador est&amp;aacute; en ejecuci&amp;oacute;n (es decir, no detenido).</target>
        </trans-unit>
        <trans-unit id="fba0cc8d18a812c71b4d8efd3450dc54e903de11" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;l&lt;/code&gt;&quot;:  reads the next line skipping the end of line, returning &lt;b&gt;fail&lt;/b&gt; on end of file. This is the default format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35126f6ad470130461b610dc64352ebf2d5ba8ac" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;l&lt;/code&gt;&quot;:  reads the next line skipping the end of line, returning &lt;b&gt;nil&lt;/b&gt; on end of file. This is the default format.</source>
          <target state="translated">&quot; &lt;code&gt;l&lt;/code&gt; &quot;: lee la siguiente l&amp;iacute;nea saltando el final de la l&amp;iacute;nea, devolviendo &lt;b&gt;nulo&lt;/b&gt; al final del archivo. Este es el formato por defecto.</target>
        </trans-unit>
        <trans-unit id="adbd07304874d87caf7dacbe33921a0377b7f1f2" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;line&lt;/code&gt;&quot;:  line buffering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf7bc41709a6ccf5aa6eae67b8f346e5001d8b6" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;line&lt;/code&gt;&quot;:  line buffering; output is buffered until a newline is output or there is any input from some special files (such as a terminal device).</source>
          <target state="translated">&quot; &lt;code&gt;line&lt;/code&gt; &quot;: b&amp;uacute;fer de l&amp;iacute;nea; la salida se almacena en b&amp;uacute;fer hasta que se produce una nueva l&amp;iacute;nea o hay alguna entrada de algunos archivos especiales (como un dispositivo terminal).</target>
        </trans-unit>
        <trans-unit id="e4a59afc3c3aee61c303a6c6f2b2a762d2ad3d81" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;n&lt;/code&gt;&quot;:  reads a numeral and returns it as a float or an integer, following the lexical conventions of Lua. (The numeral may have leading spaces and a sign.) This format always reads the longest input sequence that is a valid prefix for a numeral; if that prefix does not form a valid numeral (e.g., an empty string, &quot;&lt;code&gt;0x&lt;/code&gt;&quot;, or &quot;&lt;code&gt;3.4e-&lt;/code&gt;&quot;), it is discarded and the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;n&lt;/code&gt; &quot;: lee un numeral y lo devuelve como un float o un entero, siguiendo las convenciones l&amp;eacute;xicas de Lua. (El n&amp;uacute;mero puede tener espacios iniciales y un signo). Este formato siempre lee la secuencia de entrada m&amp;aacute;s larga que es un prefijo v&amp;aacute;lido para un n&amp;uacute;mero; si ese prefijo no forma un n&amp;uacute;mero v&amp;aacute;lido (por ejemplo, una cadena vac&amp;iacute;a, &quot; &lt;code&gt;0x&lt;/code&gt; &quot; o &quot; &lt;code&gt;3.4e-&lt;/code&gt; &quot;), se descarta y la funci&amp;oacute;n devuelve &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="480c73a0e8b85d3021bbb23368c9f75c21639058" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;n&lt;/code&gt;&quot;:  reads a numeral and returns it as a float or an integer, following the lexical conventions of Lua. (The numeral may have leading whitespaces and a sign.) This format always reads the longest input sequence that is a valid prefix for a numeral; if that prefix does not form a valid numeral (e.g., an empty string, &quot;&lt;code&gt;0x&lt;/code&gt;&quot;, or &quot;&lt;code&gt;3.4e-&lt;/code&gt;&quot;) or it is too long (more than 200 characters), it is discarded and the format returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64536f065dc9a0f02fa4493ade76a3fe03ebe56" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;no&lt;/code&gt;&quot;:  no buffering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4495ab81e55566441b9ba9cd4267c1f76a8e00" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;no&lt;/code&gt;&quot;:  no buffering; the result of any output operation appears immediately.</source>
          <target state="translated">&quot; &lt;code&gt;no&lt;/code&gt; &quot;: sin almacenamiento en b&amp;uacute;fer; el resultado de cualquier operaci&amp;oacute;n de salida aparece inmediatamente.</target>
        </trans-unit>
        <trans-unit id="6aff03076b0cbaa7624920aed996ee3d088508ee" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;r+&lt;/code&gt;&quot;:  update mode, all previous data is preserved;</source>
          <target state="translated">&quot; &lt;code&gt;r+&lt;/code&gt; &quot;: modo de actualizaci&amp;oacute;n, se conservan todos los datos anteriores;</target>
        </trans-unit>
        <trans-unit id="482f32bfc1639381f140a1f788e0fb798f9e8562" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;r&lt;/code&gt;&quot;:  read mode (the default);</source>
          <target state="translated">&quot; &lt;code&gt;r&lt;/code&gt; &quot;: modo de lectura (predeterminado);</target>
        </trans-unit>
        <trans-unit id="c5193d068fb02b2d565b221ff67347bc03380489" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;restart&lt;/code&gt;&quot;:  Restarts automatic execution of the garbage collector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0ba614002bce35b460ade5c8343fbd966c8766" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;restart&lt;/code&gt;&quot;:  restarts automatic execution of the garbage collector.</source>
          <target state="translated">&quot; &lt;code&gt;restart&lt;/code&gt; &quot;: reinicia la ejecuci&amp;oacute;n autom&amp;aacute;tica del recolector de basura.</target>
        </trans-unit>
        <trans-unit id="da9e4c23feee0a79d4abaaf5c61375cea61ef16e" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;set&lt;/code&gt;&quot;:  base is position 0 (beginning of the file);</source>
          <target state="translated">&quot; &lt;code&gt;set&lt;/code&gt; &quot;: la base es la posici&amp;oacute;n 0 (comienzo del archivo);</target>
        </trans-unit>
        <trans-unit id="3ec56036cdf5df6fcc52e9cfbd8e2a8921f7aeb1" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;setpause&lt;/code&gt;&quot;:  sets &lt;code&gt;arg&lt;/code&gt; as the new value for the &lt;em&gt;pause&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;). Returns the previous value for &lt;em&gt;pause&lt;/em&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;setpause&lt;/code&gt; &quot;: establece &lt;code&gt;arg&lt;/code&gt; como el nuevo valor para la &lt;em&gt;pausa&lt;/em&gt; del colector (ver &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ). Devuelve el valor anterior para la &lt;em&gt;pausa&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d1dc91f2ee994f6c3a3be7368d48037cc9c1b59c" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;setstepmul&lt;/code&gt;&quot;:  sets &lt;code&gt;arg&lt;/code&gt; as the new value for the &lt;em&gt;step multiplier&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;). Returns the previous value for &lt;em&gt;step&lt;/em&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;setstepmul&lt;/code&gt; &quot;: establece &lt;code&gt;arg&lt;/code&gt; como el nuevo valor para el &lt;em&gt;multiplicador&lt;/em&gt; de &lt;em&gt;pasos&lt;/em&gt; del colector (ver &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ). Devuelve el valor anterior del &lt;em&gt;paso&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c115c4696628bd2659c03d76315d495492249e40" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;signal&lt;/code&gt;&quot;:  the command was terminated by a signal; the following number is the signal that terminated the command.</source>
          <target state="translated">&quot; &lt;code&gt;signal&lt;/code&gt; &quot;: el comando termin&amp;oacute; con una se&amp;ntilde;al; el siguiente n&amp;uacute;mero es la se&amp;ntilde;al que termin&amp;oacute; el comando.</target>
        </trans-unit>
        <trans-unit id="a35dc9f04c419056daea27ec0748582a0c9f6379" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;step&lt;/code&gt;&quot;:  Performs a garbage-collection step. The step &quot;size&quot; is controlled by &lt;code&gt;arg&lt;/code&gt;. With a zero value, the collector will perform one basic (indivisible) step. For non-zero values, the collector will perform as if that amount of memory (in Kbytes) had been allocated by Lua. Returns &lt;b&gt;true&lt;/b&gt; if the step finished a collection cycle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28a219da2e678f08b09e43596cbee1a80cf4c50" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;step&lt;/code&gt;&quot;:  performs a garbage-collection step. The step &quot;size&quot; is controlled by &lt;code&gt;arg&lt;/code&gt;. With a zero value, the collector will perform one basic (indivisible) step. For non-zero values, the collector will perform as if that amount of memory (in KBytes) had been allocated by Lua. Returns &lt;b&gt;true&lt;/b&gt; if the step finished a collection cycle.</source>
          <target state="translated">&quot; &lt;code&gt;step&lt;/code&gt; &quot;: realiza un paso de recolecci&amp;oacute;n de basura. El &quot;tama&amp;ntilde;o&quot; del paso est&amp;aacute; controlado por &lt;code&gt;arg&lt;/code&gt; . Con valor cero, el recolector realizar&amp;aacute; un paso b&amp;aacute;sico (indivisible). Para valores distintos de cero, el recopilador funcionar&amp;aacute; como si Lua hubiera asignado esa cantidad de memoria (en KBytes). Devuelve &lt;b&gt;verdadero&lt;/b&gt; si el paso finaliz&amp;oacute; un ciclo de recolecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="75ecb2938319892eec67595c46d5dcd1f322568e" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;stop&lt;/code&gt;&quot;:  Stops automatic execution of the garbage collector. The collector will run only when explicitly invoked, until a call to restart it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ae23d840374f0e5fdda6d2e1995e17e2530e29" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;stop&lt;/code&gt;&quot;:  stops automatic execution of the garbage collector. The collector will run only when explicitly invoked, until a call to restart it.</source>
          <target state="translated">&quot; &lt;code&gt;stop&lt;/code&gt; &quot;: detiene la ejecuci&amp;oacute;n autom&amp;aacute;tica del recolector de basura. El recopilador se ejecutar&amp;aacute; solo cuando se invoca expl&amp;iacute;citamente, hasta que se llame para reiniciarlo.</target>
        </trans-unit>
        <trans-unit id="630c88288eece276817c37c452c13aad30aeeac6" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;w+&lt;/code&gt;&quot;:  update mode, all previous data is erased;</source>
          <target state="translated">&quot; &lt;code&gt;w+&lt;/code&gt; &quot;: modo de actualizaci&amp;oacute;n, se borran todos los datos anteriores;</target>
        </trans-unit>
        <trans-unit id="4c032e7180fccc925387c5e5d8ef02f876f66a43" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;w&lt;/code&gt;&quot;:  write mode;</source>
          <target state="translated">&quot; &lt;code&gt;w&lt;/code&gt; &quot;: modo de escritura;</target>
        </trans-unit>
        <trans-unit id="f33634dd2aed7619f53f32286917ce87f67cf9f3" translate="yes" xml:space="preserve">
          <source>&amp;copy; 1994&amp;ndash;2017 Lua.org, PUC-Rio.</source>
          <target state="translated">&amp;copy; 1994&amp;ndash;2017 Lua.org, PUC-Rio.</target>
        </trans-unit>
        <trans-unit id="d144761db2915b51c7b3617d755d730533ec0cbe" translate="yes" xml:space="preserve">
          <source>&amp;copy; 1994&amp;ndash;2020 Lua.org, PUC-Rio.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726a699c479b955107f38c46bbe964c5bb86c9c1" translate="yes" xml:space="preserve">
          <source>'': (empty space) ignored</source>
          <target state="translated">'': (espacio vac&amp;iacute;o) ignorado</target>
        </trans-unit>
        <trans-unit id="56889bd563c8faf4c3a42e886a563582cffec219" translate="yes" xml:space="preserve">
          <source>'': (space) ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90841632f7dd28deac05f9104f8757d4d938ddf" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;L&lt;/code&gt;':  pushes onto the stack a table whose indices are the numbers of the lines that are valid on the function. (A &lt;em&gt;valid line&lt;/em&gt; is a line with some associated code, that is, a line where you can put a break point. Non-valid lines include empty lines and comments.)</source>
          <target state="translated">' &lt;code&gt;L&lt;/code&gt; ': coloca en la pila una tabla cuyos &amp;iacute;ndices son los n&amp;uacute;meros de las l&amp;iacute;neas v&amp;aacute;lidas en la funci&amp;oacute;n. (Una &lt;em&gt;l&amp;iacute;nea v&amp;aacute;lida&lt;/em&gt; es una l&amp;iacute;nea con alg&amp;uacute;n c&amp;oacute;digo asociado, es decir, una l&amp;iacute;nea en la que puede colocar un punto de interrupci&amp;oacute;n. Las l&amp;iacute;neas no v&amp;aacute;lidas incluyen l&amp;iacute;neas vac&amp;iacute;as y comentarios).</target>
        </trans-unit>
        <trans-unit id="16fe771c19d862613ab04d78a26fbb806a4f2023" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;S&lt;/code&gt;':  fills in the fields &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;short_src&lt;/code&gt;, &lt;code&gt;linedefined&lt;/code&gt;, &lt;code&gt;lastlinedefined&lt;/code&gt;, and &lt;code&gt;what&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;S&lt;/code&gt; ': completa los campos &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;short_src&lt;/code&gt; , &lt;code&gt;linedefined&lt;/code&gt; , &lt;code&gt;lastlinedefined&lt;/code&gt; y &lt;code&gt;what&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="11a8d7eb3de20bf4074efa8302fa3ebc068c92db" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;c&lt;/code&gt;':  the hook is called every time Lua calls a function;</source>
          <target state="translated">' &lt;code&gt;c&lt;/code&gt; ': el gancho se llama cada vez que Lua llama a una funci&amp;oacute;n;</target>
        </trans-unit>
        <trans-unit id="5dcde03cc29cac4fbee975fd5c6324c0eb2f762a" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;f&lt;/code&gt;':  pushes onto the stack the function that is running at the given level;</source>
          <target state="translated">' &lt;code&gt;f&lt;/code&gt; ': coloca en la pila la funci&amp;oacute;n que se est&amp;aacute; ejecutando en el nivel dado;</target>
        </trans-unit>
        <trans-unit id="d52c4536e0d633bd2dc95275436338ca66e5b0e0" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;l&lt;/code&gt;':  fills in the field &lt;code&gt;currentline&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;l&lt;/code&gt; ': completa el campo &lt;code&gt;currentline&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="06eefa71811d3d77eadfb569caf992bf00533260" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;l&lt;/code&gt;':  the hook is called every time Lua enters a new line of code.</source>
          <target state="translated">' &lt;code&gt;l&lt;/code&gt; ': el gancho se llama cada vez que Lua ingresa una nueva l&amp;iacute;nea de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="19b3d6db914e545df7410bf6ead714c645f9d90c" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;n&lt;/code&gt;':  fills in the field &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;namewhat&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;n&lt;/code&gt; ': completa el &lt;code&gt;name&lt;/code&gt; del campo y &lt;code&gt;namewhat&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0af9c5fa72fd0ae40f86d69a634de5abaff185ba" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;r&lt;/code&gt;':  the hook is called every time Lua returns from a function;</source>
          <target state="translated">' &lt;code&gt;r&lt;/code&gt; ': el gancho se llama cada vez que Lua regresa de una funci&amp;oacute;n;</target>
        </trans-unit>
        <trans-unit id="5aab32dc44a04b46cf39fd9dca7828f4e75632c3" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;t&lt;/code&gt;':  fills in the field &lt;code&gt;istailcall&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;t&lt;/code&gt; ': completa el campo &lt;code&gt;istailcall&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="2995d9a5b2edfc5c4090bb5aeac40be286f51c1c" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;u&lt;/code&gt;':  fills in the fields &lt;code&gt;nups&lt;/code&gt;, &lt;code&gt;nparams&lt;/code&gt;, and &lt;code&gt;isvararg&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;u&lt;/code&gt; ': completa los campos &lt;code&gt;nups&lt;/code&gt; , &lt;code&gt;nparams&lt;/code&gt; e &lt;code&gt;isvararg&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3ba9ac7e76f439728000e96df248ad5393e0be09" translate="yes" xml:space="preserve">
          <source>(A &quot;&lt;code&gt;[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;&quot; means an optional integral numeral.) Except for padding, spaces, and configurations (options &quot;&lt;code&gt;xX &amp;lt;=&amp;gt;!&lt;/code&gt;&quot;), each option corresponds to an argument (in &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;) or a result (in &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">(Un &quot; &lt;code&gt;[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; &quot; significa un n&amp;uacute;mero integral opcional.) Excepto por el relleno, los espacios y las configuraciones (opciones &quot; &lt;code&gt;xX &amp;lt;=&amp;gt;!&lt;/code&gt; &quot;), Cada opci&amp;oacute;n corresponde a un argumento (en &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; ) o un resultado (en &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="93c9ef50a3ebe3dd10bce375075c3a8ce7976bbf" translate="yes" xml:space="preserve">
          <source>(A &quot;&lt;code&gt;[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;&quot; means an optional integral numeral.) Except for padding, spaces, and configurations (options &quot;&lt;code&gt;xX &amp;lt;=&amp;gt;!&lt;/code&gt;&quot;), each option corresponds to an argument in &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; or a result in &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77a9f254e99c74357020a933128fef2049e3240" translate="yes" xml:space="preserve">
          <source>(For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47739e8fdeffa5f4b3709743500dd5823ab5e80f" translate="yes" xml:space="preserve">
          <source>(For historical reasons, this function returns an &lt;code&gt;int&lt;/code&gt;, which now is always 1.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff34abdb860538263e1592eaf5de0e2697e490fe" translate="yes" xml:space="preserve">
          <source>(Formally this is not an incompatibility, because Lua does not specify how numbers are formatted as strings, but some programs assumed a specific format.)</source>
          <target state="translated">(Formalmente, esto no es una incompatibilidad, porque Lua no especifica c&amp;oacute;mo se formatean los n&amp;uacute;meros como cadenas, pero algunos programas asumieron un formato espec&amp;iacute;fico).</target>
        </trans-unit>
        <trans-unit id="83e737da7c8003cef965fa66244b7d4f0e811971" translate="yes" xml:space="preserve">
          <source>(In this manual, &lt;code&gt;--&amp;gt;&lt;/code&gt; indicates the result of the preceding expression.)</source>
          <target state="translated">(En este manual, &lt;code&gt;--&amp;gt;&lt;/code&gt; indica el resultado de la expresi&amp;oacute;n anterior).</target>
        </trans-unit>
        <trans-unit id="bf94fa4119b73b349cb3a869be243c96bbbd716b" translate="yes" xml:space="preserve">
          <source>(Note that it is very easy to exhaust the memory of your machine with a single call to this function.)</source>
          <target state="translated">(Tenga en cuenta que es muy f&amp;aacute;cil agotar la memoria de su m&amp;aacute;quina con una sola llamada a esta funci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="15e67d53040898eb1d72848e8bf16a113fbe8148" translate="yes" xml:space="preserve">
          <source>(Of course, the location of the Lua interpreter may be different in your machine. If &lt;code&gt;lua&lt;/code&gt; is in your &lt;code&gt;PATH&lt;/code&gt;, then</source>
          <target state="translated">(Por supuesto, la ubicaci&amp;oacute;n del int&amp;eacute;rprete de Lua puede ser diferente en su m&amp;aacute;quina. Si &lt;code&gt;lua&lt;/code&gt; est&amp;aacute; en su &lt;code&gt;PATH&lt;/code&gt; , entonces</target>
        </trans-unit>
        <trans-unit id="81e3e714f7f80485e58bd929a17d4b2437cf6658" translate="yes" xml:space="preserve">
          <source>(This only makes a difference when the body of the function contains references to &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">(Esto solo hace una diferencia cuando el cuerpo de la funci&amp;oacute;n contiene referencias a &lt;code&gt;f&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="cc7121f94b54a95b8b969917eaaadf1818bfdd84" translate="yes" xml:space="preserve">
          <source>1 &amp;ndash; Introduction</source>
          <target state="translated">1. Introducci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="8f2807c1adb4cb8317971da9ae6f8750a47585a8" translate="yes" xml:space="preserve">
          <source>2 &amp;ndash; Basic Concepts</source>
          <target state="translated">2 - Conceptos b&amp;aacute;sicos</target>
        </trans-unit>
        <trans-unit id="addc53e794c80e9178d488e577f3a4dea23392c9" translate="yes" xml:space="preserve">
          <source>2.1 &amp;ndash; Values and Types</source>
          <target state="translated">2.1 - Valores y tipos</target>
        </trans-unit>
        <trans-unit id="3a2d12c82ff6ae933fc4f58e1c29dac173475282" translate="yes" xml:space="preserve">
          <source>2.2 &amp;ndash; Environments and the Global Environment</source>
          <target state="translated">2.2 - Medio ambiente y medio ambiente global</target>
        </trans-unit>
        <trans-unit id="9ffa2c3b3aefb8ca31249b42217d40b45a53d14c" translate="yes" xml:space="preserve">
          <source>2.3 &amp;ndash; Error Handling</source>
          <target state="translated">2.3 - Manejo de errores</target>
        </trans-unit>
        <trans-unit id="5c74738bb551c5852eee4f0c5bc1c1ba329666da" translate="yes" xml:space="preserve">
          <source>2.4 &amp;ndash; Metatables and Metamethods</source>
          <target state="translated">2.4 - Metatables y metam&amp;eacute;todos</target>
        </trans-unit>
        <trans-unit id="33aac5b72dac431d0193e5a027944729e242300d" translate="yes" xml:space="preserve">
          <source>2.5 &amp;ndash; Garbage Collection</source>
          <target state="translated">2.5 - Recolecci&amp;oacute;n de basura</target>
        </trans-unit>
        <trans-unit id="0f9506705cc9aac3384b718f0231b4eeaf53f83b" translate="yes" xml:space="preserve">
          <source>2.5.1 &amp;ndash; Garbage-Collection Metamethods</source>
          <target state="translated">2.5.1 - Metam&amp;eacute;todos de recolecci&amp;oacute;n de basura</target>
        </trans-unit>
        <trans-unit id="e32b78c5e50a1f090eee84e8782e491a63c87474" translate="yes" xml:space="preserve">
          <source>2.5.1 &amp;ndash; Incremental Garbage Collection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43af5305d3d2bab0f47bc71974c0c5f7e41eb765" translate="yes" xml:space="preserve">
          <source>2.5.2 &amp;ndash; Generational Garbage Collection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360b1c24eeac1e48dfe95fc741100e73b36bcc2b" translate="yes" xml:space="preserve">
          <source>2.5.2 &amp;ndash; Weak Tables</source>
          <target state="translated">2.5.2 - Tablas d&amp;eacute;biles</target>
        </trans-unit>
        <trans-unit id="8e167c46990c9b5a8a8cb584e6e98fba1cedd41a" translate="yes" xml:space="preserve">
          <source>2.5.3 &amp;ndash; Garbage-Collection Metamethods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="214d3a585538532f8988b9596464a09d392edfe6" translate="yes" xml:space="preserve">
          <source>2.5.4 &amp;ndash; Weak Tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49622640c10cc5518dfa4cbdd39ec33d28b234e2" translate="yes" xml:space="preserve">
          <source>2.6 &amp;ndash; Coroutines</source>
          <target state="translated">2.6 - Corutinas</target>
        </trans-unit>
        <trans-unit id="44e5a7dffeb9301dcfea49c570d9242c8df4de45" translate="yes" xml:space="preserve">
          <source>3 &amp;ndash; The Language</source>
          <target state="translated">3 - El idioma</target>
        </trans-unit>
        <trans-unit id="2e41c7c97446c4f1020d50a68126a5a0606e6e8f" translate="yes" xml:space="preserve">
          <source>3.1 &amp;ndash; Lexical Conventions</source>
          <target state="translated">3.1 - Convenciones l&amp;eacute;xicas</target>
        </trans-unit>
        <trans-unit id="0612a6e0f7da40e6c864f4e6e097977a5b51bcbe" translate="yes" xml:space="preserve">
          <source>3.2 &amp;ndash; Variables</source>
          <target state="translated">3.2 - Variables</target>
        </trans-unit>
        <trans-unit id="831eca58ed9634bf35d286b0652dd764c6225329" translate="yes" xml:space="preserve">
          <source>3.3 &amp;ndash; Statements</source>
          <target state="translated">3.3 - Declaraciones</target>
        </trans-unit>
        <trans-unit id="b9b8530dd3439338077cae5d9a81b0f8388246f9" translate="yes" xml:space="preserve">
          <source>3.3.1 &amp;ndash; Blocks</source>
          <target state="translated">3.3.1 - Bloques</target>
        </trans-unit>
        <trans-unit id="249018398e87db611b2f382c32e3c2029e7a3362" translate="yes" xml:space="preserve">
          <source>3.3.2 &amp;ndash; Chunks</source>
          <target state="translated">3.3.2 - Trozos</target>
        </trans-unit>
        <trans-unit id="93fdc1a5227f5f767eda4b33118ca26d4d3ec98f" translate="yes" xml:space="preserve">
          <source>3.3.3 &amp;ndash; Assignment</source>
          <target state="translated">3.3.3 - Cesi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="60ea5bc043174dd66add3628579020e9fd6149ea" translate="yes" xml:space="preserve">
          <source>3.3.4 &amp;ndash; Control Structures</source>
          <target state="translated">3.3.4 - Estructuras de control</target>
        </trans-unit>
        <trans-unit id="b4e38214a26cbc13913d45fcdc42571b93281b8f" translate="yes" xml:space="preserve">
          <source>3.3.5 &amp;ndash; For Statement</source>
          <target state="translated">3.3.5 - Para declaraci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="1f046a545135d5e9e1e65842299b34f6b36157ac" translate="yes" xml:space="preserve">
          <source>3.3.6 &amp;ndash; Function Calls as Statements</source>
          <target state="translated">3.3.6 - Llamadas a funciones como declaraciones</target>
        </trans-unit>
        <trans-unit id="19a6d2647263682fe5a7621ae89477d702d33727" translate="yes" xml:space="preserve">
          <source>3.3.7 &amp;ndash; Local Declarations</source>
          <target state="translated">3.3.7 - Declaraciones locales</target>
        </trans-unit>
        <trans-unit id="af418c66e1cf132089f35fa7b4a14dba17e186f8" translate="yes" xml:space="preserve">
          <source>3.3.8 &amp;ndash; To-be-closed Variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac56f78d28bb6bfafede4821e374042b6d5ded3c" translate="yes" xml:space="preserve">
          <source>3.4 &amp;ndash; Expressions</source>
          <target state="translated">3.4 - Expresiones</target>
        </trans-unit>
        <trans-unit id="11859fef39e3ab01288c6dd79b5e2b11fdad4c8d" translate="yes" xml:space="preserve">
          <source>3.4.1 &amp;ndash; Arithmetic Operators</source>
          <target state="translated">3.4.1 - Operadores aritm&amp;eacute;ticos</target>
        </trans-unit>
        <trans-unit id="5ba9603d3900196b96bc99dd68bef5ea214ec46d" translate="yes" xml:space="preserve">
          <source>3.4.10 &amp;ndash; Function Calls</source>
          <target state="translated">3.4.10 - Llamadas a funciones</target>
        </trans-unit>
        <trans-unit id="d521e09f296fb652ca685e9986c89365b3a3a60e" translate="yes" xml:space="preserve">
          <source>3.4.11 &amp;ndash; Function Definitions</source>
          <target state="translated">3.4.11 - Definiciones de funciones</target>
        </trans-unit>
        <trans-unit id="0767b1e410d6366522683c5dea029dba330f750e" translate="yes" xml:space="preserve">
          <source>3.4.2 &amp;ndash; Bitwise Operators</source>
          <target state="translated">3.4.2 - Operadores bit a bit</target>
        </trans-unit>
        <trans-unit id="7fcc429ce74b3bad7b171ca68ce6278ebc43bae9" translate="yes" xml:space="preserve">
          <source>3.4.3 &amp;ndash; Coercions and Conversions</source>
          <target state="translated">3.4.3 - Coacciones y conversiones</target>
        </trans-unit>
        <trans-unit id="a5cfc763ebbbdbc2d383f04e2795f848e29252e2" translate="yes" xml:space="preserve">
          <source>3.4.4 &amp;ndash; Relational Operators</source>
          <target state="translated">3.4.4 - Operadores relacionales</target>
        </trans-unit>
        <trans-unit id="0813780c5158e7059551f2d8bd071c10fcd64a1e" translate="yes" xml:space="preserve">
          <source>3.4.5 &amp;ndash; Logical Operators</source>
          <target state="translated">3.4.5 - Operadores l&amp;oacute;gicos</target>
        </trans-unit>
        <trans-unit id="053f15c92c03eee025a09cbef6910c4913cf9628" translate="yes" xml:space="preserve">
          <source>3.4.6 &amp;ndash; Concatenation</source>
          <target state="translated">3.4.6 - Concatenaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="48ea8196506d47e56086f0bd779ad133e81d539a" translate="yes" xml:space="preserve">
          <source>3.4.7 &amp;ndash; The Length Operator</source>
          <target state="translated">3.4.7 - El operador de longitud</target>
        </trans-unit>
        <trans-unit id="b77361dfb2f580a09634468b4a92c293c9a90987" translate="yes" xml:space="preserve">
          <source>3.4.8 &amp;ndash; Precedence</source>
          <target state="translated">3.4.8 - Precedencia</target>
        </trans-unit>
        <trans-unit id="1716010a5bdaeeaa519496e7998b4394c6b17b0d" translate="yes" xml:space="preserve">
          <source>3.4.9 &amp;ndash; Table Constructors</source>
          <target state="translated">3.4.9 - Constructores de tablas</target>
        </trans-unit>
        <trans-unit id="c20fcbea7777ae7db816c4f7863db3c7e76c4be7" translate="yes" xml:space="preserve">
          <source>3.5 &amp;ndash; Visibility Rules</source>
          <target state="translated">3.5 - Reglas de visibilidad</target>
        </trans-unit>
        <trans-unit id="dd63ac66a4ed838d368dd76236f0026ba6aee449" translate="yes" xml:space="preserve">
          <source>4 &amp;ndash; The Application Program Interface</source>
          <target state="translated">4 - La interfaz del programa de aplicaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="f79922b6ade2d7cb13fd986a703b2a74313e769b" translate="yes" xml:space="preserve">
          <source>4.1 &amp;ndash; The Stack</source>
          <target state="translated">4.1 - La pila</target>
        </trans-unit>
        <trans-unit id="d9f9eb941346401ba1b1d6e7aa99b140b60d3df8" translate="yes" xml:space="preserve">
          <source>4.1.1 &amp;ndash; Stack Size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b53b631b67c084454b799b08efc2b764260fa3a" translate="yes" xml:space="preserve">
          <source>4.1.2 &amp;ndash; Valid and Acceptable Indices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1e3768345e4af898dfc41e7e10c658434cc264" translate="yes" xml:space="preserve">
          <source>4.1.3 &amp;ndash; Pointers to strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f948f17a2d03bb70942c6d60e9c6dd9718a6ab6" translate="yes" xml:space="preserve">
          <source>4.2 &amp;ndash; C Closures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b51906b5985deb44043d8f246cfc18dd2ae60aa" translate="yes" xml:space="preserve">
          <source>4.2 &amp;ndash; Stack Size</source>
          <target state="translated">4.2 - Tama&amp;ntilde;o de la pila</target>
        </trans-unit>
        <trans-unit id="b9e0c047d51ad36674867b47be7d8064f6cc1198" translate="yes" xml:space="preserve">
          <source>4.3 &amp;ndash; Registry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b2949d1c9fcdf122a9e531b559332da4485f80" translate="yes" xml:space="preserve">
          <source>4.3 &amp;ndash; Valid and Acceptable Indices</source>
          <target state="translated">4.3 - &amp;Iacute;ndices v&amp;aacute;lidos y aceptables</target>
        </trans-unit>
        <trans-unit id="74f0c5c5ee47538264fae29f7657133d0d699462" translate="yes" xml:space="preserve">
          <source>4.4 &amp;ndash; C Closures</source>
          <target state="translated">4.4 - Cierres</target>
        </trans-unit>
        <trans-unit id="0dbd1a3e805d6fec4ca12f8d780c75e4a904e874" translate="yes" xml:space="preserve">
          <source>4.4 &amp;ndash; Error Handling in C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f9e6c48a793a67b066e784105577fb0aa683bea" translate="yes" xml:space="preserve">
          <source>4.4.1 &amp;ndash; Status Codes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377aa610f8c8d69e259aec326a2c725db1573141" translate="yes" xml:space="preserve">
          <source>4.5 &amp;ndash; Handling Yields in C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6aa4af1e5cbd9bad1a034dc03de85dd86ad779" translate="yes" xml:space="preserve">
          <source>4.5 &amp;ndash; Registry</source>
          <target state="translated">4.5 - Registro</target>
        </trans-unit>
        <trans-unit id="d8452600dbf3930156ccc218b4b4ddb69035a3ec" translate="yes" xml:space="preserve">
          <source>4.6 &amp;ndash; Error Handling in C</source>
          <target state="translated">4.6 - Manejo de errores en C</target>
        </trans-unit>
        <trans-unit id="f7a50c0b6783f529c6ca7b0482b1c7c7c2bb7fdf" translate="yes" xml:space="preserve">
          <source>4.6 &amp;ndash; Functions and Types[-o, +p, &lt;em&gt;x&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275ecb37e4e88aebd92acb558147bf849a62c9bb" translate="yes" xml:space="preserve">
          <source>4.7 &amp;ndash; Handling Yields in C</source>
          <target state="translated">4.7 - Manejo de rendimientos en C</target>
        </trans-unit>
        <trans-unit id="4e14e0c386ac14d12f3f1850ac004fb05166fe20" translate="yes" xml:space="preserve">
          <source>4.7 &amp;ndash; The Debug Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1985494a7c3d7d1062380e781037ccb1f14dbf" translate="yes" xml:space="preserve">
          <source>4.8 &amp;ndash; Functions and Types[-o, +p, &lt;em&gt;x&lt;/em&gt;]</source>
          <target state="translated">4.8 - Funciones y tipos [-o, + p, &lt;em&gt;x&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="fd295b2094f1a31a0f8f4e3c5ef5c7874f795c82" translate="yes" xml:space="preserve">
          <source>4.9 &amp;ndash; The Debug Interface</source>
          <target state="translated">4.9 - La interfaz de depuraci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="7ad85d079aa056f3c063c288f0c0093ca0f6c73d" translate="yes" xml:space="preserve">
          <source>5 &amp;ndash; The Auxiliary Library</source>
          <target state="translated">5 - La biblioteca auxiliar</target>
        </trans-unit>
        <trans-unit id="71d57e32825e907432cc4adf35e23a77ed97c0a2" translate="yes" xml:space="preserve">
          <source>5.1 &amp;ndash; Functions and Types</source>
          <target state="translated">5.1 - Funciones y tipos</target>
        </trans-unit>
        <trans-unit id="92cc3da65a13c96c43af92f1e98bfede2f153c83" translate="yes" xml:space="preserve">
          <source>6 &amp;ndash; Standard Libraries</source>
          <target state="translated">6 - Bibliotecas est&amp;aacute;ndar</target>
        </trans-unit>
        <trans-unit id="cdc1f8312506691b983394a13630259db22af735" translate="yes" xml:space="preserve">
          <source>6 &amp;ndash; The Standard Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1cf8fe5aceb71994bc78f0adf755277b6681f00" translate="yes" xml:space="preserve">
          <source>6.1 &amp;ndash; Basic Functions</source>
          <target state="translated">6.1 - Funciones b&amp;aacute;sicas</target>
        </trans-unit>
        <trans-unit id="6e24ce31a4d8a8b2c4bf3eaf4c953e980b335967" translate="yes" xml:space="preserve">
          <source>6.10 &amp;ndash; The Debug Library</source>
          <target state="translated">6.10 - La biblioteca de depuraci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="03d2065bb3d3315a8c459cb76f8c692d4aabb3b3" translate="yes" xml:space="preserve">
          <source>6.2 &amp;ndash; Coroutine Manipulation</source>
          <target state="translated">6.2 - Manipulaci&amp;oacute;n de corrutinas</target>
        </trans-unit>
        <trans-unit id="7ab3ec70bbfde06cb8aacd9d27858f73840ca3e6" translate="yes" xml:space="preserve">
          <source>6.3 &amp;ndash; Modules</source>
          <target state="translated">6.3 - M&amp;oacute;dulos</target>
        </trans-unit>
        <trans-unit id="1a9e8fe3268257be8690631f66b150e7b529fa25" translate="yes" xml:space="preserve">
          <source>6.4 &amp;ndash; String Manipulation</source>
          <target state="translated">6.4 - Manipulaci&amp;oacute;n de cadenas</target>
        </trans-unit>
        <trans-unit id="c32244a851c4ca4fbd524d465d9ac63a62295558" translate="yes" xml:space="preserve">
          <source>6.4.1 &amp;ndash; Patterns</source>
          <target state="translated">6.4.1 - Patrones</target>
        </trans-unit>
        <trans-unit id="117f4fd92a6a3918b099c684ab382f396d5eb6a0" translate="yes" xml:space="preserve">
          <source>6.4.2 &amp;ndash; Format Strings for Pack and Unpack</source>
          <target state="translated">6.4.2 - Cadenas de formato para empaquetar y desempaquetar</target>
        </trans-unit>
        <trans-unit id="2c69cea016f7e6620297e4c1a14aee86bca54a5d" translate="yes" xml:space="preserve">
          <source>6.5 &amp;ndash; UTF-8 Support</source>
          <target state="translated">6.5 - Soporte UTF-8</target>
        </trans-unit>
        <trans-unit id="63cc5647192e9aeb780e978b92120a1f45dd2739" translate="yes" xml:space="preserve">
          <source>6.6 &amp;ndash; Table Manipulation</source>
          <target state="translated">6.6 - Manipulaci&amp;oacute;n de tablas</target>
        </trans-unit>
        <trans-unit id="c32e233273be58074db0281b90ff78f133dadaa9" translate="yes" xml:space="preserve">
          <source>6.7 &amp;ndash; Mathematical Functions</source>
          <target state="translated">6.7 - Funciones matem&amp;aacute;ticas</target>
        </trans-unit>
        <trans-unit id="832907e7e19406cf81191180275a0cb50dea430b" translate="yes" xml:space="preserve">
          <source>6.8 &amp;ndash; Input and Output Facilities</source>
          <target state="translated">6.8 - Instalaciones de entrada y salida</target>
        </trans-unit>
        <trans-unit id="cb34b15416a677114058591f5dd2c4ae7287d44b" translate="yes" xml:space="preserve">
          <source>6.9 &amp;ndash; Operating System Facilities</source>
          <target state="translated">6.9 - Instalaciones del sistema operativo</target>
        </trans-unit>
        <trans-unit id="392af5f262337c8a47dea77fc574c5980a74525f" translate="yes" xml:space="preserve">
          <source>7 &amp;ndash; Lua Standalone</source>
          <target state="translated">7 - Lua independiente</target>
        </trans-unit>
        <trans-unit id="8f903b288c9e6ac2b63f9c5ac1ae4e51b0452d1a" translate="yes" xml:space="preserve">
          <source>8 &amp;ndash; Incompatibilities with the Previous Version</source>
          <target state="translated">8 - Incompatibilidades con la versi&amp;oacute;n anterior</target>
        </trans-unit>
        <trans-unit id="3f8999c0013347303415ee512a5929d88176001f" translate="yes" xml:space="preserve">
          <source>8.1 &amp;ndash; Changes in the Language</source>
          <target state="translated">8.1 - Cambios en el idioma</target>
        </trans-unit>
        <trans-unit id="06621f3918bf601ab4ad6ab96566b71dfebeffb3" translate="yes" xml:space="preserve">
          <source>8.1 &amp;ndash; Incompatibilities in the Language</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e15fa697b4f86446516c25786580893e59e6a10" translate="yes" xml:space="preserve">
          <source>8.2 &amp;ndash; Changes in the Libraries</source>
          <target state="translated">8.2 - Cambios en las Bibliotecas</target>
        </trans-unit>
        <trans-unit id="23f51416a51cac5ed2d636a8149b6e8015550499" translate="yes" xml:space="preserve">
          <source>8.2 &amp;ndash; Incompatibilities in the Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d089e3545870977ceda5c673010988a582c7e893" translate="yes" xml:space="preserve">
          <source>8.3 &amp;ndash; Changes in the API</source>
          <target state="translated">8.3 - Cambios en la API</target>
        </trans-unit>
        <trans-unit id="f39f679da171dc7301920de76daf97ecf11156be" translate="yes" xml:space="preserve">
          <source>8.3 &amp;ndash; Incompatibilities in the API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31e9eb94987aca4e6da693733376a5662dabd38" translate="yes" xml:space="preserve">
          <source>9 &amp;ndash; The Complete Syntax of Lua</source>
          <target state="translated">9 - La sintaxis completa de Lua</target>
        </trans-unit>
        <trans-unit id="81d3ce176f56748de5e1f64f56afa6b88a0919fc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt; pushes the variable's value onto the stack and returns its name.</source>
          <target state="translated">&lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; inserta&lt;/a&gt; el valor de la variable en la pila y devuelve su nombre.</target>
        </trans-unit>
        <trans-unit id="997a4ac3078b35c85f1fb0a338e5857990690995" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRGCMM&quot;&gt;&lt;code&gt;LUA_ERRGCMM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; error while running a &lt;code&gt;__gc&lt;/code&gt; metamethod. (This error has no relation with the chunk being loaded. It is generated by the garbage collector.)</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRGCMM&quot;&gt; &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;error al ejecutar un &lt;code&gt;__gc&lt;/code&gt; __gc. (Este error no tiene relaci&amp;oacute;n con el fragmento que se est&amp;aacute; cargando. Lo genera el recolector de basura).</target>
        </trans-unit>
        <trans-unit id="0a62e7bf056e6b28156f4c231057917eae3f721a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; memory allocation (out-of-memory) error;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt; &lt;code&gt;LUA_ERRMEM&lt;/code&gt; &lt;/a&gt; : error de&lt;/b&gt; asignaci&amp;oacute;n de memoria (memoria&lt;b&gt; insuficiente&lt;/b&gt; );</target>
        </trans-unit>
        <trans-unit id="bb87b0a3626f8ed024c6ec50e4a5a62da84f1ba0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; no errors;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;sin errores;</target>
        </trans-unit>
        <trans-unit id="39a5a19fe9e5d2de47a8c090156531e8d630b23d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRERR&quot;&gt;&lt;code&gt;LUA_ERRERR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; error while running the message handler.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRERR&quot;&gt; &lt;code&gt;LUA_ERRERR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;error al ejecutar el manejador de mensajes.</target>
        </trans-unit>
        <trans-unit id="2e1a636b6f8349496df60024fcc170dc0d04074e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt;&lt;code&gt;LUA_ERRFILE&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; a file-related error; e.g., it cannot open or read the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58785899340ce91e0de9aca15120aa7cff3c9758" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRGCMM&quot;&gt;&lt;code&gt;LUA_ERRGCMM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; error while running a &lt;code&gt;__gc&lt;/code&gt; metamethod. For such errors, Lua does not call the message handler (as this kind of error typically has no relation with the function being called).</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRGCMM&quot;&gt; &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;error al ejecutar un &lt;code&gt;__gc&lt;/code&gt; __gc. Para tales errores, Lua no llama al manejador de mensajes (ya que este tipo de error normalmente no tiene relaci&amp;oacute;n con la funci&amp;oacute;n que se llama).</target>
        </trans-unit>
        <trans-unit id="0513936f3247fabebe04e7758e5c7c600069b199" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; memory allocation error. For such errors, Lua does not call the message handler.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRMEM&quot;&gt; &lt;code&gt;LUA_ERRMEM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;error de asignaci&amp;oacute;n de memoria. Para tales errores, Lua no llama al controlador de mensajes.</target>
        </trans-unit>
        <trans-unit id="6d5a47c8aea539962fb70e275409743f8d4b5c7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRRUN&quot;&gt;&lt;code&gt;LUA_ERRRUN&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; a runtime error.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRRUN&quot;&gt; &lt;code&gt;LUA_ERRRUN&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;un error de tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="58a8a6fac9b491348f1457d76858314d9b3fa87d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRSYNTAX&quot;&gt;&lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; syntax error during precompilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a51e900c7e297ae9668bf44b0828218aa58bb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRSYNTAX&quot;&gt;&lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; syntax error during precompilation;</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRSYNTAX&quot;&gt; &lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;error de sintaxis durante la precompilaci&amp;oacute;n;</target>
        </trans-unit>
        <trans-unit id="e602ebe4fcc62dd82a2561a804720e795fd118fe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (0): &lt;/b&gt; no errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069ddb6d3068bf3edc5b7f77df2372cab0d8f9ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (0): &lt;/b&gt; success.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; (0):&lt;/b&gt;&amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="3ec3be0613ea3827ce544ed885c9f84ec41464e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPADD&quot;&gt;&lt;code&gt;LUA_OPADD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs addition (&lt;code&gt;+&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPADD&quot;&gt; &lt;code&gt;LUA_OPADD&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza suma ( &lt;code&gt;+&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6c814447a9527d908c1ce86da63fcae3cd57025f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBAND&quot;&gt;&lt;code&gt;LUA_OPBAND&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise AND (&lt;code&gt;&amp;amp;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBAND&quot;&gt; &lt;code&gt;LUA_OPBAND&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza AND ( &lt;code&gt;&amp;amp;&lt;/code&gt; )bit a bit</target>
        </trans-unit>
        <trans-unit id="b84c3f3596e3f23015f094f8174ece0ce3d795e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBNOT&quot;&gt;&lt;code&gt;LUA_OPBNOT&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise NOT (&lt;code&gt;~&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBNOT&quot;&gt; &lt;code&gt;LUA_OPBNOT&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza bit a bit NOT ( &lt;code&gt;~&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="aa756b6d2d7eef20df16036a246330397dc748b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBOR&quot;&gt;&lt;code&gt;LUA_OPBOR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise OR (&lt;code&gt;|&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBOR&quot;&gt; &lt;code&gt;LUA_OPBOR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza OR bit a bit ( &lt;code&gt;|&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cadd32314c831b1dd6807904ee89f82906c6a5d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBXOR&quot;&gt;&lt;code&gt;LUA_OPBXOR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise exclusive OR (&lt;code&gt;~&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBXOR&quot;&gt; &lt;code&gt;LUA_OPBXOR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza OR exclusivo bit a bit ( &lt;code&gt;~&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0120c4dc4899ecd53a28bb0567448d1dfc295a55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPDIV&quot;&gt;&lt;code&gt;LUA_OPDIV&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs float division (&lt;code&gt;/&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPDIV&quot;&gt; &lt;code&gt;LUA_OPDIV&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza divisi&amp;oacute;n flotante ( &lt;code&gt;/&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="297add48d11993decc4e07fa953033476d1943cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPEQ&quot;&gt;&lt;code&gt;LUA_OPEQ&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; compares for equality (&lt;code&gt;==&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPEQ&quot;&gt; &lt;code&gt;LUA_OPEQ&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;compara la igualdad ( &lt;code&gt;==&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6ad36382d905550ab53f7c8b67e61d620b311419" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPIDIV&quot;&gt;&lt;code&gt;LUA_OPIDIV&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs floor division (&lt;code&gt;//&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPIDIV&quot;&gt; &lt;code&gt;LUA_OPIDIV&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza divisi&amp;oacute;n de piso ( &lt;code&gt;//&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="65b04a9f94a548d3eb547be608241aacea9320cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLE&quot;&gt;&lt;code&gt;LUA_OPLE&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; compares for less or equal (&lt;code&gt;&amp;lt;=&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLE&quot;&gt; &lt;code&gt;LUA_OPLE&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;compara por menor o igual ( &lt;code&gt;&amp;lt;=&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="475bd49677a764ed78bc57bf43886acf09d7bdab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLT&quot;&gt;&lt;code&gt;LUA_OPLT&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; compares for less than (&lt;code&gt;&amp;lt;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLT&quot;&gt; &lt;code&gt;LUA_OPLT&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;compara por menos de ( &lt;code&gt;&amp;lt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d59eb3b1ef4b950e8399516c5f783e0f11e809c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMOD&quot;&gt;&lt;code&gt;LUA_OPMOD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs modulo (&lt;code&gt;%&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMOD&quot;&gt; &lt;code&gt;LUA_OPMOD&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza m&amp;oacute;dulo ( &lt;code&gt;%&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3be2f129960c9b22d8bed03fc870c9ddeb0d44a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMUL&quot;&gt;&lt;code&gt;LUA_OPMUL&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs multiplication (&lt;code&gt;*&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMUL&quot;&gt; &lt;code&gt;LUA_OPMUL&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza multiplicaci&amp;oacute;n ( &lt;code&gt;*&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0df86847b8617d3071f5659dea048400514522e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPPOW&quot;&gt;&lt;code&gt;LUA_OPPOW&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs exponentiation (&lt;code&gt;^&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPPOW&quot;&gt; &lt;code&gt;LUA_OPPOW&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza exponenciaci&amp;oacute;n ( &lt;code&gt;^&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5d397dbd765f0534ad52cb6ff558ee4e7202a360" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHL&quot;&gt;&lt;code&gt;LUA_OPSHL&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs left shift (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHL&quot;&gt; &lt;code&gt;LUA_OPSHL&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza desplazamiento a la izquierda ( &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a57f78cb55bc79c59850850886b07440785fc250" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHR&quot;&gt;&lt;code&gt;LUA_OPSHR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs right shift (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHR&quot;&gt; &lt;code&gt;LUA_OPSHR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza desplazamiento a la derecha ( &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5a256a2902d1801dfd4b235ec7de48d549ccf5af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSUB&quot;&gt;&lt;code&gt;LUA_OPSUB&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs subtraction (&lt;code&gt;-&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSUB&quot;&gt; &lt;code&gt;LUA_OPSUB&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza resta ( &lt;code&gt;-&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0079ed2e4b11f9492f31692fe85400731bec09ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPUNM&quot;&gt;&lt;code&gt;LUA_OPUNM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs mathematical negation (unary &lt;code&gt;-&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPUNM&quot;&gt; &lt;code&gt;LUA_OPUNM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;realiza negaci&amp;oacute;n matem&amp;aacute;tica (unario &lt;code&gt;-&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="490be7142f1b450637c62dce5134a58b5b7cd4c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_GLOBALS&quot;&gt;&lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; At this index the registry has the global environment.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_GLOBALS&quot;&gt; &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;En este &amp;iacute;ndice, el registro tiene el entorno global.</target>
        </trans-unit>
        <trans-unit id="67692b9acd7ece42dccee1c401f83f0322c87845" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_MAINTHREAD&quot;&gt;&lt;code&gt;LUA_RIDX_MAINTHREAD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; At this index the registry has the main thread of the state. (The main thread is the one created together with the state.)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_MAINTHREAD&quot;&gt; &lt;code&gt;LUA_RIDX_MAINTHREAD&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;En este &amp;iacute;ndice, el registro tiene el hilo principal del estado. (El hilo principal es el que se crea junto con el estado).</target>
        </trans-unit>
        <trans-unit id="ac448ccff5635b14399d2d3bc060876d6ff12d0e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; the thread (coroutine) yields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2feee941513a97c61affb953f6826a6da14e6b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;em&gt;number&lt;/em&gt;: &lt;/b&gt; reads a string with up to this number of bytes, returning &lt;b&gt;fail&lt;/b&gt; on end of file. If &lt;code&gt;number&lt;/code&gt; is zero, it reads nothing and returns an empty string, or &lt;b&gt;fail&lt;/b&gt; on end of file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad03bfffa23a0e90024b5cb186d8482335efd71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;em&gt;number&lt;/em&gt;: &lt;/b&gt; reads a string with up to this number of bytes, returning &lt;b&gt;nil&lt;/b&gt; on end of file. If &lt;code&gt;number&lt;/code&gt; is zero, it reads nothing and returns an empty string, or &lt;b&gt;nil&lt;/b&gt; on end of file.</source>
          <target state="translated">&lt;b&gt;&lt;em&gt;n&amp;uacute;mero&lt;/em&gt; :&lt;/b&gt; lee una cadena con hasta este n&amp;uacute;mero de bytes, devolviendo&lt;b&gt; nulo&lt;/b&gt; al final del archivo. Si &lt;code&gt;number&lt;/code&gt; es cero, no lee nada y devuelve una cadena vac&amp;iacute;a o&lt;b&gt; nil&lt;/b&gt; al final del archivo.</target>
        </trans-unit>
        <trans-unit id="2a0c3c0bea2d7e7832082339aece729a1babeddb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;em&gt;x&lt;/em&gt;: &lt;/b&gt; (where &lt;em&gt;x&lt;/em&gt; is not one of the &lt;em&gt;magic characters&lt;/em&gt;&lt;code&gt;^$()%.[]*+-?&lt;/code&gt;) represents the character &lt;em&gt;x&lt;/em&gt; itself.</source>
          <target state="translated">&lt;b&gt;&lt;em&gt;x&lt;/em&gt; :&lt;/b&gt; (donde&lt;em&gt; x&lt;/em&gt; no es uno de los&lt;em&gt; caracteres m&amp;aacute;gicos &lt;/em&gt; &lt;code&gt;^$()%.[]*+-?&lt;/code&gt; ) representa el propio car&amp;aacute;cter&lt;em&gt; x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3d2c4186a84e56cd4d03c088b58a9fb64d00944f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The call hook: &lt;/b&gt; is called when the interpreter calls a function. The hook is called just after Lua enters the new function, before the function gets its arguments.</source>
          <target state="translated">&lt;b&gt;El gancho de llamada:&lt;/b&gt; se llama cuando el int&amp;eacute;rprete llama a una funci&amp;oacute;n. El gancho se llama justo despu&amp;eacute;s de que Lua ingrese a la nueva funci&amp;oacute;n, antes de que la funci&amp;oacute;n obtenga sus argumentos.</target>
        </trans-unit>
        <trans-unit id="4c319abdad8a73bd491f05a87214f3722450c090" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The call hook: &lt;/b&gt; is called when the interpreter calls a function. The hook is called just after Lua enters the new function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3586bc19f491f63ef8c6fbe8267e796599c9d56a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The count hook: &lt;/b&gt; is called after the interpreter executes every &lt;code&gt;count&lt;/code&gt; instructions. (This event only happens while Lua is executing a Lua function.)</source>
          <target state="translated">&lt;b&gt;El gancho de recuento:&lt;/b&gt; se llama despu&amp;eacute;s de que el int&amp;eacute;rprete ejecuta todas las instrucciones de &lt;code&gt;count&lt;/code&gt; . (Este evento solo ocurre mientras Lua est&amp;aacute; ejecutando una funci&amp;oacute;n de Lua).</target>
        </trans-unit>
        <trans-unit id="e9aa0abd3e3bccd6db88de7e1964c72d9f0dd91f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The count hook: &lt;/b&gt; is called after the interpreter executes every &lt;code&gt;count&lt;/code&gt; instructions. This event only happens while Lua is executing a Lua function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc132bdb212730eeb73d3b168b816f3020c8283b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The line hook: &lt;/b&gt; is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). (This event only happens while Lua is executing a Lua function.)</source>
          <target state="translated">&lt;b&gt;El gancho de l&amp;iacute;nea:&lt;/b&gt; se llama cuando el int&amp;eacute;rprete est&amp;aacute; a punto de iniciar la ejecuci&amp;oacute;n de una nueva l&amp;iacute;nea de c&amp;oacute;digo o cuando retrocede en el c&amp;oacute;digo (incluso a la misma l&amp;iacute;nea). (Este evento solo ocurre mientras Lua est&amp;aacute; ejecutando una funci&amp;oacute;n de Lua).</target>
        </trans-unit>
        <trans-unit id="a2cc484b73c504ec047ff5fbcd11d9342d2ef6ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The line hook: &lt;/b&gt; is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). This event only happens while Lua is executing a Lua function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d7e12d9066d079bc460e5455e6a25ab434678d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The return hook: &lt;/b&gt; is called when the interpreter returns from a function. The hook is called just before Lua leaves the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0512dd920d52edfa2ad49b9db0251dfbc206479" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The return hook: &lt;/b&gt; is called when the interpreter returns from a function. The hook is called just before Lua leaves the function. There is no standard way to access the values to be returned by the function.</source>
          <target state="translated">&lt;b&gt;El gancho de retorno:&lt;/b&gt; se llama cuando el int&amp;eacute;rprete regresa de una funci&amp;oacute;n. El gancho se llama justo antes de que Lua abandone la funci&amp;oacute;n. No existe una forma est&amp;aacute;ndar de acceder a los valores que devolver&amp;aacute; la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8805e2bcd652fa518016fd2d76cf56a7869fb8f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;![&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: sets maximum alignment to &lt;code&gt;n&lt;/code&gt; (default is native alignment)</source>
          <target state="translated">&lt;code&gt;![&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : establece la alineaci&amp;oacute;n m&amp;aacute;xima en &lt;code&gt;n&lt;/code&gt; (el valor predeterminado es la alineaci&amp;oacute;n nativa)</target>
        </trans-unit>
        <trans-unit id="3acec99eacd1af7f2ca649aaae893e3003aadfa5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;/code&gt;: modulo</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; : m&amp;oacute;dulo</target>
        </trans-unit>
        <trans-unit id="6309f6de64785e493ad21fb0175b5bdc8f6ad525" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;, for &lt;em&gt;n&lt;/em&gt; between 1 and 9; such item matches a substring equal to the &lt;em&gt;n&lt;/em&gt;-th captured string (see below);</source>
          <target state="translated">&lt;code&gt;%&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; , para &lt;em&gt;n&lt;/em&gt; entre 1 y 9; tal elemento coincide con una subcadena igual a la &lt;em&gt;n&lt;/em&gt; -&amp;eacute;sima cadena capturada (ver m&amp;aacute;s abajo);</target>
        </trans-unit>
        <trans-unit id="3290eeaf448255438e96d55704c2f0da23661d04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;em&gt;x&lt;/em&gt;&lt;/code&gt;:  (where &lt;em&gt;x&lt;/em&gt; is any non-alphanumeric character) represents the character &lt;em&gt;x&lt;/em&gt;. This is the standard way to escape the magic characters. Any non-alphanumeric character (including all punctuation characters, even the non-magical) can be preceded by a '&lt;code&gt;%&lt;/code&gt;' to represent itself in a pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20e837008e6cbff5b2ce584f8dd66b1ebff0267" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;em&gt;x&lt;/em&gt;&lt;/code&gt;:  (where &lt;em&gt;x&lt;/em&gt; is any non-alphanumeric character) represents the character &lt;em&gt;x&lt;/em&gt;. This is the standard way to escape the magic characters. Any non-alphanumeric character (including all punctuation characters, even the non-magical) can be preceded by a '&lt;code&gt;%&lt;/code&gt;' when used to represent itself in a pattern.</source>
          <target state="translated">&lt;code&gt;%&lt;em&gt;x&lt;/em&gt;&lt;/code&gt; : (donde &lt;em&gt;x&lt;/em&gt; es cualquier car&amp;aacute;cter no alfanum&amp;eacute;rico) representa el car&amp;aacute;cter &lt;em&gt;x&lt;/em&gt; . Esta es la forma est&amp;aacute;ndar de escapar de los personajes m&amp;aacute;gicos. Cualquier car&amp;aacute;cter no alfanum&amp;eacute;rico (incluidos todos los caracteres de puntuaci&amp;oacute;n, incluso los no m&amp;aacute;gicos) puede ir precedido de un ' &lt;code&gt;%&lt;/code&gt; ' cuando se utiliza para representarse a s&amp;iacute; mismo en un patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e54e56bd80af5958ec4c201065fe5778f27f86df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%a&lt;/code&gt;:  represents all letters.</source>
          <target state="translated">&lt;code&gt;%a&lt;/code&gt; : representa todas las letras.</target>
        </trans-unit>
        <trans-unit id="cbfe0af04bd3d02f8310cc2561a3ed583449532b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%b&lt;em&gt;xy&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are two distinct characters; such item matches strings that start with &lt;em&gt;x&lt;/em&gt;, end with &lt;em&gt;y&lt;/em&gt;, and where the &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are &lt;em&gt;balanced&lt;/em&gt;. This means that, if one reads the string from left to right, counting &lt;em&gt;+1&lt;/em&gt; for an &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;-1&lt;/em&gt; for a &lt;em&gt;y&lt;/em&gt;, the ending &lt;em&gt;y&lt;/em&gt; is the first &lt;em&gt;y&lt;/em&gt; where the count reaches 0. For instance, the item &lt;code&gt;%b()&lt;/code&gt; matches expressions with balanced parentheses.</source>
          <target state="translated">&lt;code&gt;%b&lt;em&gt;xy&lt;/em&gt;&lt;/code&gt; , donde &lt;em&gt;x&lt;/em&gt; y &lt;em&gt;y&lt;/em&gt; son dos caracteres distintos; tal elemento coincide con cadenas que comienzan con &lt;em&gt;x&lt;/em&gt; , terminan con &lt;em&gt;Y&lt;/em&gt; , y donde la &lt;em&gt;x&lt;/em&gt; e &lt;em&gt;y&lt;/em&gt; est&amp;aacute;n &lt;em&gt;en equilibrio&lt;/em&gt; . Esto significa que, si uno lee la cadena de izquierda a derecha, contando &lt;em&gt;+1&lt;/em&gt; para una &lt;em&gt;x&lt;/em&gt; y &lt;em&gt;-1&lt;/em&gt; para una &lt;em&gt;y&lt;/em&gt; , la &lt;em&gt;y&lt;/em&gt; final es la primera &lt;em&gt;y&lt;/em&gt; donde la cuenta llega a 0. Por ejemplo, el elemento &lt;code&gt;%b()&lt;/code&gt; coincide expresiones con par&amp;eacute;ntesis equilibrados.</target>
        </trans-unit>
        <trans-unit id="3de9b6ffd559dcc163f65726d138b7349ce95ff4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%c&lt;/code&gt;:  represents all control characters.</source>
          <target state="translated">&lt;code&gt;%c&lt;/code&gt; : representa todos los caracteres de control.</target>
        </trans-unit>
        <trans-unit id="b8ad684e3be8e7587d3c8ce155f426f377443ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%d&lt;/code&gt;:  represents all digits.</source>
          <target state="translated">&lt;code&gt;%d&lt;/code&gt; : representa todos los d&amp;iacute;gitos.</target>
        </trans-unit>
        <trans-unit id="a6f3e3f52646f53a60bfe00b2ff656a09e89a4a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%f[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt;, a &lt;em&gt;frontier pattern&lt;/em&gt;; such item matches an empty string at any position such that the next character belongs to &lt;em&gt;set&lt;/em&gt; and the previous character does not belong to &lt;em&gt;set&lt;/em&gt;. The set &lt;em&gt;set&lt;/em&gt; is interpreted as previously described. The beginning and the end of the subject are handled as if they were the character '&lt;code&gt;\0&lt;/code&gt;'.</source>
          <target state="translated">&lt;code&gt;%f[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt; , un &lt;em&gt;patr&amp;oacute;n de frontera&lt;/em&gt; ; dicho elemento coincide con una cadena vac&amp;iacute;a en cualquier posici&amp;oacute;n, de modo que el siguiente car&amp;aacute;cter pertenece al &lt;em&gt;conjunto&lt;/em&gt; y el car&amp;aacute;cter anterior no pertenece al &lt;em&gt;conjunto&lt;/em&gt; . El conjunto &lt;em&gt;conjunto&lt;/em&gt; se interpreta como se describi&amp;oacute; anteriormente. El principio y el final del tema se manejan como si fueran el car&amp;aacute;cter ' &lt;code&gt;\0&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="d1068a849784cb8f30e250147da15aaa395b0729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%g&lt;/code&gt;:  represents all printable characters except space.</source>
          <target state="translated">&lt;code&gt;%g&lt;/code&gt; : representa todos los caracteres imprimibles excepto el espacio.</target>
        </trans-unit>
        <trans-unit id="b46f710e58e77aaa525ff9403405ff161c474587" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%l&lt;/code&gt;:  represents all lowercase letters.</source>
          <target state="translated">&lt;code&gt;%l&lt;/code&gt; : representa todas las letras min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="00faa1ce628bd5bbd5ebfc1430bf64ce8032b2e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%p&lt;/code&gt;:  represents all punctuation characters.</source>
          <target state="translated">&lt;code&gt;%p&lt;/code&gt; : representa todos los caracteres de puntuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="409154041b5a8377f4c4a43f5e7a2daca1efae16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%s&lt;/code&gt;:  represents all space characters.</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt; : representa todos los caracteres de espacio.</target>
        </trans-unit>
        <trans-unit id="1d077077eba594eeb532db5bbbb344383bb9dc30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%u&lt;/code&gt;:  represents all uppercase letters.</source>
          <target state="translated">&lt;code&gt;%u&lt;/code&gt; : representa todas las letras may&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="c778e1666515254950019edcc8b53bc7994b2c06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%w&lt;/code&gt;:  represents all alphanumeric characters.</source>
          <target state="translated">&lt;code&gt;%w&lt;/code&gt; : representa todos los caracteres alfanum&amp;eacute;ricos.</target>
        </trans-unit>
        <trans-unit id="9d32033a43bf5e4d6d3a33f3c31f104d598f06a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%x&lt;/code&gt;:  represents all hexadecimal digits.</source>
          <target state="translated">&lt;code&gt;%x&lt;/code&gt; : representa todos los d&amp;iacute;gitos hexadecimales.</target>
        </trans-unit>
        <trans-unit id="321eb4eafd66d05c141a030945ca6e42e18477a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&lt;/code&gt;: bitwise AND</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; : bit a bit Y</target>
        </trans-unit>
        <trans-unit id="8997dce827f9650de2681505f986bfe4f56868cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;: right shift</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; : desplazamiento a la derecha</target>
        </trans-unit>
        <trans-unit id="09075062c64c86a8670a7f150b47a6e95e038431" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: greater than</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; : mayor que</target>
        </trans-unit>
        <trans-unit id="4cf6b41db6ebd22069687677e294b12324a1aa22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: sets big endian</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; : establece big endian</target>
        </trans-unit>
        <trans-unit id="84aa2a09e22da5344a9e8eb1d63a625c2e6ab9d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=&lt;/code&gt;: greater or equal</source>
          <target state="translated">&lt;code&gt;&amp;gt;=&lt;/code&gt; : mayor o igual</target>
        </trans-unit>
        <trans-unit id="e1e0a0e88d4b268783cec444b7830a1c8a905396" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;: left shift</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; : desplazamiento a la izquierda</target>
        </trans-unit>
        <trans-unit id="64760ee63a8e109d429eec539c3225463668a5c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: less than</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; : menor que</target>
        </trans-unit>
        <trans-unit id="0dc1199995acf8e834d1133c3d0ffe757a0c8c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: sets little endian</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; : establece little endian</target>
        </trans-unit>
        <trans-unit id="539e9a1a68d56527181e6fda1757b93c7bb90872" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;=&lt;/code&gt;: less or equal</source>
          <target state="translated">&lt;code&gt;&amp;lt;=&lt;/code&gt; : menor o igual</target>
        </trans-unit>
        <trans-unit id="d93e49b81b005f7b70f3e457112527bfdf5d8afa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt;: multiplication</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; : multiplicaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="5a896065ff143b8d4e4525f134563235b2836309" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt;: addition</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; : adici&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="3f2de6df8bf3e61510642c60648fc03fbc37107e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt;:  stop handling options;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e690d325ab205c7e3e2edc33dded7238d1e95e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt;:  stops handling options;</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; : detiene el manejo de opciones;</target>
        </trans-unit>
        <trans-unit id="3269a145a2cff5a46a814b390d0a3843be9fde31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;:  execute &lt;code&gt;stdin&lt;/code&gt; as a file and stop handling options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e30ca421360d9668078533affe3127fefa56922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;:  executes &lt;code&gt;stdin&lt;/code&gt; as a file and stops handling options.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; : ejecuta &lt;code&gt;stdin&lt;/code&gt; como un archivo y deja de manejar opciones.</target>
        </trans-unit>
        <trans-unit id="fe732ff63697204d0a3854b3dd684f5776ef0028" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;: subtraction</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; : resta</target>
        </trans-unit>
        <trans-unit id="769def5a060686cf3ed3fab103466f33fde9d1c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;: unary minus</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; : unario menos</target>
        </trans-unit>
        <trans-unit id="ce0e53259664648662edb9f1503737097f0dfb02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-E&lt;/code&gt;:  ignore environment variables;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a62c9dea412713fabd70b0572ce384a36c8975a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-E&lt;/code&gt;:  ignores environment variables;</source>
          <target state="translated">&lt;code&gt;-E&lt;/code&gt; : ignora las variables de entorno;</target>
        </trans-unit>
        <trans-unit id="34e7ee380cf18b6c041283d1ffc613935362b02d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-W&lt;/code&gt;:  turn warnings on;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83992f9bd2f910ee3bb40d66f1b26532dbf5cb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-e &lt;em&gt;stat&lt;/em&gt;&lt;/code&gt;:  execute string &lt;em&gt;stat&lt;/em&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666a8ef269cc241ff9e08c8b6b13c312ec6e0985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-e &lt;em&gt;stat&lt;/em&gt;&lt;/code&gt;:  executes string &lt;em&gt;stat&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-e &lt;em&gt;stat&lt;/em&gt;&lt;/code&gt; : ejecuta string &lt;em&gt;stat&lt;/em&gt; ;</target>
        </trans-unit>
        <trans-unit id="c0281012017d3ee240063454fe0e41787c693d52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-i&lt;/code&gt;:  enter interactive mode after running &lt;em&gt;script&lt;/em&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c08ce0d22173d753a71a183348f5899d3deb6286" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-i&lt;/code&gt;:  enters interactive mode after running &lt;em&gt;script&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-i&lt;/code&gt; : entra en modo interactivo despu&amp;eacute;s de ejecutar el &lt;em&gt;script&lt;/em&gt; ;</target>
        </trans-unit>
        <trans-unit id="974e83278ec05c54db4037ab148d266ad1e44ab2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-l &lt;em&gt;mod&lt;/em&gt;&lt;/code&gt;:  &quot;require&quot; &lt;em&gt;mod&lt;/em&gt; and assign the result to global &lt;em&gt;mod&lt;/em&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dacf10d39c10471335c9d03c807dc8f228a1a26f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-l &lt;em&gt;mod&lt;/em&gt;&lt;/code&gt;:  &quot;requires&quot; &lt;em&gt;mod&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-l &lt;em&gt;mod&lt;/em&gt;&lt;/code&gt; : &quot;requiere&quot; &lt;em&gt;mod&lt;/em&gt; ;</target>
        </trans-unit>
        <trans-unit id="48c58ee4c46816c1dbd48ba7285a214760ff3555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-v&lt;/code&gt;:  print version information;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb7b2827bd9676bf04daa9b6241bf4c4b937a87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-v&lt;/code&gt;:  prints version information;</source>
          <target state="translated">&lt;code&gt;-v&lt;/code&gt; : imprime informaci&amp;oacute;n de la versi&amp;oacute;n;</target>
        </trans-unit>
        <trans-unit id="380d1b565924cf193969bb6016e909adf7faad53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.&lt;/code&gt;:  (a dot) represents all characters.</source>
          <target state="translated">&lt;code&gt;.&lt;/code&gt; : (un punto) representa todos los caracteres.</target>
        </trans-unit>
        <trans-unit id="29471d9e07752a02a646c75289cc2200ed687ca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;//&lt;/code&gt;: floor division</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; : divisi&amp;oacute;n de piso</target>
        </trans-unit>
        <trans-unit id="e74818859a32b3c68f9a537da22031801f01b845" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/&lt;/code&gt;: float division</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; : divisi&amp;oacute;n flotante</target>
        </trans-unit>
        <trans-unit id="61efe208b861a62c6b51bce3253be1558c21c997" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;em&gt;explist&lt;/em&gt;&lt;/code&gt; is evaluated only once. Its results are an &lt;em&gt;iterator&lt;/em&gt; function, a &lt;em&gt;state&lt;/em&gt;, and an initial value for the first &lt;em&gt;iterator variable&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;explist&lt;/em&gt;&lt;/code&gt; se eval&amp;uacute;a solo una vez. Sus resultados son unafunci&amp;oacute;n de&lt;em&gt; iterador&lt;/em&gt; , un&lt;em&gt; estado&lt;/em&gt; y un valor inicial para la primera&lt;em&gt; variable de iterador&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="02c81725154593faf7b3b3f43b31b6aa30161b7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;em&gt;f&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt;, and &lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt; are invisible variables. The names are here for explanatory purposes only.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;f&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; y &lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt; son variables invisibles. Los nombres est&amp;aacute;n aqu&amp;iacute; solo con fines explicativos.</target>
        </trans-unit>
        <trans-unit id="562c795de59069a6c76dd75325349c2fc11e4bf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;&lt;em&gt;limit&lt;/em&gt;&lt;/code&gt;, and &lt;code&gt;&lt;em&gt;step&lt;/em&gt;&lt;/code&gt; are invisible variables. The names shown here are for explanatory purposes only.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;&lt;em&gt;limit&lt;/em&gt;&lt;/code&gt; y &lt;code&gt;&lt;em&gt;step&lt;/em&gt;&lt;/code&gt; son variables invisibles. Los nombres que se muestran aqu&amp;iacute; son solo para fines explicativos.</target>
        </trans-unit>
        <trans-unit id="2f71e0d38e440115b80b8062b2667073a2b99d24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;=&lt;/code&gt;: sets native endian</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; : establece endian nativo</target>
        </trans-unit>
        <trans-unit id="0a197dcb32b592a6117175ac588ba58ade78518a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt;: equality</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; : igualdad</target>
        </trans-unit>
        <trans-unit id="751cff1d44a9460c79c1d8247a3762226d5dc596" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;B&lt;/code&gt;: an unsigned byte (&lt;code&gt;char&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; : un byte sin firmar ( &lt;code&gt;char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="78939819671012d7b27e3304caefff90a2896e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;H&lt;/code&gt;: an unsigned &lt;code&gt;short&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;H&lt;/code&gt; : un &lt;code&gt;short&lt;/code&gt; sin firmar (tama&amp;ntilde;o nativo)</target>
        </trans-unit>
        <trans-unit id="7b789f63dd50ed7c3fda6b86e141977ab88fef74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;I[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: an unsigned &lt;code&gt;int&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; bytes (default is native size)</source>
          <target state="translated">&lt;code&gt;I[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : un &lt;code&gt;int&lt;/code&gt; sin firmar con &lt;code&gt;n&lt;/code&gt; bytes (el tama&amp;ntilde;o predeterminado es el nativo)</target>
        </trans-unit>
        <trans-unit id="fb9847bb7bda0dddeaa7102eb5ff82fef56363b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;J&lt;/code&gt;: a &lt;code&gt;lua_Unsigned&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;J&lt;/code&gt; : a &lt;code&gt;lua_Unsigned&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="684450a0b3b1fdd57e3aba433e9b9488eff7d191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;L&lt;/code&gt;: an unsigned &lt;code&gt;long&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; : &lt;code&gt;long&lt;/code&gt; sin firmar (tama&amp;ntilde;o nativo)</target>
        </trans-unit>
        <trans-unit id="27f93600b14adf35d6677fbf15d23ba38ce5ba29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOLLECT&lt;/code&gt;:  Performs a full garbage-collection cycle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c78f460ce68a552941c0b856d21bb1212d5c60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOLLECT&lt;/code&gt;:  performs a full garbage-collection cycle.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOLLECT&lt;/code&gt; : realiza un ciclo completo de recolecci&amp;oacute;n de basura.</target>
        </trans-unit>
        <trans-unit id="747500395594c67b24aa557bc180a4e3fe06553d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOUNT&lt;/code&gt;:  Returns the current amount of memory (in Kbytes) in use by Lua.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb5e716d218ca16ede442156a2c17fc22562d67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOUNT&lt;/code&gt;:  returns the current amount of memory (in Kbytes) in use by Lua.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOUNT&lt;/code&gt; : devuelve la cantidad actual de memoria (en Kbytes) en uso por Lua.</target>
        </trans-unit>
        <trans-unit id="78a3fcdfc44777c4235848891f60367d73a7240d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOUNTB&lt;/code&gt;:  Returns the remainder of dividing the current amount of bytes of memory in use by Lua by 1024.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a68d642e09792078a82b22bae5351cbaac81a3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOUNTB&lt;/code&gt;:  returns the remainder of dividing the current amount of bytes of memory in use by Lua by 1024.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOUNTB&lt;/code&gt; : devuelve el resto de dividir la cantidad actual de bytes de memoria en uso por Lua por 1024.</target>
        </trans-unit>
        <trans-unit id="1371f443b62c18860c20abf0482a2e79e8fde9c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCGEN&lt;/code&gt; (int minormul, int majormul):  Changes the collector to generational mode with the given parameters (see &lt;a href=&quot;#2.5.2&quot;&gt;&amp;sect;2.5.2&lt;/a&gt;). Returns the previous mode (&lt;code&gt;LUA_GCGEN&lt;/code&gt; or &lt;code&gt;LUA_GCINC&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60be1736f6e7d1a38750674de1bbd08ea5476e7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCINC&lt;/code&gt; (int pause, int stepmul, stepsize):  Changes the collector to incremental mode with the given parameters (see &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt;). Returns the previous mode (&lt;code&gt;LUA_GCGEN&lt;/code&gt; or &lt;code&gt;LUA_GCINC&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c950962077592b2b869b6743823b54de0fe765e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCISRUNNING&lt;/code&gt;:  Returns a boolean that tells whether the collector is running (i.e., not stopped).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c1ec01d66de8e0320c4d93348ae60d493d3e9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCISRUNNING&lt;/code&gt;:  returns a boolean that tells whether the collector is running (i.e., not stopped).</source>
          <target state="translated">&lt;code&gt;LUA_GCISRUNNING&lt;/code&gt; : devuelve un booleano que indica si el recopilador est&amp;aacute; en ejecuci&amp;oacute;n (es decir, no detenido).</target>
        </trans-unit>
        <trans-unit id="435724d252fc7b81107a6fac3397b96d3c576bc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCRESTART&lt;/code&gt;:  Restarts the garbage collector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2278ee01aaa7877800006c384258d197cbdf9bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCRESTART&lt;/code&gt;:  restarts the garbage collector.</source>
          <target state="translated">&lt;code&gt;LUA_GCRESTART&lt;/code&gt; : reinicia el recolector de basura.</target>
        </trans-unit>
        <trans-unit id="fa1ba56a5a60dabda23e38f6db79d5515a2addfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt;:  sets &lt;code&gt;data&lt;/code&gt; as the new value for the &lt;em&gt;pause&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;) and returns the previous value of the pause.</source>
          <target state="translated">&lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt; : establece &lt;code&gt;data&lt;/code&gt; como el nuevo valor para la &lt;em&gt;pausa&lt;/em&gt; del recolector (ver &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ) y devuelve el valor anterior de la pausa.</target>
        </trans-unit>
        <trans-unit id="3b218eaca4b6e9893a3e16aea485fd11554bfd2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt;:  sets &lt;code&gt;data&lt;/code&gt; as the new value for the &lt;em&gt;step multiplier&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;) and returns the previous value of the step multiplier.</source>
          <target state="translated">&lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt; : establece los &lt;code&gt;data&lt;/code&gt; como el nuevo valor del &lt;em&gt;multiplicador&lt;/em&gt; de &lt;em&gt;pasos&lt;/em&gt; del colector (ver &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ) y devuelve el valor anterior del multiplicador de pasos.</target>
        </trans-unit>
        <trans-unit id="1d7e799ac56c4ff839b3019633b438fb825a18fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSTEP&lt;/code&gt;:  performs an incremental step of garbage collection.</source>
          <target state="translated">&lt;code&gt;LUA_GCSTEP&lt;/code&gt; : realiza un paso incremental de recolecci&amp;oacute;n de basura.</target>
        </trans-unit>
        <trans-unit id="716d69e68a4c7b5d099f467b4dafa98467721c4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSTEP&lt;/code&gt;&lt;code&gt;(int stepsize)&lt;/code&gt;:  Performs an incremental step of garbage collection, corresponding to the allocation of &lt;code&gt;stepsize&lt;/code&gt; Kbytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3c6ec8067737770140406c5af8d2b5aa1652ec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSTOP&lt;/code&gt;:  Stops the garbage collector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450adac195733dc26043ca23487ff56033910e41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSTOP&lt;/code&gt;:  stops the garbage collector.</source>
          <target state="translated">&lt;code&gt;LUA_GCSTOP&lt;/code&gt; : detiene el recolector de basura.</target>
        </trans-unit>
        <trans-unit id="03ae56412dd5cb45458646b97dd071be591e5e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt;: a &lt;code&gt;size_t&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; : a &lt;code&gt;size_t&lt;/code&gt; (tama&amp;ntilde;o nativo)</target>
        </trans-unit>
        <trans-unit id="0a8a0f3d7f67d7fd79f7990d2b94e59b8a7b4375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;X&lt;em&gt;op&lt;/em&gt;&lt;/code&gt;: an empty item that aligns according to option &lt;code&gt;op&lt;/code&gt; (which is otherwise ignored)</source>
          <target state="translated">&lt;code&gt;X&lt;em&gt;op&lt;/em&gt;&lt;/code&gt; : un elemento vac&amp;iacute;o que se alinea de acuerdo con la opci&amp;oacute;n &lt;code&gt;op&lt;/code&gt; (que de lo contrario se ignora)</target>
        </trans-unit>
        <trans-unit id="6bce72d0d5e32b91f85c07cd8060a5d09dda59ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt;:  represents the class which is the union of all characters in &lt;em&gt;set&lt;/em&gt;. A range of characters can be specified by separating the end characters of the range, in ascending order, with a '&lt;code&gt;-&lt;/code&gt;'. All classes &lt;code&gt;%&lt;/code&gt;&lt;em&gt;x&lt;/em&gt; described above can also be used as components in &lt;em&gt;set&lt;/em&gt;. All other characters in &lt;em&gt;set&lt;/em&gt; represent themselves. For example, &lt;code&gt;[%w_]&lt;/code&gt; (or &lt;code&gt;[_%w]&lt;/code&gt;) represents all alphanumeric characters plus the underscore, &lt;code&gt;[0-7]&lt;/code&gt; represents the octal digits, and &lt;code&gt;[0-7%l%-]&lt;/code&gt; represents the octal digits plus the lowercase letters plus the '&lt;code&gt;-&lt;/code&gt;' character.</source>
          <target state="translated">&lt;code&gt;[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt; : representa la clase que es la uni&amp;oacute;n de todos los personajes del &lt;em&gt;conjunto&lt;/em&gt; . Se puede especificar un rango de caracteres separando los caracteres finales del rango, en orden ascendente, con un ' &lt;code&gt;-&lt;/code&gt; '. Todas las clases &lt;code&gt;%&lt;/code&gt; &lt;em&gt;x&lt;/em&gt; descritas anteriormente tambi&amp;eacute;n se pueden utilizar como componentes en el &lt;em&gt;conjunto&lt;/em&gt; . Todos los dem&amp;aacute;s personajes del &lt;em&gt;set se&lt;/em&gt; representan a s&amp;iacute; mismos. Por ejemplo, &lt;code&gt;[%w_]&lt;/code&gt; (o &lt;code&gt;[_%w]&lt;/code&gt; ) representa todos los caracteres alfanum&amp;eacute;ricos m&amp;aacute;s el gui&amp;oacute;n bajo, &lt;code&gt;[0-7]&lt;/code&gt; representa los d&amp;iacute;gitos octales y &lt;code&gt;[0-7%l%-]&lt;/code&gt; representa los d&amp;iacute;gitos octales m&amp;aacute;s las min&amp;uacute;sculas letras m&amp;aacute;s el car&amp;aacute;cter ' &lt;code&gt;-&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="2bfa8d127c2e8935e2fff05f79f71c951f40cbb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt;:  represents the complement of &lt;em&gt;set&lt;/em&gt;, where &lt;em&gt;set&lt;/em&gt; is interpreted as above.</source>
          <target state="translated">&lt;code&gt;[^&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt; : representa el complemento de &lt;em&gt;set&lt;/em&gt; , donde &lt;em&gt;set&lt;/em&gt; se interpreta como arriba.</target>
        </trans-unit>
        <trans-unit id="f38e7d51801e02a7747b20500a8b2e632836efe3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;: exponentiation</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; : exponenciaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="f5b98943f5025fa1cf7612c16dfff443caedc2b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__add&lt;/code&gt;:  the addition (&lt;code&gt;+&lt;/code&gt;) operation. If any operand for an addition is not a number (nor a string coercible to a number), Lua will try to call a metamethod. First, Lua will check the first operand (even if it is valid). If that operand does not define a metamethod for &lt;code&gt;__add&lt;/code&gt;, then Lua will check the second operand. If Lua can find a metamethod, it calls the metamethod with the two operands as arguments, and the result of the call (adjusted to one value) is the result of the operation. Otherwise, it raises an error.</source>
          <target state="translated">&lt;code&gt;__add&lt;/code&gt; : la operaci&amp;oacute;n de suma ( &lt;code&gt;+&lt;/code&gt; ). Si alg&amp;uacute;n operando de una suma no es un n&amp;uacute;mero (ni una cadena coercible a un n&amp;uacute;mero), Lua intentar&amp;aacute; llamar a un metam&amp;eacute;todo. Primero, Lua verificar&amp;aacute; el primer operando (incluso si es v&amp;aacute;lido). Si ese operando no define un metam&amp;eacute;todo para &lt;code&gt;__add&lt;/code&gt; , entonces Lua verificar&amp;aacute; el segundo operando. Si Lua puede encontrar un metam&amp;eacute;todo, llama al metam&amp;eacute;todo con los dos operandos como argumentos, y el resultado de la llamada (ajustado a un valor) es el resultado de la operaci&amp;oacute;n. De lo contrario, genera un error.</target>
        </trans-unit>
        <trans-unit id="1b6202fc2a36ce090174d453bc1dc37d30445ac3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__add&lt;/code&gt;:  the addition (&lt;code&gt;+&lt;/code&gt;) operation. If any operand for an addition is not a number, Lua will try to call a metamethod. It starts by checking the first operand (even if it is a number); if that operand does not define a metamethod for &lt;code&gt;__add&lt;/code&gt;, then Lua will check the second operand. If Lua can find a metamethod, it calls the metamethod with the two operands as arguments, and the result of the call (adjusted to one value) is the result of the operation. Otherwise, if no metamethod is found, Lua raises an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18498456a66957bd192a02e96a430d684b766b36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__band&lt;/code&gt;:  the bitwise AND (&lt;code&gt;&amp;amp;&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod if any operand is neither an integer nor a float coercible to an integer (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda95a3552fcf7eb5fbbb735dac806d610f70311" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__band&lt;/code&gt;:  the bitwise AND (&lt;code&gt;&amp;amp;&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod if any operand is neither an integer nor a value coercible to an integer (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;__band&lt;/code&gt; : la operaci&amp;oacute;n AND ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) bit a bit . Comportamiento similar a la operaci&amp;oacute;n de suma, excepto que Lua probar&amp;aacute; un metam&amp;eacute;todo si alg&amp;uacute;n operando no es un n&amp;uacute;mero entero ni un valor coercible a un n&amp;uacute;mero entero (ver &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8271d8f21a0a60ed616ec9f38e97d661ff31836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__bnot&lt;/code&gt;:  the bitwise NOT (unary &lt;code&gt;~&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__bnot&lt;/code&gt; : la operaci&amp;oacute;n NOT (unaria &lt;code&gt;~&lt;/code&gt; ) bit a bit . Comportamiento similar al de la operaci&amp;oacute;n AND bit a bit.</target>
        </trans-unit>
        <trans-unit id="9e9026d2ac8c089b351feccecbb25019aa6cc74f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__bor&lt;/code&gt;:  the bitwise OR (&lt;code&gt;|&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__bor&lt;/code&gt; : la operaci&amp;oacute;n OR ( &lt;code&gt;|&lt;/code&gt; ) bit a bit . Comportamiento similar al de la operaci&amp;oacute;n AND bit a bit.</target>
        </trans-unit>
        <trans-unit id="3984b6f7c6542cb91c472a68f850228f86078c2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__bxor&lt;/code&gt;:  the bitwise exclusive OR (binary &lt;code&gt;~&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__bxor&lt;/code&gt; : la operaci&amp;oacute;n OR (binaria &lt;code&gt;~&lt;/code&gt; ) exclusiva bit a bit . Comportamiento similar al de la operaci&amp;oacute;n AND bit a bit.</target>
        </trans-unit>
        <trans-unit id="47f84fd28e5003b12c1cddb7e1213ad73677ce7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__call&lt;/code&gt;:  The call operation &lt;code&gt;func(args)&lt;/code&gt;. This event happens when Lua tries to call a non-function value (that is, &lt;code&gt;func&lt;/code&gt; is not a function). The metamethod is looked up in &lt;code&gt;func&lt;/code&gt;. If present, the metamethod is called with &lt;code&gt;func&lt;/code&gt; as its first argument, followed by the arguments of the original call (&lt;code&gt;args&lt;/code&gt;). All results of the call are the result of the operation. (This is the only metamethod that allows multiple results.)</source>
          <target state="translated">&lt;code&gt;__call&lt;/code&gt; : La operaci&amp;oacute;n de llamada &lt;code&gt;func(args)&lt;/code&gt; . Este evento ocurre cuando Lua intenta llamar a un valor que no es una funci&amp;oacute;n (es decir, &lt;code&gt;func&lt;/code&gt; no es una funci&amp;oacute;n). El metam&amp;eacute;todo se busca en &lt;code&gt;func&lt;/code&gt; . Si est&amp;aacute; presente, el metam&amp;eacute;todo se llama con &lt;code&gt;func&lt;/code&gt; como primer argumento, seguido de los argumentos de la llamada original ( &lt;code&gt;args&lt;/code&gt; ). Todos los resultados de la llamada son el resultado de la operaci&amp;oacute;n. (Este es el &amp;uacute;nico metam&amp;eacute;todo que permite m&amp;uacute;ltiples resultados).</target>
        </trans-unit>
        <trans-unit id="cc5ab9ce81ff33275f7c4ff325d4c8b1c70cd0ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__call&lt;/code&gt;:  The call operation &lt;code&gt;func(args)&lt;/code&gt;. This event happens when Lua tries to call a non-function value (that is, &lt;code&gt;func&lt;/code&gt; is not a function). The metamethod is looked up in &lt;code&gt;func&lt;/code&gt;. If present, the metamethod is called with &lt;code&gt;func&lt;/code&gt; as its first argument, followed by the arguments of the original call (&lt;code&gt;args&lt;/code&gt;). All results of the call are the results of the operation. This is the only metamethod that allows multiple results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790454d48e53027f216e2bf64f3530d0774dee89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__concat&lt;/code&gt;:  the concatenation (&lt;code&gt;..&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod if any operand is neither a string nor a number (which is always coercible to a string).</source>
          <target state="translated">&lt;code&gt;__concat&lt;/code&gt; : la operaci&amp;oacute;n de concatenaci&amp;oacute;n ( &lt;code&gt;..&lt;/code&gt; ). Comportamiento similar a la operaci&amp;oacute;n de suma, excepto que Lua probar&amp;aacute; un metam&amp;eacute;todo si alg&amp;uacute;n operando no es ni una cadena ni un n&amp;uacute;mero (que siempre es coercible a una cadena).</target>
        </trans-unit>
        <trans-unit id="ad91de859a0158bed21ee979ae23cedc031843c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__div&lt;/code&gt;:  the division (&lt;code&gt;/&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__div&lt;/code&gt; : la operaci&amp;oacute;n de divisi&amp;oacute;n ( &lt;code&gt;/&lt;/code&gt; ). Comportamiento similar al de la operaci&amp;oacute;n de suma.</target>
        </trans-unit>
        <trans-unit id="7344afb47ab39dbb1dcc686092dbb2c33112ca27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__eq&lt;/code&gt;:  the equal (&lt;code&gt;==&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod only when the values being compared are either both tables or both full userdata and they are not primitively equal. The result of the call is always converted to a boolean.</source>
          <target state="translated">&lt;code&gt;__eq&lt;/code&gt; : la operaci&amp;oacute;n de igualdad ( &lt;code&gt;==&lt;/code&gt; ). Comportamiento similar a la operaci&amp;oacute;n de adici&amp;oacute;n, excepto que Lua probar&amp;aacute; un metam&amp;eacute;todo solo cuando los valores que se comparan sean ambas tablas o ambos datos de usuario completos y no sean primitivamente iguales. El resultado de la llamada siempre se convierte en booleano.</target>
        </trans-unit>
        <trans-unit id="e98db71bbf36f23352f716c30f1f7a8ecfbe62c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__idiv&lt;/code&gt;:  the floor division (&lt;code&gt;//&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__idiv&lt;/code&gt; : la operaci&amp;oacute;n de divisi&amp;oacute;n de piso ( &lt;code&gt;//&lt;/code&gt; ). Comportamiento similar al de la operaci&amp;oacute;n de suma.</target>
        </trans-unit>
        <trans-unit id="decd7b7eb1b7416a469f2fca59f8e4ddd7f2a85d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__index&lt;/code&gt;:  The indexing access &lt;code&gt;table[key]&lt;/code&gt;. This event happens when &lt;code&gt;table&lt;/code&gt; is not a table or when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;. The metamethod is looked up in &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__index&lt;/code&gt; : la &lt;code&gt;table[key]&lt;/code&gt; acceso de indexaci&amp;oacute;n [clave] . Este evento ocurre cuando la &lt;code&gt;table&lt;/code&gt; no es una tabla o cuando la &lt;code&gt;key&lt;/code&gt; no est&amp;aacute; presente en la &lt;code&gt;table&lt;/code&gt; . El metam&amp;eacute;todo se busca en la &lt;code&gt;table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59d5cdb5e9bebf293df5f5c2dd03e9513439b94b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__index&lt;/code&gt;:  The indexing access operation &lt;code&gt;table[key]&lt;/code&gt;. This event happens when &lt;code&gt;table&lt;/code&gt; is not a table or when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;. The metavalue is looked up in the metatable of &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0aff1ea5b89de9eaeaf8c0b5dcd3b5677be316c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__le&lt;/code&gt;:  the less equal (&lt;code&gt;&amp;lt;=&lt;/code&gt;) operation. Behavior similar to the less than operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f475d84a338693db6fd2862596f21c01f8175167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__le&lt;/code&gt;:  the less equal (&lt;code&gt;&amp;lt;=&lt;/code&gt;) operation. Unlike other operations, the less-equal operation can use two different events. First, Lua looks for the &lt;code&gt;__le&lt;/code&gt; metamethod in both operands, like in the less than operation. If it cannot find such a metamethod, then it will try the &lt;code&gt;__lt&lt;/code&gt; metamethod, assuming that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; is equivalent to &lt;code&gt;not (b &amp;lt; a)&lt;/code&gt;. As with the other comparison operators, the result is always a boolean. (This use of the &lt;code&gt;__lt&lt;/code&gt; event can be removed in future versions; it is also slower than a real &lt;code&gt;__le&lt;/code&gt; metamethod.)</source>
          <target state="translated">&lt;code&gt;__le&lt;/code&gt; : la operaci&amp;oacute;n menos igual ( &lt;code&gt;&amp;lt;=&lt;/code&gt; ). A diferencia de otras operaciones, la operaci&amp;oacute;n menos igual puede utilizar dos eventos diferentes. Primero, Lua busca el &lt;code&gt;__le&lt;/code&gt; __le en ambos operandos, como en la operaci&amp;oacute;n menor que. Si no puede encontrar dicho metam&amp;eacute;todo, probar&amp;aacute; el &lt;code&gt;__lt&lt;/code&gt; __lt, asumiendo que &lt;code&gt;a &amp;lt;= b&lt;/code&gt; es equivalente a &lt;code&gt;not (b &amp;lt; a)&lt;/code&gt; . Al igual que con los otros operadores de comparaci&amp;oacute;n, el resultado siempre es un booleano. (Este uso del evento &lt;code&gt;__lt&lt;/code&gt; se puede eliminar en versiones futuras; tambi&amp;eacute;n es m&amp;aacute;s lento que un &lt;code&gt;__le&lt;/code&gt; __le real ).</target>
        </trans-unit>
        <trans-unit id="c61fb722a1eddfcc88f7846f65e68ff08a2c65a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__len&lt;/code&gt;:  the length (&lt;code&gt;#&lt;/code&gt;) operation. If the object is not a string, Lua will try its metamethod. If there is a metamethod, Lua calls it with the object as argument, and the result of the call (always adjusted to one value) is the result of the operation. If there is no metamethod but the object is a table, then Lua uses the table length operation (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). Otherwise, Lua raises an error.</source>
          <target state="translated">&lt;code&gt;__len&lt;/code&gt; : la operaci&amp;oacute;n de longitud ( &lt;code&gt;#&lt;/code&gt; ). Si el objeto no es una cadena, Lua probar&amp;aacute; su metam&amp;eacute;todo. Si hay un metam&amp;eacute;todo, Lua lo llama con el objeto como argumento, y el resultado de la llamada (siempre ajustado a un valor) es el resultado de la operaci&amp;oacute;n. Si no hay metam&amp;eacute;todo, pero el objeto es una tabla, entonces Lua usa la operaci&amp;oacute;n de longitud de tabla (ver &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; ). De lo contrario, Lua genera un error.</target>
        </trans-unit>
        <trans-unit id="a3f09e158abb0f75d49c8c192f65fc3df9096218" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__lt&lt;/code&gt;:  the less than (&lt;code&gt;&amp;lt;&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod only when the values being compared are neither both numbers nor both strings. Moreover, the result of the call is always converted to a boolean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6902b36544db7b8d689de0371d69c1173727d394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__lt&lt;/code&gt;:  the less than (&lt;code&gt;&amp;lt;&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod only when the values being compared are neither both numbers nor both strings. The result of the call is always converted to a boolean.</source>
          <target state="translated">&lt;code&gt;__lt&lt;/code&gt; : la operaci&amp;oacute;n menor que ( &lt;code&gt;&amp;lt;&lt;/code&gt; ). Comportamiento similar al de la operaci&amp;oacute;n de suma, excepto que Lua intentar&amp;aacute; un metam&amp;eacute;todo solo cuando los valores que se comparan no sean ni n&amp;uacute;meros ni cadenas. El resultado de la llamada siempre se convierte en booleano.</target>
        </trans-unit>
        <trans-unit id="a925135fe1afbe74d4fe523a8c1e22003b5c4f3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__mod&lt;/code&gt;:  the modulo (&lt;code&gt;%&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__mod&lt;/code&gt; : la operaci&amp;oacute;n m&amp;oacute;dulo ( &lt;code&gt;%&lt;/code&gt; ). Comportamiento similar al de la operaci&amp;oacute;n de suma.</target>
        </trans-unit>
        <trans-unit id="1ff94de42579b732d623fc7c57cf9f6691cc124d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__mul&lt;/code&gt;:  the multiplication (&lt;code&gt;*&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__mul&lt;/code&gt; : la operaci&amp;oacute;n de multiplicaci&amp;oacute;n ( &lt;code&gt;*&lt;/code&gt; ). Comportamiento similar al de la operaci&amp;oacute;n de suma.</target>
        </trans-unit>
        <trans-unit id="bae10caba1f39db8a0508384a96106120784c41c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__newindex&lt;/code&gt;:  The indexing assignment &lt;code&gt;table[key] = value&lt;/code&gt;. Like the index event, this event happens when &lt;code&gt;table&lt;/code&gt; is not a table or when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;. The metamethod is looked up in &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__newindex&lt;/code&gt; : la &lt;code&gt;table[key] = value&lt;/code&gt; asignaci&amp;oacute;n de indexaci&amp;oacute;n [clave] = valor . Al igual que el evento de &amp;iacute;ndice, este evento ocurre cuando la &lt;code&gt;table&lt;/code&gt; no es una tabla o cuando la &lt;code&gt;key&lt;/code&gt; no est&amp;aacute; presente en la &lt;code&gt;table&lt;/code&gt; . El metam&amp;eacute;todo se busca en la &lt;code&gt;table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37937b6c573bf13ae1a75afc6ee8004d166493cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__newindex&lt;/code&gt;:  The indexing assignment &lt;code&gt;table[key] = value&lt;/code&gt;. Like the index event, this event happens when &lt;code&gt;table&lt;/code&gt; is not a table or when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;. The metavalue is looked up in the metatable of &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7488b0be1bc57b10dfdfc405a5e990f26a432a65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__pow&lt;/code&gt;:  the exponentiation (&lt;code&gt;^&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__pow&lt;/code&gt; : la operaci&amp;oacute;n de exponenciaci&amp;oacute;n ( &lt;code&gt;^&lt;/code&gt; ). Comportamiento similar al de la operaci&amp;oacute;n de suma.</target>
        </trans-unit>
        <trans-unit id="fc7215a1c4f0ddfcac8bc0abef79b38818065a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__shl&lt;/code&gt;:  the bitwise left shift (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__shl&lt;/code&gt; : la operaci&amp;oacute;n de desplazamiento a la izquierda ( &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ) bit a bit . Comportamiento similar al de la operaci&amp;oacute;n AND bit a bit.</target>
        </trans-unit>
        <trans-unit id="8da8f661ba59d8ea368c0a166410be846f25ed51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__shr&lt;/code&gt;:  the bitwise right shift (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__shr&lt;/code&gt; : la operaci&amp;oacute;n de desplazamiento a la derecha ( &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ) bit a bit . Comportamiento similar al de la operaci&amp;oacute;n AND bit a bit.</target>
        </trans-unit>
        <trans-unit id="0839e6023e2c19b90e41d7d692715ae3bb15dd52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__sub&lt;/code&gt;:  the subtraction (&lt;code&gt;-&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__sub&lt;/code&gt; : la operaci&amp;oacute;n de resta ( &lt;code&gt;-&lt;/code&gt; ). Comportamiento similar al de la operaci&amp;oacute;n de suma.</target>
        </trans-unit>
        <trans-unit id="a0a7b7005a2b1ce8342934d9e28b702f6591bbad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__unm&lt;/code&gt;:  the negation (unary &lt;code&gt;-&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__unm&lt;/code&gt; : la operaci&amp;oacute;n de negaci&amp;oacute;n (unaria &lt;code&gt;-&lt;/code&gt; ). Comportamiento similar al de la operaci&amp;oacute;n de suma.</target>
        </trans-unit>
        <trans-unit id="2034132fb0cda57893ded314ea78d570a3b8a1a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;: a signed byte (&lt;code&gt;char&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; : un byte firmado ( &lt;code&gt;char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1f9d27a224e5a678dfac01895e2774339ad358a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;: a fixed-sized string with &lt;code&gt;n&lt;/code&gt; bytes</source>
          <target state="translated">&lt;code&gt;c&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; : una cadena de tama&amp;ntilde;o fijo con &lt;code&gt;n&lt;/code&gt; bytes</target>
        </trans-unit>
        <trans-unit id="8a348caeedd88744c534e1a1de7a7057020a92eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkname&lt;/code&gt; is used as the name of the chunk for error messages and debug information (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). When absent, it defaults to &lt;code&gt;chunk&lt;/code&gt;, if &lt;code&gt;chunk&lt;/code&gt; is a string, or to &quot;&lt;code&gt;=(load)&lt;/code&gt;&quot; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007ab16ec0f7187cc23f5c4f0e1b0b9ee75de945" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkname&lt;/code&gt; is used as the name of the chunk for error messages and debug information (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;). When absent, it defaults to &lt;code&gt;chunk&lt;/code&gt;, if &lt;code&gt;chunk&lt;/code&gt; is a string, or to &quot;&lt;code&gt;=(load)&lt;/code&gt;&quot; otherwise.</source>
          <target state="translated">&lt;code&gt;chunkname&lt;/code&gt; se usa como el nombre del fragmento para mensajes de error e informaci&amp;oacute;n de depuraci&amp;oacute;n (consulte &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt; ). Cuando est&amp;aacute; ausente, por defecto es &lt;code&gt;chunk&lt;/code&gt; , si &lt;code&gt;chunk&lt;/code&gt; es una cadena, o &quot; &lt;code&gt;=(load)&lt;/code&gt; &quot; en caso contrario.</target>
        </trans-unit>
        <trans-unit id="d532eddb006ab7874f0dc6fb8cbdceb76c478728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;currentline&lt;/code&gt;:  the current line where the given function is executing. When no line information is available, &lt;code&gt;currentline&lt;/code&gt; is set to -1.</source>
          <target state="translated">&lt;code&gt;currentline&lt;/code&gt; : la l&amp;iacute;nea actual donde se est&amp;aacute; ejecutando la funci&amp;oacute;n dada. Cuando no hay informaci&amp;oacute;n de l&amp;iacute;nea disponible, &lt;code&gt;currentline&lt;/code&gt; se establece en -1.</target>
        </trans-unit>
        <trans-unit id="166b1d8e53dd83b1f49810b36d2120d5fb8cf928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt;: a &lt;code&gt;double&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; : un &lt;code&gt;double&lt;/code&gt; (tama&amp;ntilde;o nativo)</target>
        </trans-unit>
        <trans-unit id="0e1028744aa421b0605c6b88904012494c91f125" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;: a &lt;code&gt;float&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; : un &lt;code&gt;float&lt;/code&gt; (tama&amp;ntilde;o nativo)</target>
        </trans-unit>
        <trans-unit id="74c283dd60f0873bd6aa5ca9d2cc894957dbcba9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ftransfer&lt;/code&gt;:  the index in the stack of the first value being &quot;transferred&quot;, that is, parameters in a call or return values in a return. (The other values are in consecutive indices.) Using this index, you can access and modify these values through &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lua_setlocal&quot;&gt;&lt;code&gt;lua_setlocal&lt;/code&gt;&lt;/a&gt;. This field is only meaningful during a call hook, denoting the first parameter, or a return hook, denoting the first value being returned. (For call hooks, this value is always 1.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c592f8c4c1d4f47249d70ff1f5e192a26d8afe2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h&lt;/code&gt;: a signed &lt;code&gt;short&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; : un &lt;code&gt;short&lt;/code&gt; firmado (tama&amp;ntilde;o nativo)</target>
        </trans-unit>
        <trans-unit id="f5282762e143fb0df1d1386e42490a8eef06c695" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: a signed &lt;code&gt;int&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; bytes (default is native size)</source>
          <target state="translated">&lt;code&gt;i[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : un &lt;code&gt;int&lt;/code&gt; firmado con &lt;code&gt;n&lt;/code&gt; bytes (el tama&amp;ntilde;o predeterminado es el nativo)</target>
        </trans-unit>
        <trans-unit id="77b05e59859fe1e74f32e61593a0eca919f3206e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;istailcall&lt;/code&gt;:  true if this function invocation was called by a tail call. In this case, the caller of this level is not in the stack.</source>
          <target state="translated">&lt;code&gt;istailcall&lt;/code&gt; : verdadero si esta invocaci&amp;oacute;n de funci&amp;oacute;n fue llamada por una llamada de cola. En este caso, la persona que llama de este nivel no est&amp;aacute; en la pila.</target>
        </trans-unit>
        <trans-unit id="d69e22a542b48170e894be5d97f55fd47a232538" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isvararg&lt;/code&gt;:  true if the function is a vararg function (always true for C functions).</source>
          <target state="translated">&lt;code&gt;isvararg&lt;/code&gt; : verdadero si la funci&amp;oacute;n es una funci&amp;oacute;n vararg (siempre verdadero para funciones C).</target>
        </trans-unit>
        <trans-unit id="580dc9d1e4e90c03d788258153e5988096093196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;j&lt;/code&gt;: a &lt;code&gt;lua_Integer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;j&lt;/code&gt; : un &lt;code&gt;lua_Integer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e758d0de7cc3d0f062a6819b73437ee9ec2a2b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l&lt;/code&gt;: a signed &lt;code&gt;long&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; : &lt;code&gt;long&lt;/code&gt; firmado (tama&amp;ntilde;o nativo)</target>
        </trans-unit>
        <trans-unit id="f04a40c17b42b18f44495a16f52bfd52196ef418" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastlinedefined&lt;/code&gt;:  the line number where the definition of the function ends.</source>
          <target state="translated">&lt;code&gt;lastlinedefined&lt;/code&gt; : el n&amp;uacute;mero de l&amp;iacute;nea donde termina la definici&amp;oacute;n de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6ac83d3c96d2336c0ded704acb6714bea3c3ee52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt; cannot be less than the amount of C stack in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b070ad7d6ea6422e9596856316726e2174909f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt; must be less than 40000;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c558e7acb9233839c3055af52ec8d17bbbf36292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linedefined&lt;/code&gt;:  the line number where the definition of the function starts.</source>
          <target state="translated">&lt;code&gt;linedefined&lt;/code&gt; : el n&amp;uacute;mero de l&amp;iacute;nea donde comienza la definici&amp;oacute;n de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1814936b717a437d1f1941926869384106ce1392" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addchar&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addchar&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="b1e57ff274ef17e50c46ffbd715233aaa7df55ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addgsub&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="575546c5b83ac45ad492ca8e44de50943cdf9d36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addlstring&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addlstring&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ab2404026db427b81b929835fcc07320d0975966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addsize&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_addsize&lt;/code&gt; [- ?, + ?, -]</target>
        </trans-unit>
        <trans-unit id="6af536d80928bc10905ab3dce78e92ea76d54e77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addstring&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addstring&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f62f4ab7ab22c41889b8409e3b36723d81cabada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addvalue&lt;/code&gt;[-1, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addvalue&lt;/code&gt; [-1, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="32a97bb778b383afdcf82dbf302e1156a6cc0b2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_argcheck&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_argcheck&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="d807e00e947d759f9dcb553ac98ec1f1193a93e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_argerror&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_argerror&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e9d8a6e29589fc9f48f67f5632ab60dddf31d961" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_argexpected&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0420a8349297f3b02777896ea75e70b714d30a97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_buffaddr&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db817fce2c3b28619d23198a312e17e8c0b41fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_buffinit&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_buffinit&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="76b56ecab1b6154600ac285b1b29eb963a213f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_buffinitsize&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_buffinitsize&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="9012e6948fc3b64a531d97cabf645c5589aeecce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_bufflen&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4194d04d8f4c00f06cf19700bff56f0807a46c6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_buffsub&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15797d76578ab05f141375478dbdaccf46d64197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_callmeta&lt;/code&gt;[-0, +(0|1), &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_callmeta&lt;/code&gt; [-0, + (0 | 1), &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="85267089380208d1670ba57aca773cbfd01c3852" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkany&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkany&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="60a4f7f116afbde74193d5e8eb007754d432edfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkinteger&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkinteger&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="caad9f257f912ca30f4e0c4103ba996c9420a91b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checklstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checklstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="fb3b4e49519cf5dbd32c138191f993b8dc2a1534" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checknumber&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checknumber&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="38dfb40ea1a004fd0d2b69fead480d9a49d8202a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkoption&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkoption&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="322257f7e30d47626338ffdee9062b057e90cd8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkstack&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkstack&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="817bb0029ff7aff6991eab710b919497a5dbc912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="341111dc53b49f417dcd96b3fc29b039a26ba056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checktype&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checktype&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="12123157de5a720309f6a7c63a2cfa0c299903b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkudata&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkudata&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="dffa7856bb9be8c95d07d1f17dadf607bf429ad1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkversion&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkversion&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="3374658d775d8aa7fb8fe52da4e6fc7cfd927d02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_dofile&lt;/code&gt;[-0, +?, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_dofile&lt;/code&gt; [-0, + ?, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="200e70cd43edc635af7b5f245c095858f2496ed5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_dofile&lt;/code&gt;[-0, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a582cca705f2cb3830ac7257f0eb21203b6e929b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_dostring&lt;/code&gt;[-0, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_dostring&lt;/code&gt; [-0, + ?, -]</target>
        </trans-unit>
        <trans-unit id="a5a15bfcee6d520f8c55a01f53ed494d8d316be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_error&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_error&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6faffe57f68b2e507d46bda2d67142fcf1bd3eda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_execresult&lt;/code&gt;[-0, +3, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_execresult&lt;/code&gt; [-0, +3, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="689d9709c543e39ba4b14f659761c6fbee59fb20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_fileresult&lt;/code&gt;[-0, +(1|3), &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_fileresult&lt;/code&gt; [-0, + (1 | 3), &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="26ad671f853e795fc32c1842c210c309e5737a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_getmetafield&lt;/code&gt;[-0, +(0|1), &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_getmetafield&lt;/code&gt; [-0, + (0 | 1), &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="86627657b2139b0ee31a53c83ad51ed9c63ee4f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_getmetatable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_getmetatable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f0429bf39eeee8b432bf2c4ac915eb9bd9c58fe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_getsubtable&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_getsubtable&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="dcbde4eb043fd7a6a88005560668c86e718f4d64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_gsub&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_gsub&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6aa13480ee4b2afee4725e8c33c17ccef37dacb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_len&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_len&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1ff1186e40e0c45fe6b82e0cd030ddaab25d3514" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadbuffer&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_loadbuffer&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="5c9c6205f5ab035f8481cc23adec6d68a927c21e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadbufferx&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_loadbufferx&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="3efa8a062aa5c6fd99fa30d9a6b615805d5f6633" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadfile&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_loadfile&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="bed752688a8097a24d7fe06f2d44fb3b8104d51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadfilex&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_loadfilex&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a1117ad9189ec1e73f1b81cc6ca7a6ca13b4d08a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadstring&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_loadstring&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="7006cdeb7d6e0f06f8bd85a3e8e67991899f625c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newlib&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_newlib&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="4bb6d574631ce0eb10e53ee60cc236afb57494d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newlibtable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_newlibtable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1597a9788daec91a227c519bb2f818e05f9f4c08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newmetatable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_newmetatable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ce4b485fbcd4cc791900d08f23c6cdfdec7f1520" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newstate&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_newstate&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="49f8165e8132fcb469103de8892f176c1f0def64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_openlibs&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_openlibs&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="db3705a693651e2352b4cd9e06f038a5145d3eed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_opt&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83750c461dfda8dcc3cadb263ef7f900676721c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_opt&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_opt&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7ddba39b66f773750f9ae187c2d2d76d0f89ac96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optinteger&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optinteger&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="2fcf8ecf5a60e1bef873c06be25a18130a4d742f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optlstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optlstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="9f89308fc4e4595c99a38d039175c1137359ac54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optnumber&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optnumber&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="274c9ca5ceedb91c17aae3f6a7353a8fe5343712" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7a41c18601fede06cd92afc10561621476415195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_prepbuffer&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_prepbuffer&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6dd4e822d50779a6e2f55486d474e3cf4dc9a3a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_prepbuffsize&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_prepbuffsize&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0d062e1490417f3389611ce549b989dea09db184" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_pushfail&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c1792dcbf5df89608d53cfa3c381e725d7c8dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_pushresult&lt;/code&gt;[-?, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_pushresult&lt;/code&gt; [- ?, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="56aef86b4910793d510e049e250c4ba15d08651b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_pushresultsize&lt;/code&gt;[-?, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_pushresultsize&lt;/code&gt; [- ?, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="cf9ba081e7beac774ea13e9e5e96e368f77f91b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_ref&lt;/code&gt;[-1, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_ref&lt;/code&gt; [-1, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="964377d76c6003fa09c52e382c6f30d89d8e7733" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_requiref&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_requiref&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0fa64c78fb075f6bccbf9d15ca226451decea5ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_setfuncs&lt;/code&gt;[-nup, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_setfuncs&lt;/code&gt; [-nup, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="2e5d3d14dd1ede554838763a71c2eb2b30f00e10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_setmetatable&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_setmetatable&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="b4785fa0b78405754bdd9e6816e0505e89bb2ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_testudata&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_testudata&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="87fa79dd9413aed4e20cd6a034ba315882e2e0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_tolstring&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_tolstring&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="306b764f016817d71c097f8443a6177598555795" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_traceback&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_traceback&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1681fbfd259c145321f77c918190a06410715131" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_typeerror&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca032fc0be8f16a7dbcab71e66bfe7be88723983" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_typename&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_typename&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="f49e88ae95e2c08d4f66fb932d9bcde472eca71a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_unref&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_unref&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="e61c1eb9f0ad1ce243ab6024b692ea269b6a3ddc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_where&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_where&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="990854d58117af3aa9e8e4765776b83ce30f5cb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_absindex&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_absindex&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="b1819f228761942b7921d51557a46ebabdfda1ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_arith&lt;/code&gt;[-(2|1), +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_arith&lt;/code&gt; [- (2 | 1), +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f24f91865ac7127a8413e2ae152416f6c2ed006b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_atpanic&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_atpanic&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="e7479fe5b0585be43d2a995bebe0c8255ad26bbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_call&lt;/code&gt;[-(nargs+1), +nresults, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_call&lt;/code&gt; [- (nargs + 1), + nresults, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="c65d2f6c1099ba05a81459947c26df8cf58a8ea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_callk&lt;/code&gt;[-(nargs + 1), +nresults, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_callk&lt;/code&gt; [- (nargs + 1), + nresults, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="acf13cf1bfb7ad750c4fa45422c658708c5d250e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_checkstack&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_checkstack&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="ce69674693f57931d2d994412ec490a58883fe0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_close&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_close&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="9f95f6e80bc09c2b612082485467d037fdabd286" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_compare&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_compare&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a04bab7507101355ee6351af1abfc06a7108a08a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_concat&lt;/code&gt;[-n, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_concat&lt;/code&gt; [-n, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="814bbfd9c45c7f18a87781bf3ee57bb270d7c603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_copy&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_copy&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="79ee61bf6bf5fa92650008381392b1a21cbabf69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_createtable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_createtable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e7551097f181c02c15fea59139836b798d27fd76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_dump&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_dump&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d1d8b7fcdc2438a4309209f0e66816aa345e3ea0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_error&lt;/code&gt;[-1, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_error&lt;/code&gt; [-1, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="175321925aafb53c52dcfff8bf70c2d4f9b5df52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gc&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66371d02bb2a5294ddc7ff965f4078200f059e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gc&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_gc&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="9956d0bc82cc5409c737543da96a541d83bfbf7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getallocf&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getallocf&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="59632bab17bc189c3148482bc4080f9bd4b84547" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getextraspace&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getextraspace&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="60f37f158845e124eace06ea63e2280a95012974" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getfield&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_getfield&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="c94c6fd2b7c14b3e3b6ad04d5fe36bf6add888c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getglobal&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_getglobal&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ff4cee0e3a4e1d63522125ff34c46aca37313caf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gethook&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gethook&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="ec0eadfb615abc82aff0c7990a50162481f09f63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gethookcount&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gethookcount&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d7f8a674ccfd65eff1082ce412eb29972a57b18c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gethookmask&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gethookmask&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="f71c31c54898e128df0441cf376c9e767064382d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_geti&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_geti&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ea4a9e14acd3cb3bbf7462b6fb68c3ad28de14f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getinfo&lt;/code&gt;[-(0|1), +(0|1|2), &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_getinfo&lt;/code&gt; [- (0 | 1), + (0 | 1 | 2), &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0bed39a4374d24b0f719b1d6d6c9c9072489529c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getinfo&lt;/code&gt;[-(0|1), +(0|1|2), &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2144ffaa8fe826cac915c3c99e27c9ab5db89e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getiuservalue&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273e8c6ec216c7c83ca38a878d93b95631b13f24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getlocal&lt;/code&gt;[-0, +(0|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getlocal&lt;/code&gt; [-0, + (0 | 1), -]</target>
        </trans-unit>
        <trans-unit id="e2eca7f4a92d49d560aa8d947a3a1e0961d07be4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getmetatable&lt;/code&gt;[-0, +(0|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getmetatable&lt;/code&gt; [-0, + (0 | 1), -]</target>
        </trans-unit>
        <trans-unit id="7e3ce20be5f0c5d99b7e25b37999cb8bb5fd91e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getstack&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getstack&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="e01aa99ca62e5ceb24fa39ed4a6f4d31e572fa50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gettable&lt;/code&gt;[-1, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_gettable&lt;/code&gt; [-1, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="8e15475f1fb39e9839166b70e212b31d2521646e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gettop&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gettop&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="75cc1327823f758a6a97b78b712f93d5c639d881" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getupvalue&lt;/code&gt;[-0, +(0|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getupvalue&lt;/code&gt; [-0, + (0 | 1), -]</target>
        </trans-unit>
        <trans-unit id="06a9850be6a3681bd25c5c7e797cd88c22cc51e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getuservalue&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getuservalue&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="97ccd9464bf8253b4595901de1c28a281d630bca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_insert&lt;/code&gt;[-1, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_insert&lt;/code&gt; [-1, +1, -]</target>
        </trans-unit>
        <trans-unit id="ccf0205da2145136a72004529c69ef0d97389a74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isboolean&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isboolean&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d8f9274340043a6fe5b4a6502b209dfbcbc8102f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_iscfunction&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_iscfunction&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="344ac0a298f2d260c0cf30e7563213a6456c1391" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isfunction&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isfunction&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="95a6448d21c638bda4c1f328498fa19c59e41122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isinteger&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isinteger&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="906431d15e81d16a20736c110a889aa904f850f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_islightuserdata&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_islightuserdata&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="c331f628d45e17d9badc04decdc73b3dfba9aa43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnil&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnil&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="b6f54dbbadf1568e10c49c9c8d51351826575cc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnone&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnone&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="6141fdc1edd3191ed965eb184782c4bcc77ab662" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnoneornil&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnoneornil&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="244c0aa7d5c38d7aff3d8a120df5d0ff4dedd191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnumber&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnumber&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="9c5842c76ba56cc7b434b470a13d5db9a2ae746b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isstring&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isstring&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="9e4d02a146e4faff57845d1d808d69e94d4d5760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_istable&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_istable&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="fca695e4d6ae492d953e231c04e6456779c318ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isthread&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isthread&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="9054b192261af4e3df167d43972cc92d8f12c922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isuserdata&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isuserdata&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="6558ec7a9edae7a2472cab5d36feb4a25937b33a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isyieldable&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isyieldable&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="84ed319e4f41b15e379b0c80b8d751fb0a3350ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_len&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_len&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7a22e4332e1d809d6600680001552784b09874aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt; automatically detects whether the chunk is text or binary and loads it accordingly (see program &lt;code&gt;luac&lt;/code&gt;). The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;, with the addition that a &lt;code&gt;NULL&lt;/code&gt; value is equivalent to the string &quot;&lt;code&gt;bt&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; detecta autom&amp;aacute;ticamente si el fragmento es texto o binario y lo carga en consecuencia (ver programa &lt;code&gt;luac&lt;/code&gt; ). El &lt;code&gt;mode&lt;/code&gt; cadena funciona como en la funci&amp;oacute;n de &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; , con la adici&amp;oacute;n de que un valor &lt;code&gt;NULL&lt;/code&gt; es equivalente a la cadena &quot; &lt;code&gt;bt&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="205ec7f08fa763f310046a4629ec375e374f3151" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt; can return &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_ERRSYNTAX&quot;&gt;&lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;. The function may also return other values corresponding to errors raised by the read function (see &lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb7a1a988cb848b3d6f32fc68386067014fdd3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt; uses the stack internally, so the reader function must always leave the stack unmodified when returning.</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; usa la pila internamente, por lo que la funci&amp;oacute;n del lector siempre debe dejar la pila sin modificar al regresar.</target>
        </trans-unit>
        <trans-unit id="c9ad4cdb5afe054e2d52630b341bddcd5318dcbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="7374aef019136058240eb91bf9d7d1be64edc6b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newstate&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_newstate&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="1a38a1e48176080fdd830cbfa8d2959e31ce81e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newtable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_newtable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0a032a953b6701cd3d3ac0a4241cf5e3af19ca63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newthread&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_newthread&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="aa090c22b67b6e811e3f6576dbb546c21227c3b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newuserdata&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_newuserdata&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="18ba0a88db2e9be2ede36cb5e2777c3cf13f59bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newuserdatauv&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e6cbd4372d1f48086bd4ed0d56df437b0da92b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_next&lt;/code&gt;[-1, +(2|0), &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_next&lt;/code&gt; [-1, + (2 | 0), &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e97b757ec2b0dba68687708df9fcc7d28f8bcdae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_next&lt;/code&gt;[-1, +(2|0), &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26fc6d5a88b15e99cc4567b71c159df4ba7279c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pcall&lt;/code&gt;[-(nargs + 1), +(nresults|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pcall&lt;/code&gt; [- (nargs + 1), + (nresults | 1), -]</target>
        </trans-unit>
        <trans-unit id="850c75458d454fa1e854b2a9dc95240fca9f635c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pcallk&lt;/code&gt;[-(nargs + 1), +(nresults|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pcallk&lt;/code&gt; [- (nargs + 1), + (nresults | 1), -]</target>
        </trans-unit>
        <trans-unit id="88661d7b63266eddc349ccd0237a4a2fc79f215f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pop&lt;/code&gt;[-n, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pop&lt;/code&gt; [-n, +0, -]</target>
        </trans-unit>
        <trans-unit id="666e2142d3e457306d33378f3369679386a5b561" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushboolean&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushboolean&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="65a5e45fe5816a098fad98e557109633e97a1de8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushcclosure&lt;/code&gt;[-n, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushcclosure&lt;/code&gt; [-n, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="73447e0e4c9e92da86686da3e2f378b5e95bb556" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushcfunction&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushcfunction&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="6d9930915fc5c9a7d6f3b1983934256b1782cdce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushfstring&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushfstring&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="742728222fd6b05fea9d1313511dc12b79d321da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushfstring&lt;/code&gt;[-0, +1, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca7a523e75628341dcb660957104bd730722b5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushglobaltable&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushglobaltable&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="a664d85fd673d8e5f2c1f86f70023732e187465e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushinteger&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushinteger&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="a766edeb81578b9f6c5186a1ef1e02ddf5cb9453" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushlightuserdata&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushlightuserdata&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="78d98a728cf4ae7cccb9296c51e6350cb444a216" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushliteral&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushliteral&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="52c39aa3679bdd694c82d8b6920a76e7887f4f65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushlstring&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushlstring&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f18e9b33f026fcc7f0bb37b6518778960e0be147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushnil&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushnil&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="5b61a28ad71dd0c16bf5685880526849b74d1b22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushnumber&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushnumber&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="48093510761a8d9599932440e922c82a70bff0b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushstring&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushstring&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="8941a8b85742686999473929b77ca66b0c29786c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushthread&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushthread&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="a01e6c270aa1f8c90cd63c088fc55f395501c232" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushvalue&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushvalue&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="c4891a46279c1165ab6f6829b04d0f80e80af46f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushvfstring&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushvfstring&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="c47750b302979b454e9930cbacc8c1efe4377ef6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushvfstring&lt;/code&gt;[-0, +1, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5301ff5e4db06f4a902ea6e4f46a536016dec115" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawequal&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawequal&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="e7190a64e66cfdbfaa05e771b86b2428ce0f0c4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawget&lt;/code&gt;[-1, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawget&lt;/code&gt; [-1, +1, -]</target>
        </trans-unit>
        <trans-unit id="d8f63e8c899fc2163ea12e1929521f16195b8027" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawgeti&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawgeti&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="fd2f5fea0059c2e1a9ec9f806dd9bc92085001d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawgetp&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawgetp&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="32af4b6d514d73f35935bd7c665974260bb2d400" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawlen&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawlen&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="1d4cc3e1e56562010c53810d955212d9e94456ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawset&lt;/code&gt;[-2, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_rawset&lt;/code&gt; [-2, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6ebc570fbad1c557a9df049aab4ab6766494d940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawseti&lt;/code&gt;[-1, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_rawseti&lt;/code&gt; [-1, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7c35ae056b934f9d827a204944f9eb45d6eac2c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawsetp&lt;/code&gt;[-1, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_rawsetp&lt;/code&gt; [-1, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="13a48b8091c79dfb748c242e690a7dfb0126ad0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_register&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_register&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a0f12f7525f2b835c43c2bbb5726d22e75a7ad66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_remove&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_remove&lt;/code&gt; [-1, +0, -]</target>
        </trans-unit>
        <trans-unit id="e3aac1a6f4d80e971df8eaa5fd21798ce934e9c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_replace&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_replace&lt;/code&gt; [-1, +0, -]</target>
        </trans-unit>
        <trans-unit id="b1f830de2effb08c4ecef3246ffae5912534c901" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_resetthread&lt;/code&gt;[-0, +?, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a14b7df302fab9d83a4283a02b409867a164c3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_resume&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_resume&lt;/code&gt; [- ?, + ?, -]</target>
        </trans-unit>
        <trans-unit id="64b664566bc1133823238a94df36387e91cc4ce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rotate&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rotate&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="01005f76c6b7629878b4c890f865d738f3e13645" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setallocf&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setallocf&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="b0dc382a93758dd44d7aff42b2386a61c087aa9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setcstacklimit&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d7c876f5849763d0227a670cfb4cab56753235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setfield&lt;/code&gt;[-1, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_setfield&lt;/code&gt; [-1, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0afc85df066219abbaa2ee335f767a7b6896a049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setglobal&lt;/code&gt;[-1, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_setglobal&lt;/code&gt; [-1, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1b87726690c26be63f2ac34a4ef8702546d30a9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_sethook&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_sethook&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="f0d0da820dadc58bad264baff1243876ee500108" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_seti&lt;/code&gt;[-1, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_seti&lt;/code&gt; [-1, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="004a5c6164d1e4a0656eb999c1264f21fa274fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setiuservalue&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5673fc21d54441e768e98b5369226b29b8a4d4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setlocal&lt;/code&gt;[-(0|1), +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setlocal&lt;/code&gt; [- (0 | 1), +0, -]</target>
        </trans-unit>
        <trans-unit id="411f7433e89a45adb3e7009dbdd17fd585bc8560" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setmetatable&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setmetatable&lt;/code&gt; [-1, +0, -]</target>
        </trans-unit>
        <trans-unit id="20dcd39a78d5bdc5aa9f802eb25a1dd6a435cab5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_settable&lt;/code&gt;[-2, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_settable&lt;/code&gt; [-2, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="8259b61e77e47265f15b0e9934536650ba6717ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_settop&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_settop&lt;/code&gt; [- ?, + ?, -]</target>
        </trans-unit>
        <trans-unit id="fd6996e775cf476c1f493f52a1afccf6f6c1f4c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setupvalue&lt;/code&gt;[-(0|1), +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setupvalue&lt;/code&gt; [- (0 | 1), +0, -]</target>
        </trans-unit>
        <trans-unit id="962bd088aac144ff787da78a548da45dbaa42a60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setuservalue&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setuservalue&lt;/code&gt; [-1, +0, -]</target>
        </trans-unit>
        <trans-unit id="7eae365e3fdcddc5bea18be3c82bca53270c4d98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setwarnf&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc614bc467cfc52c396d5f4863abfb818cf5cd26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_status&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_status&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="2ccbee67de9eb87f0444d554fe5e403f4ee12142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_stringtonumber&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_stringtonumber&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="3c297ec1e5647fff579f5d361ceaa2a83c13bc96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_toboolean&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_toboolean&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="2f40e6bccafddc0d0eb0d56fd2ebb507f4a741b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tocfunction&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tocfunction&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="8c671d19d258d8dce1480fe0181a4b47d99286d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_toclose&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772105fa735d3f8e52e4dcf1f374a906313801c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tointeger&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tointeger&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="087ba9ee74385ce56dc7afa2421e9fe18d49cdf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tointegerx&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tointegerx&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="281abec9d8adcad8af78e123cc30469524cc8691" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tolstring&lt;/code&gt; returns a pointer to a string inside the Lua state (see &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt;). This string always has a zero ('&lt;code&gt;\0&lt;/code&gt;') after its last character (as in C), but can contain other zeros in its body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d547274b13aa55e1f5b1a1ead3114fadb93ca9e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tolstring&lt;/code&gt; returns a pointer to a string inside the Lua state. This string always has a zero ('&lt;code&gt;\0&lt;/code&gt;') after its last character (as in C), but can contain other zeros in its body.</source>
          <target state="translated">&lt;code&gt;lua_tolstring&lt;/code&gt; devuelve un puntero a una cadena dentro del estado Lua. Esta cadena siempre tiene un cero (' &lt;code&gt;\0&lt;/code&gt; ') despu&amp;eacute;s de su &amp;uacute;ltimo car&amp;aacute;cter (como en C), pero puede contener otros ceros en su cuerpo.</target>
        </trans-unit>
        <trans-unit id="784eecca5b67aab549cd43e3189c0b5977217c92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tolstring&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_tolstring&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7687cab7b8801ef5abea1aaa0693b3341c3eb2a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tonumber&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tonumber&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="99cab8a87a9cde1e6e3d9aaa6081962667424cb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tonumberx&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tonumberx&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d77c2f1d7b9ab8de85633a1ac860cb38ef23ca1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_topointer&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_topointer&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d7d11d995d3d1465098bd08f248711e428607f48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tostring&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_tostring&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e8d8a7c874870b0198c1a9b7c8f6d3c505824583" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tothread&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tothread&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="2d3423346c67cf164db6ad8970bd4f2222cb7fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_touserdata&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_touserdata&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="c0476212a8a15366d6ce4f81f04d030827e0066d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_type&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_type&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="f96cc4b0e1232bc22121e6810d74b42c2b1d3e06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_typename&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_typename&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="91a931321e8502b23d51c1a0a5c98f0c4165be7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_upvalueid&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_upvalueid&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="0ac955e136a22fb0a5cd4db3550046e858514163" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_upvalueindex&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_upvalueindex&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="27e8b4001de191561a219319ddfcf067f1e183b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_upvaluejoin&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_upvaluejoin&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="457f873509336f31072e0a6dc8f411b538781818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_version&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_version&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="265bc6c117d9a588aff02b367a9614e5bd73dc11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_warning&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb44f56e283569bb547217712306f8852f22cc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_xmove&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_xmove&lt;/code&gt; [- ?, + ?, -]</target>
        </trans-unit>
        <trans-unit id="76eecec65311fcc388227c521b10b1a314479323" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_yield&lt;/code&gt;[-?, +?, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_yield&lt;/code&gt; [- ?, + ?, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7310616b3bd3a7e949a6af634a8d1956eb6636ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_yield&lt;/code&gt;[-?, +?, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c6c643ec495e4991ca6c7475dab89f182c2cfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_yieldk&lt;/code&gt;[-?, +?, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_yieldk&lt;/code&gt; [- ?, + ?, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="c88bfed3d8a26d6ced5ab607211598d3a7aa8c93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_yieldk&lt;/code&gt;[-?, +?, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96b82c4509109433cf6af1e0be37d96a7fd94922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;: a &lt;code&gt;lua_Number&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; : a &lt;code&gt;lua_Number&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b29a4583bd00c0104cbe887c8111b95b42c3a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;:  a reasonable name for the given function. Because functions in Lua are first-class values, they do not have a fixed name: some functions can be the value of multiple global variables, while others can be stored only in a table field. The &lt;code&gt;lua_getinfo&lt;/code&gt; function checks how the function was called to find a suitable name. If it cannot find a name, then &lt;code&gt;name&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : un nombre razonable para la funci&amp;oacute;n dada. Debido a que las funciones en Lua son valores de primera clase, no tienen un nombre fijo: algunas funciones pueden ser el valor de m&amp;uacute;ltiples variables globales, mientras que otras pueden almacenarse solo en un campo de tabla. La funci&amp;oacute;n &lt;code&gt;lua_getinfo&lt;/code&gt; comprueba c&amp;oacute;mo se llam&amp;oacute; a la funci&amp;oacute;n para encontrar un nombre adecuado. Si no puede encontrar un nombre, el &lt;code&gt;name&lt;/code&gt; se establece en &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18c79c193a99a81d7281723cef6c12912cbf6433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namewhat&lt;/code&gt;:  explains the &lt;code&gt;name&lt;/code&gt; field. The value of &lt;code&gt;namewhat&lt;/code&gt; can be &lt;code&gt;&quot;global&quot;&lt;/code&gt;, &lt;code&gt;&quot;local&quot;&lt;/code&gt;, &lt;code&gt;&quot;method&quot;&lt;/code&gt;, &lt;code&gt;&quot;field&quot;&lt;/code&gt;, &lt;code&gt;&quot;upvalue&quot;&lt;/code&gt;, or &lt;code&gt;&quot;&quot;&lt;/code&gt; (the empty string), according to how the function was called. (Lua uses the empty string when no other option seems to apply.)</source>
          <target state="translated">&lt;code&gt;namewhat&lt;/code&gt; : explica el campo de &lt;code&gt;name&lt;/code&gt; . El valor de &lt;code&gt;namewhat&lt;/code&gt; puede ser &lt;code&gt;&quot;global&quot;&lt;/code&gt; , &lt;code&gt;&quot;local&quot;&lt;/code&gt; , &lt;code&gt;&quot;method&quot;&lt;/code&gt; , &lt;code&gt;&quot;field&quot;&lt;/code&gt; , &lt;code&gt;&quot;upvalue&quot;&lt;/code&gt; o &lt;code&gt;&quot;&quot;&lt;/code&gt; (la cadena vac&amp;iacute;a), de acuerdo con c&amp;oacute;mo se llam&amp;oacute; a la funci&amp;oacute;n. (Lua usa la cadena vac&amp;iacute;a cuando no parece aplicarse ninguna otra opci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="1fa95e55dd4784388ede4cc0ae537a28a3080930" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nparams&lt;/code&gt;:  the number of fixed parameters of the function (always 0 for C functions).</source>
          <target state="translated">&lt;code&gt;nparams&lt;/code&gt; : el n&amp;uacute;mero de par&amp;aacute;metros fijos de la funci&amp;oacute;n (siempre 0 para funciones C).</target>
        </trans-unit>
        <trans-unit id="b89c13db828677a2e0156fd78311a0569af50363" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nparams&lt;/code&gt;:  the number of parameters of the function (always 0 for C functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8154c866352ae7aa98001049b8f3d7bacc109ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ntransfer&lt;/code&gt;:  The number of values being transferred (see previous item). (For calls of Lua functions, this value is always equal to &lt;code&gt;nparams&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f379a6299ba3a449833511efbfb031b2dee8fac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nups&lt;/code&gt;:  the number of upvalues of the function.</source>
          <target state="translated">&lt;code&gt;nups&lt;/code&gt; : el n&amp;uacute;mero de upvalues ​​de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3afc1431e3aae979f726ea70b785e9f045e81a13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: a string preceded by its length coded as an unsigned integer with &lt;code&gt;n&lt;/code&gt; bytes (default is a &lt;code&gt;size_t&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;s[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : una cadena precedida por su longitud codificada como un entero sin signo con &lt;code&gt;n&lt;/code&gt; bytes (el valor predeterminado es &lt;code&gt;size_t&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="41b71842909a6cbea5231fb02ae01a15bb5d7485" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;short_src&lt;/code&gt;:  a &quot;printable&quot; version of &lt;code&gt;source&lt;/code&gt;, to be used in error messages.</source>
          <target state="translated">&lt;code&gt;short_src&lt;/code&gt; : una versi&amp;oacute;n &quot;imprimible&quot; de la &lt;code&gt;source&lt;/code&gt; , que se utilizar&amp;aacute; en mensajes de error.</target>
        </trans-unit>
        <trans-unit id="8c0e50b9fe2c50cd274f54eaadc1fbca633a98ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt;:  the name of the chunk that created the function. If &lt;code&gt;source&lt;/code&gt; starts with a '&lt;code&gt;@&lt;/code&gt;', it means that the function was defined in a file where the file name follows the '&lt;code&gt;@&lt;/code&gt;'. If &lt;code&gt;source&lt;/code&gt; starts with a '&lt;code&gt;=&lt;/code&gt;', the remainder of its contents describe the source in a user-dependent manner. Otherwise, the function was defined in a string where &lt;code&gt;source&lt;/code&gt; is that string.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; : el nombre del fragmento que cre&amp;oacute; la funci&amp;oacute;n. Si la &lt;code&gt;source&lt;/code&gt; comienza con una ' &lt;code&gt;@&lt;/code&gt; ', significa que la funci&amp;oacute;n se defini&amp;oacute; en un archivo donde el nombre del archivo sigue a la ' &lt;code&gt;@&lt;/code&gt; '. Si la &lt;code&gt;source&lt;/code&gt; comienza con un ' &lt;code&gt;=&lt;/code&gt; ', el resto de su contenido describe la fuente de una manera dependiente del usuario. De lo contrario, la funci&amp;oacute;n se defini&amp;oacute; en una cadena donde la &lt;code&gt;source&lt;/code&gt; es esa cadena.</target>
        </trans-unit>
        <trans-unit id="c1690813c08276efafb611b9118e1d8d238f1ab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt;:  the source of the chunk that created the function. If &lt;code&gt;source&lt;/code&gt; starts with a '&lt;code&gt;@&lt;/code&gt;', it means that the function was defined in a file where the file name follows the '&lt;code&gt;@&lt;/code&gt;'. If &lt;code&gt;source&lt;/code&gt; starts with a '&lt;code&gt;=&lt;/code&gt;', the remainder of its contents describes the source in a user-dependent manner. Otherwise, the function was defined in a string where &lt;code&gt;source&lt;/code&gt; is that string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866cb1591907e949f3206b7a8c507833d9980050" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;srclen&lt;/code&gt;:  The length of the string &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ee7088a398a6c05a7c0875bb94a590aab08cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;what&lt;/code&gt;:  the string &lt;code&gt;&quot;Lua&quot;&lt;/code&gt; if the function is a Lua function, &lt;code&gt;&quot;C&quot;&lt;/code&gt; if it is a C function, &lt;code&gt;&quot;main&quot;&lt;/code&gt; if it is the main part of a chunk.</source>
          <target state="translated">&lt;code&gt;what&lt;/code&gt; : la cadena &lt;code&gt;&quot;Lua&quot;&lt;/code&gt; si la funci&amp;oacute;n es una funci&amp;oacute;n Lua, &lt;code&gt;&quot;C&quot;&lt;/code&gt; si es una funci&amp;oacute;n C, &lt;code&gt;&quot;main&quot;&lt;/code&gt; si es la parte principal de un fragmento.</target>
        </trans-unit>
        <trans-unit id="87cd3c11f99f314ecc367ad79ade7d620b0027d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt;: one byte of padding</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; : un byte de relleno</target>
        </trans-unit>
        <trans-unit id="001502b0ce7e783ed32ff78090d4ed094c235365" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z&lt;/code&gt;: a zero-terminated string</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; : una cadena terminada en cero</target>
        </trans-unit>
        <trans-unit id="35770f2a3e697f3d7fc1b9f9a92ee552d22bf261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: bitwise OR</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; : bit a bit OR</target>
        </trans-unit>
        <trans-unit id="7d6fd4ec60e16166466f316ad472a99346ef7ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;: bitwise exclusive OR</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; : OR exclusivo bit a bit</target>
        </trans-unit>
        <trans-unit id="96b4aa7e1aec2aa10ad8536c6f27c6c544521708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;: unary bitwise NOT</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; : unario bit a bit NOT</target>
        </trans-unit>
        <trans-unit id="acd6d8cce51a342c5b90bb1907903a7f4dbad3e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~=&lt;/code&gt;: inequality</source>
          <target state="translated">&lt;code&gt;~=&lt;/code&gt; : desigualdad</target>
        </trans-unit>
        <trans-unit id="238467efd8a53a80c3098a6aa184ff8c3f711e2f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Names&lt;/em&gt; (also called &lt;em&gt;identifiers&lt;/em&gt;) in Lua can be any string of Latin letters, Arabic-Indic digits, and underscores, not beginning with a digit and not being a reserved word. Identifiers are used to name variables, table fields, and labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7f065407772e44a51b8ffb896bf3e031ec8b94" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Names&lt;/em&gt; (also called &lt;em&gt;identifiers&lt;/em&gt;) in Lua can be any string of letters, digits, and underscores, not beginning with a digit and not being a reserved word. Identifiers are used to name variables, table fields, and labels.</source>
          <target state="translated">&lt;em&gt;Los nombres&lt;/em&gt; (tambi&amp;eacute;n llamados &lt;em&gt;identificadores&lt;/em&gt; ) en Lua pueden ser cualquier cadena de letras, d&amp;iacute;gitos y guiones bajos, sin comenzar con un d&amp;iacute;gito y sin ser una palabra reservada. Los identificadores se utilizan para nombrar variables, campos de tabla y etiquetas.</target>
        </trans-unit>
        <trans-unit id="4aadb70307c23ca740f6eccdee86415794b36e75" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;break&lt;/b&gt; ends the innermost enclosing loop.</source>
          <target state="translated">Una &lt;b&gt;ruptura&lt;/b&gt; finaliza el bucle envolvente m&amp;aacute;s interno.</target>
        </trans-unit>
        <trans-unit id="144235cbc1ccef915119f45152ac47c5119d150b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;for&lt;/b&gt; statement like</source>
          <target state="translated">A &lt;b&gt;para una&lt;/b&gt; declaraci&amp;oacute;n como</target>
        </trans-unit>
        <trans-unit id="8da2571ab7c7e060c4976d340da392d89313fdab" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character class&lt;/em&gt; is used to represent a set of characters. The following combinations are allowed in describing a character class:</source>
          <target state="translated">Una &lt;em&gt;clase de caracteres&lt;/em&gt; se utiliza para representar un conjunto de caracteres. Se permiten las siguientes combinaciones para describir una clase de personaje:</target>
        </trans-unit>
        <trans-unit id="6521449c4ee4c82942f2111c4b00036b21741299" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;comment&lt;/em&gt; starts with a double hyphen (&lt;code&gt;--&lt;/code&gt;) anywhere outside a string. If the text immediately after &lt;code&gt;--&lt;/code&gt; is not an opening long bracket, the comment is a &lt;em&gt;short comment&lt;/em&gt;, which runs until the end of the line. Otherwise, it is a &lt;em&gt;long comment&lt;/em&gt;, which runs until the corresponding closing long bracket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11942e741b80827f49b57cea2ee7a3083c5c5105" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;comment&lt;/em&gt; starts with a double hyphen (&lt;code&gt;--&lt;/code&gt;) anywhere outside a string. If the text immediately after &lt;code&gt;--&lt;/code&gt; is not an opening long bracket, the comment is a &lt;em&gt;short comment&lt;/em&gt;, which runs until the end of the line. Otherwise, it is a &lt;em&gt;long comment&lt;/em&gt;, which runs until the corresponding closing long bracket. Long comments are frequently used to disable code temporarily.</source>
          <target state="translated">Un &lt;em&gt;comentario&lt;/em&gt; comienza con un gui&amp;oacute;n doble ( &lt;code&gt;--&lt;/code&gt; ) en cualquier lugar fuera de una cadena. Si el texto inmediatamente despu&amp;eacute;s &lt;code&gt;--&lt;/code&gt; no es un corchete largo de apertura, el comentario es un &lt;em&gt;comentario corto&lt;/em&gt; , que se extiende hasta el final de la l&amp;iacute;nea. De lo contrario, es un &lt;em&gt;comentario largo&lt;/em&gt; , que corre hasta el corchete largo de cierre correspondiente. Los comentarios largos se utilizan con frecuencia para deshabilitar el c&amp;oacute;digo temporalmente.</target>
        </trans-unit>
        <trans-unit id="9c0d21ff2fd9949d24c6794532468cb40838f88b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;numeric constant&lt;/em&gt; (or &lt;em&gt;numeral&lt;/em&gt;) can be written with an optional fractional part and an optional decimal exponent, marked by a letter '&lt;code&gt;e&lt;/code&gt;' or '&lt;code&gt;E&lt;/code&gt;'. Lua also accepts hexadecimal constants, which start with &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;. Hexadecimal constants also accept an optional fractional part plus an optional binary exponent, marked by a letter '&lt;code&gt;p&lt;/code&gt;' or '&lt;code&gt;P&lt;/code&gt;'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45246a537ee28cdd862e9e3b659c6215f07e13a0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;numeric constant&lt;/em&gt; (or &lt;em&gt;numeral&lt;/em&gt;) can be written with an optional fractional part and an optional decimal exponent, marked by a letter '&lt;code&gt;e&lt;/code&gt;' or '&lt;code&gt;E&lt;/code&gt;'. Lua also accepts hexadecimal constants, which start with &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;. Hexadecimal constants also accept an optional fractional part plus an optional binary exponent, marked by a letter '&lt;code&gt;p&lt;/code&gt;' or '&lt;code&gt;P&lt;/code&gt;'. A numeric constant with a radix point or an exponent denotes a float; otherwise, if its value fits in an integer, it denotes an integer. Examples of valid integer constants are</source>
          <target state="translated">Una &lt;em&gt;constante num&amp;eacute;rica&lt;/em&gt; (o &lt;em&gt;numeral&lt;/em&gt; ) se puede escribir con una parte fraccionaria opcional y un exponente decimal opcional, marcado con una letra ' &lt;code&gt;e&lt;/code&gt; ' o ' &lt;code&gt;E&lt;/code&gt; '. Lua tambi&amp;eacute;n acepta constantes hexadecimales, que comienzan con &lt;code&gt;0x&lt;/code&gt; o &lt;code&gt;0X&lt;/code&gt; . Las constantes hexadecimales tambi&amp;eacute;n aceptan una parte fraccionaria opcional m&amp;aacute;s un exponente binario opcional, marcado por una letra ' &lt;code&gt;p&lt;/code&gt; ' o ' &lt;code&gt;P&lt;/code&gt; '. Una constante num&amp;eacute;rica con un punto de base o un exponente denota un flotante; de lo contrario, si su valor encaja en un n&amp;uacute;mero entero, denota un n&amp;uacute;mero entero. Ejemplos de constantes enteras v&amp;aacute;lidas son</target>
        </trans-unit>
        <trans-unit id="43c4164c55abb7933faf258648b8253172e7ddaf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pattern item&lt;/em&gt; can be</source>
          <target state="translated">Un &lt;em&gt;elemento de patr&amp;oacute;n&lt;/em&gt; puede ser</target>
        </trans-unit>
        <trans-unit id="9b3f67e64fdd3547c2b4af7f1362a66a7279295d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pattern&lt;/em&gt; is a sequence of pattern items. A caret '&lt;code&gt;^&lt;/code&gt;' at the beginning of a pattern anchors the match at the beginning of the subject string. A '&lt;code&gt;$&lt;/code&gt;' at the end of a pattern anchors the match at the end of the subject string. At other positions, '&lt;code&gt;^&lt;/code&gt;' and '&lt;code&gt;$&lt;/code&gt;' have no special meaning and represent themselves.</source>
          <target state="translated">Un &lt;em&gt;patr&amp;oacute;n&lt;/em&gt; es una secuencia de elementos de patr&amp;oacute;n. Un signo de intercalaci&amp;oacute;n ' &lt;code&gt;^&lt;/code&gt; ' al comienzo de un patr&amp;oacute;n ancla la coincidencia al comienzo de la cadena del sujeto. Un ' &lt;code&gt;$&lt;/code&gt; ' al final de un patr&amp;oacute;n ancla la coincidencia al final de la cadena del asunto. En otras posiciones, ' &lt;code&gt;^&lt;/code&gt; ' y ' &lt;code&gt;$&lt;/code&gt; ' no tienen un significado especial y se representan a s&amp;iacute; mismos.</target>
        </trans-unit>
        <trans-unit id="c9d93dadd47fb17d5c1f30a2f6969069891cffbe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;short literal string&lt;/em&gt; can be delimited by matching single or double quotes, and can contain the following C-like escape sequences: '&lt;code&gt;\a&lt;/code&gt;' (bell), '&lt;code&gt;\b&lt;/code&gt;' (backspace), '&lt;code&gt;\f&lt;/code&gt;' (form feed), '&lt;code&gt;\n&lt;/code&gt;' (newline), '&lt;code&gt;\r&lt;/code&gt;' (carriage return), '&lt;code&gt;\t&lt;/code&gt;' (horizontal tab), '&lt;code&gt;\v&lt;/code&gt;' (vertical tab), '&lt;code&gt;\\&lt;/code&gt;' (backslash), '&lt;code&gt;\&quot;&lt;/code&gt;' (quotation mark [double quote]), and '&lt;code&gt;\'&lt;/code&gt;' (apostrophe [single quote]). A backslash followed by a line break results in a newline in the string. The escape sequence '&lt;code&gt;\z&lt;/code&gt;' skips the following span of white-space characters, including line breaks; it is particularly useful to break and indent a long literal string into multiple lines without adding the newlines and spaces into the string contents. A short literal string cannot contain unescaped line breaks nor escapes not forming a valid escape sequence.</source>
          <target state="translated">Una &lt;em&gt;cadena literal corta&lt;/em&gt; se puede delimitar haciendo coincidir comillas simples o dobles, y puede contener las siguientes secuencias de escape tipo C: ' &lt;code&gt;\a&lt;/code&gt; ' (campana), ' &lt;code&gt;\b&lt;/code&gt; ' (retroceso), ' &lt;code&gt;\f&lt;/code&gt; ' (alimentaci&amp;oacute;n de formulario), ' &lt;code&gt;\n&lt;/code&gt; ' (nueva l&amp;iacute;nea), ' &lt;code&gt;\r&lt;/code&gt; ' (retorno de carro), ' &lt;code&gt;\t&lt;/code&gt; ' (tabulaci&amp;oacute;n horizontal), ' &lt;code&gt;\v&lt;/code&gt; ' (tabulaci&amp;oacute;n vertical), ' &lt;code&gt;\\&lt;/code&gt; ' (barra invertida), ' &lt;code&gt;\&quot;&lt;/code&gt; ' (comillas [comillas dobles]) y ' &lt;code&gt;\'&lt;/code&gt; '(ap&amp;oacute;strofo [comillas simples]). Una barra invertida seguida de un salto de l&amp;iacute;nea da como resultado una nueva l&amp;iacute;nea en la cadena. La secuencia de escape' &lt;code&gt;\z&lt;/code&gt; 'omite el siguiente intervalo de caracteres de espacio en blanco, incluidos los saltos de l&amp;iacute;nea; Es particularmente &amp;uacute;til dividir y sangrar una cadena literal larga en varias l&amp;iacute;neas sin agregar nuevas l&amp;iacute;neas y espacios en el contenido de la cadena. Una cadena literal corta no puede contener saltos de l&amp;iacute;nea sin escape ni escapes que no formen una secuencia de escape v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="1e7ea716b5530b0c3020375c0eec5ca84501ca10" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;short literal string&lt;/em&gt; can be delimited by matching single or double quotes, and can contain the following C-like escape sequences: '&lt;code&gt;\a&lt;/code&gt;' (bell), '&lt;code&gt;\b&lt;/code&gt;' (backspace), '&lt;code&gt;\f&lt;/code&gt;' (form feed), '&lt;code&gt;\n&lt;/code&gt;' (newline), '&lt;code&gt;\r&lt;/code&gt;' (carriage return), '&lt;code&gt;\t&lt;/code&gt;' (horizontal tab), '&lt;code&gt;\v&lt;/code&gt;' (vertical tab), '&lt;code&gt;\\&lt;/code&gt;' (backslash), '&lt;code&gt;\&quot;&lt;/code&gt;' (quotation mark [double quote]), and '&lt;code&gt;\'&lt;/code&gt;' (apostrophe [single quote]). A backslash followed by a line break results in a newline in the string. The escape sequence '&lt;code&gt;\z&lt;/code&gt;' skips the following span of whitespace characters, including line breaks; it is particularly useful to break and indent a long literal string into multiple lines without adding the newlines and spaces into the string contents. A short literal string cannot contain unescaped line breaks nor escapes not forming a valid escape sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703f78edc26aa73fc795a76d8b68cf8ffb10eeab" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;valid index&lt;/em&gt; is an index that refers to a position that stores a modifiable Lua value. It comprises stack indices between 1 and the stack top (&lt;code&gt;1 &amp;le; abs(index) &amp;le; top&lt;/code&gt;) plus &lt;em&gt;pseudo-indices&lt;/em&gt;, which represent some positions that are accessible to C code but that are not in the stack. Pseudo-indices are used to access the registry (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;) and the upvalues of a C function (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b71986dee98cd86a5bb65ac2e321dbab699546" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;valid index&lt;/em&gt; is an index that refers to a position that stores a modifiable Lua value. It comprises stack indices between 1 and the stack top (&lt;code&gt;1 &amp;le; abs(index) &amp;le; top&lt;/code&gt;) plus &lt;em&gt;pseudo-indices&lt;/em&gt;, which represent some positions that are accessible to C code but that are not in the stack. Pseudo-indices are used to access the registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;) and the upvalues of a C function (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;).</source>
          <target state="translated">Un &lt;em&gt;&amp;iacute;ndice v&amp;aacute;lido&lt;/em&gt; es un &amp;iacute;ndice que se refiere a una posici&amp;oacute;n que almacena un valor Lua modificable. Comprende &amp;iacute;ndices de pila entre 1 y la parte superior de la pila ( &lt;code&gt;1 &amp;le; abs(index) &amp;le; top&lt;/code&gt; ) m&amp;aacute;s &lt;em&gt;pseudo&amp;iacute;ndices&lt;/em&gt; , que representan algunas posiciones que son accesibles al c&amp;oacute;digo C pero que no est&amp;aacute;n en la pila. Los pseudo&amp;iacute;ndices se utilizan para acceder al registro (ver &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; ) y los valores ascendentes de una funci&amp;oacute;n C (ver &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc2ccfd57dd2ee13db0881ad932f1a878faf0c64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;weak table&lt;/em&gt; is a table whose elements are &lt;em&gt;weak references&lt;/em&gt;. A weak reference is ignored by the garbage collector. In other words, if the only references to an object are weak references, then the garbage collector will collect that object.</source>
          <target state="translated">Una &lt;em&gt;tabla d&amp;eacute;bil&lt;/em&gt; es una tabla cuyos elementos son &lt;em&gt;referencias d&amp;eacute;biles&lt;/em&gt; . El recolector de basura ignora una referencia d&amp;eacute;bil. En otras palabras, si las &amp;uacute;nicas referencias a un objeto son referencias d&amp;eacute;biles, el recolector de basura recopilar&amp;aacute; ese objeto.</target>
        </trans-unit>
        <trans-unit id="838899562d596fefd844e484608aa6e4c2922871" translate="yes" xml:space="preserve">
          <source>A C closure can also change the values of its corresponding upvalues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa55e8031d6eb3c6d20f33859dde00134235bf3" translate="yes" xml:space="preserve">
          <source>A block can be explicitly delimited to produce a single statement:</source>
          <target state="translated">Un bloque puede ser explícitamente delimitado para producir una sola declaración:</target>
        </trans-unit>
        <trans-unit id="ec51a298084d5b31d4dab8833e20239393ee6e1e" translate="yes" xml:space="preserve">
          <source>A block is a list of statements, which are executed sequentially:</source>
          <target state="translated">Un bloque es una lista de declaraciones,que se ejecutan de forma secuencial:</target>
        </trans-unit>
        <trans-unit id="1a46bdc4d8fc003e74bbca9567f9845260ef3e19" translate="yes" xml:space="preserve">
          <source>A call of the form &lt;code&gt;return &lt;em&gt;functioncall&lt;/em&gt;&lt;/code&gt; is called a &lt;em&gt;tail call&lt;/em&gt;. Lua implements &lt;em&gt;proper tail calls&lt;/em&gt; (or &lt;em&gt;proper tail recursion&lt;/em&gt;): in a tail call, the called function reuses the stack entry of the calling function. Therefore, there is no limit on the number of nested tail calls that a program can execute. However, a tail call erases any debug information about the calling function. Note that a tail call only happens with a particular syntax, where the &lt;b&gt;return&lt;/b&gt; has one single function call as argument; this syntax makes the calling function return exactly the returns of the called function. So, none of the following examples are tail calls:</source>
          <target state="translated">Una llamada de la forma &lt;code&gt;return &lt;em&gt;functioncall&lt;/em&gt;&lt;/code&gt; se llama &lt;em&gt;llamada final&lt;/em&gt; . Lua implementa &lt;em&gt;las llamadas de cola adecuadas&lt;/em&gt; (o &lt;em&gt;la recursi&amp;oacute;n de cola adecuada&lt;/em&gt; ): en una llamada de cola, la funci&amp;oacute;n llamada reutiliza la entrada de pila de la funci&amp;oacute;n de llamada. Por lo tanto, no hay l&amp;iacute;mite en el n&amp;uacute;mero de llamadas de cola anidadas que puede ejecutar un programa. Sin embargo, una llamada de cola borra cualquier informaci&amp;oacute;n de depuraci&amp;oacute;n sobre la funci&amp;oacute;n de llamada. Tenga en cuenta que una llamada de cola solo ocurre con una sintaxis particular, donde la &lt;b&gt;devoluci&amp;oacute;n&lt;/b&gt; tiene una sola llamada de funci&amp;oacute;n como argumento; esta sintaxis hace que la funci&amp;oacute;n que llama devuelva exactamente los retornos de la funci&amp;oacute;n llamada. Entonces, ninguno de los siguientes ejemplos son llamadas de cola:</target>
        </trans-unit>
        <trans-unit id="6a544d7768ac7a0cdc7058530f1bcb86b6f1bcbf" translate="yes" xml:space="preserve">
          <source>A call of the form &lt;code&gt;return &lt;em&gt;functioncall&lt;/em&gt;&lt;/code&gt; not in the scope of a to-be-closed variable is called a &lt;em&gt;tail call&lt;/em&gt;. Lua implements &lt;em&gt;proper tail calls&lt;/em&gt; (or &lt;em&gt;proper tail recursion&lt;/em&gt;): in a tail call, the called function reuses the stack entry of the calling function. Therefore, there is no limit on the number of nested tail calls that a program can execute. However, a tail call erases any debug information about the calling function. Note that a tail call only happens with a particular syntax, where the &lt;b&gt;return&lt;/b&gt; has one single function call as argument, and it is outside the scope of any to-be-closed variable. This syntax makes the calling function return exactly the returns of the called function, without any intervening action. So, none of the following examples are tail calls:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2afda0df1ca02ec9a60e9c8cfd19f5d2f5a92aa" translate="yes" xml:space="preserve">
          <source>A chunk can be stored in a file or in a string inside the host program. To execute a chunk, Lua first &lt;em&gt;loads&lt;/em&gt; it, precompiling the chunk's code into instructions for a virtual machine, and then Lua executes the compiled code with an interpreter for the virtual machine.</source>
          <target state="translated">Un fragmento se puede almacenar en un archivo o en una cadena dentro del programa anfitri&amp;oacute;n. Para ejecutar un fragmento, Lua primero lo &lt;em&gt;carga&lt;/em&gt; , compilando previamente el c&amp;oacute;digo del fragmento en instrucciones para una m&amp;aacute;quina virtual, y luego Lua ejecuta el c&amp;oacute;digo compilado con un int&amp;eacute;rprete para la m&amp;aacute;quina virtual.</target>
        </trans-unit>
        <trans-unit id="c4ee67ff442e191f14dbdcdb9233561f4dc58f7c" translate="yes" xml:space="preserve">
          <source>A chunk is also a block (see &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt;), and so local variables can be declared in a chunk outside any explicit block.</source>
          <target state="translated">Un fragmento tambi&amp;eacute;n es un bloque (consulte &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt; ), por lo que las variables locales se pueden declarar en un fragmento fuera de cualquier bloque expl&amp;iacute;cito.</target>
        </trans-unit>
        <trans-unit id="89f058cf87035dfffc923b06bddc388bf582fef2" translate="yes" xml:space="preserve">
          <source>A coroutine can terminate its execution in two ways: normally, when its main function returns (explicitly or implicitly, after the last instruction); and abnormally, if there is an unprotected error. In case of normal termination, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;true&lt;/b&gt;, plus any values returned by the coroutine main function. In case of errors, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;false&lt;/b&gt; plus an error object.</source>
          <target state="translated">Una corrutina puede terminar su ejecuci&amp;oacute;n de dos formas: normalmente, cuando su funci&amp;oacute;n principal regresa (expl&amp;iacute;cita o impl&amp;iacute;citamente, despu&amp;eacute;s de la &amp;uacute;ltima instrucci&amp;oacute;n); y de forma anormal, si hay un error desprotegido. En caso de terminaci&amp;oacute;n normal, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; devuelve &lt;b&gt;verdadero&lt;/b&gt; , m&amp;aacute;s cualquier valor devuelto por la funci&amp;oacute;n principal de coroutine. En caso de errores, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; devuelve &lt;b&gt;falso&lt;/b&gt; m&amp;aacute;s un objeto de error.</target>
        </trans-unit>
        <trans-unit id="7fccab4c3a920129e8bc11d7ed566cc0bc58f02e" translate="yes" xml:space="preserve">
          <source>A coroutine can terminate its execution in two ways: normally, when its main function returns (explicitly or implicitly, after the last instruction); and abnormally, if there is an unprotected error. In case of normal termination, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;true&lt;/b&gt;, plus any values returned by the coroutine main function. In case of errors, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;false&lt;/b&gt; plus the error object. In this case, the coroutine does not unwind its stack, so that it is possible to inspect it after the error with the debug API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6847f15c1d2bb7a7eacf0b01a540f63bd1869ba2" translate="yes" xml:space="preserve">
          <source>A coroutine is yieldable if it is not the main thread and it is not inside a non-yieldable C function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ee02330bdc9c7efb921e9fa622f05fad377bb4" translate="yes" xml:space="preserve">
          <source>A coroutine yields by calling &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt;&lt;code&gt;coroutine.yield&lt;/code&gt;&lt;/a&gt;. When a coroutine yields, the corresponding &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns immediately, even if the yield happens inside nested function calls (that is, not in the main function, but in a function directly or indirectly called by the main function). In the case of a yield, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; also returns &lt;b&gt;true&lt;/b&gt;, plus any values passed to &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt;&lt;code&gt;coroutine.yield&lt;/code&gt;&lt;/a&gt;. The next time you resume the same coroutine, it continues its execution from the point where it yielded, with the call to &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt;&lt;code&gt;coroutine.yield&lt;/code&gt;&lt;/a&gt; returning any extra arguments passed to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una coroutine cede llamando a &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt; &lt;code&gt;coroutine.yield&lt;/code&gt; &lt;/a&gt; . Cuando una corrutina cede, la &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; correspondiente regresa inmediatamente, incluso si el rendimiento ocurre dentro de llamadas de funci&amp;oacute;n anidadas (es decir, no en la funci&amp;oacute;n principal, sino en una funci&amp;oacute;n llamada directa o indirectamente por la funci&amp;oacute;n principal). En el caso de un rendimiento, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n devuelve &lt;b&gt;verdadero&lt;/b&gt; , m&amp;aacute;s cualquier valor pasado a &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt; &lt;code&gt;coroutine.yield&lt;/code&gt; &lt;/a&gt; . La pr&amp;oacute;xima vez que reanude la misma corrutina, contin&amp;uacute;a su ejecuci&amp;oacute;n desde el punto en el que cedi&amp;oacute;, con la llamada a &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt; &lt;code&gt;coroutine.yield&lt;/code&gt; &lt;/a&gt; devolviendo cualquier argumento adicional pasado a &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3088438d805eed5e3fbd8b4df355ce4b0938eb" translate="yes" xml:space="preserve">
          <source>A detailed list of events controlled by metatables is given next. Each operation is identified by its corresponding key.</source>
          <target state="translated">A continuación se presenta una lista detallada de eventos controlados por metatablas.Cada operación se identifica con su clave correspondiente.</target>
        </trans-unit>
        <trans-unit id="0a2cccdac31c8e35779223d73ad3e331960f13dd" translate="yes" xml:space="preserve">
          <source>A detailed list of operations controlled by metatables is given next. Each event is identified by its corresponding key. By convention, all metatable keys used by Lua are composed by two underscores followed by lowercase Latin letters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ece8c655dc36e8d6319d68c95bcaac2d49dfe7" translate="yes" xml:space="preserve">
          <source>A file handle is implemented as a full userdata, with a metatable called &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; (where &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; is a macro with the actual metatable's name). The metatable is created by the I/O library (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Un identificador de archivo se implementa como datos de usuario completos, con una metatabla llamada &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; (donde &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; es una macro con el nombre real de la metatabla). La metatabla es creada por la biblioteca de E / S (ver &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd31b6026ec306c9598314c7a4fb9720392f25d4" translate="yes" xml:space="preserve">
          <source>A format string is a sequence of conversion options. The conversion options are as follows:</source>
          <target state="translated">Una cadena de formato es una secuencia de opciones de conversión.Las opciones de conversión son las siguientes:</target>
        </trans-unit>
        <trans-unit id="bbe12450770ac90f140b941579b60535c8af83cf" translate="yes" xml:space="preserve">
          <source>A function call in Lua has the following syntax:</source>
          <target state="translated">Una llamada de función en Lua tiene la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="7922d23ba8fff84e8a26ef3f217d4b75923835cc" translate="yes" xml:space="preserve">
          <source>A function definition is an executable expression, whose value has type &lt;em&gt;function&lt;/em&gt;. When Lua precompiles a chunk, all its function bodies are precompiled too, but they are not created yet. Then, whenever Lua executes the function definition, the function is &lt;em&gt;instantiated&lt;/em&gt; (or &lt;em&gt;closed&lt;/em&gt;). This function instance, or &lt;em&gt;closure&lt;/em&gt;, is the final value of the expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cb80c7bdf41b4df631b1f8aa57077bfb622b3ca" translate="yes" xml:space="preserve">
          <source>A function definition is an executable expression, whose value has type &lt;em&gt;function&lt;/em&gt;. When Lua precompiles a chunk, all its function bodies are precompiled too. Then, whenever Lua executes the function definition, the function is &lt;em&gt;instantiated&lt;/em&gt; (or &lt;em&gt;closed&lt;/em&gt;). This function instance (or &lt;em&gt;closure&lt;/em&gt;) is the final value of the expression.</source>
          <target state="translated">Una definici&amp;oacute;n de funci&amp;oacute;n es una expresi&amp;oacute;n ejecutable, cuyo valor tiene el tipo &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; . Cuando Lua precompila un fragmento, todos los cuerpos de sus funciones tambi&amp;eacute;n se precompilan. Luego, siempre que Lua ejecuta la definici&amp;oacute;n de funci&amp;oacute;n, la funci&amp;oacute;n se &lt;em&gt;instancia&lt;/em&gt; (o se &lt;em&gt;cierra&lt;/em&gt; ). Esta instancia de funci&amp;oacute;n (o &lt;em&gt;cierre&lt;/em&gt; ) es el valor final de la expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="def5b5d3fc526d80ec07c94970f2e05b00532d11" translate="yes" xml:space="preserve">
          <source>A global variable (not a function) that holds a string containing the running Lua version. The current value of this variable is &quot;&lt;code&gt;Lua 5.3&lt;/code&gt;&quot;.</source>
          <target state="translated">Una variable global (no una funci&amp;oacute;n) que contiene una cadena que contiene la versi&amp;oacute;n de Lua en ejecuci&amp;oacute;n. El valor actual de esta variable es &quot; &lt;code&gt;Lua 5.3&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="cf9aec3d455800c4f1fa314bf548b9b77afeadfa" translate="yes" xml:space="preserve">
          <source>A global variable (not a function) that holds a string containing the running Lua version. The current value of this variable is &quot;&lt;code&gt;Lua 5.4&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353c97fb2432c2d977afa942e47185d3456b4910" translate="yes" xml:space="preserve">
          <source>A global variable (not a function) that holds the global environment (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). Lua itself does not use this variable; changing its value does not affect any environment, nor vice versa.</source>
          <target state="translated">Una variable global (no una funci&amp;oacute;n) que contiene el entorno global (ver &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ). Lua en s&amp;iacute; no usa esta variable; cambiar su valor no afecta a ning&amp;uacute;n entorno, ni viceversa.</target>
        </trans-unit>
        <trans-unit id="bb9da1771a20805caac7264030f37560221e3663" translate="yes" xml:space="preserve">
          <source>A hook is disabled by setting &lt;code&gt;mask&lt;/code&gt; to zero.</source>
          <target state="translated">Un gancho se desactiva poniendo la &lt;code&gt;mask&lt;/code&gt; a cero.</target>
        </trans-unit>
        <trans-unit id="193fc3ddd618485a261dd773adce3a84dd96a30d" translate="yes" xml:space="preserve">
          <source>A label for a &lt;b&gt;goto&lt;/b&gt; cannot be declared where a label with the same name is visible, even if this other label is declared in an enclosing block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f3c7023ea10aed55497eb7b7366ee3b6a6cb22" translate="yes" xml:space="preserve">
          <source>A label is visible in the entire block where it is defined, except inside nested blocks where a label with the same name is defined and inside nested functions. A goto may jump to any visible label as long as it does not enter into the scope of a local variable.</source>
          <target state="translated">Una etiqueta es visible en todo el bloque donde se define,excepto dentro de los bloques anidados donde se define una etiqueta con el mismo nombre y dentro de las funciones anidadas.Un goto puede saltar a cualquier etiqueta visible siempre que no entre en el ámbito de una variable local.</target>
        </trans-unit>
        <trans-unit id="5cd99119e45659506f3ea872a322036815d49dcb" translate="yes" xml:space="preserve">
          <source>A label is visible in the entire block where it is defined, except inside nested functions. A goto may jump to any visible label as long as it does not enter into the scope of a local variable. A label should not be declared where a label with the same name is visible, even if this other label has been declared in an enclosing block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933dd832c6b0be5ada1dd95c6bacc46f4be4f532" translate="yes" xml:space="preserve">
          <source>A metatable controls how an object behaves in arithmetic operations, bitwise operations, order comparisons, concatenation, length operation, calls, and indexing. A metatable also can define a function to be called when a userdata or a table is garbage collected (&lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;).</source>
          <target state="translated">Una metatabla controla c&amp;oacute;mo se comporta un objeto en operaciones aritm&amp;eacute;ticas, operaciones bit a bit, comparaciones de &amp;oacute;rdenes, concatenaci&amp;oacute;n, operaci&amp;oacute;n de longitud, llamadas e indexaci&amp;oacute;n. Una metatabla tambi&amp;eacute;n puede definir una funci&amp;oacute;n que se llamar&amp;aacute; cuando se recolecten datos de usuario o una tabla como basura ( &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="713404884061ce0193a5d3c2ff7f9252eb287b76" translate="yes" xml:space="preserve">
          <source>A numeric constant with a radix point or an exponent denotes a float; otherwise, if its value fits in an integer or it is a hexadecimal constant, it denotes an integer; otherwise (that is, a decimal integer numeral that overflows), it denotes a float. Hexadecimal numerals with neither a radix point nor an exponent always denote an integer value; if the value overflows, it &lt;em&gt;wraps around&lt;/em&gt; to fit into a valid integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fbf280f4f9e4cb8aa41cf93549ddcd00b0d6b38" translate="yes" xml:space="preserve">
          <source>A path is a string containing a sequence of &lt;em&gt;templates&lt;/em&gt; separated by semicolons. For each template, the function replaces each interrogation mark (if any) in the template with a copy of &lt;code&gt;name&lt;/code&gt; wherein all occurrences of &lt;code&gt;sep&lt;/code&gt; (a dot, by default) were replaced by &lt;code&gt;rep&lt;/code&gt; (the system's directory separator, by default), and then tries to open the resulting file name.</source>
          <target state="translated">Una ruta es una cadena que contiene una secuencia de &lt;em&gt;plantillas&lt;/em&gt; separadas por punto y coma. Para cada plantilla, la funci&amp;oacute;n reemplaza cada signo de interrogaci&amp;oacute;n (si existe) en la plantilla con una copia del &lt;code&gt;name&lt;/code&gt; en el que todas las apariciones de &lt;code&gt;sep&lt;/code&gt; (un punto, por defecto) fueron reemplazadas por &lt;code&gt;rep&lt;/code&gt; (el separador de directorio del sistema, por defecto), y luego intenta abrir el nombre del archivo resultante.</target>
        </trans-unit>
        <trans-unit id="3592c30e99bab5898e5564c352fa7c9c589dc5de" translate="yes" xml:space="preserve">
          <source>A pattern can contain sub-patterns enclosed in parentheses; they describe &lt;em&gt;captures&lt;/em&gt;. When a match succeeds, the substrings of the subject string that match captures are stored (&lt;em&gt;captured&lt;/em&gt;) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern &lt;code&gt;&quot;(a*(.)%w(%s*))&quot;&lt;/code&gt;, the part of the string matching &lt;code&gt;&quot;a*(.)%w(%s*)&quot;&lt;/code&gt; is stored as the first capture (and therefore has number 1); the character matching &quot;&lt;code&gt;.&lt;/code&gt;&quot; is captured with number 2, and the part matching &quot;&lt;code&gt;%s*&lt;/code&gt;&quot; has number 3.</source>
          <target state="translated">Un patr&amp;oacute;n puede contener subpatrones entre par&amp;eacute;ntesis; describen &lt;em&gt;capturas&lt;/em&gt; . Cuando una coincidencia tiene &amp;eacute;xito, las subcadenas de la cadena de asunto que coinciden con las capturas se almacenan ( &lt;em&gt;capturan&lt;/em&gt; ) para uso futuro. Las capturas est&amp;aacute;n numeradas de acuerdo con el par&amp;eacute;ntesis izquierdo. Por ejemplo, en el patr&amp;oacute;n &lt;code&gt;&quot;(a*(.)%w(%s*))&quot;&lt;/code&gt; , la parte de la cadena que coincide con &lt;code&gt;&quot;a*(.)%w(%s*)&quot;&lt;/code&gt; se almacena como la primera captura ( y por lo tanto tiene el n&amp;uacute;mero 1); el car&amp;aacute;cter que coincide con &quot; &lt;code&gt;.&lt;/code&gt; &quot; se captura con el n&amp;uacute;mero 2, y la parte que coincide con &quot; &lt;code&gt;%s*&lt;/code&gt; &quot; tiene el n&amp;uacute;mero 3.</target>
        </trans-unit>
        <trans-unit id="f56c34aac3249901bd4e798153c3758f32451a9c" translate="yes" xml:space="preserve">
          <source>A pattern can contain sub-patterns enclosed in parentheses; they describe &lt;em&gt;captures&lt;/em&gt;. When a match succeeds, the substrings of the subject string that match captures are stored (&lt;em&gt;captured&lt;/em&gt;) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern &lt;code&gt;&quot;(a*(.)%w(%s*))&quot;&lt;/code&gt;, the part of the string matching &lt;code&gt;&quot;a*(.)%w(%s*)&quot;&lt;/code&gt; is stored as the first capture, and therefore has number 1; the character matching &quot;&lt;code&gt;.&lt;/code&gt;&quot; is captured with number 2, and the part matching &quot;&lt;code&gt;%s*&lt;/code&gt;&quot; has number 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38cf749bb9ad3579d6b255d66e52681d302f2ddf" translate="yes" xml:space="preserve">
          <source>A pointer to a thread must be passed as the first argument to every function in the library, except to &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt;, which creates a Lua state from scratch and returns a pointer to the &lt;em&gt;main thread&lt;/em&gt; in the new state.</source>
          <target state="translated">Se debe pasar un puntero a un hilo como primer argumento a cada funci&amp;oacute;n de la biblioteca, excepto a &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; &lt;/a&gt; , que crea un estado Lua desde cero y devuelve un puntero al &lt;em&gt;hilo principal&lt;/em&gt; en el nuevo estado.</target>
        </trans-unit>
        <trans-unit id="9f720f6817ac0c98d606b9b7538ff16874a21500" translate="yes" xml:space="preserve">
          <source>A pointer to this structure must be passed as the first argument to every function in the library, except to &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt;, which creates a Lua state from scratch.</source>
          <target state="translated">Se debe pasar un puntero a esta estructura como primer argumento para cada funci&amp;oacute;n de la biblioteca, excepto &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; &lt;/a&gt; , que crea un estado Lua desde cero.</target>
        </trans-unit>
        <trans-unit id="85de206f279ceaa430602580da3ee35a9d16cd8a" translate="yes" xml:space="preserve">
          <source>A program can modify the behavior of the length operator for any value but strings through the &lt;code&gt;__len&lt;/code&gt; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Un programa puede modificar el comportamiento del operador de longitud para cualquier valor excepto cadenas a trav&amp;eacute;s del &lt;code&gt;__len&lt;/code&gt; __len (ver &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd8bd19d7a0da2968b0e0676ae5bf0fd9c2f4e0b" translate="yes" xml:space="preserve">
          <source>A reference is a unique integer key. As long as you do not manually add integer keys into table &lt;code&gt;t&lt;/code&gt;, &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt; ensures the uniqueness of the key it returns. You can retrieve an object referred by reference &lt;code&gt;r&lt;/code&gt; by calling &lt;code&gt;lua_rawgeti(L, t, r)&lt;/code&gt;. Function &lt;a href=&quot;#luaL_unref&quot;&gt;&lt;code&gt;luaL_unref&lt;/code&gt;&lt;/a&gt; frees a reference and its associated object.</source>
          <target state="translated">Una referencia es una clave entera &amp;uacute;nica. Siempre que no agregue manualmente claves enteras en la tabla &lt;code&gt;t&lt;/code&gt; , &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; asegura la unicidad de la clave que devuelve. Puede recuperar un objeto referido por la referencia &lt;code&gt;r&lt;/code&gt; llamando a &lt;code&gt;lua_rawgeti(L, t, r)&lt;/code&gt; . La funci&amp;oacute;n &lt;a href=&quot;#luaL_unref&quot;&gt; &lt;code&gt;luaL_unref&lt;/code&gt; &lt;/a&gt; libera una referencia y su objeto asociado.</target>
        </trans-unit>
        <trans-unit id="3b65f579bb9fc7a51aa1518e80e26143edddac9f" translate="yes" xml:space="preserve">
          <source>A reference is a unique integer key. As long as you do not manually add integer keys into the table &lt;code&gt;t&lt;/code&gt;, &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt; ensures the uniqueness of the key it returns. You can retrieve an object referred by the reference &lt;code&gt;r&lt;/code&gt; by calling &lt;code&gt;lua_rawgeti(L, t, r)&lt;/code&gt;. The function &lt;a href=&quot;#luaL_unref&quot;&gt;&lt;code&gt;luaL_unref&lt;/code&gt;&lt;/a&gt; frees a reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5886b914eeefc6fe9c97cf73899590f4453edb42" translate="yes" xml:space="preserve">
          <source>A running coroutine is yieldable if it is not the main thread and it is not inside a non-yieldable C function.</source>
          <target state="translated">Una corutina en marcha es rendible si no es el hilo principal y no está dentro de una función C no rendible.</target>
        </trans-unit>
        <trans-unit id="02104a4bea2c474acf11ad8559dae77d59bc940e" translate="yes" xml:space="preserve">
          <source>A single name can denote a global variable or a local variable (or a function's formal parameter, which is a particular kind of local variable):</source>
          <target state="translated">Un solo nombre puede denotar una variable global o una variable local (o un parámetro formal de una función,que es un tipo particular de variable local):</target>
        </trans-unit>
        <trans-unit id="4794c70aa8c69ef2ec8802a8dbbec4cdd33e83e8" translate="yes" xml:space="preserve">
          <source>A string buffer allows C code to build Lua strings piecemeal. Its pattern of use is as follows:</source>
          <target state="translated">Un buffer de cadenas permite al código C construir cadenas Lua poco a poco.Su patrón de uso es el siguiente:</target>
        </trans-unit>
        <trans-unit id="f87ecc6b4255bdd2af412051775ae09429630fe0" translate="yes" xml:space="preserve">
          <source>A string describing some compile-time configurations for packages. This string is a sequence of lines:</source>
          <target state="translated">Una cadena que describe algunas configuraciones de tiempo de compilación para los paquetes.Esta cadena es una secuencia de líneas:</target>
        </trans-unit>
        <trans-unit id="667756bbe7670acfae5aeea4b4d1a1a336746c54" translate="yes" xml:space="preserve">
          <source>A string is converted to an integer or a float following its syntax and the rules of the Lua lexer. The string may have also leading and trailing whitespaces and a sign. All conversions from strings to numbers accept both a dot and the current locale mark as the radix character. (The Lua lexer, however, accepts only a dot.) If the string is not a valid numeral, the conversion fails. If necessary, the result of this first step is then converted to a specific number subtype following the previous rules for conversions between floats and integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abda2a67131cc4c6e97b6f92e4934b679bf8a21b" translate="yes" xml:space="preserve">
          <source>A string with the path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a C loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23bdad6197a85560a746feae91d149db8518e26" translate="yes" xml:space="preserve">
          <source>A string with the path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a Lua loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec6a000811b19de6807d9f5d778634007385bd8" translate="yes" xml:space="preserve">
          <source>A structure used to carry different pieces of information about a function or an activation record. &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; fills only the private part of this structure, for later use. To fill the other fields of &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; with useful information, call &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Una estructura que se utiliza para transportar diferentes piezas de informaci&amp;oacute;n sobre una funci&amp;oacute;n o un registro de activaci&amp;oacute;n. &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; llena solo la parte privada de esta estructura, para uso posterior. Para llenar los otros campos de &lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; con informaci&amp;oacute;n &amp;uacute;til, llame a &lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e6cc803896921b54b6c0c6d1372e559fbc21d7" translate="yes" xml:space="preserve">
          <source>A structure used to carry different pieces of information about a function or an activation record. &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; fills only the private part of this structure, for later use. To fill the other fields of &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; with useful information, you must call &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f70841dbcffb4668b72f4ee9f5d20362ac22ade" translate="yes" xml:space="preserve">
          <source>A table to store loaders for specific modules (see &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Una mesa para almacenar cargadores para m&amp;oacute;dulos espec&amp;iacute;ficos (ver &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c7b924969ceba2c59eef4a850d350c4cfb8d1b7b" translate="yes" xml:space="preserve">
          <source>A table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to control how to find modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04907543b8fecfeecd0da3b12b889da3eb87f79e" translate="yes" xml:space="preserve">
          <source>A table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to control how to load modules.</source>
          <target state="translated">Una tabla utilizada por &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; para controlar c&amp;oacute;mo cargar m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="236d800446c3c980d88f62e84b598b19165287ba" translate="yes" xml:space="preserve">
          <source>A table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to control which modules are already loaded. When you require a module &lt;code&gt;modname&lt;/code&gt; and &lt;code&gt;package.loaded[modname]&lt;/code&gt; is not false, &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; simply returns the value stored there.</source>
          <target state="translated">Una tabla utilizada por &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; para controlar qu&amp;eacute; m&amp;oacute;dulos ya est&amp;aacute;n cargados. Cuando necesita un &lt;code&gt;modname&lt;/code&gt; de m&amp;oacute;dulo y &lt;code&gt;package.loaded[modname]&lt;/code&gt; no es falso, &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; simplemente devuelve el valor almacenado all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="b29d9ef1e9f7cc0edb2ef63bd4e9310e7273fbcc" translate="yes" xml:space="preserve">
          <source>A table with exactly one border is called a &lt;em&gt;sequence&lt;/em&gt;. For instance, the table &lt;code&gt;{10, 20, 30, 40, 50}&lt;/code&gt; is a sequence, as it has only one border (5). The table &lt;code&gt;{10, 20, 30, nil, 50}&lt;/code&gt; has two borders (3 and 5), and therefore it is not a sequence. (The &lt;b&gt;nil&lt;/b&gt; at index 4 is called a &lt;em&gt;hole&lt;/em&gt;.) The table &lt;code&gt;{nil, 20, 30, nil, nil, 60, nil}&lt;/code&gt; has three borders (0, 3, and 6) and three holes (at indices 1, 4, and 5), so it is not a sequence, too. The table &lt;code&gt;{}&lt;/code&gt; is a sequence with border 0. Note that non-natural keys do not interfere with whether a table is a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3862e82890432c457763712f15a7fd6f5e4a1a62" translate="yes" xml:space="preserve">
          <source>A table with exactly one border is called a &lt;em&gt;sequence&lt;/em&gt;. For instance, the table &lt;code&gt;{10, 20, 30, 40, 50}&lt;/code&gt; is a sequence, as it has only one border (5). The table &lt;code&gt;{10, 20, 30, nil, 50}&lt;/code&gt; has two borders (3 and 5), and therefore it is not a sequence. The table &lt;code&gt;{nil, 20, 30, nil, nil, 60, nil}&lt;/code&gt; has three borders (0, 3, and 6), so it is not a sequence, too. The table &lt;code&gt;{}&lt;/code&gt; is a sequence with border 0. Note that non-natural keys do not interfere with whether a table is a sequence.</source>
          <target state="translated">Una tabla con exactamente un borde se llama &lt;em&gt;secuencia&lt;/em&gt; . Por ejemplo, la tabla &lt;code&gt;{10, 20, 30, 40, 50}&lt;/code&gt; es una secuencia, ya que solo tiene un borde (5). La tabla &lt;code&gt;{10, 20, 30, nil, 50}&lt;/code&gt; tiene dos bordes (3 y 5) y, por lo tanto, no es una secuencia. La tabla &lt;code&gt;{nil, 20, 30, nil, nil, 60, nil}&lt;/code&gt; tiene tres bordes (0, 3 y 6), por lo que tampoco es una secuencia. La tabla &lt;code&gt;{}&lt;/code&gt; es una secuencia con borde 0. Tenga en cuenta que las claves no naturales no interfieren con si una tabla es una secuencia.</target>
        </trans-unit>
        <trans-unit id="0d3f40da2d8f70f83b27ea28adbba3891980e807" translate="yes" xml:space="preserve">
          <source>A table with weak keys and strong values is also called an &lt;em&gt;ephemeron table&lt;/em&gt;. In an ephemeron table, a value is considered reachable only if its key is reachable. In particular, if the only reference to a key comes through its value, the pair is removed.</source>
          <target state="translated">Una tabla con claves d&amp;eacute;biles y valores fuertes tambi&amp;eacute;n se llama &lt;em&gt;tabla de efem&amp;eacute;rides&lt;/em&gt; . En una tabla de efem&amp;eacute;rides, un valor se considera accesible solo si su clave es accesible. En particular, si la &amp;uacute;nica referencia a una clave proviene de su valor, el par se elimina.</target>
        </trans-unit>
        <trans-unit id="c314cbbbabf225b3a951c9dc3ade2abfd472e6d5" translate="yes" xml:space="preserve">
          <source>A to-be-closed variable behaves like a constant local variable, except that its value is &lt;em&gt;closed&lt;/em&gt; whenever the variable goes out of scope, including normal block termination, exiting its block by &lt;b&gt;break&lt;/b&gt;/&lt;b&gt;goto&lt;/b&gt;/&lt;b&gt;return&lt;/b&gt;, or exiting by an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e936e6f28db7848cd749bfcf6bd58b1a46b052" translate="yes" xml:space="preserve">
          <source>A typical table traversal looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4654fe97bf7d302a9567895699edd89cbcd9e791" translate="yes" xml:space="preserve">
          <source>A typical traversal looks like this:</source>
          <target state="translated">Un típico travesaño se ve así:</target>
        </trans-unit>
        <trans-unit id="56d6e1795249533ab7eb0411e5a66433e31c3e9e" translate="yes" xml:space="preserve">
          <source>A weak table can have weak keys, weak values, or both. A table with weak values allows the collection of its values, but prevents the collection of its keys. A table with both weak keys and weak values allows the collection of both keys and values. In any case, if either the key or the value is collected, the whole pair is removed from the table. The weakness of a table is controlled by the &lt;code&gt;__mode&lt;/code&gt; field of its metatable. If the &lt;code&gt;__mode&lt;/code&gt; field is a string containing the character '&lt;code&gt;k&lt;/code&gt;', the keys in the table are weak. If &lt;code&gt;__mode&lt;/code&gt; contains '&lt;code&gt;v&lt;/code&gt;', the values in the table are weak.</source>
          <target state="translated">Una tabla d&amp;eacute;bil puede tener claves d&amp;eacute;biles, valores d&amp;eacute;biles o ambos. Una tabla con valores d&amp;eacute;biles permite la recopilaci&amp;oacute;n de sus valores, pero evita la recopilaci&amp;oacute;n de sus claves. Una tabla con claves d&amp;eacute;biles y valores d&amp;eacute;biles permite la recopilaci&amp;oacute;n de claves y valores. En cualquier caso, si se recopila la clave o el valor, el par completo se elimina de la tabla. La debilidad de una tabla est&amp;aacute; controlada por el campo &lt;code&gt;__mode&lt;/code&gt; de su metatabla. Si el campo &lt;code&gt;__mode&lt;/code&gt; es una cadena que contiene el car&amp;aacute;cter ' &lt;code&gt;k&lt;/code&gt; ', las claves de la tabla son d&amp;eacute;biles. Si &lt;code&gt;__mode&lt;/code&gt; contiene ' &lt;code&gt;v&lt;/code&gt; ', los valores de la tabla son d&amp;eacute;biles.</target>
        </trans-unit>
        <trans-unit id="05441c96afe91d476bca9fda9e9b499237ab33b1" translate="yes" xml:space="preserve">
          <source>A weak table can have weak keys, weak values, or both. A table with weak values allows the collection of its values, but prevents the collection of its keys. A table with both weak keys and weak values allows the collection of both keys and values. In any case, if either the key or the value is collected, the whole pair is removed from the table. The weakness of a table is controlled by the &lt;code&gt;__mode&lt;/code&gt; field of its metatable. This metavalue, if present, must be one of the following strings: &quot;&lt;code&gt;k&lt;/code&gt;&quot;, for a table with weak keys; &quot;&lt;code&gt;v&lt;/code&gt;&quot;, for a table with weak values; or &quot;&lt;code&gt;kv&lt;/code&gt;&quot;, for a table with both weak keys and values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="318d4efd331848e3807a2165e170def930a474b2" translate="yes" xml:space="preserve">
          <source>Acceptable indices serve to avoid extra tests against the stack top when querying the stack. For instance, a C function can query its third argument without the need to check whether there is a third argument, that is, without the need to check whether 3 is a valid index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7df36d7d8ed1468bab871c0aefed53b43ba4c0" translate="yes" xml:space="preserve">
          <source>Acceptable indices serve to avoid extra tests against the stack top when querying the stack. For instance, a C function can query its third argument without the need to first check whether there is a third argument, that is, without the need to check whether 3 is a valid index.</source>
          <target state="translated">Los índices aceptables sirven para evitar pruebas adicionales contra la parte superior de la pila cuando se consulta la pila.Por ejemplo,una función C puede consultar su tercer argumento sin necesidad de comprobar primero si hay un tercer argumento,es decir,sin necesidad de comprobar si 3 es un índice válido.</target>
        </trans-unit>
        <trans-unit id="51c17633ca2c048cb9e8c69ecfd444fc1aeb9bb6" translate="yes" xml:space="preserve">
          <source>Accepts any index, or 0, and sets the stack top to this index. If the new top is greater than the old one, then the new elements are filled with &lt;b&gt;nil&lt;/b&gt;. If &lt;code&gt;index&lt;/code&gt; is 0, then all stack elements are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9bead715d3aed55f00ef8b226e3b3d6b628f98c" translate="yes" xml:space="preserve">
          <source>Accepts any index, or 0, and sets the stack top to this index. If the new top is larger than the old one, then the new elements are filled with &lt;b&gt;nil&lt;/b&gt;. If &lt;code&gt;index&lt;/code&gt; is 0, then all stack elements are removed.</source>
          <target state="translated">Acepta cualquier &amp;iacute;ndice, o 0, y establece la parte superior de la pila en este &amp;iacute;ndice. Si la parte superior nueva es m&amp;aacute;s grande que la anterior, los elementos nuevos se rellenan con &lt;b&gt;nil&lt;/b&gt; . Si el &lt;code&gt;index&lt;/code&gt; es 0, se eliminan todos los elementos de la pila.</target>
        </trans-unit>
        <trans-unit id="b86c2f6147e79a1b4297baac1948764dddd622d9" translate="yes" xml:space="preserve">
          <source>Adds a copy of the string &lt;code&gt;s&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;), replacing any occurrence of the string &lt;code&gt;p&lt;/code&gt; with the string &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa67d1b55b60391424ed0215f797f8cda588620a" translate="yes" xml:space="preserve">
          <source>Adds the byte &lt;code&gt;c&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Agrega el byte &lt;code&gt;c&lt;/code&gt; al b&amp;uacute;fer &lt;code&gt;B&lt;/code&gt; (ver &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e90d8fb3354b196fdab7ad34fbe37926f7654b63" translate="yes" xml:space="preserve">
          <source>Adds the string pointed to by &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;l&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). The string can contain embedded zeros.</source>
          <target state="translated">Agrega la cadena apuntada por &lt;code&gt;s&lt;/code&gt; con longitud &lt;code&gt;l&lt;/code&gt; al b&amp;uacute;fer &lt;code&gt;B&lt;/code&gt; (ver &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ). La cadena puede contener ceros incrustados.</target>
        </trans-unit>
        <trans-unit id="a1554fdc1fb0aa862c71bc7fc397a26d3a4ef58d" translate="yes" xml:space="preserve">
          <source>Adds the value at the top of the stack to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). Pops the value.</source>
          <target state="translated">Agrega el valor en la parte superior de la pila al b&amp;uacute;fer &lt;code&gt;B&lt;/code&gt; (ver &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ). Destaca el valor.</target>
        </trans-unit>
        <trans-unit id="a5515574738d5addfdb921d2d442909f86caa02c" translate="yes" xml:space="preserve">
          <source>Adds the value on the top of the stack to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). Pops the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805463d8104725860e0a53e77554865962b221ce" translate="yes" xml:space="preserve">
          <source>Adds the zero-terminated string pointed to by &lt;code&gt;s&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Agrega la cadena terminada en cero apuntada por &lt;code&gt;s&lt;/code&gt; al b&amp;uacute;fer &lt;code&gt;B&lt;/code&gt; (ver &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="71ca21350559a88942a584e333d8d2fdeaeb2968" translate="yes" xml:space="preserve">
          <source>Adds to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;) a string of length &lt;code&gt;n&lt;/code&gt; previously copied to the buffer area (see &lt;a href=&quot;#luaL_prepbuffer&quot;&gt;&lt;code&gt;luaL_prepbuffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Agrega al b&amp;uacute;fer &lt;code&gt;B&lt;/code&gt; (ver &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ) una cadena de longitud &lt;code&gt;n&lt;/code&gt; previamente copiada al &amp;aacute;rea del b&amp;uacute;fer (ver &lt;a href=&quot;#luaL_prepbuffer&quot;&gt; &lt;code&gt;luaL_prepbuffer&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="43ddd8457c1f8e3ac7b12299c1894d4afcf69996" translate="yes" xml:space="preserve">
          <source>Adds to the buffer &lt;code&gt;B&lt;/code&gt; a string of length &lt;code&gt;n&lt;/code&gt; previously copied to the buffer area (see &lt;a href=&quot;#luaL_prepbuffer&quot;&gt;&lt;code&gt;luaL_prepbuffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ca9092d4638ba4ef06c7f156a5034ca7a383dc2" translate="yes" xml:space="preserve">
          <source>After an error, the other pending closing methods will still be called. Errors in these methods interrupt the respective method and generate a warning, but are otherwise ignored; the error reported is only the original one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bf8213e7ff3700b5b856d615911be85fad5679" translate="yes" xml:space="preserve">
          <source>After handling its options, &lt;code&gt;lua&lt;/code&gt; runs the given &lt;em&gt;script&lt;/em&gt;. When called without arguments, &lt;code&gt;lua&lt;/code&gt; behaves as &lt;code&gt;lua -v -i&lt;/code&gt; when the standard input (&lt;code&gt;stdin&lt;/code&gt;) is a terminal, and as &lt;code&gt;lua -&lt;/code&gt; otherwise.</source>
          <target state="translated">Despu&amp;eacute;s de manejar sus opciones, &lt;code&gt;lua&lt;/code&gt; ejecuta el &lt;em&gt;script&lt;/em&gt; dado . Cuando se llama sin argumentos, &lt;code&gt;lua&lt;/code&gt; se comporta como &lt;code&gt;lua -v -i&lt;/code&gt; cuando la entrada est&amp;aacute;ndar ( &lt;code&gt;stdin&lt;/code&gt; ) es una terminal, y como &lt;code&gt;lua -&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="cd5095c5631224575daa0d2a16efe769846a0a84" translate="yes" xml:space="preserve">
          <source>After that initialization, the loop body is repeated with the value of the control variable going through an arithmetic progression, starting at the initial value, with a common difference given by the step. A negative step makes a decreasing sequence; a step equal to zero raises an error. The loop continues while the value is less than or equal to the limit (greater than or equal to for a negative step). If the initial value is already greater than the limit (or less than, if the step is negative), the body is not executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15063350c6a79260afaac68065c69671ef9eeded" translate="yes" xml:space="preserve">
          <source>Alignment works as follows: For each option, the format gets extra padding until the data starts at an offset that is a multiple of the minimum between the option size and the maximum alignment; this minimum must be a power of 2. Options &quot;&lt;code&gt;c&lt;/code&gt;&quot; and &quot;&lt;code&gt;z&lt;/code&gt;&quot; are not aligned; option &quot;&lt;code&gt;s&lt;/code&gt;&quot; follows the alignment of its starting integer.</source>
          <target state="translated">La alineaci&amp;oacute;n funciona de la siguiente manera: para cada opci&amp;oacute;n, el formato obtiene un relleno adicional hasta que los datos comienzan en un desplazamiento que es un m&amp;uacute;ltiplo del m&amp;iacute;nimo entre el tama&amp;ntilde;o de la opci&amp;oacute;n y la alineaci&amp;oacute;n m&amp;aacute;xima; este m&amp;iacute;nimo debe ser una potencia de 2. Las opciones &quot; &lt;code&gt;c&lt;/code&gt; &quot; y &quot; &lt;code&gt;z&lt;/code&gt; &quot; no est&amp;aacute;n alineadas; la opci&amp;oacute;n &quot; &lt;code&gt;s&lt;/code&gt; &quot; sigue la alineaci&amp;oacute;n de su n&amp;uacute;mero entero inicial.</target>
        </trans-unit>
        <trans-unit id="3f5b4e7445d1ae596693345d80aebb59b269536b" translate="yes" xml:space="preserve">
          <source>All argument expressions are evaluated before the call. A call of the form &lt;code&gt;f{&lt;em&gt;fields&lt;/em&gt;}&lt;/code&gt; is syntactic sugar for &lt;code&gt;f({&lt;em&gt;fields&lt;/em&gt;})&lt;/code&gt;; that is, the argument list is a single new table. A call of the form &lt;code&gt;f'&lt;em&gt;string&lt;/em&gt;'&lt;/code&gt; (or &lt;code&gt;f&quot;&lt;em&gt;string&lt;/em&gt;&quot;&lt;/code&gt; or &lt;code&gt;f[[&lt;em&gt;string&lt;/em&gt;]]&lt;/code&gt;) is syntactic sugar for &lt;code&gt;f('&lt;em&gt;string&lt;/em&gt;')&lt;/code&gt;; that is, the argument list is a single literal string.</source>
          <target state="translated">Todas las expresiones de los argumentos se eval&amp;uacute;an antes de la llamada. Una llamada de la forma &lt;code&gt;f{&lt;em&gt;fields&lt;/em&gt;}&lt;/code&gt; es az&amp;uacute;car sint&amp;aacute;ctico para &lt;code&gt;f({&lt;em&gt;fields&lt;/em&gt;})&lt;/code&gt; ; es decir, la lista de argumentos es una &amp;uacute;nica tabla nueva. Una llamada de la forma &lt;code&gt;f'&lt;em&gt;string&lt;/em&gt;'&lt;/code&gt; (o &lt;code&gt;f&quot;&lt;em&gt;string&lt;/em&gt;&quot;&lt;/code&gt; o &lt;code&gt;f[[&lt;em&gt;string&lt;/em&gt;]]&lt;/code&gt; ) es az&amp;uacute;car sint&amp;aacute;ctico para &lt;code&gt;f('&lt;em&gt;string&lt;/em&gt;')&lt;/code&gt; ; es decir, la lista de argumentos es una &amp;uacute;nica cadena literal.</target>
        </trans-unit>
        <trans-unit id="acc9b360c0f165382f26927b4e5133003a413b44" translate="yes" xml:space="preserve">
          <source>All bitwise operations convert its operands to integers (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;), operate on all bits of those integers, and result in an integer.</source>
          <target state="translated">Todas las operaciones bit a bit convierten sus operandos en enteros (ver &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; ), operan en todos los bits de esos enteros y dan como resultado un entero.</target>
        </trans-unit>
        <trans-unit id="f305da96ae003ba3953ef2d24d1bf9f7d1a7db44" translate="yes" xml:space="preserve">
          <source>All conversions from strings to numbers accept both a dot and the current locale mark as the radix character. (The Lua lexer, however, accepts only a dot.)</source>
          <target state="translated">Todas las conversiones de cuerdas a números aceptan tanto un punto como la marca local actual como el carácter de radix.(El lexer Lua,sin embargo,acepta sólo un punto.)</target>
        </trans-unit>
        <trans-unit id="e8fc76868f788278527229cf8ae331ac5e9af057" translate="yes" xml:space="preserve">
          <source>All functions and types from the auxiliary library are defined in header file &lt;code&gt;lauxlib.h&lt;/code&gt; and have a prefix &lt;code&gt;luaL_&lt;/code&gt;.</source>
          <target state="translated">Todas las funciones y tipos de la biblioteca auxiliar se definen en el archivo de encabezado &lt;code&gt;lauxlib.h&lt;/code&gt; y tienen el prefijo &lt;code&gt;luaL_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b5a80d9354e5e4fed6af6805ce75ff37321a509" translate="yes" xml:space="preserve">
          <source>All functions in the auxiliary library are built on top of the basic API, and so they provide nothing that cannot be done with that API. Nevertheless, the use of the auxiliary library ensures more consistency to your code.</source>
          <target state="translated">Todas las funciones de la biblioteca auxiliar están construidas sobre la API básica,por lo que no proporcionan nada que no se pueda hacer con esa API.Sin embargo,el uso de la biblioteca auxiliar asegura más consistencia a su código.</target>
        </trans-unit>
        <trans-unit id="f6848b784c95c8339b84a72671e794bafd5c29ba" translate="yes" xml:space="preserve">
          <source>All functions in this library are provided inside the &lt;a id=&quot;pdf-debug&quot;&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/a&gt; table. All functions that operate over a thread have an optional first argument which is the thread to operate over. The default is always the current thread.</source>
          <target state="translated">Todas las funciones de esta biblioteca se proporcionan dentro de la tabla de &lt;a id=&quot;pdf-debug&quot;&gt; &lt;code&gt;debug&lt;/code&gt; &lt;/a&gt; . Todas las funciones que operan sobre un hilo tienen un primer argumento opcional que es el hilo sobre el que operar. El valor predeterminado es siempre el hilo actual.</target>
        </trans-unit>
        <trans-unit id="8b98fc2da2d38e4cd78c4bb220a6cf5b66fcdbf5" translate="yes" xml:space="preserve">
          <source>All libraries are implemented through the official C API and are provided as separate C modules. Currently, Lua has the following standard libraries:</source>
          <target state="translated">Todas las bibliotecas se implementan a través de la API oficial de C y se proporcionan como módulos C independientes.Actualmente,Lua tiene las siguientes bibliotecas estándar:</target>
        </trans-unit>
        <trans-unit id="2ddf3fcb87cb7aa36a3e9257adc61c9538941609" translate="yes" xml:space="preserve">
          <source>All libraries are implemented through the official C API and are provided as separate C modules. Unless otherwise noted, these library functions do not adjust its number of arguments to its expected parameters. For instance, a function documented as &lt;code&gt;foo(arg)&lt;/code&gt; should not be called without an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10be42d50eaafb61e391ebcac5db4409c7956116" translate="yes" xml:space="preserve">
          <source>All options are handled in order, except &lt;code&gt;-i&lt;/code&gt; and &lt;code&gt;-E&lt;/code&gt;. For instance, an invocation like</source>
          <target state="translated">Todas las opciones se manejan en orden, excepto &lt;code&gt;-i&lt;/code&gt; y &lt;code&gt;-E&lt;/code&gt; . Por ejemplo, una invocaci&amp;oacute;n como</target>
        </trans-unit>
        <trans-unit id="1b7b7722940601955048fe77c6f31cf2d41c7761" translate="yes" xml:space="preserve">
          <source>All padding is filled with zeros by &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; (and ignored by &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Todo el relleno se rellena con ceros mediante &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; (y &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; lo ignora&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9b755abe9d75601691ed05f64e03dc198bf8b4ec" translate="yes" xml:space="preserve">
          <source>All padding is filled with zeros by &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; and ignored by &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35badbdc9570c80976734173cdf4107df29b353" translate="yes" xml:space="preserve">
          <source>All searchers except the first one (preload) return as the extra value the file name where the module was found, as returned by &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;. The first searcher returns no extra value.</source>
          <target state="translated">Todos los buscadores excepto el primero (precarga) devuelven como valor adicional el nombre del archivo donde se encontr&amp;oacute; el m&amp;oacute;dulo, tal como lo devuelve &lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; &lt;/a&gt; . El primer buscador no devuelve ning&amp;uacute;n valor adicional.</target>
        </trans-unit>
        <trans-unit id="b6765aac3d8b1ff358b93ffd4bc398b44e25b71d" translate="yes" xml:space="preserve">
          <source>All searchers except the first one (preload) return as the extra value the file path where the module was found, as returned by &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;. The first searcher always returns the string &quot;&lt;code&gt;:preload:&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fdaa228f269a7cd440d59ce3942091cbc2215f" translate="yes" xml:space="preserve">
          <source>All three control expressions are evaluated only once, before the loop starts. They must all result in numbers.</source>
          <target state="translated">Las tres expresiones de control se evalúan una sola vez,antes de que comience el bucle.Todas deben resultar en números.</target>
        </trans-unit>
        <trans-unit id="08a75b1f27277905293829400b5db953b7bb2d39" translate="yes" xml:space="preserve">
          <source>All values in Lua are &lt;em&gt;first-class values&lt;/em&gt;. This means that all values can be stored in variables, passed as arguments to other functions, and returned as results.</source>
          <target state="translated">Todos los valores en Lua son valores de &lt;em&gt;primera clase&lt;/em&gt; . Esto significa que todos los valores pueden almacenarse en variables, pasarse como argumentos a otras funciones y devolverse como resultados.</target>
        </trans-unit>
        <trans-unit id="071aee471e8d140c1bd1a97470ea43f75e0a45ed" translate="yes" xml:space="preserve">
          <source>All values in Lua are first-class values. This means that all values can be stored in variables, passed as arguments to other functions, and returned as results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd0e37afd18d9af3189d6b1b6cc7f9956125931" translate="yes" xml:space="preserve">
          <source>Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. &lt;code&gt;next&lt;/code&gt; returns the next index of the table and its associated value. When called with &lt;b&gt;nil&lt;/b&gt; as its second argument, &lt;code&gt;next&lt;/code&gt; returns an initial index and its associated value. When called with the last index, or with &lt;b&gt;nil&lt;/b&gt; in an empty table, &lt;code&gt;next&lt;/code&gt; returns &lt;b&gt;nil&lt;/b&gt;. If the second argument is absent, then it is interpreted as &lt;b&gt;nil&lt;/b&gt;. In particular, you can use &lt;code&gt;next(t)&lt;/code&gt; to check whether a table is empty.</source>
          <target state="translated">Permite que un programa recorra todos los campos de una tabla. Su primer argumento es una tabla y su segundo argumento es un &amp;iacute;ndice en esta tabla. &lt;code&gt;next&lt;/code&gt; devuelve el siguiente &amp;iacute;ndice de la tabla y su valor asociado. Cuando se llama con &lt;b&gt;nil&lt;/b&gt; como segundo argumento, &lt;code&gt;next&lt;/code&gt; devuelve un &amp;iacute;ndice inicial y su valor asociado. Cuando se llama con el &amp;uacute;ltimo &amp;iacute;ndice, o con &lt;b&gt;nil&lt;/b&gt; en una tabla vac&amp;iacute;a, &lt;code&gt;next&lt;/code&gt; devuelve &lt;b&gt;nil&lt;/b&gt; . Si el segundo argumento est&amp;aacute; ausente, se interpreta como &lt;b&gt;nulo&lt;/b&gt; . En particular, puede usar &lt;code&gt;next(t)&lt;/code&gt; para verificar si una tabla est&amp;aacute; vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="ebc03e7cf3ee58a99f08412145950a59fa5fffde" translate="yes" xml:space="preserve">
          <source>Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. A call to &lt;code&gt;next&lt;/code&gt; returns the next index of the table and its associated value. When called with &lt;b&gt;nil&lt;/b&gt; as its second argument, &lt;code&gt;next&lt;/code&gt; returns an initial index and its associated value. When called with the last index, or with &lt;b&gt;nil&lt;/b&gt; in an empty table, &lt;code&gt;next&lt;/code&gt; returns &lt;b&gt;nil&lt;/b&gt;. If the second argument is absent, then it is interpreted as &lt;b&gt;nil&lt;/b&gt;. In particular, you can use &lt;code&gt;next(t)&lt;/code&gt; to check whether a table is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2a17f106d80620dc6b184a036cc43c0d0d20e9" translate="yes" xml:space="preserve">
          <source>Also as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;, this function only loads the chunk; it does not run it.</source>
          <target state="translated">Tambi&amp;eacute;n como &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; , esta funci&amp;oacute;n solo carga el fragmento; no lo ejecuta.</target>
        </trans-unit>
        <trans-unit id="333012935d43c77111be49619f3626aed605f1f6" translate="yes" xml:space="preserve">
          <source>Although Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a standalone language. An interpreter for Lua as a standalone language, called simply &lt;code&gt;lua&lt;/code&gt;, is provided with the standard distribution. The standalone interpreter includes all standard libraries, including the debug library. Its usage is:</source>
          <target state="translated">Aunque Lua ha sido dise&amp;ntilde;ado como un lenguaje de extensi&amp;oacute;n, para integrarse en un programa anfitri&amp;oacute;n C, tambi&amp;eacute;n se usa con frecuencia como un lenguaje independiente. Con la distribuci&amp;oacute;n est&amp;aacute;ndar se proporciona un int&amp;eacute;rprete de Lua como idioma independiente, llamado simplemente &lt;code&gt;lua&lt;/code&gt; . El int&amp;eacute;rprete independiente incluye todas las bibliotecas est&amp;aacute;ndar, incluida la biblioteca de depuraci&amp;oacute;n. Su uso es:</target>
        </trans-unit>
        <trans-unit id="3fa4ca9bca77aa7261f50ff3ad594e9a7f5b676b" translate="yes" xml:space="preserve">
          <source>Although Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a standalone language. An interpreter for Lua as a standalone language, called simply &lt;code&gt;lua&lt;/code&gt;, is provided with the standard distribution. The standalone interpreter includes all standard libraries. Its usage is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f591bdff24ecb3f0d81234f57e546b0357fc181a" translate="yes" xml:space="preserve">
          <source>An access to a global variable &lt;code&gt;x&lt;/code&gt; is equivalent to &lt;code&gt;_ENV.x&lt;/code&gt;. Due to the way that chunks are compiled, &lt;code&gt;_ENV&lt;/code&gt; is never a global name (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;).</source>
          <target state="translated">Un acceso a una variable global &lt;code&gt;x&lt;/code&gt; es equivalente a &lt;code&gt;_ENV.x&lt;/code&gt; . Debido a la forma en que se compilan los fragmentos, &lt;code&gt;_ENV&lt;/code&gt; nunca es un nombre global (consulte &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6c1adca5ebb817b22e7535a132b307a72e116a1" translate="yes" xml:space="preserve">
          <source>An access to a global variable &lt;code&gt;x&lt;/code&gt; is equivalent to &lt;code&gt;_ENV.x&lt;/code&gt;. Due to the way that chunks are compiled, the variable &lt;code&gt;_ENV&lt;/code&gt; itself is never global (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3489bcbcdb764986900a0e61314738b50570455a" translate="yes" xml:space="preserve">
          <source>An assignment to a global name &lt;code&gt;x = val&lt;/code&gt; is equivalent to the assignment &lt;code&gt;_ENV.x = val&lt;/code&gt; (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;).</source>
          <target state="translated">Una asignaci&amp;oacute;n a un nombre global &lt;code&gt;x = val&lt;/code&gt; es equivalente a la asignaci&amp;oacute;n &lt;code&gt;_ENV.x = val&lt;/code&gt; (ver &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="faeac64cb85287d304252a69d85edf0374894817" translate="yes" xml:space="preserve">
          <source>An integer with the maximum value for an integer.</source>
          <target state="translated">Un entero con el valor máximo para un entero.</target>
        </trans-unit>
        <trans-unit id="7043af6943c0de40fedd4cee1164e62e2ee3cd11" translate="yes" xml:space="preserve">
          <source>An integer with the minimum value for an integer.</source>
          <target state="translated">Un entero con el valor mínimo para un entero.</target>
        </trans-unit>
        <trans-unit id="89500035571ec2dd822bb6945adc5a8f4bd38006" translate="yes" xml:space="preserve">
          <source>An object is considered &lt;em&gt;dead&lt;/em&gt; as soon as the collector can be sure the object will not be accessed again in the normal execution of the program. (&quot;Normal execution&quot; here excludes finalizers, which can resurrect dead objects (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;), and excludes also operations using the debug library.) Note that the time when the collector can be sure that an object is dead may not coincide with the programmer's expectations. The only guarantees are that Lua will not collect an object that may still be accessed in the normal execution of the program, and it will eventually collect an object that is inaccessible from Lua. (Here, &lt;em&gt;inaccessible from Lua&lt;/em&gt; means that neither a variable nor another live object refer to the object.) Because Lua has no knowledge about C code, it never collects objects accessible through the registry (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;), which includes the global environment (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29302dcac6eba15dcddc4542a902b42251fa77ed" translate="yes" xml:space="preserve">
          <source>An opaque structure that points to a thread and indirectly (through the thread) to the whole state of a Lua interpreter. The Lua library is fully reentrant: it has no global variables. All information about a state is accessible through this structure.</source>
          <target state="translated">Una estructura opaca que apunta a un hilo e indirectamente (a través del hilo)a todo el estado de un intérprete de Lua.La biblioteca de Lua es totalmente reentrante:no tiene variables globales.Toda la información sobre un estado es accesible a través de esta estructura.</target>
        </trans-unit>
        <trans-unit id="3b2afdee2bff80f7fa27a65f139ce4ca79afecee" translate="yes" xml:space="preserve">
          <source>Any byte in a literal string not explicitly affected by the previous rules represents itself. However, Lua opens files for parsing in text mode, and the system file functions may have problems with some control characters. So, it is safer to represent non-text data as a quoted literal with explicit escape sequences for the non-text characters.</source>
          <target state="translated">Cualquier byte de una cadena literal no afectado explícitamente por las reglas anteriores se representa a sí mismo.Sin embargo,Lua abre archivos para el análisis sintáctico en modo de texto,y las funciones de los archivos del sistema pueden tener problemas con algunos caracteres de control.Por lo tanto,es más seguro representar los datos no textuales como un literal citado con secuencias de escape explícitas para los caracteres no textuales.</target>
        </trans-unit>
        <trans-unit id="d8ae7634037aa2de99f261a6927bf456c142bf84" translate="yes" xml:space="preserve">
          <source>Any byte in a literal string not explicitly affected by the previous rules represents itself. However, Lua opens files for parsing in text mode, and the system's file functions may have problems with some control characters. So, it is safer to represent binary data as a quoted literal with explicit escape sequences for the non-text characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0060ede52bc0952daad17758c1e09ebce620eaf5" translate="yes" xml:space="preserve">
          <source>Any change in the weakness of a table may take effect only at the next collect cycle. In particular, if you change the weakness to a stronger mode, Lua may still collect some items from that table before the change takes effect.</source>
          <target state="translated">Cualquier cambio en la debilidad de una mesa puede tener efecto sólo en el siguiente ciclo de recolección.En particular,si cambia la debilidad a un modo más fuerte,Lua todavía puede recoger algunos artículos de esa mesa antes de que el cambio surta efecto.</target>
        </trans-unit>
        <trans-unit id="3f738315de077ed686d71d19c5f4cc3874696c9c" translate="yes" xml:space="preserve">
          <source>Any error inside the called function is propagated upwards (with a &lt;code&gt;longjmp&lt;/code&gt;).</source>
          <target state="translated">Cualquier error dentro de la funci&amp;oacute;n llamada se propaga hacia arriba (con un &lt;code&gt;longjmp&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c05361fbe6d9fff1fca4506d17a5414301a0c77" translate="yes" xml:space="preserve">
          <source>Any error while calling and running the function is propagated upwards (with a &lt;code&gt;longjmp&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be7b70704b4f056a67191dc249a6f48adae84426" translate="yes" xml:space="preserve">
          <source>Any error while running a finalizer generates a warning; the error is not propagated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b037f464e01b904a69f5673d5e1aeced352fda1" translate="yes" xml:space="preserve">
          <source>Any expression enclosed in parentheses always results in only one value. Thus, &lt;code&gt;(f(x,y,z))&lt;/code&gt; is always a single value, even if &lt;code&gt;f&lt;/code&gt; returns several values. (The value of &lt;code&gt;(f(x,y,z))&lt;/code&gt; is the first value returned by &lt;code&gt;f&lt;/code&gt; or &lt;b&gt;nil&lt;/b&gt; if &lt;code&gt;f&lt;/code&gt; does not return any values.)</source>
          <target state="translated">Cualquier expresi&amp;oacute;n entre par&amp;eacute;ntesis siempre da como resultado un solo valor. Por tanto, &lt;code&gt;(f(x,y,z))&lt;/code&gt; es siempre un valor &amp;uacute;nico, incluso si &lt;code&gt;f&lt;/code&gt; devuelve varios valores. (El valor de &lt;code&gt;(f(x,y,z))&lt;/code&gt; es el primer valor devuelto por &lt;code&gt;f&lt;/code&gt; o &lt;b&gt;nil&lt;/b&gt; si &lt;code&gt;f&lt;/code&gt; no devuelve ning&amp;uacute;n valor.)</target>
        </trans-unit>
        <trans-unit id="7a4d95ffedc5bbaa1adc38079189908a5033db52" translate="yes" xml:space="preserve">
          <source>Any format string starts as if prefixed by &quot;&lt;code&gt;!1=&lt;/code&gt;&quot;, that is, with maximum alignment of 1 (no alignment) and native endianness.</source>
          <target state="translated">Cualquier cadena de formato comienza como si tuviera el prefijo &quot; &lt;code&gt;!1=&lt;/code&gt; &quot;, es decir, con una alineaci&amp;oacute;n m&amp;aacute;xima de 1 (sin alineaci&amp;oacute;n) y endianidad nativa.</target>
        </trans-unit>
        <trans-unit id="646e2060904f262b44a42847531c18e9dbcd493e" translate="yes" xml:space="preserve">
          <source>Any function in the API that receives stack indices works only with &lt;em&gt;valid indices&lt;/em&gt; or &lt;em&gt;acceptable indices&lt;/em&gt;.</source>
          <target state="translated">Cualquier funci&amp;oacute;n en la API que reciba &amp;iacute;ndices de pila funciona solo con &lt;em&gt;&amp;iacute;ndices v&amp;aacute;lidos&lt;/em&gt; o &lt;em&gt;&amp;iacute;ndices aceptables&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1687626599a587d25400fc4ce2fc6e934da6f356" translate="yes" xml:space="preserve">
          <source>Any function to be callable by Lua must follow the correct protocol to receive its parameters and return its results (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Cualquier funci&amp;oacute;n a la que pueda llamar Lua debe seguir el protocolo correcto para recibir sus par&amp;aacute;metros y devolver sus resultados (ver &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="185d7a33eb3655abd764787ebf509971ea6392f6" translate="yes" xml:space="preserve">
          <source>Any table used as the value of &lt;code&gt;_ENV&lt;/code&gt; is called an &lt;em&gt;environment&lt;/em&gt;.</source>
          <target state="translated">Cualquier tabla utilizada como valor de &lt;code&gt;_ENV&lt;/code&gt; se denomina &lt;em&gt;entorno&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c786e87f6aa7c682c7c682888f5d96ee64056b" translate="yes" xml:space="preserve">
          <source>Any variable name is assumed to be global unless explicitly declared as a local (see &lt;a href=&quot;#3.3.7&quot;&gt;&amp;sect;3.3.7&lt;/a&gt;). Local variables are &lt;em&gt;lexically scoped&lt;/em&gt;: local variables can be freely accessed by functions defined inside their scope (see &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;).</source>
          <target state="translated">Se asume que cualquier nombre de variable es global a menos que se declare expl&amp;iacute;citamente como local (ver &lt;a href=&quot;#3.3.7&quot;&gt;&amp;sect;3.3.7&lt;/a&gt; ). Las variables locales tienen un &lt;em&gt;&amp;aacute;mbito l&amp;eacute;xico&lt;/em&gt; : se puede acceder libremente a las variables locales mediante funciones definidas dentro de su &amp;aacute;mbito (ver &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a78246fd7dee1462777916bec1d99382a25c060e" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;f&lt;/code&gt; is the hook function. &lt;code&gt;mask&lt;/code&gt; specifies on which events the hook will be called: it is formed by a bitwise OR of the constants &lt;a id=&quot;pdf-LUA_MASKCALL&quot;&gt;&lt;code&gt;LUA_MASKCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_MASKRET&quot;&gt;&lt;code&gt;LUA_MASKRET&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_MASKLINE&quot;&gt;&lt;code&gt;LUA_MASKLINE&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_MASKCOUNT&quot;&gt;&lt;code&gt;LUA_MASKCOUNT&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;count&lt;/code&gt; argument is only meaningful when the mask includes &lt;code&gt;LUA_MASKCOUNT&lt;/code&gt;. For each event, the hook is called as explained below:</source>
          <target state="translated">El argumento &lt;code&gt;f&lt;/code&gt; es la funci&amp;oacute;n de gancho. &lt;code&gt;mask&lt;/code&gt; especifica en qu&amp;eacute; eventos se llamar&amp;aacute; el gancho: est&amp;aacute; formado por un OR bit a bit de las constantes &lt;a id=&quot;pdf-LUA_MASKCALL&quot;&gt; &lt;code&gt;LUA_MASKCALL&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_MASKRET&quot;&gt; &lt;code&gt;LUA_MASKRET&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_MASKLINE&quot;&gt; &lt;code&gt;LUA_MASKLINE&lt;/code&gt; &lt;/a&gt; y &lt;a id=&quot;pdf-LUA_MASKCOUNT&quot;&gt; &lt;code&gt;LUA_MASKCOUNT&lt;/code&gt; &lt;/a&gt; . El argumento de &lt;code&gt;count&lt;/code&gt; solo es significativo cuando la m&amp;aacute;scara incluye &lt;code&gt;LUA_MASKCOUNT&lt;/code&gt; . Para cada evento, el gancho se llama como se explica a continuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="fef66cc0524e2056cb5b4bfefd4a25591b35ea85" translate="yes" xml:space="preserve">
          <source>Arguments have the following syntax:</source>
          <target state="translated">Los argumentos tienen la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">Operadores aritméticos</target>
        </trans-unit>
        <trans-unit id="9c834ef6f4ffe0319762efe06a63f2041cc46cbe" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;, this function only loads the chunk; it does not run it.</source>
          <target state="translated">Como &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; , esta funci&amp;oacute;n solo carga el fragmento; no lo ejecuta.</target>
        </trans-unit>
        <trans-unit id="75c1c75adc6b7338308d99ea7e69e602ff6179f0" translate="yes" xml:space="preserve">
          <source>As a special case, the capture &lt;code&gt;()&lt;/code&gt; captures the current string position (a number). For instance, if we apply the pattern &lt;code&gt;&quot;()aa()&quot;&lt;/code&gt; on the string &lt;code&gt;&quot;flaaap&quot;&lt;/code&gt;, there will be two captures: 3 and 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88fec743575b609e2abb343864ded003e7d1df35" translate="yes" xml:space="preserve">
          <source>As a special case, the empty capture &lt;code&gt;()&lt;/code&gt; captures the current string position (a number). For instance, if we apply the pattern &lt;code&gt;&quot;()aa()&quot;&lt;/code&gt; on the string &lt;code&gt;&quot;flaaap&quot;&lt;/code&gt;, there will be two captures: 3 and 5.</source>
          <target state="translated">Como caso especial, la captura vac&amp;iacute;a &lt;code&gt;()&lt;/code&gt; captura la posici&amp;oacute;n actual de la cadena (un n&amp;uacute;mero). Por ejemplo, si aplicamos el patr&amp;oacute;n &lt;code&gt;&quot;()aa()&quot;&lt;/code&gt; en la cadena &lt;code&gt;&quot;flaaap&quot;&lt;/code&gt; , habr&amp;aacute; dos capturas: 3 y 5.</target>
        </trans-unit>
        <trans-unit id="608b10320a24077d4060bee1b1e8e54c6bf52c0d" translate="yes" xml:space="preserve">
          <source>As a special case, when &lt;code&gt;n&lt;/code&gt; is 0 the function returns the start of the encoding of the character that contains the &lt;code&gt;i&lt;/code&gt;-th byte of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Como caso especial, cuando &lt;code&gt;n&lt;/code&gt; es 0, la funci&amp;oacute;n devuelve el inicio de la codificaci&amp;oacute;n del car&amp;aacute;cter que contiene el &lt;code&gt;i&lt;/code&gt; -&amp;eacute;simo byte de &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f16f56abca8a29fd824d5c58c8606029f22356" translate="yes" xml:space="preserve">
          <source>As an example of how coroutines work, consider the following code:</source>
          <target state="translated">Como ejemplo de cómo funcionan las cortinas,considere el siguiente código:</target>
        </trans-unit>
        <trans-unit id="55fd3c324f7088b1e4e4ef9627852502a3224e79" translate="yes" xml:space="preserve">
          <source>As an example, consider the following definitions:</source>
          <target state="translated">A modo de ejemplo,considérense las siguientes definiciones:</target>
        </trans-unit>
        <trans-unit id="7cd41136af5368119d5e9b9681dc2f5307b6d39b" translate="yes" xml:space="preserve">
          <source>As an example, in a system using ASCII (in which '&lt;code&gt;a&lt;/code&gt;' is coded as 97, newline is coded as 10, and '&lt;code&gt;1&lt;/code&gt;' is coded as 49), the five literal strings below denote the same string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74222d71219a9516ef23c72ea9fe93b833f10fca" translate="yes" xml:space="preserve">
          <source>As an example, the following function receives a variable number of numeric arguments and returns their average and their sum:</source>
          <target state="translated">Por ejemplo,la siguiente función recibe un número variable de argumentos numéricos y devuelve su promedio y su suma:</target>
        </trans-unit>
        <trans-unit id="e53c537a917ff61bdeaf745cd25b581253b587b4" translate="yes" xml:space="preserve">
          <source>As an example, the following loop will iterate over all the words from string &lt;code&gt;s&lt;/code&gt;, printing one per line:</source>
          <target state="translated">Como ejemplo, el siguiente ciclo iterar&amp;aacute; sobre todas las palabras de la cadena &lt;code&gt;s&lt;/code&gt; , imprimiendo una por l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="10342e6eb6b2fd67fdff1919f85d366e227d7fc9" translate="yes" xml:space="preserve">
          <source>As an extension language, Lua has no notion of a &quot;main&quot; program: it works &lt;em&gt;embedded&lt;/em&gt; in a host client, called the &lt;em&gt;embedding program&lt;/em&gt; or simply the &lt;em&gt;host&lt;/em&gt;. (Frequently, this host is the stand-alone &lt;code&gt;lua&lt;/code&gt; program.) The host program can invoke functions to execute a piece of Lua code, can write and read Lua variables, and can register C functions to be called by Lua code. Through the use of C functions, Lua can be augmented to cope with a wide range of different domains, thus creating customized programming languages sharing a syntactical framework.</source>
          <target state="translated">Como lenguaje de extensi&amp;oacute;n, Lua no tiene la noci&amp;oacute;n de un programa &quot;principal&quot;: funciona &lt;em&gt;integrado&lt;/em&gt; en un cliente host, llamado &lt;em&gt;programa de incrustaci&amp;oacute;n&lt;/em&gt; o simplemente &lt;em&gt;host&lt;/em&gt; . (Con frecuencia, este host es el programa &lt;code&gt;lua&lt;/code&gt; aut&amp;oacute;nomo ). El programa host puede invocar funciones para ejecutar un fragmento de c&amp;oacute;digo Lua, puede escribir y leer variables Lua y puede registrar funciones C para que sean llamadas por c&amp;oacute;digo Lua. Mediante el uso de funciones C, Lua se puede aumentar para hacer frente a una amplia gama de dominios diferentes, creando as&amp;iacute; lenguajes de programaci&amp;oacute;n personalizados que comparten un marco sint&amp;aacute;ctico.</target>
        </trans-unit>
        <trans-unit id="18e8b25f2432d6d4994bc8412127c9c6a9fd835a" translate="yes" xml:space="preserve">
          <source>As an illustration, consider the following function:</source>
          <target state="translated">A modo de ilustración,considere la siguiente función:</target>
        </trans-unit>
        <trans-unit id="f3e9897f2d1040dc7274b7624604db4d8b6ac14f" translate="yes" xml:space="preserve">
          <source>As in most C libraries, the Lua API functions do not check their arguments for validity or consistency. However, you can change this behavior by compiling Lua with the macro &lt;a id=&quot;pdf-LUA_USE_APICHECK&quot;&gt;&lt;code&gt;LUA_USE_APICHECK&lt;/code&gt;&lt;/a&gt; defined.</source>
          <target state="translated">Como en la mayor&amp;iacute;a de las bibliotecas de C, las funciones de la API de Lua no comprueban la validez o consistencia de sus argumentos. Sin embargo, puede cambiar este comportamiento compilando Lua con la macro &lt;a id=&quot;pdf-LUA_USE_APICHECK&quot;&gt; &lt;code&gt;LUA_USE_APICHECK&lt;/code&gt; &lt;/a&gt; definida.</target>
        </trans-unit>
        <trans-unit id="24c57582c72da098884fa076ca9862645c6e1334" translate="yes" xml:space="preserve">
          <source>As usual, you can use parentheses to change the precedences of an expression. The concatenation ('&lt;code&gt;..&lt;/code&gt;') and exponentiation ('&lt;code&gt;^&lt;/code&gt;') operators are right associative. All other binary operators are left associative.</source>
          <target state="translated">Como de costumbre, puede utilizar par&amp;eacute;ntesis para cambiar las precedencias de una expresi&amp;oacute;n. Los operadores de concatenaci&amp;oacute;n (' &lt;code&gt;..&lt;/code&gt; ') y exponenciaci&amp;oacute;n (' &lt;code&gt;^&lt;/code&gt; ') son asociativos a la derecha. Todos los dem&amp;aacute;s operadores binarios se dejan asociativos.</target>
        </trans-unit>
        <trans-unit id="c494ccaeb3182bcdc157f35c0dfa7624c73ca058" translate="yes" xml:space="preserve">
          <source>As we will discuss further in &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; and &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;, any reference to a free name (that is, a name not bound to any declaration) &lt;code&gt;var&lt;/code&gt; is syntactically translated to &lt;code&gt;_ENV.var&lt;/code&gt;. Moreover, every chunk is compiled in the scope of an external local variable named &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt;), so &lt;code&gt;_ENV&lt;/code&gt; itself is never a free name in a chunk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c78100181d409a60710e1b3cf4f61c8d6e6ff7" translate="yes" xml:space="preserve">
          <source>As will be discussed in &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; and &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;, any reference to a free name (that is, a name not bound to any declaration) &lt;code&gt;var&lt;/code&gt; is syntactically translated to &lt;code&gt;_ENV.var&lt;/code&gt;. Moreover, every chunk is compiled in the scope of an external local variable named &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt;), so &lt;code&gt;_ENV&lt;/code&gt; itself is never a free name in a chunk.</source>
          <target state="translated">Como se discutir&amp;aacute; en &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; y &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt; , cualquier referencia a un nombre libre (es decir, un nombre no vinculado a ninguna declaraci&amp;oacute;n) &lt;code&gt;var&lt;/code&gt; se traduce sint&amp;aacute;cticamente a &lt;code&gt;_ENV.var&lt;/code&gt; . Adem&amp;aacute;s, cada fragmento se compila en el &amp;aacute;mbito de una variable local externa llamada &lt;code&gt;_ENV&lt;/code&gt; (ver &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt; ), por lo que &lt;code&gt;_ENV&lt;/code&gt; en s&amp;iacute; mismo nunca es un nombre libre en un fragmento.</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="3b37b5372cc754e07c5399ff64d83d0917ca19d3" translate="yes" xml:space="preserve">
          <source>At start-up, Lua initializes this variable with the value of the environment variable &lt;a id=&quot;pdf-LUA_PATH_5_3&quot;&gt;&lt;code&gt;LUA_PATH_5_3&lt;/code&gt;&lt;/a&gt; or the environment variable &lt;a id=&quot;pdf-LUA_PATH&quot;&gt;&lt;code&gt;LUA_PATH&lt;/code&gt;&lt;/a&gt; or with a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;, if those environment variables are not defined. Any &quot;&lt;code&gt;;;&lt;/code&gt;&quot; in the value of the environment variable is replaced by the default path.</source>
          <target state="translated">Al inicio, Lua inicializa esta variable con el valor de la variable de entorno &lt;a id=&quot;pdf-LUA_PATH_5_3&quot;&gt; &lt;code&gt;LUA_PATH_5_3&lt;/code&gt; &lt;/a&gt; o la variable de entorno &lt;a id=&quot;pdf-LUA_PATH&quot;&gt; &lt;code&gt;LUA_PATH&lt;/code&gt; &lt;/a&gt; o con una ruta predeterminada definida en &lt;code&gt;luaconf.h&lt;/code&gt; , si esas variables de entorno no est&amp;aacute;n definidas. Cualquier &quot; &lt;code&gt;;;&lt;/code&gt; &quot; en el valor de la variable de entorno se reemplaza por la ruta predeterminada.</target>
        </trans-unit>
        <trans-unit id="965a8cf37e38c2b411498c9c98d14641fb5a6675" translate="yes" xml:space="preserve">
          <source>At start-up, Lua initializes this variable with the value of the environment variable &lt;a id=&quot;pdf-LUA_PATH_5_4&quot;&gt;&lt;code&gt;LUA_PATH_5_4&lt;/code&gt;&lt;/a&gt; or the environment variable &lt;a id=&quot;pdf-LUA_PATH&quot;&gt;&lt;code&gt;LUA_PATH&lt;/code&gt;&lt;/a&gt; or with a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;, if those environment variables are not defined. A &quot;&lt;code&gt;;;&lt;/code&gt;&quot; in the value of the environment variable is replaced by the default path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2035e1ea09cb7bf6e711b474366484c8cc2dadf" translate="yes" xml:space="preserve">
          <source>At the end of each garbage-collection cycle, the finalizers are called in the reverse order that the objects were marked for finalization, among those collected in that cycle; that is, the first finalizer to be called is the one associated with the object marked last in the program. The execution of each finalizer may occur at any point during the execution of the regular code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c846064774d3fc9a0c20918821eeca9ef19288b" translate="yes" xml:space="preserve">
          <source>At the end of each garbage-collection cycle, the finalizers for objects are called in the reverse order that the objects were marked for finalization, among those collected in that cycle; that is, the first finalizer to be called is the one associated with the object marked last in the program. The execution of each finalizer may occur at any point during the execution of the regular code.</source>
          <target state="translated">Al final de cada ciclo de recolección de basura,los finalizadores de los objetos se llaman en el orden inverso al que se marcaron los objetos para su finalización,entre los recogidos en ese ciclo;es decir,el primer finalizador que se llama es el asociado al objeto marcado en último lugar en el programa.La ejecución de cada finalizador puede ocurrir en cualquier momento durante la ejecución del código regular.</target>
        </trans-unit>
        <trans-unit id="7b97861ba9e02b6857fb91f3d5b2a8013e6bffda" translate="yes" xml:space="preserve">
          <source>Auxiliary Library</source>
          <target state="translated">Biblioteca auxiliar</target>
        </trans-unit>
        <trans-unit id="5eab8fc3ffa32aa796174a77104a420884806a36" translate="yes" xml:space="preserve">
          <source>Basic Concepts</source>
          <target state="translated">Conceptos básicos</target>
        </trans-unit>
        <trans-unit id="8f4cb4f0510bd523b95aae50ed7278eb36070fa4" translate="yes" xml:space="preserve">
          <source>Because Lua has garbage collection, there is no guarantee that the pointer returned by &lt;code&gt;lua_tolstring&lt;/code&gt; will be valid after the corresponding Lua value is removed from the stack.</source>
          <target state="translated">Debido a que Lua tiene recolecci&amp;oacute;n de basura, no hay garant&amp;iacute;a de que el puntero devuelto por &lt;code&gt;lua_tolstring&lt;/code&gt; sea ​​v&amp;aacute;lido despu&amp;eacute;s de que el valor Lua correspondiente se elimine de la pila.</target>
        </trans-unit>
        <trans-unit id="9867425ec7caa9ffe56a90d8c50150cf1121dd68" translate="yes" xml:space="preserve">
          <source>Because Lua is an embedded extension language, Lua code starts running by a call from C code in the host program. (When you use Lua standalone, the &lt;code&gt;lua&lt;/code&gt; application is the host program.) Usually, this call is protected; so, when an otherwise unprotected error occurs during the compilation or execution of a Lua chunk, control returns to the host, which can take appropriate measures, such as printing an error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e550731f0f7f512357918c5d533714fe0133257" translate="yes" xml:space="preserve">
          <source>Because Lua is an embedded extension language, all Lua actions start from C code in the host program calling a function from the Lua library. (When you use Lua standalone, the &lt;code&gt;lua&lt;/code&gt; application is the host program.) Whenever an error occurs during the compilation or execution of a Lua chunk, control returns to the host, which can take appropriate measures (such as printing an error message).</source>
          <target state="translated">Debido a que Lua es un lenguaje de extensi&amp;oacute;n integrado, todas las acciones de Lua comienzan desde el c&amp;oacute;digo C en el programa anfitri&amp;oacute;n que llama a una funci&amp;oacute;n de la biblioteca Lua. (Cuando utiliza Lua de forma independiente, la aplicaci&amp;oacute;n &lt;code&gt;lua&lt;/code&gt; es el programa anfitri&amp;oacute;n). Siempre que se produce un error durante la compilaci&amp;oacute;n o ejecuci&amp;oacute;n de un fragmento de Lua, el control vuelve al anfitri&amp;oacute;n, que puede tomar las medidas adecuadas (como imprimir un mensaje de error).</target>
        </trans-unit>
        <trans-unit id="0fad2c0ffc739d9f59d3ff44590e127f2bd7b785" translate="yes" xml:space="preserve">
          <source>Because metatables are regular tables, they can contain arbitrary fields, not only the event names defined above. Some functions in the standard library (e.g., &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;) use other fields in metatables for their own purposes.</source>
          <target state="translated">Debido a que las metatablas son tablas regulares, pueden contener campos arbitrarios, no solo los nombres de eventos definidos anteriormente. Algunas funciones en la biblioteca est&amp;aacute;ndar (por ejemplo, &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; ) usan otros campos en metatablas para sus propios prop&amp;oacute;sitos.</target>
        </trans-unit>
        <trans-unit id="495988fc34ba4e9a5d09e95cf0bb4b8cc2aa52f9" translate="yes" xml:space="preserve">
          <source>Because of the lexical scoping rules, local variables can be freely accessed by functions defined inside their scope. A local variable used by an inner function is called an &lt;em&gt;upvalue&lt;/em&gt; (or &lt;em&gt;external local variable&lt;/em&gt;, or simply &lt;em&gt;external variable&lt;/em&gt;) inside the inner function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceef25556ecac12093ede647b1814c0461f552fa" translate="yes" xml:space="preserve">
          <source>Because of the lexical scoping rules, local variables can be freely accessed by functions defined inside their scope. A local variable used by an inner function is called an &lt;em&gt;upvalue&lt;/em&gt;, or &lt;em&gt;external local variable&lt;/em&gt;, inside the inner function.</source>
          <target state="translated">Debido a las reglas de alcance l&amp;eacute;xico, las funciones definidas dentro de su alcance pueden acceder libremente a las variables locales. Una variable local utilizada por una funci&amp;oacute;n interna se denomina valor &lt;em&gt;ascendente&lt;/em&gt; , o &lt;em&gt;variable local externa&lt;/em&gt; , dentro de la funci&amp;oacute;n interna.</target>
        </trans-unit>
        <trans-unit id="91c78c2bb9d15ae1e5ff63f172baeb9a3a177d44" translate="yes" xml:space="preserve">
          <source>Because the object being collected must still be used by the finalizer, that object (and other objects accessible only through it) must be &lt;em&gt;resurrected&lt;/em&gt; by Lua. Usually, this resurrection is transient, and the object memory is freed in the next garbage-collection cycle. However, if the finalizer stores the object in some global place (e.g., a global variable), then the resurrection is permanent. Moreover, if the finalizer marks a finalizing object for finalization again, its finalizer will be called again in the next cycle where the object is dead. In any case, the object memory is freed only in a GC cycle where the object is dead and not marked for finalization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100abb5c579b396b2c34374efb4ff5f9d32a765e" translate="yes" xml:space="preserve">
          <source>Because the object being collected must still be used by the finalizer, that object (and other objects accessible only through it) must be &lt;em&gt;resurrected&lt;/em&gt; by Lua. Usually, this resurrection is transient, and the object memory is freed in the next garbage-collection cycle. However, if the finalizer stores the object in some global place (e.g., a global variable), then the resurrection is permanent. Moreover, if the finalizer marks a finalizing object for finalization again, its finalizer will be called again in the next cycle where the object is unreachable. In any case, the object memory is freed only in a GC cycle where the object is unreachable and not marked for finalization.</source>
          <target state="translated">Debido a que el finalizador debe seguir usando el objeto que se est&amp;aacute; recolectando, ese objeto (y otros objetos accesibles solo a trav&amp;eacute;s de &amp;eacute;l) debe ser &lt;em&gt;resucitado&lt;/em&gt; por Lua. Por lo general, esta resurrecci&amp;oacute;n es transitoria y la memoria del objeto se libera en el siguiente ciclo de recolecci&amp;oacute;n de basura. Sin embargo, si el finalizador almacena el objeto en alg&amp;uacute;n lugar global (por ejemplo, una variable global), entonces la resurrecci&amp;oacute;n es permanente. Adem&amp;aacute;s, si el finalizador marca un objeto de finalizaci&amp;oacute;n para su finalizaci&amp;oacute;n nuevamente, su finalizador ser&amp;aacute; llamado nuevamente en el siguiente ciclo en el que el objeto es inalcanzable. En cualquier caso, la memoria del objeto se libera solo en un ciclo de GC en el que el objeto es inalcanzable y no est&amp;aacute; marcado para su finalizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6d5b47e3e1cfd97e4c1094c7771191d76ffbf4e8" translate="yes" xml:space="preserve">
          <source>Before running any code, &lt;code&gt;lua&lt;/code&gt; collects all command-line arguments in a global table called &lt;code&gt;arg&lt;/code&gt;. The script name goes to index 0, the first argument after the script name goes to index 1, and so on. Any arguments before the script name (that is, the interpreter name plus its options) go to negative indices. For instance, in the call</source>
          <target state="translated">Antes de ejecutar cualquier c&amp;oacute;digo, &lt;code&gt;lua&lt;/code&gt; recopila todos los argumentos de la l&amp;iacute;nea de comandos en una tabla global llamada &lt;code&gt;arg&lt;/code&gt; . El nombre de la secuencia de comandos va al &amp;iacute;ndice 0, el primer argumento despu&amp;eacute;s del nombre de la secuencia de comandos va al &amp;iacute;ndice 1, y as&amp;iacute; sucesivamente. Todos los argumentos antes del nombre del script (es decir, el nombre del int&amp;eacute;rprete m&amp;aacute;s sus opciones) van a &amp;iacute;ndices negativos. Por ejemplo, en la llamada</target>
        </trans-unit>
        <trans-unit id="509f3eacc4f43f22f296d1f65ef40407b2f61bf0" translate="yes" xml:space="preserve">
          <source>Before the assignment, the list of values is &lt;em&gt;adjusted&lt;/em&gt; to the length of the list of variables. If there are more values than needed, the excess values are thrown away. If there are fewer values than needed, the list is extended with &lt;b&gt;nil&lt;/b&gt;'s. If the list of expressions ends with a function call, then all values returned by that call enter the list of values, before the adjustment (except when the call is enclosed in parentheses; see &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d09b228ef66be3a22078c99e4ef2dcb3df78d1" translate="yes" xml:space="preserve">
          <source>Before the assignment, the list of values is &lt;em&gt;adjusted&lt;/em&gt; to the length of the list of variables. If there are more values than needed, the excess values are thrown away. If there are fewer values than needed, the list is extended with as many &lt;b&gt;nil&lt;/b&gt;'s as needed. If the list of expressions ends with a function call, then all values returned by that call enter the list of values, before the adjustment (except when the call is enclosed in parentheses; see &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt;).</source>
          <target state="translated">Antes de la asignaci&amp;oacute;n, la lista de valores se &lt;em&gt;ajusta&lt;/em&gt; a la longitud de la lista de variables. Si hay m&amp;aacute;s valores de los necesarios, los valores en exceso se desechan. Si hay menos valores de los necesarios, la lista se ampl&amp;iacute;a con tantos &lt;b&gt;nulos&lt;/b&gt; como sea necesario. Si la lista de expresiones termina con una llamada de funci&amp;oacute;n, entonces todos los valores devueltos por esa llamada ingresan a la lista de valores, antes del ajuste (excepto cuando la llamada est&amp;aacute; entre par&amp;eacute;ntesis; vea &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="746907c57e653b279bf39358594d492bc0bfe3b2" translate="yes" xml:space="preserve">
          <source>Before the first assignment to a variable, its value is &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Antes de la primera asignaci&amp;oacute;n a una variable, su valor es &lt;b&gt;nulo&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="787ed290e954603b60a8b2b5f8c704754b79f560" translate="yes" xml:space="preserve">
          <source>Besides the Lua state, the continuation function has two other parameters: the final status of the call and the context value (&lt;code&gt;ctx&lt;/code&gt;) that was passed originally to &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;. Lua does not use this context value; it only passes this value from the original function to the continuation function. For &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, the status is the same value that would be returned by &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, except that it is &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; when being executed after a yield (instead of &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;). For &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, the status is always &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; when Lua calls the continuation. (For these two functions, Lua will not call the continuation in case of errors, because they do not handle errors.) Similarly, when using &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, you should call the continuation function with &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; as the status. (For &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, there is not much point in calling directly the continuation function, because &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt; usually does not return.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eceec5af294d53441f5ac4ad61816149f7f14e22" translate="yes" xml:space="preserve">
          <source>Besides the Lua state, the continuation function has two other parameters: the final status of the call plus the context value (&lt;code&gt;ctx&lt;/code&gt;) that was passed originally to &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;. (Lua does not use this context value; it only passes this value from the original function to the continuation function.) For &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, the status is the same value that would be returned by &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, except that it is &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; when being executed after a yield (instead of &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;). For &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, the status is always &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; when Lua calls the continuation. (For these two functions, Lua will not call the continuation in case of errors, because they do not handle errors.) Similarly, when using &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, you should call the continuation function with &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; as the status. (For &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, there is not much point in calling directly the continuation function, because &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt; usually does not return.)</source>
          <target state="translated">Adem&amp;aacute;s del estado Lua, la funci&amp;oacute;n de continuaci&amp;oacute;n tiene otros dos par&amp;aacute;metros: el estado final de la llamada m&amp;aacute;s el valor de contexto ( &lt;code&gt;ctx&lt;/code&gt; ) que se pas&amp;oacute; originalmente a &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; . (Lua no usa este valor de contexto; solo pasa este valor de la funci&amp;oacute;n original a la funci&amp;oacute;n de continuaci&amp;oacute;n). Para &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; , el estado es el mismo valor que devolver&amp;iacute;a &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; , excepto que es &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; cuando se ejecuta despu&amp;eacute;s de una rendimiento (en lugar de &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; ). Para &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; , el estado siempre es &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt;cuando Lua llama a la continuaci&amp;oacute;n. (Para estas dos funciones, Lua no llamar&amp;aacute; a la continuaci&amp;oacute;n en caso de errores, porque no manejan errores). De manera similar, cuando use &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; , debe llamar a la funci&amp;oacute;n de continuaci&amp;oacute;n con &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; como estado. (Para &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; , no tiene mucho sentido llamar directamente a la funci&amp;oacute;n de continuaci&amp;oacute;n, porque &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; generalmente no regresa).</target>
        </trans-unit>
        <trans-unit id="178d0c1a22b01e10ab0fe06b4a5afb972b2a24e2" translate="yes" xml:space="preserve">
          <source>Binary operators comprise arithmetic operators (see &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt;), bitwise operators (see &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt;), relational operators (see &lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt;), logical operators (see &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt;), and the concatenation operator (see &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt;). Unary operators comprise the unary minus (see &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt;), the unary bitwise NOT (see &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt;), the unary logical &lt;b&gt;not&lt;/b&gt; (see &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt;), and the unary &lt;em&gt;length operator&lt;/em&gt; (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;).</source>
          <target state="translated">Los operadores binarios comprenden operadores aritm&amp;eacute;ticos (ver &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt; ), operadores bit a bit (v&amp;eacute;ase &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect; 3.4.2&lt;/a&gt; ), operadores relacionales (ver &lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt; ), operadores l&amp;oacute;gicos (ver &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt; ), y el operador de concatenaci&amp;oacute;n (ver &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect; 3.4.6&lt;/a&gt; ). Los operadores unarios comprenden el menos unario (ver &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt; ), el NOT unario bit a bit (ver &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt; ), el &lt;b&gt;no&lt;/b&gt; l&amp;oacute;gico unario (ver &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt; ) y el operador de &lt;em&gt;longitud&lt;/em&gt; unario (ver &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="f06f824cef5caab026aebdaccc85d665d4b620db" translate="yes" xml:space="preserve">
          <source>Bitwise Operators</source>
          <target state="translated">Operadores de Bitwise</target>
        </trans-unit>
        <trans-unit id="54c45c033f5eb914fae27a646cbd9e23d3750d19" translate="yes" xml:space="preserve">
          <source>Blocks</source>
          <target state="translated">Blocks</target>
        </trans-unit>
        <trans-unit id="b864e3b0c9b0957e85741aadf6674e44cf5c2496" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;nargs&lt;/code&gt; and &lt;code&gt;nresults&lt;/code&gt; have the same meaning as in &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;. If there are no errors during the call, &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; behaves exactly like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;. However, if there is any error, &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; catches it, pushes a single value on the stack (the error object), and returns an error code. Like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; always removes the function and its arguments from the stack.</source>
          <target state="translated">Tanto &lt;code&gt;nargs&lt;/code&gt; como &lt;code&gt;nresults&lt;/code&gt; tienen el mismo significado que en &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; . Si no hay errores durante la llamada, &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; se&lt;/a&gt; comporta exactamente como &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; . Sin embargo, si hay alg&amp;uacute;n error, &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; lo detecta , inserta un solo valor en la pila (el objeto de error) y devuelve un c&amp;oacute;digo de error. Como &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; siempre elimina la funci&amp;oacute;n y sus argumentos de la pila.</target>
        </trans-unit>
        <trans-unit id="749baad9cb11596eefaae710a32b14bec750ce16" translate="yes" xml:space="preserve">
          <source>Both function calls and assignments can start with an open parenthesis. This possibility leads to an ambiguity in Lua's grammar. Consider the following fragment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3328c9c8f16b59988d2720e58557b3f6a8cdbbb5" translate="yes" xml:space="preserve">
          <source>Both function calls and vararg expressions can result in multiple values. If a function call is used as a statement (see &lt;a href=&quot;#3.3.6&quot;&gt;&amp;sect;3.3.6&lt;/a&gt;), then its return list is adjusted to zero elements, thus discarding all returned values. If an expression is used as the last (or the only) element of a list of expressions, then no adjustment is made (unless the expression is enclosed in parentheses). In all other contexts, Lua adjusts the result list to one element, either discarding all values except the first one or adding a single &lt;b&gt;nil&lt;/b&gt; if there are no values.</source>
          <target state="translated">Tanto las llamadas a funciones como las expresiones vararg pueden dar como resultado varios valores. Si una llamada de funci&amp;oacute;n se usa como una declaraci&amp;oacute;n (ver &lt;a href=&quot;#3.3.6&quot;&gt;&amp;sect;3.3.6&lt;/a&gt; ), entonces su lista de retorno se ajusta a elementos cero, descartando as&amp;iacute; todos los valores devueltos. Si una expresi&amp;oacute;n se utiliza como &amp;uacute;ltimo (o &amp;uacute;nico) elemento de una lista de expresiones, no se realiza ning&amp;uacute;n ajuste (a menos que la expresi&amp;oacute;n est&amp;eacute; entre par&amp;eacute;ntesis). En todos los dem&amp;aacute;s contextos, Lua ajusta la lista de resultados a un elemento, ya sea descartando todos los valores excepto el primero o agregando un solo &lt;b&gt;cero&lt;/b&gt; si no hay valores.</target>
        </trans-unit>
        <trans-unit id="ef0d7df25b511d8e1f840431681fc99b96959ea0" translate="yes" xml:space="preserve">
          <source>Both right and left shifts fill the vacant bits with zeros. Negative displacements shift to the other direction; displacements with absolute values equal to or higher than the number of bits in an integer result in zero (as all bits are shifted out).</source>
          <target state="translated">Tanto el turno de la derecha como el de la izquierda llenan los espacios vacíos con ceros.Los desplazamientos negativos se desplazan en la otra dirección;los desplazamientos con valores absolutos iguales o superiores al número de bits de un número entero dan como resultado un cero (ya que todos los bits se desplazan hacia fuera).</target>
        </trans-unit>
        <trans-unit id="da6f79f89e4655f35de3f93f152ce488dacf9aed" translate="yes" xml:space="preserve">
          <source>By convention, a one-piece message starting with '&lt;code&gt;@&lt;/code&gt;' is intended to be a &lt;em&gt;control message&lt;/em&gt;, which is a message to the warning system itself. In particular, the standard warning function in Lua recognizes the control messages &quot;&lt;code&gt;@off&lt;/code&gt;&quot;, to stop the emission of warnings, and &quot;&lt;code&gt;@on&lt;/code&gt;&quot;, to (re)start the emission; it ignores unknown control messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606a21a2a41de7578fb85238576a85c01cff0d09" translate="yes" xml:space="preserve">
          <source>By default this type is &lt;code&gt;long long&lt;/code&gt;, (usually a 64-bit two-complement integer), but that can be changed to &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt; (usually a 32-bit two-complement integer). (See &lt;code&gt;LUA_INT_TYPE&lt;/code&gt; in &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">Por defecto, este tipo es &lt;code&gt;long long&lt;/code&gt; (normalmente un entero de dos complementos de 64 bits), pero se puede cambiar a &lt;code&gt;long&lt;/code&gt; o &lt;code&gt;int&lt;/code&gt; (normalmente un entero de dos complementos de 32 bits). (Ver &lt;code&gt;LUA_INT_TYPE&lt;/code&gt; en &lt;code&gt;luaconf.h&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="8d4b756a61274079d48c6b43e4f7a164ad5525c5" translate="yes" xml:space="preserve">
          <source>By default this type is double, but that can be changed to a single float or a long double. (See &lt;code&gt;LUA_FLOAT_TYPE&lt;/code&gt; in &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">De forma predeterminada, este tipo es doble, pero se puede cambiar a un solo flotante o un doble largo. (Ver &lt;code&gt;LUA_FLOAT_TYPE&lt;/code&gt; en &lt;code&gt;luaconf.h&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="29af92c8be46565be89222f77a2f4fb50aaf902e" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;i&lt;/code&gt; is 1 and &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, &lt;code&gt;i&lt;/code&gt; es 1 y &lt;code&gt;j&lt;/code&gt; es &lt;code&gt;#list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0faf3672da025664de4e899fe4c851e162d72458" translate="yes" xml:space="preserve">
          <source>By default, the decoding functions in the &lt;a href=&quot;#pdf-utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt; library do not accept surrogates as valid code points. An extra parameter in these functions makes them more permissive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b94595a9de392a583ea21fcbca5ff4996bbeb4c" translate="yes" xml:space="preserve">
          <source>By default, this area has the size of a pointer to void, but you can recompile Lua with a different size for this area. (See &lt;code&gt;LUA_EXTRASPACE&lt;/code&gt; in &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">De forma predeterminada, esta &amp;aacute;rea tiene el tama&amp;ntilde;o de un puntero para anular, pero puede volver a compilar Lua con un tama&amp;ntilde;o diferente para esta &amp;aacute;rea. (Ver &lt;code&gt;LUA_EXTRASPACE&lt;/code&gt; en &lt;code&gt;luaconf.h&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="03114feec4c78056b8ef7cfc58a14ecddceef3d8" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;#pdf-error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; if the value of its argument &lt;code&gt;v&lt;/code&gt; is false (i.e., &lt;b&gt;nil&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;); otherwise, returns all its arguments. In case of error, &lt;code&gt;message&lt;/code&gt; is the error object; when absent, it defaults to &quot;&lt;code&gt;assertion failed!&lt;/code&gt;&quot;</source>
          <target state="translated">Llama a &lt;a href=&quot;#pdf-error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; si el valor de su argumento &lt;code&gt;v&lt;/code&gt; es falso (es decir, &lt;b&gt;nulo&lt;/b&gt; o &lt;b&gt;falso&lt;/b&gt; ); de lo contrario, devuelve todos sus argumentos. En caso de error, el &lt;code&gt;message&lt;/code&gt; es el objeto de error; cuando est&amp;aacute; ausente, el valor predeterminado es &quot;&amp;iexcl; &lt;code&gt;assertion failed!&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="7dd7336a942c0830e724f83d659a39ec8e4cedbd" translate="yes" xml:space="preserve">
          <source>Calls a function (or a callable object) in protected mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9a6f6c22d821f1d190cf7b504945ad9b4cbdf3" translate="yes" xml:space="preserve">
          <source>Calls a function in protected mode.</source>
          <target state="translated">Llama a una función en modo protegido.</target>
        </trans-unit>
        <trans-unit id="b098c5a2357f0f1bcda94addf0cd58b14d7f56d4" translate="yes" xml:space="preserve">
          <source>Calls a function.</source>
          <target state="translated">Llama a una función.</target>
        </trans-unit>
        <trans-unit id="de41e844283c868632ab60b6dc9990f6e31b48dc" translate="yes" xml:space="preserve">
          <source>Calls a function. Like regular Lua calls, &lt;code&gt;lua_call&lt;/code&gt; respects the &lt;code&gt;__call&lt;/code&gt; metamethod. So, here the word &quot;function&quot; means any callable value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92585404dfb5c102735b49e368c931de0bcf925" translate="yes" xml:space="preserve">
          <source>Calls a metamethod.</source>
          <target state="translated">Se llama metamétodo.</target>
        </trans-unit>
        <trans-unit id="afb856a058891b728039960270f34dcfa7886cb5" translate="yes" xml:space="preserve">
          <source>Calls function &lt;code&gt;f&lt;/code&gt; with the given arguments in &lt;em&gt;protected mode&lt;/em&gt;. This means that any error inside &lt;code&gt;f&lt;/code&gt; is not propagated; instead, &lt;code&gt;pcall&lt;/code&gt; catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, &lt;code&gt;pcall&lt;/code&gt; also returns all results from the call, after this first result. In case of any error, &lt;code&gt;pcall&lt;/code&gt; returns &lt;b&gt;false&lt;/b&gt; plus the error message.</source>
          <target state="translated">Llama a la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; con los argumentos dados en &lt;em&gt;modo protegido&lt;/em&gt; . Esto significa que ning&amp;uacute;n error dentro de &lt;code&gt;f&lt;/code&gt; no se propaga; en su lugar, &lt;code&gt;pcall&lt;/code&gt; detecta el error y devuelve un c&amp;oacute;digo de estado. Su primer resultado es el c&amp;oacute;digo de estado (un booleano), que es verdadero si la llamada se realiza correctamente sin errores. En tal caso, &lt;code&gt;pcall&lt;/code&gt; tambi&amp;eacute;n devuelve todos los resultados de la llamada, despu&amp;eacute;s de este primer resultado. En caso de cualquier error, &lt;code&gt;pcall&lt;/code&gt; devuelve &lt;b&gt;falso&lt;/b&gt; m&amp;aacute;s el mensaje de error.</target>
        </trans-unit>
        <trans-unit id="d13e849aa5160d3c27d99ea69deec271ee71dd22" translate="yes" xml:space="preserve">
          <source>Calls the ISO C function &lt;code&gt;exit&lt;/code&gt; to terminate the host program. If &lt;code&gt;code&lt;/code&gt; is &lt;b&gt;true&lt;/b&gt;, the returned status is &lt;code&gt;EXIT_SUCCESS&lt;/code&gt;; if &lt;code&gt;code&lt;/code&gt; is &lt;b&gt;false&lt;/b&gt;, the returned status is &lt;code&gt;EXIT_FAILURE&lt;/code&gt;; if &lt;code&gt;code&lt;/code&gt; is a number, the returned status is this number. The default value for &lt;code&gt;code&lt;/code&gt; is &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">Llama a la funci&amp;oacute;n ISO C &lt;code&gt;exit&lt;/code&gt; para terminar el programa anfitri&amp;oacute;n. Si el &lt;code&gt;code&lt;/code&gt; es &lt;b&gt;verdadero&lt;/b&gt; , el estado devuelto es &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; ; si el &lt;code&gt;code&lt;/code&gt; es &lt;b&gt;falso&lt;/b&gt; , el estado devuelto es &lt;code&gt;EXIT_FAILURE&lt;/code&gt; ; si el &lt;code&gt;code&lt;/code&gt; es un n&amp;uacute;mero, el estado devuelto es este n&amp;uacute;mero. El valor predeterminado del &lt;code&gt;code&lt;/code&gt; es &lt;b&gt;verdadero&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="e92d3f3f9465503d00e813dd953f01a23f54c8bf" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;f&lt;/code&gt; with the given arguments in &lt;em&gt;protected mode&lt;/em&gt;. This means that any error inside &lt;code&gt;f&lt;/code&gt; is not propagated; instead, &lt;code&gt;pcall&lt;/code&gt; catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, &lt;code&gt;pcall&lt;/code&gt; also returns all results from the call, after this first result. In case of any error, &lt;code&gt;pcall&lt;/code&gt; returns &lt;b&gt;false&lt;/b&gt; plus the error object. Note that errors caught by &lt;code&gt;pcall&lt;/code&gt; do not call a message handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce944ae1c348eb980d3cfe553b3502d5679075a6" translate="yes" xml:space="preserve">
          <source>Captures:</source>
          <target state="translated">Captures:</target>
        </trans-unit>
        <trans-unit id="07ae3990eabe4f174acb75467a4a336ef037a4a0" translate="yes" xml:space="preserve">
          <source>Changes the allocator function of a given state to &lt;code&gt;f&lt;/code&gt; with user data &lt;code&gt;ud&lt;/code&gt;.</source>
          <target state="translated">Cambia la funci&amp;oacute;n de asignaci&amp;oacute;n de un estado dado &lt;code&gt;f&lt;/code&gt; con los datos de usuario &lt;code&gt;ud&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e6cb5ea0746fe0ad7fa97751f92f6157ed314b2" translate="yes" xml:space="preserve">
          <source>Character Class:</source>
          <target state="translated">Clase de personaje:</target>
        </trans-unit>
        <trans-unit id="c7770ae0113235aa718b727fe472f222898a4cd8" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;cond&lt;/code&gt; is true. If it is not, raises an error about the type of the argument &lt;code&gt;arg&lt;/code&gt; with a standard message (see &lt;a href=&quot;#luaL_typeerror&quot;&gt;&lt;code&gt;luaL_typeerror&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2e61548b9d88afb89262b803b6de8bd1e2b486" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;cond&lt;/code&gt; is true. If it is not, raises an error with a standard message (see &lt;a href=&quot;#luaL_argerror&quot;&gt;&lt;code&gt;luaL_argerror&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Comprueba si &lt;code&gt;cond&lt;/code&gt; es verdadera. Si no es as&amp;iacute;, genera un error con un mensaje est&amp;aacute;ndar (ver &lt;a href=&quot;#luaL_argerror&quot;&gt; &lt;code&gt;luaL_argerror&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8de5cdad4b6448665c01e91b06f6e30f6937a4c" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;obj&lt;/code&gt; is a valid file handle. Returns the string &lt;code&gt;&quot;file&quot;&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is an open file handle, &lt;code&gt;&quot;closed file&quot;&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is a closed file handle, or &lt;b&gt;fail&lt;/b&gt; if &lt;code&gt;obj&lt;/code&gt; is not a file handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e06a04dbdce44628706ea99a276e73819504d5ac" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;obj&lt;/code&gt; is a valid file handle. Returns the string &lt;code&gt;&quot;file&quot;&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is an open file handle, &lt;code&gt;&quot;closed file&quot;&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is a closed file handle, or &lt;b&gt;nil&lt;/b&gt; if &lt;code&gt;obj&lt;/code&gt; is not a file handle.</source>
          <target state="translated">Comprueba si &lt;code&gt;obj&lt;/code&gt; es un identificador de archivo v&amp;aacute;lido. Devuelve la cadena &lt;code&gt;&quot;file&quot;&lt;/code&gt; si &lt;code&gt;obj&lt;/code&gt; es un identificador de archivo abierto, &lt;code&gt;&quot;closed file&quot;&lt;/code&gt; si &lt;code&gt;obj&lt;/code&gt; es un identificador de archivo cerrado o &lt;b&gt;nil&lt;/b&gt; si &lt;code&gt;obj&lt;/code&gt; no es un identificador de archivo.</target>
        </trans-unit>
        <trans-unit id="c496e326cea24bf25262cd1109c5d86ac743d694" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;v1&lt;/code&gt; is equal to &lt;code&gt;v2&lt;/code&gt;, without invoking the &lt;code&gt;__eq&lt;/code&gt; metamethod. Returns a boolean.</source>
          <target state="translated">Comprueba si &lt;code&gt;v1&lt;/code&gt; es igual a &lt;code&gt;v2&lt;/code&gt; , sin invocar el &lt;code&gt;__eq&lt;/code&gt; __eq. Devuelve un booleano.</target>
        </trans-unit>
        <trans-unit id="e7a1a2b67c524de176bf4a3fb93211ffc3fb80e2" translate="yes" xml:space="preserve">
          <source>Checks whether the code making the call and the Lua library being called are using the same version of Lua and the same numeric types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f0115e5d4ddbb6ea3de5ce5156cd7d330a1e43" translate="yes" xml:space="preserve">
          <source>Checks whether the core running the call, the core that created the Lua state, and the code making the call are all using the same version of Lua. Also checks whether the core running the call and the core that created the Lua state are using the same address space.</source>
          <target state="translated">Comprueba si el núcleo que ejecuta la llamada,el núcleo que creó el estado de Lua y el código que hace la llamada están todos usando la misma versión de Lua.También comprueba si el núcleo que ejecuta la llamada y el núcleo que creó el estado Lua están usando el mismo espacio de direcciones.</target>
        </trans-unit>
        <trans-unit id="c7e0b23ddda5a7e9cb9a184dd2fb56f91b2baeb4" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;t&lt;/code&gt;. See &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt; for the encoding of types for &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Comprueba si el argumento de la funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; tiene el tipo &lt;code&gt;t&lt;/code&gt; . Vea &lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; &lt;/a&gt; para la codificaci&amp;oacute;n de tipos para &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b16eca39d17a0b9497d463be5d8e1222fd6c33fd" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a number and returns this number converted to a &lt;code&gt;lua_Number&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34efff80aa99092adc3395e3a3c3cec54e5e3ae4" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a number and returns this number.</source>
          <target state="translated">Comprueba si el argumento de la funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; es un n&amp;uacute;mero y devuelve este n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="acb38043b3ab1b3ca9ad57148867e32ff48f49a4" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and returns this string.</source>
          <target state="translated">Comprueba si el argumento de la funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; es una cadena y devuelve esta cadena.</target>
        </trans-unit>
        <trans-unit id="fd80c52685065a298a4083d4f4ae27709571e837" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and returns this string; if &lt;code&gt;l&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt; fills &lt;code&gt;*l&lt;/code&gt; with the string's length.</source>
          <target state="translated">Comprueba si el argumento de la funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; es una cadena y devuelve esta cadena; si &lt;code&gt;l&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; llena &lt;code&gt;*l&lt;/code&gt; con la longitud de la cadena.</target>
        </trans-unit>
        <trans-unit id="5842d397b39cf79e605ee014fa9f083d17de207a" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and returns this string; if &lt;code&gt;l&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt; fills its referent with the string's length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bda7fb8ccffc0321708f10ba7b5f9fa4d8f642f" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and searches for this string in the array &lt;code&gt;lst&lt;/code&gt; (which must be NULL-terminated). Returns the index in the array where the string was found. Raises an error if the argument is not a string or if the string cannot be found.</source>
          <target state="translated">Comprueba si el argumento de la funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; es una cadena y busca esta cadena en la matriz &lt;code&gt;lst&lt;/code&gt; (que debe terminar en NULL). Devuelve el &amp;iacute;ndice de la matriz donde se encontr&amp;oacute; la cadena. Genera un error si el argumento no es una cadena o si no se puede encontrar la cadena.</target>
        </trans-unit>
        <trans-unit id="bfaae18ec316bac0d06a7d8b2f1269f7452bb73f" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a userdata of the type &lt;code&gt;tname&lt;/code&gt; (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;) and returns the userdata address (see &lt;a href=&quot;#lua_touserdata&quot;&gt;&lt;code&gt;lua_touserdata&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Comprueba si el argumento de la funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; es un userdata del tipo &lt;code&gt;tname&lt;/code&gt; (ver &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; ) y devuelve la direcci&amp;oacute;n de userdata (ver &lt;a href=&quot;#lua_touserdata&quot;&gt; &lt;code&gt;lua_touserdata&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f674b5558104cb7ee3833fe2715ff7a7d7c623af" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a userdata of the type &lt;code&gt;tname&lt;/code&gt; (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;) and returns the userdata's memory-block address (see &lt;a href=&quot;#lua_touserdata&quot;&gt;&lt;code&gt;lua_touserdata&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c6e89e09e8362727785a70d17dbd46aac6e5d8" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is an integer (or can be converted to an integer) and returns this integer cast to a &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Comprueba si el argumento de la funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; es un n&amp;uacute;mero entero (o puede convertirse en un n&amp;uacute;mero entero) y devuelve esta &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; entero a un lua_Integer .</target>
        </trans-unit>
        <trans-unit id="783fecf056e15a65f58fa6b7270185e8e643cd1c" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is an integer (or can be converted to an integer) and returns this integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6102b1e83850fda1240175c176c9a4d38d5de9" translate="yes" xml:space="preserve">
          <source>Checks whether the function has an argument of any type (including &lt;b&gt;nil&lt;/b&gt;) at position &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">Comprueba si la funci&amp;oacute;n tiene un argumento de cualquier tipo (incluido &lt;b&gt;nil&lt;/b&gt; ) en la posici&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a527377dfdcd1435bbaa177dc63f2a6bb39b269" translate="yes" xml:space="preserve">
          <source>Chunks</source>
          <target state="translated">Chunks</target>
        </trans-unit>
        <trans-unit id="b103f8207401db3956a89008862d6396af66ca00" translate="yes" xml:space="preserve">
          <source>Chunks can also be precompiled into binary form; see program &lt;code&gt;luac&lt;/code&gt; and function &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt; for details. Programs in source and compiled forms are interchangeable; Lua automatically detects the file type and acts accordingly (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Los fragmentos tambi&amp;eacute;n se pueden precompilar en forma binaria; consulte el programa &lt;code&gt;luac&lt;/code&gt; y la funci&amp;oacute;n &lt;a href=&quot;#pdf-string.dump&quot;&gt; &lt;code&gt;string.dump&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles. Los programas en formato fuente y compilado son intercambiables; Lua detecta autom&amp;aacute;ticamente el tipo de archivo y act&amp;uacute;a en consecuencia (ver &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd0bb028508d5391ee85c23dff25b23b7541487b" translate="yes" xml:space="preserve">
          <source>Chunks can also be precompiled into binary form; see the program &lt;code&gt;luac&lt;/code&gt; and the function &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt; for details. Programs in source and compiled forms are interchangeable; Lua automatically detects the file type and acts accordingly (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3eaf45d0b3c8a3178b4208172178403c6ec43b" translate="yes" xml:space="preserve">
          <source>Close all active to-be-closed variables in the main thread, release all objects in the given Lua state (calling the corresponding garbage-collection metamethods, if any), and frees all dynamic memory used by this state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52566db36dfcd9f2bf9c74284a4bfdd56dc85476" translate="yes" xml:space="preserve">
          <source>Closes &lt;code&gt;file&lt;/code&gt;. Note that files are automatically closed when their handles are garbage collected, but that takes an unpredictable amount of time to happen.</source>
          <target state="translated">Cierra el &lt;code&gt;file&lt;/code&gt; . Tenga en cuenta que los archivos se cierran autom&amp;aacute;ticamente cuando sus identificadores se recolectan como basura, pero eso lleva una cantidad de tiempo impredecible.</target>
        </trans-unit>
        <trans-unit id="c33ada8169beda98f995719f265c2b9b12d94172" translate="yes" xml:space="preserve">
          <source>Closes coroutine &lt;code&gt;co&lt;/code&gt;, that is, closes all its pending to-be-closed variables and puts the coroutine in a dead state. The given coroutine must be dead or suspended. In case of error closing some variable, returns &lt;b&gt;false&lt;/b&gt; plus the error object; otherwise returns &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85fc3e790a7e917db028a531acd7642ab374f383" translate="yes" xml:space="preserve">
          <source>Coercions and Conversions</source>
          <target state="translated">Coacciones y conversiones</target>
        </trans-unit>
        <trans-unit id="226470405b7e44d61ec64752eddb0da20100aa01" translate="yes" xml:space="preserve">
          <source>Compares two Lua values. Returns 1 if the value at index &lt;code&gt;index1&lt;/code&gt; satisfies &lt;code&gt;op&lt;/code&gt; when compared with the value at index &lt;code&gt;index2&lt;/code&gt;, following the semantics of the corresponding Lua operator (that is, it may call metamethods). Otherwise returns 0. Also returns 0 if any of the indices is not valid.</source>
          <target state="translated">Compara dos valores de Lua. Devuelve 1 si el valor en el &amp;iacute;ndice &lt;code&gt;index1&lt;/code&gt; satisface &lt;code&gt;op&lt;/code&gt; cuando se compara con el valor en el &amp;iacute;ndice &lt;code&gt;index2&lt;/code&gt; , siguiendo la sem&amp;aacute;ntica del operador Lua correspondiente (es decir, puede llamar a metam&amp;eacute;todos). De lo contrario, devuelve 0. Tambi&amp;eacute;n devuelve 0 si alguno de los &amp;iacute;ndices no es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="372bb0dd29dd69cdea95231ec5f25f17cfbc3df5" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;n&lt;/code&gt; values at the top of the stack, pops them, and leaves the result at the top. If &lt;code&gt;n&lt;/code&gt; is 1, the result is the single value on the stack (that is, the function does nothing); if &lt;code&gt;n&lt;/code&gt; is 0, the result is the empty string. Concatenation is performed following the usual semantics of Lua (see &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt;).</source>
          <target state="translated">Concatena los &lt;code&gt;n&lt;/code&gt; valores en la parte superior de la pila, los muestra y deja el resultado en la parte superior. Si &lt;code&gt;n&lt;/code&gt; es 1, el resultado es el valor &amp;uacute;nico en la pila (es decir, la funci&amp;oacute;n no hace nada); si &lt;code&gt;n&lt;/code&gt; es 0, el resultado es la cadena vac&amp;iacute;a. La concatenaci&amp;oacute;n se realiza siguiendo la sem&amp;aacute;ntica habitual de Lua (ver &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f844149a29a3be3af394cb4f1bac67af1c62acdd" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;n&lt;/code&gt; values at the top of the stack, pops them, and leaves the result on the top. If &lt;code&gt;n&lt;/code&gt; is 1, the result is the single value on the stack (that is, the function does nothing); if &lt;code&gt;n&lt;/code&gt; is 0, the result is the empty string. Concatenation is performed following the usual semantics of Lua (see &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec037fd21cdbe752cf956ee1da877b809e27461" translate="yes" xml:space="preserve">
          <source>Concatenation</source>
          <target state="translated">Concatenation</target>
        </trans-unit>
        <trans-unit id="398713ac023b450e8c4b5b95b390a7f9a7cf2b57" translate="yes" xml:space="preserve">
          <source>Continuation functions now receive as parameters what they needed to get through &lt;code&gt;lua_getctx&lt;/code&gt;, so &lt;code&gt;lua_getctx&lt;/code&gt; has been removed. Adapt your code accordingly.</source>
          <target state="translated">Las funciones de continuaci&amp;oacute;n ahora reciben como par&amp;aacute;metros lo que necesitaban para pasar a trav&amp;eacute;s de &lt;code&gt;lua_getctx&lt;/code&gt; , por &lt;code&gt;lua_getctx&lt;/code&gt; se ha eliminado lua_getctx . Adapte su c&amp;oacute;digo en consecuencia.</target>
        </trans-unit>
        <trans-unit id="49551177d73377982310b6a218929215d8146939" translate="yes" xml:space="preserve">
          <source>Control Structures</source>
          <target state="translated">Estructuras de control</target>
        </trans-unit>
        <trans-unit id="5ee818a21f2b1465f364481c4e0134cff5f18467" translate="yes" xml:space="preserve">
          <source>Controls the garbage collector.</source>
          <target state="translated">Controla el recolector de basura.</target>
        </trans-unit>
        <trans-unit id="7837da47cfdd57111dc0e4c0e5a4d9267fcf8abb" translate="yes" xml:space="preserve">
          <source>Converts a Lua float to a Lua integer. This macro assumes that &lt;code&gt;n&lt;/code&gt; has an integral value. If that value is within the range of Lua integers, it is converted to an integer and assigned to &lt;code&gt;*p&lt;/code&gt;. The macro results in a boolean indicating whether the conversion was successful. (Note that this range test can be tricky to do correctly without this macro, due to roundings.)</source>
          <target state="translated">Convierte un flotante Lua en un entero Lua. Esta macro asume que &lt;code&gt;n&lt;/code&gt; tiene un valor integral. Si ese valor est&amp;aacute; dentro del rango de n&amp;uacute;meros enteros Lua, se convierte en un n&amp;uacute;mero entero y se asigna a &lt;code&gt;*p&lt;/code&gt; . La macro da como resultado un booleano que indica si la conversi&amp;oacute;n se realiz&amp;oacute; correctamente. (Tenga en cuenta que esta prueba de rango puede ser dif&amp;iacute;cil de realizar correctamente sin esta macro, debido a los redondeos).</target>
        </trans-unit>
        <trans-unit id="5e3aa93bc10e31bb44d33a41364e25a0f08ad8ca" translate="yes" xml:space="preserve">
          <source>Converts a value at the given index to a C function. That value must be a C function; otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Convierte un valor en el &amp;iacute;ndice dado en una funci&amp;oacute;n C. Ese valor debe ser una funci&amp;oacute;n C; de lo contrario, devuelve &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d84bb361f91b5e3df288f36388a7c2ecfd791972" translate="yes" xml:space="preserve">
          <source>Converts any Lua value at the given index to a C string in a reasonable format. The resulting string is pushed onto the stack and also returned by the function (see &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt;). If &lt;code&gt;len&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the function also sets &lt;code&gt;*len&lt;/code&gt; with the string length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d00d889b1b22745925c2a76fb0e196b525544aa3" translate="yes" xml:space="preserve">
          <source>Converts any Lua value at the given index to a C string in a reasonable format. The resulting string is pushed onto the stack and also returned by the function. If &lt;code&gt;len&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the function also sets &lt;code&gt;*len&lt;/code&gt; with the string length.</source>
          <target state="translated">Convierte cualquier valor Lua en el &amp;iacute;ndice dado en una cadena C en un formato razonable. La cadena resultante se inserta en la pila y tambi&amp;eacute;n la devuelve la funci&amp;oacute;n. Si &lt;code&gt;len&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , la funci&amp;oacute;n tambi&amp;eacute;n establece &lt;code&gt;*len&lt;/code&gt; con la longitud de la cadena.</target>
        </trans-unit>
        <trans-unit id="116e857e2ca9e12d4b94e18f89755a1be1b5803e" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to a C boolean value (0 or 1). Like all tests in Lua, &lt;a href=&quot;#lua_toboolean&quot;&gt;&lt;code&gt;lua_toboolean&lt;/code&gt;&lt;/a&gt; returns true for any Lua value different from &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt;; otherwise it returns false. (If you want to accept only actual boolean values, use &lt;a href=&quot;#lua_isboolean&quot;&gt;&lt;code&gt;lua_isboolean&lt;/code&gt;&lt;/a&gt; to test the value's type.)</source>
          <target state="translated">Convierte el valor Lua en el &amp;iacute;ndice dado en un valor booleano C (0 o 1). Como todas las pruebas en Lua, &lt;a href=&quot;#lua_toboolean&quot;&gt; &lt;code&gt;lua_toboolean&lt;/code&gt; &lt;/a&gt; devuelve verdadero para cualquier valor de Lua diferente de &lt;b&gt;falso&lt;/b&gt; y &lt;b&gt;nulo&lt;/b&gt; ; de lo contrario, devuelve falso. (Si desea aceptar solo valores booleanos reales, use &lt;a href=&quot;#lua_isboolean&quot;&gt; &lt;code&gt;lua_isboolean&lt;/code&gt; &lt;/a&gt; para probar el tipo de valor).</target>
        </trans-unit>
        <trans-unit id="d683bc445abde80f362551e45b28ac54bcdd2673" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to a C string. If &lt;code&gt;len&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it sets &lt;code&gt;*len&lt;/code&gt; with the string length. The Lua value must be a string or a number; otherwise, the function returns &lt;code&gt;NULL&lt;/code&gt;. If the value is a number, then &lt;code&gt;lua_tolstring&lt;/code&gt; also &lt;em&gt;changes the actual value in the stack to a string&lt;/em&gt;. (This change confuses &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;lua_tolstring&lt;/code&gt; is applied to keys during a table traversal.)</source>
          <target state="translated">Convierte el valor Lua en el &amp;iacute;ndice dado en una cadena C. Si &lt;code&gt;len&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , establece &lt;code&gt;*len&lt;/code&gt; con la longitud de la cadena. El valor de Lua debe ser una cadena o un n&amp;uacute;mero; de lo contrario, la funci&amp;oacute;n devuelve &lt;code&gt;NULL&lt;/code&gt; . Si el valor es un n&amp;uacute;mero, entonces &lt;code&gt;lua_tolstring&lt;/code&gt; tambi&amp;eacute;n &lt;em&gt;cambia el valor real en la pila a una cadena&lt;/em&gt; . (Este cambio confunde &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; &lt;/a&gt; cuando se aplica &lt;code&gt;lua_tolstring&lt;/code&gt; a las claves durante un recorrido de tabla).</target>
        </trans-unit>
        <trans-unit id="b70c1818d1a487a028f6acabf5e97860ef23c14b" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to the C type &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt;). The Lua value must be a number or a string convertible to a number (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;); otherwise, &lt;a href=&quot;#lua_tonumberx&quot;&gt;&lt;code&gt;lua_tonumberx&lt;/code&gt;&lt;/a&gt; returns 0.</source>
          <target state="translated">Convierte el valor Lua en el &amp;iacute;ndice dado al tipo C &lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt; (ver &lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt; ). El valor de Lua debe ser un n&amp;uacute;mero o una cadena convertible en un n&amp;uacute;mero (ver &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; ); de lo contrario, &lt;a href=&quot;#lua_tonumberx&quot;&gt; &lt;code&gt;lua_tonumberx&lt;/code&gt; &lt;/a&gt; devuelve 0.</target>
        </trans-unit>
        <trans-unit id="15f299b2d961c145de7c7f6e078e5bce8ef3ebc3" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to the signed integral type &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;. The Lua value must be an integer, or a number or string convertible to an integer (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;); otherwise, &lt;code&gt;lua_tointegerx&lt;/code&gt; returns 0.</source>
          <target state="translated">Convierte el valor Lua en el &amp;iacute;ndice dado al tipo integral con &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; . El valor de Lua debe ser un n&amp;uacute;mero entero, o un n&amp;uacute;mero o cadena convertible en un entero (ver &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; ); de lo contrario, &lt;code&gt;lua_tointegerx&lt;/code&gt; devuelve 0.</target>
        </trans-unit>
        <trans-unit id="56b8fd88e6e0c138775b719f7a5a3ba451055b5f" translate="yes" xml:space="preserve">
          <source>Converts the acceptable index &lt;code&gt;idx&lt;/code&gt; into an equivalent absolute index (that is, one that does not depend on the stack top).</source>
          <target state="translated">Convierte el &lt;code&gt;idx&lt;/code&gt; del &amp;iacute;ndice aceptable en un &amp;iacute;ndice absoluto equivalente (es decir, uno que no depende de la parte superior de la pila).</target>
        </trans-unit>
        <trans-unit id="e6fb8705a562a080e28f0029fd5720bc4900e0ba" translate="yes" xml:space="preserve">
          <source>Converts the angle &lt;code&gt;x&lt;/code&gt; from degrees to radians.</source>
          <target state="translated">Convierte el &amp;aacute;ngulo &lt;code&gt;x&lt;/code&gt; de grados a radianes.</target>
        </trans-unit>
        <trans-unit id="a9e18c902b7ca6a770ce37f4b1286eab04eed85b" translate="yes" xml:space="preserve">
          <source>Converts the angle &lt;code&gt;x&lt;/code&gt; from radians to degrees.</source>
          <target state="translated">Convierte el &amp;aacute;ngulo &lt;code&gt;x&lt;/code&gt; de radianes a grados.</target>
        </trans-unit>
        <trans-unit id="f0f8e779d171995ba326ae0853150d5a8e164de0" translate="yes" xml:space="preserve">
          <source>Converts the value at the given index to a Lua thread (represented as &lt;code&gt;lua_State*&lt;/code&gt;). This value must be a thread; otherwise, the function returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Convierte el valor en el &amp;iacute;ndice dado en un hilo Lua (representado como &lt;code&gt;lua_State*&lt;/code&gt; ). Este valor debe ser un hilo; de lo contrario, la funci&amp;oacute;n devuelve &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4765ce3c61b7fb38e87d3739e274dc0e2ee52ed7" translate="yes" xml:space="preserve">
          <source>Converts the value at the given index to a generic C pointer (&lt;code&gt;void*&lt;/code&gt;). The value can be a userdata, a table, a thread, a string, or a function; otherwise, &lt;code&gt;lua_topointer&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;. Different objects will give different pointers. There is no way to convert the pointer back to its original value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa669b19e261e97a900695fc2754e811aa721912" translate="yes" xml:space="preserve">
          <source>Converts the value at the given index to a generic C pointer (&lt;code&gt;void*&lt;/code&gt;). The value can be a userdata, a table, a thread, or a function; otherwise, &lt;code&gt;lua_topointer&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;. Different objects will give different pointers. There is no way to convert the pointer back to its original value.</source>
          <target state="translated">Convierte el valor en el &amp;iacute;ndice dado en un puntero C gen&amp;eacute;rico ( &lt;code&gt;void*&lt;/code&gt; ). El valor puede ser un dato de usuario, una tabla, un hilo o una funci&amp;oacute;n; de lo contrario, &lt;code&gt;lua_topointer&lt;/code&gt; devuelve &lt;code&gt;NULL&lt;/code&gt; . Diferentes objetos dar&amp;aacute;n diferentes punteros. No hay forma de volver a convertir el puntero a su valor original.</target>
        </trans-unit>
        <trans-unit id="e5b98b4c46b3b3b87df50590e233197fb42ee19f" translate="yes" xml:space="preserve">
          <source>Converts the zero-terminated string &lt;code&gt;s&lt;/code&gt; to a number, pushes that number into the stack, and returns the total size of the string, that is, its length plus one. The conversion can result in an integer or a float, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). The string may have leading and trailing spaces and a sign. If the string is not a valid numeral, returns 0 and pushes nothing. (Note that the result can be used as a boolean, true if the conversion succeeds.)</source>
          <target state="translated">Convierte la cadena &lt;code&gt;s&lt;/code&gt; terminada en cero en un n&amp;uacute;mero, inserta ese n&amp;uacute;mero en la pila y devuelve el tama&amp;ntilde;o total de la cadena, es decir, su longitud m&amp;aacute;s uno. La conversi&amp;oacute;n puede resultar en un n&amp;uacute;mero entero o flotante, de acuerdo con las convenciones l&amp;eacute;xicas de Lua (ver &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; ). La cadena puede tener espacios iniciales y finales y un letrero. Si la cadena no es un n&amp;uacute;mero v&amp;aacute;lido, devuelve 0 y no inserta nada. (Tenga en cuenta que el resultado se puede utilizar como booleano, verdadero si la conversi&amp;oacute;n se realiza correctamente).</target>
        </trans-unit>
        <trans-unit id="a07ce76e129eba5face8c2a20345f32b8dbfed46" translate="yes" xml:space="preserve">
          <source>Converts the zero-terminated string &lt;code&gt;s&lt;/code&gt; to a number, pushes that number into the stack, and returns the total size of the string, that is, its length plus one. The conversion can result in an integer or a float, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). The string may have leading and trailing whitespaces and a sign. If the string is not a valid numeral, returns 0 and pushes nothing. (Note that the result can be used as a boolean, true if the conversion succeeds.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afda351611f229d2ffdcdc3ced1f84f41bb44f33" translate="yes" xml:space="preserve">
          <source>Copies the element at index &lt;code&gt;fromidx&lt;/code&gt; into the valid index &lt;code&gt;toidx&lt;/code&gt;, replacing the value at that position. Values at other positions are not affected.</source>
          <target state="translated">Copia el elemento en el &amp;iacute;ndice de &lt;code&gt;fromidx&lt;/code&gt; en el &amp;iacute;ndice v&amp;aacute;lido de &lt;code&gt;toidx&lt;/code&gt; , reemplazando el valor en esa posici&amp;oacute;n. Los valores en otras posiciones no se ven afectados.</target>
        </trans-unit>
        <trans-unit id="038697113018f4400bc94f1be4aebad0829b635a" translate="yes" xml:space="preserve">
          <source>Coroutines</source>
          <target state="translated">Coroutines</target>
        </trans-unit>
        <trans-unit id="725136a9add10a0a9d7033c2e6eefd6766658f99" translate="yes" xml:space="preserve">
          <source>Creates a copy of string &lt;code&gt;s&lt;/code&gt; by replacing any occurrence of the string &lt;code&gt;p&lt;/code&gt; with the string &lt;code&gt;r&lt;/code&gt;. Pushes the resulting string on the stack and returns it.</source>
          <target state="translated">Crea una copia de la cadena &lt;code&gt;s&lt;/code&gt; reemplazando cualquier ocurrencia de la cadena &lt;code&gt;p&lt;/code&gt; con la cadena &lt;code&gt;r&lt;/code&gt; . Empuja la cadena resultante en la pila y la devuelve.</target>
        </trans-unit>
        <trans-unit id="5baad47488e2efeffe466611b840cdf047cbb4cc" translate="yes" xml:space="preserve">
          <source>Creates a copy of string &lt;code&gt;s&lt;/code&gt;, replacing any occurrence of the string &lt;code&gt;p&lt;/code&gt; with the string &lt;code&gt;r&lt;/code&gt;. Pushes the resulting string on the stack and returns it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409211348501f0fceae087d0a64eb7812f2900e2" translate="yes" xml:space="preserve">
          <source>Creates a new Lua state. It calls &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt; with an allocator based on the standard C &lt;code&gt;realloc&lt;/code&gt; function and then sets a panic function (see &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt;) that prints an error message to the standard error output in case of fatal errors.</source>
          <target state="translated">Crea un nuevo estado Lua. Llama a &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; &lt;/a&gt; con un asignador basado en la funci&amp;oacute;n de &lt;code&gt;realloc&lt;/code&gt; est&amp;aacute;ndar de C y luego establece una funci&amp;oacute;n de p&amp;aacute;nico (ver &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt; ) que imprime un mensaje de error en la salida de error est&amp;aacute;ndar en caso de errores fatales.</target>
        </trans-unit>
        <trans-unit id="5f7935c892ad0010ffd499bdb61eaf24ac62873c" translate="yes" xml:space="preserve">
          <source>Creates a new Lua state. It calls &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt; with an allocator based on the standard C allocation functions and then sets a warning function and a panic function (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;) that print messages to the standard error output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2e14753be2923d3727ec4c0b2962317308b7a78" translate="yes" xml:space="preserve">
          <source>Creates a new coroutine, with body &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; must be a function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to &lt;code&gt;resume&lt;/code&gt;. Returns the same values returned by &lt;code&gt;resume&lt;/code&gt;, except the first boolean. In case of error, propagates the error.</source>
          <target state="translated">Crea una nueva corrutina, con cuerpo &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; debe ser una funci&amp;oacute;n. Devuelve una funci&amp;oacute;n que reanuda la corrutina cada vez que se llama. Cualquier argumento que se pase a la funci&amp;oacute;n se comporta como argumentos adicionales para &lt;code&gt;resume&lt;/code&gt; . Devuelve los mismos valores devueltos por &lt;code&gt;resume&lt;/code&gt; , excepto el primer booleano. En caso de error, propaga el error.</target>
        </trans-unit>
        <trans-unit id="05bb83a7ae7bf5c690003996483410c7c3b04c7a" translate="yes" xml:space="preserve">
          <source>Creates a new coroutine, with body &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; must be a function. Returns this new coroutine, an object with type &lt;code&gt;&quot;thread&quot;&lt;/code&gt;.</source>
          <target state="translated">Crea una nueva corrutina, con cuerpo &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; debe ser una funci&amp;oacute;n. Devuelve esta nueva corrutina, un objeto con tipo &lt;code&gt;&quot;thread&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34e792658e08ad25182b4ae588e7bb882e49e2e5" translate="yes" xml:space="preserve">
          <source>Creates a new coroutine, with body &lt;code&gt;f&lt;/code&gt;; &lt;code&gt;f&lt;/code&gt; must be a function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to this function behave as the extra arguments to &lt;code&gt;resume&lt;/code&gt;. The function returns the same values returned by &lt;code&gt;resume&lt;/code&gt;, except the first boolean. In case of error, the function closes the coroutine and propagates the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a50f66b26d5dc5b8cc4ba979a4ea976308b32d2" translate="yes" xml:space="preserve">
          <source>Creates a new empty table and pushes it onto the stack. It is equivalent to &lt;code&gt;lua_createtable(L, 0, 0)&lt;/code&gt;.</source>
          <target state="translated">Crea una nueva tabla vac&amp;iacute;a y la coloca en la pila. Es equivalente a &lt;code&gt;lua_createtable(L, 0, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96db399082b6917880b7df2255e1672897dcd9fd" translate="yes" xml:space="preserve">
          <source>Creates a new empty table and pushes it onto the stack. Parameter &lt;code&gt;narr&lt;/code&gt; is a hint for how many elements the table will have as a sequence; parameter &lt;code&gt;nrec&lt;/code&gt; is a hint for how many other elements the table will have. Lua may use these hints to preallocate memory for the new table. This preallocation is useful for performance when you know in advance how many elements the table will have. Otherwise you can use the function &lt;a href=&quot;#lua_newtable&quot;&gt;&lt;code&gt;lua_newtable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Crea una nueva tabla vac&amp;iacute;a y la coloca en la pila. El par&amp;aacute;metro &lt;code&gt;narr&lt;/code&gt; es una pista de cu&amp;aacute;ntos elementos tendr&amp;aacute; la tabla como secuencia; El par&amp;aacute;metro &lt;code&gt;nrec&lt;/code&gt; es una pista de cu&amp;aacute;ntos otros elementos tendr&amp;aacute; la tabla. Lua puede usar estas sugerencias para preasignar memoria para la nueva tabla. Esta preasignaci&amp;oacute;n es &amp;uacute;til para el rendimiento cuando sabe de antemano cu&amp;aacute;ntos elementos tendr&amp;aacute; la tabla. De lo contrario, puede utilizar la funci&amp;oacute;n &lt;a href=&quot;#lua_newtable&quot;&gt; &lt;code&gt;lua_newtable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5012a48dd57af0841e13fac54cae3a40c700e59a" translate="yes" xml:space="preserve">
          <source>Creates a new empty table and pushes it onto the stack. Parameter &lt;code&gt;narr&lt;/code&gt; is a hint for how many elements the table will have as a sequence; parameter &lt;code&gt;nrec&lt;/code&gt; is a hint for how many other elements the table will have. Lua may use these hints to preallocate memory for the new table. This preallocation may help performance when you know in advance how many elements the table will have. Otherwise you can use the function &lt;a href=&quot;#lua_newtable&quot;&gt;&lt;code&gt;lua_newtable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31f96efce2ac04d437d79b84748bce9570451a0d" translate="yes" xml:space="preserve">
          <source>Creates a new independent state and returns its main thread. Returns &lt;code&gt;NULL&lt;/code&gt; if it cannot create the state (due to lack of memory). The argument &lt;code&gt;f&lt;/code&gt; is the allocator function; Lua will do all memory allocation for this state through this function (see &lt;a href=&quot;#lua_Alloc&quot;&gt;&lt;code&gt;lua_Alloc&lt;/code&gt;&lt;/a&gt;). The second argument, &lt;code&gt;ud&lt;/code&gt;, is an opaque pointer that Lua passes to the allocator in every call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc85f5dc1d8e4aacd51d81be148d528a2a237f3a" translate="yes" xml:space="preserve">
          <source>Creates a new table and registers there the functions in list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">Crea una nueva tabla y registra all&amp;iacute; las funciones en la lista &lt;code&gt;l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c341a15f1d3c228a7286e34a264438cedaa0d0e8" translate="yes" xml:space="preserve">
          <source>Creates a new table and registers there the functions in the list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e609328dccbccc7603668252d3543d1885dfb3e" translate="yes" xml:space="preserve">
          <source>Creates a new table with a size optimized to store all entries in the array &lt;code&gt;l&lt;/code&gt; (but does not actually store them). It is intended to be used in conjunction with &lt;a href=&quot;#luaL_setfuncs&quot;&gt;&lt;code&gt;luaL_setfuncs&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#luaL_newlib&quot;&gt;&lt;code&gt;luaL_newlib&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Crea una nueva tabla con un tama&amp;ntilde;o optimizado para almacenar todas las entradas en la matriz &lt;code&gt;l&lt;/code&gt; (pero en realidad no las almacena). Est&amp;aacute; dise&amp;ntilde;ado para usarse junto con &lt;a href=&quot;#luaL_setfuncs&quot;&gt; &lt;code&gt;luaL_setfuncs&lt;/code&gt; &lt;/a&gt; (ver &lt;a href=&quot;#luaL_newlib&quot;&gt; &lt;code&gt;luaL_newlib&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c2dc3a7ed086d8ba5b98b47e50da72e0597ad2f" translate="yes" xml:space="preserve">
          <source>Creates a new thread running in a new, independent state. Returns &lt;code&gt;NULL&lt;/code&gt; if it cannot create the thread or the state (due to lack of memory). The argument &lt;code&gt;f&lt;/code&gt; is the allocator function; Lua does all memory allocation for this state through this function (see &lt;a href=&quot;#lua_Alloc&quot;&gt;&lt;code&gt;lua_Alloc&lt;/code&gt;&lt;/a&gt;). The second argument, &lt;code&gt;ud&lt;/code&gt;, is an opaque pointer that Lua passes to the allocator in every call.</source>
          <target state="translated">Crea un nuevo hilo que se ejecuta en un estado nuevo e independiente. Devuelve &lt;code&gt;NULL&lt;/code&gt; si no puede crear el hilo o el estado (debido a la falta de memoria). El argumento &lt;code&gt;f&lt;/code&gt; es la funci&amp;oacute;n de asignaci&amp;oacute;n; Lua hace toda la asignaci&amp;oacute;n de memoria para este estado a trav&amp;eacute;s de esta funci&amp;oacute;n (ver &lt;a href=&quot;#lua_Alloc&quot;&gt; &lt;code&gt;lua_Alloc&lt;/code&gt; &lt;/a&gt; ). El segundo argumento, &lt;code&gt;ud&lt;/code&gt; , es un puntero opaco que Lua pasa al asignador en cada llamada.</target>
        </trans-unit>
        <trans-unit id="fd9ec8c11d7ac5415a760ccd09c2fad1db9839cf" translate="yes" xml:space="preserve">
          <source>Creates a new thread, pushes it on the stack, and returns a pointer to a &lt;a href=&quot;#lua_State&quot;&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt; that represents this new thread. The new thread returned by this function shares with the original thread its global environment, but has an independent execution stack.</source>
          <target state="translated">Crea un nuevo hilo, lo empuja a la pila y devuelve un puntero a &lt;a href=&quot;#lua_State&quot;&gt; &lt;code&gt;lua_State&lt;/code&gt; &lt;/a&gt; que representa este nuevo hilo. El nuevo hilo devuelto por esta funci&amp;oacute;n comparte con el hilo original su entorno global, pero tiene una pila de ejecuci&amp;oacute;n independiente.</target>
        </trans-unit>
        <trans-unit id="6e0ca6aea862016d29b1b85fa495b05b651392c7" translate="yes" xml:space="preserve">
          <source>Creates and pushes a traceback of the stack &lt;code&gt;L1&lt;/code&gt;. If &lt;code&gt;msg&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt; it is appended at the beginning of the traceback. The &lt;code&gt;level&lt;/code&gt; parameter tells at which level to start the traceback.</source>
          <target state="translated">Crea y empuja un rastreo de la pila &lt;code&gt;L1&lt;/code&gt; . Si &lt;code&gt;msg&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , se agrega al comienzo del rastreo. El par&amp;aacute;metro de &lt;code&gt;level&lt;/code&gt; indica en qu&amp;eacute; nivel iniciar el rastreo.</target>
        </trans-unit>
        <trans-unit id="15bfd10f645b4386c20f64772098c6ffce3ebad6" translate="yes" xml:space="preserve">
          <source>Creates and pushes a traceback of the stack &lt;code&gt;L1&lt;/code&gt;. If &lt;code&gt;msg&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is appended at the beginning of the traceback. The &lt;code&gt;level&lt;/code&gt; parameter tells at which level to start the traceback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fe05dc16322e6d58cea2513fabb05e8a458e73" translate="yes" xml:space="preserve">
          <source>Creates and returns a &lt;em&gt;reference&lt;/em&gt;, in the table at index &lt;code&gt;t&lt;/code&gt;, for the object at the top of the stack (and pops the object).</source>
          <target state="translated">Crea y devuelve una &lt;em&gt;referencia&lt;/em&gt; , en la tabla en el &amp;iacute;ndice &lt;code&gt;t&lt;/code&gt; , para el objeto en la parte superior de la pila (y saca el objeto).</target>
        </trans-unit>
        <trans-unit id="ab88cefb740e57d0abb3b9da6bbb94af440a19a0" translate="yes" xml:space="preserve">
          <source>Creates and returns a &lt;em&gt;reference&lt;/em&gt;, in the table at index &lt;code&gt;t&lt;/code&gt;, for the object on the top of the stack (and pops the object).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1819b6bacdff250db0276b77bedb508731402da" translate="yes" xml:space="preserve">
          <source>Currently, Lua has the following standard libraries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6bb0e66f778837dd13f606426508f8246862247" translate="yes" xml:space="preserve">
          <source>Deletes the file (or empty directory, on POSIX systems) with the given name. If this function fails, it returns &lt;b&gt;fail&lt;/b&gt; plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1d518693f03f77a887add36287621e0ff6c775" translate="yes" xml:space="preserve">
          <source>Deletes the file (or empty directory, on POSIX systems) with the given name. If this function fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="translated">Elimina el archivo (o directorio vac&amp;iacute;o, en sistemas POSIX) con el nombre dado. Si esta funci&amp;oacute;n falla, devuelve &lt;b&gt;nil&lt;/b&gt; , m&amp;aacute;s una cadena que describe el error y el c&amp;oacute;digo de error. De lo contrario, devuelve verdadero.</target>
        </trans-unit>
        <trans-unit id="7e2e965899d00dbeb421cf187b25cd3fbb127acb" translate="yes" xml:space="preserve">
          <source>Despite the existence of this external &lt;code&gt;_ENV&lt;/code&gt; variable and the translation of free names, &lt;code&gt;_ENV&lt;/code&gt; is a completely regular name. In particular, you can define new variables and parameters with that name. Each reference to a free name uses the &lt;code&gt;_ENV&lt;/code&gt; that is visible at that point in the program, following the usual visibility rules of Lua (see &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;).</source>
          <target state="translated">A pesar de la existencia de esta variable externa &lt;code&gt;_ENV&lt;/code&gt; y la traducci&amp;oacute;n de nombres libres, &lt;code&gt;_ENV&lt;/code&gt; es un nombre completamente regular. En particular, puede definir nuevas variables y par&amp;aacute;metros con ese nombre. Cada referencia a un nombre libre utiliza el &lt;code&gt;_ENV&lt;/code&gt; que es visible en ese punto del programa, siguiendo las reglas de visibilidad habituales de Lua (ver &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="12de5a5770780d211823aca1736624c0440ac4a1" translate="yes" xml:space="preserve">
          <source>Despite the name, the metamethod for this event can be either a function or a table. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; as arguments, and the result of the call (adjusted to one value) is the result of the operation. If it is a table, the final result is the result of indexing this table with &lt;code&gt;key&lt;/code&gt;. (This indexing is regular, not raw, and therefore can trigger another metamethod.)</source>
          <target state="translated">A pesar del nombre, el metam&amp;eacute;todo para este evento puede ser una funci&amp;oacute;n o una tabla. Si es una funci&amp;oacute;n, se llama con &lt;code&gt;table&lt;/code&gt; y &lt;code&gt;key&lt;/code&gt; como argumentos, y el resultado de la llamada (ajustado a un valor) es el resultado de la operaci&amp;oacute;n. Si es una tabla, el resultado final es el resultado de indexar esta tabla con &lt;code&gt;key&lt;/code&gt; . (Esta indexaci&amp;oacute;n es regular, no sin formato y, por lo tanto, puede activar otro metam&amp;eacute;todo).</target>
        </trans-unit>
        <trans-unit id="e2dd868cc18f6f74b6780c7bcc3d9948c1df04c3" translate="yes" xml:space="preserve">
          <source>Destroys all objects in the given Lua state (calling the corresponding garbage-collection metamethods, if any) and frees all dynamic memory used by this state. On several platforms, you may not need to call this function, because all resources are naturally released when the host program ends. On the other hand, long-running programs that create multiple states, such as daemons or web servers, will probably need to close states as soon as they are not needed.</source>
          <target state="translated">Destruye todos los objetos en el estado Lua dado (llamando a los correspondientes métodos de recolección de basura,si los hay)y libera toda la memoria dinámica utilizada por este estado.En varias plataformas,puede que no sea necesario llamar a esta función,porque todos los recursos se liberan de forma natural cuando el programa anfitrión termina.Por otro lado,los programas de larga duración que crean múltiples estados,como los demonios o los servidores web,probablemente necesitarán cerrar los estados tan pronto como no se necesiten.</target>
        </trans-unit>
        <trans-unit id="d6c256480b3e40e037a15bde7dbddae426d6a7cf" translate="yes" xml:space="preserve">
          <source>Does the equivalent of &lt;code&gt;t[i] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">&amp;iquest;Es el equivalente de &lt;code&gt;t[i] = v&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es la tabla en el &amp;iacute;ndice dado y &lt;code&gt;v&lt;/code&gt; es el valor en la parte superior de la pila?</target>
        </trans-unit>
        <trans-unit id="f50cba5754e004689e56ef62b61d400bb02211d6" translate="yes" xml:space="preserve">
          <source>Does the equivalent of &lt;code&gt;t[i] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;v&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83102ba0627ee415bcdafad8e821cc410f6ca4e8" translate="yes" xml:space="preserve">
          <source>Does the equivalent of &lt;code&gt;t[p] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index, &lt;code&gt;p&lt;/code&gt; is encoded as a light userdata, and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">&amp;iquest;Es el equivalente de &lt;code&gt;t[p] = v&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es la tabla en el &amp;iacute;ndice dado, &lt;code&gt;p&lt;/code&gt; est&amp;aacute; codificado como datos de usuario livianos y &lt;code&gt;v&lt;/code&gt; es el valor en la parte superior de la pila.</target>
        </trans-unit>
        <trans-unit id="e1dce27792ce14fbdc9c700a06d947b4b3c9e572" translate="yes" xml:space="preserve">
          <source>Does the equivalent of &lt;code&gt;t[p] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index, &lt;code&gt;p&lt;/code&gt; is encoded as a light userdata, and &lt;code&gt;v&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e1d7b2dfe0e4b65f51a80784409021aefed2c4" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[k] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">&amp;iquest;Es el equivalente a &lt;code&gt;t[k] = v&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es el valor en el &amp;iacute;ndice dado y &lt;code&gt;v&lt;/code&gt; es el valor en la parte superior de la pila?</target>
        </trans-unit>
        <trans-unit id="726cb88662f8c5ab515b5a42d04ffa849062af21" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[k] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;v&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b79cf1f60fca53d0de89a3a12255d00973edf92" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[k] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index, &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack, and &lt;code&gt;k&lt;/code&gt; is the value just below the top.</source>
          <target state="translated">&amp;iquest;Equivale a &lt;code&gt;t[k] = v&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es el valor en el &amp;iacute;ndice dado, &lt;code&gt;v&lt;/code&gt; es el valor en la parte superior de la pila y &lt;code&gt;k&lt;/code&gt; es el valor justo debajo de la parte superior.</target>
        </trans-unit>
        <trans-unit id="18da5e882f06adc234eb1a0b52d52ca16968a459" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[k] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index, &lt;code&gt;v&lt;/code&gt; is the value on the top of the stack, and &lt;code&gt;k&lt;/code&gt; is the value just below the top.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3b7a2b7b1afec72c53764dcaa4a8915523e72b" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[n] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">&amp;iquest;Equivale a &lt;code&gt;t[n] = v&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es el valor en el &amp;iacute;ndice dado y &lt;code&gt;v&lt;/code&gt; es el valor en la parte superior de la pila.</target>
        </trans-unit>
        <trans-unit id="211bb7a17fd232fd8888d171735fcbac259859ce" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[n] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;v&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="054070872d4195e45bf298511993c73d44db5c6e" translate="yes" xml:space="preserve">
          <source>Dumps a function as a binary chunk. Receives a Lua function on the top of the stack and produces a binary chunk that, if loaded again, results in a function equivalent to the one dumped. As it produces parts of the chunk, &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; calls function &lt;code&gt;writer&lt;/code&gt; (see &lt;a href=&quot;#lua_Writer&quot;&gt;&lt;code&gt;lua_Writer&lt;/code&gt;&lt;/a&gt;) with the given &lt;code&gt;data&lt;/code&gt; to write them.</source>
          <target state="translated">Vuelca una funci&amp;oacute;n como un fragmento binario. Recibe una funci&amp;oacute;n Lua en la parte superior de la pila y produce un fragmento binario que, si se carga nuevamente, da como resultado una funci&amp;oacute;n equivalente a la que se volc&amp;oacute;. A medida que produce partes del fragmento, &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; llama a la funci&amp;oacute;n &lt;code&gt;writer&lt;/code&gt; (ver &lt;a href=&quot;#lua_Writer&quot;&gt; &lt;code&gt;lua_Writer&lt;/code&gt; &lt;/a&gt; ) con los &lt;code&gt;data&lt;/code&gt; dados para escribirlos.</target>
        </trans-unit>
        <trans-unit id="c90c7bb6d9829fd16d0afd908f93d4e6040aff4e" translate="yes" xml:space="preserve">
          <source>During its normal operation, a string buffer uses a variable number of stack slots. So, while using a buffer, you cannot assume that you know where the top of the stack is. You can use the stack between successive calls to buffer operations as long as that use is balanced; that is, when you call a buffer operation, the stack is at the same level it was immediately after the previous buffer operation. (The only exception to this rule is &lt;a href=&quot;#luaL_addvalue&quot;&gt;&lt;code&gt;luaL_addvalue&lt;/code&gt;&lt;/a&gt;.) After calling &lt;a href=&quot;#luaL_pushresult&quot;&gt;&lt;code&gt;luaL_pushresult&lt;/code&gt;&lt;/a&gt; the stack is back to its level when the buffer was initialized, plus the final string on its top.</source>
          <target state="translated">Durante su funcionamiento normal, un b&amp;uacute;fer de cadena utiliza un n&amp;uacute;mero variable de ranuras de pila. Por lo tanto, mientras usa un b&amp;uacute;fer, no puede asumir que sabe d&amp;oacute;nde est&amp;aacute; la parte superior de la pila. Puede usar la pila entre llamadas sucesivas para almacenar operaciones en b&amp;uacute;fer siempre que ese uso sea equilibrado; es decir, cuando llama a una operaci&amp;oacute;n de b&amp;uacute;fer, la pila est&amp;aacute; al mismo nivel que estaba inmediatamente despu&amp;eacute;s de la operaci&amp;oacute;n de b&amp;uacute;fer anterior. (La &amp;uacute;nica excepci&amp;oacute;n a esta regla es &lt;a href=&quot;#luaL_addvalue&quot;&gt; &lt;code&gt;luaL_addvalue&lt;/code&gt; &lt;/a&gt; .) Despu&amp;eacute;s de llamar a &lt;a href=&quot;#luaL_pushresult&quot;&gt; &lt;code&gt;luaL_pushresult&lt;/code&gt; ,&lt;/a&gt; la pila vuelve a su nivel cuando se inicializ&amp;oacute; el b&amp;uacute;fer, m&amp;aacute;s la cadena final en su parte superior.</target>
        </trans-unit>
        <trans-unit id="806c211c6a1d685f5e0426f1a70520457c62882e" translate="yes" xml:space="preserve">
          <source>During its normal operation, a string buffer uses a variable number of stack slots. So, while using a buffer, you cannot assume that you know where the top of the stack is. You can use the stack between successive calls to buffer operations as long as that use is balanced; that is, when you call a buffer operation, the stack is at the same level it was immediately after the previous buffer operation. (The only exception to this rule is &lt;a href=&quot;#luaL_addvalue&quot;&gt;&lt;code&gt;luaL_addvalue&lt;/code&gt;&lt;/a&gt;.) After calling &lt;a href=&quot;#luaL_pushresult&quot;&gt;&lt;code&gt;luaL_pushresult&lt;/code&gt;&lt;/a&gt;, the stack is back to its level when the buffer was initialized, plus the final string on its top.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76fabdeb134cd6b1444f21660aa818a7b0d8c8f" translate="yes" xml:space="preserve">
          <source>Dynamically links the host program with the C library &lt;code&gt;libname&lt;/code&gt;.</source>
          <target state="translated">Vincula din&amp;aacute;micamente el programa host con la biblioteca de C. &lt;code&gt;libname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0f3fe6a9590293b6274b20698d15691bfb7be9e" translate="yes" xml:space="preserve">
          <source>Each Lua state has one or more threads, which correspond to independent, cooperative lines of execution. The type &lt;a href=&quot;#lua_State&quot;&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt; (despite its name) refers to a thread. (Indirectly, through the thread, it also refers to the Lua state associated to the thread.)</source>
          <target state="translated">Cada estado Lua tiene uno o m&amp;aacute;s subprocesos, que corresponden a l&amp;iacute;neas de ejecuci&amp;oacute;n independientes y cooperativas. El tipo &lt;a href=&quot;#lua_State&quot;&gt; &lt;code&gt;lua_State&lt;/code&gt; &lt;/a&gt; (a pesar de su nombre) se refiere a un hilo. (Indirectamente, a trav&amp;eacute;s del hilo, tambi&amp;eacute;n se refiere al estado Lua asociado al hilo).</target>
        </trans-unit>
        <trans-unit id="c5aba24ed5a01dfc4d7e064e0144db7d74d4c725" translate="yes" xml:space="preserve">
          <source>Each call made from Lua code counts one unit. Other operations (e.g., calls made from C to Lua or resuming a coroutine) may have a higher cost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271d158703dde3ea70b23b6f13cd8c963bd8f8f2" translate="yes" xml:space="preserve">
          <source>Each character in the string &lt;code&gt;what&lt;/code&gt; selects some fields of the structure &lt;code&gt;ar&lt;/code&gt; to be filled or a value to be pushed on the stack:</source>
          <target state="translated">Cada car&amp;aacute;cter en la cadena &lt;code&gt;what&lt;/code&gt; selecciona algunos campos de la estructura &lt;code&gt;ar&lt;/code&gt; para ser llenado o un valor que se inserta en la pila:</target>
        </trans-unit>
        <trans-unit id="ecc99d29acc89d3df821079ad381b56b5089631f" translate="yes" xml:space="preserve">
          <source>Each entry in this table is a &lt;em&gt;searcher function&lt;/em&gt;. When looking for a module, &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; calls each of these searchers in ascending order, with the module name (the argument given to &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;) as its sole argument. If the searcher finds the module, it returns another function, the module &lt;em&gt;loader&lt;/em&gt;, plus an extra value, a &lt;em&gt;loader data&lt;/em&gt;, that will be passed to that loader and returned as a second result by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;. If it cannot find the module, it returns a string explaining why (or &lt;b&gt;nil&lt;/b&gt; if it has nothing to say).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ea340a21718b1d5eb33af7ac68465d8a3a932c" translate="yes" xml:space="preserve">
          <source>Each entry in this table is a &lt;em&gt;searcher function&lt;/em&gt;. When looking for a module, &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; calls each of these searchers in ascending order, with the module name (the argument given to &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;) as its sole parameter. The function can return another function (the module &lt;em&gt;loader&lt;/em&gt;) plus an extra value that will be passed to that loader, or a string explaining why it did not find that module (or &lt;b&gt;nil&lt;/b&gt; if it has nothing to say).</source>
          <target state="translated">Cada entrada de esta tabla es una &lt;em&gt;funci&amp;oacute;n de b&amp;uacute;squeda&lt;/em&gt; . Al buscar un m&amp;oacute;dulo, &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; llama a cada uno de estos buscadores en orden ascendente, con el nombre del m&amp;oacute;dulo (el argumento dado para &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; ) como su &amp;uacute;nico par&amp;aacute;metro. La funci&amp;oacute;n puede devolver otra funci&amp;oacute;n (el &lt;em&gt;cargador de&lt;/em&gt; m&amp;oacute;dulos ) m&amp;aacute;s un valor extra que se le pasar&amp;aacute; a ese cargador, o una cadena que explique por qu&amp;eacute; no encontr&amp;oacute; ese m&amp;oacute;dulo (o &lt;b&gt;nulo&lt;/b&gt; si no tiene nada que decir).</target>
        </trans-unit>
        <trans-unit id="d34e2e6727edc3edc80604ce079f860a50da5e4e" translate="yes" xml:space="preserve">
          <source>Each field of the form &lt;code&gt;[exp1] = exp2&lt;/code&gt; adds to the new table an entry with key &lt;code&gt;exp1&lt;/code&gt; and value &lt;code&gt;exp2&lt;/code&gt;. A field of the form &lt;code&gt;name = exp&lt;/code&gt; is equivalent to &lt;code&gt;[&quot;name&quot;] = exp&lt;/code&gt;. Fields of the form &lt;code&gt;exp&lt;/code&gt; are equivalent to &lt;code&gt;[i] = exp&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; are consecutive integers starting with 1; fields in the other formats do not affect this counting. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315546f1f8c7df68b4e7271febe7523458c848c7" translate="yes" xml:space="preserve">
          <source>Each field of the form &lt;code&gt;[exp1] = exp2&lt;/code&gt; adds to the new table an entry with key &lt;code&gt;exp1&lt;/code&gt; and value &lt;code&gt;exp2&lt;/code&gt;. A field of the form &lt;code&gt;name = exp&lt;/code&gt; is equivalent to &lt;code&gt;[&quot;name&quot;] = exp&lt;/code&gt;. Finally, fields of the form &lt;code&gt;exp&lt;/code&gt; are equivalent to &lt;code&gt;[i] = exp&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; are consecutive integers starting with 1. Fields in the other formats do not affect this counting. For example,</source>
          <target state="translated">Cada campo del formulario &lt;code&gt;[exp1] = exp2&lt;/code&gt; agrega a la nueva tabla una entrada con la clave &lt;code&gt;exp1&lt;/code&gt; y el valor &lt;code&gt;exp2&lt;/code&gt; . Un campo de la forma &lt;code&gt;name = exp&lt;/code&gt; es equivalente a &lt;code&gt;[&quot;name&quot;] = exp&lt;/code&gt; . Finalmente, los campos de la forma &lt;code&gt;exp&lt;/code&gt; son equivalentes a &lt;code&gt;[i] = exp&lt;/code&gt; , donde &lt;code&gt;i&lt;/code&gt; son enteros consecutivos que comienzan con 1. Los campos en los otros formatos no afectan este conteo. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="5ded60221fcd42af87598bfa3998cbd1f3094a3c" translate="yes" xml:space="preserve">
          <source>Each new thread has this area initialized with a copy of the area of the main thread.</source>
          <target state="translated">Cada nuevo hilo tiene esta área inicializada con una copia del área del hilo principal.</target>
        </trans-unit>
        <trans-unit id="e9d9039bee56c9dff367db5db3ac501d7692cf55" translate="yes" xml:space="preserve">
          <source>Each variable name may be postfixed by an attribute (a name between angle brackets):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0667e652664cd1df4e1207278c25e646648c5640" translate="yes" xml:space="preserve">
          <source>Emits a warning with a message composed by the concatenation of all its arguments (which should be strings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33e48b8cc5703ec215b544663c0ef8acefbf248" translate="yes" xml:space="preserve">
          <source>Emits a warning with the given message. A message in a call with &lt;code&gt;tocont&lt;/code&gt; true should be continued in another call to this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be0ef9871b5f19e17f15ac19ff4343a0cff10de" translate="yes" xml:space="preserve">
          <source>Ensures that the stack has space for at least &lt;code&gt;n&lt;/code&gt; extra elements, that is, that you can safely push up to &lt;code&gt;n&lt;/code&gt; values into it. It returns false if it cannot fulfill the request, either because it would cause the stack to be greater than a fixed maximum size (typically at least several thousand elements) or because it cannot allocate memory for the extra space. This function never shrinks the stack; if the stack already has space for the extra elements, it is left unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724adec43f3df4f9471590e57b3efefd102497cf" translate="yes" xml:space="preserve">
          <source>Ensures that the stack has space for at least &lt;code&gt;n&lt;/code&gt; extra slots (that is, that you can safely push up to &lt;code&gt;n&lt;/code&gt; values into it). It returns false if it cannot fulfill the request, either because it would cause the stack to be larger than a fixed maximum size (typically at least several thousand elements) or because it cannot allocate memory for the extra space. This function never shrinks the stack; if the stack already has space for the extra slots, it is left unchanged.</source>
          <target state="translated">Garantiza que la pila tenga espacio para al menos &lt;code&gt;n&lt;/code&gt; ranuras adicionales (es decir, que pueda introducir de forma segura &lt;code&gt;n&lt;/code&gt; valores en ella). Devuelve falso si no puede cumplir con la solicitud, ya sea porque har&amp;iacute;a que la pila sea m&amp;aacute;s grande que un tama&amp;ntilde;o m&amp;aacute;ximo fijo (normalmente al menos varios miles de elementos) o porque no puede asignar memoria para el espacio adicional. Esta funci&amp;oacute;n nunca reduce la pila; si la pila ya tiene espacio para las ranuras adicionales, no se modifica.</target>
        </trans-unit>
        <trans-unit id="94cdd3c18c2b4719474c53fa6f1b9fb02152a15d" translate="yes" xml:space="preserve">
          <source>Ensures that the value &lt;code&gt;t[fname]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at index &lt;code&gt;idx&lt;/code&gt;, is a table, and pushes that table onto the stack. Returns true if it finds a previous table there and false if it creates a new table.</source>
          <target state="translated">Asegura que el valor &lt;code&gt;t[fname]&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es el valor en el &amp;iacute;ndice &lt;code&gt;idx&lt;/code&gt; , es una tabla, y empuja esa tabla a la pila. Devuelve verdadero si encuentra una tabla anterior all&amp;iacute; y falso si crea una nueva tabla.</target>
        </trans-unit>
        <trans-unit id="d2187e2e8c84822845af903355cda0cd820011ab" translate="yes" xml:space="preserve">
          <source>Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word &lt;code&gt;cont&lt;/code&gt; finishes this function, so that the caller continues its execution.</source>
          <target state="translated">Ingresa a un modo interactivo con el usuario, ejecutando cada cadena que ingresa el usuario. Usando comandos simples y otras facilidades de depuraci&amp;oacute;n, el usuario puede inspeccionar variables globales y locales, cambiar sus valores, evaluar expresiones, etc. Una l&amp;iacute;nea que contiene solo la palabra &lt;code&gt;cont&lt;/code&gt; finaliza esta funci&amp;oacute;n, de modo que el llamador contin&amp;uacute;a su ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4bc7c25b89d339e7967419718f888c8e7706661a" translate="yes" xml:space="preserve">
          <source>Environments and the Global Environment</source>
          <target state="translated">Los entornos y el medio ambiente mundial</target>
        </trans-unit>
        <trans-unit id="911d3f66ebade1de45eca3fa1b80cbca2b45963a" translate="yes" xml:space="preserve">
          <source>Equality (&lt;code&gt;==&lt;/code&gt;) first compares the type of its operands. If the types are different, then the result is &lt;b&gt;false&lt;/b&gt;. Otherwise, the values of the operands are compared. Strings are compared in the obvious way. Numbers are equal if they denote the same mathematical value.</source>
          <target state="translated">Equality ( &lt;code&gt;==&lt;/code&gt; ) primero compara el tipo de sus operandos. Si los tipos son diferentes, el resultado es &lt;b&gt;falso&lt;/b&gt; . De lo contrario, se comparan los valores de los operandos. Las cadenas se comparan de forma obvia. Los n&amp;uacute;meros son iguales si denotan el mismo valor matem&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="7ce354bf488d1a0add3dbce3df2fdb2d17bd01c3" translate="yes" xml:space="preserve">
          <source>Equality (&lt;code&gt;==&lt;/code&gt;) first compares the type of its operands. If the types are different, then the result is &lt;b&gt;false&lt;/b&gt;. Otherwise, the values of the operands are compared. Strings are equal if they have the same byte content. Numbers are equal if they denote the same mathematical value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bba7708d9cd62b79eff18edb05f15a66e6e4fc3" translate="yes" xml:space="preserve">
          <source>Equality comparisons do not convert strings to numbers or vice versa. Thus, &lt;code&gt;&quot;0&quot;==0&lt;/code&gt; evaluates to &lt;b&gt;false&lt;/b&gt;, and &lt;code&gt;t[0]&lt;/code&gt; and &lt;code&gt;t[&quot;0&quot;]&lt;/code&gt; denote different entries in a table.</source>
          <target state="translated">Las comparaciones de igualdad no convierten cadenas en n&amp;uacute;meros o viceversa. Por lo tanto, &lt;code&gt;&quot;0&quot;==0&lt;/code&gt; eval&amp;uacute;a como &lt;b&gt;falso&lt;/b&gt; , y &lt;code&gt;t[0]&lt;/code&gt; y &lt;code&gt;t[&quot;0&quot;]&lt;/code&gt; denotan diferentes entradas en una tabla.</target>
        </trans-unit>
        <trans-unit id="eeb6206afe341a7d07c673213b74b2763b8aad8a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#luaL_loadbufferx&quot;&gt;&lt;code&gt;luaL_loadbufferx&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;mode&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Equivalente a &lt;a href=&quot;#luaL_loadbufferx&quot;&gt; &lt;code&gt;luaL_loadbufferx&lt;/code&gt; &lt;/a&gt; con &lt;code&gt;mode&lt;/code&gt; igual a &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c5ac0bf4ab4157c76c5229bc6b001f02e1bbdbe" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#luaL_loadfilex&quot;&gt;&lt;code&gt;luaL_loadfilex&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;mode&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Equivalente a &lt;a href=&quot;#luaL_loadfilex&quot;&gt; &lt;code&gt;luaL_loadfilex&lt;/code&gt; &lt;/a&gt; con &lt;code&gt;mode&lt;/code&gt; igual a &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="417f3cabd0ae3b21c9200dade7625b6b803e2a8a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt;&lt;code&gt;luaL_prepbuffsize&lt;/code&gt;&lt;/a&gt; with the predefined size &lt;a id=&quot;pdf-LUAL_BUFFERSIZE&quot;&gt;&lt;code&gt;LUAL_BUFFERSIZE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Equivalente a &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt; &lt;code&gt;luaL_prepbuffsize&lt;/code&gt; &lt;/a&gt; con el tama&amp;ntilde;o predefinido &lt;a id=&quot;pdf-LUAL_BUFFERSIZE&quot;&gt; &lt;code&gt;LUAL_BUFFERSIZE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bdbca26c05283a107728b580733fbf5005aa002" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_pushfstring&quot;&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;, except that it receives a &lt;code&gt;va_list&lt;/code&gt; instead of a variable number of arguments.</source>
          <target state="translated">Equivalente a &lt;a href=&quot;#lua_pushfstring&quot;&gt; &lt;code&gt;lua_pushfstring&lt;/code&gt; &lt;/a&gt; , excepto que recibe un &lt;code&gt;va_list&lt;/code&gt; en lugar de un n&amp;uacute;mero variable de argumentos.</target>
        </trans-unit>
        <trans-unit id="048179e8ca8eda05fb0bd3fd434b84a3be42d2f7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_tointegerx&quot;&gt;&lt;code&gt;lua_tointegerx&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;isnum&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Equivalente a &lt;a href=&quot;#lua_tointegerx&quot;&gt; &lt;code&gt;lua_tointegerx&lt;/code&gt; &lt;/a&gt; con &lt;code&gt;isnum&lt;/code&gt; igual a &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eea1358153e9600e250e3541353b60210297af9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;len&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Equivalente a &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt; con &lt;code&gt;len&lt;/code&gt; igual a &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="859cc0dd8a506649ee3ce18e480ee774adf2690e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_tonumberx&quot;&gt;&lt;code&gt;lua_tonumberx&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;isnum&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Equivalente a &lt;a href=&quot;#lua_tonumberx&quot;&gt; &lt;code&gt;lua_tonumberx&lt;/code&gt; &lt;/a&gt; con &lt;code&gt;isnum&lt;/code&gt; igual a &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f10e3538e7d3cff0cc3010f6eafa5510d5b4eabf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;file:close()&lt;/code&gt;. Without a &lt;code&gt;file&lt;/code&gt;, closes the default output file.</source>
          <target state="translated">Equivalente a &lt;code&gt;file:close()&lt;/code&gt; . Sin un &lt;code&gt;file&lt;/code&gt; , cierra el archivo de salida predeterminado.</target>
        </trans-unit>
        <trans-unit id="47bb85f8430ddf2501d6a1df9b4dd575ae0b94f6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;io.input():read(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt;.</source>
          <target state="translated">Equivalente a &lt;code&gt;io.input():read(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b236c5a9b8def03419e72a62b54cf06568e7ac12" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;io.output():flush()&lt;/code&gt;.</source>
          <target state="translated">Equivalente a &lt;code&gt;io.output():flush()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a16ee993787daf20f8abfd04e25a53a52555ae" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;io.output():write(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt;.</source>
          <target state="translated">Equivalente a &lt;code&gt;io.output():write(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95841ee72cef3e69b1415de06e904a02c3a22ad7" translate="yes" xml:space="preserve">
          <source>Equivalent to the sequence &lt;a href=&quot;#luaL_addsize&quot;&gt;&lt;code&gt;luaL_addsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_pushresult&quot;&gt;&lt;code&gt;luaL_pushresult&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Equivalente a la secuencia &lt;a href=&quot;#luaL_addsize&quot;&gt; &lt;code&gt;luaL_addsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#luaL_pushresult&quot;&gt; &lt;code&gt;luaL_pushresult&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a9197bd8cc7210e1d081737ce79a0004c900ea5" translate="yes" xml:space="preserve">
          <source>Equivalent to the sequence &lt;a href=&quot;#luaL_buffinit&quot;&gt;&lt;code&gt;luaL_buffinit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt;&lt;code&gt;luaL_prepbuffsize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Equivalente a la secuencia &lt;a href=&quot;#luaL_buffinit&quot;&gt; &lt;code&gt;luaL_buffinit&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt; &lt;code&gt;luaL_prepbuffsize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">Manejo de errores</target>
        </trans-unit>
        <trans-unit id="efce06d9e3b29a083012c673a0d05df2af20d9a0" translate="yes" xml:space="preserve">
          <source>Even when we use the term &quot;function&quot;, any facility in the API may be provided as a macro instead. Except where stated otherwise, all such macros use each of their arguments exactly once (except for the first argument, which is always a Lua state), and so do not generate any hidden side-effects.</source>
          <target state="translated">Incluso cuando utilizamos el término &quot;función&quot;,cualquier instalación de la API puede ser proporcionada como una macro.Salvo que se indique lo contrario,todas esas macros utilizan cada uno de sus argumentos exactamente una vez (excepto el primer argumento,que siempre es un estado Lua),por lo que no generan ningún efecto secundario oculto.</target>
        </trans-unit>
        <trans-unit id="8b0fc04bd9046928072da89380d0ae2b41ea04f1" translate="yes" xml:space="preserve">
          <source>Every value in Lua can have a &lt;em&gt;metatable&lt;/em&gt;. This &lt;em&gt;metatable&lt;/em&gt; is an ordinary Lua table that defines the behavior of the original value under certain events. You can change several aspects of the behavior of a value by setting specific fields in its metatable. For instance, when a non-numeric value is the operand of an addition, Lua checks for a function in the field &quot;&lt;code&gt;__add&lt;/code&gt;&quot; of the value's metatable. If it finds one, Lua calls this function to perform the addition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876b22e6469bec417ede0947f746abdd3c61cdc3" translate="yes" xml:space="preserve">
          <source>Every value in Lua can have a &lt;em&gt;metatable&lt;/em&gt;. This &lt;em&gt;metatable&lt;/em&gt; is an ordinary Lua table that defines the behavior of the original value under certain special operations. You can change several aspects of the behavior of operations over a value by setting specific fields in its metatable. For instance, when a non-numeric value is the operand of an addition, Lua checks for a function in the field &quot;&lt;code&gt;__add&lt;/code&gt;&quot; of the value's metatable. If it finds one, Lua calls this function to perform the addition.</source>
          <target state="translated">Cada valor en Lua puede tener una &lt;em&gt;metatabla&lt;/em&gt; . Esta &lt;em&gt;metatabla&lt;/em&gt; es una tabla Lua ordinaria que define el comportamiento del valor original bajo ciertas operaciones especiales. Puede cambiar varios aspectos del comportamiento de las operaciones sobre un valor estableciendo campos espec&amp;iacute;ficos en su metatabla. Por ejemplo, cuando un valor no num&amp;eacute;rico es el operando de una suma, Lua busca una funci&amp;oacute;n en el campo &quot; &lt;code&gt;__add&lt;/code&gt; &quot; de la metatabla del valor. Si encuentra uno, Lua llama a esta funci&amp;oacute;n para realizar la suma.</target>
        </trans-unit>
        <trans-unit id="34fb3456225dbfac064754a0c940e7ab97d70dab" translate="yes" xml:space="preserve">
          <source>Examples of valid float constants are</source>
          <target state="translated">Ejemplos de constantes de flotación válidas son</target>
        </trans-unit>
        <trans-unit id="bbe7dddfbe009d74560c9fb2bc36df0adb3cf044" translate="yes" xml:space="preserve">
          <source>Examples of valid integer constants are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9054ac99639aca0dedbf9ce85be2d8cb078353" translate="yes" xml:space="preserve">
          <source>Except for the basic and the package libraries, each library provides all its functions as fields of a global table or as methods of its objects.</source>
          <target state="translated">Excepto las bibliotecas básicas y de paquetes,cada biblioteca proporciona todas sus funciones como campos de una tabla global o como métodos de sus objetos.</target>
        </trans-unit>
        <trans-unit id="36df5e76b9e2376e585d0d88a013dd481aa092f2" translate="yes" xml:space="preserve">
          <source>Except for these guarantees, the garbage collector is free to invalidate any pointer to internal strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a454333e5ab07af66349fc9dcc89eefc63ffc046" translate="yes" xml:space="preserve">
          <source>Exchange values between different threads of the same state.</source>
          <target state="translated">Intercambiar valores entre diferentes hilos del mismo estado.</target>
        </trans-unit>
        <trans-unit id="8a70a348295e730e4d487448d5bdfd5d0a1f52d4" translate="yes" xml:space="preserve">
          <source>Explicit blocks are useful to control the scope of variable declarations. Explicit blocks are also sometimes used to add a &lt;b&gt;return&lt;/b&gt; statement in the middle of another block (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;).</source>
          <target state="translated">Los bloques expl&amp;iacute;citos son &amp;uacute;tiles para controlar el alcance de las declaraciones de variables. Los bloques expl&amp;iacute;citos tambi&amp;eacute;n se utilizan a veces para agregar una declaraci&amp;oacute;n de &lt;b&gt;retorno&lt;/b&gt; en medio de otro bloque (consulte &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6068d6a6087004b84e19a26f762381a6d306ebf7" translate="yes" xml:space="preserve">
          <source>Exponentiation and float division (&lt;code&gt;/&lt;/code&gt;) always convert their operands to floats and the result is always a float. Exponentiation uses the ISO C function &lt;code&gt;pow&lt;/code&gt;, so that it works for non-integer exponents too.</source>
          <target state="translated">La exponenciaci&amp;oacute;n y la divisi&amp;oacute;n flotante ( &lt;code&gt;/&lt;/code&gt; ) siempre convierten sus operandos en flotantes y el resultado siempre es flotante. La exponenciaci&amp;oacute;n usa la funci&amp;oacute;n ISO C &lt;code&gt;pow&lt;/code&gt; , por lo que tambi&amp;eacute;n funciona para exponentes no enteros.</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="3403002da8268dbb07086fbb61ed468d09402d3c" translate="yes" xml:space="preserve">
          <source>Expressions are discussed in &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt;.</source>
          <target state="translated">Las expresiones se analizan en &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b900d18f3b16f1700e6e2ba6ff4f8eb135f2fffe" translate="yes" xml:space="preserve">
          <source>Finalizers cannot yield. Except for that, they can do anything, such as raise errors, create new objects, or even run the garbage collector. However, because they can run in unpredictable times, it is good practice to restrict each finalizer to the minimum necessary to properly release its associated resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952220342168dc20bbaf6ee3888975552b5929df" translate="yes" xml:space="preserve">
          <source>Finish by calling &lt;code&gt;luaL_pushresult(&amp;amp;b)&lt;/code&gt;. This call leaves the final string on the top of the stack.</source>
          <target state="translated">Termine llamando a &lt;code&gt;luaL_pushresult(&amp;amp;b)&lt;/code&gt; . Esta llamada deja la cadena final en la parte superior de la pila.</target>
        </trans-unit>
        <trans-unit id="670400b569fd752b91bcbce8ea30c99ca0c5d950" translate="yes" xml:space="preserve">
          <source>Finish by calling &lt;code&gt;luaL_pushresultsize(&amp;amp;b, sz)&lt;/code&gt;, where &lt;code&gt;sz&lt;/code&gt; is the total size of the resulting string copied into that space (which may be less than or equal to the preallocated size).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e24c3abeab89141035172a8f0844d2e645ae86bc" translate="yes" xml:space="preserve">
          <source>Finish by calling &lt;code&gt;luaL_pushresultsize(&amp;amp;b, sz)&lt;/code&gt;, where &lt;code&gt;sz&lt;/code&gt; is the total size of the resulting string copied into that space.</source>
          <target state="translated">Termine llamando a &lt;code&gt;luaL_pushresultsize(&amp;amp;b, sz)&lt;/code&gt; , donde &lt;code&gt;sz&lt;/code&gt; es el tama&amp;ntilde;o total de la cadena resultante copiada en ese espacio.</target>
        </trans-unit>
        <trans-unit id="fa1b0bd32568564210439e9f8bbb29579af4e8f6" translate="yes" xml:space="preserve">
          <source>Finishes the use of buffer &lt;code&gt;B&lt;/code&gt; leaving the final string on the top of the stack.</source>
          <target state="translated">Termina el uso del b&amp;uacute;fer &lt;code&gt;B&lt;/code&gt; dejando la cadena final en la parte superior de la pila.</target>
        </trans-unit>
        <trans-unit id="9581cd1476458beea36edaaa1aab1a70ddd9b799" translate="yes" xml:space="preserve">
          <source>First &lt;code&gt;require&lt;/code&gt; queries &lt;code&gt;package.preload[modname]&lt;/code&gt;. If it has a value, this value (which must be a function) is the loader. Otherwise &lt;code&gt;require&lt;/code&gt; searches for a Lua loader using the path stored in &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;. If that also fails, it searches for a C loader using the path stored in &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt;. If that also fails, it tries an &lt;em&gt;all-in-one&lt;/em&gt; loader (see &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Primero se &lt;code&gt;require&lt;/code&gt; consultas &lt;code&gt;package.preload[modname]&lt;/code&gt; . Si tiene un valor, este valor (que debe ser una funci&amp;oacute;n) es el cargador. De lo contrario, &lt;code&gt;require&lt;/code&gt; b&amp;uacute;squedas de un cargador Lua utilizando la ruta almacenada en &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt; . Si eso tambi&amp;eacute;n falla, busca un cargador C utilizando la ruta almacenada en &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt; . Si eso tambi&amp;eacute;n falla, intenta un cargador &lt;em&gt;todo en uno&lt;/em&gt; (vea &lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf6993356b76fa41b8a9a12311a4583412cacf12" translate="yes" xml:space="preserve">
          <source>First declare a variable &lt;code&gt;b&lt;/code&gt; of type &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Primero declare una variable &lt;code&gt;b&lt;/code&gt; de tipo &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b612f7a5723bf19c46b295718acbab9a0f0352e8" translate="yes" xml:space="preserve">
          <source>Floor division (&lt;code&gt;//&lt;/code&gt;) is a division that rounds the quotient towards minus infinity, resulting in the floor of the division of its operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d47a74b914f2999fca9d267f869c38ca08b9e6" translate="yes" xml:space="preserve">
          <source>Floor division (&lt;code&gt;//&lt;/code&gt;) is a division that rounds the quotient towards minus infinity, that is, the floor of the division of its operands.</source>
          <target state="translated">Floor division ( &lt;code&gt;//&lt;/code&gt; ) es una divisi&amp;oacute;n que redondea el cociente hacia menos infinito, es decir, el piso de la divisi&amp;oacute;n de sus operandos.</target>
        </trans-unit>
        <trans-unit id="9578580e96abd6dc66d3f4a9ec50cb8852f521d3" translate="yes" xml:space="preserve">
          <source>Following the IEEE 754 standard, NaN is considered neither smaller than, nor equal to, nor greater than any value (including itself).</source>
          <target state="translated">De acuerdo con la norma IEEE 754,el NaN no se considera ni menor,ni igual,ni mayor que cualquier valor (incluido el propio).</target>
        </trans-unit>
        <trans-unit id="d39e6b7dbac19bdb82dc3bde1e716ea23dd45ecc" translate="yes" xml:space="preserve">
          <source>Following the IEEE 754 standard, the special value NaN is considered neither less than, nor equal to, nor greater than any value, including itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e9fd5a8e55921ad3d74bebecaa1afe7054a8ef" translate="yes" xml:space="preserve">
          <source>For C functions, this function uses the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; as a name for all upvalues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7968a691f0ed611daf368a38173ca221f41fe6c2" translate="yes" xml:space="preserve">
          <source>For C functions, this function uses the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; as a name for all upvalues. (For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.)</source>
          <target state="translated">Para las funciones de C, esta funci&amp;oacute;n usa la cadena vac&amp;iacute;a &lt;code&gt;&quot;&quot;&lt;/code&gt; como nombre para todos los upvalues. (Para las funciones de Lua, los upvalues ​​son las variables locales externas que utiliza la funci&amp;oacute;n y que, en consecuencia, se incluyen en su cierre).</target>
        </trans-unit>
        <trans-unit id="826bad097a9af03241478f133b816c28a093c4ff" translate="yes" xml:space="preserve">
          <source>For Statement</source>
          <target state="translated">Para la declaración</target>
        </trans-unit>
        <trans-unit id="232d13ae76c1a448a0dbe30fce0093b7011c947c" translate="yes" xml:space="preserve">
          <source>For all classes represented by single letters (&lt;code&gt;%a&lt;/code&gt;, &lt;code&gt;%c&lt;/code&gt;, etc.), the corresponding uppercase letter represents the complement of the class. For instance, &lt;code&gt;%S&lt;/code&gt; represents all non-space characters.</source>
          <target state="translated">Para todas las clases representadas por letras simples ( &lt;code&gt;%a&lt;/code&gt; , &lt;code&gt;%c&lt;/code&gt; , etc.), la letra may&amp;uacute;scula correspondiente representa el complemento de la clase. Por ejemplo, &lt;code&gt;%S&lt;/code&gt; representa todos los caracteres que no son espacios.</target>
        </trans-unit>
        <trans-unit id="b277899f2ddc10d7e3dad8301744987f188c3222" translate="yes" xml:space="preserve">
          <source>For an object (table or userdata) to be finalized when collected, you must &lt;em&gt;mark&lt;/em&gt; it for finalization. You mark an object for finalization when you set its metatable and the metatable has a field indexed by the string &quot;&lt;code&gt;__gc&lt;/code&gt;&quot;. Note that if you set a metatable without a &lt;code&gt;__gc&lt;/code&gt; field and later create that field in the metatable, the object will not be marked for finalization.</source>
          <target state="translated">Para que un objeto (tabla o datos de usuario) se finalice cuando se recopile, debe &lt;em&gt;marcarlo&lt;/em&gt; para su finalizaci&amp;oacute;n. Marca un objeto para su finalizaci&amp;oacute;n cuando establece su metatabla y la metatabla tiene un campo indexado por la cadena &quot; &lt;code&gt;__gc&lt;/code&gt; &quot;. Tenga en cuenta que si establece una metatabla sin un campo &lt;code&gt;__gc&lt;/code&gt; y luego crea ese campo en la metatabla, el objeto no se marcar&amp;aacute; para su finalizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="21127f5444f9175d599260124aacb43b3cb15bde" translate="yes" xml:space="preserve">
          <source>For call events, &lt;code&gt;event&lt;/code&gt; can be &lt;code&gt;LUA_HOOKCALL&lt;/code&gt;, the normal value, or &lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt;, for a tail call; in this case, there will be no corresponding return event.</source>
          <target state="translated">Para eventos de llamada, el &lt;code&gt;event&lt;/code&gt; o puede ser &lt;code&gt;LUA_HOOKCALL&lt;/code&gt; , el valor normal, o &lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt; , para una llamada de cola; en este caso, no habr&amp;aacute; evento de devoluci&amp;oacute;n correspondiente.</target>
        </trans-unit>
        <trans-unit id="8a923a874466c00de43a4442ce2de3d1c4f3b26b" translate="yes" xml:space="preserve">
          <source>For compatibility, the old names still work as macros assuming one single user value. Note, however, that userdata with zero user values are more efficient memory-wise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7148362f69bffc94f20dd8e3caacb347b05e34" translate="yes" xml:space="preserve">
          <source>For complete control of how numbers are converted, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef19782c3b513548f8d3e4e46e68c607de619e6c" translate="yes" xml:space="preserve">
          <source>For convenience, most query operations in the API do not follow a strict stack discipline. Instead, they can refer to any element in the stack by using an &lt;em&gt;index&lt;/em&gt;: A positive index represents an absolute stack position (starting at 1); a negative index represents an offset relative to the top of the stack. More specifically, if the stack has &lt;em&gt;n&lt;/em&gt; elements, then index 1 represents the first element (that is, the element that was pushed onto the stack first) and index &lt;em&gt;n&lt;/em&gt; represents the last element; index -1 also represents the last element (that is, the element at the top) and index &lt;em&gt;-n&lt;/em&gt; represents the first element.</source>
          <target state="translated">Por conveniencia, la mayor&amp;iacute;a de las operaciones de consulta en la API no siguen una disciplina de pila estricta. En su lugar, pueden hacer referencia a cualquier elemento de la pila mediante el uso de un &lt;em&gt;&amp;iacute;ndice&lt;/em&gt; : un &amp;iacute;ndice positivo representa una posici&amp;oacute;n absoluta de la pila (comenzando en 1); un &amp;iacute;ndice negativo representa un desplazamiento relativo a la parte superior de la pila. M&amp;aacute;s espec&amp;iacute;ficamente, si la pila tiene &lt;em&gt;n&lt;/em&gt; elementos, entonces el &amp;iacute;ndice 1 representa el primer elemento (es decir, el elemento que se insert&amp;oacute; primero en la pila) y el &amp;iacute;ndice &lt;em&gt;n&lt;/em&gt; representa el &amp;uacute;ltimo elemento; index -1 tambi&amp;eacute;n representa el &amp;uacute;ltimo elemento (es decir, el elemento en la parte superior) e index &lt;em&gt;-n&lt;/em&gt; representa el primer elemento.</target>
        </trans-unit>
        <trans-unit id="7045093cbdc1f5ddefba6dd2df77ec7c61d8c223" translate="yes" xml:space="preserve">
          <source>For convenience, most query operations in the API do not follow a strict stack discipline. Instead, they can refer to any element in the stack by using an &lt;em&gt;index&lt;/em&gt;: A positive index represents an absolute stack position, starting at 1 as the bottom of the stack; a negative index represents an offset relative to the top of the stack. More specifically, if the stack has &lt;em&gt;n&lt;/em&gt; elements, then index 1 represents the first element (that is, the element that was pushed onto the stack first) and index &lt;em&gt;n&lt;/em&gt; represents the last element; index -1 also represents the last element (that is, the element at the top) and index &lt;em&gt;-n&lt;/em&gt; represents the first element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e7817ee2d33410b37da66bff2f4abc60fd9f19" translate="yes" xml:space="preserve">
          <source>For convenience, when the opening long bracket is immediately followed by a newline, the newline is not included in the string. As an example, in a system using ASCII (in which '&lt;code&gt;a&lt;/code&gt;' is coded as 97, newline is coded as 10, and '&lt;code&gt;1&lt;/code&gt;' is coded as 49), the five literal strings below denote the same string:</source>
          <target state="translated">Por conveniencia, cuando el corchete largo de apertura es seguido inmediatamente por una nueva l&amp;iacute;nea, la nueva l&amp;iacute;nea no se incluye en la cadena. Como ejemplo, en un sistema que usa ASCII (en el que ' &lt;code&gt;a&lt;/code&gt; ' se codifica como 97, la nueva l&amp;iacute;nea se codifica como 10 y el ' &lt;code&gt;1&lt;/code&gt; ' se codifica como 49), las cinco cadenas literales a continuaci&amp;oacute;n denotan la misma cadena:</target>
        </trans-unit>
        <trans-unit id="c75b8f31dba0d91bae695aa013d0381fc16c8094" translate="yes" xml:space="preserve">
          <source>For functions that can be called with acceptable indices, any non-valid index is treated as if it contains a value of a virtual type &lt;a id=&quot;pdf-LUA_TNONE&quot;&gt;&lt;code&gt;LUA_TNONE&lt;/code&gt;&lt;/a&gt;, which behaves like a nil value.</source>
          <target state="translated">Para las funciones que se pueden llamar con &amp;iacute;ndices aceptables, cualquier &amp;iacute;ndice no v&amp;aacute;lido se trata como si contuviera un valor de tipo virtual &lt;a id=&quot;pdf-LUA_TNONE&quot;&gt; &lt;code&gt;LUA_TNONE&lt;/code&gt; &lt;/a&gt; , que se comporta como un valor nulo.</target>
        </trans-unit>
        <trans-unit id="a31447203fafe5a4da4338521a4a4fb721154e10" translate="yes" xml:space="preserve">
          <source>For instance, if the path is the string</source>
          <target state="translated">Por ejemplo,si el camino es la cadena</target>
        </trans-unit>
        <trans-unit id="ea7d77d2e3991db06f939eac321dd577052affc3" translate="yes" xml:space="preserve">
          <source>For instance, the expression &lt;code&gt;debug.getinfo(1,&quot;n&quot;).name&lt;/code&gt; returns a name for the current function, if a reasonable name can be found, and the expression &lt;code&gt;debug.getinfo(print)&lt;/code&gt; returns a table with all available information about the &lt;a href=&quot;#pdf-print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Por ejemplo, la expresi&amp;oacute;n &lt;code&gt;debug.getinfo(1,&quot;n&quot;).name&lt;/code&gt; devuelve un nombre para la funci&amp;oacute;n actual, si se puede encontrar un nombre razonable, y la expresi&amp;oacute;n &lt;code&gt;debug.getinfo(print)&lt;/code&gt; devuelve una tabla con toda la informaci&amp;oacute;n disponible sobre la funci&amp;oacute;n de &lt;a href=&quot;#pdf-print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d773bc0c304ccd5d231dc0560bc0e8adc234c3e" translate="yes" xml:space="preserve">
          <source>For integer loops, the control variable never wraps around; instead, the loop ends in case of an overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f325475ad152d3908d4847a20ea6df37fed2cc91" translate="yes" xml:space="preserve">
          <source>For more details about these options, see &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles sobre estas opciones, consulte &lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34c0c487495b8d4cfa8ec08b6a774ef30e784f4f" translate="yes" xml:space="preserve">
          <source>For options &quot;&lt;code&gt;!&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &quot;&lt;code&gt;s&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &quot;&lt;code&gt;i&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, and &quot;&lt;code&gt;I&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &lt;code&gt;n&lt;/code&gt; can be any integer between 1 and 16. All integral options check overflows; &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; checks whether the given value fits in the given size; &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt; checks whether the read value fits in a Lua integer.</source>
          <target state="translated">Para las opciones &quot; &lt;code&gt;!&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;, &quot; &lt;code&gt;s&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;, &quot; &lt;code&gt;i&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot; y &quot; &lt;code&gt;I&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;, &lt;code&gt;n&lt;/code&gt; puede ser cualquier n&amp;uacute;mero entero entre 1 y 16. Todas las opciones integrales comprueban los desbordamientos; &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; comprueba si el valor dado se ajusta al tama&amp;ntilde;o dado; &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; comprueba si el valor le&amp;iacute;do se ajusta a un entero Lua.</target>
        </trans-unit>
        <trans-unit id="16f59a41653df80c51829c1441745313f8b7cbbb" translate="yes" xml:space="preserve">
          <source>For options &quot;&lt;code&gt;!&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &quot;&lt;code&gt;s&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &quot;&lt;code&gt;i&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, and &quot;&lt;code&gt;I&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &lt;code&gt;n&lt;/code&gt; can be any integer between 1 and 16. All integral options check overflows; &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; checks whether the given value fits in the given size; &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt; checks whether the read value fits in a Lua integer. For the unsigned options, Lua integers are treated as unsigned values too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad544ef0a62b91c4a51eea38e40c1547b59eca51" translate="yes" xml:space="preserve">
          <source>For the last two cases, &lt;code&gt;size&lt;/code&gt; is a hint for the size of the buffer, in bytes. The default is an appropriate size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81592a23f0c3cfdc23fb61def4f995f00f7e4be" translate="yes" xml:space="preserve">
          <source>For the last two cases, &lt;code&gt;size&lt;/code&gt; specifies the size of the buffer, in bytes. The default is an appropriate size.</source>
          <target state="translated">Para los dos &amp;uacute;ltimos casos, el &lt;code&gt;size&lt;/code&gt; especifica el tama&amp;ntilde;o del b&amp;uacute;fer, en bytes. El tama&amp;ntilde;o predeterminado es apropiado.</target>
        </trans-unit>
        <trans-unit id="f0c4dd09d2da4ac2d83e7333654eda3bf03b94aa" translate="yes" xml:space="preserve">
          <source>For the unary operators (negation, length, and bitwise NOT), the metamethod is computed and called with a dummy second operand, equal to the first one. This extra operand is only to simplify Lua's internals (by making these operators behave like a binary operation) and may be removed in future versions. (For most uses this extra operand is irrelevant.)</source>
          <target state="translated">Para los operadores unarios (negación,longitud y bitwise NOT),el metamétodo se calcula y se llama con un segundo operando ficticio,igual al primero.Este operando extra es sólo para simplificar los internos de Lua (haciendo que estos operadores se comporten como una operación binaria)y puede ser eliminado en futuras versiones.(Para la mayoría de los usos este operando extra es irrelevante).</target>
        </trans-unit>
        <trans-unit id="aacfef94d4b7963c7011b036882763ad9f51ddc6" translate="yes" xml:space="preserve">
          <source>For the unary operators (negation, length, and bitwise NOT), the metamethod is computed and called with a dummy second operand, equal to the first one. This extra operand is only to simplify Lua's internals (by making these operators behave like a binary operation) and may be removed in future versions. For most uses this extra operand is irrelevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bee60d752066315e8c5d61073cf8553d9376cba" translate="yes" xml:space="preserve">
          <source>For this function, a caret '&lt;code&gt;^&lt;/code&gt;' at the start of a pattern does not work as an anchor, as this would prevent the iteration.</source>
          <target state="translated">Para esta funci&amp;oacute;n, un signo de intercalaci&amp;oacute;n ' &lt;code&gt;^&lt;/code&gt; ' al comienzo de un patr&amp;oacute;n no funciona como un ancla, ya que esto evitar&amp;iacute;a la iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="399be06d89bf8fe00ffb06cec99c776653b07ce7" translate="yes" xml:space="preserve">
          <source>Format Strings for Pack and Unpack</source>
          <target state="translated">Formatear las cuerdas para empacar y desempacar</target>
        </trans-unit>
        <trans-unit id="5811b125cf5b52aaade18ffd4cbe777aa740f3a9" translate="yes" xml:space="preserve">
          <source>Full userdata now has an arbitrary number of associated user values. Therefore, the functions &lt;code&gt;lua_newuserdata&lt;/code&gt;, &lt;code&gt;lua_setuservalue&lt;/code&gt;, and &lt;code&gt;lua_getuservalue&lt;/code&gt; were replaced by &lt;a href=&quot;#lua_newuserdatauv&quot;&gt;&lt;code&gt;lua_newuserdatauv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_setiuservalue&quot;&gt;&lt;code&gt;lua_setiuservalue&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_getiuservalue&quot;&gt;&lt;code&gt;lua_getiuservalue&lt;/code&gt;&lt;/a&gt;, which have an extra argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530d75eed648d882414a993d7c2be06a4295791d" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; has an extra parameter, &lt;code&gt;strip&lt;/code&gt;. Use 0 as the value of this parameter to get the old behavior.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; tiene un par&amp;aacute;metro adicional, &lt;code&gt;strip&lt;/code&gt; . Utilice 0 como valor de este par&amp;aacute;metro para obtener el comportamiento anterior.</target>
        </trans-unit>
        <trans-unit id="d8cdf10face49f05a0d7bce562c1cbcff9eeec04" translate="yes" xml:space="preserve">
          <source>Function Calls</source>
          <target state="translated">Llamadas de función</target>
        </trans-unit>
        <trans-unit id="4b57ecf18e5d2f870512efd9673b84b72878ac94" translate="yes" xml:space="preserve">
          <source>Function Calls as Statements</source>
          <target state="translated">La función llama como declaraciones</target>
        </trans-unit>
        <trans-unit id="92923ba91494ddefbc1f5287cf60c97558518359" translate="yes" xml:space="preserve">
          <source>Function Definitions</source>
          <target state="translated">Definiciones de la función</target>
        </trans-unit>
        <trans-unit id="a8675a73106b372729db5f272e24a7c2891c266a" translate="yes" xml:space="preserve">
          <source>Function calls and assignments can start with an open parenthesis. This possibility leads to an ambiguity in Lua's grammar. Consider the following fragment:</source>
          <target state="translated">Las llamadas y asignaciones de funciones pueden comenzar con un paréntesis abierto.Esta posibilidad lleva a una ambigüedad en la gramática de Lua.Considere el siguiente fragmento:</target>
        </trans-unit>
        <trans-unit id="723bc3c839b5efbdcf6d6d540aec9e08e9a27818" translate="yes" xml:space="preserve">
          <source>Functions called &lt;code&gt;luaL_check*&lt;/code&gt; always raise an error if the check is not satisfied.</source>
          <target state="translated">Las funciones llamadas &lt;code&gt;luaL_check*&lt;/code&gt; siempre generan un error si la verificaci&amp;oacute;n no se cumple.</target>
        </trans-unit>
        <trans-unit id="2d65cedef6534edb90967211162bdffe8c828103" translate="yes" xml:space="preserve">
          <source>Functions that create byte sequences accept all values up to &lt;code&gt;0x7FFFFFFF&lt;/code&gt;, as defined in the original UTF-8 specification; that implies byte sequences of up to six bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c702d0533cf7bf413cae345667e4f93afbda238" translate="yes" xml:space="preserve">
          <source>Functions that do not need a specific mutable position, but only a value (e.g., query functions), can be called with acceptable indices. An &lt;em&gt;acceptable index&lt;/em&gt; can be any valid index, but it also can be any positive index after the stack top within the space allocated for the stack, that is, indices up to the stack size. (Note that 0 is never an acceptable index.) Except when noted otherwise, functions in the API work with acceptable indices.</source>
          <target state="translated">Las funciones que no necesitan una posici&amp;oacute;n mutable espec&amp;iacute;fica, sino solo un valor (por ejemplo, funciones de consulta), se pueden llamar con &amp;iacute;ndices aceptables. Un &lt;em&gt;&amp;iacute;ndice aceptable&lt;/em&gt; puede ser cualquier &amp;iacute;ndice v&amp;aacute;lido, pero tambi&amp;eacute;n puede ser cualquier &amp;iacute;ndice positivo despu&amp;eacute;s de la parte superior de la pila dentro del espacio asignado para la pila, es decir, &amp;iacute;ndices hasta el tama&amp;ntilde;o de la pila. (Tenga en cuenta que 0 nunca es un &amp;iacute;ndice aceptable). Excepto cuando se indique lo contrario, las funciones de la API funcionan con &amp;iacute;ndices aceptables.</target>
        </trans-unit>
        <trans-unit id="71ee2fc0b246259543c3707b31174809b1446b0a" translate="yes" xml:space="preserve">
          <source>Functions that do not need a specific mutable position, but only a value (e.g., query functions), can be called with acceptable indices. An &lt;em&gt;acceptable index&lt;/em&gt; can be any valid index, but it also can be any positive index after the stack top within the space allocated for the stack, that is, indices up to the stack size. (Note that 0 is never an acceptable index.) Indices to upvalues (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;) greater than the real number of upvalues in the current C function are also acceptable (but invalid). Except when noted otherwise, functions in the API work with acceptable indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eec0deb30fe9df087749c912f9fa2e221445a8" translate="yes" xml:space="preserve">
          <source>Functions that interpret byte sequences only accept valid sequences (well formed and not overlong). By default, they only accept byte sequences that result in valid Unicode code points, rejecting values greater than &lt;code&gt;10FFFF&lt;/code&gt; and surrogates. A boolean argument &lt;code&gt;lax&lt;/code&gt;, when available, lifts these checks, so that all values up to &lt;code&gt;0x7FFFFFFF&lt;/code&gt; are accepted. (Not well formed and overlong sequences are still rejected.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a5aae46bd7798a00126da19dd14418bb7e3eb8" translate="yes" xml:space="preserve">
          <source>Functions to inject/project unsigned integers (&lt;code&gt;lua_pushunsigned&lt;/code&gt;, &lt;code&gt;lua_tounsigned&lt;/code&gt;, &lt;code&gt;lua_tounsignedx&lt;/code&gt;, &lt;code&gt;luaL_checkunsigned&lt;/code&gt;, &lt;code&gt;luaL_optunsigned&lt;/code&gt;) were deprecated. Use their signed equivalents with a type cast.</source>
          <target state="translated">Las funciones para inyectar / proyectar enteros sin firmar ( &lt;code&gt;lua_pushunsigned&lt;/code&gt; , &lt;code&gt;lua_tounsigned&lt;/code&gt; , &lt;code&gt;lua_tounsignedx&lt;/code&gt; , &lt;code&gt;luaL_checkunsigned&lt;/code&gt; , &lt;code&gt;luaL_optunsigned&lt;/code&gt; ) quedaron en desuso. Utilice sus equivalentes firmados con un molde tipogr&amp;aacute;fico.</target>
        </trans-unit>
        <trans-unit id="399c67992893454b594db8a5c3ddb1835002a32d" translate="yes" xml:space="preserve">
          <source>Functions with upvalues have only their number of upvalues saved. When (re)loaded, those upvalues receive fresh instances containing &lt;b&gt;nil&lt;/b&gt;. (You can use the debug library to serialize and reload the upvalues of a function in a way adequate to your needs.)</source>
          <target state="translated">Las funciones con upvalues ​​solo tienen guardado su n&amp;uacute;mero de upvalues. Cuando (re) cargan, esos upvalues ​​reciben instancias nuevas que contienen &lt;b&gt;nil&lt;/b&gt; . (Puede usar la biblioteca de depuraci&amp;oacute;n para serializar y recargar los valores de una funci&amp;oacute;n de una manera adecuada a sus necesidades).</target>
        </trans-unit>
        <trans-unit id="0b638ca7daccce15b49244cde0902229230009dc" translate="yes" xml:space="preserve">
          <source>Functions with upvalues have only their number of upvalues saved. When (re)loaded, those upvalues receive fresh instances. (See the &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; function for details about how these upvalues are initialized. You can use the debug library to serialize and reload the upvalues of a function in a way adequate to your needs.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">Recolección de basura</target>
        </trans-unit>
        <trans-unit id="f6855bbf563c59c18fc37154e4af975ae952d5a4" translate="yes" xml:space="preserve">
          <source>Garbage-Collection Metamethods</source>
          <target state="translated">Metamétodos de recolección de basura</target>
        </trans-unit>
        <trans-unit id="313100c75a8533ab565e1eb0ac9c81f85a7c5073" translate="yes" xml:space="preserve">
          <source>Generates a Lua error, using the value at the top of the stack as the error object. This function does a long jump, and therefore never returns (see &lt;a href=&quot;#luaL_error&quot;&gt;&lt;code&gt;luaL_error&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Genera un error Lua, utilizando el valor en la parte superior de la pila como objeto de error. Esta funci&amp;oacute;n realiza un salto largo y, por lo tanto, nunca regresa (ver &lt;a href=&quot;#luaL_error&quot;&gt; &lt;code&gt;luaL_error&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="50c098c65024d0b52b85fb9aca6369ae9372e358" translate="yes" xml:space="preserve">
          <source>Generational Garbage Collection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0be169e33a9a31268a5328272fe2fa469b1c7ec" translate="yes" xml:space="preserve">
          <source>Gets information about a local variable of a given activation record or a given function.</source>
          <target state="translated">Obtiene información sobre una variable local de un registro de activación determinado o una función determinada.</target>
        </trans-unit>
        <trans-unit id="a91634dbb2a1cbd99fd7a796a6dde64168923d2e" translate="yes" xml:space="preserve">
          <source>Gets information about a local variable or a temporary value of a given activation record or a given function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf3ef7371f5378d8e58a5b0757ef77be8111cff" translate="yes" xml:space="preserve">
          <source>Gets information about a specific function or function invocation.</source>
          <target state="translated">Obtiene información sobre una función específica o la invocación de una función.</target>
        </trans-unit>
        <trans-unit id="5d07f6c25730366d5782ddf2124f63eacbe7a041" translate="yes" xml:space="preserve">
          <source>Gets information about the &lt;code&gt;n&lt;/code&gt;-th upvalue of the closure at index &lt;code&gt;funcindex&lt;/code&gt;. It pushes the upvalue's value onto the stack and returns its name. Returns &lt;code&gt;NULL&lt;/code&gt; (and pushes nothing) when the index &lt;code&gt;n&lt;/code&gt; is greater than the number of upvalues.</source>
          <target state="translated">Obtiene informaci&amp;oacute;n sobre el &lt;code&gt;n&lt;/code&gt; -&amp;eacute;simo valor ascendente del cierre en el &amp;iacute;ndice &lt;code&gt;funcindex&lt;/code&gt; . Empuja el valor del upvalue en la pila y devuelve su nombre. Devuelve &lt;code&gt;NULL&lt;/code&gt; (y no inserta nada) cuando el &amp;iacute;ndice &lt;code&gt;n&lt;/code&gt; es mayor que el n&amp;uacute;mero de upvalues.</target>
        </trans-unit>
        <trans-unit id="62c6dfe4bd33a93e8e74cb65c4ff32424b3ecf7b" translate="yes" xml:space="preserve">
          <source>Gets information about the interpreter runtime stack.</source>
          <target state="translated">Obtiene información sobre la pila de tiempo de ejecución del intérprete.</target>
        </trans-unit>
        <trans-unit id="0b201abab8551378dd82fcd0d47c8bebaab95fa2" translate="yes" xml:space="preserve">
          <source>Gets the real value of &lt;code&gt;table[index]&lt;/code&gt;, without invoking the &lt;code&gt;__index&lt;/code&gt; metamethod. &lt;code&gt;table&lt;/code&gt; must be a table; &lt;code&gt;index&lt;/code&gt; may be any value.</source>
          <target state="translated">Obtiene el valor real de la &lt;code&gt;table[index]&lt;/code&gt; , sin invocar el &lt;code&gt;__index&lt;/code&gt; __index. &lt;code&gt;table&lt;/code&gt; debe ser una mesa; &lt;code&gt;index&lt;/code&gt; puede tener cualquier valor.</target>
        </trans-unit>
        <trans-unit id="2eb65b9436b0e69a1305aac536012a51200d6c8e" translate="yes" xml:space="preserve">
          <source>Gets the real value of &lt;code&gt;table[index]&lt;/code&gt;, without using the &lt;code&gt;__index&lt;/code&gt; metavalue. &lt;code&gt;table&lt;/code&gt; must be a table; &lt;code&gt;index&lt;/code&gt; may be any value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91020a88f59d9c8fbc1c662bdb6eda5896f6dbfe" translate="yes" xml:space="preserve">
          <source>Given a list where all elements are strings or numbers, returns the string &lt;code&gt;list[i]..sep..list[i+1] &amp;middot;&amp;middot;&amp;middot; sep..list[j]&lt;/code&gt;. The default value for &lt;code&gt;sep&lt;/code&gt; is the empty string, the default for &lt;code&gt;i&lt;/code&gt; is 1, and the default for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is greater than &lt;code&gt;j&lt;/code&gt;, returns the empty string.</source>
          <target state="translated">Dada una lista donde todos los elementos son cadenas o n&amp;uacute;meros, devuelve la cadena &lt;code&gt;list[i]..sep..list[i+1] &amp;middot;&amp;middot;&amp;middot; sep..list[j]&lt;/code&gt; . El valor predeterminado para &lt;code&gt;sep&lt;/code&gt; es la cadena vac&amp;iacute;a, el predeterminado para &lt;code&gt;i&lt;/code&gt; es 1 y el predeterminado para &lt;code&gt;j&lt;/code&gt; es &lt;code&gt;#list&lt;/code&gt; . Si &lt;code&gt;i&lt;/code&gt; es mayor que &lt;code&gt;j&lt;/code&gt; , devuelve la cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="b57745f04b18114e4271e54461167a450eab4e48" translate="yes" xml:space="preserve">
          <source>Grows the stack size to &lt;code&gt;top + sz&lt;/code&gt; elements, raising an error if the stack cannot grow to that size. &lt;code&gt;msg&lt;/code&gt; is an additional text to go into the error message (or &lt;code&gt;NULL&lt;/code&gt; for no additional text).</source>
          <target state="translated">Aumenta el tama&amp;ntilde;o de la pila hasta &lt;code&gt;top + sz&lt;/code&gt; elementos top + sz , lo que genera un error si la pila no puede crecer hasta ese tama&amp;ntilde;o. &lt;code&gt;msg&lt;/code&gt; es un texto adicional para incluir en el mensaje de error (o &lt;code&gt;NULL&lt;/code&gt; si no hay texto adicional).</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">Aquí hay algunos ejemplos:</target>
        </trans-unit>
        <trans-unit id="4b1c6bd65c741e8ff2d3bbd3ff2fc22c3d2a47ba" translate="yes" xml:space="preserve">
          <source>Here is a simple implementation for the allocator function. It is used in the auxiliary library by &lt;a href=&quot;#luaL_newstate&quot;&gt;&lt;code&gt;luaL_newstate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Aqu&amp;iacute; hay una implementaci&amp;oacute;n simple para la funci&amp;oacute;n de asignaci&amp;oacute;n. Se usa en la biblioteca auxiliar por &lt;a href=&quot;#luaL_newstate&quot;&gt; &lt;code&gt;luaL_newstate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1dab51e6891f4e284fffd166a6bd35c869f4cc2" translate="yes" xml:space="preserve">
          <source>Here is the complete syntax of Lua in extended BNF. As usual in extended BNF, {A} means 0 or more As, and [A] means an optional A. (For operator precedences, see &lt;a href=&quot;#3.4.8&quot;&gt;&amp;sect;3.4.8&lt;/a&gt;; for a description of the terminals Name, Numeral, and LiteralString, see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;.)</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la sintaxis completa de Lua en BNF extendido. Como es habitual en BNF extendido, {A} significa 0 o m&amp;aacute;s As, y [A] significa una A opcional (para precedencias de operadores, consulte &lt;a href=&quot;#3.4.8&quot;&gt;&amp;sect;3.4.8&lt;/a&gt; ; para obtener una descripci&amp;oacute;n de los terminales Name, Numeral y LiteralString, consulte &lt;a href=&quot;#3.1&quot;&gt;&amp;sect; 3.1&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="ded763c4029757dddf3f7027714a4cf075c2d5bd" translate="yes" xml:space="preserve">
          <source>Here it is in C:</source>
          <target state="translated">Aquí está en C:</target>
        </trans-unit>
        <trans-unit id="3f274b8694db69b484f40f23944a016b4fffa6f3" translate="yes" xml:space="preserve">
          <source>Here we list all functions and types from the C API in alphabetical order. Each function has an indicator like this:</source>
          <target state="translated">Aquí enumeramos todas las funciones y tipos de la API de C en orden alfabético.Cada función tiene un indicador como este:</target>
        </trans-unit>
        <trans-unit id="759a7b44d9cbdbdff0c6256556529057e71e4bfc" translate="yes" xml:space="preserve">
          <source>Here we list all functions and types from the auxiliary library in alphabetical order.</source>
          <target state="translated">Aquí enumeramos todas las funciones y tipos de la biblioteca auxiliar en orden alfabético.</target>
        </trans-unit>
        <trans-unit id="5ef4637da05a815223e812a542adefe907813773" translate="yes" xml:space="preserve">
          <source>Here we list the incompatibilities that you may find when moving a program from Lua 5.2 to Lua 5.3. You can avoid some incompatibilities by compiling Lua with appropriate options (see file &lt;code&gt;luaconf.h&lt;/code&gt;). However, all these compatibility options will be removed in the future.</source>
          <target state="translated">Aqu&amp;iacute; enumeramos las incompatibilidades que puede encontrar al mover un programa de Lua 5.2 a Lua 5.3. Puede evitar algunas incompatibilidades compilando Lua con las opciones adecuadas (consulte el archivo &lt;code&gt;luaconf.h&lt;/code&gt; ). Sin embargo, todas estas opciones de compatibilidad se eliminar&amp;aacute;n en el futuro.</target>
        </trans-unit>
        <trans-unit id="baa813e9ef48afa17599283672646b10b398c71d" translate="yes" xml:space="preserve">
          <source>Here we list the incompatibilities that you may find when moving a program from Lua 5.3 to Lua 5.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1634499670e7d73f48fc27f8298b086983ef130f" translate="yes" xml:space="preserve">
          <source>Here, to &lt;em&gt;close&lt;/em&gt; a value means to call its &lt;code&gt;__close&lt;/code&gt; metamethod. When calling the metamethod, the value itself is passed as the first argument and the error object that caused the exit (if any) is passed as a second argument; if there was no error, the second argument is &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e8633ec37fd0a545b50c273991305c0a0ccd6af" translate="yes" xml:space="preserve">
          <source>Hook functions can yield under the following conditions: Only count and line events can yield; to yield, a hook function must finish its execution calling &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;nresults&lt;/code&gt; equal to zero (that is, with no values).</source>
          <target state="translated">Las funciones de gancho pueden ceder en las siguientes condiciones: S&amp;oacute;lo pueden ceder los eventos de recuento y l&amp;iacute;nea; para ceder, una funci&amp;oacute;n de gancho debe terminar su ejecuci&amp;oacute;n llamando a &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; con &lt;code&gt;nresults&lt;/code&gt; iguales a cero (es decir, sin valores).</target>
        </trans-unit>
        <trans-unit id="57503e65706288b8ec579f8045e20e5c7fc42803" translate="yes" xml:space="preserve">
          <source>Hook functions cannot have continuations, that is, they cannot call &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; with a non-null &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Las funciones de gancho no pueden tener continuaciones, es decir, no pueden llamar a &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; con una &lt;code&gt;k&lt;/code&gt; no nula .</target>
        </trans-unit>
        <trans-unit id="8e26681d60fc0627c647c42d14db1c8969032f43" translate="yes" xml:space="preserve">
          <source>Hooks are disabled by setting &lt;code&gt;mask&lt;/code&gt; to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c8d828197edf926fd895a22fd233a53985fe4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;chunk&lt;/code&gt; is a string, the chunk is this string. If &lt;code&gt;chunk&lt;/code&gt; is a function, &lt;code&gt;load&lt;/code&gt; calls it repeatedly to get the chunk pieces. Each call to &lt;code&gt;chunk&lt;/code&gt; must return a string that concatenates with previous results. A return of an empty string, &lt;b&gt;nil&lt;/b&gt;, or no value signals the end of the chunk.</source>
          <target state="translated">Si el &lt;code&gt;chunk&lt;/code&gt; es una cadena, el fragmento es esta cadena. Si &lt;code&gt;chunk&lt;/code&gt; es una funci&amp;oacute;n, &lt;code&gt;load&lt;/code&gt; la llama repetidamente para obtener los fragmentos. Cada llamada a &lt;code&gt;chunk&lt;/code&gt; debe devolver una cadena que se concatene con los resultados anteriores. Un retorno de una cadena vac&amp;iacute;a, &lt;b&gt;nulo&lt;/b&gt; o sin valor indica el final del fragmento.</target>
        </trans-unit>
        <trans-unit id="56626a6306a0218f5ebc2bc99df5b09f8b5d3616" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;def&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the function uses &lt;code&gt;def&lt;/code&gt; as a default value when there is no argument &lt;code&gt;arg&lt;/code&gt; or when this argument is &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Si &lt;code&gt;def&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , la funci&amp;oacute;n usa &lt;code&gt;def&lt;/code&gt; como valor predeterminado cuando no hay argumento &lt;code&gt;arg&lt;/code&gt; o cuando este argumento es &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ce3a21a7279c845347c98d6941a31e57eb8f0480" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is absent, it defaults to &quot;&lt;code&gt;%c&lt;/code&gt;&quot;, which gives a human-readable date and time representation using the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b55b3722d0d97704dcddb34cbf9bcdade76ec4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is not &quot;&lt;code&gt;*t&lt;/code&gt;&quot;, then &lt;code&gt;date&lt;/code&gt; returns the date as a string, formatted according to the same rules as the ISO C function &lt;code&gt;strftime&lt;/code&gt;.</source>
          <target state="translated">Si el &lt;code&gt;format&lt;/code&gt; o no es &quot; &lt;code&gt;*t&lt;/code&gt; &quot;, la &lt;code&gt;date&lt;/code&gt; devuelve la fecha como una cadena, formateada de acuerdo con las mismas reglas que la funci&amp;oacute;n ISO C &lt;code&gt;strftime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="506e40ff0a74eaa2a16ebe55cc542c656b7d6688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; starts with '&lt;code&gt;!&lt;/code&gt;', then the date is formatted in Coordinated Universal Time. After this optional character, if &lt;code&gt;format&lt;/code&gt; is the string &quot;&lt;code&gt;*t&lt;/code&gt;&quot;, then &lt;code&gt;date&lt;/code&gt; returns a table with the following fields: &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; (1&amp;ndash;12), &lt;code&gt;day&lt;/code&gt; (1&amp;ndash;31), &lt;code&gt;hour&lt;/code&gt; (0&amp;ndash;23), &lt;code&gt;min&lt;/code&gt; (0&amp;ndash;59), &lt;code&gt;sec&lt;/code&gt; (0&amp;ndash;61), &lt;code&gt;wday&lt;/code&gt; (weekday, 1&amp;ndash;7, Sunday is 1), &lt;code&gt;yday&lt;/code&gt; (day of the year, 1&amp;ndash;366), and &lt;code&gt;isdst&lt;/code&gt; (daylight saving flag, a boolean). This last field may be absent if the information is not available.</source>
          <target state="translated">Si el &lt;code&gt;format&lt;/code&gt; o comienza con ' &lt;code&gt;!&lt;/code&gt; ', la fecha se formatea en Hora universal coordinada. Despu&amp;eacute;s de este car&amp;aacute;cter opcional, si el &lt;code&gt;format&lt;/code&gt; o es la cadena &quot; &lt;code&gt;*t&lt;/code&gt; &quot;, la &lt;code&gt;date&lt;/code&gt; devuelve una tabla con los siguientes campos: &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; (1&amp;ndash;12), &lt;code&gt;day&lt;/code&gt; (1&amp;ndash;31), &lt;code&gt;hour&lt;/code&gt; (0&amp;ndash;23), &lt;code&gt;min&lt;/code&gt; ( 0&amp;ndash;59), &lt;code&gt;sec&lt;/code&gt; (0&amp;ndash;61), &lt;code&gt;wday&lt;/code&gt; (d&amp;iacute;a de la semana, 1&amp;ndash;7, el domingo es 1), &lt;code&gt;yday&lt;/code&gt; (d&amp;iacute;a del a&amp;ntilde;o, 1&amp;ndash;366) e &lt;code&gt;isdst&lt;/code&gt; ( indicador de horario de verano, un valor booleano). Este &amp;uacute;ltimo campo puede estar ausente si la informaci&amp;oacute;n no est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="5fabd7f39d8301559d47d11e33fa3e76d67812f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; starts with '&lt;code&gt;!&lt;/code&gt;', then the date is formatted in Coordinated Universal Time. After this optional character, if &lt;code&gt;format&lt;/code&gt; is the string &quot;&lt;code&gt;*t&lt;/code&gt;&quot;, then &lt;code&gt;date&lt;/code&gt; returns a table with the following fields: &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; (1&amp;ndash;12), &lt;code&gt;day&lt;/code&gt; (1&amp;ndash;31), &lt;code&gt;hour&lt;/code&gt; (0&amp;ndash;23), &lt;code&gt;min&lt;/code&gt; (0&amp;ndash;59), &lt;code&gt;sec&lt;/code&gt; (0&amp;ndash;61, due to leap seconds), &lt;code&gt;wday&lt;/code&gt; (weekday, 1&amp;ndash;7, Sunday is 1), &lt;code&gt;yday&lt;/code&gt; (day of the year, 1&amp;ndash;366), and &lt;code&gt;isdst&lt;/code&gt; (daylight saving flag, a boolean). This last field may be absent if the information is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8190672d8b6e5a23cf38bf7fd250cf0fc81f9304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;funcname&lt;/code&gt; is &quot;&lt;code&gt;*&lt;/code&gt;&quot;, then it only links with the library, making the symbols exported by the library available to other dynamically linked libraries. Otherwise, it looks for a function &lt;code&gt;funcname&lt;/code&gt; inside the library and returns this function as a C function. So, &lt;code&gt;funcname&lt;/code&gt; must follow the &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt; prototype (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Si &lt;code&gt;funcname&lt;/code&gt; es &quot; &lt;code&gt;*&lt;/code&gt; &quot;, entonces solo se vincula con la biblioteca, haciendo que los s&amp;iacute;mbolos exportados por la biblioteca est&amp;eacute;n disponibles para otras bibliotecas vinculadas din&amp;aacute;micamente. De lo contrario, busca una funci&amp;oacute;n &lt;code&gt;funcname&lt;/code&gt; dentro de la biblioteca y devuelve esta funci&amp;oacute;n como una funci&amp;oacute;n C. Entonces, &lt;code&gt;funcname&lt;/code&gt; debe seguir el prototipo &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; (ver &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3843661cd0d22957a2df1b74e3cc0eae40b47007" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;glb&lt;/code&gt; is true, also stores the module into global &lt;code&gt;modname&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;glb&lt;/code&gt; es verdadero, tambi&amp;eacute;n almacena el m&amp;oacute;dulo en global &lt;code&gt;modname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99af05450ff1a222db083914ea7a113dd84ad562" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;glb&lt;/code&gt; is true, also stores the module into the global &lt;code&gt;modname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dfd113b7f3930f57215faca9229d63e5a7444d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index&lt;/code&gt; is a number, returns all arguments after argument number &lt;code&gt;index&lt;/code&gt;; a negative number indexes from the end (-1 is the last argument). Otherwise, &lt;code&gt;index&lt;/code&gt; must be the string &lt;code&gt;&quot;#&quot;&lt;/code&gt;, and &lt;code&gt;select&lt;/code&gt; returns the total number of extra arguments it received.</source>
          <target state="translated">Si el &lt;code&gt;index&lt;/code&gt; es un n&amp;uacute;mero, devuelve todos los argumentos despu&amp;eacute;s del &lt;code&gt;index&lt;/code&gt; n&amp;uacute;mero del argumento ; un n&amp;uacute;mero negativo indexa desde el final (-1 es el &amp;uacute;ltimo argumento). De lo contrario, &lt;code&gt;index&lt;/code&gt; debe ser la cadena &lt;code&gt;&quot;#&quot;&lt;/code&gt; , y &lt;code&gt;select&lt;/code&gt; devuelve el n&amp;uacute;mero total de argumentos adicionales que recibi&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="9a792f6a10658dfe428995a06ea53ae4d673e447" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isnum&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, its referent is assigned a boolean value that indicates whether the operation succeeded.</source>
          <target state="translated">Si &lt;code&gt;isnum&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , a su referente se le asigna un valor booleano que indica si la operaci&amp;oacute;n tuvo &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="5b55802773aaefd409c45001fa5f1235e3bd43a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;l&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, fills its referent with the result's length. If the result is &lt;code&gt;NULL&lt;/code&gt; (only possible when returning &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;d == NULL&lt;/code&gt;), its length is considered zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15877b81cb8f4644f0e73a139f0b786972779bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;l&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, fills the position &lt;code&gt;*l&lt;/code&gt; with the result's length. If the result is &lt;code&gt;NULL&lt;/code&gt; (only possible when returning &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;d == NULL&lt;/code&gt;), its length is considered zero.</source>
          <target state="translated">Si &lt;code&gt;l&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , llena la posici&amp;oacute;n &lt;code&gt;*l&lt;/code&gt; con la longitud del resultado. Si el resultado es &lt;code&gt;NULL&lt;/code&gt; (s&amp;oacute;lo es posible cuando se entreguen &lt;code&gt;d&lt;/code&gt; y &lt;code&gt;d == NULL&lt;/code&gt; ), su longitud se considera cero.</target>
        </trans-unit>
        <trans-unit id="73f0cbaf64ffcc698ebe789e3bf72282c151d928" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;locale&lt;/code&gt; is the empty string, the current locale is set to an implementation-defined native locale. If &lt;code&gt;locale&lt;/code&gt; is the string &quot;&lt;code&gt;C&lt;/code&gt;&quot;, the current locale is set to the standard C locale.</source>
          <target state="translated">Si &lt;code&gt;locale&lt;/code&gt; es la cadena vac&amp;iacute;a, la locale actual se establece en una locale nativa definida por la implementaci&amp;oacute;n. Si la &lt;code&gt;locale&lt;/code&gt; es la cadena &quot; &lt;code&gt;C&lt;/code&gt; &quot;, la configuraci&amp;oacute;n regional actual se establece en la configuraci&amp;oacute;n regional C est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="acb78160a1f280ce628830b7a5b6f03f442478bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;message&lt;/code&gt; is present but is neither a string nor &lt;b&gt;nil&lt;/b&gt;, this function returns &lt;code&gt;message&lt;/code&gt; without further processing. Otherwise, it returns a string with a traceback of the call stack. The optional &lt;code&gt;message&lt;/code&gt; string is appended at the beginning of the traceback. An optional &lt;code&gt;level&lt;/code&gt; number tells at which level to start the traceback (default is 1, the function calling &lt;code&gt;traceback&lt;/code&gt;).</source>
          <target state="translated">Si el &lt;code&gt;message&lt;/code&gt; est&amp;aacute; presente pero no es una cadena ni es &lt;b&gt;nulo&lt;/b&gt; , esta funci&amp;oacute;n devuelve el &lt;code&gt;message&lt;/code&gt; sin m&amp;aacute;s procesamiento. De lo contrario, devuelve una cadena con un seguimiento de la pila de llamadas. La cadena de &lt;code&gt;message&lt;/code&gt; opcional se agrega al comienzo del rastreo. Un n&amp;uacute;mero de &lt;code&gt;level&lt;/code&gt; opcional indica en qu&amp;eacute; nivel iniciar el rastreo (el valor predeterminado es 1, la funci&amp;oacute;n que llama al &lt;code&gt;traceback&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="842cd5b591dfca5b2f8676469b17faefa0a0959f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;modname&lt;/code&gt; is not already present in &lt;a href=&quot;#pdf-package.loaded&quot;&gt;&lt;code&gt;package.loaded&lt;/code&gt;&lt;/a&gt;, calls function &lt;code&gt;openf&lt;/code&gt; with string &lt;code&gt;modname&lt;/code&gt; as an argument and sets the call result in &lt;code&gt;package.loaded[modname]&lt;/code&gt;, as if that function has been called through &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;modname&lt;/code&gt; no est&amp;aacute; ya presente en &lt;a href=&quot;#pdf-package.loaded&quot;&gt; &lt;code&gt;package.loaded&lt;/code&gt; &lt;/a&gt; , llama a la funci&amp;oacute;n &lt;code&gt;openf&lt;/code&gt; con la cadena &lt;code&gt;modname&lt;/code&gt; como argumento y establece el resultado de la llamada en &lt;code&gt;package.loaded[modname]&lt;/code&gt; , como si esa funci&amp;oacute;n hubiera sido llamada a trav&amp;eacute;s de &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c31adda24a7d148cbbeb4abd1c9efc9a5e0f6cc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msgh&lt;/code&gt; is 0, then the error object returned on the stack is exactly the original error object. Otherwise, &lt;code&gt;msgh&lt;/code&gt; is the stack index of a &lt;em&gt;message handler&lt;/em&gt;. (This index cannot be a pseudo-index.) In case of runtime errors, this function will be called with the error object and its return value will be the object returned on the stack by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;msgh&lt;/code&gt; es 0, entonces el objeto de error devuelto en la pila es exactamente el objeto de error original. De lo contrario, &lt;code&gt;msgh&lt;/code&gt; es el &amp;iacute;ndice de pila de un &lt;em&gt;controlador de mensajes&lt;/em&gt; . (Este &amp;iacute;ndice no puede ser un pseudo-&amp;iacute;ndice.) En caso de errores de tiempo de ejecuci&amp;oacute;n, esta funci&amp;oacute;n se llamar&amp;aacute; con el objeto de error y su valor de retorno ser&amp;aacute; el objeto devuelto en la pila por &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51f00954e85aa7f6bdec96453ea0264b6dcaf354" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msgh&lt;/code&gt; is 0, then the error object returned on the stack is exactly the original error object. Otherwise, &lt;code&gt;msgh&lt;/code&gt; is the stack index of a &lt;em&gt;message handler&lt;/em&gt;. (This index cannot be a pseudo-index.) In case of runtime errors, this handler will be called with the error object and its return value will be the object returned on the stack by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1820013984578d01f9005b716812fa4d2f636236" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;object&lt;/code&gt; does not have a metatable, returns &lt;b&gt;nil&lt;/b&gt;. Otherwise, if the object's metatable has a &lt;code&gt;__metatable&lt;/code&gt; field, returns the associated value. Otherwise, returns the metatable of the given object.</source>
          <target state="translated">Si el &lt;code&gt;object&lt;/code&gt; no tiene una metatabla, devuelve &lt;b&gt;nil&lt;/b&gt; . De lo contrario, si la metatabla del objeto tiene un campo &lt;code&gt;__metatable&lt;/code&gt; , devuelve el valor asociado. De lo contrario, devuelve la metatabla del objeto dado.</target>
        </trans-unit>
        <trans-unit id="32f4a130048c4d1f47c68966ce8a1eedff4ff989" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;package.loaded[modname]&lt;/code&gt; is not true, calls the function &lt;code&gt;openf&lt;/code&gt; with the string &lt;code&gt;modname&lt;/code&gt; as an argument and sets the call result to &lt;code&gt;package.loaded[modname]&lt;/code&gt;, as if that function has been called through &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8540353902febf7d816e3357366d699709e0ebfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ref&lt;/code&gt; is &lt;a href=&quot;#pdf-LUA_NOREF&quot;&gt;&lt;code&gt;LUA_NOREF&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdf-LUA_REFNIL&quot;&gt;&lt;code&gt;LUA_REFNIL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_unref&quot;&gt;&lt;code&gt;luaL_unref&lt;/code&gt;&lt;/a&gt; does nothing.</source>
          <target state="translated">Si &lt;code&gt;ref&lt;/code&gt; es &lt;a href=&quot;#pdf-LUA_NOREF&quot;&gt; &lt;code&gt;LUA_NOREF&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#pdf-LUA_REFNIL&quot;&gt; &lt;code&gt;LUA_REFNIL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#luaL_unref&quot;&gt; &lt;code&gt;luaL_unref&lt;/code&gt; &lt;/a&gt; no hace nada.</target>
        </trans-unit>
        <trans-unit id="0ef9686e0e91a6b272fed24ea40a04743ba642b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order.</source>
          <target state="translated">Si &lt;code&gt;repl&lt;/code&gt; es una funci&amp;oacute;n, esta funci&amp;oacute;n se llama cada vez que se produce una coincidencia, con todas las subcadenas capturadas pasadas como argumentos, en orden.</target>
        </trans-unit>
        <trans-unit id="acbcb36c3a66c6e9e703f8cba5f8b02711833af9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a string, then its value is used for replacement. The character &lt;code&gt;%&lt;/code&gt; works as an escape character: any sequence in &lt;code&gt;repl&lt;/code&gt; of the form &lt;code&gt;%&lt;em&gt;d&lt;/em&gt;&lt;/code&gt;, with &lt;em&gt;d&lt;/em&gt; between 1 and 9, stands for the value of the &lt;em&gt;d&lt;/em&gt;-th captured substring. The sequence &lt;code&gt;%0&lt;/code&gt; stands for the whole match. The sequence &lt;code&gt;%%&lt;/code&gt; stands for a single &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;repl&lt;/code&gt; es una cadena, entonces su valor se usa para reemplazo. El car&amp;aacute;cter &lt;code&gt;%&lt;/code&gt; funciona como un car&amp;aacute;cter de escape: cualquier secuencia en &lt;code&gt;repl&lt;/code&gt; de la forma &lt;code&gt;%&lt;em&gt;d&lt;/em&gt;&lt;/code&gt; , con &lt;em&gt;d&lt;/em&gt; entre 1 y 9, representa el valor de la subcadena &lt;em&gt;d&lt;/em&gt; -&amp;eacute;sima capturada. La secuencia &lt;code&gt;%0&lt;/code&gt; representa la coincidencia completa. La secuencia &lt;code&gt;%%&lt;/code&gt; representa un solo &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff6ab223165de6902e09a1476a0be29b9ea3f5ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a string, then its value is used for replacement. The character &lt;code&gt;%&lt;/code&gt; works as an escape character: any sequence in &lt;code&gt;repl&lt;/code&gt; of the form &lt;code&gt;%&lt;em&gt;d&lt;/em&gt;&lt;/code&gt;, with &lt;em&gt;d&lt;/em&gt; between 1 and 9, stands for the value of the &lt;em&gt;d&lt;/em&gt;-th captured substring; the sequence &lt;code&gt;%0&lt;/code&gt; stands for the whole match; the sequence &lt;code&gt;%%&lt;/code&gt; stands for a single &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b705ba3b278873bc97aa05e3303e0da7b4c996" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a table, then the table is queried for every match, using the first capture as the key.</source>
          <target state="translated">Si &lt;code&gt;repl&lt;/code&gt; es una tabla, entonces se consulta la tabla para cada coincidencia, utilizando la primera captura como clave.</target>
        </trans-unit>
        <trans-unit id="904a3adc32b5b8e5036d0de4893c822c32415c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, pushes &lt;b&gt;nil&lt;/b&gt; and returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es &lt;code&gt;NULL&lt;/code&gt; , empuja &lt;b&gt;nil&lt;/b&gt; y devuelve &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0fc40539b156bda0a027e224a170becb69976c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;strip&lt;/code&gt; is true, the binary representation may not include all debug information about the function, to save space.</source>
          <target state="translated">Si &lt;code&gt;strip&lt;/code&gt; es verdadero, es posible que la representaci&amp;oacute;n binaria no incluya toda la informaci&amp;oacute;n de depuraci&amp;oacute;n sobre la funci&amp;oacute;n, para ahorrar espacio.</target>
        </trans-unit>
        <trans-unit id="6d87b247b5a3a2f34515ba0454eae0564f8d8461" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; has a metamethod &lt;code&gt;__pairs&lt;/code&gt;, calls it with &lt;code&gt;t&lt;/code&gt; as argument and returns the first three results from the call.</source>
          <target state="translated">Si &lt;code&gt;t&lt;/code&gt; tiene un metam&amp;eacute;todo &lt;code&gt;__pairs&lt;/code&gt; , lo llama con &lt;code&gt;t&lt;/code&gt; como argumento y devuelve los primeros tres resultados de la llamada.</target>
        </trans-unit>
        <trans-unit id="6a36ae900eb1d0b16388ad9e7be56d13d79c7b23" translate="yes" xml:space="preserve">
          <source>If a call does not respect some restriction, it returns a false value. Otherwise, the call returns the old limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5e3c24123e04d1065dc068ae3601efba71ee43" translate="yes" xml:space="preserve">
          <source>If a coroutine yields and is never resumed again, some variables may never go out of scope, and therefore they will never be closed. (These variables are the ones created inside the coroutine and in scope at the point where the coroutine yielded.) Similarly, if a coroutine ends with an error, it does not unwind its stack, so it does not close any variable. In both cases, you can either use finalizers or call &lt;a href=&quot;#pdf-coroutine.close&quot;&gt;&lt;code&gt;coroutine.close&lt;/code&gt;&lt;/a&gt; to close the variables. However, if the coroutine was created through &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt;, then its corresponding function will close the coroutine in case of errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2adbca5a2a771576b0ebf6701fe853d554fc4c" translate="yes" xml:space="preserve">
          <source>If a weak table is among the resurrected objects in a collection cycle, it may not be properly cleared until the next cycle.</source>
          <target state="translated">Si una mesa débil se encuentra entre los objetos resucitados en un ciclo de recolección,puede que no se despeje adecuadamente hasta el siguiente ciclo.</target>
        </trans-unit>
        <trans-unit id="976c050d10a007d84f504f71e351c1274cb11c09" translate="yes" xml:space="preserve">
          <source>If an error happens outside any protected environment, Lua calls a &lt;em&gt;panic function&lt;/em&gt; (see &lt;a href=&quot;#lua_atpanic&quot;&gt;&lt;code&gt;lua_atpanic&lt;/code&gt;&lt;/a&gt;) and then calls &lt;code&gt;abort&lt;/code&gt;, thus exiting the host application. Your panic function can avoid this exit by never returning (e.g., doing a long jump to your own recovery point outside Lua).</source>
          <target state="translated">Si ocurre un error fuera de cualquier entorno protegido, Lua llama a una &lt;em&gt;funci&amp;oacute;n de p&amp;aacute;nico&lt;/em&gt; (ver &lt;a href=&quot;#lua_atpanic&quot;&gt; &lt;code&gt;lua_atpanic&lt;/code&gt; &lt;/a&gt; ) y luego llama a &lt;code&gt;abort&lt;/code&gt; ar , saliendo as&amp;iacute; de la aplicaci&amp;oacute;n host. Su funci&amp;oacute;n de p&amp;aacute;nico puede evitar esta salida sin volver nunca (por ejemplo, haciendo un salto de longitud a su propio punto de recuperaci&amp;oacute;n fuera de Lua).</target>
        </trans-unit>
        <trans-unit id="e107b713ef11ceff440f1d9e5663846987c63f66" translate="yes" xml:space="preserve">
          <source>If both the initial value and the step are integers, the loop is done with integers; note that the limit may not be an integer. Otherwise, the three values are converted to floats and the loop is done with floats. Beware of floating-point accuracy in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7b831a74ddf1c4c96bf3f5226d336731f2c355" translate="yes" xml:space="preserve">
          <source>If present, an initial assignment has the same semantics of a multiple assignment (see &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;). Otherwise, all variables are initialized with &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Si est&amp;aacute; presente, una asignaci&amp;oacute;n inicial tiene la misma sem&amp;aacute;ntica que una asignaci&amp;oacute;n m&amp;uacute;ltiple (v&amp;eacute;ase &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt; ). De lo contrario, todas las variables se inicializan con &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="55db45ca89124ba7a270035150611f949eb9d322" translate="yes" xml:space="preserve">
          <source>If several to-be-closed variables go out of scope at the same event, they are closed in the reverse order that they were declared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10ce6dce1cf5ed21ab267244f3f1b4e5f1c53a0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;time&lt;/code&gt; argument is present, this is the time to be formatted (see the &lt;a href=&quot;#pdf-os.time&quot;&gt;&lt;code&gt;os.time&lt;/code&gt;&lt;/a&gt; function for a description of this value). Otherwise, &lt;code&gt;date&lt;/code&gt; formats the current time.</source>
          <target state="translated">Si el argumento de &lt;code&gt;time&lt;/code&gt; est&amp;aacute; presente, este es el tiempo que debe formatearse (consulte la funci&amp;oacute;n &lt;a href=&quot;#pdf-os.time&quot;&gt; &lt;code&gt;os.time&lt;/code&gt; &lt;/a&gt; para obtener una descripci&amp;oacute;n de este valor). De lo contrario, la &lt;code&gt;date&lt;/code&gt; formatea la hora actual.</target>
        </trans-unit>
        <trans-unit id="445b1cd7605edb6c9a09a49501ea3688f7a25284" translate="yes" xml:space="preserve">
          <source>If the coroutine runs without any errors, &lt;code&gt;resume&lt;/code&gt; returns &lt;b&gt;true&lt;/b&gt; plus any values passed to &lt;code&gt;yield&lt;/code&gt; (when the coroutine yields) or any values returned by the body function (when the coroutine terminates). If there is any error, &lt;code&gt;resume&lt;/code&gt; returns &lt;b&gt;false&lt;/b&gt; plus the error message.</source>
          <target state="translated">Si la corrutina se ejecuta sin errores, &lt;code&gt;resume&lt;/code&gt; devuelve &lt;b&gt;verdadero&lt;/b&gt; m&amp;aacute;s los valores pasados ​​a &lt;code&gt;yield&lt;/code&gt; (cuando la corrutina cede) o cualquier valor devuelto por la funci&amp;oacute;n del cuerpo (cuando la corrutina termina). Si hay alg&amp;uacute;n error, &lt;code&gt;resume&lt;/code&gt; devuelve &lt;b&gt;falso&lt;/b&gt; m&amp;aacute;s el mensaje de error.</target>
        </trans-unit>
        <trans-unit id="7b6f2b834df4a30b4ac80f0070150d4a65977018" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is a number, returns this number as a &lt;code&gt;lua_Number&lt;/code&gt;. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55f1311c7ac9c86cbdbbe5af34159b56481c975" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is a number, returns this number. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">Si el argumento de la funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; es un n&amp;uacute;mero, devuelve este n&amp;uacute;mero. Si este argumento est&amp;aacute; ausente o es &lt;b&gt;nulo&lt;/b&gt; , devuelve &lt;code&gt;d&lt;/code&gt; . De lo contrario, genera un error.</target>
        </trans-unit>
        <trans-unit id="1d6a415374d2508756a64e53d2de95963256a6b5" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is a string, returns this string. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">Si el argumento de la funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; es una cadena, devuelve esta cadena. Si este argumento est&amp;aacute; ausente o es &lt;b&gt;nulo&lt;/b&gt; , devuelve &lt;code&gt;d&lt;/code&gt; . De lo contrario, genera un error.</target>
        </trans-unit>
        <trans-unit id="6e17c7a9a9f53d843ebe48aadc33c874ae824510" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is an integer (or convertible to an integer), returns this integer. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">Si el argumento de la funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; es un n&amp;uacute;mero entero (o convertible en un n&amp;uacute;mero entero), devuelve este n&amp;uacute;mero entero. Si este argumento est&amp;aacute; ausente o es &lt;b&gt;nulo&lt;/b&gt; , devuelve &lt;code&gt;d&lt;/code&gt; . De lo contrario, genera un error.</target>
        </trans-unit>
        <trans-unit id="6955dc842a401e17e5808166f841d89d4b08032c" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is an integer (or it is convertible to an integer), returns this integer. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e13f8872ac6f0a738c6612fcccd3954091bb67" translate="yes" xml:space="preserve">
          <source>If the global variable &lt;a id=&quot;pdf-_PROMPT&quot;&gt;&lt;code&gt;_PROMPT&lt;/code&gt;&lt;/a&gt; contains a string, then its value is used as the prompt. Similarly, if the global variable &lt;a id=&quot;pdf-_PROMPT2&quot;&gt;&lt;code&gt;_PROMPT2&lt;/code&gt;&lt;/a&gt; contains a string, its value is used as the secondary prompt (issued during incomplete statements).</source>
          <target state="translated">Si la variable global &lt;a id=&quot;pdf-_PROMPT&quot;&gt; &lt;code&gt;_PROMPT&lt;/code&gt; &lt;/a&gt; contiene una cadena, su valor se utiliza como indicador. De manera similar, si la variable global &lt;a id=&quot;pdf-_PROMPT2&quot;&gt; &lt;code&gt;_PROMPT2&lt;/code&gt; &lt;/a&gt; contiene una cadena, su valor se utiliza como indicador secundario (emitido durante declaraciones incompletas).</target>
        </trans-unit>
        <trans-unit id="69dd50d5154f10c839f6adf50538404208ab3819" translate="yes" xml:space="preserve">
          <source>If the last field in the list has the form &lt;code&gt;exp&lt;/code&gt; and the expression is a function call or a vararg expression, then all values returned by this expression enter the list consecutively (see &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;).</source>
          <target state="translated">Si el &amp;uacute;ltimo campo de la lista tiene la forma &lt;code&gt;exp&lt;/code&gt; y la expresi&amp;oacute;n es una llamada de funci&amp;oacute;n o una expresi&amp;oacute;n vararg, entonces todos los valores devueltos por esta expresi&amp;oacute;n ingresan a la lista consecutivamente (ver &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c2c41a18b7f1f35462130fbee68e6deb46c899ae" translate="yes" xml:space="preserve">
          <source>If the metatable of &lt;code&gt;v&lt;/code&gt; has a &lt;code&gt;__tostring&lt;/code&gt; field, then &lt;code&gt;tostring&lt;/code&gt; calls the corresponding value with &lt;code&gt;v&lt;/code&gt; as argument, and uses the result of the call as its result.</source>
          <target state="translated">Si la metatabla de &lt;code&gt;v&lt;/code&gt; tiene un campo &lt;code&gt;__tostring&lt;/code&gt; , entonces &lt;code&gt;tostring&lt;/code&gt; llama al valor correspondiente con &lt;code&gt;v&lt;/code&gt; como argumento y usa el resultado de la llamada como resultado.</target>
        </trans-unit>
        <trans-unit id="e667a50bd3d336c5fd3f6afdae1b6efc47c42fa7" translate="yes" xml:space="preserve">
          <source>If the metatable of &lt;code&gt;v&lt;/code&gt; has a &lt;code&gt;__tostring&lt;/code&gt; field, then &lt;code&gt;tostring&lt;/code&gt; calls the corresponding value with &lt;code&gt;v&lt;/code&gt; as argument, and uses the result of the call as its result. Otherwise, if the metatable of &lt;code&gt;v&lt;/code&gt; has a &lt;code&gt;__name&lt;/code&gt; field with a string value, &lt;code&gt;tostring&lt;/code&gt; may use that string in its final result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e2a2337d10f7a7f932c47ab9c9e3292e20a274" translate="yes" xml:space="preserve">
          <source>If the object at index &lt;code&gt;obj&lt;/code&gt; has a metatable and this metatable has a field &lt;code&gt;e&lt;/code&gt;, this function calls this field passing the object as its only argument. In this case this function returns true and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns false (without pushing any value on the stack).</source>
          <target state="translated">Si el objeto en el &amp;iacute;ndice &lt;code&gt;obj&lt;/code&gt; tiene una metatabla y esta metatabla tiene un campo &lt;code&gt;e&lt;/code&gt; , esta funci&amp;oacute;n llama a este campo pasando el objeto como su &amp;uacute;nico argumento. En este caso, esta funci&amp;oacute;n devuelve verdadero y coloca en la pila el valor devuelto por la llamada. Si no hay metatabla o metam&amp;eacute;todo, esta funci&amp;oacute;n devuelve falso (sin presionar ning&amp;uacute;n valor en la pila).</target>
        </trans-unit>
        <trans-unit id="4b1b45d6011ef45970bc5881245d1e395b5b10f6" translate="yes" xml:space="preserve">
          <source>If the object at index &lt;code&gt;obj&lt;/code&gt; has a metatable and this metatable has a field &lt;code&gt;e&lt;/code&gt;, this function calls this field passing the object as its only argument. In this case this function returns true and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns false without pushing any value on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5290383f51a42a73a3f52ae1f2cee8c56a74c3fd" translate="yes" xml:space="preserve">
          <source>If the object at the top of the stack is &lt;b&gt;nil&lt;/b&gt;, &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt; returns the constant &lt;a id=&quot;pdf-LUA_REFNIL&quot;&gt;&lt;code&gt;LUA_REFNIL&lt;/code&gt;&lt;/a&gt;. The constant &lt;a id=&quot;pdf-LUA_NOREF&quot;&gt;&lt;code&gt;LUA_NOREF&lt;/code&gt;&lt;/a&gt; is guaranteed to be different from any reference returned by &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si el objeto en la parte superior de la pila es &lt;b&gt;nulo&lt;/b&gt; , &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; devuelve la constante &lt;a id=&quot;pdf-LUA_REFNIL&quot;&gt; &lt;code&gt;LUA_REFNIL&lt;/code&gt; &lt;/a&gt; . Se garantiza que la constante &lt;a id=&quot;pdf-LUA_NOREF&quot;&gt; &lt;code&gt;LUA_NOREF&lt;/code&gt; &lt;/a&gt; ser&amp;aacute; diferente de cualquier referencia devuelta por &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad1fb87f39a8d1517edf25e3706b1bb571e2c0af" translate="yes" xml:space="preserve">
          <source>If the object on the top of the stack is &lt;b&gt;nil&lt;/b&gt;, &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt; returns the constant &lt;a id=&quot;pdf-LUA_REFNIL&quot;&gt;&lt;code&gt;LUA_REFNIL&lt;/code&gt;&lt;/a&gt;. The constant &lt;a id=&quot;pdf-LUA_NOREF&quot;&gt;&lt;code&gt;LUA_NOREF&lt;/code&gt;&lt;/a&gt; is guaranteed to be different from any reference returned by &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acec67c576442c0c5a9f70f70aebd00845c9de45" translate="yes" xml:space="preserve">
          <source>If the optional second argument &lt;code&gt;close&lt;/code&gt; is true, closes the Lua state before exiting.</source>
          <target state="translated">Si el segundo argumento opcional &lt;code&gt;close&lt;/code&gt; es verdadero, cierra el estado Lua antes de salir.</target>
        </trans-unit>
        <trans-unit id="3b0396e6bb027f8d7ab0995f60b457d88ddf9d43" translate="yes" xml:space="preserve">
          <source>If the pattern has captures, then in a successful match the captured values are also returned, after the two indices.</source>
          <target state="translated">Si el patrón tiene capturas,entonces en una coincidencia exitosa los valores capturados también se devuelven,después de los dos índices.</target>
        </trans-unit>
        <trans-unit id="c6c1efa56f5f1f5e27073806e14cba57116db8fa" translate="yes" xml:space="preserve">
          <source>If the registry already has the key &lt;code&gt;tname&lt;/code&gt;, returns 0. Otherwise, creates a new table to be used as a metatable for userdata, adds to this new table the pair &lt;code&gt;__name = tname&lt;/code&gt;, adds to the registry the pair &lt;code&gt;[tname] = new table&lt;/code&gt;, and returns 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55dfb22871228c3e2bce9a6e070cde79a0f26198" translate="yes" xml:space="preserve">
          <source>If the registry already has the key &lt;code&gt;tname&lt;/code&gt;, returns 0. Otherwise, creates a new table to be used as a metatable for userdata, adds to this new table the pair &lt;code&gt;__name = tname&lt;/code&gt;, adds to the registry the pair &lt;code&gt;[tname] = new table&lt;/code&gt;, and returns 1. (The entry &lt;code&gt;__name&lt;/code&gt; is used by some error-reporting functions.)</source>
          <target state="translated">Si el registro ya tiene la clave &lt;code&gt;tname&lt;/code&gt; , devuelve 0. De lo contrario, crea una nueva tabla para usar como metatabla para los datos de usuario, agrega a esta nueva tabla el par &lt;code&gt;__name = tname&lt;/code&gt; , agrega al registro el par &lt;code&gt;[tname] = new table&lt;/code&gt; , y devuelve 1. ( &lt;code&gt;__name&lt;/code&gt; funciones de informe de errores utilizan la entrada __name ).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
