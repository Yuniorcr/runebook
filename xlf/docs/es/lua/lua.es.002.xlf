<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="lua">
    <body>
      <group id="lua">
        <trans-unit id="aa39944ec03b1ec2d3455e9418607f7822bf72a3" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, its first upvalue is set to the value of the global environment stored at index &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; in the registry (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;). When loading main chunks, this upvalue will be the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afde979ca5fc178b1fdd97cd1a0eb2a3d73cbc9c" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, its first upvalue is set to the value of the global environment stored at index &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; in the registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). When loading main chunks, this upvalue will be the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Si la funci&amp;oacute;n resultante tiene upvalues, su primer upvalue se establece en el valor del entorno global almacenado en el &amp;iacute;ndice &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; en el registro (ver &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; ). Al cargar fragmentos principales, este valor ascendente ser&amp;aacute; la variable &lt;code&gt;_ENV&lt;/code&gt; (consulte &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ). Otros upvalues ​​se inicializan con &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="275e9e5485299a94935ea18cd6064e91a7392a15" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, the first upvalue is set to the value of &lt;code&gt;env&lt;/code&gt;, if that parameter is given, or to the value of the global environment. Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;. (When you load a main chunk, the resulting function will always have exactly one upvalue, the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). However, when you load a binary chunk created from a function (see &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt;), the resulting function can have an arbitrary number of upvalues.) All upvalues are fresh, that is, they are not shared with any other function.</source>
          <target state="translated">Si la funci&amp;oacute;n resultante tiene upvalues, el primer upvalue se establece en el valor de &lt;code&gt;env&lt;/code&gt; , si se proporciona ese par&amp;aacute;metro, o en el valor del entorno global. Otros upvalues ​​se inicializan con &lt;b&gt;nil&lt;/b&gt; . (Cuando carga un fragmento principal, la funci&amp;oacute;n resultante siempre tendr&amp;aacute; exactamente un upvalue, la variable &lt;code&gt;_ENV&lt;/code&gt; (consulte &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ). Sin embargo, cuando carga un fragmento binario creado a partir de una funci&amp;oacute;n (consulte &lt;a href=&quot;#pdf-string.dump&quot;&gt; &lt;code&gt;string.dump&lt;/code&gt; &lt;/a&gt; ), la funci&amp;oacute;n resultante puede tienen un n&amp;uacute;mero arbitrario de upvalues.) Todos los upvalues ​​son nuevos, es decir, no se comparten con ninguna otra funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2440107420c56013ca178ce5e9d33aaab09429e6" translate="yes" xml:space="preserve">
          <source>If the third expression (the step) is absent, then a step of 1 is used.</source>
          <target state="translated">Si la tercera expresión (el paso)está ausente,entonces se utiliza un paso de 1.</target>
        </trans-unit>
        <trans-unit id="b6867da3d50ebe1ffe1a4f6e7b8d21bdab6c2e11" translate="yes" xml:space="preserve">
          <source>If the userdata does not have that value, pushes &lt;b&gt;nil&lt;/b&gt; and returns &lt;a href=&quot;#pdf-LUA_TNONE&quot;&gt;&lt;code&gt;LUA_TNONE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30fdcf02dde9756f746a6d73d9bf8f5049261a0f" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;x&lt;/code&gt; is convertible to an integer, returns that integer. Otherwise, returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876e4bd473070df65d9eb13c67cd61272830f8dd" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;x&lt;/code&gt; is convertible to an integer, returns that integer. Otherwise, returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Si el valor &lt;code&gt;x&lt;/code&gt; es convertible a un n&amp;uacute;mero entero, devuelve ese n&amp;uacute;mero entero. De lo contrario, devuelve &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="94b7f8b2fd53356736681842c541a85531d3f0c6" translate="yes" xml:space="preserve">
          <source>If the value at the given index has a metatable, the function pushes that metatable onto the stack and returns 1. Otherwise, the function returns 0 and pushes nothing on the stack.</source>
          <target state="translated">Si el valor en el índice dado tiene una metatabla,la función empuja esa metatabla a la pila y devuelve 1.En caso contrario,la función devuelve 0 y no empuja nada en la pila.</target>
        </trans-unit>
        <trans-unit id="9441049c218d493b700b38a8bccd81b0ab58775b" translate="yes" xml:space="preserve">
          <source>If the value at the given index is a full userdata, returns its block address. If the value is a light userdata, returns its pointer. Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Si el valor en el &amp;iacute;ndice dado es un usuario completo, devuelve su direcci&amp;oacute;n de bloque. Si el valor es un usuario ligero, devuelve su puntero. De lo contrario, devuelve &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5badf0b625046b21174cf23ead77965326f8cc" translate="yes" xml:space="preserve">
          <source>If the value at the given index is a full userdata, returns its memory-block address. If the value is a light userdata, returns its value (a pointer). Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4632120bcb257e680797b7d6b495d6ae5165f498" translate="yes" xml:space="preserve">
          <source>If the value has a metatable with a &lt;code&gt;__tostring&lt;/code&gt; field, then &lt;code&gt;luaL_tolstring&lt;/code&gt; calls the corresponding metamethod with the value as argument, and uses the result of the call as its result.</source>
          <target state="translated">Si el valor tiene una metatabla con un campo &lt;code&gt;__tostring&lt;/code&gt; , entonces &lt;code&gt;luaL_tolstring&lt;/code&gt; llama al metam&amp;eacute;todo correspondiente con el valor como argumento y usa el resultado de la llamada como resultado.</target>
        </trans-unit>
        <trans-unit id="d98fc2205300b7d347d732dbb4a9c377f9f7a2f3" translate="yes" xml:space="preserve">
          <source>If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;nil&lt;/b&gt;, then there is no replacement (that is, the original match is kept in the string).</source>
          <target state="translated">Si el valor devuelto por la consulta de la tabla o por la llamada a la funci&amp;oacute;n es una cadena o un n&amp;uacute;mero, entonces se usa como cadena de reemplazo; de lo contrario, si es &lt;b&gt;falso&lt;/b&gt; o &lt;b&gt;nulo&lt;/b&gt; , entonces no hay reemplazo (es decir, la coincidencia original se mantiene en la cadena).</target>
        </trans-unit>
        <trans-unit id="ff3df837749e4825f721110ceca71ee53b60c2f6" translate="yes" xml:space="preserve">
          <source>If there are no syntactic errors, &lt;code&gt;load&lt;/code&gt; returns the compiled chunk as a function; otherwise, it returns &lt;b&gt;fail&lt;/b&gt; plus the error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5b55c4ebb32433c98e6d7ba29a004a9265213b" translate="yes" xml:space="preserve">
          <source>If there are no syntactic errors, returns the compiled chunk as a function; otherwise, returns &lt;b&gt;nil&lt;/b&gt; plus the error message.</source>
          <target state="translated">Si no hay errores sint&amp;aacute;cticos, devuelve el fragmento compilado como funci&amp;oacute;n; de lo contrario, devuelve &lt;b&gt;nil&lt;/b&gt; m&amp;aacute;s el mensaje de error.</target>
        </trans-unit>
        <trans-unit id="94d76ea95ae9d04310650a4926fa6e03a91eead5" translate="yes" xml:space="preserve">
          <source>If there is any error loading or running the module, or if it cannot find any loader for the module, then &lt;code&gt;require&lt;/code&gt; raises an error.</source>
          <target state="translated">Si hay alg&amp;uacute;n error al cargar o ejecutar el m&amp;oacute;dulo, o si no puede encontrar ning&amp;uacute;n cargador para el m&amp;oacute;dulo, &lt;code&gt;require&lt;/code&gt; genera un error.</target>
        </trans-unit>
        <trans-unit id="ce92cea2e328d0390d4ad8b2857051594fc6df6d" translate="yes" xml:space="preserve">
          <source>If there is any error while running a closing method, that error is handled like an error in the regular code where the variable was defined. However, Lua may call the method one more time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6dbd64b84e48ca7300b890ff312675543ee0f6" translate="yes" xml:space="preserve">
          <source>If there is no script in the call, the interpreter name goes to index 0, followed by the other arguments. For instance, the call</source>
          <target state="translated">Si no hay guión en la llamada,el nombre del intérprete va al índice 0,seguido de los otros argumentos.Por ejemplo,la llamada</target>
        </trans-unit>
        <trans-unit id="2f77907008466a9df684a2c79024f9604e714a0c" translate="yes" xml:space="preserve">
          <source>If this option is given together with option '&lt;code&gt;f&lt;/code&gt;', its table is pushed after the function.</source>
          <target state="translated">Si esta opci&amp;oacute;n se da junto con la opci&amp;oacute;n ' &lt;code&gt;f&lt;/code&gt; ', su tabla se inserta despu&amp;eacute;s de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="232d4cb58dd3dc6d647132e58f5ddab6d89f9ef6" translate="yes" xml:space="preserve">
          <source>If you know beforehand the maximum size of the resulting string, you can use the buffer like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda48319758ff6bba8bcf8cb507f6d311265837c" translate="yes" xml:space="preserve">
          <source>If you know beforehand the total size of the resulting string, you can use the buffer like this:</source>
          <target state="translated">Si conoces de antemano el tamaño total de la cadena resultante,puedes usar el buffer así:</target>
        </trans-unit>
        <trans-unit id="0e57af394dbc6d5a626668daa30c3f8e2018059e" translate="yes" xml:space="preserve">
          <source>If you set the step multiplier to a very large number (larger than 10% of the maximum number of bytes that the program may use), the collector behaves like a stop-the-world collector. If you then set the pause to 200, the collector behaves as in old Lua versions, doing a complete collection every time Lua doubles its memory usage.</source>
          <target state="translated">Si se establece el multiplicador de pasos en un número muy grande (mayor del 10% del número máximo de bytes que el programa puede utilizar),el colector se comporta como un colector de parada del mundo.Si entonces fijas la pausa en 200,el coleccionista se comporta como en las antiguas versiones de Lua,haciendo una colección completa cada vez que Lua dobla su uso de memoria.</target>
        </trans-unit>
        <trans-unit id="29af696fcc1cdd39d14ec551ccbd633c6f06b895" translate="yes" xml:space="preserve">
          <source>If, after the translation of negative indices, &lt;code&gt;i&lt;/code&gt; is less than 1, it is corrected to 1. If &lt;code&gt;j&lt;/code&gt; is greater than the string length, it is corrected to that length. If, after these corrections, &lt;code&gt;i&lt;/code&gt; is greater than &lt;code&gt;j&lt;/code&gt;, the function returns the empty string.</source>
          <target state="translated">Si, despu&amp;eacute;s de la traducci&amp;oacute;n de &amp;iacute;ndices negativos, &lt;code&gt;i&lt;/code&gt; es menor que 1, se corrige a 1. Si &lt;code&gt;j&lt;/code&gt; es mayor que la longitud de la cadena, se corrige a esa longitud. Si, despu&amp;eacute;s de estas correcciones, &lt;code&gt;i&lt;/code&gt; es mayor que &lt;code&gt;j&lt;/code&gt; , la funci&amp;oacute;n devuelve la cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="a9f42e3411c1cd363cce85bb39824046e38afc0c" translate="yes" xml:space="preserve">
          <source>In POSIX systems, this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e188c4467182589f4f24a348f7b82d5dc4eb843" translate="yes" xml:space="preserve">
          <source>In a conversion from integer to float, if the integer value has an exact representation as a float, that is the result. Otherwise, the conversion gets the nearest higher or the nearest lower representable value. This kind of conversion never fails.</source>
          <target state="translated">En una conversión de entero a flotante,si el valor entero tiene una representación exacta como flotante,ese es el resultado.De lo contrario,la conversión obtiene el valor representable más alto o más bajo más cercano.Este tipo de conversión nunca falla.</target>
        </trans-unit>
        <trans-unit id="ea37a32b7be8a539051904217ddd263915df9e9c" translate="yes" xml:space="preserve">
          <source>In a function call, first prefixexp and args are evaluated. If the value of prefixexp has type &lt;em&gt;function&lt;/em&gt;, then this function is called with the given arguments. Otherwise, if present, the prefixexp &lt;code&gt;__call&lt;/code&gt; metamethod is called: its first argument is the value of prefixexp, followed by the original call arguments (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b9aa4de4630491dcb4d24142294547e0b16cc1" translate="yes" xml:space="preserve">
          <source>In a function call, first prefixexp and args are evaluated. If the value of prefixexp has type &lt;em&gt;function&lt;/em&gt;, then this function is called with the given arguments. Otherwise, the prefixexp &quot;call&quot; metamethod is called, having as first parameter the value of prefixexp, followed by the original call arguments (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">En una llamada a funci&amp;oacute;n, se eval&amp;uacute;an el primer prefijoexp y los argumentos. Si el valor de prefixexp tiene una &lt;em&gt;funci&amp;oacute;n de&lt;/em&gt; tipo , esta funci&amp;oacute;n se llama con los argumentos dados. De lo contrario, se llama al metam&amp;eacute;todo prefixexp &quot;call&quot;, que tiene como primer par&amp;aacute;metro el valor de prefixexp, seguido de los argumentos de la llamada original (ver &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="49949926795e2c68295a80e05d4c59850e0ba7a4" translate="yes" xml:space="preserve">
          <source>In addition to the previous list, the interpreter also respects the following keys in metatables: &lt;code&gt;__gc&lt;/code&gt; (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;), &lt;code&gt;__close&lt;/code&gt; (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;), &lt;code&gt;__mode&lt;/code&gt; (see &lt;a href=&quot;#2.5.4&quot;&gt;&amp;sect;2.5.4&lt;/a&gt;), and &lt;code&gt;__name&lt;/code&gt;. (The entry &lt;code&gt;__name&lt;/code&gt;, when it contains a string, may be used by &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt; and in error messages.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62eebdc1879c0b1be4e46a0d6b0e9bcf316566f7" translate="yes" xml:space="preserve">
          <source>In any case, if the pattern specifies no captures, then it behaves as if the whole pattern was inside a capture.</source>
          <target state="translated">En cualquier caso,si el patrón no especifica ninguna captura,entonces se comporta como si todo el patrón estuviera dentro de una captura.</target>
        </trans-unit>
        <trans-unit id="2bb9e40f7423d9d013509578590213e990081254" translate="yes" xml:space="preserve">
          <source>In both cases pushes onto the stack the final value associated with &lt;code&gt;tname&lt;/code&gt; in the registry.</source>
          <target state="translated">En ambos casos, &lt;code&gt;tname&lt;/code&gt; en la pila el valor final asociado con tname en el registro.</target>
        </trans-unit>
        <trans-unit id="2fdfe218bfd306e46380cb987820b12f4c22a7cd" translate="yes" xml:space="preserve">
          <source>In both cases, the function pushes onto the stack the final value associated with &lt;code&gt;tname&lt;/code&gt; in the registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745fa42e653c44e85ff99efe0906a4b1ecb00bd0" translate="yes" xml:space="preserve">
          <source>In case of errors opening the file, this function raises the error, instead of returning an error code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="529481951babb324dab477372f5c6d52890e6006" translate="yes" xml:space="preserve">
          <source>In case of errors this function raises the error, instead of returning an error code.</source>
          <target state="translated">En caso de errores,esta función aumenta el error,en lugar de devolver un código de error.</target>
        </trans-unit>
        <trans-unit id="f30334a63968b6ddb7bb2b4604dd500f34422267" translate="yes" xml:space="preserve">
          <source>In case of errors, the stack is not unwound, so you can use the debug API over it. The error object is on the top of the stack.</source>
          <target state="translated">En caso de errores,la pila no se desenrolla,por lo que puedes usar la API de depuración sobre ella.El objeto del error está en la parte superior de la pila.</target>
        </trans-unit>
        <trans-unit id="467db70feecc1c4f6d135a7d76a384db5dda44c8" translate="yes" xml:space="preserve">
          <source>In case of overflows in integer arithmetic, all operations &lt;em&gt;wrap around&lt;/em&gt;, according to the usual rules of two-complement arithmetic. (In other words, they return the unique representable integer that is equal modulo &lt;em&gt;2&lt;sup&gt;64&lt;/sup&gt;&lt;/em&gt; to the mathematical result.)</source>
          <target state="translated">En caso de desbordamientos en aritm&amp;eacute;tica de enteros, todas las operaciones se &lt;em&gt;envuelven&lt;/em&gt; , de acuerdo con las reglas habituales de la aritm&amp;eacute;tica de dos complementos. (En otras palabras, devuelven el n&amp;uacute;mero entero representable &amp;uacute;nico que es igual m&amp;oacute;dulo &lt;em&gt;2 &lt;sup&gt;64&lt;/sup&gt;&lt;/em&gt; al resultado matem&amp;aacute;tico).</target>
        </trans-unit>
        <trans-unit id="e042bc5ef9c39f04e2c4f57f3960a9657ca9b2b3" translate="yes" xml:space="preserve">
          <source>In case of overflows in integer arithmetic, all operations &lt;em&gt;wrap around&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4404e49caab8b46532d3c1ccdfde90bff4f9337a" translate="yes" xml:space="preserve">
          <source>In case of success, &lt;code&gt;seek&lt;/code&gt; returns the final file position, measured in bytes from the beginning of the file. If &lt;code&gt;seek&lt;/code&gt; fails, it returns &lt;b&gt;fail&lt;/b&gt;, plus a string describing the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2e9f70152b7436cb1235e5607b1026adf8b4df" translate="yes" xml:space="preserve">
          <source>In case of success, &lt;code&gt;seek&lt;/code&gt; returns the final file position, measured in bytes from the beginning of the file. If &lt;code&gt;seek&lt;/code&gt; fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error.</source>
          <target state="translated">En caso de &amp;eacute;xito, &lt;code&gt;seek&lt;/code&gt; devuelve la posici&amp;oacute;n final del archivo, medida en bytes desde el principio del archivo. Si la &lt;code&gt;seek&lt;/code&gt; falla, devuelve &lt;b&gt;nil&lt;/b&gt; , m&amp;aacute;s una cadena que describe el error.</target>
        </trans-unit>
        <trans-unit id="8ce8027efe413a45818ec783d9d3bd6228742c83" translate="yes" xml:space="preserve">
          <source>In case of success, returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends.</source>
          <target state="translated">En caso de éxito,devuelve un mango para un archivo temporal.Este archivo se abre en el modo de actualización y se elimina automáticamente cuando el programa termina.</target>
        </trans-unit>
        <trans-unit id="6be35cfe80694e8f2a500c5ffa60712ba072cc6f" translate="yes" xml:space="preserve">
          <source>In case of success, this function returns &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a86eee5d971d25767843d4dbdef34e84774cef" translate="yes" xml:space="preserve">
          <source>In case of success, this function returns &lt;code&gt;file&lt;/code&gt;. Otherwise it returns &lt;b&gt;nil&lt;/b&gt; plus a string describing the error.</source>
          <target state="translated">En caso de &amp;eacute;xito, esta funci&amp;oacute;n devuelve &lt;code&gt;file&lt;/code&gt; . De lo contrario, devuelve &lt;b&gt;nil&lt;/b&gt; m&amp;aacute;s una cadena que describe el error.</target>
        </trans-unit>
        <trans-unit id="8c632a9fad5564d87f459215e17e926cda31f0ee" translate="yes" xml:space="preserve">
          <source>In case of unprotected errors in the script, the interpreter reports the error to the standard error stream. If the error object is not a string but has a metamethod &lt;code&gt;__tostring&lt;/code&gt;, the interpreter calls this metamethod to produce the final message. Otherwise, the interpreter converts the error object to a string and adds a stack traceback to it.</source>
          <target state="translated">En caso de errores no protegidos en la secuencia de comandos, el int&amp;eacute;rprete informa del error al flujo de errores est&amp;aacute;ndar. Si el objeto de error no es una cadena pero tiene un metam&amp;eacute;todo &lt;code&gt;__tostring&lt;/code&gt; , el int&amp;eacute;rprete llama a este metam&amp;eacute;todo para producir el mensaje final. De lo contrario, el int&amp;eacute;rprete convierte el objeto de error en una cadena y le agrega un seguimiento de pila.</target>
        </trans-unit>
        <trans-unit id="bea04697f039ec14dc1ee8265502eaa4d56df50c" translate="yes" xml:space="preserve">
          <source>In case of unprotected errors in the script, the interpreter reports the error to the standard error stream. If the error object is not a string but has a metamethod &lt;code&gt;__tostring&lt;/code&gt;, the interpreter calls this metamethod to produce the final message. Otherwise, the interpreter converts the error object to a string and adds a stack traceback to it. When warnings are on, they are simply printed in the standard error output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f47d88fa41a69cbb5505a94710be0b6ddd4668" translate="yes" xml:space="preserve">
          <source>In general, Lua's garbage collection can free or move internal memory and then invalidate pointers to internal strings. To allow a safe use of these pointers, The API guarantees that any pointer to a string in a stack index is valid while the value at that index is neither modified nor popped. When the index is a pseudo-index (referring to an upvalue), the pointer is valid while the corresponding call is active and the corresponding upvalue is not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea95e591f583f4a7ef86223f97f4160fc20ef3bf" translate="yes" xml:space="preserve">
          <source>In generational mode, the collector does frequent &lt;em&gt;minor&lt;/em&gt; collections, which traverses only objects recently created. If after a minor collection the use of memory is still above a limit, the collector does a stop-the-world &lt;em&gt;major&lt;/em&gt; collection, which traverses all objects. The generational mode uses two parameters: the &lt;em&gt;minor multiplier&lt;/em&gt; and the &lt;em&gt;the major multiplier&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd00f2668545ca027b5cc5fd8421e849fff38797" translate="yes" xml:space="preserve">
          <source>In incremental mode, each GC cycle performs a mark-and-sweep collection in small steps interleaved with the program's execution. In this mode, the collector uses three numbers to control its garbage-collection cycles: the &lt;em&gt;garbage-collector pause&lt;/em&gt;, the &lt;em&gt;garbage-collector step multiplier&lt;/em&gt;, and the &lt;em&gt;garbage-collector step size&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae459100d0f219cfd74a53f2eb34f96a6176512" translate="yes" xml:space="preserve">
          <source>In interactive mode, Lua repeatedly prompts and waits for a line. After reading a line, Lua first try to interpret the line as an expression. If it succeeds, it prints its value. Otherwise, it interprets the line as a statement. If you write an incomplete statement, the interpreter waits for its completion by issuing a different prompt.</source>
          <target state="translated">En el modo interactivo,Lua insiste y espera una línea.Después de leer una línea,Lua primero intenta interpretar la línea como una expresión.Si tiene éxito,imprime su valor.De lo contrario,interpreta la línea como una afirmación.Si escribe una declaración incompleta,el intérprete espera a que se complete emitiendo un aviso diferente.</target>
        </trans-unit>
        <trans-unit id="63d381d8ee2b95ac5052d39e95b78fbc9ea8d9fb" translate="yes" xml:space="preserve">
          <source>In order to communicate properly with Lua, a C function must use the following protocol, which defines the way parameters and results are passed: a C function receives its arguments from Lua in its stack in direct order (the first argument is pushed first). So, when the function starts, &lt;code&gt;lua_gettop(L)&lt;/code&gt; returns the number of arguments received by the function. The first argument (if any) is at index 1 and its last argument is at index &lt;code&gt;lua_gettop(L)&lt;/code&gt;. To return values to Lua, a C function just pushes them onto the stack, in direct order (the first result is pushed first), and returns in C the number of results. Any other value in the stack below the results will be properly discarded by Lua. Like a Lua function, a C function called by Lua can also return many results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b57c85f9e4681ef2b296b47dfe58462b42111a" translate="yes" xml:space="preserve">
          <source>In order to communicate properly with Lua, a C function must use the following protocol, which defines the way parameters and results are passed: a C function receives its arguments from Lua in its stack in direct order (the first argument is pushed first). So, when the function starts, &lt;code&gt;lua_gettop(L)&lt;/code&gt; returns the number of arguments received by the function. The first argument (if any) is at index 1 and its last argument is at index &lt;code&gt;lua_gettop(L)&lt;/code&gt;. To return values to Lua, a C function just pushes them onto the stack, in direct order (the first result is pushed first), and returns the number of results. Any other value in the stack below the results will be properly discarded by Lua. Like a Lua function, a C function called by Lua can also return many results.</source>
          <target state="translated">Para comunicarse correctamente con Lua, una funci&amp;oacute;n C debe usar el siguiente protocolo, que define la forma en que se pasan los par&amp;aacute;metros y los resultados: una funci&amp;oacute;n C recibe sus argumentos de Lua en su pila en orden directo (el primer argumento se inserta primero). Entonces, cuando se inicia la funci&amp;oacute;n, &lt;code&gt;lua_gettop(L)&lt;/code&gt; devuelve el n&amp;uacute;mero de argumentos recibidos por la funci&amp;oacute;n. El primer argumento (si lo hay) est&amp;aacute; en el &amp;iacute;ndice 1 y su &amp;uacute;ltimo argumento est&amp;aacute; en el &amp;iacute;ndice &lt;code&gt;lua_gettop(L)&lt;/code&gt; . Para devolver valores a Lua, una funci&amp;oacute;n C simplemente los coloca en la pila, en orden directo (el primer resultado se inserta primero) y devuelve el n&amp;uacute;mero de resultados. Cualquier otro valor en la pila debajo de los resultados ser&amp;aacute; descartado correctamente por Lua. Como una funci&amp;oacute;n Lua, una funci&amp;oacute;n C llamada por Lua tambi&amp;eacute;n puede devolver muchos resultados.</target>
        </trans-unit>
        <trans-unit id="1509d2ba42008705f892c900bc91b5bc201ddc1e" translate="yes" xml:space="preserve">
          <source>In the &lt;b&gt;repeat&lt;/b&gt;&amp;ndash;&lt;b&gt;until&lt;/b&gt; loop, the inner block does not end at the &lt;b&gt;until&lt;/b&gt; keyword, but only after the condition. So, the condition can refer to local variables declared inside the loop block.</source>
          <target state="translated">En el ciclo &lt;b&gt;repeat&lt;/b&gt; - &lt;b&gt;until&lt;/b&gt; , el bloque interno no termina en la palabra clave &lt;b&gt;hasta&lt;/b&gt; , sino solo despu&amp;eacute;s de la condici&amp;oacute;n. Entonces, la condici&amp;oacute;n puede referirse a variables locales declaradas dentro del bloque de bucle.</target>
        </trans-unit>
        <trans-unit id="82f098174293e606c23ea050f8d7e73e0153453e" translate="yes" xml:space="preserve">
          <source>In the above code, the new function &lt;code&gt;k&lt;/code&gt; is a &lt;em&gt;continuation function&lt;/em&gt; (with type &lt;a href=&quot;#lua_KFunction&quot;&gt;&lt;code&gt;lua_KFunction&lt;/code&gt;&lt;/a&gt;), which should do all the work that the original function was doing after calling &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;. Now, we must inform Lua that it must call &lt;code&gt;k&lt;/code&gt; if the Lua code being executed by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; gets interrupted in some way (errors or yielding), so we rewrite the code as here, replacing &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">En el c&amp;oacute;digo anterior, la nueva funci&amp;oacute;n &lt;code&gt;k&lt;/code&gt; es una &lt;em&gt;funci&amp;oacute;n de continuaci&amp;oacute;n&lt;/em&gt; (con tipo &lt;a href=&quot;#lua_KFunction&quot;&gt; &lt;code&gt;lua_KFunction&lt;/code&gt; &lt;/a&gt; ), que deber&amp;iacute;a hacer todo el trabajo que estaba haciendo la funci&amp;oacute;n original despu&amp;eacute;s de llamar a &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; . Ahora, debemos informar a Lua que debe llamar a &lt;code&gt;k&lt;/code&gt; si el c&amp;oacute;digo de Lua que est&amp;aacute; ejecutando &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; se interrumpe de alguna manera (errores o ceder), por lo que reescribimos el c&amp;oacute;digo como aqu&amp;iacute;, reemplazando &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; por &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1a9834b08661ce8efa680d14f8d2efb7c60bfccf" translate="yes" xml:space="preserve">
          <source>In the case of an out-of-memory error, the value in the given index is immediately closed, as if it was already marked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f49d50825ba7a2c55ba6aba66f792c4da727cd" translate="yes" xml:space="preserve">
          <source>In the first case, the parameter &lt;code&gt;ar&lt;/code&gt; must be a valid activation record that was filled by a previous call to &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; or given as argument to a hook (see &lt;a href=&quot;#lua_Hook&quot;&gt;&lt;code&gt;lua_Hook&lt;/code&gt;&lt;/a&gt;). The index &lt;code&gt;n&lt;/code&gt; selects which local variable to inspect; see &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt;&lt;code&gt;debug.getlocal&lt;/code&gt;&lt;/a&gt; for details about variable indices and names.</source>
          <target state="translated">En el primer caso, el par&amp;aacute;metro &lt;code&gt;ar&lt;/code&gt; debe ser un registro de activaci&amp;oacute;n v&amp;aacute;lido que fue llenado por una llamada anterior a &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; o dado como argumento a un gancho (ver &lt;a href=&quot;#lua_Hook&quot;&gt; &lt;code&gt;lua_Hook&lt;/code&gt; &lt;/a&gt; ). El &amp;iacute;ndice &lt;code&gt;n&lt;/code&gt; selecciona qu&amp;eacute; variable local inspeccionar; consulte &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt; &lt;code&gt;debug.getlocal&lt;/code&gt; &lt;/a&gt; para obtener detalles sobre &amp;iacute;ndices y nombres de variables.</target>
        </trans-unit>
        <trans-unit id="41a440753f8786d13a87f3b118280fbe98ed6aa7" translate="yes" xml:space="preserve">
          <source>In the second case, &lt;code&gt;ar&lt;/code&gt; must be &lt;code&gt;NULL&lt;/code&gt; and the function to be inspected must be at the top of the stack. In this case, only parameters of Lua functions are visible (as there is no information about what variables are active) and no values are pushed onto the stack.</source>
          <target state="translated">En el segundo caso, &lt;code&gt;ar&lt;/code&gt; debe ser &lt;code&gt;NULL&lt;/code&gt; y la funci&amp;oacute;n a inspeccionar debe estar en la parte superior de la pila. En este caso, solo los par&amp;aacute;metros de las funciones Lua son visibles (ya que no hay informaci&amp;oacute;n sobre qu&amp;eacute; variables est&amp;aacute;n activas) y no se insertan valores en la pila.</target>
        </trans-unit>
        <trans-unit id="5b74c4ab2ab9491434583e802b1853e197a9999c" translate="yes" xml:space="preserve">
          <source>In the second case, &lt;code&gt;ar&lt;/code&gt; must be &lt;code&gt;NULL&lt;/code&gt; and the function to be inspected must be on the top of the stack. In this case, only parameters of Lua functions are visible (as there is no information about what variables are active) and no values are pushed onto the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431335cf2ea122b520413c8e75c042e2443dd934" translate="yes" xml:space="preserve">
          <source>In this case, all returned values are thrown away. Function calls are explained in &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;.</source>
          <target state="translated">En este caso, todos los valores devueltos se desechan. Las llamadas a funciones se explican en &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="789e39d8c294634d33eb6b9c165293b5343c70b0" translate="yes" xml:space="preserve">
          <source>In words, a border is any (natural) index in a table where a non-nil value is followed by a nil value (or zero, when index 1 is nil).</source>
          <target state="translated">En palabras,un borde es cualquier índice (natural)de un cuadro en el que un valor no nulo va seguido de un valor nulo (o cero,cuando el índice 1 es nulo).</target>
        </trans-unit>
        <trans-unit id="46873fd5ff052b8cbb9d6a8125368950d99d54a9" translate="yes" xml:space="preserve">
          <source>In words, a border is any (natural) index present in the table that is followed by an absent index (or zero, when index 1 is absent).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8e5fd662c079ec4e558198c08627aa99e4ddde" translate="yes" xml:space="preserve">
          <source>In words, if the argument &lt;code&gt;arg&lt;/code&gt; is nil or absent, the macro results in the default &lt;code&gt;dflt&lt;/code&gt;. Otherwise, it results in the result of calling &lt;code&gt;func&lt;/code&gt; with the state &lt;code&gt;L&lt;/code&gt; and the argument index &lt;code&gt;arg&lt;/code&gt; as arguments. Note that it evaluates the expression &lt;code&gt;dflt&lt;/code&gt; only if needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d61c65c4df032dfd4680710a9c5e29989e4f8c3" translate="yes" xml:space="preserve">
          <source>In words, if the argument &lt;code&gt;arg&lt;/code&gt; is nil or absent, the macro results in the default &lt;code&gt;dflt&lt;/code&gt;. Otherwise, it results in the result of calling &lt;code&gt;func&lt;/code&gt; with the state &lt;code&gt;L&lt;/code&gt; and the argument index &lt;code&gt;arg&lt;/code&gt; as parameters. Note that it evaluates the expression &lt;code&gt;dflt&lt;/code&gt; only if needed.</source>
          <target state="translated">En palabras, si el argumento &lt;code&gt;arg&lt;/code&gt; es nulo o est&amp;aacute; ausente, la macro da como resultado el &lt;code&gt;dflt&lt;/code&gt; predeterminado . De lo contrario, resulta en el resultado de llamar a &lt;code&gt;func&lt;/code&gt; con el estado &lt;code&gt;L&lt;/code&gt; y el argumento &lt;code&gt;arg&lt;/code&gt; como par&amp;aacute;metros. Tenga en cuenta que eval&amp;uacute;a la expresi&amp;oacute;n &lt;code&gt;dflt&lt;/code&gt; solo si es necesario.</target>
        </trans-unit>
        <trans-unit id="01a07bfb5ef11a02986679665264fe04ed7927b3" translate="yes" xml:space="preserve">
          <source>Incremental Garbage Collection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea01033355ce358e0c79f805090383ef4dadccc" translate="yes" xml:space="preserve">
          <source>Initializes a buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). This function does not allocate any space; the buffer must be declared as a variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c7955edf181aeadc7e61f0904d3690ad3a91fb" translate="yes" xml:space="preserve">
          <source>Initializes a buffer &lt;code&gt;B&lt;/code&gt;. This function does not allocate any space; the buffer must be declared as a variable (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Inicializa un tamp&amp;oacute;n &lt;code&gt;B&lt;/code&gt; . Esta funci&amp;oacute;n no asigna ning&amp;uacute;n espacio; el b&amp;uacute;fer debe declararse como una variable (ver &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0abea9e11cfbbca6718360dab7feca24a7e28d57" translate="yes" xml:space="preserve">
          <source>Inserts element &lt;code&gt;value&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, shifting up the elements &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt;. The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list+1&lt;/code&gt;, so that a call &lt;code&gt;table.insert(t,x)&lt;/code&gt; inserts &lt;code&gt;x&lt;/code&gt; at the end of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Inserta el &lt;code&gt;value&lt;/code&gt; elemento en la posici&amp;oacute;n &lt;code&gt;pos&lt;/code&gt; en la &lt;code&gt;list&lt;/code&gt; a , desplazando hacia arriba la &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; elementos [pos], lista [pos + 1], &amp;middot;&amp;middot;&amp;middot;, lista [#lista] . El valor predeterminado para &lt;code&gt;pos&lt;/code&gt; es &lt;code&gt;#list+1&lt;/code&gt; , de modo que una llamada &lt;code&gt;table.insert(t,x)&lt;/code&gt; inserta &lt;code&gt;x&lt;/code&gt; al final de la lista &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97337f3db6c1f37e6b68c3a033b725e785a46913" translate="yes" xml:space="preserve">
          <source>Inserts element &lt;code&gt;value&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, shifting up the elements &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt;. The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list+1&lt;/code&gt;, so that a call &lt;code&gt;table.insert(t,x)&lt;/code&gt; inserts &lt;code&gt;x&lt;/code&gt; at the end of the list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3151191ed07199be567c359ddf6e784a4e531a23" translate="yes" xml:space="preserve">
          <source>Inside a C function you can raise an error by calling &lt;a href=&quot;#lua_error&quot;&gt;&lt;code&gt;lua_error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Dentro de una funci&amp;oacute;n C puede generar un error llamando a &lt;a href=&quot;#lua_error&quot;&gt; &lt;code&gt;lua_error&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7de63f7ebba7b4f1b63972998e3589e858efeb5" translate="yes" xml:space="preserve">
          <source>Inside a C function you can raise an error explicitly by calling &lt;a href=&quot;#lua_error&quot;&gt;&lt;code&gt;lua_error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b166ec01ff2a0e99bcb49337529aa50cdf9ed8" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to handle errors. (Lua will use exceptions if you compile it as C++; search for &lt;code&gt;LUAI_THROW&lt;/code&gt; in the source code for details.) When Lua faces any error (such as a memory allocation error or a type error) it &lt;em&gt;raises&lt;/em&gt; an error; that is, it does a long jump. A &lt;em&gt;protected environment&lt;/em&gt; uses &lt;code&gt;setjmp&lt;/code&gt; to set a recovery point; any error jumps to the most recent active recovery point.</source>
          <target state="translated">Internamente, Lua usa la facilidad de C &lt;code&gt;longjmp&lt;/code&gt; para manejar errores. (Lua usar&amp;aacute; excepciones si lo compila como C ++; busque &lt;code&gt;LUAI_THROW&lt;/code&gt; en el c&amp;oacute;digo fuente para m&amp;aacute;s detalles.) Cuando Lua enfrenta cualquier error (como un error de asignaci&amp;oacute;n de memoria o un error de tipo), &lt;em&gt;genera&lt;/em&gt; un error; es decir, hace un salto de longitud. Un &lt;em&gt;entorno protegido&lt;/em&gt; usa &lt;code&gt;setjmp&lt;/code&gt; para establecer un punto de recuperaci&amp;oacute;n; cualquier error salta al punto de recuperaci&amp;oacute;n activo m&amp;aacute;s reciente.</target>
        </trans-unit>
        <trans-unit id="5b482879524a2f9c14e638942f5681b2d3a687a1" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to handle errors. (Lua will use exceptions if you compile it as C++; search for &lt;code&gt;LUAI_THROW&lt;/code&gt; in the source code for details.) When Lua faces any error, such as a memory allocation error or a type error, it &lt;em&gt;raises&lt;/em&gt; an error; that is, it does a long jump. A &lt;em&gt;protected environment&lt;/em&gt; uses &lt;code&gt;setjmp&lt;/code&gt; to set a recovery point; any error jumps to the most recent active recovery point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8519c30b2fe0a1d5b4b757f31a04911a4641884f" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to yield a coroutine. Therefore, if a C function &lt;code&gt;foo&lt;/code&gt; calls an API function and this API function yields (directly or indirectly by calling another function that yields), Lua cannot return to &lt;code&gt;foo&lt;/code&gt; any more, because the &lt;code&gt;longjmp&lt;/code&gt; removes its frame from the C stack.</source>
          <target state="translated">Internamente, Lua usa la facilidad de C &lt;code&gt;longjmp&lt;/code&gt; para producir una corrutina. Por lo tanto, si una funci&amp;oacute;n C &lt;code&gt;foo&lt;/code&gt; llama a una funci&amp;oacute;n API y esta funci&amp;oacute;n API cede (directa o indirectamente llamando a otra funci&amp;oacute;n que cede), Lua ya no puede volver a &lt;code&gt;foo&lt;/code&gt; , porque el &lt;code&gt;longjmp&lt;/code&gt; elimina su marco de la pila C.</target>
        </trans-unit>
        <trans-unit id="7b4e8ed077aa1747843eb727cc8f6e4bfe8b0b8a" translate="yes" xml:space="preserve">
          <source>It can only be called from the main coroutine (thread);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad02c3ff1e54045c9f87d15faf0f433734a4ee16" translate="yes" xml:space="preserve">
          <source>It cannot be called while handling a stack-overflow error;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa29374aa14b1802d3041c63b03777bfa3568ee" translate="yes" xml:space="preserve">
          <source>It is a good practice to add all needed metamethods to a table before setting it as a metatable of some object. In particular, the &lt;code&gt;__gc&lt;/code&gt; metamethod works only when this order is followed (see &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt;).</source>
          <target state="translated">Es una buena pr&amp;aacute;ctica agregar todos los metam&amp;eacute;todos necesarios a una tabla antes de configurarla como metatabla de alg&amp;uacute;n objeto. En particular, el &lt;code&gt;__gc&lt;/code&gt; __gc funciona solo cuando se sigue este orden (ver &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ea190191ffd1383568cdfab371917a78dd082eb" translate="yes" xml:space="preserve">
          <source>It is a good practice to add all needed metamethods to a table before setting it as a metatable of some object. In particular, the &lt;code&gt;__gc&lt;/code&gt; metamethod works only when this order is followed (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;). It is also a good practice to set the metatable of an object right after its creation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1db3cf420aeec740d5b98f3c2218fb5a839f1cb0" translate="yes" xml:space="preserve">
          <source>It is implemented as a macro. The array &lt;code&gt;l&lt;/code&gt; must be the actual array, not a pointer to it.</source>
          <target state="translated">Se implementa como una macro. La matriz &lt;code&gt;l&lt;/code&gt; debe ser la matriz real, no un puntero a ella.</target>
        </trans-unit>
        <trans-unit id="c9afa0ea65ace9886d214c45b938bb7c94f5de0d" translate="yes" xml:space="preserve">
          <source>It is implemented as the following macro:</source>
          <target state="translated">Se implementa como la siguiente macro:</target>
        </trans-unit>
        <trans-unit id="783b6db8dfbf8f740fac86413ecee3fd449cddff" translate="yes" xml:space="preserve">
          <source>It is safe to load malformed binary chunks; &lt;code&gt;load&lt;/code&gt; signals an appropriate error. However, Lua does not check the consistency of the code inside binary chunks; running maliciously crafted bytecode can crash the interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="190f1a01da6183ca61829ab46d875cc8475bbf31" translate="yes" xml:space="preserve">
          <source>It returns &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; if there are no errors, or an error code in case of errors (see &lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2562ec974531de3f4ff5f92b1e35fb5384a96e25" translate="yes" xml:space="preserve">
          <source>It returns false if there are no errors or true in case of errors.</source>
          <target state="translated">Devuelve falso si no hay errores o verdadero en caso de errores.</target>
        </trans-unit>
        <trans-unit id="53569202de7b24893f55608fc3a251509d5c5ed1" translate="yes" xml:space="preserve">
          <source>Labels and empty statements are called &lt;em&gt;void statements&lt;/em&gt;, as they perform no actions.</source>
          <target state="translated">Las etiquetas y las declaraciones vac&amp;iacute;as se denominan &lt;em&gt;declaraciones nulas&lt;/em&gt; , ya que no realizan acciones.</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="34328aff9c833379f4f7362578f7f6f3c35f336b" translate="yes" xml:space="preserve">
          <source>Language constructs will be explained using the usual extended BNF notation, in which {&lt;em&gt;a&lt;/em&gt;} means 0 or more &lt;em&gt;a&lt;/em&gt;'s, and [&lt;em&gt;a&lt;/em&gt;] means an optional &lt;em&gt;a&lt;/em&gt;. Non-terminals are shown like non-terminal, keywords are shown like &lt;b&gt;kword&lt;/b&gt;, and other terminal symbols are shown like &amp;lsquo;&lt;b&gt;=&lt;/b&gt;&amp;rsquo;. The complete syntax of Lua can be found in &lt;a href=&quot;#9&quot;&gt;&amp;sect;9&lt;/a&gt; at the end of this manual.</source>
          <target state="translated">Construcciones de lenguaje se explicar&amp;aacute;n usando la notaci&amp;oacute;n BNF extendida habitual, en la que { &lt;em&gt;a&lt;/em&gt; } significa 0 o m&amp;aacute;s &lt;em&gt;a&lt;/em&gt; 's, y [ &lt;em&gt;un&lt;/em&gt; ] significa un opcional &lt;em&gt;una&lt;/em&gt; . Los no terminales se muestran como no terminales, las palabras clave se muestran como &lt;b&gt;kword&lt;/b&gt; y otros s&amp;iacute;mbolos de terminal se muestran como ' &lt;b&gt;=&lt;/b&gt; '. La sintaxis completa de Lua se puede encontrar en &lt;a href=&quot;#9&quot;&gt;&amp;sect;9&lt;/a&gt; al final de este manual.</target>
        </trans-unit>
        <trans-unit id="b15777583b377cc227a5505487783a1d631969a6" translate="yes" xml:space="preserve">
          <source>Leaves a copy of the module on the stack.</source>
          <target state="translated">Deja una copia del módulo en la pila.</target>
        </trans-unit>
        <trans-unit id="c282589ab5afc326acf6f1bd9d84cafcef993944" translate="yes" xml:space="preserve">
          <source>Level 0 is the running function, level 1 is the function that called the running function, etc.</source>
          <target state="translated">El nivel 0 es la función de funcionamiento,el nivel 1 es la función que se llama la función de funcionamiento,etc.</target>
        </trans-unit>
        <trans-unit id="bd2f93f70d8b01be186bad25b37a58b9b3ce91ea" translate="yes" xml:space="preserve">
          <source>Lexical Conventions</source>
          <target state="translated">Convenciones léxicas</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Con licencia del MIT.</target>
        </trans-unit>
        <trans-unit id="63d6bf8afb548c458acc9de58d99159419a5b08e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine. Any arguments passed to this function go as extra arguments to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; returns all the values returned by &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, except the first one (the boolean error code). Unlike &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; does not catch errors; any error is propagated to the caller.</source>
          <target state="translated">Como &lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; &lt;/a&gt; , la funci&amp;oacute;n &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n crea una corrutina, pero en lugar de devolver la corrutina en s&amp;iacute;, devuelve una funci&amp;oacute;n que, cuando se llama, reanuda la corrutina. Cualquier argumento que se pase a esta funci&amp;oacute;n va como argumentos adicionales a &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; devuelve todos los valores devueltos por &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; , excepto el primero (el c&amp;oacute;digo de error booleano). A diferencia de &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; no detecta errores; cualquier error se propaga a la persona que llama.</target>
        </trans-unit>
        <trans-unit id="9f39f04881560be91c1cf898317730aebddff532" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine. Any arguments passed to this function go as extra arguments to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; returns all the values returned by &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, except the first one (the boolean error code). Unlike &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, the function created by &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; propagates any error to the caller. In this case, the function also closes the coroutine (see &lt;a href=&quot;#pdf-coroutine.close&quot;&gt;&lt;code&gt;coroutine.close&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589bb9a9b2f8417c5c99beaf7b463ed9bff7b7a8" translate="yes" xml:space="preserve">
          <source>Like any other reference manual, this document is dry in places. For a discussion of the decisions behind the design of Lua, see the technical papers available at Lua's web site. For a detailed introduction to programming in Lua, see Roberto's book, &lt;em&gt;Programming in Lua&lt;/em&gt;.</source>
          <target state="translated">Como cualquier otro manual de referencia, este documento est&amp;aacute; seco en algunos lugares. Para una discusi&amp;oacute;n de las decisiones detr&amp;aacute;s del dise&amp;ntilde;o de Lua, vea los documentos t&amp;eacute;cnicos disponibles en el sitio web de Lua. Para obtener una introducci&amp;oacute;n detallada a la programaci&amp;oacute;n en Lua, consulte el libro de Roberto, &lt;em&gt;Programaci&amp;oacute;n en Lua&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0685b0afda8aac522f92e3eb98e6860f9fdecb1c" translate="yes" xml:space="preserve">
          <source>Like indices, the values of table fields can be of any type. In particular, because functions are first-class values, table fields can contain functions. Thus tables can also carry &lt;em&gt;methods&lt;/em&gt; (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;).</source>
          <target state="translated">Al igual que los &amp;iacute;ndices, los valores de los campos de la tabla pueden ser de cualquier tipo. En particular, debido a que las funciones son valores de primera clase, los campos de la tabla pueden contener funciones. Por tanto, las tablas tambi&amp;eacute;n pueden &lt;a href=&quot;#3.4.11&quot;&gt;contener &lt;/a&gt;&lt;em&gt;m&amp;eacute;todos&lt;/em&gt; (consulte &amp;sect;3.4.11 ).</target>
        </trans-unit>
        <trans-unit id="8afe6c1d451218575629deb4965cb995c2e958ea" translate="yes" xml:space="preserve">
          <source>Like with indexing, the metamethod for this event can be either a function or a table. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; as arguments. If it is a table, Lua does an indexing assignment to this table with the same key and value. (This assignment is regular, not raw, and therefore can trigger another metamethod.)</source>
          <target state="translated">Al igual que con la indexaci&amp;oacute;n, el metam&amp;eacute;todo para este evento puede ser una funci&amp;oacute;n o una tabla. Si es una funci&amp;oacute;n, se llama con la &lt;code&gt;table&lt;/code&gt; , la &lt;code&gt;key&lt;/code&gt; y el &lt;code&gt;value&lt;/code&gt; como argumentos. Si es una tabla, Lua realiza una asignaci&amp;oacute;n de indexaci&amp;oacute;n a esta tabla con la misma clave y valor. (Esta asignaci&amp;oacute;n es regular, no cruda y, por lo tanto, puede activar otro metam&amp;eacute;todo).</target>
        </trans-unit>
        <trans-unit id="b37120a70be7b7e2fa099662ff64ecef444b9310" translate="yes" xml:space="preserve">
          <source>Like with indexing, the metavalue for this event can be either a function, a table, or any value with an &lt;code&gt;__newindex&lt;/code&gt; metavalue. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; as arguments. Otherwise, Lua repeats the indexing assignment over this metavalue with the same key and value. This assignment is regular, not raw, and therefore can trigger another &lt;code&gt;__newindex&lt;/code&gt; metavalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86fb0e6b085882445de9a7a2409c78eb9059df37" translate="yes" xml:space="preserve">
          <source>Literal decimal integer constants that overflow are read as floats, instead of wrapping around. You can use hexadecimal notation for such constants if you want the old behavior (reading them as integers with wrap around).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf4bcbf4e9a4c997d9f25e1a4ebd39ad823de69" translate="yes" xml:space="preserve">
          <source>Literal strings can also be defined using a long format enclosed by &lt;em&gt;long brackets&lt;/em&gt;. We define an &lt;em&gt;opening long bracket of level &lt;em&gt;n&lt;/em&gt;&lt;/em&gt; as an opening square bracket followed by &lt;em&gt;n&lt;/em&gt; equal signs followed by another opening square bracket. So, an opening long bracket of level 0 is written as &lt;code&gt;[[&lt;/code&gt;, an opening long bracket of level 1 is written as &lt;code&gt;[=[&lt;/code&gt;, and so on. A &lt;em&gt;closing long bracket&lt;/em&gt; is defined similarly; for instance, a closing long bracket of level 4 is written as &lt;code&gt;]====]&lt;/code&gt;. A &lt;em&gt;long literal&lt;/em&gt; starts with an opening long bracket of any level and ends at the first closing long bracket of the same level. It can contain any text except a closing bracket of the same level. Literals in this bracketed form can run for several lines, do not interpret any escape sequences, and ignore long brackets of any other level. Any kind of end-of-line sequence (carriage return, newline, carriage return followed by newline, or newline followed by carriage return) is converted to a simple newline.</source>
          <target state="translated">Las cadenas literales tambi&amp;eacute;n se pueden definir utilizando un formato &lt;em&gt;largo entre corchetes largos&lt;/em&gt; . Definimos un &lt;em&gt;corchete largo de apertura de nivel &lt;em&gt;n&lt;/em&gt;&lt;/em&gt; como un corchete de apertura seguido de &lt;em&gt;n&lt;/em&gt; signos iguales seguidos de otro corchete de apertura. Entonces, un corchete largo de apertura del nivel 0 se escribe como &lt;code&gt;[[&lt;/code&gt; , un corchete largo de apertura del nivel 1 se escribe como &lt;code&gt;[=[&lt;/code&gt; , y as&amp;iacute; sucesivamente. Un &lt;em&gt;par&amp;eacute;ntesis largo de cierre&lt;/em&gt; se define de manera similar; por ejemplo, un corchete largo de cierre del nivel 4 se escribe como &lt;code&gt;]====]&lt;/code&gt; . Un &lt;em&gt;literal largo&lt;/em&gt;comienza con un soporte largo de apertura de cualquier nivel y termina en el primer soporte largo de cierre del mismo nivel. Puede contener cualquier texto excepto un corchete de cierre del mismo nivel. Los literales en esta forma entre corchetes se pueden ejecutar para varias l&amp;iacute;neas, no interpretan ninguna secuencia de escape e ignoran los corchetes largos de cualquier otro nivel. Cualquier tipo de secuencia de final de l&amp;iacute;nea (retorno de carro, nueva l&amp;iacute;nea, retorno de carro seguido de nueva l&amp;iacute;nea o nueva l&amp;iacute;nea seguida de retorno de carro) se convierte en una nueva l&amp;iacute;nea simple.</target>
        </trans-unit>
        <trans-unit id="7806930c3347438897b185e0ff1d0adc3021f8d3" translate="yes" xml:space="preserve">
          <source>Literal strings can also be defined using a long format enclosed by &lt;em&gt;long brackets&lt;/em&gt;. We define an &lt;em&gt;opening long bracket of level &lt;em&gt;n&lt;/em&gt;&lt;/em&gt; as an opening square bracket followed by &lt;em&gt;n&lt;/em&gt; equal signs followed by another opening square bracket. So, an opening long bracket of level 0 is written as &lt;code&gt;[[&lt;/code&gt;, an opening long bracket of level 1 is written as &lt;code&gt;[=[&lt;/code&gt;, and so on. A &lt;em&gt;closing long bracket&lt;/em&gt; is defined similarly; for instance, a closing long bracket of level 4 is written as &lt;code&gt;]====]&lt;/code&gt;. A &lt;em&gt;long literal&lt;/em&gt; starts with an opening long bracket of any level and ends at the first closing long bracket of the same level. It can contain any text except a closing bracket of the same level. Literals in this bracketed form can run for several lines, do not interpret any escape sequences, and ignore long brackets of any other level. Any kind of end-of-line sequence (carriage return, newline, carriage return followed by newline, or newline followed by carriage return) is converted to a simple newline. When the opening long bracket is immediately followed by a newline, the newline is not included in the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1021ae8c4b84ca4a4e3486abedfb8d10587c094" translate="yes" xml:space="preserve">
          <source>Loads a Lua chunk without running it. If there are no errors, &lt;code&gt;lua_load&lt;/code&gt; pushes the compiled chunk as a Lua function on top of the stack. Otherwise, it pushes an error message.</source>
          <target state="translated">Carga un fragmento de Lua sin ejecutarlo. Si no hay errores, &lt;code&gt;lua_load&lt;/code&gt; coloca el fragmento compilado como una funci&amp;oacute;n Lua en la parte superior de la pila. De lo contrario, muestra un mensaje de error.</target>
        </trans-unit>
        <trans-unit id="d5d5fd2502388f4bdbfdc40480095cb9940c91fb" translate="yes" xml:space="preserve">
          <source>Loads a buffer as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the buffer pointed to by &lt;code&gt;buff&lt;/code&gt; with size &lt;code&gt;sz&lt;/code&gt;.</source>
          <target state="translated">Carga un b&amp;uacute;fer como un fragmento de Lua. Esta funci&amp;oacute;n usa &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; para cargar el fragmento en el b&amp;uacute;fer al que apunta &lt;code&gt;buff&lt;/code&gt; con tama&amp;ntilde;o &lt;code&gt;sz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="014ceb5ba979a3f7460e80adaf03760442d4492f" translate="yes" xml:space="preserve">
          <source>Loads a chunk.</source>
          <target state="translated">Carga un trozo.</target>
        </trans-unit>
        <trans-unit id="8dd06506aefef93d24f715ed25819bedec96323c" translate="yes" xml:space="preserve">
          <source>Loads a file as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the file named &lt;code&gt;filename&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then it loads from the standard input. The first line in the file is ignored if it starts with a &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">Carga un archivo como un fragmento de Lua. Esta funci&amp;oacute;n usa &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; para cargar el fragmento en el archivo llamado &lt;code&gt;filename&lt;/code&gt; . Si el &lt;code&gt;filename&lt;/code&gt; es &lt;code&gt;NULL&lt;/code&gt; , se carga desde la entrada est&amp;aacute;ndar. La primera l&amp;iacute;nea del archivo se ignora si comienza con &lt;code&gt;#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f640ebe64a89ecb5b9bd56467fcc7e3fb5298535" translate="yes" xml:space="preserve">
          <source>Loads a string as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the zero-terminated string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Carga una cadena como un trozo de Lua. Esta funci&amp;oacute;n usa &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; para cargar el fragmento en la cadena terminada en cero &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="601f4f126ff0dc3c88078602ece1575bc60b38da" translate="yes" xml:space="preserve">
          <source>Loads and runs the given file. It is defined as the following macro:</source>
          <target state="translated">Carga y ejecuta el archivo dado.Se define como la siguiente macro:</target>
        </trans-unit>
        <trans-unit id="41daddb6c30d8daa7aa997ef002e9682aa252572" translate="yes" xml:space="preserve">
          <source>Loads and runs the given string. It is defined as the following macro:</source>
          <target state="translated">Carga y ejecuta la cuerda dada.Se define como la siguiente macro:</target>
        </trans-unit>
        <trans-unit id="07953018574342518cc4ef6ce0bb634e54cd3232" translate="yes" xml:space="preserve">
          <source>Loads the given module. The function starts by looking into the &lt;a href=&quot;#pdf-package.loaded&quot;&gt;&lt;code&gt;package.loaded&lt;/code&gt;&lt;/a&gt; table to determine whether &lt;code&gt;modname&lt;/code&gt; is already loaded. If it is, then &lt;code&gt;require&lt;/code&gt; returns the value stored at &lt;code&gt;package.loaded[modname]&lt;/code&gt;. (The absence of a second result in this case signals that this call did not have to load the module.) Otherwise, it tries to find a &lt;em&gt;loader&lt;/em&gt; for the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5754e2c7cbb7348e49d26f5b052dec66fe41474e" translate="yes" xml:space="preserve">
          <source>Loads the given module. The function starts by looking into the &lt;a href=&quot;#pdf-package.loaded&quot;&gt;&lt;code&gt;package.loaded&lt;/code&gt;&lt;/a&gt; table to determine whether &lt;code&gt;modname&lt;/code&gt; is already loaded. If it is, then &lt;code&gt;require&lt;/code&gt; returns the value stored at &lt;code&gt;package.loaded[modname]&lt;/code&gt;. Otherwise, it tries to find a &lt;em&gt;loader&lt;/em&gt; for the module.</source>
          <target state="translated">Carga el m&amp;oacute;dulo dado. La funci&amp;oacute;n comienza mirando en la tabla &lt;a href=&quot;#pdf-package.loaded&quot;&gt; &lt;code&gt;package.loaded&lt;/code&gt; &lt;/a&gt; para determinar si &lt;code&gt;modname&lt;/code&gt; ya est&amp;aacute; cargado. Si es as&amp;iacute;, &lt;code&gt;require&lt;/code&gt; devuelve el valor almacenado en &lt;code&gt;package.loaded[modname]&lt;/code&gt; . De lo contrario, intenta encontrar un &lt;em&gt;cargador&lt;/em&gt; para el m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="675ad816883ad3050b77c4af165af0c382872da3" translate="yes" xml:space="preserve">
          <source>Local Declarations</source>
          <target state="translated">Declaraciones locales</target>
        </trans-unit>
        <trans-unit id="e74ccb9aead3e3f9b1bc796bf321e14c551c0f2e" translate="yes" xml:space="preserve">
          <source>Local variables can be declared anywhere inside a block. The declaration can include an initial assignment:</source>
          <target state="translated">Las variables locales pueden ser declaradas en cualquier lugar dentro de un bloque.La declaración puede incluir una asignación inicial:</target>
        </trans-unit>
        <trans-unit id="c10d9e4965c7bd64f801ff5a335aa4dea4e1bdf4" translate="yes" xml:space="preserve">
          <source>Local variables can be declared anywhere inside a block. The declaration can include an initialization:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eac6118ebdd55aa38b41f70efdf532e567ffd8" translate="yes" xml:space="preserve">
          <source>Logical Operators</source>
          <target state="translated">Operadores lógicos</target>
        </trans-unit>
        <trans-unit id="f3c2c12151d04fbe64aef12442234645ff418818" translate="yes" xml:space="preserve">
          <source>Looks for the first &lt;em&gt;match&lt;/em&gt; of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds one, then &lt;code&gt;match&lt;/code&gt; returns the captures from the pattern; otherwise it returns &lt;b&gt;nil&lt;/b&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is returned. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative.</source>
          <target state="translated">Busca la primera &lt;em&gt;coincidencia&lt;/em&gt; de &lt;code&gt;pattern&lt;/code&gt; (consulte &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; ) en la cadena &lt;code&gt;s&lt;/code&gt; . Si encuentra una, &lt;code&gt;match&lt;/code&gt; devuelve las capturas del patr&amp;oacute;n; de lo contrario, devuelve &lt;b&gt;nil&lt;/b&gt; . Si el &lt;code&gt;pattern&lt;/code&gt; no especifica capturas, se devuelve toda la coincidencia. Un tercer argumento num&amp;eacute;rico opcional &lt;code&gt;init&lt;/code&gt; especifica d&amp;oacute;nde comenzar la b&amp;uacute;squeda; su valor predeterminado es 1 y puede ser negativo.</target>
        </trans-unit>
        <trans-unit id="8c9988ddc14961cb0c52bb6cea07ce6c02324d47" translate="yes" xml:space="preserve">
          <source>Looks for the first &lt;em&gt;match&lt;/em&gt; of the &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds one, then &lt;code&gt;match&lt;/code&gt; returns the captures from the pattern; otherwise it returns &lt;b&gt;fail&lt;/b&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is returned. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac72aba64827a6df2b943b8e5302e4719c3c812b" translate="yes" xml:space="preserve">
          <source>Looks for the first match of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds a match, then &lt;code&gt;find&lt;/code&gt; returns the indices of &lt;code&gt;s&lt;/code&gt; where this occurrence starts and ends; otherwise, it returns &lt;b&gt;fail&lt;/b&gt;. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative. A value of &lt;b&gt;true&lt;/b&gt; as a fourth, optional argument &lt;code&gt;plain&lt;/code&gt; turns off the pattern matching facilities, so the function does a plain &quot;find substring&quot; operation, with no characters in &lt;code&gt;pattern&lt;/code&gt; being considered magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0531dd8559629f728382a45e8fa0141160f819b2" translate="yes" xml:space="preserve">
          <source>Looks for the first match of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds a match, then &lt;code&gt;find&lt;/code&gt; returns the indices of &lt;code&gt;s&lt;/code&gt; where this occurrence starts and ends; otherwise, it returns &lt;b&gt;nil&lt;/b&gt;. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative. A value of &lt;b&gt;true&lt;/b&gt; as a fourth, optional argument &lt;code&gt;plain&lt;/code&gt; turns off the pattern matching facilities, so the function does a plain &quot;find substring&quot; operation, with no characters in &lt;code&gt;pattern&lt;/code&gt; being considered magic. Note that if &lt;code&gt;plain&lt;/code&gt; is given, then &lt;code&gt;init&lt;/code&gt; must be given as well.</source>
          <target state="translated">Busca la primera coincidencia de &lt;code&gt;pattern&lt;/code&gt; (consulte &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; ) en la cadena &lt;code&gt;s&lt;/code&gt; . Si encuentra una coincidencia, &lt;code&gt;find&lt;/code&gt; devuelve los &amp;iacute;ndices de &lt;code&gt;s&lt;/code&gt; donde esta ocurrencia comienza y termina; de lo contrario, devuelve &lt;b&gt;nil&lt;/b&gt; . Un tercer argumento num&amp;eacute;rico opcional &lt;code&gt;init&lt;/code&gt; especifica d&amp;oacute;nde comenzar la b&amp;uacute;squeda; su valor predeterminado es 1 y puede ser negativo. Un valor de &lt;b&gt;verdadero&lt;/b&gt; como cuarto argumento opcional &lt;code&gt;plain&lt;/code&gt; desactiva las facilidades de coincidencia de patrones, por lo que la funci&amp;oacute;n realiza una operaci&amp;oacute;n simple de &quot;buscar subcadena&quot;, sin que ning&amp;uacute;n car&amp;aacute;cter en el &lt;code&gt;pattern&lt;/code&gt; se considere m&amp;aacute;gico. Tenga en cuenta que si se da &lt;code&gt;plain&lt;/code&gt; , entonces &lt;code&gt;init&lt;/code&gt; debe dar init .</target>
        </trans-unit>
        <trans-unit id="b0832074630eb731d7fbe8074de48a90cd9bb220" translate="yes" xml:space="preserve">
          <source>Lua</source>
          <target state="translated">Lua</target>
        </trans-unit>
        <trans-unit id="74935e355c6d4299b6901e869daba41fae3ae4f2" translate="yes" xml:space="preserve">
          <source>Lua 5.3 Reference Manual</source>
          <target state="translated">Lua 5.3 Manual de referencia</target>
        </trans-unit>
        <trans-unit id="1c9ec46a65315e465f99f9adf0e3977cea4a15cf" translate="yes" xml:space="preserve">
          <source>Lua 5.4 Reference Manual</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8957a41e15b0eb53aad63ef201700fe8063f094" translate="yes" xml:space="preserve">
          <source>Lua allows multiple assignments. Therefore, the syntax for assignment defines a list of variables on the left side and a list of expressions on the right side. The elements in both lists are separated by commas:</source>
          <target state="translated">Lua permite múltiples asignaciones.Por lo tanto,la sintaxis de la asignación define una lista de variables en el lado izquierdo y una lista de expresiones en el lado derecho.Los elementos de ambas listas están separados por comas:</target>
        </trans-unit>
        <trans-unit id="1e02808cd690aaf7df864db5c4c452af196be013" translate="yes" xml:space="preserve">
          <source>Lua also converts strings to numbers, whenever a number is expected.</source>
          <target state="translated">Lua también convierte las cuerdas en números,siempre que se espera un número.</target>
        </trans-unit>
        <trans-unit id="93377de262ae6c56472bd1d07591e21435ec1e52" translate="yes" xml:space="preserve">
          <source>Lua also defines the constants &lt;a id=&quot;pdf-LUA_MININTEGER&quot;&gt;&lt;code&gt;LUA_MININTEGER&lt;/code&gt;&lt;/a&gt; and &lt;a id=&quot;pdf-LUA_MAXINTEGER&quot;&gt;&lt;code&gt;LUA_MAXINTEGER&lt;/code&gt;&lt;/a&gt;, with the minimum and the maximum values that fit in this type.</source>
          <target state="translated">Lua tambi&amp;eacute;n define las constantes &lt;a id=&quot;pdf-LUA_MININTEGER&quot;&gt; &lt;code&gt;LUA_MININTEGER&lt;/code&gt; &lt;/a&gt; y &lt;a id=&quot;pdf-LUA_MAXINTEGER&quot;&gt; &lt;code&gt;LUA_MAXINTEGER&lt;/code&gt; &lt;/a&gt; , con los valores m&amp;iacute;nimo y m&amp;aacute;ximo que encajan en este tipo.</target>
        </trans-unit>
        <trans-unit id="801090e92a322f968636387436cbfb91aa33b154" translate="yes" xml:space="preserve">
          <source>Lua also has a &lt;b&gt;for&lt;/b&gt; statement, in two flavors (see &lt;a href=&quot;#3.3.5&quot;&gt;&amp;sect;3.3.5&lt;/a&gt;).</source>
          <target state="translated">Lua tambi&amp;eacute;n tiene una declaraci&amp;oacute;n &lt;b&gt;for&lt;/b&gt; , en dos sabores (ver &lt;a href=&quot;#3.3.5&quot;&gt;&amp;sect;3.3.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b8bd17007ccbbeb2e48374787c45da4db96657dd" translate="yes" xml:space="preserve">
          <source>Lua also offers a system of &lt;em&gt;warnings&lt;/em&gt; (see &lt;a href=&quot;#pdf-warn&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;). Unlike errors, warnings do not interfere in any way with program execution. They typically only generate a message to the user, although this behavior can be adapted from C (see &lt;a href=&quot;#lua_setwarnf&quot;&gt;&lt;code&gt;lua_setwarnf&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da908593ea7c1cd8a16b5d87a2733072f9be916" translate="yes" xml:space="preserve">
          <source>Lua assumes the following behavior from the allocator function:</source>
          <target state="translated">Lua asume el siguiente comportamiento de la función asignadora:</target>
        </trans-unit>
        <trans-unit id="ebffede5db745b98cdaa093a245240704c9e96b1" translate="yes" xml:space="preserve">
          <source>Lua can call (and manipulate) functions written in Lua and functions written in C (see &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;). Both are represented by the type &lt;em&gt;function&lt;/em&gt;.</source>
          <target state="translated">Lua puede llamar (y manipular) funciones escritas en Lua y funciones escritas en C (ver &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; ). Ambos est&amp;aacute;n representados por la &lt;em&gt;funci&amp;oacute;n de&lt;/em&gt; tipo .</target>
        </trans-unit>
        <trans-unit id="95c6862384367c489829b9fcf5d130d494969aa1" translate="yes" xml:space="preserve">
          <source>Lua code can explicitly generate an error by calling the &lt;a href=&quot;#pdf-error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function. If you need to catch errors in Lua, you can use &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; to call a given function in &lt;em&gt;protected mode&lt;/em&gt;.</source>
          <target state="translated">El c&amp;oacute;digo Lua puede generar expl&amp;iacute;citamente un error llamando a la funci&amp;oacute;n de &lt;a href=&quot;#pdf-error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; . Si necesita detectar errores en Lua, puede usar &lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt; para llamar a una funci&amp;oacute;n determinada en &lt;em&gt;modo protegido&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1dc01b0813afb0e9f0eaf4570d6c6a76184553b6" translate="yes" xml:space="preserve">
          <source>Lua code can explicitly raise an error by calling the &lt;a href=&quot;#pdf-error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function. (This function never returns.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1864a075a2790c597421da62110c2e5ddf9a0670" translate="yes" xml:space="preserve">
          <source>Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode with a register-based virtual machine, and has automatic memory management with a generational garbage collection, making it ideal for configuration, scripting, and rapid prototyping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55000944726bac35e3a7a8c2c659ce8ea827ae88" translate="yes" xml:space="preserve">
          <source>Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode with a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.</source>
          <target state="translated">Lua combina una sintaxis procesal simple con poderosas construcciones de descripción de datos basadas en arreglos asociativos y semántica extensible.Lua se teclea dinámicamente,se ejecuta interpretando el código de bytes con una máquina virtual basada en registros,y tiene una gestión automática de la memoria con recogida incremental de basura,lo que lo hace ideal para la configuración,la programación y la creación rápida de prototipos.</target>
        </trans-unit>
        <trans-unit id="8c26f824cf75010655e9550b8fde705425a3784c" translate="yes" xml:space="preserve">
          <source>Lua does not check the consistency of binary chunks. Maliciously crafted binary chunks can crash the interpreter.</source>
          <target state="translated">Lua no comprueba la consistencia de los trozos binarios.Los trozos binarios mal hechos pueden hacer que el intérprete se caiga.</target>
        </trans-unit>
        <trans-unit id="1a5e8dc647ce5f791a0e6cc5be4cbed5172328da" translate="yes" xml:space="preserve">
          <source>Lua handles a chunk as the body of an anonymous function with a variable number of arguments (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;). As such, chunks can define local variables, receive arguments, and return values. Moreover, such anonymous function is compiled as in the scope of an external local variable called &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). The resulting function always has &lt;code&gt;_ENV&lt;/code&gt; as its only external variable, even if it does not use that variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b65ab36f2f47f5954bb270f0f9be36cfe1a6ba" translate="yes" xml:space="preserve">
          <source>Lua handles a chunk as the body of an anonymous function with a variable number of arguments (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;). As such, chunks can define local variables, receive arguments, and return values. Moreover, such anonymous function is compiled as in the scope of an external local variable called &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). The resulting function always has &lt;code&gt;_ENV&lt;/code&gt; as its only upvalue, even if it does not use that variable.</source>
          <target state="translated">Lua maneja un fragmento como el cuerpo de una funci&amp;oacute;n an&amp;oacute;nima con un n&amp;uacute;mero variable de argumentos (ver &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; ). Como tal, los fragmentos pueden definir variables locales, recibir argumentos y devolver valores. Adem&amp;aacute;s, dicha funci&amp;oacute;n an&amp;oacute;nima se compila como en el alcance de una variable local externa llamada &lt;code&gt;_ENV&lt;/code&gt; (ver &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ). La funci&amp;oacute;n resultante siempre tiene &lt;code&gt;_ENV&lt;/code&gt; como su &amp;uacute;nico valor de actualizaci&amp;oacute;n, incluso si no usa esa variable.</target>
        </trans-unit>
        <trans-unit id="7bb5694782dd5240f5a360755736e520cb7caddd" translate="yes" xml:space="preserve">
          <source>Lua has &lt;em&gt;empty statements&lt;/em&gt; that allow you to separate statements with semicolons, start a block with a semicolon or write two semicolons in sequence:</source>
          <target state="translated">Lua tiene &lt;em&gt;declaraciones vac&amp;iacute;as&lt;/em&gt; que le permiten separar declaraciones con punto y coma, comenzar un bloque con un punto y coma o escribir dos puntos y coma en secuencia:</target>
        </trans-unit>
        <trans-unit id="3e19bed5c0654df07eeefc8d0dbcff0cc7fb976e" translate="yes" xml:space="preserve">
          <source>Lua has explicit rules about when each subtype is used, but it also converts between them automatically as needed (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;). Therefore, the programmer may choose to mostly ignore the difference between integers and floats or to assume complete control over the representation of each number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b67a26f91c4bb6ecbeaabc79499925202576c4" translate="yes" xml:space="preserve">
          <source>Lua has no built-in debugging facilities. Instead, it offers a special interface by means of functions and &lt;em&gt;hooks&lt;/em&gt;. This interface allows the construction of different kinds of debuggers, profilers, and other tools that need &quot;inside information&quot; from the interpreter.</source>
          <target state="translated">Lua no tiene funciones de depuraci&amp;oacute;n integradas. En cambio, ofrece una interfaz especial mediante funciones y &lt;em&gt;ganchos&lt;/em&gt; . Esta interfaz permite la construcci&amp;oacute;n de diferentes tipos de depuradores, perfiladores y otras herramientas que necesitan &quot;informaci&amp;oacute;n privilegiada&quot; del int&amp;eacute;rprete.</target>
        </trans-unit>
        <trans-unit id="ab53ba5d8b707a086c1f55306a5e491b7ca0c834" translate="yes" xml:space="preserve">
          <source>Lua implements an incremental mark-and-sweep collector. It uses two numbers to control its garbage-collection cycles: the &lt;em&gt;garbage-collector pause&lt;/em&gt; and the &lt;em&gt;garbage-collector step multiplier&lt;/em&gt;. Both use percentage points as units (e.g., a value of 100 means an internal value of 1).</source>
          <target state="translated">Lua implementa un recolector de marca y barrido incremental. Utiliza dos n&amp;uacute;meros para controlar sus ciclos de &lt;em&gt;recolecci&amp;oacute;n de basura&lt;/em&gt; : la &lt;em&gt;pausa&lt;/em&gt; del &lt;em&gt;recolector de basura&lt;/em&gt; y el &lt;em&gt;multiplicador de pasos del recolector de basura&lt;/em&gt; . Ambos usan puntos porcentuales como unidades (por ejemplo, un valor de 100 significa un valor interno de 1).</target>
        </trans-unit>
        <trans-unit id="ad855bd45416f0333645541d1257309374015262" translate="yes" xml:space="preserve">
          <source>Lua initializes its pseudo-random generator with the equivalent of a call to &lt;a href=&quot;#pdf-math.randomseed&quot;&gt;&lt;code&gt;math.randomseed&lt;/code&gt;&lt;/a&gt; with no arguments, so that &lt;code&gt;math.random&lt;/code&gt; should generate different sequences of results each time the program runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be60237bd80620e268374029f3211e510b05c17" translate="yes" xml:space="preserve">
          <source>Lua initializes the C path &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; in the same way it initializes the Lua path &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;, using the environment variable &lt;a id=&quot;pdf-LUA_CPATH_5_3&quot;&gt;&lt;code&gt;LUA_CPATH_5_3&lt;/code&gt;&lt;/a&gt;, or the environment variable &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt;&lt;code&gt;LUA_CPATH&lt;/code&gt;&lt;/a&gt;, or a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">Lua inicializa la ruta de C &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt; de la misma manera que inicializa la ruta de Lua &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt; , utilizando la variable de entorno &lt;a id=&quot;pdf-LUA_CPATH_5_3&quot;&gt; &lt;code&gt;LUA_CPATH_5_3&lt;/code&gt; &lt;/a&gt; , o la variable de entorno &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt; &lt;code&gt;LUA_CPATH&lt;/code&gt; &lt;/a&gt; , o una ruta predeterminada definida en &lt;code&gt;luaconf.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dd87e2bc11c5d748dd2ecd3b8a3e7dcc5b9ccfa" translate="yes" xml:space="preserve">
          <source>Lua initializes the C path &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; in the same way it initializes the Lua path &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;, using the environment variable &lt;a id=&quot;pdf-LUA_CPATH_5_4&quot;&gt;&lt;code&gt;LUA_CPATH_5_4&lt;/code&gt;&lt;/a&gt;, or the environment variable &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt;&lt;code&gt;LUA_CPATH&lt;/code&gt;&lt;/a&gt;, or a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4714009f33265bf1fc4688da888d62c97c45d7b7" translate="yes" xml:space="preserve">
          <source>Lua initializes this table with four searcher functions.</source>
          <target state="translated">Lua inicializa esta tabla con cuatro funciones de búsqueda.</target>
        </trans-unit>
        <trans-unit id="ef9edf704545b26dfa394b151700f2e58198d961" translate="yes" xml:space="preserve">
          <source>Lua is a &lt;em&gt;dynamically typed language&lt;/em&gt;. This means that variables do not have types; only values do. There are no type definitions in the language. All values carry their own type.</source>
          <target state="translated">Lua es un &lt;em&gt;lenguaje escrito din&amp;aacute;micamente&lt;/em&gt; . Esto significa que las variables no tienen tipos; s&amp;oacute;lo los valores lo hacen. No hay definiciones de tipo en el idioma. Todos los valores tienen su propio tipo.</target>
        </trans-unit>
        <trans-unit id="768b1dfa86b0332cedc5bdb9fcc8e17166f9ef47" translate="yes" xml:space="preserve">
          <source>Lua is a case-sensitive language: &lt;code&gt;and&lt;/code&gt; is a reserved word, but &lt;code&gt;And&lt;/code&gt; and &lt;code&gt;AND&lt;/code&gt; are two different, valid names. As a convention, programs should avoid creating names that start with an underscore followed by one or more uppercase letters (such as &lt;a href=&quot;#pdf-_VERSION&quot;&gt;&lt;code&gt;_VERSION&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Lua es un lenguaje que distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas: &lt;code&gt;and&lt;/code&gt; es una palabra reservada, pero &lt;code&gt;And&lt;/code&gt; y &lt;code&gt;AND&lt;/code&gt; son dos nombres v&amp;aacute;lidos diferentes. Como convenci&amp;oacute;n, los programas deben evitar crear nombres que comiencen con un gui&amp;oacute;n bajo seguido de una o m&amp;aacute;s letras may&amp;uacute;sculas (como &lt;a href=&quot;#pdf-_VERSION&quot;&gt; &lt;code&gt;_VERSION&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="14462b481cdd16dd35942cf7ea65c476fc81dc92" translate="yes" xml:space="preserve">
          <source>Lua is a dynamically typed language. This means that variables do not have types; only values do. There are no type definitions in the language. All values carry their own type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5747aeb4d5eff65fa7549c62e63b2802c05d28fa" translate="yes" xml:space="preserve">
          <source>Lua is a free-form language. It ignores spaces (including new lines) and comments between lexical elements (tokens), except as delimiters between names and keywords.</source>
          <target state="translated">El lua es un idioma de forma libre.Ignora los espacios (incluidas las líneas nuevas)y los comentarios entre los elementos léxicos (fichas),excepto como delimitadores entre los nombres y las palabras clave.</target>
        </trans-unit>
        <trans-unit id="d6fc1e0827574e83666a7aeb884cd5cd48ccb329" translate="yes" xml:space="preserve">
          <source>Lua is a free-form language. It ignores spaces and comments between lexical elements (tokens), except as delimiters between two tokens. In source code, Lua recognizes as spaces the standard ASCII whitespace characters space, form feed, newline, carriage return, horizontal tab, and vertical tab.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cf3931978ad3da8f2a0c2e42a3bc57db1befcb" translate="yes" xml:space="preserve">
          <source>Lua is a lexically scoped language. The scope of a local variable begins at the first statement after its declaration and lasts until the last non-void statement of the innermost block that includes the declaration. Consider the following example:</source>
          <target state="translated">El lua es un idioma de alcance léxico.El alcance de una variable local comienza en la primera declaración después de su declaración y dura hasta la última declaración no evasiva del bloque más interno que incluye la declaración.Consideremos el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="64997c71b569a923ad45e14df6ef4a0a98b01aef" translate="yes" xml:space="preserve">
          <source>Lua is a powerful, efficient, lightweight, embeddable scripting language. It supports procedural programming, object-oriented programming, functional programming, data-driven programming, and data description.</source>
          <target state="translated">Lua es un poderoso,eficiente,ligero e incrustado lenguaje de escritura.Soporta la programación de procedimientos,la programación orientada a objetos,la programación funcional,la programación basada en datos y la descripción de datos.</target>
        </trans-unit>
        <trans-unit id="6525b86788861e011c88cf07f7294dd56f02830d" translate="yes" xml:space="preserve">
          <source>Lua is free software, and is provided as usual with no guarantees, as stated in its license. The implementation described in this manual is available at Lua's official web site, &lt;code&gt;www.lua.org&lt;/code&gt;.</source>
          <target state="translated">Lua es un software gratuito y se proporciona como de costumbre sin garant&amp;iacute;as, como se indica en su licencia. La implementaci&amp;oacute;n descrita en este manual est&amp;aacute; disponible en el sitio web oficial de Lua, &lt;code&gt;www.lua.org&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf89f8ce15263309be1a18939b1bc8b312081d0b" translate="yes" xml:space="preserve">
          <source>Lua is implemented as a library, written in &lt;em&gt;clean C&lt;/em&gt;, the common subset of Standard C and C++. The Lua distribution includes a host program called &lt;code&gt;lua&lt;/code&gt;, which uses the Lua library to offer a complete, standalone Lua interpreter, for interactive or batch use. Lua is intended to be used both as a powerful, lightweight, embeddable scripting language for any program that needs one, and as a powerful but lightweight and efficient stand-alone language.</source>
          <target state="translated">Lua se implementa como una biblioteca, escrita en &lt;em&gt;C limpio&lt;/em&gt; , el subconjunto com&amp;uacute;n de Standard C y C ++. La distribuci&amp;oacute;n Lua incluye un programa anfitri&amp;oacute;n llamado &lt;code&gt;lua&lt;/code&gt; , que utiliza la biblioteca Lua para ofrecer un int&amp;eacute;rprete Lua completo e independiente, para uso interactivo o por lotes. Lua est&amp;aacute; destinado a ser utilizado como un lenguaje de scripting potente, ligero e integrable para cualquier programa que lo necesite, y como un lenguaje independiente potente pero ligero y eficiente.</target>
        </trans-unit>
        <trans-unit id="d706bcd1ff8f8bec50ed4b63b5fce0e2915787d3" translate="yes" xml:space="preserve">
          <source>Lua keeps a distinguished environment called the &lt;em&gt;global environment&lt;/em&gt;. This value is kept at a special index in the C registry (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;). In Lua, the global variable &lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is initialized with this same value. (&lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is never used internally, so changing its value will affect only your own code.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766bf2f3607b0c894574e1db0930518cd452197d" translate="yes" xml:space="preserve">
          <source>Lua keeps a distinguished environment called the &lt;em&gt;global environment&lt;/em&gt;. This value is kept at a special index in the C registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). In Lua, the global variable &lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is initialized with this same value. (&lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is never used internally.)</source>
          <target state="translated">Lua mantiene un entorno distinguido llamado &lt;em&gt;entorno global&lt;/em&gt; . Este valor se mantiene en un &amp;iacute;ndice especial en el registro C (ver &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; ). En Lua, la variable global &lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt; se inicializa con este mismo valor. ( &lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt; nunca se usa internamente).</target>
        </trans-unit>
        <trans-unit id="50a6344d2469ab6de8e8a3709a57a990d508f2b9" translate="yes" xml:space="preserve">
          <source>Lua performs automatic memory management. This means that you do not have to worry about allocating memory for new objects or freeing it when the objects are no longer needed. Lua manages memory automatically by running a &lt;em&gt;garbage collector&lt;/em&gt; to collect all &lt;em&gt;dead objects&lt;/em&gt; (that is, objects that are no longer accessible from Lua). All memory used by Lua is subject to automatic management: strings, tables, userdata, functions, threads, internal structures, etc.</source>
          <target state="translated">Lua realiza la gesti&amp;oacute;n autom&amp;aacute;tica de la memoria. Esto significa que no tiene que preocuparse por asignar memoria para nuevos objetos o liberarla cuando los objetos ya no sean necesarios. Lua administra la memoria autom&amp;aacute;ticamente ejecutando un &lt;em&gt;recolector de basura&lt;/em&gt; para recolectar todos &lt;em&gt;los objetos muertos&lt;/em&gt; (es decir, objetos a los que ya no se puede acceder desde Lua). Toda la memoria utilizada por Lua est&amp;aacute; sujeta a una gesti&amp;oacute;n autom&amp;aacute;tica: cadenas, tablas, datos de usuario, funciones, hilos, estructuras internas, etc.</target>
        </trans-unit>
        <trans-unit id="a37183d7def474e8ad0a40034770f88144395901" translate="yes" xml:space="preserve">
          <source>Lua performs automatic memory management. This means that you do not have to worry about allocating memory for new objects or freeing it when the objects are no longer needed. Lua manages memory automatically by running a &lt;em&gt;garbage collector&lt;/em&gt; to collect all &lt;em&gt;dead&lt;/em&gt; objects. All memory used by Lua is subject to automatic management: strings, tables, userdata, functions, threads, internal structures, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304c36d43ad643a3a401b38816464fd6feff69ef" translate="yes" xml:space="preserve">
          <source>Lua provides a &lt;em&gt;registry&lt;/em&gt;, a predefined table that can be used by any C code to store whatever Lua values it needs to store. The registry table is always accessible at pseudo-index &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt;&lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt;&lt;/a&gt;. Any C library can store data into this table, but it must take care to choose keys that are different from those used by other libraries, to avoid collisions. Typically, you should use as key a string containing your library name, or a light userdata with the address of a C object in your code, or any Lua object created by your code. As with variable names, string keys starting with an underscore followed by uppercase letters are reserved for Lua.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff53c69b14f5a971156b01cea314fe8462f1fb40" translate="yes" xml:space="preserve">
          <source>Lua provides a &lt;em&gt;registry&lt;/em&gt;, a predefined table that can be used by any C code to store whatever Lua values it needs to store. The registry table is always located at pseudo-index &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt;&lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt;&lt;/a&gt;. Any C library can store data into this table, but it must take care to choose keys that are different from those used by other libraries, to avoid collisions. Typically, you should use as key a string containing your library name, or a light userdata with the address of a C object in your code, or any Lua object created by your code. As with variable names, string keys starting with an underscore followed by uppercase letters are reserved for Lua.</source>
          <target state="translated">Lua proporciona un &lt;em&gt;registro&lt;/em&gt; , una tabla predefinida que puede ser utilizada por cualquier c&amp;oacute;digo C para almacenar los valores de Lua que necesite almacenar. La tabla de registro siempre se encuentra en el &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt; &lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt; &lt;/a&gt; . Cualquier biblioteca de C puede almacenar datos en esta tabla, pero debe tener cuidado de elegir claves que sean diferentes de las que usan otras bibliotecas para evitar colisiones. Por lo general, debe usar como clave una cadena que contenga el nombre de su biblioteca, o un usuario ligero con la direcci&amp;oacute;n de un objeto C en su c&amp;oacute;digo, o cualquier objeto Lua creado por su c&amp;oacute;digo. Al igual que con los nombres de variables, las claves de cadena que comienzan con un gui&amp;oacute;n bajo seguido de letras may&amp;uacute;sculas est&amp;aacute;n reservadas para Lua.</target>
        </trans-unit>
        <trans-unit id="c7ec27426739f62c59f6fb19adc0cf4fd8e79bdf" translate="yes" xml:space="preserve">
          <source>Lua provides some automatic conversions between some types and representations at run time. Bitwise operators always convert float operands to integers. Exponentiation and float division always convert integer operands to floats. All other arithmetic operations applied to mixed numbers (integers and floats) convert the integer operand to a float. The C API also converts both integers to floats and floats to integers, as needed. Moreover, string concatenation accepts numbers as arguments, besides strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aebea72c222a51d9f5c90460286acb8ff7bd836" translate="yes" xml:space="preserve">
          <source>Lua provides some automatic conversions between some types and representations at run time. Bitwise operators always convert float operands to integers. Exponentiation and float division always convert integer operands to floats. All other arithmetic operations applied to mixed numbers (integers and floats) convert the integer operand to a float; this is called the &lt;em&gt;usual rule&lt;/em&gt;. The C API also converts both integers to floats and floats to integers, as needed. Moreover, string concatenation accepts numbers as arguments, besides strings.</source>
          <target state="translated">Lua proporciona algunas conversiones autom&amp;aacute;ticas entre algunos tipos y representaciones en tiempo de ejecuci&amp;oacute;n. Los operadores bit a bit siempre convierten operandos flotantes a enteros. La exponenciaci&amp;oacute;n y la divisi&amp;oacute;n flotante siempre convierten operandos enteros en flotantes. Todas las dem&amp;aacute;s operaciones aritm&amp;eacute;ticas aplicadas a n&amp;uacute;meros mixtos (enteros y flotantes) convierten el operando entero en un flotante; esto se llama la &lt;em&gt;regla habitual&lt;/em&gt; . La API de C tambi&amp;eacute;n convierte tanto enteros en flotantes como flotantes en enteros, seg&amp;uacute;n sea necesario. Adem&amp;aacute;s, la concatenaci&amp;oacute;n de cadenas acepta n&amp;uacute;meros como argumentos, adem&amp;aacute;s de cadenas.</target>
        </trans-unit>
        <trans-unit id="fc88527d32d4eef52fab883602cc5a04e027d076" translate="yes" xml:space="preserve">
          <source>Lua supports an almost conventional set of statements, similar to those in Pascal or C. This set includes assignments, control structures, function calls, and variable declarations.</source>
          <target state="translated">Lua soporta un conjunto de declaraciones casi convencionales,similares a las de Pascal o C.Este conjunto incluye asignaciones,estructuras de control,llamadas a funciones y declaraciones variables.</target>
        </trans-unit>
        <trans-unit id="91dafa2daf60652dca7a18b91e3e12584dce5ecb" translate="yes" xml:space="preserve">
          <source>Lua supports an almost conventional set of statements, similar to those in other conventional languages. This set includes blocks, assignments, control structures, function calls, and variable declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d24c360e7097470e8a9eb4284ea5f5a81791560b" translate="yes" xml:space="preserve">
          <source>Lua supports coroutines, also called &lt;em&gt;collaborative multithreading&lt;/em&gt;. A coroutine in Lua represents an independent thread of execution. Unlike threads in multithread systems, however, a coroutine only suspends its execution by explicitly calling a yield function.</source>
          <target state="translated">Lua admite corrutinas, tambi&amp;eacute;n llamadas &lt;em&gt;multiproceso colaborativo&lt;/em&gt; . Una corrutina en Lua representa un hilo de ejecuci&amp;oacute;n independiente. Sin embargo, a diferencia de los subprocesos en los sistemas de subprocesos m&amp;uacute;ltiples, una corrutina solo suspende su ejecuci&amp;oacute;n llamando expl&amp;iacute;citamente a una funci&amp;oacute;n de rendimiento.</target>
        </trans-unit>
        <trans-unit id="3591c85e3de8f7bdc4a45d500a8261a9e6ec09be" translate="yes" xml:space="preserve">
          <source>Lua supports the following arithmetic operators:</source>
          <target state="translated">Lua apoya a los siguientes operadores aritméticos:</target>
        </trans-unit>
        <trans-unit id="f0e5bf2dcec5e267f3660839f8aee19d34a65569" translate="yes" xml:space="preserve">
          <source>Lua supports the following bitwise operators:</source>
          <target state="translated">Lua apoya a los siguientes operadores de bits:</target>
        </trans-unit>
        <trans-unit id="681beb7c86ad47856fd70c3b7329189c44c67f13" translate="yes" xml:space="preserve">
          <source>Lua supports the following relational operators:</source>
          <target state="translated">Lua apoya a los siguientes operadores relacionales:</target>
        </trans-unit>
        <trans-unit id="ea7647f42e558dda5334904038fac1e7ced0aeee" translate="yes" xml:space="preserve">
          <source>Lua treats the continuation function as if it were the original function. The continuation function receives the same Lua stack from the original function, in the same state it would be if the callee function had returned. (For instance, after a &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; the function and its arguments are removed from the stack and replaced by the results from the call.) It also has the same upvalues. Whatever it returns is handled by Lua as if it were the return of the original function.</source>
          <target state="translated">Lua trata la funci&amp;oacute;n de continuaci&amp;oacute;n como si fuera la funci&amp;oacute;n original. La funci&amp;oacute;n de continuaci&amp;oacute;n recibe la misma pila Lua de la funci&amp;oacute;n original, en el mismo estado que estar&amp;iacute;a si la funci&amp;oacute;n de llamada hubiera regresado. (Por ejemplo, despu&amp;eacute;s de un &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; ,&lt;/a&gt; la funci&amp;oacute;n y sus argumentos se eliminan de la pila y se reemplazan por los resultados de la llamada). Tambi&amp;eacute;n tiene los mismos valores superiores. Todo lo que devuelve es manejado por Lua como si fuera el retorno de la funci&amp;oacute;n original.</target>
        </trans-unit>
        <trans-unit id="8d18554a7115d65153a0cecb32181cd5cd13b803" translate="yes" xml:space="preserve">
          <source>Lua uses a &lt;em&gt;virtual stack&lt;/em&gt; to pass values to and from C. Each element in this stack represents a Lua value (&lt;b&gt;nil&lt;/b&gt;, number, string, etc.). Functions in the API can access this stack through the Lua state parameter that they receive.</source>
          <target state="translated">Lua usa una &lt;em&gt;pila virtual&lt;/em&gt; para pasar valores ay desde C. Cada elemento de esta pila representa un valor Lua ( &lt;b&gt;nulo&lt;/b&gt; , n&amp;uacute;mero, cadena, etc.). Las funciones de la API pueden acceder a esta pila a trav&amp;eacute;s del par&amp;aacute;metro de estado Lua que reciben.</target>
        </trans-unit>
        <trans-unit id="9ab5b312f28e26ecbcf6e086d97bd76369eeeb34" translate="yes" xml:space="preserve">
          <source>Lua versions can always change the C API in ways that do not imply source-code changes in a program, such as the numeric values for constants or the implementation of functions as macros. Therefore, you should never assume that binaries are compatible between different Lua versions. Always recompile clients of the Lua API when using a new version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="225017af8d199117d297936391565191b16afd75" translate="yes" xml:space="preserve">
          <source>Lua versions can always change the C API in ways that do not imply source-code changes in a program, such as the numeric values for constants or the implementation of functions as macros. Therefore, you should not assume that binaries are compatible between different Lua versions. Always recompile clients of the Lua API when using a new version.</source>
          <target state="translated">Las versiones de Lua siempre pueden cambiar la API de C de maneras que no impliquen cambios en el código fuente de un programa,como los valores numéricos de las constantes o la implementación de funciones como macros.Por lo tanto,no se debe asumir que los binarios son compatibles entre las diferentes versiones de Lua.Siempre recompile los clientes de la API de Lua cuando utilice una nueva versión.</target>
        </trans-unit>
        <trans-unit id="d9819702e70f7dce9f1483706cfae2f70bcb9e32" translate="yes" xml:space="preserve">
          <source>Macros to project non-default integer types (&lt;code&gt;luaL_checkint&lt;/code&gt;, &lt;code&gt;luaL_optint&lt;/code&gt;, &lt;code&gt;luaL_checklong&lt;/code&gt;, &lt;code&gt;luaL_optlong&lt;/code&gt;) were deprecated. Use their equivalent over &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt; with a type cast (or, when possible, use &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt; in your code).</source>
          <target state="translated">Las macros para proyectar tipos de enteros no predeterminados ( &lt;code&gt;luaL_checkint&lt;/code&gt; , &lt;code&gt;luaL_optint&lt;/code&gt; , &lt;code&gt;luaL_checklong&lt;/code&gt; , &lt;code&gt;luaL_optlong&lt;/code&gt; ) quedaron obsoletas. Use su equivalente sobre &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; con un tipo de conversi&amp;oacute;n (o, cuando sea posible, use &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; en su c&amp;oacute;digo).</target>
        </trans-unit>
        <trans-unit id="b77ee37c1b7bd6807618cb75d302c1c6fbf5df15" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;n1&lt;/code&gt;-th upvalue of the Lua closure &lt;code&gt;f1&lt;/code&gt; refer to the &lt;code&gt;n2&lt;/code&gt;-th upvalue of the Lua closure &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">Haga que el &lt;code&gt;n1&lt;/code&gt; -&amp;eacute;simo valor al alza del cierre Lua &lt;code&gt;f1&lt;/code&gt; se refiera al &lt;code&gt;n2&lt;/code&gt; -&amp;eacute;simo valor al alza del cierre Lua &lt;code&gt;f2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62787e3133e3f8c1540f23ea948a696e338e2fa1" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;n1&lt;/code&gt;-th upvalue of the Lua closure at index &lt;code&gt;funcindex1&lt;/code&gt; refer to the &lt;code&gt;n2&lt;/code&gt;-th upvalue of the Lua closure at index &lt;code&gt;funcindex2&lt;/code&gt;.</source>
          <target state="translated">Haga que el &lt;code&gt;n1&lt;/code&gt; -&amp;eacute;simo valor al alza del cierre de Lua en el &amp;iacute;ndice &lt;code&gt;funcindex1&lt;/code&gt; se refiera al &lt;code&gt;n2&lt;/code&gt; -&amp;eacute;simo valor al alza del cierre Lua en el &amp;iacute;ndice &lt;code&gt;funcindex2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f45634619c3458c08eba16dfa423d4f5456e189b" translate="yes" xml:space="preserve">
          <source>Marks the given index in the stack as a to-be-closed &quot;variable&quot; (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;). Like a to-be-closed variable in Lua, the value at that index in the stack will be closed when it goes out of scope. Here, in the context of a C function, to go out of scope means that the running function returns to Lua, there is an error, or the index is removed from the stack through &lt;a href=&quot;#lua_settop&quot;&gt;&lt;code&gt;lua_settop&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pop&quot;&gt;&lt;code&gt;lua_pop&lt;/code&gt;&lt;/a&gt;. An index marked as to-be-closed should not be removed from the stack by any other function in the API except &lt;a href=&quot;#lua_settop&quot;&gt;&lt;code&gt;lua_settop&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pop&quot;&gt;&lt;code&gt;lua_pop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0580c95da4f3ceb84abf5c18ee164021809ea4c" translate="yes" xml:space="preserve">
          <source>Metatables and Metamethods</source>
          <target state="translated">Metatables y Metamétodos</target>
        </trans-unit>
        <trans-unit id="4feff686bfbdf59cf154d1294db67c187b9f7489" translate="yes" xml:space="preserve">
          <source>Modulo is defined as the remainder of a division that rounds the quotient towards minus infinity (floor division).</source>
          <target state="translated">El módulo se define como el resto de una división que redondea el cociente hacia el menos infinito (división de piso).</target>
        </trans-unit>
        <trans-unit id="71e2b3ce8af16f1677267e51894cb5b57ee61429" translate="yes" xml:space="preserve">
          <source>Moreover, with a &lt;code&gt;count&lt;/code&gt; different from zero, the hook is called also after every &lt;code&gt;count&lt;/code&gt; instructions.</source>
          <target state="translated">Adem&amp;aacute;s, con un &lt;code&gt;count&lt;/code&gt; diferente de cero, el gancho tambi&amp;eacute;n se llama despu&amp;eacute;s de cada instrucci&amp;oacute;n de &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68a5432576b0a8367df52ec04ef603f754149162" translate="yes" xml:space="preserve">
          <source>Most functions in the API can raise an error, for instance due to a memory allocation error. The documentation for each function indicates whether it can raise errors.</source>
          <target state="translated">La mayoría de las funciones de la API pueden dar lugar a un error,por ejemplo,debido a un error de asignación de memoria.En la documentación de cada función se indica si puede provocar errores.</target>
        </trans-unit>
        <trans-unit id="211349efeacad71bfc6580d063e630f7c7ac8b51" translate="yes" xml:space="preserve">
          <source>Moves elements from table &lt;code&gt;a1&lt;/code&gt; to table &lt;code&gt;a2&lt;/code&gt;, performing the equivalent to the following multiple assignment: &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt;. The default for &lt;code&gt;a2&lt;/code&gt; is &lt;code&gt;a1&lt;/code&gt;. The destination range can overlap with the source range. The number of elements to be moved must fit in a Lua integer.</source>
          <target state="translated">Mueve elementos de la tabla &lt;code&gt;a1&lt;/code&gt; a la tabla &lt;code&gt;a2&lt;/code&gt; , realizando el equivalente a la siguiente asignaci&amp;oacute;n m&amp;uacute;ltiple: &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt; . El valor predeterminado para &lt;code&gt;a2&lt;/code&gt; es &lt;code&gt;a1&lt;/code&gt; . El rango de destino puede superponerse con el rango de origen. El n&amp;uacute;mero de elementos que se mover&amp;aacute;n debe caber en un entero Lua.</target>
        </trans-unit>
        <trans-unit id="510e5879338c47950130f12189e321dcf4ce36c2" translate="yes" xml:space="preserve">
          <source>Moves elements from the table &lt;code&gt;a1&lt;/code&gt; to the table &lt;code&gt;a2&lt;/code&gt;, performing the equivalent to the following multiple assignment: &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt;. The default for &lt;code&gt;a2&lt;/code&gt; is &lt;code&gt;a1&lt;/code&gt;. The destination range can overlap with the source range. The number of elements to be moved must fit in a Lua integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2bdd0bd3d59fce772f98ee9eb7eb0b3b6d4a93" translate="yes" xml:space="preserve">
          <source>Moves the top element into the given valid index without shifting any element (therefore replacing the value at that given index), and then pops the top element.</source>
          <target state="translated">Mueve el elemento superior en el índice válido dado sin desplazar ningún elemento (reemplazando por lo tanto el valor en ese índice dado),y luego hace saltar el elemento superior.</target>
        </trans-unit>
        <trans-unit id="4e0c82df95dd4d912151141c645e29919783b9cd" translate="yes" xml:space="preserve">
          <source>Moves the top element into the given valid index, shifting up the elements above this index to open space. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">Mueve el elemento superior al índice válido dado,desplazando hacia arriba los elementos por encima de este índice al espacio abierto.Esta función no puede ser llamada con un pseudoíndice,porque un pseudoíndice no es una posición real de la pila.</target>
        </trans-unit>
        <trans-unit id="391a0967919882d8d7da074ecd835868b9ad0813" translate="yes" xml:space="preserve">
          <source>Multiple matches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ebf3f60d00dc82250b0b628b803e44dd494422" translate="yes" xml:space="preserve">
          <source>Name denotes identifiers (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b225abd3f0033a18a8e56044eee89e7ebbd191" translate="yes" xml:space="preserve">
          <source>Name denotes identifiers, as defined in &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;.</source>
          <target state="translated">Nombre denota identificadores, como se define en &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="132dfdc791b8ee51cdbc214b5f4f4d7ac599cf90" translate="yes" xml:space="preserve">
          <source>Native endianness assumes that the whole system is either big or little endian. The packing functions will not emulate correctly the behavior of mixed-endian formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff07f80cb3da5ffaa1ac22e6dac9b937f6ab24f" translate="yes" xml:space="preserve">
          <source>Nonetheless, it is always a good practice not to rely on these implicit coercions, as they are not always applied; in particular, &lt;code&gt;&quot;1&quot;==1&lt;/code&gt; is false and &lt;code&gt;&quot;1&quot;&amp;lt;1&lt;/code&gt; raises an error (see &lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt;). These coercions exist mainly for compatibility and may be removed in future versions of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14931c9658b2e9143b168a9666b173cd80e49603" translate="yes" xml:space="preserve">
          <source>Note that Standard C ensures that &lt;code&gt;free(NULL)&lt;/code&gt; has no effect and that &lt;code&gt;realloc(NULL,size)&lt;/code&gt; is equivalent to &lt;code&gt;malloc(size)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fb92775055c34d37036245800bd4e66793f8802" translate="yes" xml:space="preserve">
          <source>Note that Standard C ensures that &lt;code&gt;free(NULL)&lt;/code&gt; has no effect and that &lt;code&gt;realloc(NULL,size)&lt;/code&gt; is equivalent to &lt;code&gt;malloc(size)&lt;/code&gt;. This code assumes that &lt;code&gt;realloc&lt;/code&gt; does not fail when shrinking a block. (Although Standard C does not ensure this behavior, it seems to be a safe assumption.)</source>
          <target state="translated">Tenga en cuenta que el est&amp;aacute;ndar C asegura que &lt;code&gt;free(NULL)&lt;/code&gt; no tiene ning&amp;uacute;n efecto y que &lt;code&gt;realloc(NULL,size)&lt;/code&gt; es equivalente a &lt;code&gt;malloc(size)&lt;/code&gt; . Este c&amp;oacute;digo asume que &lt;code&gt;realloc&lt;/code&gt; no falla al encoger un bloque. (Aunque el est&amp;aacute;ndar C no garantiza este comportamiento, parece ser una suposici&amp;oacute;n segura).</target>
        </trans-unit>
        <trans-unit id="7a567518fb3007e639daf24d7ac35ede7aba1d84" translate="yes" xml:space="preserve">
          <source>Note that commands for &lt;code&gt;debug.debug&lt;/code&gt; are not lexically nested within any function and so have no direct access to local variables.</source>
          <target state="translated">Tenga en cuenta que los comandos para &lt;code&gt;debug.debug&lt;/code&gt; no est&amp;aacute;n anidados l&amp;eacute;xicamente dentro de ninguna funci&amp;oacute;n y por lo tanto no tienen acceso directo a las variables locales.</target>
        </trans-unit>
        <trans-unit id="a3819f26854d326b0f73d55f7e4a2133dc45716a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;comp&lt;/code&gt; function must define a strict partial order over the elements in the list; that is, it must be asymmetric and transitive. Otherwise, no valid sort may be possible.</source>
          <target state="translated">Tenga en cuenta que la funci&amp;oacute;n &lt;code&gt;comp&lt;/code&gt; debe definir un orden parcial estricto sobre los elementos de la lista; es decir, debe ser asim&amp;eacute;trico y transitivo. De lo contrario, es posible que no sea posible una clasificaci&amp;oacute;n v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="1dab5c0bc6e3b7d33e45552977787711c9e9cd82" translate="yes" xml:space="preserve">
          <source>Note that the code above is &lt;em&gt;balanced&lt;/em&gt;: at its end, the stack is back to its original configuration. This is considered good programming practice.</source>
          <target state="translated">Tenga en cuenta que el c&amp;oacute;digo anterior est&amp;aacute; &lt;em&gt;equilibrado&lt;/em&gt; : al final, la pila vuelve a su configuraci&amp;oacute;n original. Esto se considera una buena pr&amp;aacute;ctica de programaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="27456ef634a2ef274b5d4e632f792b2f499755a1" translate="yes" xml:space="preserve">
          <source>Note that, both in case of errors and of a regular return, by the time the &lt;code&gt;__close&lt;/code&gt; metamethod runs, the C stack was already unwound, so that any automatic C variable declared in the calling function will be out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f095d9ef1108e5d2ebeb20830f7a9cdf31641d73" translate="yes" xml:space="preserve">
          <source>Note the external, explicit call to the continuation: Lua will call the continuation only if needed, that is, in case of errors or resuming after a yield. If the called function returns normally without ever yielding, &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;) will also return normally. (Of course, instead of calling the continuation in that case, you can do the equivalent work directly inside the original function.)</source>
          <target state="translated">Tenga en cuenta la llamada externa y expl&amp;iacute;cita a la continuaci&amp;oacute;n: Lua llamar&amp;aacute; a la continuaci&amp;oacute;n solo si es necesario, es decir, en caso de errores o reanudando despu&amp;eacute;s de un rendimiento. Si la funci&amp;oacute;n llamada regresa normalmente sin ceder, &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; (y &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; ) tambi&amp;eacute;n regresar&amp;aacute; normalmente. (Por supuesto, en lugar de llamar a la continuaci&amp;oacute;n en ese caso, puede hacer el trabajo equivalente directamente dentro de la funci&amp;oacute;n original).</target>
        </trans-unit>
        <trans-unit id="20d78a8e421517dfc8501178399cb2a435e63306" translate="yes" xml:space="preserve">
          <source>Note the following:</source>
          <target state="translated">Tenga en cuenta lo siguiente:</target>
        </trans-unit>
        <trans-unit id="143069908049a001ca51a83cef0a8d3fcbe11397" translate="yes" xml:space="preserve">
          <source>Notice that each execution of a &lt;b&gt;local&lt;/b&gt; statement defines new local variables. Consider the following example:</source>
          <target state="translated">Observe que cada ejecuci&amp;oacute;n de una declaraci&amp;oacute;n &lt;b&gt;local&lt;/b&gt; define nuevas variables locales. Considere el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="fcc164423a09d2953e5486a056f1e10293de0711" translate="yes" xml:space="preserve">
          <source>Notice that, in a declaration like &lt;code&gt;local x = x&lt;/code&gt;, the new &lt;code&gt;x&lt;/code&gt; being declared is not in scope yet, and so the second &lt;code&gt;x&lt;/code&gt; refers to the outside variable.</source>
          <target state="translated">Observe que, en una declaraci&amp;oacute;n como &lt;code&gt;local x = x&lt;/code&gt; , la nueva &lt;code&gt;x&lt;/code&gt; que se declara a&amp;uacute;n no est&amp;aacute; dentro del alcance, por lo que la segunda &lt;code&gt;x&lt;/code&gt; se refiere a la variable externa.</target>
        </trans-unit>
        <trans-unit id="d213f09117ec25cd2306bbea812a90e0c2b8aabb" translate="yes" xml:space="preserve">
          <source>Now we want to allow the Lua code being run by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; to yield. First, we can rewrite our function like here:</source>
          <target state="translated">Ahora queremos permitir que el c&amp;oacute;digo Lua que est&amp;aacute; ejecutando &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; ceda. Primero, podemos reescribir nuestra funci&amp;oacute;n como aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="754d929d0f6f3e09a813d3e11d5cb6448eada594" translate="yes" xml:space="preserve">
          <source>Numerals and literal strings are explained in &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;; variables are explained in &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt;; function definitions are explained in &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;; function calls are explained in &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;; table constructors are explained in &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt;. Vararg expressions, denoted by three dots ('&lt;code&gt;...&lt;/code&gt;'), can only be used when directly inside a vararg function; they are explained in &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;.</source>
          <target state="translated">Los n&amp;uacute;meros y cadenas literales se explican en &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; ; las variables se explican en &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; ; las definiciones de funciones se explican en &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; ; las llamadas a funciones se explican en &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; ; Los constructores de tablas se explican en &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt; . Las expresiones vararg, denotadas por tres puntos (' &lt;code&gt;...&lt;/code&gt; '), solo pueden usarse cuando est&amp;aacute;n directamente dentro de una funci&amp;oacute;n vararg; se explican en &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ef3b305c58fad6f6199b8fc85c384f4f0aec1bf" translate="yes" xml:space="preserve">
          <source>Numeric codes are not necessarily portable across platforms.</source>
          <target state="translated">Los códigos numéricos no son necesariamente portátiles entre plataformas.</target>
        </trans-unit>
        <trans-unit id="b0a0e9260ed5a6d09f75bd0cd4a96d473084f65f" translate="yes" xml:space="preserve">
          <source>Of course, the location of the Lua interpreter may be different in your machine. If &lt;code&gt;lua&lt;/code&gt; is in your &lt;code&gt;PATH&lt;/code&gt;, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e9a773eef8de621ab2c2acf9814098928b38f7" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).</source>
          <target state="translated">En los sistemas POSIX,esta función también crea un archivo con ese nombre,para evitar riesgos de seguridad.(Alguien más podría crear el archivo con permisos equivocados en el tiempo que transcurre entre la obtención del nombre y la creación del archivo).Todavía tiene que abrir el archivo para usarlo y eliminarlo (aunque no lo use).</target>
        </trans-unit>
        <trans-unit id="b4eb9b31d3cdaa19214342b44ace3c1948a9b1c8" translate="yes" xml:space="preserve">
          <source>On non-POSIX systems, this function may be not thread safe because of its reliance on C function &lt;code&gt;gmtime&lt;/code&gt; and C function &lt;code&gt;localtime&lt;/code&gt;.</source>
          <target state="translated">En sistemas que no son POSIX, esta funci&amp;oacute;n puede no ser segura para subprocesos debido a su dependencia de la funci&amp;oacute;n C &lt;code&gt;gmtime&lt;/code&gt; y la funci&amp;oacute;n C &lt;code&gt;localtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="327d9d40cc45661d18c144b659d732ccb083e105" translate="yes" xml:space="preserve">
          <source>On several platforms, you may not need to call this function, because all resources are naturally released when the host program ends. On the other hand, long-running programs that create multiple states, such as daemons or web servers, will probably need to close states as soon as they are not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087e8ef073a71f75716b2985ce5b0a8533e700f2" translate="yes" xml:space="preserve">
          <source>Once a loader is found, &lt;code&gt;require&lt;/code&gt; calls the loader with two arguments: &lt;code&gt;modname&lt;/code&gt; and an extra value dependent on how it got the loader. (If the loader came from a file, this extra value is the file name.) If the loader returns any non-nil value, &lt;code&gt;require&lt;/code&gt; assigns the returned value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;. If the loader does not return a non-nil value and has not assigned any value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;, then &lt;code&gt;require&lt;/code&gt; assigns &lt;b&gt;true&lt;/b&gt; to this entry. In any case, &lt;code&gt;require&lt;/code&gt; returns the final value of &lt;code&gt;package.loaded[modname]&lt;/code&gt;.</source>
          <target state="translated">Una vez que se encuentra un cargador, &lt;code&gt;require&lt;/code&gt; llama al cargador con dos argumentos: &lt;code&gt;modname&lt;/code&gt; y un valor adicional que depende de c&amp;oacute;mo obtuvo el cargador. (Si el cargador proviene de un archivo, este valor adicional es el nombre del archivo). Si el cargador devuelve un valor que no sea nulo, &lt;code&gt;require&lt;/code&gt; asigna el valor devuelto a &lt;code&gt;package.loaded[modname]&lt;/code&gt; . Si el cargador no devuelve un valor distinto de nulo y no ha asignado ning&amp;uacute;n valor a &lt;code&gt;package.loaded[modname]&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; asigna &lt;b&gt;verdadero&lt;/b&gt; a esta entrada. En cualquier caso, &lt;code&gt;require&lt;/code&gt; devuelve el valor final de &lt;code&gt;package.loaded[modname]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf51682813139c6b06902191dce5e737d2d9c9a1" translate="yes" xml:space="preserve">
          <source>Once a loader is found, &lt;code&gt;require&lt;/code&gt; calls the loader with two arguments: &lt;code&gt;modname&lt;/code&gt; and an extra value, a &lt;em&gt;loader data&lt;/em&gt;, also returned by the searcher. The loader data can be any value useful to the module; for the default searchers, it indicates where the loader was found. (For instance, if the loader came from a file, this extra value is the file path.) If the loader returns any non-nil value, &lt;code&gt;require&lt;/code&gt; assigns the returned value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;. If the loader does not return a non-nil value and has not assigned any value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;, then &lt;code&gt;require&lt;/code&gt; assigns &lt;b&gt;true&lt;/b&gt; to this entry. In any case, &lt;code&gt;require&lt;/code&gt; returns the final value of &lt;code&gt;package.loaded[modname]&lt;/code&gt;. Besides that value, &lt;code&gt;require&lt;/code&gt; also returns as a second result the loader data returned by the searcher, which indicates how &lt;code&gt;require&lt;/code&gt; found the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f13732846387f19dd5d62a467bb6af8a9e77c4" translate="yes" xml:space="preserve">
          <source>Only objects that have an explicit construction are removed from weak tables. Values, such as numbers and light C functions, are not subject to garbage collection, and therefore are not removed from weak tables (unless their associated values are collected). Although strings are subject to garbage collection, they do not have an explicit construction and their equality is by value; they behave more like values than like objects. Therefore, they are not removed from weak tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd79eaea9e398294fa6609bcc37919375540b811" translate="yes" xml:space="preserve">
          <source>Only objects that have an explicit construction are removed from weak tables. Values, such as numbers and light C functions, are not subject to garbage collection, and therefore are not removed from weak tables (unless their associated values are collected). Although strings are subject to garbage collection, they do not have an explicit construction, and therefore are not removed from weak tables.</source>
          <target state="translated">Sólo los objetos que tienen una construcción explícita son retirados de las mesas débiles.Los valores,como los números y las funciones C ligeras,no están sujetos a la recogida de basura y,por lo tanto,no se eliminan de las tablas débiles (a menos que se recojan sus valores asociados).Aunque las cadenas están sujetas a la recogida de basura,no tienen una construcción explícita y,por lo tanto,no se eliminan de las tablas débiles.</target>
        </trans-unit>
        <trans-unit id="b08de619674921c221a144a642faade8131401ce" translate="yes" xml:space="preserve">
          <source>Opens all standard Lua libraries into the given state.</source>
          <target state="translated">Abre todas las bibliotecas estándar de Lua en el estado dado.</target>
        </trans-unit>
        <trans-unit id="fed8115b8cb0d575a6d2ddd5024ea0f4b7c2651d" translate="yes" xml:space="preserve">
          <source>Opens the given file name in read mode and returns an iterator function that works like &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; over the opened file. When the iterator function detects the end of file, it returns no values (to finish the loop) and automatically closes the file.</source>
          <target state="translated">Abre el nombre de archivo dado en modo lectura y devuelve una funci&amp;oacute;n de iterador que funciona como &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; sobre el archivo abierto. Cuando la funci&amp;oacute;n de iterador detecta el final del archivo, no devuelve ning&amp;uacute;n valor (para finalizar el ciclo) y cierra autom&amp;aacute;ticamente el archivo.</target>
        </trans-unit>
        <trans-unit id="94b0d085d949942fdb3fb646a2df4ce4d0e5c72f" translate="yes" xml:space="preserve">
          <source>Opens the given file name in read mode and returns an iterator function that works like &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; over the opened file. When the iterator function fails to read any value, it automatically closes the file. Besides the iterator function, &lt;code&gt;io.lines&lt;/code&gt; returns three other values: two &lt;b&gt;nil&lt;/b&gt; values as placeholders, plus the created file handle. Therefore, when used in a generic &lt;b&gt;for&lt;/b&gt; loop, the file is closed also if the loop is interrupted by an error or a &lt;b&gt;break&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9790a0effb3e0767d24700689fb5bce0eb0f23" translate="yes" xml:space="preserve">
          <source>Opens the named file and executes its content as a Lua chunk. When called without arguments, &lt;code&gt;dofile&lt;/code&gt; executes the content of the standard input (&lt;code&gt;stdin&lt;/code&gt;). Returns all values returned by the chunk. In case of errors, &lt;code&gt;dofile&lt;/code&gt; propagates the error to its caller. (That is, &lt;code&gt;dofile&lt;/code&gt; does not run in protected mode.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4996bd3a029769976e9b98ed2378b1547c48ce7d" translate="yes" xml:space="preserve">
          <source>Opens the named file and executes its contents as a Lua chunk. When called without arguments, &lt;code&gt;dofile&lt;/code&gt; executes the contents of the standard input (&lt;code&gt;stdin&lt;/code&gt;). Returns all values returned by the chunk. In case of errors, &lt;code&gt;dofile&lt;/code&gt; propagates the error to its caller (that is, &lt;code&gt;dofile&lt;/code&gt; does not run in protected mode).</source>
          <target state="translated">Abre el archivo nombrado y ejecuta su contenido como un fragmento de Lua. Cuando se llama sin argumentos, &lt;code&gt;dofile&lt;/code&gt; ejecuta el contenido de la entrada est&amp;aacute;ndar ( &lt;code&gt;stdin&lt;/code&gt; ). Devuelve todos los valores devueltos por el fragmento. En caso de errores, &lt;code&gt;dofile&lt;/code&gt; propaga el error a su llamador (es decir, &lt;code&gt;dofile&lt;/code&gt; no se ejecuta en modo protegido).</target>
        </trans-unit>
        <trans-unit id="1b77184a8e40f826198903ec77c88ff94fba7356" translate="yes" xml:space="preserve">
          <source>Operator precedence in Lua follows the table below, from lower to higher priority:</source>
          <target state="translated">La precedencia de los operadores en Lua sigue el cuadro que figura a continuación,de menor a mayor prioridad:</target>
        </trans-unit>
        <trans-unit id="5d68118be76331913c2ce7bb079ac0bdce1e02a7" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;s&lt;/code&gt; expects a string; if its argument is not a string, it is converted to one following the same rules of &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;. If the option has any modifier (flags, width, length), the string argument should not contain embedded zeros.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;s&lt;/code&gt; espera una cadena; si su argumento no es una cadena, se convierte en una que sigue las mismas reglas de &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; . Si la opci&amp;oacute;n tiene alg&amp;uacute;n modificador (banderas, ancho, largo), el argumento de cadena no debe contener ceros incrustados.</target>
        </trans-unit>
        <trans-unit id="87ca1fbe6a8feba28ed3fc6964e861a77643303f" translate="yes" xml:space="preserve">
          <source>Option names in &lt;a href=&quot;#pdf-io.read&quot;&gt;&lt;code&gt;io.read&lt;/code&gt;&lt;/a&gt; do not have a starting '&lt;code&gt;*&lt;/code&gt;' anymore. For compatibility, Lua will continue to accept (and ignore) this character.</source>
          <target state="translated">Los nombres de las opciones en &lt;a href=&quot;#pdf-io.read&quot;&gt; &lt;code&gt;io.read&lt;/code&gt; &lt;/a&gt; ya no tienen un ' &lt;code&gt;*&lt;/code&gt; ' inicial . Por compatibilidad, Lua seguir&amp;aacute; aceptando (e ignorando) este car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="b8e36de59136b88fc2be5c019f1c1af0d901d853" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, and &lt;code&gt;g&lt;/code&gt; all expect a number as argument. Options &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; expect an integer. When Lua is compiled with a C89 compiler, options &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; (hexadecimal floats) do not support any modifier (flags, width, length).</source>
          <target state="translated">Opciones &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt; y &lt;code&gt;g&lt;/code&gt; todos esperamos un n&amp;uacute;mero como argumento. Las opciones &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; esperan un n&amp;uacute;mero entero. Cuando Lua se compila con un compilador C89, las opciones &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; (flotantes hexadecimales) no admiten ning&amp;uacute;n modificador (banderas, ancho, largo).</target>
        </trans-unit>
        <trans-unit id="8a1abeaa4ebe74d5340ad5d927126ab129362a92" translate="yes" xml:space="preserve">
          <source>Otherwise, returns three values: the &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; function, the table &lt;code&gt;t&lt;/code&gt;, and &lt;b&gt;nil&lt;/b&gt;, so that the construction</source>
          <target state="translated">De lo contrario, devuelve tres valores: la &lt;a href=&quot;#pdf-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n, la tabla &lt;code&gt;t&lt;/code&gt; , y &lt;b&gt;nil&lt;/b&gt; , de modo que la construcci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="178c0a8da555da3fb52bb9fe10047627cb505e75" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;ar&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;ar&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; son como en la funci&amp;oacute;n &lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8dc64fc2f4cd99c0ced65561a7ce6e7af2b4bf51" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;ar&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in the function &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea29796519b03e49b8f299281d87fde989109ec" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;n&lt;/code&gt; cannot be greater than the number of upvalues.</source>
          <target state="translated">Par&amp;aacute;metros &lt;code&gt;funcindex&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; son como en la funci&amp;oacute;n &lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt; , pero &lt;code&gt;n&lt;/code&gt; no puede ser mayor que el n&amp;uacute;mero de upvalues.</target>
        </trans-unit>
        <trans-unit id="430e32c1c643e4f1d035c6b28b1a7ed4bf4a0eac" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Par&amp;aacute;metros &lt;code&gt;funcindex&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; son como en la funci&amp;oacute;n &lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc00bbb5ef17f161e882643cc3eb1de5624c1761" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in the function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;n&lt;/code&gt; cannot be greater than the number of upvalues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4fbfbc25528bfc37258607c935be76b6d23f936" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in the function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5ec09aef437013e06ea8a8354f4fd26022ed2a" translate="yes" xml:space="preserve">
          <source>Parameters act as local variables that are initialized with the argument values:</source>
          <target state="translated">Los parámetros actúan como variables locales que se inicializan con los valores de los argumentos:</target>
        </trans-unit>
        <trans-unit id="448ecaf1d946410d7f3122c5e30729943106812b" translate="yes" xml:space="preserve">
          <source>Pattern Item:</source>
          <target state="translated">Artículo de patrón:</target>
        </trans-unit>
        <trans-unit id="5da899e9024f2b8d94cc4514fe33d4ff85310e83" translate="yes" xml:space="preserve">
          <source>Pattern:</source>
          <target state="translated">Pattern:</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="8d2dcea1a0ef2ec1d9376ec9b8afe27c3f59c3e3" translate="yes" xml:space="preserve">
          <source>Patterns in Lua are described by regular strings, which are interpreted as patterns by the pattern-matching functions &lt;a href=&quot;#pdf-string.find&quot;&gt;&lt;code&gt;string.find&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.gmatch&quot;&gt;&lt;code&gt;string.gmatch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.gsub&quot;&gt;&lt;code&gt;string.gsub&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-string.match&quot;&gt;&lt;code&gt;string.match&lt;/code&gt;&lt;/a&gt;. This section describes the syntax and the meaning (that is, what they match) of these strings.</source>
          <target state="translated">Los patrones en Lua se describen mediante cadenas regulares, que se interpretan como patrones mediante las funciones de coincidencia de patrones &lt;a href=&quot;#pdf-string.find&quot;&gt; &lt;code&gt;string.find&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-string.gmatch&quot;&gt; &lt;code&gt;string.gmatch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-string.gsub&quot;&gt; &lt;code&gt;string.gsub&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#pdf-string.match&quot;&gt; &lt;code&gt;string.match&lt;/code&gt; &lt;/a&gt; . Esta secci&amp;oacute;n describe la sintaxis y el significado (es decir, con qu&amp;eacute; coinciden) de estas cadenas.</target>
        </trans-unit>
        <trans-unit id="dc7394297e26f026260d375d7cd96592fbd9339e" translate="yes" xml:space="preserve">
          <source>Performs an arithmetic or bitwise operation over the two values (or one, in the case of negations) at the top of the stack, with the value at the top being the second operand, pops these values, and pushes the result of the operation. The function follows the semantics of the corresponding Lua operator (that is, it may call metamethods).</source>
          <target state="translated">Realiza una operación aritmética o bitácora sobre los dos valores (o uno,en el caso de las negaciones)en la parte superior de la pila,siendo el valor de la parte superior el segundo operando,hace saltar estos valores y empuja el resultado de la operación.La función sigue la semántica del operador Lua correspondiente (es decir,puede llamarse metamétodos).</target>
        </trans-unit>
        <trans-unit id="1fd5e0033b4343c024b4c61550d5dda42703ec57" translate="yes" xml:space="preserve">
          <source>Performs an arithmetic or bitwise operation over the two values (or one, in the case of negations) at the top of the stack, with the value on the top being the second operand, pops these values, and pushes the result of the operation. The function follows the semantics of the corresponding Lua operator (that is, it may call metamethods).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7dc30bd933bbb4baaecee808c6149d39035466" translate="yes" xml:space="preserve">
          <source>Pointers to strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1299b0bc498833db75f9cf0fffff3c4bae0facff" translate="yes" xml:space="preserve">
          <source>Pops &lt;code&gt;n&lt;/code&gt; elements from the stack.</source>
          <target state="translated">Saca &lt;code&gt;n&lt;/code&gt; elementos de la pila.</target>
        </trans-unit>
        <trans-unit id="fcc747279637a2d8a447881433d9aea7cb9cb559" translate="yes" xml:space="preserve">
          <source>Pops a key from the stack, and pushes a key&amp;ndash;value pair from the table at the given index (the &quot;next&quot; pair after the given key). If there are no more elements in the table, then &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt; returns 0 (and pushes nothing).</source>
          <target state="translated">Saca una clave de la pila y empuja un par clave-valor de la tabla en el &amp;iacute;ndice dado (el &quot;siguiente&quot; par despu&amp;eacute;s de la clave dada). Si no hay m&amp;aacute;s elementos en la tabla, entonces &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; &lt;/a&gt; devuelve 0 (y no inserta nada).</target>
        </trans-unit>
        <trans-unit id="d60cca5dd50e4b83932b42fd8d8d9fbffe7a1bc8" translate="yes" xml:space="preserve">
          <source>Pops a key from the stack, and pushes a key&amp;ndash;value pair from the table at the given index, the &quot;next&quot; pair after the given key. If there are no more elements in the table, then &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt; returns 0 and pushes nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38ce2b2d648784be385652bd2405ecdc4f5fbdbc" translate="yes" xml:space="preserve">
          <source>Pops a table from the stack and sets it as the new metatable for the value at the given index.</source>
          <target state="translated">Saca una tabla de la pila y la establece como la nueva metatabla para el valor en el índice dado.</target>
        </trans-unit>
        <trans-unit id="3748a23e8606e10be9753871f0543fd3b3c035b8" translate="yes" xml:space="preserve">
          <source>Pops a table or &lt;b&gt;nil&lt;/b&gt; from the stack and sets that value as the new metatable for the value at the given index. (&lt;b&gt;nil&lt;/b&gt; means no metatable.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cbea7516afa5834e8becd7f7d4a828165b122a" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new &lt;code&gt;n&lt;/code&gt;-th user value associated to the full userdata at the given index. Returns 0 if the userdata does not have that value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0a9d18a088445b817b9df7884bfcb32d185882" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new value associated to the full userdata at the given index.</source>
          <target state="translated">Saca un valor de la pila y lo establece como el nuevo valor asociado a los datos de usuario completos en el índice dado.</target>
        </trans-unit>
        <trans-unit id="e2b2f785858d2ccd19fa2b3c3174e4f53334d580" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new value of global &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Saca un valor de la pila y lo establece como el nuevo valor del &lt;code&gt;name&lt;/code&gt; global .</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="38891db011f7fa7075e0b3b67c891847a651262c" translate="yes" xml:space="preserve">
          <source>Pushes a C function onto the stack. This function is equivalent to &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; with no upvalues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6069e3ce33f065015c2dc7cf19747d682b66d1cb" translate="yes" xml:space="preserve">
          <source>Pushes a C function onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type &lt;code&gt;function&lt;/code&gt; that, when called, invokes the corresponding C function.</source>
          <target state="translated">Inserta una funci&amp;oacute;n C en la pila. Esta funci&amp;oacute;n recibe un puntero a una funci&amp;oacute;n C y coloca en la pila un valor Lua de tipo &lt;code&gt;function&lt;/code&gt; que, cuando se llama, invoca la funci&amp;oacute;n C correspondiente.</target>
        </trans-unit>
        <trans-unit id="225557cebb89115cc93c59763f61b47f6e9246c5" translate="yes" xml:space="preserve">
          <source>Pushes a boolean value with value &lt;code&gt;b&lt;/code&gt; onto the stack.</source>
          <target state="translated">Inserta un valor booleano con valor &lt;code&gt;b&lt;/code&gt; en la pila.</target>
        </trans-unit>
        <trans-unit id="894000f061d35d3982475e83383dc72799631571" translate="yes" xml:space="preserve">
          <source>Pushes a copy of the element at the given index onto the stack.</source>
          <target state="translated">Empuja una copia del elemento en el índice dado en la pila.</target>
        </trans-unit>
        <trans-unit id="b6ff7b2e435c0e0bd4a4dbe8af13548197a7ba1c" translate="yes" xml:space="preserve">
          <source>Pushes a float with value &lt;code&gt;n&lt;/code&gt; onto the stack.</source>
          <target state="translated">Coloca un flotante con valor &lt;code&gt;n&lt;/code&gt; en la pila.</target>
        </trans-unit>
        <trans-unit id="1b7c742fb6acbbb7614fff04126bb1d65108509f" translate="yes" xml:space="preserve">
          <source>Pushes a light userdata onto the stack.</source>
          <target state="translated">Empuja una luz de datos de usuario en la pila.</target>
        </trans-unit>
        <trans-unit id="f9640c606650c6c3b185fb6d556165b919470195" translate="yes" xml:space="preserve">
          <source>Pushes a new C closure onto the stack.</source>
          <target state="translated">Empuja un nuevo cierre C en la pila.</target>
        </trans-unit>
        <trans-unit id="783ef23f706b3af65f922bb64840e0a1f3a3b44a" translate="yes" xml:space="preserve">
          <source>Pushes a new C closure onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type &lt;code&gt;function&lt;/code&gt; that, when called, invokes the corresponding C function. The parameter &lt;code&gt;n&lt;/code&gt; tells how many upvalues this function will have (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a59444f671b252069eb2dc564dace63fe90d50" translate="yes" xml:space="preserve">
          <source>Pushes a nil value onto the stack.</source>
          <target state="translated">Empuja un valor nulo en la pila.</target>
        </trans-unit>
        <trans-unit id="2ac334edd538c29ffe856d049cab16b02559c4e6" translate="yes" xml:space="preserve">
          <source>Pushes an integer with value &lt;code&gt;n&lt;/code&gt; onto the stack.</source>
          <target state="translated">Inserta un n&amp;uacute;mero entero con valor &lt;code&gt;n&lt;/code&gt; en la pila.</target>
        </trans-unit>
        <trans-unit id="f8ab0829fe517855f739ffae026b3c01efbb88ce" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a formatted string and returns a pointer to this string (see &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt;). It is similar to the ISO C function &lt;code&gt;sprintf&lt;/code&gt;, but has two important differences. First, you do not have to allocate space for the result; the result is a Lua string and Lua takes care of memory allocation (and deallocation, through garbage collection). Second, the conversion specifiers are quite restricted. There are no flags, widths, or precisions. The conversion specifiers can only be '&lt;code&gt;%%&lt;/code&gt;' (inserts the character '&lt;code&gt;%&lt;/code&gt;'), '&lt;code&gt;%s&lt;/code&gt;' (inserts a zero-terminated string, with no size restrictions), '&lt;code&gt;%f&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%I&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%p&lt;/code&gt;' (inserts a pointer), '&lt;code&gt;%d&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt;), '&lt;code&gt;%c&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt; as a one-byte character), and '&lt;code&gt;%U&lt;/code&gt;' (inserts a &lt;code&gt;long int&lt;/code&gt; as a UTF-8 byte sequence).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf2182a4bd44a4ababe6986cdc0d46624511d6f" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a formatted string and returns a pointer to this string. It is similar to the ISO C function &lt;code&gt;sprintf&lt;/code&gt;, but has some important differences:</source>
          <target state="translated">Inserta en la pila una cadena formateada y devuelve un puntero a esta cadena. Es similar a la funci&amp;oacute;n &lt;code&gt;sprintf&lt;/code&gt; de ISO C , pero tiene algunas diferencias importantes:</target>
        </trans-unit>
        <trans-unit id="e3eb6979dbbec2441c887e7c302c341c3e2193b2" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a string identifying the current position of the control at level &lt;code&gt;lvl&lt;/code&gt; in the call stack. Typically this string has the following format:</source>
          <target state="translated">Inserta en la pila una cadena que identifica la posici&amp;oacute;n actual del control en el nivel &lt;code&gt;lvl&lt;/code&gt; de la pila de llamadas. Normalmente, esta cadena tiene el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="31d25d3d93b7e126c80bd4b8ac83684541597116" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the &lt;code&gt;n&lt;/code&gt;-th user value associated with the full userdata at the given index and returns the type of the pushed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1400d6038d9c13c6266dab4b80bdcdd7fc31a04b" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the Lua value associated with the full userdata at the given index.</source>
          <target state="translated">Empuja en la pila el valor Lua asociado a los datos de usuario completos en el índice dado.</target>
        </trans-unit>
        <trans-unit id="96d78a717bd5f3b49461732d2e8f02559185b11e" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the field &lt;code&gt;e&lt;/code&gt; from the metatable of the object at index &lt;code&gt;obj&lt;/code&gt; and returns the type of pushed value. If the object does not have a metatable, or if the metatable does not have this field, pushes nothing and returns &lt;code&gt;LUA_TNIL&lt;/code&gt;.</source>
          <target state="translated">Coloca en la pila el campo &lt;code&gt;e&lt;/code&gt; de la metatabla del objeto en el &amp;iacute;ndice &lt;code&gt;obj&lt;/code&gt; y devuelve el tipo de valor insertado . Si el objeto no tiene una metatabla, o si la metatabla no tiene este campo, no empuja nada y devuelve &lt;code&gt;LUA_TNIL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d063d65f8ebdd7680c71182f22ecc37ef6878b23" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the field &lt;code&gt;e&lt;/code&gt; from the metatable of the object at index &lt;code&gt;obj&lt;/code&gt; and returns the type of the pushed value. If the object does not have a metatable, or if the metatable does not have this field, pushes nothing and returns &lt;code&gt;LUA_TNIL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a3ae7b655cf9df13c5b9cf6975aa8b58442402" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;) (&lt;b&gt;nil&lt;/b&gt; if there is no metatable associated with that name). Returns the type of the pushed value.</source>
          <target state="translated">Coloca en la pila la metatabla asociada con el nombre &lt;code&gt;tname&lt;/code&gt; en el registro (ver &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; ) ( &lt;b&gt;nulo&lt;/b&gt; si no hay una metatabla asociada con ese nombre). Devuelve el tipo de valor introducido.</target>
        </trans-unit>
        <trans-unit id="c76c4d4c11e0c9e0d1f805bd491ba2da9880963e" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the metatable associated with the name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;), or &lt;b&gt;nil&lt;/b&gt; if there is no metatable associated with that name. Returns the type of the pushed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3681d4e1cdd569fb3b2f3300755bb4d0cfb69c67" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[i]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Coloca en la pila el valor &lt;code&gt;t[i]&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es el valor en el &amp;iacute;ndice dado. Como en Lua, esta funci&amp;oacute;n puede activar un metam&amp;eacute;todo para el evento &quot;index&quot; (ver &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="160cbb51fcadb575239ec804bbd26447a616f853" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;k&lt;/code&gt; is the pointer &lt;code&gt;p&lt;/code&gt; represented as a light userdata. The access is raw; that is, it does not invoke the &lt;code&gt;__index&lt;/code&gt; metamethod.</source>
          <target state="translated">Coloca en la pila el valor &lt;code&gt;t[k]&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es la tabla en el &amp;iacute;ndice dado &lt;code&gt;k&lt;/code&gt; es el puntero &lt;code&gt;p&lt;/code&gt; representado como datos de usuario ligeros. El acceso es crudo; es decir, no invoca el &lt;code&gt;__index&lt;/code&gt; __index.</target>
        </trans-unit>
        <trans-unit id="f758b684030c5bdc751c5b58b931a7f7b9972806" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;k&lt;/code&gt; is the pointer &lt;code&gt;p&lt;/code&gt; represented as a light userdata. The access is raw; that is, it does not use the &lt;code&gt;__index&lt;/code&gt; metavalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba28c13e89d272d19c50f5e767726525d936e21" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;k&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">Coloca en la pila el valor &lt;code&gt;t[k]&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es el valor en el &amp;iacute;ndice dado &lt;code&gt;k&lt;/code&gt; es el valor en la parte superior de la pila.</target>
        </trans-unit>
        <trans-unit id="2c9f6ce9bcbe6e782d6892ed66ce333a49c1c0f5" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;k&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d433d1f4953100bc2a0c9d7a8e8e092f7c0a5c2a" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Coloca en la pila el valor &lt;code&gt;t[k]&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es el valor en el &amp;iacute;ndice dado. Como en Lua, esta funci&amp;oacute;n puede activar un metam&amp;eacute;todo para el evento &quot;index&quot; (ver &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="27c3e32a80e22fb604cbe4557acc820d3c5231a7" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[n]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index. The access is raw, that is, it does not invoke the &lt;code&gt;__index&lt;/code&gt; metamethod.</source>
          <target state="translated">Coloca en la pila el valor &lt;code&gt;t[n]&lt;/code&gt; , donde &lt;code&gt;t&lt;/code&gt; es la tabla en el &amp;iacute;ndice dado. El acceso es sin &lt;code&gt;__index&lt;/code&gt; , es decir, no invoca el metam&amp;eacute;todo __index.</target>
        </trans-unit>
        <trans-unit id="dbeb4c059af4ccf3fb9e1fdfc5784413b8117212" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[n]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index. The access is raw, that is, it does not use the &lt;code&gt;__index&lt;/code&gt; metavalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3adeb92584bb85f61e3f56627b5522106f4dd7b4" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value of the global &lt;code&gt;name&lt;/code&gt;. Returns the type of that value.</source>
          <target state="translated">Coloca en la pila el valor del &lt;code&gt;name&lt;/code&gt; global . Devuelve el tipo de ese valor.</target>
        </trans-unit>
        <trans-unit id="d5f71bf51568746d5ff514f34182d2dde3178d9d" translate="yes" xml:space="preserve">
          <source>Pushes the &lt;b&gt;fail&lt;/b&gt; value onto the stack (see &lt;a href=&quot;#6&quot;&gt;&amp;sect;6&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bb89f8fd253dc6a3b3b23f64ce3135d6817db4" translate="yes" xml:space="preserve">
          <source>Pushes the global environment onto the stack.</source>
          <target state="translated">Empuja el medio ambiente global hacia la pila.</target>
        </trans-unit>
        <trans-unit id="b8b8e3282a4a6ab4f3ed7c29929c1ea38215b0e1" translate="yes" xml:space="preserve">
          <source>Pushes the string pointed to by &lt;code&gt;s&lt;/code&gt; with size &lt;code&gt;len&lt;/code&gt; onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns. The string can contain any binary data, including embedded zeros.</source>
          <target state="translated">Empuja la cuerda se&amp;ntilde;alada por &lt;code&gt;s&lt;/code&gt; con el tama&amp;ntilde;o &lt;code&gt;len&lt;/code&gt; en la pila. Lua hace (o reutiliza) una copia interna de la cadena dada, por lo que la memoria en &lt;code&gt;s&lt;/code&gt; se puede liberar o reutilizar inmediatamente despu&amp;eacute;s de que la funci&amp;oacute;n regrese. La cadena puede contener cualquier dato binario, incluidos ceros incrustados.</target>
        </trans-unit>
        <trans-unit id="5639aa8221a13af71464ab360f3a38097209c56d" translate="yes" xml:space="preserve">
          <source>Pushes the string pointed to by &lt;code&gt;s&lt;/code&gt; with size &lt;code&gt;len&lt;/code&gt; onto the stack. Lua will make or reuse an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns. The string can contain any binary data, including embedded zeros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b66a7bc8fe80fa098dee231f5eaec5a6ccedfa" translate="yes" xml:space="preserve">
          <source>Pushes the thread represented by &lt;code&gt;L&lt;/code&gt; onto the stack. Returns 1 if this thread is the main thread of its state.</source>
          <target state="translated">Empuja el hilo representado por &lt;code&gt;L&lt;/code&gt; en la pila. Devuelve 1 si este hilo es el hilo principal de su estado.</target>
        </trans-unit>
        <trans-unit id="4854f8dce1b3efb397d0da3cc0315b1cfb867e30" translate="yes" xml:space="preserve">
          <source>Pushes the zero-terminated string pointed to by &lt;code&gt;s&lt;/code&gt; onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns.</source>
          <target state="translated">Empuja la cadena terminada en cero se&amp;ntilde;alada por &lt;code&gt;s&lt;/code&gt; en la pila. Lua hace (o reutiliza) una copia interna de la cadena dada, por lo que la memoria en &lt;code&gt;s&lt;/code&gt; se puede liberar o reutilizar inmediatamente despu&amp;eacute;s de que la funci&amp;oacute;n regrese.</target>
        </trans-unit>
        <trans-unit id="8860aa35b65cff58872a8601fb6de276a53dc538" translate="yes" xml:space="preserve">
          <source>Pushes the zero-terminated string pointed to by &lt;code&gt;s&lt;/code&gt; onto the stack. Lua will make or reuse an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cfffe2498f662da17fd436630bb5c185a5f3013" translate="yes" xml:space="preserve">
          <source>Raises a Lua error, using the value on the top of the stack as the error object. This function does a long jump, and therefore never returns (see &lt;a href=&quot;#luaL_error&quot;&gt;&lt;code&gt;luaL_error&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9d1916a4b52d4c954d6611c2265a068aa73389" translate="yes" xml:space="preserve">
          <source>Raises a type error for the argument &lt;code&gt;arg&lt;/code&gt; of the C function that called it, using a standard message; &lt;code&gt;tname&lt;/code&gt; is a &quot;name&quot; for the expected type. This function never returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b9354a43204b93a4330b1af0c9ff798523b53da" translate="yes" xml:space="preserve">
          <source>Raises an error (see &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;) with @{message} as the error object. This function never returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf358ba5588da456b49a6b3b1276c902731720d9" translate="yes" xml:space="preserve">
          <source>Raises an error if the value of its argument &lt;code&gt;v&lt;/code&gt; is false (i.e., &lt;b&gt;nil&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;); otherwise, returns all its arguments. In case of error, &lt;code&gt;message&lt;/code&gt; is the error object; when absent, it defaults to &quot;&lt;code&gt;assertion failed!&lt;/code&gt;&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0763820b54eedcf07407cf791911e6a4435f20" translate="yes" xml:space="preserve">
          <source>Raises an error reporting a problem with argument &lt;code&gt;arg&lt;/code&gt; of the C function that called it, using a standard message that includes &lt;code&gt;extramsg&lt;/code&gt; as a comment:</source>
          <target state="translated">Genera un error al informar un problema con el argumento &lt;code&gt;arg&lt;/code&gt; de la funci&amp;oacute;n C que lo llam&amp;oacute;, usando un mensaje est&amp;aacute;ndar que incluye &lt;code&gt;extramsg&lt;/code&gt; como comentario:</target>
        </trans-unit>
        <trans-unit id="2195072e1ce816af3985bb81599b653639e6d200" translate="yes" xml:space="preserve">
          <source>Raises an error. The error message format is given by &lt;code&gt;fmt&lt;/code&gt; plus any extra arguments, following the same rules of &lt;a href=&quot;#lua_pushfstring&quot;&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;. It also adds at the beginning of the message the file name and the line number where the error occurred, if this information is available.</source>
          <target state="translated">Genera un error. El formato del mensaje de error viene dado por &lt;code&gt;fmt&lt;/code&gt; m&amp;aacute;s cualquier argumento adicional, siguiendo las mismas reglas de &lt;a href=&quot;#lua_pushfstring&quot;&gt; &lt;code&gt;lua_pushfstring&lt;/code&gt; &lt;/a&gt; . Tambi&amp;eacute;n agrega al principio del mensaje el nombre del archivo y el n&amp;uacute;mero de l&amp;iacute;nea donde ocurri&amp;oacute; el error, si esta informaci&amp;oacute;n est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="e31b0fedf40d60473a1681a9f95cd0f5ccee72ff" translate="yes" xml:space="preserve">
          <source>Reads the file &lt;code&gt;file&lt;/code&gt;, according to the given formats, which specify what to read. For each format, the function returns a string or a number with the characters read, or &lt;b&gt;fail&lt;/b&gt; if it cannot read data with the specified format. (In this latter case, the function does not read subsequent formats.) When called without arguments, it uses a default format that reads the next line (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a33dab1cf51144cd77abed8a485f73ea3a2319" translate="yes" xml:space="preserve">
          <source>Reads the file &lt;code&gt;file&lt;/code&gt;, according to the given formats, which specify what to read. For each format, the function returns a string or a number with the characters read, or &lt;b&gt;nil&lt;/b&gt; if it cannot read data with the specified format. (In this latter case, the function does not read subsequent formats.) When called without formats, it uses a default format that reads the next line (see below).</source>
          <target state="translated">Lee el archivo de &lt;code&gt;file&lt;/code&gt; , de acuerdo con los formatos dados, que especifican qu&amp;eacute; leer. Para cada formato, la funci&amp;oacute;n devuelve una cadena o un n&amp;uacute;mero con los caracteres le&amp;iacute;dos, o &lt;b&gt;nil&lt;/b&gt; si no puede leer datos con el formato especificado. (En este &amp;uacute;ltimo caso, la funci&amp;oacute;n no lee los formatos posteriores.) Cuando se llama sin formatos, usa un formato predeterminado que lee la siguiente l&amp;iacute;nea (ver m&amp;aacute;s abajo).</target>
        </trans-unit>
        <trans-unit id="19c5c64f58aecd561b0cc1876786dfe7cb5a0fec" translate="yes" xml:space="preserve">
          <source>Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale.</source>
          <target state="translated">Recibe una cadena y devuelve una copia de esta cadena con todas las letras minúsculas cambiadas a mayúsculas.El resto de los caracteres se mantienen sin cambios.La definición de lo que es una letra minúscula depende de la localidad actual.</target>
        </trans-unit>
        <trans-unit id="540aac1cb2574351ee99baa96641925cd5f56a55" translate="yes" xml:space="preserve">
          <source>Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale.</source>
          <target state="translated">Recibe una cadena y devuelve una copia de esta cadena con todas las letras mayúsculas cambiadas a minúsculas.El resto de los caracteres se mantienen sin cambios.La definición de lo que es una letra mayúscula depende de la localidad actual.</target>
        </trans-unit>
        <trans-unit id="b890d3f853acc49ad9cf651903e6eb6cdf33901a" translate="yes" xml:space="preserve">
          <source>Receives a string and returns its length. The empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; has length 0. Embedded zeros are counted, so &lt;code&gt;&quot;a\000bc\000&quot;&lt;/code&gt; has length 5.</source>
          <target state="translated">Recibe una cadena y devuelve su longitud. La cadena vac&amp;iacute;a &lt;code&gt;&quot;&quot;&lt;/code&gt; tiene una longitud de 0. Los ceros incrustados se cuentan, por lo que &lt;code&gt;&quot;a\000bc\000&quot;&lt;/code&gt; tiene una longitud de 5.</target>
        </trans-unit>
        <trans-unit id="d82851b5722eeb1a4807bb839e4ddddefaeb2a1b" translate="yes" xml:space="preserve">
          <source>Receives a value of any type and converts it to a string in a human-readable format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525f707997f87240ceb1b2b5bdf4cfc009a704fc" translate="yes" xml:space="preserve">
          <source>Receives a value of any type and converts it to a string in a human-readable format. (For complete control of how numbers are converted, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Recibe un valor de cualquier tipo y lo convierte en una cadena en un formato legible por humanos. (Para un control completo de c&amp;oacute;mo se convierten los n&amp;uacute;meros, utilice &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f08637f98da65a6c936ab18edfd8700b8df77cb5" translate="yes" xml:space="preserve">
          <source>Receives any number of arguments and prints their values to &lt;code&gt;stdout&lt;/code&gt;, converting each argument to a string following the same rules of &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a03622d8f97ccec5d5f7daa5dac73af6b7c7028" translate="yes" xml:space="preserve">
          <source>Receives any number of arguments and prints their values to &lt;code&gt;stdout&lt;/code&gt;, using the &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt; function to convert each argument to a string. &lt;code&gt;print&lt;/code&gt; is not intended for formatted output, but only as a quick way to show a value, for instance for debugging. For complete control over the output, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.write&quot;&gt;&lt;code&gt;io.write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Recibe cualquier n&amp;uacute;mero de argumentos e imprime sus valores en &lt;code&gt;stdout&lt;/code&gt; , usando la funci&amp;oacute;n &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; para convertir cada argumento en una cadena. &lt;code&gt;print&lt;/code&gt; no est&amp;aacute; dise&amp;ntilde;ado para salida formateada, sino solo como una forma r&amp;aacute;pida de mostrar un valor, por ejemplo, para depurar. Para un control completo sobre la salida, use &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#pdf-io.write&quot;&gt; &lt;code&gt;io.write&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2cf76b7f314d7be6b1d5b068287552d8871811e" translate="yes" xml:space="preserve">
          <source>Receives zero or more integers, converts each one to its corresponding UTF-8 byte sequence and returns a string with the concatenation of all these sequences.</source>
          <target state="translated">Recibe cero o más números enteros,convierte cada uno a su correspondiente secuencia de bytes UTF-8 y devuelve una cadena con la concatenación de todas estas secuencias.</target>
        </trans-unit>
        <trans-unit id="cb0dfce9b4c27c4105f7ed0248bef997f2d2f7bb" translate="yes" xml:space="preserve">
          <source>Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numeric code equal to its corresponding argument.</source>
          <target state="translated">Recibe cero o más números enteros.Devuelve una cadena de longitud igual al número de argumentos,en la que cada carácter tiene el código numérico interno igual a su correspondiente argumento.</target>
        </trans-unit>
        <trans-unit id="ac1a2088772d8a0274c1a663c003fac03a83bcc4" translate="yes" xml:space="preserve">
          <source>Regardless, if the resulting function has any upvalues, its first upvalue is set to the value of &lt;code&gt;env&lt;/code&gt;, if that parameter is given, or to the value of the global environment. Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;. All upvalues are fresh, that is, they are not shared with any other function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba50e88a283776123b7b75fd12714beb6542b84c" translate="yes" xml:space="preserve">
          <source>Registers all functions in the array &lt;code&gt;l&lt;/code&gt; (see &lt;a href=&quot;#luaL_Reg&quot;&gt;&lt;code&gt;luaL_Reg&lt;/code&gt;&lt;/a&gt;) into the table on the top of the stack (below optional upvalues, see next).</source>
          <target state="translated">Registra todas las funciones en la matriz &lt;code&gt;l&lt;/code&gt; (ver &lt;a href=&quot;#luaL_Reg&quot;&gt; &lt;code&gt;luaL_Reg&lt;/code&gt; &lt;/a&gt; ) en la tabla en la parte superior de la pila (debajo de los valores de subida opcionales, ver a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="354032ada697719ccb58ca87cd221831508c42b3" translate="yes" xml:space="preserve">
          <source>Relational Operators</source>
          <target state="translated">Operadores de relación</target>
        </trans-unit>
        <trans-unit id="7d652aafaa213ccec3954206dc0a95e5d151cad3" translate="yes" xml:space="preserve">
          <source>Releases reference &lt;code&gt;ref&lt;/code&gt; from the table at index &lt;code&gt;t&lt;/code&gt; (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;). The entry is removed from the table, so that the referred object can be collected. The reference &lt;code&gt;ref&lt;/code&gt; is also freed to be used again.</source>
          <target state="translated">Libera la referencia de &lt;code&gt;ref&lt;/code&gt; erencia de la tabla en el &amp;iacute;ndice &lt;code&gt;t&lt;/code&gt; (ver &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; ). La entrada se elimina de la tabla para que se pueda recopilar el objeto referido. La referencia de &lt;code&gt;ref&lt;/code&gt; erencia tambi&amp;eacute;n se libera para ser utilizada nuevamente.</target>
        </trans-unit>
        <trans-unit id="af7c5beadc65cf6aecf24cf7287288561cb7ead7" translate="yes" xml:space="preserve">
          <source>Releases the reference &lt;code&gt;ref&lt;/code&gt; from the table at index &lt;code&gt;t&lt;/code&gt; (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;). The entry is removed from the table, so that the referred object can be collected. The reference &lt;code&gt;ref&lt;/code&gt; is also freed to be used again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f21ed8cdd38e88c74187592dabfbf9189cec444" translate="yes" xml:space="preserve">
          <source>Remember that, whenever an operation needs the length of a table, all caveats about the length operator apply (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). All functions ignore non-numeric keys in the tables given as arguments.</source>
          <target state="translated">Recuerde que, siempre que una operaci&amp;oacute;n necesite la longitud de una tabla, se aplican todas las advertencias sobre el operador de longitud (consulte &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; ). Todas las funciones ignoran las teclas no num&amp;eacute;ricas en las tablas dadas como argumentos.</target>
        </trans-unit>
        <trans-unit id="50df2da2a4204c47a50a5f2a2a11c7eea37ba603" translate="yes" xml:space="preserve">
          <source>Removes &lt;code&gt;n&lt;/code&gt; bytes from the the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). The buffer must have at least that many bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dd440324a053f93400815574d10e0db636ed3b" translate="yes" xml:space="preserve">
          <source>Removes from &lt;code&gt;list&lt;/code&gt; the element at position &lt;code&gt;pos&lt;/code&gt;, returning the value of the removed element. When &lt;code&gt;pos&lt;/code&gt; is an integer between 1 and &lt;code&gt;#list&lt;/code&gt;, it shifts down the elements &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; and erases element &lt;code&gt;list[#list]&lt;/code&gt;; The index &lt;code&gt;pos&lt;/code&gt; can also be 0 when &lt;code&gt;#list&lt;/code&gt; is 0, or &lt;code&gt;#list + 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78486a859650e2590601f8f6a90106add4cefb81" translate="yes" xml:space="preserve">
          <source>Removes from &lt;code&gt;list&lt;/code&gt; the element at position &lt;code&gt;pos&lt;/code&gt;, returning the value of the removed element. When &lt;code&gt;pos&lt;/code&gt; is an integer between 1 and &lt;code&gt;#list&lt;/code&gt;, it shifts down the elements &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; and erases element &lt;code&gt;list[#list]&lt;/code&gt;; The index &lt;code&gt;pos&lt;/code&gt; can also be 0 when &lt;code&gt;#list&lt;/code&gt; is 0, or &lt;code&gt;#list + 1&lt;/code&gt;; in those cases, the function erases the element &lt;code&gt;list[pos]&lt;/code&gt;.</source>
          <target state="translated">Elimina de la &lt;code&gt;list&lt;/code&gt; a el elemento en la posici&amp;oacute;n &lt;code&gt;pos&lt;/code&gt; , devolviendo el valor del elemento eliminado. Cuando &lt;code&gt;pos&lt;/code&gt; es un n&amp;uacute;mero entero entre 1 y &lt;code&gt;#list&lt;/code&gt; , desplaza hacia abajo la &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; elementos [pos + 1], list [pos + 2], &amp;middot;&amp;middot;&amp;middot;, list [#list] y borra la &lt;code&gt;list[#list]&lt;/code&gt; elementos [#list] ; El &amp;iacute;ndice &lt;code&gt;pos&lt;/code&gt; tambi&amp;eacute;n puede ser 0 cuando &lt;code&gt;#list&lt;/code&gt; es 0, o &lt;code&gt;#list + 1&lt;/code&gt; ; en esos casos, la funci&amp;oacute;n borra la &lt;code&gt;list[pos]&lt;/code&gt; elementos [pos] .</target>
        </trans-unit>
        <trans-unit id="11e20bb227ba77f3bb86f13b7935abd6f4634200" translate="yes" xml:space="preserve">
          <source>Removes the element at the given valid index, shifting down the elements above this index to fill the gap. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">Elimina el elemento en el índice válido dado,desplazando hacia abajo los elementos por encima de este índice para llenar el hueco.Esta función no puede ser llamada con un pseudoíndice,porque un pseudoíndice no es una posición real de la pila.</target>
        </trans-unit>
        <trans-unit id="1d1ad46541c1bc833d763b9872ae152506b03c2a" translate="yes" xml:space="preserve">
          <source>Renames the file or directory named &lt;code&gt;oldname&lt;/code&gt; to &lt;code&gt;newname&lt;/code&gt;. If this function fails, it returns &lt;b&gt;fail&lt;/b&gt;, plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57bc261321eacee5a6b51aa33ad8b6bdff0d2216" translate="yes" xml:space="preserve">
          <source>Renames the file or directory named &lt;code&gt;oldname&lt;/code&gt; to &lt;code&gt;newname&lt;/code&gt;. If this function fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="translated">Cambia el nombre del archivo o directorio llamado &lt;code&gt;oldname&lt;/code&gt; a &lt;code&gt;newname&lt;/code&gt; . Si esta funci&amp;oacute;n falla, devuelve &lt;b&gt;nil&lt;/b&gt; , m&amp;aacute;s una cadena que describe el error y el c&amp;oacute;digo de error. De lo contrario, devuelve verdadero.</target>
        </trans-unit>
        <trans-unit id="6fa4b690dd13963596a568015e6ef34dfd9eea75" translate="yes" xml:space="preserve">
          <source>Resets a thread, cleaning its call stack and closing all pending to-be-closed variables. Returns a status code: &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; for no errors in closing methods, or an error status otherwise. In case of error, leaves the error object on the top of the stack,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce3bd88cc94ffb61167bb8f7b9e843c7604f13b" translate="yes" xml:space="preserve">
          <source>Results are returned using the &lt;b&gt;return&lt;/b&gt; statement (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;). If control reaches the end of a function without encountering a &lt;b&gt;return&lt;/b&gt; statement, then the function returns with no results.</source>
          <target state="translated">Los resultados se devuelven utilizando la declaraci&amp;oacute;n de &lt;b&gt;retorno&lt;/b&gt; (consulte &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt; ). Si el control llega al final de una funci&amp;oacute;n sin encontrar una declaraci&amp;oacute;n de &lt;b&gt;retorno&lt;/b&gt; , entonces la funci&amp;oacute;n regresa sin resultados.</target>
        </trans-unit>
        <trans-unit id="244c963cdbd920ed3e3a03fe837b76f265d0a0b8" translate="yes" xml:space="preserve">
          <source>Resurrected objects (that is, objects being finalized and objects accessible only through objects being finalized) have a special behavior in weak tables. They are removed from weak values before running their finalizers, but are removed from weak keys only in the next collection after running their finalizers, when such objects are actually freed. This behavior allows the finalizer to access properties associated with the object through weak tables.</source>
          <target state="translated">Los objetos resucitados (es decir,los objetos que se están finalizando y los objetos accesibles sólo a través de los objetos que se están finalizando)tienen un comportamiento especial en las mesas débiles.Se eliminan de los valores débiles antes de ejecutar sus finalizadores,pero se eliminan de las claves débiles sólo en la siguiente colección después de ejecutar sus finalizadores,cuando tales objetos se liberan realmente.Este comportamiento permite que el finalizador acceda a las propiedades asociadas con el objeto a través de tablas débiles.</target>
        </trans-unit>
        <trans-unit id="d0a2349b7422351122e89416a8339b7ba9df8537" translate="yes" xml:space="preserve">
          <source>Returns &quot;&lt;code&gt;integer&lt;/code&gt;&quot; if &lt;code&gt;x&lt;/code&gt; is an integer, &quot;&lt;code&gt;float&lt;/code&gt;&quot; if it is a float, or &lt;b&gt;fail&lt;/b&gt; if &lt;code&gt;x&lt;/code&gt; is not a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03118cc39c1e81c1c438cef7d116290590135b5a" translate="yes" xml:space="preserve">
          <source>Returns &quot;&lt;code&gt;integer&lt;/code&gt;&quot; if &lt;code&gt;x&lt;/code&gt; is an integer, &quot;&lt;code&gt;float&lt;/code&gt;&quot; if it is a float, or &lt;b&gt;nil&lt;/b&gt; if &lt;code&gt;x&lt;/code&gt; is not a number.</source>
          <target state="translated">Devuelve &quot; &lt;code&gt;integer&lt;/code&gt; &quot; si &lt;code&gt;x&lt;/code&gt; es un n&amp;uacute;mero entero, &quot; &lt;code&gt;float&lt;/code&gt; &quot; si es un n&amp;uacute;mero flotante o &lt;b&gt;nil&lt;/b&gt; si &lt;code&gt;x&lt;/code&gt; no es un n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="ec136d49176b1dfa086d0b59ff735d87f5d8b25c" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given coroutine can yield, and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si la corutina dada puede ceder,y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="36a260eb163a20a6982a495d8fcda57196ae377b" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given index is not valid or if the value at this index is &lt;b&gt;nil&lt;/b&gt;, and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el &amp;iacute;ndice dado no es v&amp;aacute;lido o si el valor de este &amp;iacute;ndice es &lt;b&gt;nulo&lt;/b&gt; y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="8a03c180e8267d605c7828397144f7c543874d2c" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given index is not valid, and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el índice dado no es válido,y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="8d7984f5b9d91f61d05816274d72ac1e8b987b70" translate="yes" xml:space="preserve">
          <source>Returns 1 if the two values in indices &lt;code&gt;index1&lt;/code&gt; and &lt;code&gt;index2&lt;/code&gt; are primitively equal (that is, equal without calling the &lt;code&gt;__eq&lt;/code&gt; metamethod). Otherwise returns 0. Also returns 0 if any of the indices are not valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abb71a0bd2d89035111fe1406578f64ee99f1cd" translate="yes" xml:space="preserve">
          <source>Returns 1 if the two values in indices &lt;code&gt;index1&lt;/code&gt; and &lt;code&gt;index2&lt;/code&gt; are primitively equal (that is, without calling the &lt;code&gt;__eq&lt;/code&gt; metamethod). Otherwise returns 0. Also returns 0 if any of the indices are not valid.</source>
          <target state="translated">Devuelve 1 si los dos valores de los &amp;iacute;ndices &lt;code&gt;index1&lt;/code&gt; e &lt;code&gt;index2&lt;/code&gt; son primitivamente iguales (es decir, sin llamar al &lt;code&gt;__eq&lt;/code&gt; __eq). De lo contrario, devuelve 0. Tambi&amp;eacute;n devuelve 0 si alguno de los &amp;iacute;ndices no es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="77b6c0faff8f019e54587bee38b27269e8ece2d8" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is &lt;b&gt;nil&lt;/b&gt;, and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor en el &amp;iacute;ndice dado es &lt;b&gt;nulo&lt;/b&gt; y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="acad229e61c0f7b3cf84876f85fd1aed4340fdeb" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a C function, and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor en el índice dado es una función C,y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="c6d1286ca58fd2bca52facd7ccf6f424aa47dca4" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a boolean, and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor en el índice dado es un booleano,y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="04d4d0a8fc1e9ff9c642f37982cd6541f074eaf2" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a function (either C or Lua), and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor en el índice dado es una función (ya sea C o Lua),y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="85c97cef398c89971e6d5d95362f5833c0efeb94" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a light userdata, and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor del índice dado es un dato de usuario ligero,y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="293be583246b5c6f5755824ebef65496d84be9b9" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a number or a string convertible to a number, and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor en el índice dado es un número o una cadena convertible en un número,y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="1ef629a2e4c4bd109da15d0096305f549d521e11" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a string or a number (which is always convertible to a string), and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor en el índice dado es una cadena o un número (que siempre es convertible en una cadena),y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="b24b734f996f24f0d2edcb352efb5d0a8733d485" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a table, and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor en el índice dado es una tabla,y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="6452edfae9b54954154513a55afe95f60e75b4fa" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a thread, and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor en el índice dado es un hilo,y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="fbf8a110fe7143ca6d907ca070a5c03ffa0f2050" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a userdata (either full or light), and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor del índice dado es un dato de usuario (completo o ligero),y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="83893644ee4437282f1a7daf1d6a53c7e83643da" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is an integer (that is, the value is a number and is represented as an integer), and 0 otherwise.</source>
          <target state="translated">Devuelve 1 si el valor en el índice dado es un número entero (es decir,el valor es un número y se representa como un entero),y 0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="671cca4567b26fcc0ceb0e43e3d2829f1469cdbb" translate="yes" xml:space="preserve">
          <source>Returns &lt;b&gt;fail&lt;/b&gt; if there is no active hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d04eca2996cc50939c173c775d0d5f069d8627" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pops nothing) when the index &lt;code&gt;n&lt;/code&gt; is greater than the number of upvalues.</source>
          <target state="translated">Devuelve &lt;code&gt;NULL&lt;/code&gt; (y no muestra nada) cuando el &amp;iacute;ndice &lt;code&gt;n&lt;/code&gt; es mayor que el n&amp;uacute;mero de upvalues.</target>
        </trans-unit>
        <trans-unit id="f56ddb3bc18ad7e4888cfe9050da5f11bd833971" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pops nothing) when the index is greater than the number of active local variables.</source>
          <target state="translated">Devuelve &lt;code&gt;NULL&lt;/code&gt; (y no muestra nada) cuando el &amp;iacute;ndice es mayor que el n&amp;uacute;mero de variables locales activas.</target>
        </trans-unit>
        <trans-unit id="57d7205f6585ea512d11e87992ca7441e1e7627e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pushes nothing) when the index is greater than the number of active local variables.</source>
          <target state="translated">Devuelve &lt;code&gt;NULL&lt;/code&gt; (y no inserta nada) cuando el &amp;iacute;ndice es mayor que el n&amp;uacute;mero de variables locales activas.</target>
        </trans-unit>
        <trans-unit id="33a341b65f8f92cdfebf70c0c2e075fb9c61bdea" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;udata&lt;/code&gt;, or &lt;b&gt;fail&lt;/b&gt; if the userdata does not have that value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfcdfcdeac01eab8c7e33e91fd9027aed705b576" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;udata&lt;/code&gt;.</source>
          <target state="translated">Devuelve &lt;code&gt;udata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95b61d5c1d6df056ea18d8531706d5088a5cc2ec" translate="yes" xml:space="preserve">
          <source>Returns a binary string containing the values &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt;, etc. packed (that is, serialized in binary form) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="translated">Devuelve una cadena binaria que contiene los valores &lt;code&gt;v1&lt;/code&gt; , &lt;code&gt;v2&lt;/code&gt; , etc. empaquetada (es decir, serializada en forma binaria) de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; (ver &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b9eaabee84b326fc38aa7a158662184bb8db15f9" translate="yes" xml:space="preserve">
          <source>Returns a binary string containing the values &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt;, etc. serialized in binary form (packed) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fa3ab9c6fcc7c0b0e41c857bf1c60b601f5344" translate="yes" xml:space="preserve">
          <source>Returns a boolean, true if and only if integer &lt;code&gt;m&lt;/code&gt; is below integer &lt;code&gt;n&lt;/code&gt; when they are compared as unsigned integers.</source>
          <target state="translated">Devuelve un valor booleano, verdadero si y solo si el entero &lt;code&gt;m&lt;/code&gt; est&amp;aacute; por debajo del entero &lt;code&gt;n&lt;/code&gt; cuando se comparan como enteros sin signo.</target>
        </trans-unit>
        <trans-unit id="83c4b62eb52291289917793f1a6cc1b8ea7a62cf" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;s&lt;/code&gt; in which all (or the first &lt;code&gt;n&lt;/code&gt;, if given) occurrences of the &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) have been replaced by a replacement string specified by &lt;code&gt;repl&lt;/code&gt;, which can be a string, a table, or a function. &lt;code&gt;gsub&lt;/code&gt; also returns, as its second value, the total number of matches that occurred. The name &lt;code&gt;gsub&lt;/code&gt; comes from &lt;em&gt;Global SUBstitution&lt;/em&gt;.</source>
          <target state="translated">Devuelve una copia de &lt;code&gt;s&lt;/code&gt; en la que todas (o las primeras &lt;code&gt;n&lt;/code&gt; , si se dan) apariciones del &lt;code&gt;pattern&lt;/code&gt; (ver &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; ) han sido reemplazadas por una cadena de reemplazo especificada por &lt;code&gt;repl&lt;/code&gt; , que puede ser una cadena, una tabla o un funci&amp;oacute;n. &lt;code&gt;gsub&lt;/code&gt; tambi&amp;eacute;n devuelve, como segundo valor, el n&amp;uacute;mero total de coincidencias que se produjeron. El nombre &lt;code&gt;gsub&lt;/code&gt; proviene de &lt;em&gt;Global SUBstitution&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2ddd8b557487a7047dc27604858d100902c9eec4" translate="yes" xml:space="preserve">
          <source>Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the ISO C function &lt;code&gt;sprintf&lt;/code&gt;. The only differences are that the options/modifiers &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt; are not supported and that there is an extra option, &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">Devuelve una versi&amp;oacute;n formateada de su n&amp;uacute;mero variable de argumentos siguiendo la descripci&amp;oacute;n dada en su primer argumento (que debe ser una cadena). La cadena de formato sigue las mismas reglas que la funci&amp;oacute;n ISO C &lt;code&gt;sprintf&lt;/code&gt; . Las &amp;uacute;nicas diferencias son que las opciones / modificadores &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; y &lt;code&gt;p&lt;/code&gt; no son compatibles y que no es una opci&amp;oacute;n adicional, &lt;code&gt;q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf32d68131adf8c84f92b82d86f22e200e2d442a" translate="yes" xml:space="preserve">
          <source>Returns a formatted version of its variable number of arguments following the description given in its first argument, which must be a string. The format string follows the same rules as the ISO C function &lt;code&gt;sprintf&lt;/code&gt;. The only differences are that the conversion specifiers and modifiers &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; are not supported and that there is an extra specifier, &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48dde3bd411386a559edd6defab289be69c364ab" translate="yes" xml:space="preserve">
          <source>Returns a new table with all arguments stored into keys 1, 2, etc. and with a field &quot;&lt;code&gt;n&lt;/code&gt;&quot; with the total number of arguments. Note that the resulting table may not be a sequence, if some arguments are &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e8f9acfbbc61db53d975814a02f1c9aab94a23d" translate="yes" xml:space="preserve">
          <source>Returns a new table with all parameters stored into keys 1, 2, etc. and with a field &quot;&lt;code&gt;n&lt;/code&gt;&quot; with the total number of parameters. Note that the resulting table may not be a sequence.</source>
          <target state="translated">Devuelve una nueva tabla con todos los par&amp;aacute;metros almacenados en las teclas 1, 2, etc. y con un campo &quot; &lt;code&gt;n&lt;/code&gt; &quot; con el n&amp;uacute;mero total de par&amp;aacute;metros. Tenga en cuenta que la tabla resultante puede no ser una secuencia.</target>
        </trans-unit>
        <trans-unit id="04445fdc39272b542d188c106147fa8b6a611119" translate="yes" xml:space="preserve">
          <source>Returns a pointer to a raw memory area associated with the given Lua state. The application can use this area for any purpose; Lua does not use it for anything.</source>
          <target state="translated">Devuelve un puntero a un área de memoria cruda asociada con el estado Lua dado.La aplicación puede usar esta área para cualquier propósito;Lua no la usa para nada.</target>
        </trans-unit>
        <trans-unit id="45395b391aa23f00e9e4439bd741094c423c0b46" translate="yes" xml:space="preserve">
          <source>Returns a pointer to the internal copy of the string (see &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4330812b83811a6da51b5ddf77a1c753b5a3f8" translate="yes" xml:space="preserve">
          <source>Returns a pointer to the internal copy of the string.</source>
          <target state="translated">Devuelve un puntero a la copia interna de la cadena.</target>
        </trans-unit>
        <trans-unit id="110bc8230211fc8ab3a4f90c96eb53b6ace38d6f" translate="yes" xml:space="preserve">
          <source>Returns a string containing a binary representation (a &lt;em&gt;binary chunk&lt;/em&gt;) of the given function, so that a later &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; on this string returns a copy of the function (but with new upvalues). If &lt;code&gt;strip&lt;/code&gt; is a true value, the binary representation may not include all debug information about the function, to save space.</source>
          <target state="translated">Devuelve una cadena que contiene una representaci&amp;oacute;n binaria (un &lt;em&gt;fragmento binario&lt;/em&gt; ) de la funci&amp;oacute;n dada, de modo que una &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; posterior en esta cadena devuelve una copia de la funci&amp;oacute;n (pero con nuevos valores superiores). Si &lt;code&gt;strip&lt;/code&gt; es un valor verdadero, es posible que la representaci&amp;oacute;n binaria no incluya toda la informaci&amp;oacute;n de depuraci&amp;oacute;n sobre la funci&amp;oacute;n, para ahorrar espacio.</target>
        </trans-unit>
        <trans-unit id="7785dcf0d96ed76232f8ceff4782113f5d891ebc" translate="yes" xml:space="preserve">
          <source>Returns a string or a table containing date and time, formatted according to the given string &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">Devuelve una cadena o una tabla que contiene la fecha y la hora, formateada seg&amp;uacute;n el &lt;code&gt;format&lt;/code&gt; o de cadena dado .</target>
        </trans-unit>
        <trans-unit id="e96b629efb1e60f437ca5030afcaedd1ef526018" translate="yes" xml:space="preserve">
          <source>Returns a string that is the concatenation of &lt;code&gt;n&lt;/code&gt; copies of the string &lt;code&gt;s&lt;/code&gt; separated by the string &lt;code&gt;sep&lt;/code&gt;. The default value for &lt;code&gt;sep&lt;/code&gt; is the empty string (that is, no separator). Returns the empty string if &lt;code&gt;n&lt;/code&gt; is not positive.</source>
          <target state="translated">Devuelve una cadena que es la concatenaci&amp;oacute;n de &lt;code&gt;n&lt;/code&gt; copias de la cadena &lt;code&gt;s&lt;/code&gt; separadas por la cadena &lt;code&gt;sep&lt;/code&gt; . El valor predeterminado para &lt;code&gt;sep&lt;/code&gt; es la cadena vac&amp;iacute;a (es decir, sin separador). Devuelve la cadena vac&amp;iacute;a si &lt;code&gt;n&lt;/code&gt; no es positivo.</target>
        </trans-unit>
        <trans-unit id="c23b06e9809db45e6323880c87aa7252a0bafcb4" translate="yes" xml:space="preserve">
          <source>Returns a string that is the string &lt;code&gt;s&lt;/code&gt; reversed.</source>
          <target state="translated">Devuelve una cadena que es la cadena &lt;code&gt;s&lt;/code&gt; invertida.</target>
        </trans-unit>
        <trans-unit id="fc7ced1cf6bbd4c86f0ee87b0d833bbb93586b07" translate="yes" xml:space="preserve">
          <source>Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.</source>
          <target state="translated">Devuelve una cadena con un nombre de archivo que puede ser usado para un archivo temporal.El archivo debe abrirse explícitamente antes de su uso y eliminarse explícitamente cuando ya no se necesite.</target>
        </trans-unit>
        <trans-unit id="aa92524d06f459f4bfe53bf566701137d5986c99" translate="yes" xml:space="preserve">
          <source>Returns a table with information about a function. You can give the function directly or you can give a number as the value of &lt;code&gt;f&lt;/code&gt;, which means the function running at level &lt;code&gt;f&lt;/code&gt; of the call stack of the given thread: level 0 is the current function (&lt;code&gt;getinfo&lt;/code&gt; itself); level 1 is the function that called &lt;code&gt;getinfo&lt;/code&gt; (except for tail calls, which do not count in the stack); and so on. If &lt;code&gt;f&lt;/code&gt; is a number greater than the number of active functions, then &lt;code&gt;getinfo&lt;/code&gt; returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41736de9eba1b5a23348a72c73555dbf11b75db2" translate="yes" xml:space="preserve">
          <source>Returns a table with information about a function. You can give the function directly or you can give a number as the value of &lt;code&gt;f&lt;/code&gt;, which means the function running at level &lt;code&gt;f&lt;/code&gt; of the call stack of the given thread: level 0 is the current function (&lt;code&gt;getinfo&lt;/code&gt; itself); level 1 is the function that called &lt;code&gt;getinfo&lt;/code&gt; (except for tail calls, which do not count on the stack); and so on. If &lt;code&gt;f&lt;/code&gt; is a number larger than the number of active functions, then &lt;code&gt;getinfo&lt;/code&gt; returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Devuelve una tabla con informaci&amp;oacute;n sobre una funci&amp;oacute;n. Puede dar la funci&amp;oacute;n directamente o puede dar un n&amp;uacute;mero como el valor de &lt;code&gt;f&lt;/code&gt; , lo que significa que la funci&amp;oacute;n se est&amp;aacute; ejecutando en el nivel &lt;code&gt;f&lt;/code&gt; de la pila de llamadas del hilo dado: el nivel 0 es la funci&amp;oacute;n actual ( &lt;code&gt;getinfo&lt;/code&gt; en s&amp;iacute;); el nivel 1 es la funci&amp;oacute;n que llam&amp;oacute; a &lt;code&gt;getinfo&lt;/code&gt; (excepto para las llamadas de cola, que no cuentan en la pila); y as&amp;iacute;. Si &lt;code&gt;f&lt;/code&gt; es un n&amp;uacute;mero mayor que el n&amp;uacute;mero de funciones activas, entonces &lt;code&gt;getinfo&lt;/code&gt; devuelve &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="10b30ad1ae8da522aed09e1a02ace7921e1f51a6" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier (as a light userdata) for the upvalue numbered &lt;code&gt;n&lt;/code&gt; from the given function.</source>
          <target state="translated">Devuelve un identificador &amp;uacute;nico (como datos de usuario ligeros) para el valor superior numerado &lt;code&gt;n&lt;/code&gt; de la funci&amp;oacute;n dada.</target>
        </trans-unit>
        <trans-unit id="0b3fe57552c933213408135c6244c0db831931eb" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier for the upvalue numbered &lt;code&gt;n&lt;/code&gt; from the closure at index &lt;code&gt;funcindex&lt;/code&gt;.</source>
          <target state="translated">Devuelve un identificador &amp;uacute;nico para el upvalue numerado &lt;code&gt;n&lt;/code&gt; del cierre en index &lt;code&gt;funcindex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bee587bfd0df43f919edb6f2e537b30c2fff9e47" translate="yes" xml:space="preserve">
          <source>Returns an address to a space of size &lt;code&gt;sz&lt;/code&gt; where you can copy a string to be added to buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). After copying the string into this space you must call &lt;a href=&quot;#luaL_addsize&quot;&gt;&lt;code&gt;luaL_addsize&lt;/code&gt;&lt;/a&gt; with the size of the string to actually add it to the buffer.</source>
          <target state="translated">Devuelve una direcci&amp;oacute;n a un espacio de tama&amp;ntilde;o &lt;code&gt;sz&lt;/code&gt; donde puede copiar una cadena para agregarla al b&amp;uacute;fer &lt;code&gt;B&lt;/code&gt; (ver &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ). Despu&amp;eacute;s de copiar la cadena en este espacio, debe llamar a &lt;a href=&quot;#luaL_addsize&quot;&gt; &lt;code&gt;luaL_addsize&lt;/code&gt; &lt;/a&gt; con el tama&amp;ntilde;o de la cadena para agregarla al b&amp;uacute;fer.</target>
        </trans-unit>
        <trans-unit id="aee809e239d975376124c38ef9a8bbd38533ebb2" translate="yes" xml:space="preserve">
          <source>Returns an approximation of the amount in seconds of CPU time used by the program, as returned by the underlying ISO C function &lt;code&gt;clock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791d30f65759aca9bc8c2ab0c81b3414394fb75d" translate="yes" xml:space="preserve">
          <source>Returns an approximation of the amount in seconds of CPU time used by the program.</source>
          <target state="translated">Devuelve una aproximación de la cantidad en segundos de tiempo de CPU utilizado por el programa.</target>
        </trans-unit>
        <trans-unit id="ed3bd9acca66b3345ff64ecf82770701deaf6e39" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, reads the file according to the given formats. When no format is given, uses &quot;&lt;code&gt;l&lt;/code&gt;&quot; as a default. As an example, the construction</source>
          <target state="translated">Devuelve una funci&amp;oacute;n de iterador que, cada vez que se llama, lee el archivo de acuerdo con los formatos dados. Cuando no se proporciona ning&amp;uacute;n formato, utiliza &quot; &lt;code&gt;l&lt;/code&gt; &quot; por defecto. Como ejemplo, la construcci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="9502ef377c9031927e39c05f93ef446921a0becd" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, returns the next captures from &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) over the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is produced in each call.</source>
          <target state="translated">Devuelve una funci&amp;oacute;n iteradora que, cada vez que se llama, devuelve las siguientes capturas del &lt;code&gt;pattern&lt;/code&gt; (ver &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; ) sobre la cadena &lt;code&gt;s&lt;/code&gt; . Si el &lt;code&gt;pattern&lt;/code&gt; no especifica capturas, entonces se produce toda la coincidencia en cada llamada.</target>
        </trans-unit>
        <trans-unit id="45001f49f50b2b70b2e8422ff32e20831e96980c" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, returns the next captures from &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) over the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is produced in each call. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d0a5b7853c9d4da9293e66e82d86cf0df6305f" translate="yes" xml:space="preserve">
          <source>Returns the &quot;length&quot; of the value at the given index as a number; it is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). Raises an error if the result of the operation is not an integer. (This case can only happen through metamethods.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5fe629e50500647001f1530cb02685325af73a" translate="yes" xml:space="preserve">
          <source>Returns the &quot;length&quot; of the value at the given index as a number; it is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). Raises an error if the result of the operation is not an integer. (This case only can happen through metamethods.)</source>
          <target state="translated">Devuelve la &quot;longitud&quot; del valor en el &amp;iacute;ndice dado como un n&amp;uacute;mero; es equivalente al operador ' &lt;code&gt;#&lt;/code&gt; ' en Lua (ver &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; ). Genera un error si el resultado de la operaci&amp;oacute;n no es un n&amp;uacute;mero entero. (Este caso solo puede ocurrir a trav&amp;eacute;s de metam&amp;eacute;todos).</target>
        </trans-unit>
        <trans-unit id="f1e0f7037fc97a264b1135ee9cbbd443e4839b55" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;n&lt;/code&gt;-th user value associated to the userdata &lt;code&gt;u&lt;/code&gt; plus a boolean, &lt;b&gt;false&lt;/b&gt; if the userdata does not have that value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db78771d6acbed28111d58cf748f20e4959f1e52" translate="yes" xml:space="preserve">
          <source>Returns the Lua value associated to &lt;code&gt;u&lt;/code&gt;. If &lt;code&gt;u&lt;/code&gt; is not a full userdata, returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Devuelve el valor de Lua asociado a &lt;code&gt;u&lt;/code&gt; . Si &lt;code&gt;u&lt;/code&gt; no es un usuario completo, devuelve &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d1851a04bfd13cc05cd523998c36bdc322db17e1" translate="yes" xml:space="preserve">
          <source>Returns the absolute value of &lt;code&gt;x&lt;/code&gt;. (integer/float)</source>
          <target state="translated">Devuelve el valor absoluto de &lt;code&gt;x&lt;/code&gt; . (entero / flotante)</target>
        </trans-unit>
        <trans-unit id="043e0287b11b1a9c8f88357339923c8234440ef7" translate="yes" xml:space="preserve">
          <source>Returns the address of the current content of buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). Note that any addition to the buffer may invalidate this address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e9a2e3f9c2da4b70e14502d18cc907361074e9" translate="yes" xml:space="preserve">
          <source>Returns the address of the version number (a C static variable) stored in the Lua core. When called with a valid &lt;a href=&quot;#lua_State&quot;&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt;, returns the address of the version used to create that state. When called with &lt;code&gt;NULL&lt;/code&gt;, returns the address of the version running the call.</source>
          <target state="translated">Devuelve la direcci&amp;oacute;n del n&amp;uacute;mero de versi&amp;oacute;n (una variable est&amp;aacute;tica de C) almacenado en el n&amp;uacute;cleo de Lua. Cuando se llama con un &lt;a href=&quot;#lua_State&quot;&gt; &lt;code&gt;lua_State&lt;/code&gt; &lt;/a&gt; v&amp;aacute;lido , devuelve la direcci&amp;oacute;n de la versi&amp;oacute;n utilizada para crear ese estado. Cuando se llama con &lt;code&gt;NULL&lt;/code&gt; , devuelve la direcci&amp;oacute;n de la versi&amp;oacute;n que ejecuta la llamada.</target>
        </trans-unit>
        <trans-unit id="d492dc5dd4aa5f92735d2073fff7474e1a6b394e" translate="yes" xml:space="preserve">
          <source>Returns the arc cosine of &lt;code&gt;x&lt;/code&gt; (in radians).</source>
          <target state="translated">Devuelve el arco coseno de &lt;code&gt;x&lt;/code&gt; (en radianes).</target>
        </trans-unit>
        <trans-unit id="f089a8dff08d67188de1f7c5039f149b9fa4a377" translate="yes" xml:space="preserve">
          <source>Returns the arc sine of &lt;code&gt;x&lt;/code&gt; (in radians).</source>
          <target state="translated">Devuelve el arco seno de &lt;code&gt;x&lt;/code&gt; (en radianes).</target>
        </trans-unit>
        <trans-unit id="fa1247ba15c62e976046573c6ccc1feeee2f5b6b" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (in radians), but uses the signs of both arguments to find the quadrant of the result. It also handles correctly the case of &lt;code&gt;x&lt;/code&gt; being zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94a36782eb1a80f58363dabc61ceebcb41f258d2" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of &lt;code&gt;x&lt;/code&gt; being zero.)</source>
          <target state="translated">Devuelve el arco tangente de &lt;code&gt;y/x&lt;/code&gt; (en radianes), pero usa los signos de ambos par&amp;aacute;metros para encontrar el cuadrante del resultado. (Tambi&amp;eacute;n maneja correctamente el caso de que &lt;code&gt;x&lt;/code&gt; sea ​​cero).</target>
        </trans-unit>
        <trans-unit id="54bafb79a60778cdf93eb8dffe6dc26866068180" translate="yes" xml:space="preserve">
          <source>Returns the argument with the maximum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4793305a62a7e062a99c696537172768770061" translate="yes" xml:space="preserve">
          <source>Returns the argument with the maximum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;. (integer/float)</source>
          <target state="translated">Devuelve el argumento con el valor m&amp;aacute;ximo, seg&amp;uacute;n el operador Lua &lt;code&gt;&amp;lt;&lt;/code&gt; . (entero / flotante)</target>
        </trans-unit>
        <trans-unit id="d704759b0150aa7e291bb40d3b9e1aa860586ad0" translate="yes" xml:space="preserve">
          <source>Returns the argument with the minimum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b18e62742fdde277f18684dd6adb5af258b562" translate="yes" xml:space="preserve">
          <source>Returns the argument with the minimum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;. (integer/float)</source>
          <target state="translated">Devuelve el argumento con el valor m&amp;iacute;nimo, seg&amp;uacute;n el operador Lua &lt;code&gt;&amp;lt;&lt;/code&gt; . (entero / flotante)</target>
        </trans-unit>
        <trans-unit id="e0191dad2cae73c27ef7de25f92860dda78cff8d" translate="yes" xml:space="preserve">
          <source>Returns the code points (as integers) from all characters in &lt;code&gt;s&lt;/code&gt; that start between byte position &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both included). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. It raises an error if it meets any invalid byte sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008974cf3ea7a0e47cc66825ae9db754a6215ba2" translate="yes" xml:space="preserve">
          <source>Returns the codepoints (as integers) from all characters in &lt;code&gt;s&lt;/code&gt; that start between byte position &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both included). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. It raises an error if it meets any invalid byte sequence.</source>
          <target state="translated">Devuelve los puntos de c&amp;oacute;digo (como n&amp;uacute;meros enteros) de todos los caracteres en &lt;code&gt;s&lt;/code&gt; que comienzan entre la posici&amp;oacute;n del byte &lt;code&gt;i&lt;/code&gt; y &lt;code&gt;j&lt;/code&gt; (ambos incluidos). El valor predeterminado para &lt;code&gt;i&lt;/code&gt; es 1 y para &lt;code&gt;j&lt;/code&gt; es &lt;code&gt;i&lt;/code&gt; . Genera un error si encuentra alguna secuencia de bytes no v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="4e9e95635ca72435ec1e4654b329133fcb9b67b6" translate="yes" xml:space="preserve">
          <source>Returns the cosine of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">Devuelve el coseno de &lt;code&gt;x&lt;/code&gt; (se supone que est&amp;aacute; en radianes).</target>
        </trans-unit>
        <trans-unit id="d63943c503fbdbc9daf70eb8b368eb63c603cce5" translate="yes" xml:space="preserve">
          <source>Returns the current hook count.</source>
          <target state="translated">Devuelve el número de ganchos actual.</target>
        </trans-unit>
        <trans-unit id="91adc8b466cf6e5462daa3cdcd2555a890c15635" translate="yes" xml:space="preserve">
          <source>Returns the current hook function.</source>
          <target state="translated">Devuelve la función de gancho actual.</target>
        </trans-unit>
        <trans-unit id="77c0c811e0708693f332c243247f1f4509702b82" translate="yes" xml:space="preserve">
          <source>Returns the current hook mask.</source>
          <target state="translated">Devuelve la máscara de gancho actual.</target>
        </trans-unit>
        <trans-unit id="dfa58fd57235ee80a6d63769d911723e3534cac8" translate="yes" xml:space="preserve">
          <source>Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; function).</source>
          <target state="translated">Devuelve la configuraci&amp;oacute;n de gancho actual del hilo, como tres valores: la funci&amp;oacute;n de gancho actual, la m&amp;aacute;scara de gancho actual y el recuento de gancho actual (seg&amp;uacute;n lo establecido por la funci&amp;oacute;n &lt;a href=&quot;#pdf-debug.sethook&quot;&gt; &lt;code&gt;debug.sethook&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="732a0eb24511cdffe2ee8db1f2a63d0d03797e0b" translate="yes" xml:space="preserve">
          <source>Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count, as set by the &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4984b9b007c5eee4f424cfbc9e8ac599f7bc3b2" translate="yes" xml:space="preserve">
          <source>Returns the current time when called without arguments, or a time representing the local date and time specified by the given table. This table must have fields &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, and &lt;code&gt;day&lt;/code&gt;, and may have fields &lt;code&gt;hour&lt;/code&gt; (default is 12), &lt;code&gt;min&lt;/code&gt; (default is 0), &lt;code&gt;sec&lt;/code&gt; (default is 0), and &lt;code&gt;isdst&lt;/code&gt; (default is &lt;b&gt;nil&lt;/b&gt;). Other fields are ignored. For a description of these fields, see the &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Devuelve la hora actual cuando se llama sin argumentos, o una hora que representa la fecha y hora locales especificadas por la tabla dada. Esta tabla debe tener campos &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; y &lt;code&gt;day&lt;/code&gt; , y puede tener campos &lt;code&gt;hour&lt;/code&gt; (el valor predeterminado es 12), &lt;code&gt;min&lt;/code&gt; (el valor predeterminado es 0), &lt;code&gt;sec&lt;/code&gt; (el valor predeterminado es 0) e &lt;code&gt;isdst&lt;/code&gt; (el valor predeterminado es &lt;b&gt;nulo&lt;/b&gt; ). Los dem&amp;aacute;s campos se ignoran. Para obtener una descripci&amp;oacute;n de estos campos, consulte la funci&amp;oacute;n &lt;a href=&quot;#pdf-os.date&quot;&gt; &lt;code&gt;os.date&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b56d9d3e264bf539db578bb8f6317e05525f18e" translate="yes" xml:space="preserve">
          <source>Returns the destination table &lt;code&gt;a2&lt;/code&gt;.</source>
          <target state="translated">Devuelve la tabla de destino &lt;code&gt;a2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a89ca3dbaee05fa9562365bbb11bd2987b8b36f" translate="yes" xml:space="preserve">
          <source>Returns the difference, in seconds, from time &lt;code&gt;t1&lt;/code&gt; to time &lt;code&gt;t2&lt;/code&gt; (where the times are values returned by &lt;a href=&quot;#pdf-os.time&quot;&gt;&lt;code&gt;os.time&lt;/code&gt;&lt;/a&gt;). In POSIX, Windows, and some other systems, this value is exactly &lt;code&gt;t2&lt;/code&gt;&lt;em&gt;-&lt;/em&gt;&lt;code&gt;t1&lt;/code&gt;.</source>
          <target state="translated">Devuelve la diferencia, en segundos, del tiempo &lt;code&gt;t1&lt;/code&gt; al tiempo &lt;code&gt;t2&lt;/code&gt; (donde los tiempos son valores devueltos por &lt;a href=&quot;#pdf-os.time&quot;&gt; &lt;code&gt;os.time&lt;/code&gt; &lt;/a&gt; ). En POSIX, Windows y algunos otros sistemas, este valor es exactamente &lt;code&gt;t2&lt;/code&gt; &lt;em&gt;- &lt;/em&gt; &lt;code&gt;t1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74ef8f0d43907d8993cbf07845e98c64309c4c57" translate="yes" xml:space="preserve">
          <source>Returns the elements from the given list. This function is equivalent to</source>
          <target state="translated">Devuelve los elementos de la lista dada.Esta función es equivalente a</target>
        </trans-unit>
        <trans-unit id="a0ecb44d1768c16defe86a7226eb7cdb677c4d76" translate="yes" xml:space="preserve">
          <source>Returns the index of the top element in the stack. Because indices start at 1, this result is equal to the number of elements in the stack; in particular, 0 means an empty stack.</source>
          <target state="translated">Devuelve el índice del elemento superior de la pila.Debido a que los índices comienzan en 1,este resultado es igual al número de elementos en la pila;en particular,0 significa una pila vacía.</target>
        </trans-unit>
        <trans-unit id="aae1a98a2afe7e2f6164ed56d98f2c5601c177ce" translate="yes" xml:space="preserve">
          <source>Returns the integral part of &lt;code&gt;x&lt;/code&gt; and the fractional part of &lt;code&gt;x&lt;/code&gt;. Its second result is always a float.</source>
          <target state="translated">Devuelve la parte integral de &lt;code&gt;x&lt;/code&gt; y la parte fraccionaria de &lt;code&gt;x&lt;/code&gt; . Su segundo resultado es siempre un flotador.</target>
        </trans-unit>
        <trans-unit id="d07d66699f96edb0b840ccb7b505ca206ea713f8" translate="yes" xml:space="preserve">
          <source>Returns the internal numeric codes of the characters &lt;code&gt;s[i]&lt;/code&gt;, &lt;code&gt;s[i+1]&lt;/code&gt;, ..., &lt;code&gt;s[j]&lt;/code&gt;. The default value for &lt;code&gt;i&lt;/code&gt; is 1; the default value for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. These indices are corrected following the same rules of function &lt;a href=&quot;#pdf-string.sub&quot;&gt;&lt;code&gt;string.sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Devuelve los c&amp;oacute;digos num&amp;eacute;ricos internos de los caracteres &lt;code&gt;s[i]&lt;/code&gt; , &lt;code&gt;s[i+1]&lt;/code&gt; , ..., &lt;code&gt;s[j]&lt;/code&gt; . El valor predeterminado para &lt;code&gt;i&lt;/code&gt; es 1; el valor predeterminado para &lt;code&gt;j&lt;/code&gt; es &lt;code&gt;i&lt;/code&gt; . Estos &amp;iacute;ndices se corrigen siguiendo las mismas reglas de funci&amp;oacute;n &lt;a href=&quot;#pdf-string.sub&quot;&gt; &lt;code&gt;string.sub&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b30312394bff808c7607188052990ddfc3f0af18" translate="yes" xml:space="preserve">
          <source>Returns the largest integral value less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a74944cfaba1cf96089aa04c3aab36bd768194" translate="yes" xml:space="preserve">
          <source>Returns the largest integral value smaller than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Devuelve el mayor valor integral menor o igual &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b65eebb8bdbd39036e0d29924f25daa397f311e" translate="yes" xml:space="preserve">
          <source>Returns the length of the current content of buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a82986faba63c6df7b4a7e1f2c3e8675bebec131" translate="yes" xml:space="preserve">
          <source>Returns the length of the object &lt;code&gt;v&lt;/code&gt;, which must be a table or a string, without invoking the &lt;code&gt;__len&lt;/code&gt; metamethod. Returns an integer.</source>
          <target state="translated">Devuelve la longitud del objeto &lt;code&gt;v&lt;/code&gt; , que debe ser una tabla o una cadena, sin invocar el &lt;code&gt;__len&lt;/code&gt; __len. Devuelve un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="4d195539511c55ff9d09810f9cb9cabd46d5d2c6" translate="yes" xml:space="preserve">
          <source>Returns the length of the value at the given index. It is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;) and may trigger a metamethod for the &quot;length&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). The result is pushed on the stack.</source>
          <target state="translated">Devuelve la longitud del valor en el &amp;iacute;ndice dado. Es equivalente al operador ' &lt;code&gt;#&lt;/code&gt; ' en Lua (ver &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; ) y puede activar un metam&amp;eacute;todo para el evento &quot;length&quot; (ver &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ). El resultado se coloca en la pila.</target>
        </trans-unit>
        <trans-unit id="ca18490544ebe4ab9d2b88782ccfa4bfa597d5c6" translate="yes" xml:space="preserve">
          <source>Returns the logarithm of &lt;code&gt;x&lt;/code&gt; in the given base. The default for &lt;code&gt;base&lt;/code&gt; is &lt;em&gt;e&lt;/em&gt; (so that the function returns the natural logarithm of &lt;code&gt;x&lt;/code&gt;).</source>
          <target state="translated">Devuelve el logaritmo de &lt;code&gt;x&lt;/code&gt; en la base dada. El valor predeterminado para la &lt;code&gt;base&lt;/code&gt; es &lt;em&gt;e&lt;/em&gt; (de modo que la funci&amp;oacute;n devuelve el logaritmo natural de &lt;code&gt;x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d77d922681562ed53526ab1cca990af72395285d" translate="yes" xml:space="preserve">
          <source>Returns the maximum value between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;-x&lt;/code&gt;. (integer/float)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3cb57918cd0fd4016648ae402c7074bcd73a43b" translate="yes" xml:space="preserve">
          <source>Returns the memory-allocation function of a given state. If &lt;code&gt;ud&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, Lua stores in &lt;code&gt;*ud&lt;/code&gt; the opaque pointer given when the memory-allocator function was set.</source>
          <target state="translated">Devuelve la funci&amp;oacute;n de asignaci&amp;oacute;n de memoria de un estado dado. Si &lt;code&gt;ud&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , Lua almacena en &lt;code&gt;*ud&lt;/code&gt; el puntero opaco dado cuando se estableci&amp;oacute; la funci&amp;oacute;n de asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="274b26f09340089c109b77fcaa34ab85c7b27be3" translate="yes" xml:space="preserve">
          <source>Returns the metatable of the given &lt;code&gt;value&lt;/code&gt; or &lt;b&gt;nil&lt;/b&gt; if it does not have a metatable.</source>
          <target state="translated">Devuelve la metatabla del &lt;code&gt;value&lt;/code&gt; dado o &lt;b&gt;nil&lt;/b&gt; si no tiene una metatabla.</target>
        </trans-unit>
        <trans-unit id="f827b993d336f39e4e067ba1cd00ca433786753f" translate="yes" xml:space="preserve">
          <source>Returns the name of the type encoded by the value &lt;code&gt;tp&lt;/code&gt;, which must be one the values returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Devuelve el nombre del tipo codificado por el valor &lt;code&gt;tp&lt;/code&gt; , que debe ser uno de los valores devueltos por &lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5d2c5467f6b31c133d151a482f437390192631a" translate="yes" xml:space="preserve">
          <source>Returns the name of the type of the value at the given index.</source>
          <target state="translated">Devuelve el nombre del tipo de valor en el índice dado.</target>
        </trans-unit>
        <trans-unit id="09f17fbeecb99d8ceed703c8e378ebf644bfa53e" translate="yes" xml:space="preserve">
          <source>Returns the new state, or &lt;code&gt;NULL&lt;/code&gt; if there is a memory allocation error.</source>
          <target state="translated">Devuelve el nuevo estado o &lt;code&gt;NULL&lt;/code&gt; si hay un error de asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="d43b7f45fadd64b442bc6cb030aac62b5fed9b46" translate="yes" xml:space="preserve">
          <source>Returns the number of UTF-8 characters in string &lt;code&gt;s&lt;/code&gt; that start between positions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both inclusive). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is -1. If it finds any invalid byte sequence, returns &lt;b&gt;fail&lt;/b&gt; plus the position of the first invalid byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fac8d97901da4fcfa21c51273c8ade3e30d4960" translate="yes" xml:space="preserve">
          <source>Returns the number of UTF-8 characters in string &lt;code&gt;s&lt;/code&gt; that start between positions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both inclusive). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is -1. If it finds any invalid byte sequence, returns a false value plus the position of the first invalid byte.</source>
          <target state="translated">Devuelve el n&amp;uacute;mero de caracteres UTF-8 en la cadena &lt;code&gt;s&lt;/code&gt; que comienzan entre las posiciones &lt;code&gt;i&lt;/code&gt; y &lt;code&gt;j&lt;/code&gt; (ambas inclusive). El valor predeterminado para &lt;code&gt;i&lt;/code&gt; es 1 y para &lt;code&gt;j&lt;/code&gt; es -1. Si encuentra una secuencia de bytes no v&amp;aacute;lida, devuelve un valor falso m&amp;aacute;s la posici&amp;oacute;n del primer byte no v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="84f83acaebe526961dfec0323624b3e5b62c9fd0" translate="yes" xml:space="preserve">
          <source>Returns the position (in bytes) where the encoding of the &lt;code&gt;n&lt;/code&gt;-th character of &lt;code&gt;s&lt;/code&gt; (counting from position &lt;code&gt;i&lt;/code&gt;) starts. A negative &lt;code&gt;n&lt;/code&gt; gets characters before position &lt;code&gt;i&lt;/code&gt;. The default for &lt;code&gt;i&lt;/code&gt; is 1 when &lt;code&gt;n&lt;/code&gt; is non-negative and &lt;code&gt;#s + 1&lt;/code&gt; otherwise, so that &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; gets the offset of the &lt;code&gt;n&lt;/code&gt;-th character from the end of the string. If the specified character is neither in the subject nor right after its end, the function returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c4cc904851482307ead3085d1ccd1030454da6" translate="yes" xml:space="preserve">
          <source>Returns the position (in bytes) where the encoding of the &lt;code&gt;n&lt;/code&gt;-th character of &lt;code&gt;s&lt;/code&gt; (counting from position &lt;code&gt;i&lt;/code&gt;) starts. A negative &lt;code&gt;n&lt;/code&gt; gets characters before position &lt;code&gt;i&lt;/code&gt;. The default for &lt;code&gt;i&lt;/code&gt; is 1 when &lt;code&gt;n&lt;/code&gt; is non-negative and &lt;code&gt;#s + 1&lt;/code&gt; otherwise, so that &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; gets the offset of the &lt;code&gt;n&lt;/code&gt;-th character from the end of the string. If the specified character is neither in the subject nor right after its end, the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Devuelve la posici&amp;oacute;n (en bytes) donde comienza la codificaci&amp;oacute;n del &lt;code&gt;n&lt;/code&gt; -&amp;eacute;simo car&amp;aacute;cter de &lt;code&gt;s&lt;/code&gt; (contando desde la posici&amp;oacute;n &lt;code&gt;i&lt;/code&gt; ). Una &lt;code&gt;n&lt;/code&gt; negativa obtiene caracteres antes de la posici&amp;oacute;n &lt;code&gt;i&lt;/code&gt; . El valor predeterminado para &lt;code&gt;i&lt;/code&gt; es 1 cuando &lt;code&gt;n&lt;/code&gt; no es negativo y &lt;code&gt;#s + 1&lt;/code&gt; caso contrario, de modo que &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; obtiene el desplazamiento del &lt;code&gt;n&lt;/code&gt; -&amp;eacute;simo car&amp;aacute;cter desde el final de la cadena. Si el car&amp;aacute;cter especificado no est&amp;aacute; en el sujeto ni justo despu&amp;eacute;s de su final, la funci&amp;oacute;n devuelve &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3fa00427da0e5f4dcde3c242518db402bf818a" translate="yes" xml:space="preserve">
          <source>Returns the pseudo-index that represents the &lt;code&gt;i&lt;/code&gt;-th upvalue of the running function (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;). &lt;code&gt;i&lt;/code&gt; must be in the range &lt;em&gt;[1,256]&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc45c511f20e727c297897c4a412e04b9bb492de" translate="yes" xml:space="preserve">
          <source>Returns the pseudo-index that represents the &lt;code&gt;i&lt;/code&gt;-th upvalue of the running function (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;).</source>
          <target state="translated">Devuelve el pseudo&amp;iacute;ndice que representa el &lt;code&gt;i&lt;/code&gt; -&amp;eacute;simo valor ascendente de la funci&amp;oacute;n en ejecuci&amp;oacute;n (consulte &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="33f56655c8e98bdcbd9254da5f1e14cc5e047720" translate="yes" xml:space="preserve">
          <source>Returns the raw &quot;length&quot; of the value at the given index: for strings, this is the string length; for tables, this is the result of the length operator ('&lt;code&gt;#&lt;/code&gt;') with no metamethods; for userdata, this is the size of the block of memory allocated for the userdata. For other values, this call returns 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d8bb977f9b8a6f1742fd3f9dc45db22e1fcb68" translate="yes" xml:space="preserve">
          <source>Returns the raw &quot;length&quot; of the value at the given index: for strings, this is the string length; for tables, this is the result of the length operator ('&lt;code&gt;#&lt;/code&gt;') with no metamethods; for userdata, this is the size of the block of memory allocated for the userdata; for other values, it is 0.</source>
          <target state="translated">Devuelve la &quot;longitud&quot; sin procesar del valor en el &amp;iacute;ndice dado: para cadenas, esta es la longitud de la cadena; para tablas, este es el resultado del operador de longitud (' &lt;code&gt;#&lt;/code&gt; ') sin metam&amp;eacute;todos; para datos de usuario, este es el tama&amp;ntilde;o del bloque de memoria asignado para los datos de usuario; para otros valores, es 0.</target>
        </trans-unit>
        <trans-unit id="94fe4847ff4993fa7c4fb27d617dd7c02c05a931" translate="yes" xml:space="preserve">
          <source>Returns the registry table (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4878c08432faeac78e45f44f0026ebddb8749ef" translate="yes" xml:space="preserve">
          <source>Returns the registry table (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="translated">Devuelve la tabla de registro (consulte &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1f182d1d0910847b92e9f446a7345b1cf7e93ffa" translate="yes" xml:space="preserve">
          <source>Returns the remainder of the division of &lt;code&gt;x&lt;/code&gt; by &lt;code&gt;y&lt;/code&gt; that rounds the quotient towards zero. (integer/float)</source>
          <target state="translated">Devuelve el resto de la divisi&amp;oacute;n de &lt;code&gt;x&lt;/code&gt; por &lt;code&gt;y&lt;/code&gt; que redondea el cociente hacia cero. (entero / flotante)</target>
        </trans-unit>
        <trans-unit id="568e6f5ede477aed12d9d477add4ad442b3fde9c" translate="yes" xml:space="preserve">
          <source>Returns the resulting name of the first file that it can open in read mode (after closing the file), or &lt;b&gt;fail&lt;/b&gt; plus an error message if none succeeds. (This error message lists all file names it tried to open.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d00adfd429e9ecb79de1d7e05907584e1f561cc" translate="yes" xml:space="preserve">
          <source>Returns the resulting name of the first file that it can open in read mode (after closing the file), or &lt;b&gt;nil&lt;/b&gt; plus an error message if none succeeds. (This error message lists all file names it tried to open.)</source>
          <target state="translated">Devuelve el nombre resultante del primer archivo que puede abrir en modo lectura (despu&amp;eacute;s de cerrar el archivo), o &lt;b&gt;nil&lt;/b&gt; m&amp;aacute;s un mensaje de error si ninguno tiene &amp;eacute;xito. (Este mensaje de error enumera todos los nombres de archivo que intent&amp;oacute; abrir).</target>
        </trans-unit>
        <trans-unit id="0cafeada936b9b3c536bfda3d7c114159746bc82" translate="yes" xml:space="preserve">
          <source>Returns the running coroutine plus a boolean, true when the running coroutine is the main one.</source>
          <target state="translated">Devuelve la rutina de correr más una booleana,cierto cuando la rutina de correr es la principal.</target>
        </trans-unit>
        <trans-unit id="f520f4734dbc499082a5c134aebb7e5257b19210" translate="yes" xml:space="preserve">
          <source>Returns the sine of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">Devuelve el seno de &lt;code&gt;x&lt;/code&gt; (se supone que est&amp;aacute; en radianes).</target>
        </trans-unit>
        <trans-unit id="da558ef5afc0fc9c0d21911a38e825ff24dcf0a2" translate="yes" xml:space="preserve">
          <source>Returns the size of a string resulting from &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; with the given format. The format string cannot have the variable-length options '&lt;code&gt;s&lt;/code&gt;' or '&lt;code&gt;z&lt;/code&gt;' (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="translated">Devuelve el tama&amp;ntilde;o de una cadena resultante de &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; con el formato dado. La cadena de formato no puede tener las opciones de longitud variable ' &lt;code&gt;s&lt;/code&gt; ' o ' &lt;code&gt;z&lt;/code&gt; ' (consulte &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8a271ccad0d5f1305d18e3f34055196791089e29" translate="yes" xml:space="preserve">
          <source>Returns the smallest integral value greater than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b392e0c4352ffea2f8586f23e071e85ca1ffec" translate="yes" xml:space="preserve">
          <source>Returns the smallest integral value larger than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Devuelve el valor integral m&amp;aacute;s peque&amp;ntilde;o mayor o igual que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a156517157e4cb0343c49c32e737cf3b8fa30ca3" translate="yes" xml:space="preserve">
          <source>Returns the square root of &lt;code&gt;x&lt;/code&gt;. (You can also use the expression &lt;code&gt;x^0.5&lt;/code&gt; to compute this value.)</source>
          <target state="translated">Devuelve la ra&amp;iacute;z cuadrada de &lt;code&gt;x&lt;/code&gt; . (Tambi&amp;eacute;n puede usar la expresi&amp;oacute;n &lt;code&gt;x^0.5&lt;/code&gt; para calcular este valor).</target>
        </trans-unit>
        <trans-unit id="92c7a785497146b5964e3cfcb16d7bf24c7763b5" translate="yes" xml:space="preserve">
          <source>Returns the status of coroutine &lt;code&gt;co&lt;/code&gt;, as a string: &lt;code&gt;&quot;running&quot;&lt;/code&gt;, if the coroutine is running (that is, it called &lt;code&gt;status&lt;/code&gt;); &lt;code&gt;&quot;suspended&quot;&lt;/code&gt;, if the coroutine is suspended in a call to &lt;code&gt;yield&lt;/code&gt;, or if it has not started running yet; &lt;code&gt;&quot;normal&quot;&lt;/code&gt; if the coroutine is active but not running (that is, it has resumed another coroutine); and &lt;code&gt;&quot;dead&quot;&lt;/code&gt; if the coroutine has finished its body function, or if it has stopped with an error.</source>
          <target state="translated">Devuelve el estado de coroutine &lt;code&gt;co&lt;/code&gt; , como una cadena: &lt;code&gt;&quot;running&quot;&lt;/code&gt; , si la coroutine est&amp;aacute; en ejecuci&amp;oacute;n (es decir, se llama &lt;code&gt;status&lt;/code&gt; ); &lt;code&gt;&quot;suspended&quot;&lt;/code&gt; , si la corrutina se suspende en una llamada a &lt;code&gt;yield&lt;/code&gt; , o si a&amp;uacute;n no ha comenzado a ejecutarse; &lt;code&gt;&quot;normal&quot;&lt;/code&gt; si la corrutina est&amp;aacute; activa pero no se est&amp;aacute; ejecutando (es decir, ha reanudado otra corrutina); y &lt;code&gt;&quot;dead&quot;&lt;/code&gt; si la corrutina ha terminado su funci&amp;oacute;n corporal, o si se ha detenido con un error.</target>
        </trans-unit>
        <trans-unit id="ae60fb59b3fcc2ee3f16755978255651eb156610" translate="yes" xml:space="preserve">
          <source>Returns the status of the coroutine &lt;code&gt;co&lt;/code&gt;, as a string: &lt;code&gt;&quot;running&quot;&lt;/code&gt;, if the coroutine is running (that is, it is the one that called &lt;code&gt;status&lt;/code&gt;); &lt;code&gt;&quot;suspended&quot;&lt;/code&gt;, if the coroutine is suspended in a call to &lt;code&gt;yield&lt;/code&gt;, or if it has not started running yet; &lt;code&gt;&quot;normal&quot;&lt;/code&gt; if the coroutine is active but not running (that is, it has resumed another coroutine); and &lt;code&gt;&quot;dead&quot;&lt;/code&gt; if the coroutine has finished its body function, or if it has stopped with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6643f34f054d2169fc15059330c9797cabe4b0f8" translate="yes" xml:space="preserve">
          <source>Returns the status of the thread &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">Devuelve el estado de la rosca &lt;code&gt;L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce13df23b5d839e4a1b3c62a7a51b8e7083872ff" translate="yes" xml:space="preserve">
          <source>Returns the substring of &lt;code&gt;s&lt;/code&gt; that starts at &lt;code&gt;i&lt;/code&gt; and continues until &lt;code&gt;j&lt;/code&gt;; &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; can be negative. If &lt;code&gt;j&lt;/code&gt; is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call &lt;code&gt;string.sub(s,1,j)&lt;/code&gt; returns a prefix of &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;string.sub(s, -i)&lt;/code&gt; (for a positive &lt;code&gt;i&lt;/code&gt;) returns a suffix of &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Devuelve la subcadena de &lt;code&gt;s&lt;/code&gt; que comienza en &lt;code&gt;i&lt;/code&gt; y contin&amp;uacute;a hasta &lt;code&gt;j&lt;/code&gt; ; &lt;code&gt;i&lt;/code&gt; y &lt;code&gt;j&lt;/code&gt; pueden ser negativos. Si &lt;code&gt;j&lt;/code&gt; est&amp;aacute; ausente, se asume que es igual a -1 (que es lo mismo que la longitud de la cadena). En particular, la llamada &lt;code&gt;string.sub(s,1,j)&lt;/code&gt; devuelve un prefijo de &lt;code&gt;s&lt;/code&gt; con longitud &lt;code&gt;j&lt;/code&gt; , y &lt;code&gt;string.sub(s, -i)&lt;/code&gt; (para una &lt;code&gt;i&lt;/code&gt; positiva ) devuelve un sufijo de &lt;code&gt;s&lt;/code&gt; con longitud &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d879230a982638cb3037d087aec816766d1bff4" translate="yes" xml:space="preserve">
          <source>Returns the tangent of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">Devuelve la tangente de &lt;code&gt;x&lt;/code&gt; (se supone que est&amp;aacute; en radianes).</target>
        </trans-unit>
        <trans-unit id="aeb49cdc670f656ecf94cc356e8482541619f67b" translate="yes" xml:space="preserve">
          <source>Returns the type of its only argument, coded as a string. The possible results of this function are &quot;&lt;code&gt;nil&lt;/code&gt;&quot; (a string, not the value &lt;b&gt;nil&lt;/b&gt;), &quot;&lt;code&gt;number&lt;/code&gt;&quot;, &quot;&lt;code&gt;string&lt;/code&gt;&quot;, &quot;&lt;code&gt;boolean&lt;/code&gt;&quot;, &quot;&lt;code&gt;table&lt;/code&gt;&quot;, &quot;&lt;code&gt;function&lt;/code&gt;&quot;, &quot;&lt;code&gt;thread&lt;/code&gt;&quot;, and &quot;&lt;code&gt;userdata&lt;/code&gt;&quot;.</source>
          <target state="translated">Devuelve el tipo de su &amp;uacute;nico argumento, codificado como una cadena. Los posibles resultados de esta funci&amp;oacute;n son &quot; &lt;code&gt;nil&lt;/code&gt; &quot; (una cadena, no el valor &lt;b&gt;nil&lt;/b&gt; ), &quot; &lt;code&gt;number&lt;/code&gt; &quot;, &quot; &lt;code&gt;string&lt;/code&gt; &quot;, &quot; &lt;code&gt;boolean&lt;/code&gt; o &quot;, &quot; &lt;code&gt;table&lt;/code&gt; &quot;, &quot; &lt;code&gt;function&lt;/code&gt; &quot;, &quot; &lt;code&gt;thread&lt;/code&gt; &quot; y &quot;datos de &lt;code&gt;userdata&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="b7cc3af32266285b487ea68c1fc6ffc164e146f6" translate="yes" xml:space="preserve">
          <source>Returns the type of the pushed value.</source>
          <target state="translated">Devuelve el tipo de valor empujado.</target>
        </trans-unit>
        <trans-unit id="11efeaa1a0a1dad64efc60561b86e6d305ce3e58" translate="yes" xml:space="preserve">
          <source>Returns the type of the value in the given valid index, or &lt;code&gt;LUA_TNONE&lt;/code&gt; for a non-valid (but acceptable) index. The types returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt; are coded by the following constants defined in &lt;code&gt;lua.h&lt;/code&gt;: &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt;&lt;code&gt;LUA_TNIL&lt;/code&gt;&lt;/a&gt; (0), &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt;&lt;code&gt;LUA_TNUMBER&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt;&lt;code&gt;LUA_TBOOLEAN&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt;&lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Devuelve el tipo de valor en el &amp;iacute;ndice v&amp;aacute;lido dado, o &lt;code&gt;LUA_TNONE&lt;/code&gt; para un &amp;iacute;ndice no v&amp;aacute;lido (pero aceptable). Los tipos devueltos por &lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; &lt;/a&gt; est&amp;aacute;n codificados por las siguientes constantes definidas en &lt;code&gt;lua.h&lt;/code&gt; : &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt; &lt;code&gt;LUA_TNIL&lt;/code&gt; &lt;/a&gt; (0), &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt; &lt;code&gt;LUA_TNUMBER&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt; &lt;code&gt;LUA_TBOOLEAN&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt; &lt;code&gt;LUA_TSTRING&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt; &lt;code&gt;LUA_TTABLE&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt; &lt;code&gt;LUA_TFUNCTION&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt; &lt;code&gt;LUA_TUSERDATA&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt; &lt;code&gt;LUA_TTHREAD&lt;/code&gt; &lt;/a&gt; y &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt; &lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="386a1f58fe55c34012815a8391ceb7917714f28e" translate="yes" xml:space="preserve">
          <source>Returns the type of the value in the given valid index, or &lt;code&gt;LUA_TNONE&lt;/code&gt; for a non-valid but acceptable index. The types returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt; are coded by the following constants defined in &lt;code&gt;lua.h&lt;/code&gt;: &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt;&lt;code&gt;LUA_TNIL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt;&lt;code&gt;LUA_TNUMBER&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt;&lt;code&gt;LUA_TBOOLEAN&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt;&lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c355c772b6a7cd3959fe3ff1b22ce6913ee6b493" translate="yes" xml:space="preserve">
          <source>Returns the value &lt;em&gt;e&lt;sup&gt;x&lt;/sup&gt;&lt;/em&gt; (where &lt;code&gt;e&lt;/code&gt; is the base of natural logarithms).</source>
          <target state="translated">Devuelve el valor &lt;em&gt;e &lt;sup&gt;x&lt;/sup&gt;&lt;/em&gt; (donde &lt;code&gt;e&lt;/code&gt; es la base de los logaritmos naturales).</target>
        </trans-unit>
        <trans-unit id="0fb28ceb3afa0ab32151ee21709c9aa0178b4cd0" translate="yes" xml:space="preserve">
          <source>Returns the value of the process environment variable &lt;code&gt;varname&lt;/code&gt; or &lt;b&gt;fail&lt;/b&gt; if the variable is not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f640b6a2396fe00ff3c46e513b55ada5898623" translate="yes" xml:space="preserve">
          <source>Returns the value of the process environment variable &lt;code&gt;varname&lt;/code&gt;, or &lt;b&gt;nil&lt;/b&gt; if the variable is not defined.</source>
          <target state="translated">Devuelve el valor de la variable de entorno del proceso &lt;code&gt;varname&lt;/code&gt; , o &lt;b&gt;nil&lt;/b&gt; si la variable no est&amp;aacute; definida.</target>
        </trans-unit>
        <trans-unit id="f3b86e22b7e07287e106fe5463ecf2e5e16d5d52" translate="yes" xml:space="preserve">
          <source>Returns the values packed in string &lt;code&gt;s&lt;/code&gt; (see &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;). An optional &lt;code&gt;pos&lt;/code&gt; marks where to start reading in &lt;code&gt;s&lt;/code&gt; (default is 1). After the read values, this function also returns the index of the first unread byte in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Devuelve los valores empaquetados en la cadena &lt;code&gt;s&lt;/code&gt; (ver &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; ) de acuerdo con el formato string &lt;code&gt;fmt&lt;/code&gt; (ver &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt; ). Un opcional de &lt;code&gt;pos&lt;/code&gt; marcas d&amp;oacute;nde comenzar a leer en &lt;code&gt;s&lt;/code&gt; (por defecto es 1). Despu&amp;eacute;s de los valores le&amp;iacute;dos, esta funci&amp;oacute;n tambi&amp;eacute;n devuelve el &amp;iacute;ndice del primer byte no le&amp;iacute;do en &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9da6ffc3c7ea901268412d4b32b6956c0cf722ea" translate="yes" xml:space="preserve">
          <source>Returns the version number of this core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc3adbac55a1cae7b7dbc056f59867a7e653730" translate="yes" xml:space="preserve">
          <source>Returns three values (an iterator function, the table &lt;code&gt;t&lt;/code&gt;, and 0) so that the construction</source>
          <target state="translated">Devuelve tres valores (una funci&amp;oacute;n de iterador, la tabla &lt;code&gt;t&lt;/code&gt; y 0) para que la construcci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="fd4f281c2403b2b4ec6dfa198827f4141e53f9ac" translate="yes" xml:space="preserve">
          <source>Returns true when the coroutine &lt;code&gt;co&lt;/code&gt; can yield. The default for &lt;code&gt;co&lt;/code&gt; is the running coroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db585fd6f4edc4d15ef6261e32bad83a4e3fc94" translate="yes" xml:space="preserve">
          <source>Returns true when the running coroutine can yield.</source>
          <target state="translated">Vuelve a la realidad cuando la rutina de la carrera puede ceder.</target>
        </trans-unit>
        <trans-unit id="86872d97a4648c727afb8bd8743402fb113d9d79" translate="yes" xml:space="preserve">
          <source>Returns values so that the construction</source>
          <target state="translated">Devuelve valores para que la construcción</target>
        </trans-unit>
        <trans-unit id="c0dd5c1f0b221305574b2b927c5b76675e55a510" translate="yes" xml:space="preserve">
          <source>Rotates the stack elements between the valid index &lt;code&gt;idx&lt;/code&gt; and the top of the stack. The elements are rotated &lt;code&gt;n&lt;/code&gt; positions in the direction of the top, for a positive &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; positions in the direction of the bottom, for a negative &lt;code&gt;n&lt;/code&gt;. The absolute value of &lt;code&gt;n&lt;/code&gt; must not be greater than the size of the slice being rotated. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">Rota los elementos de la pila entre el &lt;code&gt;idx&lt;/code&gt; de &amp;iacute;ndice v&amp;aacute;lido y la parte superior de la pila. Los elementos se rotan &lt;code&gt;n&lt;/code&gt; posiciones en la direcci&amp;oacute;n de la parte superior, para una &lt;code&gt;n&lt;/code&gt; positiva , o &lt;code&gt;-n&lt;/code&gt; posiciones en la direcci&amp;oacute;n de la parte inferior, para una &lt;code&gt;n&lt;/code&gt; negativa . El valor absoluto de &lt;code&gt;n&lt;/code&gt; no debe ser mayor que el tama&amp;ntilde;o del corte que se est&amp;aacute; rotando. Esta funci&amp;oacute;n no se puede llamar con un pseudo-&amp;iacute;ndice, porque un pseudo-&amp;iacute;ndice no es una posici&amp;oacute;n de pila real.</target>
        </trans-unit>
        <trans-unit id="cb167298f69784fe48c5d2a384e7c877c8d9492d" translate="yes" xml:space="preserve">
          <source>Saves any written data to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">Guarda cualquier dato escrito en un &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="920400471986593c15fc84e450728648c16819e7" translate="yes" xml:space="preserve">
          <source>Searchers should raise no errors and have no side effects in Lua. (They may have side effects in C, for instance by linking the application with a library.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3440752ad05f6155ff5680caecbafde2dc649d9b" translate="yes" xml:space="preserve">
          <source>Searches for the given &lt;code&gt;name&lt;/code&gt; in the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">Busca el &lt;code&gt;name&lt;/code&gt; de pila en la &lt;code&gt;path&lt;/code&gt; indicada .</target>
        </trans-unit>
        <trans-unit id="94692e4b88a2528c0b5e86368b0213b54dbd9884" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; for more details about garbage collection and some of these options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a18ffdb89ed379138be3152d18086f1d55d2a3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt;&lt;code&gt;debug.getlocal&lt;/code&gt;&lt;/a&gt; for more information about variable indices and names.</source>
          <target state="translated">Consulte &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt; &lt;code&gt;debug.getlocal&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre &amp;iacute;ndices y nombres de variables.</target>
        </trans-unit>
        <trans-unit id="c68ceaa8d812b1b10a7eea6ccb5e07ce5de30a37" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pdf-debug.getupvalue&quot;&gt;&lt;code&gt;debug.getupvalue&lt;/code&gt;&lt;/a&gt; for more information about upvalues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8806221244780430f4dab1be1efe9e1deb956088" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pdf-warn&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt; for more details about warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3360426ce5422bc56d751e0aa6008fce46fc70e" translate="yes" xml:space="preserve">
          <source>See function &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; for the caveats of modifying the table during its traversal.</source>
          <target state="translated">Consulte la funci&amp;oacute;n &lt;a href=&quot;#pdf-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; para conocer las advertencias de modificar la tabla durante su recorrido.</target>
        </trans-unit>
        <trans-unit id="19f37898f520273219e289bdee9a8581baa73269" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;x&lt;/code&gt; as the &quot;seed&quot; for the pseudo-random generator: equal seeds produce equal sequences of numbers.</source>
          <target state="translated">Establece &lt;code&gt;x&lt;/code&gt; como la &quot;semilla&quot; para el generador pseudoaleatorio: las semillas iguales producen secuencias iguales de n&amp;uacute;meros.</target>
        </trans-unit>
        <trans-unit id="0d4c31b081bb4e342a5c7b04bb15e6651ad21d58" translate="yes" xml:space="preserve">
          <source>Sets a new limit for the C stack. This limit controls how deeply nested calls can go in Lua, with the intent of avoiding a stack overflow. A limit too small restricts recursive calls pointlessly; a limit too large exposes the interpreter to stack-overflow crashes. Unfortunately, there is no way to know a priori the maximum safe limit for a platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7966d7ba898208a4bfff8332d8d2ce5eab98e952" translate="yes" xml:space="preserve">
          <source>Sets a new limit for the C stack. This limit controls how deeply nested calls can go in Lua, with the intent of avoiding a stack overflow. Returns the old limit in case of success, or zero in case of error. For more details about this function, see &lt;a href=&quot;#pdf-debug.setcstacklimit&quot;&gt;&lt;code&gt;debug.setcstacklimit&lt;/code&gt;&lt;/a&gt;, its equivalent in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffaec0474c3c12ab33648528a0c531a28325cf4" translate="yes" xml:space="preserve">
          <source>Sets a new panic function and returns the old one (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2903d5c5e2f6aac5cee42b812f29848f11b229" translate="yes" xml:space="preserve">
          <source>Sets a new panic function and returns the old one (see &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt;).</source>
          <target state="translated">Establece una nueva funci&amp;oacute;n de p&amp;aacute;nico y devuelve la anterior (ver &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="10482f8b5b12a1f1db635550932f8faad32fd81b" translate="yes" xml:space="preserve">
          <source>Sets and gets the file position, measured from the beginning of the file, to the position given by &lt;code&gt;offset&lt;/code&gt; plus a base specified by the string &lt;code&gt;whence&lt;/code&gt;, as follows:</source>
          <target state="translated">Establece y obtiene la posici&amp;oacute;n del archivo, medida desde el principio del archivo, hasta la posici&amp;oacute;n dada por el &lt;code&gt;offset&lt;/code&gt; m&amp;aacute;s una base especificada por la cadena de &lt;code&gt;whence&lt;/code&gt; , como sigue:</target>
        </trans-unit>
        <trans-unit id="c75eca40914b6c7ff395b6a435b1b2509e75386b" translate="yes" xml:space="preserve">
          <source>Sets the C function &lt;code&gt;f&lt;/code&gt; as the new value of global &lt;code&gt;name&lt;/code&gt;. It is defined as a macro:</source>
          <target state="translated">Establece la funci&amp;oacute;n C &lt;code&gt;f&lt;/code&gt; como el nuevo valor del &lt;code&gt;name&lt;/code&gt; global . Se define como una macro:</target>
        </trans-unit>
        <trans-unit id="081317fb6ecee7ae4baa46c02f924ee275f76a03" translate="yes" xml:space="preserve">
          <source>Sets the buffering mode for a file. There are three available modes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de2f1f4dd9362493d0d4861f3dfe60cc83af4578" translate="yes" xml:space="preserve">
          <source>Sets the buffering mode for an output file. There are three available modes:</source>
          <target state="translated">Establece el modo de búfer para un archivo de salida.Hay tres modos disponibles:</target>
        </trans-unit>
        <trans-unit id="47362e1529f7af535b225ac5e5e41ff2aab64e46" translate="yes" xml:space="preserve">
          <source>Sets the current locale of the program. &lt;code&gt;locale&lt;/code&gt; is a system-dependent string specifying a locale; &lt;code&gt;category&lt;/code&gt; is an optional string describing which category to change: &lt;code&gt;&quot;all&quot;&lt;/code&gt;, &lt;code&gt;&quot;collate&quot;&lt;/code&gt;, &lt;code&gt;&quot;ctype&quot;&lt;/code&gt;, &lt;code&gt;&quot;monetary&quot;&lt;/code&gt;, &lt;code&gt;&quot;numeric&quot;&lt;/code&gt;, or &lt;code&gt;&quot;time&quot;&lt;/code&gt;; the default category is &lt;code&gt;&quot;all&quot;&lt;/code&gt;. The function returns the name of the new locale, or &lt;b&gt;fail&lt;/b&gt; if the request cannot be honored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772769933fe32ebc8452718b212f21e2ae3b3d0a" translate="yes" xml:space="preserve">
          <source>Sets the current locale of the program. &lt;code&gt;locale&lt;/code&gt; is a system-dependent string specifying a locale; &lt;code&gt;category&lt;/code&gt; is an optional string describing which category to change: &lt;code&gt;&quot;all&quot;&lt;/code&gt;, &lt;code&gt;&quot;collate&quot;&lt;/code&gt;, &lt;code&gt;&quot;ctype&quot;&lt;/code&gt;, &lt;code&gt;&quot;monetary&quot;&lt;/code&gt;, &lt;code&gt;&quot;numeric&quot;&lt;/code&gt;, or &lt;code&gt;&quot;time&quot;&lt;/code&gt;; the default category is &lt;code&gt;&quot;all&quot;&lt;/code&gt;. The function returns the name of the new locale, or &lt;b&gt;nil&lt;/b&gt; if the request cannot be honored.</source>
          <target state="translated">Establece la configuraci&amp;oacute;n regional actual del programa. &lt;code&gt;locale&lt;/code&gt; es una cadena dependiente del sistema que especifica una locale; &lt;code&gt;category&lt;/code&gt; es una cadena opcional que describe qu&amp;eacute; categor&amp;iacute;a cambiar: &lt;code&gt;&quot;all&quot;&lt;/code&gt; , &lt;code&gt;&quot;collate&quot;&lt;/code&gt; , &lt;code&gt;&quot;ctype&quot;&lt;/code&gt; , &lt;code&gt;&quot;monetary&quot;&lt;/code&gt; , &lt;code&gt;&quot;numeric&quot;&lt;/code&gt; o &lt;code&gt;&quot;time&quot;&lt;/code&gt; ; la categor&amp;iacute;a predeterminada es &lt;code&gt;&quot;all&quot;&lt;/code&gt; . La funci&amp;oacute;n devuelve el nombre de la nueva configuraci&amp;oacute;n regional o &lt;b&gt;nil&lt;/b&gt; si la solicitud no se puede cumplir.</target>
        </trans-unit>
        <trans-unit id="577d8bdc520c0556720156fb048d7cc9591b0b65" translate="yes" xml:space="preserve">
          <source>Sets the debugging hook function.</source>
          <target state="translated">Establece la función del gancho de depuración.</target>
        </trans-unit>
        <trans-unit id="0e50f7de74529ef0127c0979e57072500795bcf0" translate="yes" xml:space="preserve">
          <source>Sets the given &lt;code&gt;value&lt;/code&gt; as the &lt;code&gt;n&lt;/code&gt;-th user value associated to the given &lt;code&gt;udata&lt;/code&gt;. &lt;code&gt;udata&lt;/code&gt; must be a full userdata.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="292ec4e82927af4194013aa2f75932b01e97689c" translate="yes" xml:space="preserve">
          <source>Sets the given &lt;code&gt;value&lt;/code&gt; as the Lua value associated to the given &lt;code&gt;udata&lt;/code&gt;. &lt;code&gt;udata&lt;/code&gt; must be a full userdata.</source>
          <target state="translated">Establece el &lt;code&gt;value&lt;/code&gt; dado como el valor Lua asociado al &lt;code&gt;udata&lt;/code&gt; dado . &lt;code&gt;udata&lt;/code&gt; debe ser un userdata completo.</target>
        </trans-unit>
        <trans-unit id="0f680b53b706554348285320cb60fd7dd4bf3ce4" translate="yes" xml:space="preserve">
          <source>Sets the given function as a hook. The string &lt;code&gt;mask&lt;/code&gt; and the number &lt;code&gt;count&lt;/code&gt; describe when the hook will be called. The string mask may have any combination of the following characters, with the given meaning:</source>
          <target state="translated">Establece la funci&amp;oacute;n dada como un gancho. La &lt;code&gt;mask&lt;/code&gt; cadena y el &lt;code&gt;count&lt;/code&gt; n&amp;uacute;meros describen cu&amp;aacute;ndo se llamar&amp;aacute; al gancho. La m&amp;aacute;scara de cadena puede tener cualquier combinaci&amp;oacute;n de los siguientes caracteres, con el significado dado:</target>
        </trans-unit>
        <trans-unit id="cfa457abdfe638a1c05389781b6cb767699e3f5e" translate="yes" xml:space="preserve">
          <source>Sets the given function as the debug hook. The string &lt;code&gt;mask&lt;/code&gt; and the number &lt;code&gt;count&lt;/code&gt; describe when the hook will be called. The string mask may have any combination of the following characters, with the given meaning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b8a030605b64f54e56dc4eb6882692a1e86465" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given &lt;code&gt;value&lt;/code&gt; to the given &lt;code&gt;table&lt;/code&gt; (which can be &lt;b&gt;nil&lt;/b&gt;). Returns &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Establece la metatabla para el &lt;code&gt;value&lt;/code&gt; dado en la &lt;code&gt;table&lt;/code&gt; dada (que puede ser &lt;b&gt;nula&lt;/b&gt; ). Devuelve &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc55fa8aad2a6ef152d3844b1dbc7d9854df5817" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given table. (To change the metatable of other types from Lua code, you must use the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).) If &lt;code&gt;metatable&lt;/code&gt; is &lt;b&gt;nil&lt;/b&gt;, removes the metatable of the given table. If the original metatable has a &lt;code&gt;__metatable&lt;/code&gt; field, raises an error.</source>
          <target state="translated">Establece la metatabla para la tabla dada. (Para cambiar la metatabla de otros tipos del c&amp;oacute;digo Lua, debe usar la biblioteca de depuraci&amp;oacute;n ( &lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt; )). Si la &lt;code&gt;metatable&lt;/code&gt; es &lt;b&gt;nula&lt;/b&gt; , elimina la metatabla de la tabla dada. Si la metatabla original tiene un campo &lt;code&gt;__metatable&lt;/code&gt; , genera un error.</target>
        </trans-unit>
        <trans-unit id="a0ebfc6ec4adb4b51d14e3fb506f43ec69d2311e" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given table. If &lt;code&gt;metatable&lt;/code&gt; is &lt;b&gt;nil&lt;/b&gt;, removes the metatable of the given table. If the original metatable has a &lt;code&gt;__metatable&lt;/code&gt; field, raises an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587b6bacfd61f3dd529496795bf4b5531bf0411f" translate="yes" xml:space="preserve">
          <source>Sets the metatable of the object at the top of the stack as the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Establece la metatabla del objeto en la parte superior de la pila como la metatabla asociada con el nombre &lt;code&gt;tname&lt;/code&gt; en el registro (ver &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d22790332cf1d45f6a8843c4ad039244e90ff99f" translate="yes" xml:space="preserve">
          <source>Sets the metatable of the object on the top of the stack as the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="980d28e7c69235ce8818955ee39047b99459cc45" translate="yes" xml:space="preserve">
          <source>Sets the real value of &lt;code&gt;table[index]&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, without invoking the &lt;code&gt;__newindex&lt;/code&gt; metamethod. &lt;code&gt;table&lt;/code&gt; must be a table, &lt;code&gt;index&lt;/code&gt; any value different from &lt;b&gt;nil&lt;/b&gt; and NaN, and &lt;code&gt;value&lt;/code&gt; any Lua value.</source>
          <target state="translated">Establece el valor real de la &lt;code&gt;table[index]&lt;/code&gt; en &lt;code&gt;value&lt;/code&gt; , sin invocar el &lt;code&gt;__newindex&lt;/code&gt; __newindex. &lt;code&gt;table&lt;/code&gt; debe ser una tabla, &lt;code&gt;index&lt;/code&gt; ar cualquier valor diferente de &lt;b&gt;nil&lt;/b&gt; y NaN, y &lt;code&gt;value&lt;/code&gt; cualquier valor Lua.</target>
        </trans-unit>
        <trans-unit id="83fb6edb67ceac4c3bec94b60202ea6ff8ecd172" translate="yes" xml:space="preserve">
          <source>Sets the real value of &lt;code&gt;table[index]&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, without using the &lt;code&gt;__newindex&lt;/code&gt; metavalue. &lt;code&gt;table&lt;/code&gt; must be a table, &lt;code&gt;index&lt;/code&gt; any value different from &lt;b&gt;nil&lt;/b&gt; and NaN, and &lt;code&gt;value&lt;/code&gt; any Lua value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64764244caf680f963cbe34576ef7f19047e51d8" translate="yes" xml:space="preserve">
          <source>Sets the value of a closure's upvalue. It assigns the value at the top of the stack to the upvalue and returns its name. It also pops the value from the stack.</source>
          <target state="translated">Establece el valor de un cierre.Asigna el valor en la parte superior de la pila al valor de subida y devuelve su nombre.También saca el valor de la pila.</target>
        </trans-unit>
        <trans-unit id="a4f7f3cdc50e6225c7b313befabe93f7ca2bf356" translate="yes" xml:space="preserve">
          <source>Sets the value of a closure's upvalue. It assigns the value on the top of the stack to the upvalue and returns its name. It also pops the value from the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffba6d217c9340ff452d0b26d7bde601a75effed" translate="yes" xml:space="preserve">
          <source>Sets the value of a local variable of a given activation record. It assigns the value at the top of the stack to the variable and returns its name. It also pops the value from the stack.</source>
          <target state="translated">Establece el valor de una variable local de un registro de activación determinado.Asigna el valor en la parte superior de la pila a la variable y devuelve su nombre.También saca el valor de la pila.</target>
        </trans-unit>
        <trans-unit id="7f22679a70311edfc5f50384a42d2ab7fff23fa6" translate="yes" xml:space="preserve">
          <source>Sets the value of a local variable of a given activation record. It assigns the value on the top of the stack to the variable and returns its name. It also pops the value from the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03940c1d1ac3a2bf1547c98b0cbe03f39d14377" translate="yes" xml:space="preserve">
          <source>Sets the warning function to be used by Lua to emit warnings (see &lt;a href=&quot;#lua_WarnFunction&quot;&gt;&lt;code&gt;lua_WarnFunction&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;ud&lt;/code&gt; parameter sets the value &lt;code&gt;ud&lt;/code&gt; passed to the warning function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e346a8f5ef11e0659f9d13d2fd20c5971760ec54" translate="yes" xml:space="preserve">
          <source>Several functions in the API return pointers (&lt;code&gt;const char*&lt;/code&gt;) to Lua strings in the stack. (See &lt;a href=&quot;#lua_pushfstring&quot;&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pushlstring&quot;&gt;&lt;code&gt;lua_pushlstring&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pushstring&quot;&gt;&lt;code&gt;lua_pushstring&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#luaL_checklstring&quot;&gt;&lt;code&gt;luaL_checklstring&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_checkstring&quot;&gt;&lt;code&gt;luaL_checkstring&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#luaL_tolstring&quot;&gt;&lt;code&gt;luaL_tolstring&lt;/code&gt;&lt;/a&gt; in the auxiliary library.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13dfadc7fc1e60158ee478b1d01c15a1a262b8f8" translate="yes" xml:space="preserve">
          <source>Several functions in the auxiliary library are used to check C function arguments. Because the error message is formatted for arguments (e.g., &quot;&lt;code&gt;bad argument #1&lt;/code&gt;&quot;), you should not use these functions for other stack values.</source>
          <target state="translated">Varias funciones de la biblioteca auxiliar se utilizan para comprobar los argumentos de la funci&amp;oacute;n C. Debido a que el mensaje de error est&amp;aacute; formateado para argumentos (por ejemplo, &quot; &lt;code&gt;bad argument #1&lt;/code&gt; &quot;), no debe usar estas funciones para otros valores de pila.</target>
        </trans-unit>
        <trans-unit id="d7d26a3bd3ccc1bc11907697040007c09639a73d" translate="yes" xml:space="preserve">
          <source>Several functions in the auxiliary library use internally some extra stack slots. When a function in the auxiliary library uses less than five slots, it does not check the stack size; it simply assumes that there are enough slots.</source>
          <target state="translated">Varias funciones de la biblioteca auxiliar utilizan internamente algunas ranuras de pila adicionales.Cuando una función de la biblioteca auxiliar utiliza menos de cinco ranuras,no comprueba el tamaño de la pila;simplemente supone que hay suficientes ranuras.</target>
        </trans-unit>
        <trans-unit id="1a5b014735ed16f1ba36e3785a0f441d0242e3d9" translate="yes" xml:space="preserve">
          <source>Several functions that report errors in the API use the following status codes to indicate different kinds of errors or other conditions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d00af90d2bbbb33d085cc5ef987064ed22d642" translate="yes" xml:space="preserve">
          <source>Several operations in Lua can &lt;em&gt;raise&lt;/em&gt; an error. An error interrupts the normal flow of the program, which can continue by &lt;em&gt;catching&lt;/em&gt; the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db95dfa9c967586d03ebee139b1fb3b17b47718b" translate="yes" xml:space="preserve">
          <source>Several places in Lua coerce strings to numbers when necessary. In particular, the string library sets metamethods that try to coerce strings to numbers in all arithmetic operations. If the conversion fails, the library calls the metamethod of the other operand (if present) or it raises an error. Note that bitwise operators do not do this coercion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6f5999f6739678269276a1253783f2e33caacc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#lua_gettable&quot;&gt;&lt;code&gt;lua_gettable&lt;/code&gt;&lt;/a&gt;, but does a raw access (i.e., without metamethods).</source>
          <target state="translated">Similar a &lt;a href=&quot;#lua_gettable&quot;&gt; &lt;code&gt;lua_gettable&lt;/code&gt; &lt;/a&gt; , pero tiene un acceso sin formato (es decir, sin metam&amp;eacute;todos).</target>
        </trans-unit>
        <trans-unit id="98d6dc9d6d25a6a5bcf82cd4cb364da6adb19bc6" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#lua_settable&quot;&gt;&lt;code&gt;lua_settable&lt;/code&gt;&lt;/a&gt;, but does a raw assignment (i.e., without metamethods).</source>
          <target state="translated">Similar a &lt;a href=&quot;#lua_settable&quot;&gt; &lt;code&gt;lua_settable&lt;/code&gt; &lt;/a&gt; , pero hace una asignaci&amp;oacute;n sin formato (es decir, sin metam&amp;eacute;todos).</target>
        </trans-unit>
        <trans-unit id="bb8fabad1f82bd899f79eae459334cf7e778fcba" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#pdf-io.input&quot;&gt;&lt;code&gt;io.input&lt;/code&gt;&lt;/a&gt;, but operates over the default output file.</source>
          <target state="translated">Similar a &lt;a href=&quot;#pdf-io.input&quot;&gt; &lt;code&gt;io.input&lt;/code&gt; &lt;/a&gt; , pero opera sobre el archivo de salida predeterminado.</target>
        </trans-unit>
        <trans-unit id="be9918f302436d602e28315cc5eff3fc1e73bb44" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;, but gets the chunk from file &lt;code&gt;filename&lt;/code&gt; or from the standard input, if no file name is given.</source>
          <target state="translated">Similar a &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; , pero obtiene el fragmento del &lt;code&gt;filename&lt;/code&gt; del archivo o de la entrada est&amp;aacute;ndar, si no se proporciona un nombre de archivo.</target>
        </trans-unit>
        <trans-unit id="26f694e9b1074e2724d2aeb68c0547978de3e666" translate="yes" xml:space="preserve">
          <source>Similarly, Lua versions can always change the internal representation of precompiled chunks; precompiled chunks are not compatible between different Lua versions.</source>
          <target state="translated">Del mismo modo,las versiones de Lua siempre pueden cambiar la representación interna de los trozos precompilados;los trozos precompilados no son compatibles entre las diferentes versiones de Lua.</target>
        </trans-unit>
        <trans-unit id="fbd85d6dbfcd7a9c4f67b15fec97031a2abeaf4f" translate="yes" xml:space="preserve">
          <source>Some functions in the debug interface also return pointers to strings, namely &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_setlocal&quot;&gt;&lt;code&gt;lua_setlocal&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_setupvalue&quot;&gt;&lt;code&gt;lua_setupvalue&lt;/code&gt;&lt;/a&gt;. For these functions, the pointer is guaranteed to be valid while the caller function is active and the given closure (if one was given) is in the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91f7e308fa2ec755f5b9629aa68bea063366955f" translate="yes" xml:space="preserve">
          <source>Sorts list elements in a given order, &lt;em&gt;in-place&lt;/em&gt;, from &lt;code&gt;list[1]&lt;/code&gt; to &lt;code&gt;list[#list]&lt;/code&gt;. If &lt;code&gt;comp&lt;/code&gt; is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order (so that, after the sort, &lt;code&gt;i &amp;lt; j&lt;/code&gt; implies &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt;). If &lt;code&gt;comp&lt;/code&gt; is not given, then the standard Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt; is used instead.</source>
          <target state="translated">Ordena los elementos de la lista en un orden determinado, &lt;em&gt;en el lugar&lt;/em&gt; , de la &lt;code&gt;list[1]&lt;/code&gt; a la &lt;code&gt;list[#list]&lt;/code&gt; . Si se da &lt;code&gt;comp&lt;/code&gt; , entonces debe ser una funci&amp;oacute;n que reciba dos elementos de la lista y devuelva verdadero cuando el primer elemento debe ir antes que el segundo en el orden final (de modo que, despu&amp;eacute;s de la clasificaci&amp;oacute;n, &lt;code&gt;i &amp;lt; j&lt;/code&gt; implica &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt; ). Si no se proporciona &lt;code&gt;comp&lt;/code&gt; , entonces se usa el operador est&amp;aacute;ndar de Lua &lt;code&gt;&amp;lt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="c0517f4c6665e2b52991a1cccc3781c492c0e6b1" translate="yes" xml:space="preserve">
          <source>Sorts the list elements in a given order, &lt;em&gt;in-place&lt;/em&gt;, from &lt;code&gt;list[1]&lt;/code&gt; to &lt;code&gt;list[#list]&lt;/code&gt;. If &lt;code&gt;comp&lt;/code&gt; is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order (so that, after the sort, &lt;code&gt;i &amp;lt; j&lt;/code&gt; implies &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt;). If &lt;code&gt;comp&lt;/code&gt; is not given, then the standard Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt; is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a010f7f7cdbd4258d79a8a94cbe56bc77bf2b5e7" translate="yes" xml:space="preserve">
          <source>Square brackets are used to index a table:</source>
          <target state="translated">Los corchetes se usan para indexar una tabla:</target>
        </trans-unit>
        <trans-unit id="15f3db96858a0b179ed1ef035b7c3729debc1d46" translate="yes" xml:space="preserve">
          <source>Stack Size</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8857dbe9de4909ed5c2183cf91102dab19f054b" translate="yes" xml:space="preserve">
          <source>Standard Libraries</source>
          <target state="translated">Bibliotecas estándar</target>
        </trans-unit>
        <trans-unit id="3aa420e36a031586ffcaad7595673c265cb89fc8" translate="yes" xml:space="preserve">
          <source>Starts and resumes a coroutine in the given thread &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">Inicia y reanuda un co-rutina en el hilo dado &lt;code&gt;L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d40756a05671d2e92d48621babd1cb1ebcde9165" translate="yes" xml:space="preserve">
          <source>Starts or continues the execution of coroutine &lt;code&gt;co&lt;/code&gt;. The first time you resume a coroutine, it starts running its body. The values &lt;code&gt;val1&lt;/code&gt;, ... are passed as the arguments to the body function. If the coroutine has yielded, &lt;code&gt;resume&lt;/code&gt; restarts it; the values &lt;code&gt;val1&lt;/code&gt;, ... are passed as the results from the yield.</source>
          <target state="translated">Inicia o contin&amp;uacute;a la ejecuci&amp;oacute;n de coroutine &lt;code&gt;co&lt;/code&gt; . La primera vez que reanuda una corrutina, comienza a ejecutar su cuerpo. Los valores &lt;code&gt;val1&lt;/code&gt; , ... se pasan como argumentos a la funci&amp;oacute;n body. Si la corrutina ha cedido, &lt;code&gt;resume&lt;/code&gt; la reinicia; los valores &lt;code&gt;val1&lt;/code&gt; , ... se pasan como resultados del rendimiento.</target>
        </trans-unit>
        <trans-unit id="fdcf228dfc0fc5649ba85944b97fefcca7ffe43a" translate="yes" xml:space="preserve">
          <source>Starts program &lt;code&gt;prog&lt;/code&gt; in a separated process and returns a file handle that you can use to read data from this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;r&quot;&lt;/code&gt;, the default) or to write data to this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;w&quot;&lt;/code&gt;).</source>
          <target state="translated">Inicia el programa &lt;code&gt;prog&lt;/code&gt; en un proceso separado y devuelve un identificador de archivo que puede usar para leer datos de este programa (si el &lt;code&gt;mode&lt;/code&gt; es &lt;code&gt;&quot;r&quot;&lt;/code&gt; , el valor predeterminado) o para escribir datos en este programa (si el &lt;code&gt;mode&lt;/code&gt; es &lt;code&gt;&quot;w&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fe31e15bdd22d691294377c44baf7ad2201f9aed" translate="yes" xml:space="preserve">
          <source>Starts the program &lt;code&gt;prog&lt;/code&gt; in a separated process and returns a file handle that you can use to read data from this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;r&quot;&lt;/code&gt;, the default) or to write data to this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;w&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="7f5583f5096a76c834c0bcc4f4885ffca8fe34cd" translate="yes" xml:space="preserve">
          <source>Status Codes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3601848fbaa157ee7ad1bf17ef71628017fcdf" translate="yes" xml:space="preserve">
          <source>Suppose the running thread yields while executing the callee function. After the thread resumes, it eventually will finish running the callee function. However, the callee function cannot return to the original function, because its frame in the C stack was destroyed by the yield. Instead, Lua calls a &lt;em&gt;continuation function&lt;/em&gt;, which was given as an argument to the callee function. As the name implies, the continuation function should continue the task of the original function.</source>
          <target state="translated">Suponga que el hilo en ejecuci&amp;oacute;n cede mientras se ejecuta la funci&amp;oacute;n de llamada. Despu&amp;eacute;s de que el hilo se reanude, eventualmente terminar&amp;aacute; de ejecutar la funci&amp;oacute;n de llamada. Sin embargo, la funci&amp;oacute;n callee no puede volver a la funci&amp;oacute;n original, porque su marco en la pila C fue destruido por el rendimiento. En cambio, Lua llama a una &lt;em&gt;funci&amp;oacute;n de continuaci&amp;oacute;n&lt;/em&gt; , que se proporcion&amp;oacute; como argumento a la funci&amp;oacute;n de llamada. Como su nombre lo indica, la funci&amp;oacute;n de continuaci&amp;oacute;n debe continuar la tarea de la funci&amp;oacute;n original.</target>
        </trans-unit>
        <trans-unit id="e83b7d557c46acb05b744857e11a6cfdb7f1df00" translate="yes" xml:space="preserve">
          <source>Suspends the execution of the calling coroutine. Any arguments to &lt;code&gt;yield&lt;/code&gt; are passed as extra results to &lt;code&gt;resume&lt;/code&gt;.</source>
          <target state="translated">Suspende la ejecuci&amp;oacute;n de la corrutina de llamada. Cualquier argumento que se &lt;code&gt;yield&lt;/code&gt; se pasa como resultados adicionales para &lt;code&gt;resume&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf68697aa23858afae69b1650bbb5ac00b4caade" translate="yes" xml:space="preserve">
          <source>Table Constructors</source>
          <target state="translated">Constructores de mesas</target>
        </trans-unit>
        <trans-unit id="ddade22015227084f0c0a4b0fb958ac23eef35ed" translate="yes" xml:space="preserve">
          <source>Table constructors are expressions that create tables. Every time a constructor is evaluated, a new table is created. A constructor can be used to create an empty table or to create a table and initialize some of its fields. The general syntax for constructors is</source>
          <target state="translated">Los constructores de tablas son expresiones que crean tablas.Cada vez que se evalúa un constructor,se crea una nueva tabla.Un constructor puede ser usado para crear una tabla vacía o para crear una tabla e inicializar algunos de sus campos.La sintaxis general de los constructores es</target>
        </trans-unit>
        <trans-unit id="8eb8356b5217b3ad22882eb75be685d15131abcf" translate="yes" xml:space="preserve">
          <source>Tables and full userdata have individual metatables (although multiple tables and userdata can share their metatables). Values of all other types share one single metatable per type; that is, there is one single metatable for all numbers, one for all strings, etc. By default, a value has no metatable, but the string library sets a metatable for the string type (see &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt;).</source>
          <target state="translated">Las tablas y los datos de usuario completos tienen metatablas individuales (aunque varias tablas y datos de usuario pueden compartir sus metatablas). Los valores de todos los dem&amp;aacute;s tipos comparten una &amp;uacute;nica metatabla por tipo; es decir, hay una &amp;uacute;nica metatabla para todos los n&amp;uacute;meros, una para todas las cadenas, etc. Por defecto, un valor no tiene metatabla, pero la biblioteca de cadenas establece una metatabla para el tipo de cadena (ver &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a43eec2139292b4bea0916e6b1d5992b76b7800a" translate="yes" xml:space="preserve">
          <source>Tables and full userdata have individual metatables, although multiple tables and userdata can share their metatables. Values of all other types share one single metatable per type; that is, there is one single metatable for all numbers, one for all strings, etc. By default, a value has no metatable, but the string library sets a metatable for the string type (see &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790df16e07d28fbd0bc25fd6c6058d692af71b40" translate="yes" xml:space="preserve">
          <source>Tables are the sole data-structuring mechanism in Lua; they can be used to represent ordinary arrays, lists, symbol tables, sets, records, graphs, trees, etc. To represent records, Lua uses the field name as an index. The language supports this representation by providing &lt;code&gt;a.name&lt;/code&gt; as syntactic sugar for &lt;code&gt;a[&quot;name&quot;]&lt;/code&gt;. There are several convenient ways to create tables in Lua (see &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt;).</source>
          <target state="translated">Las tablas son el &amp;uacute;nico mecanismo de estructuraci&amp;oacute;n de datos en Lua; se pueden usar para representar matrices, listas, tablas de s&amp;iacute;mbolos, conjuntos, registros, gr&amp;aacute;ficos, &amp;aacute;rboles, etc. ordinarios. Para representar registros, Lua usa el nombre del campo como &amp;iacute;ndice. El lenguaje apoya esta representaci&amp;oacute;n proporcionando &lt;code&gt;a.name&lt;/code&gt; como az&amp;uacute;car sint&amp;aacute;ctico para &lt;code&gt;a[&quot;name&quot;]&lt;/code&gt; . Hay varias formas convenientes de crear tablas en Lua (consulte &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e421a06df75071a6abebc4fb3581855738824adb" translate="yes" xml:space="preserve">
          <source>Tables, functions, threads, and (full) userdata values are &lt;em&gt;objects&lt;/em&gt;: variables do not actually &lt;em&gt;contain&lt;/em&gt; these values, only &lt;em&gt;references&lt;/em&gt; to them. Assignment, parameter passing, and function returns always manipulate references to such values; these operations do not imply any kind of copy.</source>
          <target state="translated">Las tablas, funciones, subprocesos y valores de datos de usuario (completos) son &lt;em&gt;objetos&lt;/em&gt; : las variables en realidad no &lt;em&gt;contienen&lt;/em&gt; estos valores, solo &lt;em&gt;referencias&lt;/em&gt; a ellos. La asignaci&amp;oacute;n, el paso de par&amp;aacute;metros y los retornos de funci&amp;oacute;n siempre manipulan las referencias a dichos valores; estas operaciones no implican ning&amp;uacute;n tipo de copia.</target>
        </trans-unit>
        <trans-unit id="669e76ec887de715ba103acde30a3797fae1f331" translate="yes" xml:space="preserve">
          <source>Tables, userdata, and threads are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, a userdata, or a thread), this new object is different from any previously existing object. A function is always equal to itself. Functions with any detectable difference (different behavior, different definition) are always different. Functions created at different times but with no detectable differences may be classified as equal or not (depending on internal caching details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99385b30015343b5b8e00056e58a762956df3e7d" translate="yes" xml:space="preserve">
          <source>Tables, userdata, and threads are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, userdata, or thread), this new object is different from any previously existing object. Closures with the same reference are always equal. Closures with any detectable difference (different behavior, different definition) are always different.</source>
          <target state="translated">Las tablas,los datos de usuario y los hilos se comparan por referencia:dos objetos se consideran iguales sólo si son el mismo objeto.Cada vez que se crea un nuevo objeto (una tabla,datos de usuario o un hilo),este nuevo objeto es diferente de cualquier objeto previamente existente.Los cierres con la misma referencia son siempre iguales.Los cierres con cualquier diferencia detectable (diferente comportamiento,diferente definición)son siempre diferentes.</target>
        </trans-unit>
        <trans-unit id="446beb4016f56d03fb7aeada345cb1a7a86ea482" translate="yes" xml:space="preserve">
          <source>Terminates the last protected function called and returns &lt;code&gt;message&lt;/code&gt; as the error object. Function &lt;code&gt;error&lt;/code&gt; never returns.</source>
          <target state="translated">Termina la &amp;uacute;ltima funci&amp;oacute;n protegida llamada y devuelve el &lt;code&gt;message&lt;/code&gt; como objeto de error. El &lt;code&gt;error&lt;/code&gt; de funci&amp;oacute;n nunca regresa.</target>
        </trans-unit>
        <trans-unit id="aad621a873e57ea830369714dc4bd782c2449476" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; function returns one of the following constants (defined in &lt;code&gt;lua.h&lt;/code&gt;):</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; devuelve una de las siguientes constantes (definidas en &lt;code&gt;lua.h&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="c9f4dcc9b6adcf3724a0f1527ff15ababb77be1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; function returns one of the following status codes: &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_ERRRUN&quot;&gt;&lt;code&gt;LUA_ERRRUN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#pdf-LUA_ERRERR&quot;&gt;&lt;code&gt;LUA_ERRERR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d59a96e495b4ed1314e7a452acf7cf2be3dd16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pdf-ipairs&quot;&gt;&lt;code&gt;ipairs&lt;/code&gt;&lt;/a&gt; iterator now respects metamethods and its &lt;code&gt;__ipairs&lt;/code&gt; metamethod has been deprecated.</source>
          <target state="translated">El iterador &lt;a href=&quot;#pdf-ipairs&quot;&gt; &lt;code&gt;ipairs&lt;/code&gt; &lt;/a&gt; ahora respeta los metam&amp;eacute;todos y su &lt;code&gt;__ipairs&lt;/code&gt; __ipairs ha quedado obsoleto.</target>
        </trans-unit>
        <trans-unit id="bc47dc2ae4b1f24c3a3899f4b1f9405cda8bd057" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;break&lt;/b&gt; statement terminates the execution of a &lt;b&gt;while&lt;/b&gt;, &lt;b&gt;repeat&lt;/b&gt;, or &lt;b&gt;for&lt;/b&gt; loop, skipping to the next statement after the loop:</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;b&gt;break&lt;/b&gt; finaliza la ejecuci&amp;oacute;n de un ciclo &lt;b&gt;while&lt;/b&gt; , &lt;b&gt;repetici&amp;oacute;n&lt;/b&gt; o &lt;b&gt;for&lt;/b&gt; , saltando a la siguiente instrucci&amp;oacute;n despu&amp;eacute;s del ciclo:</target>
        </trans-unit>
        <trans-unit id="be57b4db5d11ecd50b150a3c2c7baa57bca94b87" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;for&lt;/b&gt; statement has two forms: one numerical and one generic.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;b&gt;for&lt;/b&gt; tiene dos formas: una num&amp;eacute;rica y otra gen&amp;eacute;rica.</target>
        </trans-unit>
        <trans-unit id="b061702cc21366ebd955da1cbb0818c2844543b8" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;goto&lt;/b&gt; statement transfers the program control to a label. For syntactical reasons, labels in Lua are considered statements too:</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;b&gt;goto&lt;/b&gt; transfiere el control del programa a una etiqueta. Por razones sint&amp;aacute;cticas, las etiquetas en Lua tambi&amp;eacute;n se consideran declaraciones:</target>
        </trans-unit>
        <trans-unit id="eeaa513ac2a2fd15596d8309fe530d856f6a61e0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement can only be written as the last statement of a block. If it is necessary to &lt;b&gt;return&lt;/b&gt; in the middle of a block, then an explicit inner block can be used, as in the idiom &lt;code&gt;do return end&lt;/code&gt;, because now &lt;b&gt;return&lt;/b&gt; is the last statement in its (inner) block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c9f54acbc996a7d79b7252d182ed631a6a317f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement can only be written as the last statement of a block. If it is really necessary to &lt;b&gt;return&lt;/b&gt; in the middle of a block, then an explicit inner block can be used, as in the idiom &lt;code&gt;do return end&lt;/code&gt;, because now &lt;b&gt;return&lt;/b&gt; is the last statement in its (inner) block.</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;b&gt;retorno&lt;/b&gt; solo se puede escribir como la &amp;uacute;ltima declaraci&amp;oacute;n de un bloque. Si es realmente necesario &lt;b&gt;regresar&lt;/b&gt; en medio de un bloque, entonces se puede usar un bloque interno expl&amp;iacute;cito, como en el idioma &lt;code&gt;do return end&lt;/code&gt; , porque ahora &lt;b&gt;return&lt;/b&gt; es la &amp;uacute;ltima instrucci&amp;oacute;n en su bloque (interno).</target>
        </trans-unit>
        <trans-unit id="c44e88f5118a01354e009d7fa35997d3c87c7c1a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement is used to return values from a function or a chunk (which is an anonymous function). Functions can return more than one value, so the syntax for the &lt;b&gt;return&lt;/b&gt; statement is</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;b&gt;retorno&lt;/b&gt; se usa para devolver valores de una funci&amp;oacute;n o un fragmento (que es una funci&amp;oacute;n an&amp;oacute;nima). Las funciones pueden devolver m&amp;aacute;s de un valor, por lo que la sintaxis de la declaraci&amp;oacute;n de &lt;b&gt;retorno&lt;/b&gt; es</target>
        </trans-unit>
        <trans-unit id="50d916d7e4fcf57b5d8ca62cda2c1b54e390dceb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement is used to return values from a function or a chunk (which is handled as an anonymous function). Functions can return more than one value, so the syntax for the &lt;b&gt;return&lt;/b&gt; statement is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b646ffbbdcd054326d494ba2f5c649f95d36297" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bit32&lt;/code&gt; library has been deprecated. It is easy to require a compatible external library or, better yet, to replace its functions with appropriate bitwise operations. (Keep in mind that &lt;code&gt;bit32&lt;/code&gt; operates on 32-bit integers, while the bitwise operators in Lua 5.3 operate on Lua integers, which by default have 64 bits.)</source>
          <target state="translated">La biblioteca &lt;code&gt;bit32&lt;/code&gt; ha quedado obsoleta. Es f&amp;aacute;cil requerir una biblioteca externa compatible o, mejor a&amp;uacute;n, reemplazar sus funciones con operaciones bit a bit adecuadas. (Tenga en cuenta que &lt;code&gt;bit32&lt;/code&gt; opera con enteros de 32 bits, mientras que los operadores bit a bit en Lua 5.3 operan con enteros Lua, que por defecto tienen 64 bits).</target>
        </trans-unit>
        <trans-unit id="768417f6f84362fdef7cb578c8c372a00d6776b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chunkname&lt;/code&gt; argument gives a name to the chunk, which is used for error messages and in debug information (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c35b56166af83b28a7e0e22c5d357b538f84788" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chunkname&lt;/code&gt; argument gives a name to the chunk, which is used for error messages and in debug information (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;).</source>
          <target state="translated">El argumento &lt;code&gt;chunkname&lt;/code&gt; le da un nombre al fragmento, que se usa para mensajes de error y en informaci&amp;oacute;n de depuraci&amp;oacute;n (ver &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bae62f5a0575c4f5ff2aabe5bf99d9776f3199b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lua_load&lt;/code&gt; function uses a user-supplied &lt;code&gt;reader&lt;/code&gt; function to read the chunk (see &lt;a href=&quot;#lua_Reader&quot;&gt;&lt;code&gt;lua_Reader&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;data&lt;/code&gt; argument is an opaque value passed to the reader function.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;lua_load&lt;/code&gt; utiliza una funci&amp;oacute;n de &lt;code&gt;reader&lt;/code&gt; proporcionada por el usuario para leer el fragmento (consulte &lt;a href=&quot;#lua_Reader&quot;&gt; &lt;code&gt;lua_Reader&lt;/code&gt; &lt;/a&gt; ). El argumento de &lt;code&gt;data&lt;/code&gt; es un valor opaco que se pasa a la funci&amp;oacute;n del lector.</target>
        </trans-unit>
        <trans-unit id="85f9907ce6878c8dc7e267337764d4964c7fae3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; string can also have a '&lt;code&gt;b&lt;/code&gt;' at the end, which is needed in some systems to open the file in binary mode.</source>
          <target state="translated">La cadena de &lt;code&gt;mode&lt;/code&gt; tambi&amp;eacute;n puede tener una ' &lt;code&gt;b&lt;/code&gt; ' al final, que es necesaria en algunos sistemas para abrir el archivo en modo binario.</target>
        </trans-unit>
        <trans-unit id="2688f69f4c7b22c66219e46ee16c2eac721dcdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; string can be any of the following:</source>
          <target state="translated">La cadena de &lt;code&gt;mode&lt;/code&gt; puede ser cualquiera de las siguientes:</target>
        </trans-unit>
        <trans-unit id="dcce9d1975851c844f7c2f304003970e38bff938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;q&lt;/code&gt; option formats a string between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;q&lt;/code&gt; formatea una cadena entre comillas dobles, utilizando secuencias de escape cuando es necesario para garantizar que el int&amp;eacute;rprete de Lua pueda leerla de forma segura. Por ejemplo, la llamada</target>
        </trans-unit>
        <trans-unit id="ab9206bbe0932c07e692d615d61a36493a13a496" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;auxiliary library&lt;/em&gt; provides several convenient functions to interface C with Lua. While the basic API provides the primitive functions for all interactions between C and Lua, the auxiliary library provides higher-level functions for some common tasks.</source>
          <target state="translated">La &lt;em&gt;biblioteca auxiliar&lt;/em&gt; proporciona varias funciones convenientes para conectar C con Lua. Mientras que la API b&amp;aacute;sica proporciona las funciones primitivas para todas las interacciones entre C y Lua, la biblioteca auxiliar proporciona funciones de nivel superior para algunas tareas comunes.</target>
        </trans-unit>
        <trans-unit id="8ab6afc13be0118f613c20671f20dcaa66bf50fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;block&lt;/em&gt; is repeated for &lt;em&gt;name&lt;/em&gt; starting at the value of the first &lt;em&gt;exp&lt;/em&gt;, until it passes the second &lt;em&gt;exp&lt;/em&gt; by steps of the third &lt;em&gt;exp&lt;/em&gt;. More precisely, a &lt;b&gt;for&lt;/b&gt; statement like</source>
          <target state="translated">El &lt;em&gt;bloque&lt;/em&gt; se repite para el &lt;em&gt;nombre&lt;/em&gt; comenzando en el valor de la primera &lt;em&gt;exp&lt;/em&gt; , hasta que pasa la segunda &lt;em&gt;exp&lt;/em&gt; por pasos de la tercera &lt;em&gt;exp&lt;/em&gt; . M&amp;aacute;s precisamente, una declaraci&amp;oacute;n &lt;b&gt;for&lt;/b&gt; como</target>
        </trans-unit>
        <trans-unit id="d3b254f35dcb5161307fc6d343f99ec868c9f36b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;colon&lt;/em&gt; syntax is used for defining &lt;em&gt;methods&lt;/em&gt;, that is, functions that have an implicit extra parameter &lt;code&gt;self&lt;/code&gt;. Thus, the statement</source>
          <target state="translated">La sintaxis de &lt;em&gt;dos puntos&lt;/em&gt; se utiliza para definir &lt;em&gt;m&amp;eacute;todos&lt;/em&gt; , es decir, funciones que tienen un par&amp;aacute;metro adicional impl&amp;iacute;cito &lt;code&gt;self&lt;/code&gt; . Por lo tanto, la declaraci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="f572f282cad30118a92f64a8c2a8e8b7d0ba81c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;colon&lt;/em&gt; syntax is used to emulate &lt;em&gt;methods&lt;/em&gt;, adding an implicit extra parameter &lt;code&gt;self&lt;/code&gt; to the function. Thus, the statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d7a7980421d2b17bd0aed9b9a529fd71ecec0a9" translate="yes" xml:space="preserve">
          <source>The I/O library provides two different styles for file manipulation. The first one uses implicit file handles; that is, there are operations to set a default input file and a default output file, and all input/output operations are done over these default files. The second style uses explicit file handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171411617a28d7de2b0226c80067f77ec30897f7" translate="yes" xml:space="preserve">
          <source>The I/O library provides two different styles for file manipulation. The first one uses implicit file handles; that is, there are operations to set a default input file and a default output file, and all input/output operations are over these default files. The second style uses explicit file handles.</source>
          <target state="translated">La biblioteca de E/S proporciona dos estilos diferentes para la manipulación de archivos.El primero utiliza manipuladores de archivos implícitos;es decir,hay operaciones para establecer un archivo de entrada predeterminado y un archivo de salida predeterminado,y todas las operaciones de entrada/salida se realizan sobre estos archivos predeterminados.El segundo estilo utiliza manejadores de archivos explícitos.</target>
        </trans-unit>
        <trans-unit id="fe26bd92623ecffd0ef5b0b7681c64345000ef38" translate="yes" xml:space="preserve">
          <source>The Length Operator</source>
          <target state="translated">El operador de longitud</target>
        </trans-unit>
        <trans-unit id="b46439f6fc2b5220d043e60a0c5b1b7e77db627e" translate="yes" xml:space="preserve">
          <source>The Lua library is fully reentrant: it has no global variables. It keeps all information it needs in a dynamic structure, called the &lt;em&gt;Lua state&lt;/em&gt;.</source>
          <target state="translated">La biblioteca Lua es completamente reentrante: no tiene variables globales. Mantiene toda la informaci&amp;oacute;n que necesita en una estructura din&amp;aacute;mica, llamada &lt;em&gt;estado Lua&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="07b128e0f94f3f9a107ec1b9a4411b8083a41fce" translate="yes" xml:space="preserve">
          <source>The Table library now respects metamethods for setting and getting elements.</source>
          <target state="translated">La biblioteca de la Mesa ahora respeta los métodos para establecer y obtener elementos.</target>
        </trans-unit>
        <trans-unit id="eb554fe048e1c8b347ad8a3da87d434c8b60f5db" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding of a Unicode character can be inserted in a literal string with the escape sequence &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (note the mandatory enclosing brackets), where &lt;em&gt;XXX&lt;/em&gt; is a sequence of one or more hexadecimal digits representing the character code point.</source>
          <target state="translated">La codificaci&amp;oacute;n UTF-8 de un car&amp;aacute;cter Unicode se puede insertar en una cadena literal con la secuencia de escape &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (observe los corchetes obligatorios), donde &lt;em&gt;XXX&lt;/em&gt; es una secuencia de uno o m&amp;aacute;s d&amp;iacute;gitos hexadecimales que representan el punto del c&amp;oacute;digo del car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="133b64cb1acd8fa4b0993eef50a3ec5beecc6e3a" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding of a Unicode character can be inserted in a literal string with the escape sequence &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (with mandatory enclosing braces), where &lt;em&gt;XXX&lt;/em&gt; is a sequence of one or more hexadecimal digits representing the character code point. This code point can be any value less than &lt;em&gt;2&lt;sup&gt;31&lt;/sup&gt;&lt;/em&gt;. (Lua uses the original UTF-8 specification here, which is not restricted to valid Unicode code points.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e71c6008a2054b02c7458c10af8db199b93e0fc" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;l&lt;/code&gt; must be the actual array, not a pointer to it.</source>
          <target state="translated">La matriz &lt;code&gt;l&lt;/code&gt; debe ser la matriz real, no un puntero a ella.</target>
        </trans-unit>
        <trans-unit id="ec4ef8ac03868996fbe27096f10720a2a635fd47" translate="yes" xml:space="preserve">
          <source>The assignment statement first evaluates all its expressions and only then the assignments are performed. Thus the code</source>
          <target state="translated">La declaración de asignación evalúa primero todas sus expresiones y sólo entonces se realizan las asignaciones.Así,el código</target>
        </trans-unit>
        <trans-unit id="63ea036976be25a6fccc44715a31648a894a2cd9" translate="yes" xml:space="preserve">
          <source>The available formats are</source>
          <target state="translated">Los formatos disponibles son</target>
        </trans-unit>
        <trans-unit id="1bf5ee36dda4ba103acec9799a8f08fe38658693" translate="yes" xml:space="preserve">
          <source>The basic expressions in Lua are the following:</source>
          <target state="translated">Las expresiones básicas en Lua son las siguientes:</target>
        </trans-unit>
        <trans-unit id="a90f0e6ef32f54b398b228c2483c97e99f92d4d7" translate="yes" xml:space="preserve">
          <source>The basic library provides core functions to Lua. If you do not include this library in your application, you should check carefully whether you need to provide implementations for some of its facilities.</source>
          <target state="translated">La biblioteca básica proporciona funciones básicas a Lua.Si no incluye esta biblioteca en su aplicación,debe comprobar cuidadosamente si necesita proporcionar implementaciones para algunas de sus instalaciones.</target>
        </trans-unit>
        <trans-unit id="6a4e9c1cd28f7989f62ba005ba19f087fc3592ba" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;next&lt;/code&gt; is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields.</source>
          <target state="translated">El comportamiento de &lt;code&gt;next&lt;/code&gt; no est&amp;aacute; definido si, durante el recorrido, asigna alg&amp;uacute;n valor a un campo no existente en la tabla. Sin embargo, puede modificar los campos existentes. En particular, puede borrar los campos existentes.</target>
        </trans-unit>
        <trans-unit id="ff207200b1250dc2b47ca5a7a827de1d648909f3" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;next&lt;/code&gt; is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may set existing fields to nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc90ae531b088f04f67083e165dbcb68af23283" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;collectgarbage(&quot;count&quot;)&lt;/code&gt; now returns only one result. (You can compute that second result from the fractional part of the first result.)</source>
          <target state="translated">La llamada &lt;code&gt;collectgarbage(&quot;count&quot;)&lt;/code&gt; ahora devuelve solo un resultado. (Puede calcular ese segundo resultado a partir de la parte fraccionaria del primer resultado).</target>
        </trans-unit>
        <trans-unit id="c68441a4203b3cd2bfe34776a10e03a400a467cb" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;io.lines()&lt;/code&gt; (with no file name) is equivalent to &lt;code&gt;io.input():lines(&quot;*l&quot;)&lt;/code&gt;; that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends.</source>
          <target state="translated">La llamada &lt;code&gt;io.lines()&lt;/code&gt; (sin nombre de archivo) es equivalente a &lt;code&gt;io.input():lines(&quot;*l&quot;)&lt;/code&gt; ; es decir, itera sobre las l&amp;iacute;neas del archivo de entrada predeterminado. En este caso, no cierra el archivo cuando finaliza el ciclo.</target>
        </trans-unit>
        <trans-unit id="56312b3ed08e17201e15d0358b34f5524a82475c" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;io.lines()&lt;/code&gt; (with no file name) is equivalent to &lt;code&gt;io.input():lines(&quot;l&quot;)&lt;/code&gt;; that is, it iterates over the lines of the default input file. In this case, the iterator does not close the file when the loop ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4ad773c547ffbe50168aed20636ff53516332e" translate="yes" xml:space="preserve">
          <source>The closing value behaves like a to-be-closed variable (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;), which can be used to release resources when the loop ends. Otherwise, it does not interfere with the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798511549246488486c822aec3e1cc74d4fe6a5b" translate="yes" xml:space="preserve">
          <source>The coercion of strings to numbers in arithmetic and bitwise operations has been removed from the core language. The string library does a similar job for arithmetic (but not for bitwise) operations using the string metamethods. However, unlike in previous versions, the new implementation preserves the implicit type of the numeral in the string. For instance, the result of &lt;code&gt;&quot;1&quot; + &quot;2&quot;&lt;/code&gt; now is an integer, not a float.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef37fdd6b0b5e41eab32a9928b1d9217a2a5737b" translate="yes" xml:space="preserve">
          <source>The computation of the length of a table has a guaranteed worst time of &lt;em&gt;O(log n)&lt;/em&gt;, where &lt;em&gt;n&lt;/em&gt; is the largest natural key in the table.</source>
          <target state="translated">El c&amp;aacute;lculo de la longitud de una tabla tiene garantizado el peor tiempo de &lt;em&gt;O (log n)&lt;/em&gt; , donde &lt;em&gt;n&lt;/em&gt; es la clave natural m&amp;aacute;s grande de la tabla.</target>
        </trans-unit>
        <trans-unit id="0b56d75e0be562bbdd8ce192220fca509ed349d6" translate="yes" xml:space="preserve">
          <source>The condition expression of a control structure can return any value. Both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; are considered false. All values different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; are considered true (in particular, the number 0 and the empty string are also true).</source>
          <target state="translated">La expresi&amp;oacute;n de condici&amp;oacute;n de una estructura de control puede devolver cualquier valor. Tanto &lt;b&gt;falso&lt;/b&gt; como &lt;b&gt;nulo&lt;/b&gt; se consideran falsos. Todos los valores diferentes de &lt;b&gt;nil&lt;/b&gt; y &lt;b&gt;false&lt;/b&gt; se consideran verdaderos (en particular, el n&amp;uacute;mero 0 y la cadena vac&amp;iacute;a tambi&amp;eacute;n son verdaderos).</target>
        </trans-unit>
        <trans-unit id="3b920454c4c1d2c03393d9ac78ec720b9fbaa526" translate="yes" xml:space="preserve">
          <source>The condition expression of a control structure can return any value. Both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; test false. All values different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; test true. In particular, the number 0 and the empty string also test true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec24a70490264f051fb6d0ae4a587a4f8d0e22eb" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; was removed. Errors in finalizers are never propagated; instead, they generate a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3733f14fe1543e4589c9195fb66e8ff53166d2c" translate="yes" xml:space="preserve">
          <source>The control structures &lt;b&gt;if&lt;/b&gt;, &lt;b&gt;while&lt;/b&gt;, and &lt;b&gt;repeat&lt;/b&gt; have the usual meaning and familiar syntax:</source>
          <target state="translated">Las estructuras de control &lt;b&gt;if&lt;/b&gt; , &lt;b&gt;while&lt;/b&gt; y &lt;b&gt;repeat&lt;/b&gt; tienen el significado habitual y la sintaxis familiar:</target>
        </trans-unit>
        <trans-unit id="fd0c2e7539b39e7334ffb646988e686084be276b" translate="yes" xml:space="preserve">
          <source>The conversion from float to integer checks whether the float has an exact representation as an integer (that is, the float has an integral value and it is in the range of integer representation). If it does, that representation is the result. Otherwise, the conversion fails.</source>
          <target state="translated">La conversión de flotador a entero comprueba si el flotador tiene una representación exacta como un entero (es decir,el flotador tiene un valor integral y está en el rango de representación de un entero).Si es así,esa representación es el resultado.De lo contrario,la conversión falla.</target>
        </trans-unit>
        <trans-unit id="2672e5ddb4380b4a0e9162708d0ffacc1d9552f5" translate="yes" xml:space="preserve">
          <source>The conversion from numbers to strings uses a non-specified human-readable format. For complete control over how numbers are converted to strings, use the &lt;code&gt;format&lt;/code&gt; function from the string library (see &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">La conversi&amp;oacute;n de n&amp;uacute;meros a cadenas utiliza un formato legible por humanos no especificado. Para tener un control completo sobre c&amp;oacute;mo los n&amp;uacute;meros se convierten en cadenas, use la funci&amp;oacute;n de &lt;code&gt;format&lt;/code&gt; o de la biblioteca de cadenas (consulte &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d7eef57d5a172c39981c5ce7311c830825d6249b" translate="yes" xml:space="preserve">
          <source>The conversion from numbers to strings uses a non-specified human-readable format. To convert numbers to strings in any specific way, use the function &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4fc8189f226b883ce5f116eb5b865021736d178" translate="yes" xml:space="preserve">
          <source>The conversion from strings to numbers goes as follows: First, the string is converted to an integer or a float, following its syntax and the rules of the Lua lexer. (The string may have also leading and trailing spaces and a sign.) Then, the resulting number (float or integer) is converted to the type (float or integer) required by the context (e.g., the operation that forced the conversion).</source>
          <target state="translated">La conversión de las cadenas a los números es la siguiente:Primero,la cuerda se convierte en un entero o en un flotador,siguiendo su sintaxis y las reglas del Lua lexer.(La cadena puede tener también espacios anteriores y posteriores y un signo.)Luego,el número resultante (flotante o entero)se convierte en el tipo (flotante o entero)que requiere el contexto (por ejemplo,la operación que forzó la conversión).</target>
        </trans-unit>
        <trans-unit id="f171e574fe61e971bf96a3990d066bb469d0ea25" translate="yes" xml:space="preserve">
          <source>The conversion of a float to a string now adds a &lt;code&gt;.0&lt;/code&gt; suffix to the result if it looks like an integer. (For instance, the float 2.0 will be printed as &lt;code&gt;2.0&lt;/code&gt;, not as &lt;code&gt;2&lt;/code&gt;.) You should always use an explicit format when you need a specific format for numbers.</source>
          <target state="translated">La conversi&amp;oacute;n de un flotante en una cadena ahora agrega un sufijo &lt;code&gt;.0&lt;/code&gt; al resultado si parece un n&amp;uacute;mero entero. (Por ejemplo, el float 2.0 se imprimir&amp;aacute; como &lt;code&gt;2.0&lt;/code&gt; , no como &lt;code&gt;2&lt;/code&gt; . ) Siempre debe usar un formato expl&amp;iacute;cito cuando necesite un formato espec&amp;iacute;fico para n&amp;uacute;meros.</target>
        </trans-unit>
        <trans-unit id="fde25091233105fea6baa5683b61b7b5603b3cd0" translate="yes" xml:space="preserve">
          <source>The conversion of strings can result in integers or floats, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). (The string may have leading and trailing spaces and a sign.)</source>
          <target state="translated">La conversi&amp;oacute;n de cadenas puede resultar en n&amp;uacute;meros enteros o flotantes, de acuerdo con las convenciones l&amp;eacute;xicas de Lua (ver &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; ). (La cadena puede tener espacios iniciales y finales y un signo).</target>
        </trans-unit>
        <trans-unit id="8a7deb37cbfaea7e8697ec963b8057a9bed112e3" translate="yes" xml:space="preserve">
          <source>The conversion of strings can result in integers or floats, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). The string may have leading and trailing spaces and a sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2779abe0bdda569ab2443dd1aeb2c757f08c9877" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, and &lt;code&gt;g&lt;/code&gt; all expect a number as argument. The specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; expect an integer. When Lua is compiled with a C89 compiler, the specifiers &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; (hexadecimal floats) do not support modifiers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a41a1a32246a11826a5d6e075e45733f76f3306" translate="yes" xml:space="preserve">
          <source>The conversion specifiers are quite restricted. There are no flags, widths, or precisions. The conversion specifiers can only be '&lt;code&gt;%%&lt;/code&gt;' (inserts the character '&lt;code&gt;%&lt;/code&gt;'), '&lt;code&gt;%s&lt;/code&gt;' (inserts a zero-terminated string, with no size restrictions), '&lt;code&gt;%f&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%I&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%p&lt;/code&gt;' (inserts a pointer as a hexadecimal numeral), '&lt;code&gt;%d&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt;), '&lt;code&gt;%c&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt; as a one-byte character), and '&lt;code&gt;%U&lt;/code&gt;' (inserts a &lt;code&gt;long int&lt;/code&gt; as a UTF-8 byte sequence).</source>
          <target state="translated">Los especificadores de conversi&amp;oacute;n est&amp;aacute;n bastante restringidos. No hay banderas, anchos ni precisiones. Los especificadores de conversi&amp;oacute;n solo pueden ser ' &lt;code&gt;%%&lt;/code&gt; ' (inserta el car&amp;aacute;cter ' &lt;code&gt;%&lt;/code&gt; '), ' &lt;code&gt;%s&lt;/code&gt; ' (inserta una cadena terminada en cero, sin restricciones de tama&amp;ntilde;o), ' &lt;code&gt;%f&lt;/code&gt; ' (inserta un &lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt; ), ' &lt;code&gt;%I&lt;/code&gt; '(inserta un &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; ),' &lt;code&gt;%p&lt;/code&gt; '(inserta un puntero como un n&amp;uacute;mero hexadecimal),' &lt;code&gt;%d&lt;/code&gt; '(inserta un &lt;code&gt;int&lt;/code&gt; ),' &lt;code&gt;%c&lt;/code&gt; '(inserta un &lt;code&gt;int&lt;/code&gt; como un car&amp;aacute;cter de un byte) y' &lt;code&gt;%U&lt;/code&gt; '(inserta un &lt;code&gt;long int&lt;/code&gt; como una secuencia de bytes UTF-8).</target>
        </trans-unit>
        <trans-unit id="4a2b4eab7e7e8e47540c45b140f9d1c1edf8fd79" translate="yes" xml:space="preserve">
          <source>The current parser always sees such constructions in the first way, interpreting the open parenthesis as the start of the arguments to a call. To avoid this ambiguity, it is a good practice to always precede with a semicolon statements that start with a parenthesis:</source>
          <target state="translated">El analizador actual siempre ve tales construcciones de la primera manera,interpretando el paréntesis abierto como el inicio de los argumentos de una llamada.Para evitar esta ambigüedad,es una buena práctica preceder siempre con un punto y coma las declaraciones que comienzan con un paréntesis:</target>
        </trans-unit>
        <trans-unit id="c9bf869e4f0cbfc39ea3983d219f80c93e648f82" translate="yes" xml:space="preserve">
          <source>The default GC mode with the default parameters are adequate for most uses. However, programs that waste a large proportion of their time allocating and freeing memory can benefit from other settings. Keep in mind that the GC behavior is non-portable both across platforms and across different Lua releases; therefore, optimal settings are also non-portable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1273a024b1e39aac89ab0ab6781ebe040b7fbcc0" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;, so that a call &lt;code&gt;table.remove(l)&lt;/code&gt; removes the last element of list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">El valor predeterminado para &lt;code&gt;pos&lt;/code&gt; es &lt;code&gt;#list&lt;/code&gt; , de modo que una llamada &lt;code&gt;table.remove(l)&lt;/code&gt; elimina el &amp;uacute;ltimo elemento de la lista &lt;code&gt;l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29c63af20a776235dbc6fd94c8529980ff13aa8a" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;, so that a call &lt;code&gt;table.remove(l)&lt;/code&gt; removes the last element of the list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c08370b3a28f0fd5960d5a4c5c48fa16e93a96" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;whence&lt;/code&gt; is &lt;code&gt;&quot;cur&quot;&lt;/code&gt;, and for &lt;code&gt;offset&lt;/code&gt; is 0. Therefore, the call &lt;code&gt;file:seek()&lt;/code&gt; returns the current file position, without changing it; the call &lt;code&gt;file:seek(&quot;set&quot;)&lt;/code&gt; sets the position to the beginning of the file (and returns 0); and the call &lt;code&gt;file:seek(&quot;end&quot;)&lt;/code&gt; sets the position to the end of the file, and returns its size.</source>
          <target state="translated">El valor predeterminado para &lt;code&gt;whence&lt;/code&gt; es &lt;code&gt;&quot;cur&quot;&lt;/code&gt; y para el &lt;code&gt;offset&lt;/code&gt; es 0. Por lo tanto, el &lt;code&gt;file:seek()&lt;/code&gt; llamada : seek () devuelve la posici&amp;oacute;n actual del archivo, sin cambiarlo; el &lt;code&gt;file:seek(&quot;set&quot;)&lt;/code&gt; llamada : seek (&quot;set&quot;) establece la posici&amp;oacute;n al principio del archivo (y devuelve 0); y el &lt;code&gt;file:seek(&quot;end&quot;)&lt;/code&gt; llamada : seek (&quot;end&quot;) establece la posici&amp;oacute;n al final del archivo y devuelve su tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="6bc56dc8d299b9d15b00a924ab6b6763132d6c6e" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;x&lt;/code&gt; is 1, so that the call &lt;code&gt;math.atan(y)&lt;/code&gt; returns the arc tangent of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">El valor predeterminado para &lt;code&gt;x&lt;/code&gt; es 1, por lo que la llamada &lt;code&gt;math.atan(y)&lt;/code&gt; devuelve el arco tangente de &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c1119d71f1c451d5f2fe0db217d85e8a5bba94c" translate="yes" xml:space="preserve">
          <source>The definitions of letter, space, and other character groups depend on the current locale. In particular, the class &lt;code&gt;[a-z]&lt;/code&gt; may not be equivalent to &lt;code&gt;%l&lt;/code&gt;.</source>
          <target state="translated">Las definiciones de letras, espacios y otros grupos de caracteres dependen de la configuraci&amp;oacute;n regional actual. En particular, la clase &lt;code&gt;[a-z]&lt;/code&gt; puede no ser equivalente a &lt;code&gt;%l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f71cbe788ea609ab97e549ccaa27836b38cc887d" translate="yes" xml:space="preserve">
          <source>The field list can have an optional trailing separator, as a convenience for machine-generated code.</source>
          <target state="translated">La lista de campos puede tener un separador de arrastre opcional,como una conveniencia para el código generado por la máquina.</target>
        </trans-unit>
        <trans-unit id="e2dc2a9366caaece55ab74f5902257c1d9cc63e9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; have the following meaning:</source>
          <target state="translated">Los campos de &lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; tienen el siguiente significado:</target>
        </trans-unit>
        <trans-unit id="5cf6a1464c2f6d6211946c68accd0138255e9433" translate="yes" xml:space="preserve">
          <source>The fifth line is a mark to ignore all text after it when building the &lt;code&gt;luaopen_&lt;/code&gt; function name. Default is '&lt;code&gt;-&lt;/code&gt;'.</source>
          <target state="translated">La quinta l&amp;iacute;nea es una marca para ignorar todo el texto que sigue al crear el nombre de la funci&amp;oacute;n &lt;code&gt;luaopen_&lt;/code&gt; . El valor predeterminado es ' &lt;code&gt;-&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="d550e1bb0cbfc7b8de8aa9f3e58a6e8b1e903f3a" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.packsize&quot;&gt;&lt;code&gt;string.packsize&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt; is a format string, which describes the layout of the structure being created or read.</source>
          <target state="translated">El primer argumento de &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-string.packsize&quot;&gt; &lt;code&gt;string.packsize&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; es una cadena de formato, que describe el dise&amp;ntilde;o de la estructura que se est&amp;aacute; creando o leyendo.</target>
        </trans-unit>
        <trans-unit id="35b2be930dbf43b40449e98f73501827b087ff5f" translate="yes" xml:space="preserve">
          <source>The first field, &lt;code&gt;o&lt;/code&gt;, is how many elements the function pops from the stack. The second field, &lt;code&gt;p&lt;/code&gt;, is how many elements the function pushes onto the stack. (Any function always pushes its results after popping its arguments.) A field in the form &lt;code&gt;x|y&lt;/code&gt; means the function can push (or pop) &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; elements, depending on the situation; an interrogation mark '&lt;code&gt;?&lt;/code&gt;' means that we cannot know how many elements the function pops/pushes by looking only at its arguments (e.g., they may depend on what is on the stack). The third field, &lt;code&gt;x&lt;/code&gt;, tells whether the function may raise errors: '&lt;code&gt;-&lt;/code&gt;' means the function never raises any error; '&lt;code&gt;m&lt;/code&gt;' means the function may raise out-of-memory errors and errors running a &lt;code&gt;__gc&lt;/code&gt; metamethod; '&lt;code&gt;e&lt;/code&gt;' means the function may raise any errors (it can run arbitrary Lua code, either directly or through metamethods); '&lt;code&gt;v&lt;/code&gt;' means the function may raise an error on purpose.</source>
          <target state="translated">El primer campo, &lt;code&gt;o&lt;/code&gt; , es cu&amp;aacute;ntos elementos saca la funci&amp;oacute;n de la pila. El segundo campo, &lt;code&gt;p&lt;/code&gt; , es cu&amp;aacute;ntos elementos empuja la funci&amp;oacute;n a la pila. (Cualquier funci&amp;oacute;n siempre empuja sus resultados despu&amp;eacute;s de hacer estallar sus argumentos.) Un campo en la forma &lt;code&gt;x|y&lt;/code&gt; significa que la funci&amp;oacute;n puede empujar (o pop) &lt;code&gt;x&lt;/code&gt; o &lt;code&gt;y&lt;/code&gt; elementos, dependiendo de la situaci&amp;oacute;n; un signo de interrogaci&amp;oacute;n ' &lt;code&gt;?&lt;/code&gt; 'significa que no podemos saber cu&amp;aacute;ntos elementos extrae / empuja la funci&amp;oacute;n mirando solo sus argumentos (por ejemplo, pueden depender de lo que hay en la pila). El tercer campo, &lt;code&gt;x&lt;/code&gt; , indica si la funci&amp;oacute;n puede generar errores: ' &lt;code&gt;-&lt;/code&gt; ' significa que la funci&amp;oacute;n nunca genera ning&amp;uacute;n error; ' &lt;code&gt;m&lt;/code&gt; 'significa que la funci&amp;oacute;n puede generar errores de memoria &lt;code&gt;__gc&lt;/code&gt; y errores al ejecutar un metam&amp;eacute;todo __gc; ' &lt;code&gt;e&lt;/code&gt; ' significa que la funci&amp;oacute;n puede generar errores (puede ejecutar c&amp;oacute;digo Lua arbitrario, ya sea directamente o mediante metam&amp;eacute;todos); ' &lt;code&gt;v&lt;/code&gt; ' significa que la funci&amp;oacute;n puede generar un error a prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="0c89478a55ea6827ef7574f90e0b65d3a882b531" translate="yes" xml:space="preserve">
          <source>The first field, &lt;code&gt;o&lt;/code&gt;, is how many elements the function pops from the stack. The second field, &lt;code&gt;p&lt;/code&gt;, is how many elements the function pushes onto the stack. (Any function always pushes its results after popping its arguments.) A field in the form &lt;code&gt;x|y&lt;/code&gt; means the function can push (or pop) &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; elements, depending on the situation; an interrogation mark '&lt;code&gt;?&lt;/code&gt;' means that we cannot know how many elements the function pops/pushes by looking only at its arguments. (For instance, they may depend on what is in the stack.) The third field, &lt;code&gt;x&lt;/code&gt;, tells whether the function may raise errors: '&lt;code&gt;-&lt;/code&gt;' means the function never raises any error; '&lt;code&gt;m&lt;/code&gt;' means the function may raise only out-of-memory errors; '&lt;code&gt;v&lt;/code&gt;' means the function may raise the errors explained in the text; '&lt;code&gt;e&lt;/code&gt;' means the function can run arbitrary Lua code, either directly or through metamethods, and therefore may raise any errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080894d3f355773389e870abdc64bf22951aa7fd" translate="yes" xml:space="preserve">
          <source>The first line is the directory separator string. Default is '&lt;code&gt;\&lt;/code&gt;' for Windows and '&lt;code&gt;/&lt;/code&gt;' for all other systems.</source>
          <target state="translated">La primera l&amp;iacute;nea es la cadena de separaci&amp;oacute;n de directorios. El valor predeterminado es ' &lt;code&gt;\&lt;/code&gt; ' para Windows y ' &lt;code&gt;/&lt;/code&gt; ' para todos los dem&amp;aacute;s sistemas.</target>
        </trans-unit>
        <trans-unit id="618ae404e5e9c891f664deb6c2fb8fab741ce902" translate="yes" xml:space="preserve">
          <source>The first parameter or local variable has index 1, and so on, following the order that they are declared in the code, counting only the variables that are active in the current scope of the function. Compile-time constants may not appear in this listing, if they were optimized away by the compiler. Negative indices refer to vararg arguments; -1 is the first vararg argument. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no variable with the given index, and raises an error when called with a level out of range. (You can call &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt;&lt;code&gt;debug.getinfo&lt;/code&gt;&lt;/a&gt; to check whether the level is valid.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b927b10bd57d8d0d9d2adab8cf882393f87f3f97" translate="yes" xml:space="preserve">
          <source>The first parameter or local variable has index 1, and so on, following the order that they are declared in the code, counting only the variables that are active in the current scope of the function. Negative indices refer to vararg parameters; -1 is the first vararg parameter. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no variable with the given index, and raises an error when called with a level out of range. (You can call &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt;&lt;code&gt;debug.getinfo&lt;/code&gt;&lt;/a&gt; to check whether the level is valid.)</source>
          <target state="translated">El primer par&amp;aacute;metro o variable local tiene &amp;iacute;ndice 1, y as&amp;iacute; sucesivamente, siguiendo el orden en que se declaran en el c&amp;oacute;digo, contando solo las variables que est&amp;aacute;n activas en el &amp;aacute;mbito actual de la funci&amp;oacute;n. Los &amp;iacute;ndices negativos se refieren a par&amp;aacute;metros de vararg; -1 es el primer par&amp;aacute;metro de vararg. La funci&amp;oacute;n devuelve &lt;b&gt;nil&lt;/b&gt; si no hay una variable con el &amp;iacute;ndice dado y genera un error cuando se llama con un nivel fuera de rango. (Puede llamar a &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt; &lt;code&gt;debug.getinfo&lt;/code&gt; &lt;/a&gt; para verificar si el nivel es v&amp;aacute;lido).</target>
        </trans-unit>
        <trans-unit id="ee8f303d70c303dd14cac48bd1f16c3b0dcbcc40" translate="yes" xml:space="preserve">
          <source>The first searcher simply looks for a loader in the &lt;a href=&quot;#pdf-package.preload&quot;&gt;&lt;code&gt;package.preload&lt;/code&gt;&lt;/a&gt; table.</source>
          <target state="translated">El primer buscador simplemente busca un cargador en la tabla &lt;a href=&quot;#pdf-package.preload&quot;&gt; &lt;code&gt;package.preload&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62aececc4ee40da1a864200ef2a0c8a1bcbfc8f7" translate="yes" xml:space="preserve">
          <source>The float value &lt;code&gt;HUGE_VAL&lt;/code&gt;, a value greater than any other numeric value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d265942ec96276d66e6ab599ec30b3a3b29815fd" translate="yes" xml:space="preserve">
          <source>The float value &lt;code&gt;HUGE_VAL&lt;/code&gt;, a value larger than any other numeric value.</source>
          <target state="translated">El valor flotante &lt;code&gt;HUGE_VAL&lt;/code&gt; , un valor mayor que cualquier otro valor num&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="196211405f17ee844517a47f2e8b2cb60db3f8ce" translate="yes" xml:space="preserve">
          <source>The following &lt;em&gt;keywords&lt;/em&gt; are reserved and cannot be used as names:</source>
          <target state="translated">Las siguientes &lt;em&gt;palabras clave&lt;/em&gt; est&amp;aacute;n reservadas y no se pueden utilizar como nombres:</target>
        </trans-unit>
        <trans-unit id="ab8a72a62eca0d1ef8ee4d0f5f153c9b1519bd5d" translate="yes" xml:space="preserve">
          <source>The following example shows how the host program can do the equivalent to this Lua code:</source>
          <target state="translated">El siguiente ejemplo muestra cómo el programa anfitrión puede hacer el equivalente a este código Lua:</target>
        </trans-unit>
        <trans-unit id="278e2855a1845e2a26526bc29fe7fac6d57babe0" translate="yes" xml:space="preserve">
          <source>The following functions were deprecated in the mathematical library: &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, and &lt;code&gt;ldexp&lt;/code&gt;. You can replace &lt;code&gt;math.pow(x,y)&lt;/code&gt; with &lt;code&gt;x^y&lt;/code&gt;; you can replace &lt;code&gt;math.atan2&lt;/code&gt; with &lt;code&gt;math.atan&lt;/code&gt;, which now accepts one or two parameters; you can replace &lt;code&gt;math.ldexp(x,exp)&lt;/code&gt; with &lt;code&gt;x * 2.0^exp&lt;/code&gt;. For the other operations, you can either use an external library or implement them in Lua.</source>
          <target state="translated">Las siguientes funciones quedaron obsoletas en la biblioteca matem&amp;aacute;tica: &lt;code&gt;atan2&lt;/code&gt; , &lt;code&gt;cosh&lt;/code&gt; , &lt;code&gt;sinh&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;pow&lt;/code&gt; , &lt;code&gt;frexp&lt;/code&gt; e &lt;code&gt;ldexp&lt;/code&gt; . Puede reemplazar &lt;code&gt;math.pow(x,y)&lt;/code&gt; con &lt;code&gt;x^y&lt;/code&gt; ; puede reemplazar &lt;code&gt;math.atan2&lt;/code&gt; con &lt;code&gt;math.atan&lt;/code&gt; , que ahora acepta uno o dos par&amp;aacute;metros; puede reemplazar &lt;code&gt;math.ldexp(x,exp)&lt;/code&gt; con &lt;code&gt;x * 2.0^exp&lt;/code&gt; . Para las otras operaciones, puede usar una biblioteca externa o implementarlas en Lua.</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">Las siguientes cuerdas denotan otras fichas:</target>
        </trans-unit>
        <trans-unit id="ba13fb8d8389b33ab088d4fc65f5ec35b8d33e18" translate="yes" xml:space="preserve">
          <source>The following syntactic sugar simplifies function definitions:</source>
          <target state="translated">El siguiente azúcar sintáctico simplifica las definiciones de las funciones:</target>
        </trans-unit>
        <trans-unit id="af2cb037b897b34b24d5a23238cf877011ea082c" translate="yes" xml:space="preserve">
          <source>The form</source>
          <target state="translated">La forma</target>
        </trans-unit>
        <trans-unit id="7a0c21abdce99c6d3820ba447237185fd89bfedf" translate="yes" xml:space="preserve">
          <source>The formats &quot;&lt;code&gt;l&lt;/code&gt;&quot; and &quot;&lt;code&gt;L&lt;/code&gt;&quot; should be used only for text files.</source>
          <target state="translated">Los formatos &quot; &lt;code&gt;l&lt;/code&gt; &quot; y &quot; &lt;code&gt;L&lt;/code&gt; &quot; deben usarse solo para archivos de texto.</target>
        </trans-unit>
        <trans-unit id="dd4c785119c8c33799dde8b20447ed83f6ee2b11" translate="yes" xml:space="preserve">
          <source>The fourth line is a string that, in a path in Windows, is replaced by the executable's directory. Default is '&lt;code&gt;!&lt;/code&gt;'.</source>
          <target state="translated">La cuarta l&amp;iacute;nea es una cadena que, en una ruta en Windows, se reemplaza por el directorio del ejecutable. El valor predeterminado es ' &lt;code&gt;!&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="c4934c1b60689ce3f2c3bcb8e146450b0295d47d" translate="yes" xml:space="preserve">
          <source>The fourth searcher tries an &lt;em&gt;all-in-one loader&lt;/em&gt;. It searches the C path for a library for the root name of the given module. For instance, when requiring &lt;code&gt;a.b.c&lt;/code&gt;, it will search for a C library for &lt;code&gt;a&lt;/code&gt;. If found, it looks into it for an open function for the submodule; in our example, that would be &lt;code&gt;luaopen_a_b_c&lt;/code&gt;. With this facility, a package can pack several C submodules into one single library, with each submodule keeping its original open function.</source>
          <target state="translated">El cuarto buscador prueba un &lt;em&gt;cargador todo en uno&lt;/em&gt; . Busca en la ruta C una biblioteca para el nombre ra&amp;iacute;z del m&amp;oacute;dulo dado. Por ejemplo, cuando requiera &lt;code&gt;a.b.c&lt;/code&gt; , buscar&amp;aacute; una biblioteca C para &lt;code&gt;a&lt;/code&gt; . Si lo encuentra, busca una funci&amp;oacute;n abierta para el subm&amp;oacute;dulo; en nuestro ejemplo, ser&amp;iacute;a &lt;code&gt;luaopen_a_b_c&lt;/code&gt; . Con esta funci&amp;oacute;n, un paquete puede empaquetar varios subm&amp;oacute;dulos C en una sola biblioteca, y cada subm&amp;oacute;dulo mantiene su funci&amp;oacute;n abierta original.</target>
        </trans-unit>
        <trans-unit id="0b073a91442e0e0571f6fed07833298243fbd91c" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; has an extra parameter. This out parameter returns the number of values on the top of the stack that were yielded or returned by the coroutine. (In previous versions, those values were the entire stack.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c583d7e5932250cb3b5f290df0a3aa69c7e5671" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#lua_version&quot;&gt;&lt;code&gt;lua_version&lt;/code&gt;&lt;/a&gt; returns the version number, instead of an address of the version number. The Lua core should work correctly with libraries using their own static copies of the same core, so there is no need to check whether they are using the same address space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e053a7fc1423644f26201e21114115843c06a5" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#pdf-io.lines&quot;&gt;&lt;code&gt;io.lines&lt;/code&gt;&lt;/a&gt; now returns four values, instead of just one. That can be a problem when it is used as the sole argument to another function that has optional parameters, such as in &lt;code&gt;load(io.lines(filename, &quot;L&quot;))&lt;/code&gt;. To fix that issue, you can wrap the call into parentheses, to adjust its number of results to one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc8b5fcb7191e1242fe3f17f70a609a4340afa3" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#pdf-print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; does not call &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt; to format its arguments; instead, it has this functionality hardwired. You should use &lt;code&gt;__tostring&lt;/code&gt; to modify how values are printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0263ab6ca26086df9c4e35bef1b518910d2dc151" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#pdf-string.gsub&quot;&gt;&lt;code&gt;string.gsub&lt;/code&gt;&lt;/a&gt; and the iterator &lt;a href=&quot;#pdf-string.gmatch&quot;&gt;&lt;code&gt;string.gmatch&lt;/code&gt;&lt;/a&gt; match multiple occurrences of the given pattern in the subject. For these functions, a new match is considered valid only if it ends at least one byte after the end of the previous match. In other words, the pattern machine never accepts the empty string as a match immediately after another match. As an example, consider the results of the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ef273b64fc52356a4906b3e7d6eabe19ee71ea" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;print&lt;/code&gt; is not intended for formatted output, but only as a quick way to show a value, for instance for debugging. For complete control over the output, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.write&quot;&gt;&lt;code&gt;io.write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220aaa9b01b5620d0798784b861e1408f8a717e8" translate="yes" xml:space="preserve">
          <source>The function returns the address of the block of memory. Lua ensures that this address is valid as long as the corresponding userdata is alive (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;). Moreover, if the userdata is marked for finalization (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;), its address is valid at least until the call to its finalizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc98f5bacbd5d5c9b5f87b48eedc41b8165ed273" translate="yes" xml:space="preserve">
          <source>The garbage collector (GC) in Lua can work in two modes: incremental and generational.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3fbd703ec3951b9eef95d2b7d4e3956a139b1f1" translate="yes" xml:space="preserve">
          <source>The garbage-collector pause controls how long the collector waits before starting a new cycle. Larger values make the collector less aggressive. Values smaller than 100 mean the collector will not wait to start a new cycle. A value of 200 means that the collector waits for the total memory in use to double before starting a new cycle.</source>
          <target state="translated">La pausa del recolector de basura controla el tiempo que el recolector espera antes de comenzar un nuevo ciclo.Los valores más grandes hacen que el recolector sea menos agresivo.Los valores inferiores a 100 significan que el recolector no esperará para iniciar un nuevo ciclo.Un valor de 200 significa que el recolector espera que la memoria total en uso se duplique antes de comenzar un nuevo ciclo.</target>
        </trans-unit>
        <trans-unit id="9930e7ac93649b09106490695fbc0f2072543bb0" translate="yes" xml:space="preserve">
          <source>The garbage-collector pause controls how long the collector waits before starting a new cycle. The collector starts a new cycle when the use of memory hits &lt;em&gt;n%&lt;/em&gt; of the use after the previous collection. Larger values make the collector less aggressive. Values equal to or less than 100 mean the collector will not wait to start a new cycle. A value of 200 means that the collector waits for the total memory in use to double before starting a new cycle. The default value is 200; the maximum value is 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da0189eddd3acd188369ff8e9890d24f44cba07" translate="yes" xml:space="preserve">
          <source>The garbage-collector step multiplier controls the relative speed of the collector relative to memory allocation. Larger values make the collector more aggressive but also increase the size of each incremental step. You should not use values smaller than 100, because they make the collector too slow and can result in the collector never finishing a cycle. The default is 200, which means that the collector runs at &quot;twice&quot; the speed of memory allocation.</source>
          <target state="translated">El multiplicador de pasos del recolector de basura controla la velocidad relativa del recolector en relación con la asignación de la memoria.Los valores más grandes hacen que el recolector sea más agresivo pero también aumentan el tamaño de cada paso incremental.No se deben utilizar valores inferiores a 100,porque hacen que el recolector sea demasiado lento y pueden hacer que el recolector no termine nunca un ciclo.El valor predeterminado es 200,lo que significa que el colector funciona a &quot;el doble&quot; de la velocidad de asignación de memoria.</target>
        </trans-unit>
        <trans-unit id="edd02666b7bd31dec27098654c590c3963c3039b" translate="yes" xml:space="preserve">
          <source>The garbage-collector step multiplier controls the speed of the collector relative to memory allocation, that is, how many elements it marks or sweeps for each kilobyte of memory allocated. Larger values make the collector more aggressive but also increase the size of each incremental step. You should not use values less than 100, because they make the collector too slow and can result in the collector never finishing a cycle. The default value is 100; the maximum value is 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a660cf022dffa05c59d7259e6adabb7cdd6f67" translate="yes" xml:space="preserve">
          <source>The garbage-collector step size controls the size of each incremental step, specifically how many bytes the interpreter allocates before performing a step. This parameter is logarithmic: A value of &lt;em&gt;n&lt;/em&gt; means the interpreter will allocate &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; bytes between steps and perform equivalent work during the step. A large value (e.g., 60) makes the collector a stop-the-world (non-incremental) collector. The default value is 13, which means steps of approximately 8 Kbytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dc362bec1b0383d76bda32165a279742df9516d" translate="yes" xml:space="preserve">
          <source>The generational mode for the garbage collector was removed. (It was an experimental feature in Lua 5.2.)</source>
          <target state="translated">El modo generacional para el recolector de basura fue eliminado.(Era un rasgo experimental en Lua 5.2.)</target>
        </trans-unit>
        <trans-unit id="d89e31ab18c670e311841a5e28477ef95d2189d8" translate="yes" xml:space="preserve">
          <source>The generic &lt;b&gt;for&lt;/b&gt; loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3906554899c83e568ddf64f2f5b8f01161ffbe7d" translate="yes" xml:space="preserve">
          <source>The generic &lt;b&gt;for&lt;/b&gt; statement works over functions, called &lt;em&gt;iterators&lt;/em&gt;. On each iteration, the iterator function is called to produce a new value, stopping when this new value is &lt;b&gt;nil&lt;/b&gt;. The generic &lt;b&gt;for&lt;/b&gt; loop has the following syntax:</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;b&gt;for&lt;/b&gt; gen&amp;eacute;rica funciona sobre funciones, llamadas &lt;em&gt;iteradores&lt;/em&gt; . En cada iteraci&amp;oacute;n, se llama a la funci&amp;oacute;n iteradora para producir un nuevo valor, deteni&amp;eacute;ndose cuando este nuevo valor es &lt;b&gt;nulo&lt;/b&gt; . El bucle &lt;b&gt;for&lt;/b&gt; gen&amp;eacute;rico tiene la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="856007e1c22ba68bdc34a47c09a357751a2f6c62" translate="yes" xml:space="preserve">
          <source>The given identifier (Name) defines the control variable, which is a new variable local to the loop body (&lt;em&gt;block&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd954aa3fd6697b79eaabbdef5d75d8c6c7ba3dc" translate="yes" xml:space="preserve">
          <source>The grammar could see it in two ways:</source>
          <target state="translated">La gramática podía verlo de dos maneras:</target>
        </trans-unit>
        <trans-unit id="65c328f00080b0011f18aa3b0ed9224892f98cda" translate="yes" xml:space="preserve">
          <source>The grammar could see this fragment in two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4c9ed6f872e82764d4027ec65c0b5bc05fccbd" translate="yes" xml:space="preserve">
          <source>The indexing of tables follows the definition of raw equality in the language. The expressions &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;a[j]&lt;/code&gt; denote the same table element if and only if &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are raw equal (that is, equal without metamethods). In particular, floats with integral values are equal to their respective integers (e.g., &lt;code&gt;1.0 == 1&lt;/code&gt;). To avoid ambiguities, any float used as a key that is equal to an integer is converted to that integer. For instance, if you write &lt;code&gt;a[2.0] = true&lt;/code&gt;, the actual key inserted into the table will be the integer &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16256befb5f873dad0793713187bd7e83a270f1" translate="yes" xml:space="preserve">
          <source>The indexing of tables follows the definition of raw equality in the language. The expressions &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;a[j]&lt;/code&gt; denote the same table element if and only if &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are raw equal (that is, equal without metamethods). In particular, floats with integral values are equal to their respective integers (e.g., &lt;code&gt;1.0 == 1&lt;/code&gt;). To avoid ambiguities, any float with integral value used as a key is converted to its respective integer. For instance, if you write &lt;code&gt;a[2.0] = true&lt;/code&gt;, the actual key inserted into the table will be the integer &lt;code&gt;2&lt;/code&gt;. (On the other hand, 2 and &quot;&lt;code&gt;2&lt;/code&gt;&quot; are different Lua values and therefore denote different table entries.)</source>
          <target state="translated">La indexaci&amp;oacute;n de tablas sigue la definici&amp;oacute;n de igualdad bruta en el idioma. Las expresiones &lt;code&gt;a[i]&lt;/code&gt; y &lt;code&gt;a[j]&lt;/code&gt; denotan el mismo elemento de tabla si y s&amp;oacute;lo si &lt;code&gt;i&lt;/code&gt; y &lt;code&gt;j&lt;/code&gt; son iguales en bruto (es decir, iguales sin metam&amp;eacute;todos). En particular, los flotantes con valores integrales son iguales a sus respectivos n&amp;uacute;meros enteros (por ejemplo, &lt;code&gt;1.0 == 1&lt;/code&gt; ). Para evitar ambig&amp;uuml;edades, cualquier flotante con valor integral utilizado como clave se convierte en su n&amp;uacute;mero entero respectivo. Por ejemplo, si escribe &lt;code&gt;a[2.0] = true&lt;/code&gt; , la clave real insertada en la tabla ser&amp;aacute; el n&amp;uacute;mero entero &lt;code&gt;2&lt;/code&gt; . (Por otro lado, 2 y &quot; &lt;code&gt;2&lt;/code&gt; &quot; son valores Lua diferentes y, por lo tanto, denotan entradas de tabla diferentes).</target>
        </trans-unit>
        <trans-unit id="63673ee512e5ce79f47a34ae0e3f5ac37fa01bb2" translate="yes" xml:space="preserve">
          <source>The integer keys in the registry are used by the reference mechanism (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;) and by some predefined values. Therefore, integer keys in the registry must not be used for other purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b21a8105ceb5ba09152263fc96b9536c63b0161" translate="yes" xml:space="preserve">
          <source>The integer keys in the registry are used by the reference mechanism (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;) and by some predefined values. Therefore, integer keys must not be used for other purposes.</source>
          <target state="translated">Las claves enteras en el registro son utilizadas por el mecanismo de referencia (ver &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; ) y por algunos valores predefinidos. Por lo tanto, las claves enteras no se deben utilizar para otros fines.</target>
        </trans-unit>
        <trans-unit id="9e586180c1379ce5751eba407cc18f08a9cdeaf0" translate="yes" xml:space="preserve">
          <source>The interaction between ranges and classes is not defined. Therefore, patterns like &lt;code&gt;[%a-z]&lt;/code&gt; or &lt;code&gt;[a-%%]&lt;/code&gt; have no meaning.</source>
          <target state="translated">La interacci&amp;oacute;n entre rangos y clases no est&amp;aacute; definida. Por lo tanto, patrones como &lt;code&gt;[%a-z]&lt;/code&gt; o &lt;code&gt;[a-%%]&lt;/code&gt; no tienen significado.</target>
        </trans-unit>
        <trans-unit id="6dede3b6c4c93cdc9b3511ce20065bb16da883ae" translate="yes" xml:space="preserve">
          <source>The key for each event in a metatable is a string with the event name prefixed by two underscores; the corresponding value is called a &lt;em&gt;metavalue&lt;/em&gt;. For most events, the metavalue must be a function, which is then called a &lt;em&gt;metamethod&lt;/em&gt;. In the previous example, the key is the string &quot;&lt;code&gt;__add&lt;/code&gt;&quot; and the metamethod is the function that performs the addition. Unless stated otherwise, a metamethod may in fact be any callable value, which is either a function or a value with a &lt;code&gt;__call&lt;/code&gt; metamethod.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c90b056889f7693fbb491e97825cdc7458b557" translate="yes" xml:space="preserve">
          <source>The key for each event in a metatable is a string with the event name prefixed by two underscores; the corresponding values are called &lt;em&gt;metamethods&lt;/em&gt;. In the previous example, the key is &quot;&lt;code&gt;__add&lt;/code&gt;&quot; and the metamethod is the function that performs the addition.</source>
          <target state="translated">La clave para cada evento en una metatabla es una cadena con el nombre del evento precedido por dos guiones bajos; los valores correspondientes se denominan &lt;em&gt;metam&amp;eacute;todos&lt;/em&gt; . En el ejemplo anterior, la clave es &quot; &lt;code&gt;__add&lt;/code&gt; &quot; y el metam&amp;eacute;todo es la funci&amp;oacute;n que realiza la suma.</target>
        </trans-unit>
        <trans-unit id="a1e3c58922162233ff6ef255d5df925e8da6f663" translate="yes" xml:space="preserve">
          <source>The length of a string is its number of bytes (that is, the usual meaning of string length when each character is one byte).</source>
          <target state="translated">La longitud de una cadena es su número de bytes (es decir,el significado habitual de la longitud de una cadena cuando cada carácter es un byte).</target>
        </trans-unit>
        <trans-unit id="d1dc4024a9680b5759a0dab678db12d3202b04ba" translate="yes" xml:space="preserve">
          <source>The length of a string is its number of bytes. (That is the usual meaning of string length when each character is one byte.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01dac97eea86a239bf3254b898850f4681c59248" translate="yes" xml:space="preserve">
          <source>The length operator applied on a table returns a border in that table. A &lt;em&gt;border&lt;/em&gt; in a table &lt;code&gt;t&lt;/code&gt; is any natural number that satisfies the following condition:</source>
          <target state="translated">El operador de longitud aplicado en una tabla devuelve un borde en esa tabla. Un &lt;em&gt;borde&lt;/em&gt; en una tabla &lt;code&gt;t&lt;/code&gt; es cualquier n&amp;uacute;mero natural que satisface la siguiente condici&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="3a0004633e5acb8c29842421799433ea833432d7" translate="yes" xml:space="preserve">
          <source>The length operator is denoted by the unary prefix operator &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">El operador de longitud se indica mediante el operador de prefijo unario &lt;code&gt;#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13a462f71ac26baf154dba8703e365c0df2ac20a" translate="yes" xml:space="preserve">
          <source>The library function &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; returns a string describing the type of a given value (see &lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt;).</source>
          <target state="translated">El &lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n de biblioteca devuelve una cadena que describe el tipo de un valor dado (ver &lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5fc003c63a59472e6941a3dc3f9e6ddca58cd50e" translate="yes" xml:space="preserve">
          <source>The library function &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; returns a string describing the type of a given value (see &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6144a62a4a0e6d0612f6eb91c540d8aa8bcf7d08" translate="yes" xml:space="preserve">
          <source>The logical operators in Lua are &lt;b&gt;and&lt;/b&gt;, &lt;b&gt;or&lt;/b&gt;, and &lt;b&gt;not&lt;/b&gt;. Like the control structures (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;), all logical operators consider both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; as false and anything else as true.</source>
          <target state="translated">Los operadores l&amp;oacute;gicos en Lua son &lt;b&gt;y&lt;/b&gt; , &lt;b&gt;o&lt;/b&gt; y &lt;b&gt;no&lt;/b&gt; . Al igual que las estructuras de control (consulte &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt; ), todos los operadores l&amp;oacute;gicos consideran &lt;b&gt;falso&lt;/b&gt; y &lt;b&gt;nil&lt;/b&gt; como falso y cualquier otra cosa como verdadero.</target>
        </trans-unit>
        <trans-unit id="50f9701ab78d887f6625cde402aefbda0aeac6cc" translate="yes" xml:space="preserve">
          <source>The loop creates ten closures (that is, ten instances of the anonymous function). Each of these closures uses a different &lt;code&gt;y&lt;/code&gt; variable, while all of them share the same &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">El bucle crea diez cierres (es decir, diez instancias de la funci&amp;oacute;n an&amp;oacute;nima). Cada uno de estos cierres usa una variable &lt;code&gt;y&lt;/code&gt; diferente , mientras que todos comparten la misma &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1f770e06bb0b2e653c2173ac5aacca6b0af5ebd" translate="yes" xml:space="preserve">
          <source>The loop starts by evaluating &lt;em&gt;explist&lt;/em&gt; to produce four values: an &lt;em&gt;iterator function&lt;/em&gt;, a &lt;em&gt;state&lt;/em&gt;, an initial value for the control variable, and a &lt;em&gt;closing value&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3ff1f0aa94e8024327de7dc633ad7a75222d95" translate="yes" xml:space="preserve">
          <source>The loop starts by evaluating once the three control expressions. Their values are called respectively the &lt;em&gt;initial value&lt;/em&gt;, the &lt;em&gt;limit&lt;/em&gt;, and the &lt;em&gt;step&lt;/em&gt;. If the step is absent, it defaults to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdc614cc4ad6f49d0283a9ba3115c9056932e8c" translate="yes" xml:space="preserve">
          <source>The loop variable &lt;code&gt;v&lt;/code&gt; is local to the loop body. If you need its value after the loop, assign it to another variable before exiting the loop.</source>
          <target state="translated">La variable de bucle &lt;code&gt;v&lt;/code&gt; es local al cuerpo del bucle. Si necesita su valor despu&amp;eacute;s del ciclo, as&amp;iacute;gnelo a otra variable antes de salir del ciclo.</target>
        </trans-unit>
        <trans-unit id="939c85d0694beae03ef42c252fc95eeaad38dd40" translate="yes" xml:space="preserve">
          <source>The loop variables &lt;code&gt;&lt;em&gt;var_i&lt;/em&gt;&lt;/code&gt; are local to the loop; you cannot use their values after the &lt;b&gt;for&lt;/b&gt; ends. If you need these values, then assign them to other variables before breaking or exiting the loop.</source>
          <target state="translated">Las variables de ciclo &lt;code&gt;&lt;em&gt;var_i&lt;/em&gt;&lt;/code&gt; son locales del ciclo; no puede usar sus valores despu&amp;eacute;s de los fines de &lt;b&gt;for&lt;/b&gt; . Si necesita estos valores, as&amp;iacute;gnelos a otras variables antes de romper o salir del ciclo.</target>
        </trans-unit>
        <trans-unit id="b244dd1c7e2205379de1905e2e723510ea200bac" translate="yes" xml:space="preserve">
          <source>The main difference between Lua 5.2 and Lua 5.3 is the introduction of an integer subtype for numbers. Although this change should not affect &quot;normal&quot; computations, some computations (mainly those that involve some kind of overflow) can give different results.</source>
          <target state="translated">La principal diferencia entre Lua 5.2 y Lua 5.3 es la introducción de un subtipo entero para los números.Aunque este cambio no debería afectar a los cálculos &quot;normales&quot;,algunos cálculos (principalmente los que implican algún tipo de desbordamiento)pueden dar resultados diferentes.</target>
        </trans-unit>
        <trans-unit id="3024413e5d3167e329701cbe9f0df4ab1bc0ec8a" translate="yes" xml:space="preserve">
          <source>The major multiplier controls the frequency of major collections. For a major multiplier &lt;em&gt;x&lt;/em&gt;, a new major collection will be done when memory grows &lt;em&gt;x%&lt;/em&gt; larger than the memory in use after the previous major collection. For instance, for a multiplier of 100, the collector will do a major collection when the use of memory gets larger than twice the use after the previous collection. The default value is 100; the maximum value is 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc3afb9da0c5e976f755e7c1da0bc9514acc6c24" translate="yes" xml:space="preserve">
          <source>The maximum value for &lt;code&gt;n&lt;/code&gt; is 255.</source>
          <target state="translated">El valor m&amp;aacute;ximo de &lt;code&gt;n&lt;/code&gt; es 255.</target>
        </trans-unit>
        <trans-unit id="ffedb8611bd2219ed1341ed93dfa610c03d14160" translate="yes" xml:space="preserve">
          <source>The meaning of accesses to table fields can be changed via metatables (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab795f1f93d86887860588306bf3a809576817cd" translate="yes" xml:space="preserve">
          <source>The meaning of accesses to table fields can be changed via metatables. An access to an indexed variable &lt;code&gt;t[i]&lt;/code&gt; is equivalent to a call &lt;code&gt;gettable_event(t,i)&lt;/code&gt;. (See &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; for a complete description of the &lt;code&gt;gettable_event&lt;/code&gt; function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.)</source>
          <target state="translated">El significado de los accesos a los campos de la tabla se puede cambiar mediante metatablas. Un acceso a una variable indexada &lt;code&gt;t[i]&lt;/code&gt; es equivalente a una llamada &lt;code&gt;gettable_event(t,i)&lt;/code&gt; . (Consulte &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; para obtener una descripci&amp;oacute;n completa de la funci&amp;oacute;n &lt;code&gt;gettable_event&lt;/code&gt; . Esta funci&amp;oacute;n no est&amp;aacute; definida ni se puede llamar en Lua. La usamos aqu&amp;iacute; solo con fines explicativos).</target>
        </trans-unit>
        <trans-unit id="51f3fb78699ea2b9989d6abd1980c0cbe4cf6630" translate="yes" xml:space="preserve">
          <source>The meaning of assignments to global variables and table fields can be changed via metatables. An assignment to an indexed variable &lt;code&gt;t[i] = val&lt;/code&gt; is equivalent to &lt;code&gt;settable_event(t,i,val)&lt;/code&gt;. (See &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; for a complete description of the &lt;code&gt;settable_event&lt;/code&gt; function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.)</source>
          <target state="translated">El significado de las asignaciones a variables globales y campos de tabla se puede cambiar mediante metatablas. Una asignaci&amp;oacute;n a una variable indexada &lt;code&gt;t[i] = val&lt;/code&gt; es equivalente a &lt;code&gt;settable_event(t,i,val)&lt;/code&gt; . (Consulte &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; para obtener una descripci&amp;oacute;n completa de la funci&amp;oacute;n &lt;code&gt;settable_event&lt;/code&gt; . Esta funci&amp;oacute;n no est&amp;aacute; definida ni se puede llamar en Lua. La usamos aqu&amp;iacute; solo con fines explicativos).</target>
        </trans-unit>
        <trans-unit id="9a2953cd0234cc021c9ceb35ae45458389e231cf" translate="yes" xml:space="preserve">
          <source>The meaning of assignments to table fields and global variables (which are actually table fields, too) can be changed via metatables (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476f7f8ec4dc606dda756c2c57f4d79d5157eb87" translate="yes" xml:space="preserve">
          <source>The metatable for file handles provides metamethods for &lt;code&gt;__gc&lt;/code&gt; and &lt;code&gt;__close&lt;/code&gt; that try to close the file when called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a517aff7a09be0502b296b4a746e4f103b62d5ad" translate="yes" xml:space="preserve">
          <source>The metavalue for this event can be either a function, a table, or any value with an &lt;code&gt;__index&lt;/code&gt; metavalue. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; as arguments, and the result of the call (adjusted to one value) is the result of the operation. Otherwise, the final result is the result of indexing this metavalue with &lt;code&gt;key&lt;/code&gt;. This indexing is regular, not raw, and therefore can trigger another &lt;code&gt;__index&lt;/code&gt; metavalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a54b38487e5e67e3c97a44903b55794c2a39219" translate="yes" xml:space="preserve">
          <source>The minor multiplier controls the frequency of minor collections. For a minor multiplier &lt;em&gt;x&lt;/em&gt;, a new minor collection will be done when memory grows &lt;em&gt;x%&lt;/em&gt; larger than the memory in use after the previous major collection. For instance, for a multiplier of 20, the collector will do a minor collection when the use of memory gets 20% larger than the use after the previous major collection. The default value is 20; the maximum value is 200.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15199f2dd863423c43df4649876d6a87282f6752" translate="yes" xml:space="preserve">
          <source>The names &lt;em&gt;var_i&lt;/em&gt; declare loop variables local to the loop body. The first of these variables is the &lt;em&gt;control variable&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fe8ffeb58ed09038372ff537610ec6335cea78" translate="yes" xml:space="preserve">
          <source>The negation operator &lt;b&gt;not&lt;/b&gt; always returns &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;true&lt;/b&gt;. The conjunction operator &lt;b&gt;and&lt;/b&gt; returns its first argument if this value is &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;nil&lt;/b&gt;; otherwise, &lt;b&gt;and&lt;/b&gt; returns its second argument. The disjunction operator &lt;b&gt;or&lt;/b&gt; returns its first argument if this value is different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt;; otherwise, &lt;b&gt;or&lt;/b&gt; returns its second argument. Both &lt;b&gt;and&lt;/b&gt; and &lt;b&gt;or&lt;/b&gt; use short-circuit evaluation; that is, the second operand is evaluated only if necessary. Here are some examples:</source>
          <target state="translated">El operador de negaci&amp;oacute;n &lt;b&gt;no&lt;/b&gt; siempre devuelve &lt;b&gt;falso&lt;/b&gt; o &lt;b&gt;verdadero&lt;/b&gt; . El operador de conjunci&amp;oacute;n &lt;b&gt;y&lt;/b&gt; devuelve su primer argumento si este valor es &lt;b&gt;falso&lt;/b&gt; o &lt;b&gt;nulo&lt;/b&gt; ; de lo contrario, &lt;b&gt;y&lt;/b&gt; devuelve su segundo argumento. El operador de disyunci&amp;oacute;n &lt;b&gt;o&lt;/b&gt; devuelve su primer argumento, si este valor es distinto de &lt;b&gt;cero&lt;/b&gt; y &lt;b&gt;falsa&lt;/b&gt; ; de lo contrario, &lt;b&gt;o&lt;/b&gt; devuelve su segundo argumento. Tanto &lt;b&gt;y&lt;/b&gt; y &lt;b&gt;o&lt;/b&gt; evaluaci&amp;oacute;n de corto circuito de uso; es decir, el segundo operando se eval&amp;uacute;a solo si es necesario. Aqu&amp;iacute; hay unos ejemplos:</target>
        </trans-unit>
        <trans-unit id="38ec12da384a6d35f4d20d38b437d28efd6741c1" translate="yes" xml:space="preserve">
          <source>The next example collects all pairs &lt;code&gt;key=value&lt;/code&gt; from the given string into a table:</source>
          <target state="translated">El siguiente ejemplo recopila todos los pares &lt;code&gt;key=value&lt;/code&gt; de la cadena dada en una tabla:</target>
        </trans-unit>
        <trans-unit id="116b01f4d99ddb42293ee136ce9aea24e5e4cfa4" translate="yes" xml:space="preserve">
          <source>The notation &lt;b&gt;fail&lt;/b&gt; means a false value representing some kind of failure. (Currently, &lt;b&gt;fail&lt;/b&gt; is equal to &lt;b&gt;nil&lt;/b&gt;, but that may change in future versions. The recommendation is to always test the success of these functions with &lt;code&gt;(not status)&lt;/code&gt;, instead of &lt;code&gt;(status == nil)&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71396a651a41b41de0bb0db4aedd5e23034b53f6" translate="yes" xml:space="preserve">
          <source>The numerical &lt;b&gt;for&lt;/b&gt; loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8808774c2b04bca424be7db4bdcbf672bc791b6" translate="yes" xml:space="preserve">
          <source>The numerical &lt;b&gt;for&lt;/b&gt; loop repeats a block of code while a control variable goes through an arithmetic progression. It has the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb025962461d05ecdc613ae74134730113e392ef" translate="yes" xml:space="preserve">
          <source>The numerical &lt;b&gt;for&lt;/b&gt; loop repeats a block of code while a control variable runs through an arithmetic progression. It has the following syntax:</source>
          <target state="translated">El bucle &lt;b&gt;for&lt;/b&gt; num&amp;eacute;rico repite un bloque de c&amp;oacute;digo mientras una variable de control se ejecuta a trav&amp;eacute;s de una progresi&amp;oacute;n aritm&amp;eacute;tica. Tiene la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="17ab43bf243843bc19a105d07ba039f8f3f1779b" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~=&lt;/code&gt; is exactly the negation of equality (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">El operador &lt;code&gt;~=&lt;/code&gt; es exactamente la negaci&amp;oacute;n de la igualdad ( &lt;code&gt;==&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3db0143b2ada0fe6ef4d1b484bfc03ef679605a8" translate="yes" xml:space="preserve">
          <source>The options &quot;&lt;code&gt;setpause&lt;/code&gt;&quot; and &quot;&lt;code&gt;setstepmul&lt;/code&gt;&quot; of the function &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt; are deprecated. You should use the new option &quot;&lt;code&gt;incremental&lt;/code&gt;&quot; to set them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47866a087f6f3e0b29ca9d79b5ace30fa7e691fb" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;-e&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, and &lt;code&gt;-W&lt;/code&gt; are handled in the order they appear. For instance, an invocation like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cd1dd677d9388e84d76eced4474c97bac8b4fd" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt; and &lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt; of the function &lt;a href=&quot;#lua_gc&quot;&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt; are deprecated. You should use the new option &lt;code&gt;LUA_GCINC&lt;/code&gt; to set them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbc030680dac1e5576f7a0a32beac02271b1de9f" translate="yes" xml:space="preserve">
          <source>The options are:</source>
          <target state="translated">Las opciones son:</target>
        </trans-unit>
        <trans-unit id="c0e99c83b2c086ff1b9d5a58745baab04d9e1b8a" translate="yes" xml:space="preserve">
          <source>The order in which the indices are enumerated is not specified, &lt;em&gt;even for numeric indices&lt;/em&gt;. (To traverse a table in numerical order, use a numerical &lt;b&gt;for&lt;/b&gt;.)</source>
          <target state="translated">No se especifica el orden en el que se enumeran los &amp;iacute;ndices, &lt;em&gt;incluso para &amp;iacute;ndices num&amp;eacute;ricos&lt;/em&gt; . (Para recorrer una tabla en orden num&amp;eacute;rico, use un n&amp;uacute;mero &lt;b&gt;para&lt;/b&gt; .)</target>
        </trans-unit>
        <trans-unit id="30b30ff9b28bb0a62b9d5eaa0e7b9c185acec6fd" translate="yes" xml:space="preserve">
          <source>The order of the assignments in a constructor is undefined. (This order would be relevant only when there are repeated keys.)</source>
          <target state="translated">El orden de las asignaciones en un constructor no está definido.(Este orden sólo sería relevante cuando hay claves repetidas.)</target>
        </trans-unit>
        <trans-unit id="e03d986c8e2482e4650648398c1e744ca72bdc4f" translate="yes" xml:space="preserve">
          <source>The order operators work as follows. If both arguments are numbers, then they are compared according to their mathematical values (regardless of their subtypes). Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the &quot;lt&quot; or the &quot;le&quot; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). A comparison &lt;code&gt;a &amp;gt; b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt; a&lt;/code&gt; and &lt;code&gt;a &amp;gt;= b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt;= a&lt;/code&gt;.</source>
          <target state="translated">Los operadores de &amp;oacute;rdenes funcionan de la siguiente manera. Si ambos argumentos son n&amp;uacute;meros, entonces se comparan de acuerdo con sus valores matem&amp;aacute;ticos (independientemente de sus subtipos). De lo contrario, si ambos argumentos son cadenas, sus valores se comparan de acuerdo con la configuraci&amp;oacute;n regional actual. De lo contrario, Lua intenta llamar al metam&amp;eacute;todo &quot;lt&quot; o &quot;le&quot; (ver &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ). Una comparaci&amp;oacute;n &lt;code&gt;a &amp;gt; b&lt;/code&gt; se traduce en &lt;code&gt;b &amp;lt; a&lt;/code&gt; y &lt;code&gt;a &amp;gt;= b&lt;/code&gt; se traduce en &lt;code&gt;b &amp;lt;= a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16d32560c1bc7362c02c6c6224e74a5d3dda3efc" translate="yes" xml:space="preserve">
          <source>The order operators work as follows. If both arguments are numbers, then they are compared according to their mathematical values, regardless of their subtypes. Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the &lt;code&gt;__lt&lt;/code&gt; or the &lt;code&gt;__le&lt;/code&gt; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). A comparison &lt;code&gt;a &amp;gt; b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt; a&lt;/code&gt; and &lt;code&gt;a &amp;gt;= b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt;= a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0cda038c86954689aa106e41f099cb177ac64c" translate="yes" xml:space="preserve">
          <source>The package library provides basic facilities for loading modules in Lua. It exports one function directly in the global environment: &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;. Everything else is exported in a table &lt;a id=&quot;pdf-package&quot;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La biblioteca de paquetes proporciona instalaciones b&amp;aacute;sicas para cargar m&amp;oacute;dulos en Lua. Exporta una funci&amp;oacute;n directamente en el entorno global: &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; . Todo lo dem&amp;aacute;s se exporta en un &lt;a id=&quot;pdf-package&quot;&gt; &lt;code&gt;package&lt;/code&gt; &lt;/a&gt; tabla .</target>
        </trans-unit>
        <trans-unit id="fa03a4bf443ac88c87678b3c72b93c4aa7015676" translate="yes" xml:space="preserve">
          <source>The package library provides basic facilities for loading modules in Lua. It exports one function directly in the global environment: &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;. Everything else is exported in the table &lt;a id=&quot;pdf-package&quot;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31abba930e733e4da53e00b6f03a89251bd121d5" translate="yes" xml:space="preserve">
          <source>The panic function runs as if it were a message handler (see &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;); in particular, the error object is at the top of the stack. However, there is no guarantee about stack space. To push anything on the stack, the panic function must first check the available space (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;).</source>
          <target state="translated">La funci&amp;oacute;n de p&amp;aacute;nico se ejecuta como si fuera un gestor de mensajes (ver &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt; ); en particular, el objeto de error est&amp;aacute; en la parte superior de la pila. Sin embargo, no hay garant&amp;iacute;a sobre el espacio de la pila. Para empujar algo en la pila, la funci&amp;oacute;n de p&amp;aacute;nico primero debe verificar el espacio disponible (ver &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b28207f33d009ff23a6c3b0471b814b49c1801a0" translate="yes" xml:space="preserve">
          <source>The panic function runs as if it were a message handler (see &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;); in particular, the error object is on the top of the stack. However, there is no guarantee about stack space. To push anything on the stack, the panic function must first check the available space (see &lt;a href=&quot;#4.1.1&quot;&gt;&amp;sect;4.1.1&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248c6c24d6328dcec1eced4a5902bd1ca25c30a6" translate="yes" xml:space="preserve">
          <source>The panic function, as its name implies, is a mechanism of last resort. Programs should avoid it. As a general rule, when a C function is called by Lua with a Lua state, it can do whatever it wants on that Lua state, as it should be already protected. However, when C code operates on other Lua states (e.g., a Lua parameter to the function, a Lua state stored in the registry, or the result of &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;), it should use them only in API calls that cannot raise errors.</source>
          <target state="translated">La funci&amp;oacute;n de p&amp;aacute;nico, como su nombre lo indica, es un mecanismo de &amp;uacute;ltimo recurso. Los programas deber&amp;iacute;an evitarlo. Como regla general, cuando Lua llama a una funci&amp;oacute;n C con un estado Lua, puede hacer lo que quiera en ese estado Lua, ya que ya deber&amp;iacute;a estar protegida. Sin embargo, cuando el c&amp;oacute;digo C opera en otros estados de Lua (por ejemplo, un par&amp;aacute;metro de Lua para la funci&amp;oacute;n, un estado de Lua almacenado en el registro o el resultado de &lt;a href=&quot;#lua_newthread&quot;&gt; &lt;code&gt;lua_newthread&lt;/code&gt; &lt;/a&gt; ), debe usarlos solo en llamadas API que no pueden generar errores.</target>
        </trans-unit>
        <trans-unit id="7cd9dea0b0f86a65a80b1cdf11372d51ac94ffd8" translate="yes" xml:space="preserve">
          <source>The panic function, as its name implies, is a mechanism of last resort. Programs should avoid it. As a general rule, when a C function is called by Lua with a Lua state, it can do whatever it wants on that Lua state, as it should be already protected. However, when C code operates on other Lua states (e.g., a Lua-state argument to the function, a Lua state stored in the registry, or the result of &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;), it should use them only in API calls that cannot raise errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1c6d6c99e2e0d628fe3fc7ee1c5062d171bd6d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;f&lt;/code&gt; may also be a function. In that case, &lt;code&gt;getlocal&lt;/code&gt; returns only the name of function parameters.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;f&lt;/code&gt; tambi&amp;eacute;n puede ser una funci&amp;oacute;n. En ese caso, &lt;code&gt;getlocal&lt;/code&gt; devuelve solo el nombre de los par&amp;aacute;metros de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2ee0f1d943cdb63fea614a28b80243ba707db6c6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;from&lt;/code&gt; represents the coroutine that is resuming &lt;code&gt;L&lt;/code&gt;. If there is no such coroutine, this parameter can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;from&lt;/code&gt; representa la co-rutina que est&amp;aacute; reanudando &lt;code&gt;L&lt;/code&gt; . Si no existe tal co-rutina, este par&amp;aacute;metro puede ser &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65650656d52c148c40e15fc089970d7544c3c111" translate="yes" xml:space="preserve">
          <source>The path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a C loader.</source>
          <target state="translated">La ruta utilizada por &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; para buscar un cargador C.</target>
        </trans-unit>
        <trans-unit id="a62c3b69148e7d0643526b28757764d931f17eab" translate="yes" xml:space="preserve">
          <source>The path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a Lua loader.</source>
          <target state="translated">La ruta utilizada por &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; para buscar un cargador Lua.</target>
        </trans-unit>
        <trans-unit id="c5695907c31c4cdbe5adbf65f538570d9f4bbc4f" translate="yes" xml:space="preserve">
          <source>The pattern (a string, not a function) &quot;&lt;code&gt;[\0-\x7F\xC2-\xF4][\x80-\xBF]*&lt;/code&gt;&quot; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;), which matches exactly one UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string.</source>
          <target state="translated">El patr&amp;oacute;n (una cadena, no una funci&amp;oacute;n) &quot; &lt;code&gt;[\0-\x7F\xC2-\xF4][\x80-\xBF]*&lt;/code&gt; &quot; (ver &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; ), que coincide exactamente con una secuencia de bytes UTF-8, asumiendo que el sujeto es una cadena UTF-8 v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="44576e42d538a0d4f15232ab1f12c35467c5f2ae" translate="yes" xml:space="preserve">
          <source>The pattern (a string, not a function) &quot;&lt;code&gt;[\0-\x7F\xC2-\xFD][\x80-\xBF]*&lt;/code&gt;&quot; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;), which matches exactly one UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87cd937e99e46145262ab909bbf52a9d51f4acf0" translate="yes" xml:space="preserve">
          <source>The pseudo-random number generator used by the function &lt;a href=&quot;#pdf-math.random&quot;&gt;&lt;code&gt;math.random&lt;/code&gt;&lt;/a&gt; now starts with a somewhat random seed. Moreover, it uses a different algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4807ffe56b89f96d5345484b52e6277f351113a1" translate="yes" xml:space="preserve">
          <source>The reader function used by &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. Every time &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; needs another piece of the chunk, it calls the reader, passing along its &lt;code&gt;data&lt;/code&gt; parameter. The reader must return a pointer to a block of memory with a new piece of the chunk and set &lt;code&gt;size&lt;/code&gt; to the block size. The block must exist until the reader function is called again. To signal the end of the chunk, the reader must return &lt;code&gt;NULL&lt;/code&gt; or set &lt;code&gt;size&lt;/code&gt; to zero. The reader function may return pieces of any size greater than zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94196df3b0309cd7d7af8dbae4fe9b55da3dd1ee" translate="yes" xml:space="preserve">
          <source>The reader function used by &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. Every time it needs another piece of the chunk, &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; calls the reader, passing along its &lt;code&gt;data&lt;/code&gt; parameter. The reader must return a pointer to a block of memory with a new piece of the chunk and set &lt;code&gt;size&lt;/code&gt; to the block size. The block must exist until the reader function is called again. To signal the end of the chunk, the reader must return &lt;code&gt;NULL&lt;/code&gt; or set &lt;code&gt;size&lt;/code&gt; to zero. The reader function may return pieces of any size greater than zero.</source>
          <target state="translated">La funci&amp;oacute;n de lectura utilizada por &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; . Cada vez que necesita otra parte del fragmento, &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; llama al lector y le pasa su par&amp;aacute;metro de &lt;code&gt;data&lt;/code&gt; . El lector debe devolver un puntero a un bloque de memoria con una nueva parte del fragmento y establecer el &lt;code&gt;size&lt;/code&gt; del bloque. El bloque debe existir hasta que se vuelva a llamar a la funci&amp;oacute;n de lector. Para se&amp;ntilde;alar el final del fragmento, el lector debe devolver &lt;code&gt;NULL&lt;/code&gt; o establecer el &lt;code&gt;size&lt;/code&gt; en cero. La funci&amp;oacute;n de lector puede devolver piezas de cualquier tama&amp;ntilde;o mayor que cero.</target>
        </trans-unit>
        <trans-unit id="37f620be9ce9c46f8c6dc3707673277eb2ba004c" translate="yes" xml:space="preserve">
          <source>The return values of &lt;code&gt;lua_load&lt;/code&gt; are:</source>
          <target state="translated">Los valores de retorno de &lt;code&gt;lua_load&lt;/code&gt; son:</target>
        </trans-unit>
        <trans-unit id="2b6bd9b2d65f7c99bb3fd044a11a11e501baf7b6" translate="yes" xml:space="preserve">
          <source>The returned table can contain all the fields returned by &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;, with the string &lt;code&gt;what&lt;/code&gt; describing which fields to fill in. The default for &lt;code&gt;what&lt;/code&gt; is to get all information available, except the table of valid lines. If present, the option '&lt;code&gt;f&lt;/code&gt;' adds a field named &lt;code&gt;func&lt;/code&gt; with the function itself. If present, the option '&lt;code&gt;L&lt;/code&gt;' adds a field named &lt;code&gt;activelines&lt;/code&gt; with the table of valid lines.</source>
          <target state="translated">La tabla devuelta puede contener todos los campos devueltos por &lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; &lt;/a&gt; , con la cadena &lt;code&gt;what&lt;/code&gt; que describe qu&amp;eacute; campos completar. El valor predeterminado para &lt;code&gt;what&lt;/code&gt; es obtener toda la informaci&amp;oacute;n disponible, excepto la tabla de l&amp;iacute;neas v&amp;aacute;lidas. Si est&amp;aacute; presente, la opci&amp;oacute;n ' &lt;code&gt;f&lt;/code&gt; ' agrega un campo llamado &lt;code&gt;func&lt;/code&gt; con la funci&amp;oacute;n en s&amp;iacute;. Si est&amp;aacute; presente, la opci&amp;oacute;n ' &lt;code&gt;L&lt;/code&gt; ' agrega un campo llamado &lt;code&gt;activelines&lt;/code&gt; con la tabla de l&amp;iacute;neas v&amp;aacute;lidas.</target>
        </trans-unit>
        <trans-unit id="f55f8b6574e5379a6bf6381df42f2bd48b5ec87a" translate="yes" xml:space="preserve">
          <source>The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other systems, this number counts the number of seconds since some given start time (the &quot;epoch&quot;). In other systems, the meaning is not specified, and the number returned by &lt;code&gt;time&lt;/code&gt; can be used only as an argument to &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-os.difftime&quot;&gt;&lt;code&gt;os.difftime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El valor devuelto es un n&amp;uacute;mero, cuyo significado depende de su sistema. En POSIX, Windows y algunos otros sistemas, este n&amp;uacute;mero cuenta el n&amp;uacute;mero de segundos desde una hora de inicio determinada (la &quot;&amp;eacute;poca&quot;). En otros sistemas, no se especifica el significado, y el n&amp;uacute;mero devuelto por &lt;code&gt;time&lt;/code&gt; solo se puede usar como argumento para &lt;a href=&quot;#pdf-os.date&quot;&gt; &lt;code&gt;os.date&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#pdf-os.difftime&quot;&gt; &lt;code&gt;os.difftime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfbc7fd540fdc9556b78c0aa760e8e168374c2f5" translate="yes" xml:space="preserve">
          <source>The searcher for C loaders used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; changed the way it handles versioned names. Now, the version should come after the module name (as is usual in most other tools). For compatibility, that searcher still tries the old format if it cannot find an open function according to the new style. (Lua 5.2 already worked that way, but it did not document the change.)</source>
          <target state="translated">El buscador de cargadores C usado por &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; cambi&amp;oacute; la forma en que maneja los nombres versionados. Ahora, la versi&amp;oacute;n deber&amp;iacute;a ir despu&amp;eacute;s del nombre del m&amp;oacute;dulo (como es habitual en la mayor&amp;iacute;a de las otras herramientas). Por compatibilidad, ese buscador a&amp;uacute;n intenta el formato anterior si no puede encontrar una funci&amp;oacute;n abierta de acuerdo con el nuevo estilo. (Lua 5.2 ya funcionaba de esa manera, pero no document&amp;oacute; el cambio).</target>
        </trans-unit>
        <trans-unit id="9d03150830b6678b3746886a32e87ec44fd83128" translate="yes" xml:space="preserve">
          <source>The second and third results come from Lua matching an empty string after '&lt;code&gt;b&lt;/code&gt;' and another one after '&lt;code&gt;c&lt;/code&gt;'. Lua does not match an empty string after '&lt;code&gt;a&lt;/code&gt;', because it would end at the same position of the previous match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15f5fb6601ee9ab09f9a53d09100cffc80fdb3d" translate="yes" xml:space="preserve">
          <source>The second line is the character that separates templates in a path. Default is '&lt;code&gt;;&lt;/code&gt;'.</source>
          <target state="translated">La segunda l&amp;iacute;nea es el car&amp;aacute;cter que separa las plantillas en una ruta. El valor predeterminado es ' &lt;code&gt;;&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="98a2720d48fa26f6e8827171e22966063e194996" translate="yes" xml:space="preserve">
          <source>The second searcher looks for a loader as a Lua library, using the path stored at &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;. The search is done as described in function &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El segundo buscador busca un cargador como una biblioteca Lua, usando la ruta almacenada en &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt; . La b&amp;uacute;squeda se realiza como se describe en la funci&amp;oacute;n &lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="137238d8dbd009a149982e6efcc20bad727cfcef" translate="yes" xml:space="preserve">
          <source>The semantics of the numerical &lt;b&gt;for&lt;/b&gt; loop over integers changed in some details. In particular, the control variable never wraps around.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff10cde6ef36b0ce8ea3feff1924805fea5410a7" translate="yes" xml:space="preserve">
          <source>The sort algorithm is not stable: elements considered equal by the given order may have their relative positions changed by the sort.</source>
          <target state="translated">El algoritmo de clasificación no es estable:los elementos considerados iguales por el orden dado pueden tener sus posiciones relativas cambiadas por la clasificación.</target>
        </trans-unit>
        <trans-unit id="f130a0a60b21f9cce2226de0fac2751f12370d42" translate="yes" xml:space="preserve">
          <source>The specific behavior of each mode is non portable; check the underlying ISO C function &lt;code&gt;setvbuf&lt;/code&gt; in your platform for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a64ebff4c2ef0f4608bbc1604d0fba5b08a8c95" translate="yes" xml:space="preserve">
          <source>The specifier &lt;code&gt;p&lt;/code&gt; formats the pointer returned by &lt;a href=&quot;#lua_topointer&quot;&gt;&lt;code&gt;lua_topointer&lt;/code&gt;&lt;/a&gt;. That gives a unique string identifier for tables, userdata, threads, strings, and functions. For other values (numbers, nil, booleans), this specifier results in a string representing the pointer &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="092e708e29157a676fc8263f0a955c36a4f68199" translate="yes" xml:space="preserve">
          <source>The specifier &lt;code&gt;q&lt;/code&gt; formats booleans, nil, numbers, and strings in a way that the result is a valid constant in Lua source code. Booleans and nil are written in the obvious way (&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt;). Floats are written in hexadecimal, to preserve full precision. A string is written between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e415d3f3923dae036c196db9c13a7408c478cc" translate="yes" xml:space="preserve">
          <source>The specifier &lt;code&gt;s&lt;/code&gt; expects a string; if its argument is not a string, it is converted to one following the same rules of &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;. If the specifier has any modifier, the corresponding string argument should not contain embedded zeros.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5106e7eaf9b7ca3b362e6dc6b36e589c34ea6d05" translate="yes" xml:space="preserve">
          <source>The standard Lua libraries provide useful functions that are implemented directly through the C API. Some of these functions provide essential services to the language (e.g., &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt;); others provide access to &quot;outside&quot; services (e.g., I/O); and others could be implemented in Lua itself, but are quite useful or have critical performance requirements that deserve an implementation in C (e.g., &lt;a href=&quot;#pdf-table.sort&quot;&gt;&lt;code&gt;table.sort&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Las bibliotecas est&amp;aacute;ndar de Lua proporcionan funciones &amp;uacute;tiles que se implementan directamente a trav&amp;eacute;s de la API de C. Algunas de estas funciones proporcionan servicios esenciales al lenguaje (por ejemplo, &lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt; ); otros brindan acceso a servicios &quot;externos&quot; (por ejemplo, E / S); y otros podr&amp;iacute;an implementarse en Lua mismo, pero son bastante &amp;uacute;tiles o tienen requisitos de desempe&amp;ntilde;o cr&amp;iacute;ticos que merecen una implementaci&amp;oacute;n en C (por ejemplo, &lt;a href=&quot;#pdf-table.sort&quot;&gt; &lt;code&gt;table.sort&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4f9a410557c9b2b1485364215e1b8ab3d88af66f" translate="yes" xml:space="preserve">
          <source>The standard Lua libraries provide useful functions that are implemented in C through the C API. Some of these functions provide essential services to the language (e.g., &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt;); others provide access to outside services (e.g., I/O); and others could be implemented in Lua itself, but that for different reasons deserve an implementation in C (e.g., &lt;a href=&quot;#pdf-table.sort&quot;&gt;&lt;code&gt;table.sort&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f42f392bd799378902334c3d54a3414a4cf4d102" translate="yes" xml:space="preserve">
          <source>The standard paths in the official distribution may change between versions.</source>
          <target state="translated">Las vías estándar de la distribución oficial pueden cambiar entre las versiones.</target>
        </trans-unit>
        <trans-unit id="eaeb2de6b243d1a84e816fda80b831d0cddcf07f" translate="yes" xml:space="preserve">
          <source>The standard representation for file handles used by the standard I/O library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7020ccdbf4af39d9ada89f1f68b18c849ca42e" translate="yes" xml:space="preserve">
          <source>The standard representation for file handles, which is used by the standard I/O library.</source>
          <target state="translated">La representación estándar para los manejos de archivos,que es utilizada por la biblioteca de E/S estándar.</target>
        </trans-unit>
        <trans-unit id="9fd3499f821fa1f3548e8129d6b35f2161cdaff1" translate="yes" xml:space="preserve">
          <source>The statement</source>
          <target state="translated">La declaración</target>
        </trans-unit>
        <trans-unit id="b51c68cae2ce99f1a793fe977a6ed087cdabd1ba" translate="yes" xml:space="preserve">
          <source>The status can be 0 (&lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;) for a normal thread, an error code if the thread finished the execution of a &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; with an error, or &lt;a id=&quot;pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the thread is suspended.</source>
          <target state="translated">El estado puede ser 0 ( &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; ) para un hilo normal, un c&amp;oacute;digo de error si el hilo finaliz&amp;oacute; la ejecuci&amp;oacute;n de un &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; con un error o &lt;a id=&quot;pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; si el hilo est&amp;aacute; suspendido.</target>
        </trans-unit>
        <trans-unit id="ba591c4d2347c93e195f1809555bf57c5b0e8a4a" translate="yes" xml:space="preserve">
          <source>The status can be &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; for a normal thread, an error code if the thread finished the execution of a &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; with an error, or &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the thread is suspended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6107c417c0095d03331e66cca35b7fc41f404ee" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; controls whether the chunk can be text or binary (that is, a precompiled chunk). It may be the string &quot;&lt;code&gt;b&lt;/code&gt;&quot; (only binary chunks), &quot;&lt;code&gt;t&lt;/code&gt;&quot; (only text chunks), or &quot;&lt;code&gt;bt&lt;/code&gt;&quot; (both binary and text). The default is &quot;&lt;code&gt;bt&lt;/code&gt;&quot;.</source>
          <target state="translated">El &lt;code&gt;mode&lt;/code&gt; cadena controla si el fragmento puede ser texto o binario (es decir, un fragmento precompilado). Puede ser la cadena &quot; &lt;code&gt;b&lt;/code&gt; &quot; (solo fragmentos binarios), &quot; &lt;code&gt;t&lt;/code&gt; &quot; (solo fragmentos de texto) o &quot; &lt;code&gt;bt&lt;/code&gt; &quot; (tanto binarios como de texto). El valor predeterminado es &quot; &lt;code&gt;bt&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="eb61b3491c7ef29459d2f5f3b4868e8b5f23f56b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El &lt;code&gt;mode&lt;/code&gt; cadena funciona como en la funci&amp;oacute;n &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="beb93a28bba84bfd321ab6652fb3b4fded30346b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; works as in the function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5be0aef9b83b79d571f55826d5a136dfb44d41" translate="yes" xml:space="preserve">
          <source>The string concatenation operator in Lua is denoted by two dots ('&lt;code&gt;..&lt;/code&gt;'). If both operands are strings or numbers, then the numbers are converted to strings in a non-specified format (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;). Otherwise, the &lt;code&gt;__concat&lt;/code&gt; metamethod is called (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8627952ee0ea9e9e84752d1eff85ae25a6b8cff5" translate="yes" xml:space="preserve">
          <source>The string concatenation operator in Lua is denoted by two dots ('&lt;code&gt;..&lt;/code&gt;'). If both operands are strings or numbers, then they are converted to strings according to the rules described in &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;. Otherwise, the &lt;code&gt;__concat&lt;/code&gt; metamethod is called (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">El operador de concatenaci&amp;oacute;n de cadenas en Lua se indica con dos puntos (' &lt;code&gt;..&lt;/code&gt; '). Si ambos operandos son cadenas o n&amp;uacute;meros, entonces se convierten en cadenas de acuerdo con las reglas descritas en &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; . De lo contrario, se llama al &lt;code&gt;__concat&lt;/code&gt; __concat (consulte &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9045fd903c161a4ac7a29583b9b8dcf0e5541479" translate="yes" xml:space="preserve">
          <source>The string library assumes one-byte character encodings.</source>
          <target state="translated">La biblioteca de cadenas asume codificaciones de caracteres de un byte.</target>
        </trans-unit>
        <trans-unit id="b2b7ec0f9126a815843a8b6eedc7a7a4064d3eb8" translate="yes" xml:space="preserve">
          <source>The string library provides all its functions inside the table &lt;a id=&quot;pdf-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. It also sets a metatable for strings where the &lt;code&gt;__index&lt;/code&gt; field points to the &lt;code&gt;string&lt;/code&gt; table. Therefore, you can use the string functions in object-oriented style. For instance, &lt;code&gt;string.byte(s,i)&lt;/code&gt; can be written as &lt;code&gt;s:byte(i)&lt;/code&gt;.</source>
          <target state="translated">La biblioteca de cadenas proporciona todas sus funciones dentro de la &lt;a id=&quot;pdf-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; la tabla . Tambi&amp;eacute;n establece una metatabla para cadenas donde el campo &lt;code&gt;__index&lt;/code&gt; apunta a la tabla de &lt;code&gt;string&lt;/code&gt; . Por lo tanto, puede utilizar las funciones de cadena en estilo orientado a objetos. Por ejemplo, &lt;code&gt;string.byte(s,i)&lt;/code&gt; se puede escribir como &lt;code&gt;s:byte(i)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10a50517543fae51ebb08fb2ec16c2bc73963b6e" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;var.Name&lt;/code&gt; is just syntactic sugar for &lt;code&gt;var[&quot;Name&quot;]&lt;/code&gt;:</source>
          <target state="translated">La sintaxis &lt;code&gt;var.Name&lt;/code&gt; es simplemente az&amp;uacute;car sint&amp;aacute;ctica para &lt;code&gt;var[&quot;Name&quot;]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="050ff8b5782f01590c86d4091d6bf58f847c8377" translate="yes" xml:space="preserve">
          <source>The syntax for function definition is</source>
          <target state="translated">La sintaxis para la definición de la función es</target>
        </trans-unit>
        <trans-unit id="632eb45dbc253afb0e4d9a6d182579e0f0a1fc32" translate="yes" xml:space="preserve">
          <source>The table &lt;code&gt;io&lt;/code&gt; also provides three predefined file handles with their usual meanings from C: &lt;a id=&quot;pdf-io.stdin&quot;&gt;&lt;code&gt;io.stdin&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-io.stdout&quot;&gt;&lt;code&gt;io.stdout&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-io.stderr&quot;&gt;&lt;code&gt;io.stderr&lt;/code&gt;&lt;/a&gt;. The I/O library never closes these files.</source>
          <target state="translated">La tabla &lt;code&gt;io&lt;/code&gt; tambi&amp;eacute;n proporciona tres identificadores de archivo predefinidos con sus significados habituales de C: &lt;a id=&quot;pdf-io.stdin&quot;&gt; &lt;code&gt;io.stdin&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-io.stdout&quot;&gt; &lt;code&gt;io.stdout&lt;/code&gt; &lt;/a&gt; y &lt;a id=&quot;pdf-io.stderr&quot;&gt; &lt;code&gt;io.stderr&lt;/code&gt; &lt;/a&gt; . La biblioteca de E / S nunca cierra estos archivos.</target>
        </trans-unit>
        <trans-unit id="a5bb6863eedf039eb3411f3dbe0637455e54c4cb" translate="yes" xml:space="preserve">
          <source>The third line is the string that marks the substitution points in a template. Default is '&lt;code&gt;?&lt;/code&gt;'.</source>
          <target state="translated">La tercera l&amp;iacute;nea es la cadena que marca los puntos de sustituci&amp;oacute;n en una plantilla. El valor predeterminado es ' &lt;code&gt;?&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="2123107d9c2b8fa74113fcb8969ea618ea87943f" translate="yes" xml:space="preserve">
          <source>The third searcher looks for a loader as a C library, using the path given by the variable &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt;. Again, the search is done as described in function &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;. For instance, if the C path is the string</source>
          <target state="translated">El tercer buscador busca un cargador como una biblioteca C, usando la ruta dada por la variable &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt; . Nuevamente, la b&amp;uacute;squeda se realiza como se describe en la funci&amp;oacute;n &lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; &lt;/a&gt; . Por ejemplo, si la ruta C es la cadena</target>
        </trans-unit>
        <trans-unit id="addd796f69c05ccc4f282e63f096edaf0f445ae8" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;number&lt;/em&gt; represents both integer numbers and real (floating-point) numbers, using two subtypes: &lt;em&gt;integer&lt;/em&gt; and &lt;em&gt;float&lt;/em&gt;. Standard Lua uses 64-bit integers and double-precision (64-bit) floats, but you can also compile Lua so that it uses 32-bit integers and/or single-precision (32-bit) floats. The option with 32 bits for both integers and floats is particularly attractive for small machines and embedded systems. (See macro &lt;code&gt;LUA_32BITS&lt;/code&gt; in file &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8accc1fdc3658380909273543cc837dcd9d22775" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;number&lt;/em&gt; uses two internal representations, or two subtypes, one called &lt;em&gt;integer&lt;/em&gt; and the other called &lt;em&gt;float&lt;/em&gt;. Lua has explicit rules about when each representation is used, but it also converts between them automatically as needed (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;). Therefore, the programmer may choose to mostly ignore the difference between integers and floats or to assume complete control over the representation of each number. Standard Lua uses 64-bit integers and double-precision (64-bit) floats, but you can also compile Lua so that it uses 32-bit integers and/or single-precision (32-bit) floats. The option with 32 bits for both integers and floats is particularly attractive for small machines and embedded systems. (See macro &lt;code&gt;LUA_32BITS&lt;/code&gt; in file &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">El &lt;em&gt;n&amp;uacute;mero de&lt;/em&gt; tipo usa dos representaciones internas, o dos subtipos, uno llamado &lt;em&gt;entero&lt;/em&gt; y el otro llamado &lt;em&gt;flotante&lt;/em&gt; . Lua tiene reglas expl&amp;iacute;citas sobre cu&amp;aacute;ndo se usa cada representaci&amp;oacute;n, pero tambi&amp;eacute;n convierte entre ellas autom&amp;aacute;ticamente seg&amp;uacute;n sea necesario (ver &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; ). Por lo tanto, el programador puede optar por ignorar la diferencia entre enteros y flotantes o asumir el control completo sobre la representaci&amp;oacute;n de cada n&amp;uacute;mero. Lua est&amp;aacute;ndar usa n&amp;uacute;meros enteros de 64 bits y flotantes de doble precisi&amp;oacute;n (64 bits), pero tambi&amp;eacute;n puede compilar Lua para que use n&amp;uacute;meros enteros de 32 bits y / o flotantes de precisi&amp;oacute;n simple (32 bits). La opci&amp;oacute;n con 32 bits para enteros y flotantes es particularmente atractiva para m&amp;aacute;quinas peque&amp;ntilde;as y sistemas integrados. (Ver macro &lt;code&gt;LUA_32BITS&lt;/code&gt; en el archivo &lt;code&gt;luaconf.h&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="c9782558cfd51d05e29ec07247ff6f0f3156a12c" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;string&lt;/em&gt; represents immutable sequences of bytes. Lua is 8-bit clean: strings can contain any 8-bit value, including embedded zeros ('&lt;code&gt;\0&lt;/code&gt;'). Lua is also encoding-agnostic; it makes no assumptions about the contents of a string. The length of any string in Lua must fit in a Lua integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb6b5b3a4f6e457499e2efa89d3127e8a5239e3" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;table&lt;/em&gt; implements associative arrays, that is, arrays that can be indexed not only with numbers, but with any Lua value except &lt;b&gt;nil&lt;/b&gt; and NaN. (&lt;em&gt;Not a Number&lt;/em&gt; is a special value used to represent undefined or unrepresentable numerical results, such as &lt;code&gt;0/0&lt;/code&gt;.) Tables can be &lt;em&gt;heterogeneous&lt;/em&gt;; that is, they can contain values of all types (except &lt;b&gt;nil&lt;/b&gt;). Any key with value &lt;b&gt;nil&lt;/b&gt; is not considered part of the table. Conversely, any key that is not part of a table has an associated value &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">La &lt;em&gt;tabla de&lt;/em&gt; tipos implementa matrices asociativas, es decir, matrices que pueden indexarse ​​no solo con n&amp;uacute;meros, sino con cualquier valor Lua excepto &lt;b&gt;nil&lt;/b&gt; y NaN. ( &lt;em&gt;No es un n&amp;uacute;mero&lt;/em&gt; es un valor especial que se utiliza para representar resultados num&amp;eacute;ricos no definidos o no representables, como &lt;code&gt;0/0&lt;/code&gt; ). Las tablas pueden ser &lt;em&gt;heterog&amp;eacute;neas&lt;/em&gt; ; es decir, pueden contener valores de todos los tipos (excepto &lt;b&gt;nil&lt;/b&gt; ). Cualquier clave con valor &lt;b&gt;nulo&lt;/b&gt; no se considera parte de la tabla. Por el contrario, cualquier clave que no forme parte de una tabla tiene un valor asociado &lt;b&gt;nulo&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="30d0477a11463f9ad22a4a02ea0328499a10323e" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;table&lt;/em&gt; implements associative arrays, that is, arrays that can have as indices not only numbers, but any Lua value except &lt;b&gt;nil&lt;/b&gt; and NaN. (&lt;em&gt;Not a Number&lt;/em&gt; is a special floating-point value used by the IEEE 754 standard to represent undefined numerical results, such as &lt;code&gt;0/0&lt;/code&gt;.) Tables can be &lt;em&gt;heterogeneous&lt;/em&gt;; that is, they can contain values of all types (except &lt;b&gt;nil&lt;/b&gt;). Any key associated to the value &lt;b&gt;nil&lt;/b&gt; is not considered part of the table. Conversely, any key that is not part of a table has an associated value &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9440269930bed052fd86cfbac01a1a963271db" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;thread&lt;/em&gt; represents independent threads of execution and it is used to implement coroutines (see &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt;). Lua threads are not related to operating-system threads. Lua supports coroutines on all systems, even those that do not support threads natively.</source>
          <target state="translated">El tipo &lt;em&gt;hilo&lt;/em&gt; representa hilos de ejecuci&amp;oacute;n independientes y se utiliza para implementar corrutinas (ver &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt; ). Los hilos de Lua no est&amp;aacute;n relacionados con los hilos del sistema operativo. Lua admite corrutinas en todos los sistemas, incluso en aquellos que no admiten subprocesos de forma nativa.</target>
        </trans-unit>
        <trans-unit id="8121e5be3e303e17463413ad6f8abdbed524db9a" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;userdata&lt;/em&gt; is provided to allow arbitrary C data to be stored in Lua variables. A userdata value represents a block of raw memory. There are two kinds of userdata: &lt;em&gt;full userdata&lt;/em&gt;, which is an object with a block of memory managed by Lua, and &lt;em&gt;light userdata&lt;/em&gt;, which is simply a C pointer value. Userdata has no predefined operations in Lua, except assignment and identity test. By using &lt;em&gt;metatables&lt;/em&gt;, the programmer can define operations for full userdata values (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). Userdata values cannot be created or modified in Lua, only through the C API. This guarantees the integrity of data owned by the host program and C libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549971961a231ddc4a1edb8a913953e6d0ac1c5d" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;userdata&lt;/em&gt; is provided to allow arbitrary C data to be stored in Lua variables. A userdata value represents a block of raw memory. There are two kinds of userdata: &lt;em&gt;full userdata&lt;/em&gt;, which is an object with a block of memory managed by Lua, and &lt;em&gt;light userdata&lt;/em&gt;, which is simply a C pointer value. Userdata has no predefined operations in Lua, except assignment and identity test. By using &lt;em&gt;metatables&lt;/em&gt;, the programmer can define operations for full userdata values (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). Userdata values cannot be created or modified in Lua, only through the C API. This guarantees the integrity of data owned by the host program.</source>
          <target state="translated">El tipo &lt;em&gt;userdata&lt;/em&gt; se proporciona para permitir que se almacenen datos C arbitrarios en variables Lua. Un valor de datos de usuario representa un bloque de memoria bruta. Hay dos tipos de datos de usuario: datos de usuario &lt;em&gt;completos&lt;/em&gt; , que son un objeto con un bloque de memoria administrado por Lua, y datos de &lt;em&gt;usuarios ligeros&lt;/em&gt; , que son simplemente un valor de puntero C. Userdata no tiene operaciones predefinidas en Lua, excepto la asignaci&amp;oacute;n y la prueba de identidad. Al usar &lt;em&gt;metatablas&lt;/em&gt; , el programador puede definir operaciones para valores completos de datos de usuario (ver &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ). Los valores de datos de usuario no se pueden crear ni modificar en Lua, solo a trav&amp;eacute;s de la API de C. Esto garantiza la integridad de los datos que pertenecen al programa anfitri&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cb2dae663cd0b88537f77f62b52ecd0fdceb5eb7" translate="yes" xml:space="preserve">
          <source>The type for continuation-function contexts. It must be a numeric type. This type is defined as &lt;code&gt;intptr_t&lt;/code&gt; when &lt;code&gt;intptr_t&lt;/code&gt; is available, so that it can store pointers too. Otherwise, it is defined as &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">El tipo para contextos de funci&amp;oacute;n de continuaci&amp;oacute;n. Debe ser de tipo num&amp;eacute;rico. Este tipo se define como &lt;code&gt;intptr_t&lt;/code&gt; cuando &lt;code&gt;intptr_t&lt;/code&gt; est&amp;aacute; disponible, de modo que tambi&amp;eacute;n puede almacenar punteros. De lo contrario, se define como &lt;code&gt;ptrdiff_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b81ea3cf634f923ceea25ead913b80cfce712bbf" translate="yes" xml:space="preserve">
          <source>The type of floats in Lua.</source>
          <target state="translated">El tipo de carrozas en Lua.</target>
        </trans-unit>
        <trans-unit id="7bd0bf99561dfbd918dc1bdb99594d59c184307f" translate="yes" xml:space="preserve">
          <source>The type of integers in Lua.</source>
          <target state="translated">El tipo de números enteros en Lua.</target>
        </trans-unit>
        <trans-unit id="f3373938fcc3069867ceda08c5889260b4eb48bd" translate="yes" xml:space="preserve">
          <source>The type of the memory-allocation function used by Lua states. The allocator function must provide a functionality similar to &lt;code&gt;realloc&lt;/code&gt;, but not exactly the same. Its arguments are &lt;code&gt;ud&lt;/code&gt;, an opaque pointer passed to &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;ptr&lt;/code&gt;, a pointer to the block being allocated/reallocated/freed; &lt;code&gt;osize&lt;/code&gt;, the original size of the block or some code about what is being allocated; and &lt;code&gt;nsize&lt;/code&gt;, the new size of the block.</source>
          <target state="translated">El tipo de funci&amp;oacute;n de asignaci&amp;oacute;n de memoria utilizada por los estados de Lua. La funci&amp;oacute;n de &lt;code&gt;realloc&lt;/code&gt; debe proporcionar una funcionalidad similar a la de reasignaci&amp;oacute;n , pero no exactamente igual. Sus argumentos son &lt;code&gt;ud&lt;/code&gt; , un puntero opaco que se pasa a &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; &lt;/a&gt; ; &lt;code&gt;ptr&lt;/code&gt; , un puntero al bloque que se asigna / reasigna / libera; &lt;code&gt;osize&lt;/code&gt; , el tama&amp;ntilde;o original del bloque o alg&amp;uacute;n c&amp;oacute;digo sobre lo que se est&amp;aacute; asignando; y &lt;code&gt;nsize&lt;/code&gt; , el nuevo tama&amp;ntilde;o del bloque.</target>
        </trans-unit>
        <trans-unit id="1df269fdb1511aeac5ae2230ae20c7d3efe5a527" translate="yes" xml:space="preserve">
          <source>The type of the writer function used by &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;. Every time &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; produces another piece of chunk, it calls the writer, passing along the buffer to be written (&lt;code&gt;p&lt;/code&gt;), its size (&lt;code&gt;sz&lt;/code&gt;), and the &lt;code&gt;ud&lt;/code&gt; parameter supplied to &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2467b4ef42d2fed95d1a97e4a127587c63bf40" translate="yes" xml:space="preserve">
          <source>The type of the writer function used by &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;. Every time it produces another piece of chunk, &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; calls the writer, passing along the buffer to be written (&lt;code&gt;p&lt;/code&gt;), its size (&lt;code&gt;sz&lt;/code&gt;), and the &lt;code&gt;data&lt;/code&gt; parameter supplied to &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El tipo de funci&amp;oacute;n de &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; utilizada por lua_dump . Cada vez que produce otro fragmento de fragmento, &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; llama al escritor, pasando el b&amp;uacute;fer a escribir ( &lt;code&gt;p&lt;/code&gt; ), su tama&amp;ntilde;o ( &lt;code&gt;sz&lt;/code&gt; ) y el par&amp;aacute;metro de &lt;code&gt;data&lt;/code&gt; proporcionado a &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d018270dc227693da93d9f0a8f9276ac74a821c3" translate="yes" xml:space="preserve">
          <source>The type of warning functions, called by Lua to emit warnings. The first parameter is an opaque pointer set by &lt;a href=&quot;#lua_setwarnf&quot;&gt;&lt;code&gt;lua_setwarnf&lt;/code&gt;&lt;/a&gt;. The second parameter is the warning message. The third parameter is a boolean that indicates whether the message is to be continued by the message in the next call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979b7ad2557665ac8c789bc0692eee0412bef53c" translate="yes" xml:space="preserve">
          <source>The unit of compilation of Lua is called a &lt;em&gt;chunk&lt;/em&gt;. Syntactically, a chunk is simply a block:</source>
          <target state="translated">La unidad de compilaci&amp;oacute;n de Lua se llama &lt;em&gt;chunk&lt;/em&gt; . Sint&amp;aacute;cticamente, un fragmento es simplemente un bloque:</target>
        </trans-unit>
        <trans-unit id="1fd90de9694cbc90328b75bdffaf97623ca0a9b7" translate="yes" xml:space="preserve">
          <source>The unsigned version of &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La versi&amp;oacute;n sin firmar de &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f42098ee42cafd687bbe509745646e96e9e3b55" translate="yes" xml:space="preserve">
          <source>The use of the &lt;code&gt;__lt&lt;/code&gt; metamethod to emulate &lt;code&gt;__le&lt;/code&gt; has been removed. When needed, this metamethod must be explicitly defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee895c6fec2956941edfd9074d2ad8c6a07996da" translate="yes" xml:space="preserve">
          <source>The value assigned to a to-be-closed variable must have a &lt;code&gt;__close&lt;/code&gt; metamethod or be a false value. (&lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; are ignored as to-be-closed values.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5edb4c646d2befa84cf3aa4de94da00e72b361" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;op&lt;/code&gt; must be one of the following constants:</source>
          <target state="translated">El valor de &lt;code&gt;op&lt;/code&gt; debe ser una de las siguientes constantes:</target>
        </trans-unit>
        <trans-unit id="afade59d4e86a697bf216612fdf19b790b49ed5e" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;&amp;pi;&lt;/em&gt;.</source>
          <target state="translated">El valor de &lt;em&gt;&amp;pi;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9dc3bab908539601286c9612ae1893b48ba8219b" translate="yes" xml:space="preserve">
          <source>The value returned is the error code returned by the last call to the writer; 0 means no errors.</source>
          <target state="translated">El valor devuelto es el código de error devuelto por la última llamada al escritor;0 significa que no hay errores.</target>
        </trans-unit>
        <trans-unit id="112b2baa6655f11d826fd17791c335badbd32d34" translate="yes" xml:space="preserve">
          <source>The values in these fields do not need to be inside their valid ranges. For instance, if &lt;code&gt;sec&lt;/code&gt; is -10, it means -10 seconds from the time specified by the other fields; if &lt;code&gt;hour&lt;/code&gt; is 1000, it means +1000 hours from the time specified by the other fields.</source>
          <target state="translated">No es necesario que los valores de estos campos est&amp;eacute;n dentro de sus rangos v&amp;aacute;lidos. Por ejemplo, si &lt;code&gt;sec&lt;/code&gt; es -10, significa -10 segundos desde el tiempo especificado por los otros campos; si la &lt;code&gt;hour&lt;/code&gt; es 1000, significa +1000 horas a partir de la hora especificada por los otros campos.</target>
        </trans-unit>
        <trans-unit id="a99a66eb862f6556290fc79e5e1c7450f919252a" translate="yes" xml:space="preserve">
          <source>The visibility rules for local variables are explained in &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;.</source>
          <target state="translated">Las reglas de visibilidad para las variables locales se explican en &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1638bbae2e91cad1bcbf2314b579efab5e69fee7" translate="yes" xml:space="preserve">
          <source>The writer returns an error code: 0 means no errors; any other value means an error and stops &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; from calling the writer again.</source>
          <target state="translated">El escritor devuelve un c&amp;oacute;digo de error: 0 significa que no hay errores; cualquier otro valor significa un error y evita que &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; vuelva&lt;/a&gt; a llamar al escritor.</target>
        </trans-unit>
        <trans-unit id="e53998e37ed2ba9b38d4b4c370361cd1f8e85f86" translate="yes" xml:space="preserve">
          <source>Then add string pieces to the buffer calling any of the &lt;code&gt;luaL_add*&lt;/code&gt; functions.</source>
          <target state="translated">Luego agregue piezas de cadena al b&amp;uacute;fer llamando a cualquiera de las funciones &lt;code&gt;luaL_add*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58d5ea479608da6d358fd4117e4c1650306f8953" translate="yes" xml:space="preserve">
          <source>Then copy the string into that space.</source>
          <target state="translated">Entonces copie la cuerda en ese espacio.</target>
        </trans-unit>
        <trans-unit id="c38aad0ad68cbec114bc022549a75392e5ff942b" translate="yes" xml:space="preserve">
          <source>Then initialize it and preallocate a space of size &lt;code&gt;sz&lt;/code&gt; with a call &lt;code&gt;luaL_buffinitsize(L, &amp;amp;b, sz)&lt;/code&gt;.</source>
          <target state="translated">Luego, inicial&amp;iacute;celo y preasigne un espacio de tama&amp;ntilde;o &lt;code&gt;sz&lt;/code&gt; con una llamada &lt;code&gt;luaL_buffinitsize(L, &amp;amp;b, sz)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fde5c748e0c5d875fb24467538da27e6356bfa2" translate="yes" xml:space="preserve">
          <source>Then initialize it with a call &lt;code&gt;luaL_buffinit(L, &amp;amp;b)&lt;/code&gt;.</source>
          <target state="translated">Luego &lt;code&gt;luaL_buffinit(L, &amp;amp;b)&lt;/code&gt; con una llamada luaL_buffinit (L, &amp;amp; b) .</target>
        </trans-unit>
        <trans-unit id="4a6ac0ddbec77a0c5d75add2623e877e243218e1" translate="yes" xml:space="preserve">
          <source>Then produce the string into that space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20602b0df785d59b7a2fc157ec725f513e02a1fe" translate="yes" xml:space="preserve">
          <source>Then, at each iteration, Lua calls the iterator function with two arguments: the state and the control variable. The results from this call are then assigned to the loop variables, following the rules of multiple assignments (see &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;). If the control variable becomes &lt;b&gt;nil&lt;/b&gt;, the loop terminates. Otherwise, the body is executed and the loop goes to the next iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c089f6502b4ba313710d9bbf20645416ed3a409" translate="yes" xml:space="preserve">
          <source>Then, we have the following mapping from arguments to parameters and to the vararg expression:</source>
          <target state="translated">Entonces,tenemos el siguiente mapeo de los argumentos a los parámetros y a la expresión vararg:</target>
        </trans-unit>
        <trans-unit id="589d73d8b2db93fee46410c9d04b6ddf513bc616" translate="yes" xml:space="preserve">
          <source>There are eight basic types in Lua: &lt;em&gt;nil&lt;/em&gt;, &lt;em&gt;boolean&lt;/em&gt;, &lt;em&gt;number&lt;/em&gt;, &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;function&lt;/em&gt;, &lt;em&gt;userdata&lt;/em&gt;, &lt;em&gt;thread&lt;/em&gt;, and &lt;em&gt;table&lt;/em&gt;. The type &lt;em&gt;nil&lt;/em&gt; has one single value, &lt;b&gt;nil&lt;/b&gt;, whose main property is to be different from any other value; it often represents the absence of a useful value. The type &lt;em&gt;boolean&lt;/em&gt; has two values, &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;true&lt;/b&gt;. Both &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; make a condition false; they are collectively called &lt;em&gt;false values&lt;/em&gt;. Any other value makes a condition true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f15568d44d3dd2fb189f12b0a139775af30148" translate="yes" xml:space="preserve">
          <source>There are eight basic types in Lua: &lt;em&gt;nil&lt;/em&gt;, &lt;em&gt;boolean&lt;/em&gt;, &lt;em&gt;number&lt;/em&gt;, &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;function&lt;/em&gt;, &lt;em&gt;userdata&lt;/em&gt;, &lt;em&gt;thread&lt;/em&gt;, and &lt;em&gt;table&lt;/em&gt;. The type &lt;em&gt;nil&lt;/em&gt; has one single value, &lt;b&gt;nil&lt;/b&gt;, whose main property is to be different from any other value; it usually represents the absence of a useful value. The type &lt;em&gt;boolean&lt;/em&gt; has two values, &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;true&lt;/b&gt;. Both &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; make a condition false; any other value makes it true. The type &lt;em&gt;number&lt;/em&gt; represents both integer numbers and real (floating-point) numbers. The type &lt;em&gt;string&lt;/em&gt; represents immutable sequences of bytes. Lua is 8-bit clean: strings can contain any 8-bit value, including embedded zeros ('&lt;code&gt;\0&lt;/code&gt;'). Lua is also encoding-agnostic; it makes no assumptions about the contents of a string.</source>
          <target state="translated">Hay ocho tipos b&amp;aacute;sicos en Lua: &lt;em&gt;nil&lt;/em&gt; , &lt;em&gt;boolean&lt;/em&gt; , &lt;em&gt;number&lt;/em&gt; , &lt;em&gt;string&lt;/em&gt; , &lt;em&gt;function&lt;/em&gt; , &lt;em&gt;userdata&lt;/em&gt; , &lt;em&gt;thread&lt;/em&gt; y &lt;em&gt;table&lt;/em&gt; . El tipo &lt;em&gt;nil&lt;/em&gt; tiene un solo valor, &lt;b&gt;nil&lt;/b&gt; , cuya propiedad principal es ser diferente de cualquier otro valor; generalmente representa la ausencia de un valor &amp;uacute;til. El tipo &lt;em&gt;booleano&lt;/em&gt; tiene dos valores, &lt;b&gt;falso&lt;/b&gt; y &lt;b&gt;verdadero&lt;/b&gt; . Tanto &lt;b&gt;cero&lt;/b&gt; como &lt;b&gt;falso&lt;/b&gt; hacen que una condici&amp;oacute;n sea falsa; cualquier otro valor lo hace verdadero. El &lt;em&gt;n&amp;uacute;mero de&lt;/em&gt; tipo&lt;em&gt;&lt;/em&gt;representa tanto n&amp;uacute;meros enteros como n&amp;uacute;meros reales (de punto flotante). El tipo de &lt;em&gt;cadena&lt;/em&gt; representa secuencias inmutables de bytes. Lua es limpio de 8 bits: las cadenas pueden contener cualquier valor de 8 bits, incluidos ceros incrustados (' &lt;code&gt;\0&lt;/code&gt; '). Lua tambi&amp;eacute;n es independiente de la codificaci&amp;oacute;n; no hace suposiciones sobre el contenido de una cadena.</target>
        </trans-unit>
        <trans-unit id="e4a1ac0a2e0cbd023852a04862ae5b37cf817438" translate="yes" xml:space="preserve">
          <source>There are two possible attributes: &lt;code&gt;const&lt;/code&gt;, which declares a constant variable, that is, a variable that cannot be assigned to after its initialization; and &lt;code&gt;close&lt;/code&gt;, which declares a to-be-closed variable (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;). A list of variables can contain at most one to-be-closed variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a0eb6e93ec0e9480d194fa3833ccbc401284c3" translate="yes" xml:space="preserve">
          <source>There is a system-dependent limit on the number of values that a function may return. This limit is guaranteed to be greater than 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7846fd1d69e8fc588a803bcf086d6b71c1b7e6c8" translate="yes" xml:space="preserve">
          <source>There is a system-dependent limit on the number of values that a function may return. This limit is guaranteed to be larger than 1000.</source>
          <target state="translated">Hay un límite dependiente del sistema en el número de valores que una función puede devolver.Este límite se garantiza que sea mayor de 1000.</target>
        </trans-unit>
        <trans-unit id="190864f70f817fcefb7920da72729737abc80388" translate="yes" xml:space="preserve">
          <source>There is no explicit function to close or to destroy a thread. Threads are subject to garbage collection, like any Lua object.</source>
          <target state="translated">No hay una función explícita para cerrar o destruir un hilo.Los hilos están sujetos a la recolección de basura,como cualquier objeto Lua.</target>
        </trans-unit>
        <trans-unit id="cda37c5365062edc06713b41ab47ba449b3019c1" translate="yes" xml:space="preserve">
          <source>These constants are defined in the header file &lt;code&gt;lua.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33a5b691e1bbd0d76427c85690ea834884923c9e" translate="yes" xml:space="preserve">
          <source>These operators always result in &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">Estos operadores siempre dan como resultado &lt;b&gt;falso&lt;/b&gt; o &lt;b&gt;verdadero&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="23af1fc0e094c2dd4a126a0afba341a0993ddceb" translate="yes" xml:space="preserve">
          <source>These unique identifiers allow a program to check whether different closures share upvalues. Lua closures that share an upvalue (that is, that access a same external local variable) will return identical ids for those upvalue indices.</source>
          <target state="translated">Estos identificadores únicos permiten que un programa compruebe si los diferentes cierres comparten los valores.Los cierres Lua que comparten un upvalue (es decir,que acceden a una misma variable local externa)devolverán idénticos ids para esos índices de upvalue.</target>
        </trans-unit>
        <trans-unit id="fcf0ac285f24f41a8021faef38d1d581f4af95ef" translate="yes" xml:space="preserve">
          <source>This function allocates a new block of memory with the given size, pushes onto the stack a new full userdata with the block address, and returns this address. The host program can freely use this memory.</source>
          <target state="translated">Esta función asigna un nuevo bloque de memoria con el tamaño dado,empuja sobre la pila un nuevo dato de usuario completo con la dirección del bloque,y devuelve esta dirección.El programa anfitrión puede utilizar libremente esta memoria.</target>
        </trans-unit>
        <trans-unit id="80082966d6e2d690085ef70dbe523603499247be" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;level&lt;/code&gt; of the stack. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no local variable with the given index, and raises an error when called with a &lt;code&gt;level&lt;/code&gt; out of range. (You can call &lt;code&gt;getinfo&lt;/code&gt; to check whether the level is valid.) Otherwise, it returns the name of the local variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ee19d0f7467cfbd14cfa290c226be8222d4802" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;level&lt;/code&gt; of the stack. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no local variable with the given index, and raises an error when called with a &lt;code&gt;level&lt;/code&gt; out of range. (You can call &lt;code&gt;getinfo&lt;/code&gt; to check whether the level is valid.) Otherwise, it returns the name of the local variable.</source>
          <target state="translated">Esta funci&amp;oacute;n asigna el valor &lt;code&gt;value&lt;/code&gt; a la variable local con &amp;iacute;ndice &lt;code&gt;local&lt;/code&gt; de la funci&amp;oacute;n a &lt;code&gt;level&lt;/code&gt; de la pila. La funci&amp;oacute;n devuelve &lt;b&gt;nil&lt;/b&gt; si no hay una variable local con el &amp;iacute;ndice dado y genera un error cuando se llama con un &lt;code&gt;level&lt;/code&gt; fuera de rango. (Puede llamar a &lt;code&gt;getinfo&lt;/code&gt; para verificar si el nivel es v&amp;aacute;lido). De lo contrario, devuelve el nombre de la variable local.</target>
        </trans-unit>
        <trans-unit id="d4f42b7d060b48926fc5748edd544aaabb74f7f0" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7496e2514cb1dfc80c2cf0b9e57db48fa2c53f8" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.</source>
          <target state="translated">Esta funci&amp;oacute;n asigna el valor de &lt;code&gt;value&lt;/code&gt; al upvalue con &amp;iacute;ndice &lt;code&gt;up&lt;/code&gt; de la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; . La funci&amp;oacute;n devuelve &lt;b&gt;nil&lt;/b&gt; si no hay ning&amp;uacute;n valor de subida con el &amp;iacute;ndice dado. De lo contrario, devuelve el nombre del upvalue.</target>
        </trans-unit>
        <trans-unit id="ca95f2234def804d470e8cb89141fa32f72381d2" translate="yes" xml:space="preserve">
          <source>This function assumes that &lt;code&gt;s&lt;/code&gt; is a valid UTF-8 string.</source>
          <target state="translated">Esta funci&amp;oacute;n asume que &lt;code&gt;s&lt;/code&gt; es una cadena UTF-8 v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="9890c3cbbc40d1dddc0de99ae46a48146fcb130a" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580c46d5d2b043293bd752a3640317342ee77988" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n se comporta exactamente como &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; , pero permite que la funci&amp;oacute;n llamada ceda (ver &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="228ffaca57d64d62cbfa46f275e2308925e5e66b" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n se comporta exactamente como &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; , pero permite que la funci&amp;oacute;n llamada ceda (ver &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6950878744f6693dff083a31e116fc5f8c212d8b" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, except that it allows the called function to yield (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5d902b412506777fd97b25d07c93121dc8d6e1" translate="yes" xml:space="preserve">
          <source>This function can raise an error if it is called from a thread with a pending C call with no continuation function (what is called a &lt;em&gt;C-call boundary&lt;/em&gt;), or it is called from a thread that is not running inside a resume (typically the main thread).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bff58bee943ec12e3d7290610d93d1b1f73d8e7" translate="yes" xml:space="preserve">
          <source>This function can raise an error if it is called from a thread with a pending C call with no continuation function, or it is called from a thread that is not running inside a resume (e.g., the main thread).</source>
          <target state="translated">Esta función puede dar lugar a un error si se llama desde un hilo con una llamada C pendiente sin función de continuación,o si se llama desde un hilo que no se está ejecutando dentro de un resumen (por ejemplo,el hilo principal).</target>
        </trans-unit>
        <trans-unit id="66854dc63d240dfdfb45adabbcf93e7e8754325d" translate="yes" xml:space="preserve">
          <source>This function creates and pushes on the stack a new full userdata, with &lt;code&gt;nuvalue&lt;/code&gt; associated Lua values, called &lt;code&gt;user values&lt;/code&gt;, plus an associated block of raw memory with &lt;code&gt;size&lt;/code&gt; bytes. (The user values can be set and read with the functions &lt;a href=&quot;#lua_setiuservalue&quot;&gt;&lt;code&gt;lua_setiuservalue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lua_getiuservalue&quot;&gt;&lt;code&gt;lua_getiuservalue&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54be94a59f0bc6784fed88d3a32e726d290eea51" translate="yes" xml:space="preserve">
          <source>This function does not pop the Lua function from the stack.</source>
          <target state="translated">Esta función no hace saltar la función Lua de la pila.</target>
        </trans-unit>
        <trans-unit id="2481d6e1ad7079fac144cbb94c27fa70e98a36a3" translate="yes" xml:space="preserve">
          <source>This function fills parts of a &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; structure with an identification of the &lt;em&gt;activation record&lt;/em&gt; of the function executing at a given level. Level 0 is the current running function, whereas level &lt;em&gt;n+1&lt;/em&gt; is the function that has called level &lt;em&gt;n&lt;/em&gt; (except for tail calls, which do not count in the stack). When called with a level greater than the stack depth, &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; returns 0; otherwise it returns 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b380c64bb33a1e7916dc907712574229b22846ec" translate="yes" xml:space="preserve">
          <source>This function fills parts of a &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; structure with an identification of the &lt;em&gt;activation record&lt;/em&gt; of the function executing at a given level. Level 0 is the current running function, whereas level &lt;em&gt;n+1&lt;/em&gt; is the function that has called level &lt;em&gt;n&lt;/em&gt; (except for tail calls, which do not count on the stack). When there are no errors, &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; returns 1; when called with a level greater than the stack depth, it returns 0.</source>
          <target state="translated">Esta funci&amp;oacute;n llena partes de una estructura &lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; con una identificaci&amp;oacute;n del &lt;em&gt;registro&lt;/em&gt; de &lt;em&gt;activaci&amp;oacute;n&lt;/em&gt; de la funci&amp;oacute;n que se ejecuta en un nivel dado. El nivel 0 es la funci&amp;oacute;n en ejecuci&amp;oacute;n actual, mientras que el nivel &lt;em&gt;n + 1&lt;/em&gt; es la funci&amp;oacute;n que ha llamado al nivel &lt;em&gt;n&lt;/em&gt; (excepto para las llamadas de cola, que no cuentan en la pila). Cuando no hay errores, &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; devuelve 1; cuando se llama con un nivel mayor que la profundidad de la pila, devuelve 0.</target>
        </trans-unit>
        <trans-unit id="024557e7c0e16ad2ced2b25eb7a968becab0102d" translate="yes" xml:space="preserve">
          <source>This function has the following restrictions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f4de101d63040fc5211037c7343d4c56e0ad01" translate="yes" xml:space="preserve">
          <source>This function is a generic interface to the garbage collector. It performs different functions according to its first argument, &lt;code&gt;opt&lt;/code&gt;:</source>
          <target state="translated">Esta funci&amp;oacute;n es una interfaz gen&amp;eacute;rica para el recolector de basura. Realiza diferentes funciones seg&amp;uacute;n su primer argumento, &lt;code&gt;opt&lt;/code&gt; a :</target>
        </trans-unit>
        <trans-unit id="d28a53b3b111db987336d2926f880313a09864bb" translate="yes" xml:space="preserve">
          <source>This function is an interface to the underling pseudo-random generator function provided by C.</source>
          <target state="translated">Esta función es una interfaz con la función generadora seudoaleatoria subyacente proporcionada por C.</target>
        </trans-unit>
        <trans-unit id="1f6bb805a39a7c15cbab2acf8a9252c04d7c39ee" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, but it has no continuation (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). Therefore, when the thread resumes, it continues the function that called the function calling &lt;code&gt;lua_yield&lt;/code&gt;. To avoid surprises, this function should be called only in a tail call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98115d2ab8e4d7be0cefa4bae9be552429cd8c3" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, but it has no continuation (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). Therefore, when the thread resumes, it continues the function that called the function calling &lt;code&gt;lua_yield&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n es equivalente a &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; , pero no tiene continuaci&amp;oacute;n (ver &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; ). Por lo tanto, cuando el hilo se reanuda, contin&amp;uacute;a la funci&amp;oacute;n que llam&amp;oacute; a la funci&amp;oacute;n que llama a &lt;code&gt;lua_yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09df5ee7dcda106a1d20f49f414f02662778ab04" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the ISO C function &lt;code&gt;system&lt;/code&gt;. It passes &lt;code&gt;command&lt;/code&gt; to be executed by an operating system shell. Its first result is &lt;b&gt;true&lt;/b&gt; if the command terminated successfully, or &lt;b&gt;fail&lt;/b&gt; otherwise. After this first result the function returns a string plus a number, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670f5f1a9510a05d3452d6c53437d60b035753b4" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the ISO C function &lt;code&gt;system&lt;/code&gt;. It passes &lt;code&gt;command&lt;/code&gt; to be executed by an operating system shell. Its first result is &lt;b&gt;true&lt;/b&gt; if the command terminated successfully, or &lt;b&gt;nil&lt;/b&gt; otherwise. After this first result the function returns a string plus a number, as follows:</source>
          <target state="translated">Esta funci&amp;oacute;n es equivalente a la funci&amp;oacute;n ISO C &lt;code&gt;system&lt;/code&gt; . Pasa un &lt;code&gt;command&lt;/code&gt; para que lo ejecute un shell del sistema operativo. Su primer resultado es &lt;b&gt;verdadero&lt;/b&gt; si el comando termin&amp;oacute; con &amp;eacute;xito, o &lt;b&gt;nulo en&lt;/b&gt; caso contrario. Despu&amp;eacute;s de este primer resultado, la funci&amp;oacute;n devuelve una cadena m&amp;aacute;s un n&amp;uacute;mero, como sigue:</target>
        </trans-unit>
        <trans-unit id="d3b4b199ecaac9ea3831e4133d9a32cb7ae19470" translate="yes" xml:space="preserve">
          <source>This function is inherently insecure, as it allows Lua to call any function in any readable dynamic library in the system. (Lua calls any function assuming the function has a proper prototype and respects a proper protocol (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;). Therefore, calling an arbitrary function in an arbitrary dynamic library more often than not results in an access violation.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a39cb0734d0402904008bd0b6e1f1f1778321f" translate="yes" xml:space="preserve">
          <source>This function is not supported by Standard C. As such, it is only available on some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the &lt;code&gt;dlfcn&lt;/code&gt; standard).</source>
          <target state="translated">Esta funci&amp;oacute;n no es compatible con Standard C. Como tal, solo est&amp;aacute; disponible en algunas plataformas (Windows, Linux, Mac OS X, Solaris, BSD, adem&amp;aacute;s de otros sistemas Unix que admiten el est&amp;aacute;ndar &lt;code&gt;dlfcn&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="09ff91542609c4270a5672d90a1b6660e19831ef" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt;, except that it sets a new message handler &lt;code&gt;msgh&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n es similar a &lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt; , excepto que establece un nuevo controlador de mensajes &lt;code&gt;msgh&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="717f7af51aaada41e5e3c40f203c1a8fa9d3bad9" translate="yes" xml:space="preserve">
          <source>This function is system dependent and is not available on all platforms.</source>
          <target state="translated">Esta función depende del sistema y no está disponible en todas las plataformas.</target>
        </trans-unit>
        <trans-unit id="11f290796c947e6dfdea50bcfa8240bdb86eb8a0" translate="yes" xml:space="preserve">
          <source>This function is used to build a prefix for error messages.</source>
          <target state="translated">Esta función se utiliza para construir un prefijo para los mensajes de error.</target>
        </trans-unit>
        <trans-unit id="ab9f48a6c272547f77904d32d9efdba0ecb10345" translate="yes" xml:space="preserve">
          <source>This function may be not thread safe because of its reliance on C function &lt;code&gt;setlocale&lt;/code&gt;.</source>
          <target state="translated">Es posible que esta funci&amp;oacute;n no sea segura para subprocesos debido a su dependencia de la funci&amp;oacute;n C &lt;code&gt;setlocale&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5e00f4b8570418e20286901c0f8bb0744338ebc" translate="yes" xml:space="preserve">
          <source>This function may raise an error if the given key is neither &lt;b&gt;nil&lt;/b&gt; nor present in the table. See function &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; for the caveats of modifying the table during its traversal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9bf98dd64c563d3dc312b225a1b47e8d89ef87d" translate="yes" xml:space="preserve">
          <source>This function may raise errors due to memory overflow or an invalid conversion specifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e84460922436ebf110cd9c953279251f6cb0bb" translate="yes" xml:space="preserve">
          <source>This function never returns, but it is an idiom to use it in C functions as &lt;code&gt;return luaL_error(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n nunca regresa, pero es un modismo usarla en funciones C como &lt;code&gt;return luaL_error(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a6a8e72aaf1ce15e733e732a309d591ddf3339d" translate="yes" xml:space="preserve">
          <source>This function never returns.</source>
          <target state="translated">Esta función nunca regresa.</target>
        </trans-unit>
        <trans-unit id="dbd53ac438e83a0043cb356691fb688496f31d3d" translate="yes" xml:space="preserve">
          <source>This function opens a file, in the mode specified in the string &lt;code&gt;mode&lt;/code&gt;. In case of success, it returns a new file handle.</source>
          <target state="translated">Esta funci&amp;oacute;n abre un archivo, en el modo especificado en el &lt;code&gt;mode&lt;/code&gt; cadena . En caso de &amp;eacute;xito, devuelve un nuevo identificador de archivo.</target>
        </trans-unit>
        <trans-unit id="48efe0efa8028e0841dad22b3bd2dd2fd225e975" translate="yes" xml:space="preserve">
          <source>This function performs several tasks, according to the value of the parameter &lt;code&gt;what&lt;/code&gt;. For options that need extra arguments, they are listed after the option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1586e455af396a0193bb677436a0ad64943d1618" translate="yes" xml:space="preserve">
          <source>This function performs several tasks, according to the value of the parameter &lt;code&gt;what&lt;/code&gt;:</source>
          <target state="translated">Esta funci&amp;oacute;n realiza varias tareas, seg&amp;uacute;n el valor del par&amp;aacute;metro &lt;code&gt;what&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc205d90b6658beebf2ab75bca0642c69aa0ce84" translate="yes" xml:space="preserve">
          <source>This function pops &lt;code&gt;n&lt;/code&gt; values from the stack &lt;code&gt;from&lt;/code&gt;, and pushes them onto the stack &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n extrae &lt;code&gt;n&lt;/code&gt; valores de la pila &lt;code&gt;from&lt;/code&gt; y los empuja a la pila &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4693da6260e34753896c1e887316822f4ced3e1d" translate="yes" xml:space="preserve">
          <source>This function pops both the key and the value from the stack. As in Lua, this function may trigger a metamethod for the &quot;newindex&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n saca tanto la clave como el valor de la pila. Como en Lua, esta funci&amp;oacute;n puede activar un metam&amp;eacute;todo para el evento &quot;newindex&quot; (ver &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="02f15be23e4eaf0571f919cc7f7e66b956f4d346" translate="yes" xml:space="preserve">
          <source>This function pops the key from the stack, pushing the resulting value in its place. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n saca la clave de la pila, empujando el valor resultante en su lugar. Como en Lua, esta funci&amp;oacute;n puede activar un metam&amp;eacute;todo para el evento &quot;index&quot; (ver &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="02c44d9ce8f4d61b45f6e95f4c2615a475b30c3d" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. As in Lua, this function may trigger a metamethod for the &quot;newindex&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n saca el valor de la pila. Como en Lua, esta funci&amp;oacute;n puede activar un metam&amp;eacute;todo para el evento &quot;newindex&quot; (ver &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d650072e7d52525aa4e9529e95f455ff101b8ac7" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not invoke &lt;code&gt;__newindex&lt;/code&gt; metamethod.</source>
          <target state="translated">Esta funci&amp;oacute;n saca el valor de la pila. La asignaci&amp;oacute;n es sin &lt;code&gt;__newindex&lt;/code&gt; , es decir, no invoca el metam&amp;eacute;todo __newindex.</target>
        </trans-unit>
        <trans-unit id="4dc9661dd76f18a4a7b7bac51f4e0d8886007ef1" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not invoke the &lt;code&gt;__newindex&lt;/code&gt; metamethod.</source>
          <target state="translated">Esta funci&amp;oacute;n saca el valor de la pila. La asignaci&amp;oacute;n es sin &lt;code&gt;__newindex&lt;/code&gt; , es decir, no invoca el metam&amp;eacute;todo __newindex.</target>
        </trans-unit>
        <trans-unit id="819a7807b617b8fa803512c61d1ba2dc4d437101" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not use the &lt;code&gt;__newindex&lt;/code&gt; metavalue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab41c2efc54cdc4ab08b428ef1fab2ac04e1717" translate="yes" xml:space="preserve">
          <source>This function produces the return values for file-related functions in the standard library (&lt;a href=&quot;#pdf-io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-os.rename&quot;&gt;&lt;code&gt;os.rename&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-file:seek&quot;&gt;&lt;code&gt;file:seek&lt;/code&gt;&lt;/a&gt;, etc.).</source>
          <target state="translated">Esta funci&amp;oacute;n produce los valores de retorno para funciones relacionadas con archivos en la biblioteca est&amp;aacute;ndar ( &lt;a href=&quot;#pdf-io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-os.rename&quot;&gt; &lt;code&gt;os.rename&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-file:seek&quot;&gt; &lt;code&gt;file:seek&lt;/code&gt; &lt;/a&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="7ba307bd4b8d4a518ec757e560baba91e283126d" translate="yes" xml:space="preserve">
          <source>This function produces the return values for process-related functions in the standard library (&lt;a href=&quot;#pdf-os.execute&quot;&gt;&lt;code&gt;os.execute&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.close&quot;&gt;&lt;code&gt;io.close&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n produce los valores de retorno para funciones relacionadas con el proceso en la biblioteca est&amp;aacute;ndar ( &lt;a href=&quot;#pdf-os.execute&quot;&gt; &lt;code&gt;os.execute&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#pdf-io.close&quot;&gt; &lt;code&gt;io.close&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b6746e2c8158506c924e3d9368f6e2be32b4e0d2" translate="yes" xml:space="preserve">
          <source>This function returns 0 on error (for instance, an invalid option in &lt;code&gt;what&lt;/code&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve 0 en caso de error (por ejemplo, una opci&amp;oacute;n no v&amp;aacute;lida en &lt;code&gt;what&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="007342df8b0ff02345d55706dd45be96b5514f81" translate="yes" xml:space="preserve">
          <source>This function returns 0 to signal an invalid option in &lt;code&gt;what&lt;/code&gt;; even then the valid options are handled correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4eda5d295976dd3059ff0cebee20501ad1d66f" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve la &lt;code&gt;table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedc3ddfbc8f8f82058b7b55965c12222160cb90" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;f&lt;/code&gt; of the stack. This function accesses not only explicit local variables, but also parameters and temporary values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb6c1599fe3ff6cd07d37a480afe2c16e49c014" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;f&lt;/code&gt; of the stack. This function accesses not only explicit local variables, but also parameters, temporaries, etc.</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve el nombre y el valor de la variable local con &amp;iacute;ndice &lt;code&gt;local&lt;/code&gt; de la funci&amp;oacute;n en el nivel &lt;code&gt;f&lt;/code&gt; de la pila. Esta funci&amp;oacute;n accede no solo a variables locales expl&amp;iacute;citas, sino tambi&amp;eacute;n a par&amp;aacute;metros, temporales, etc.</target>
        </trans-unit>
        <trans-unit id="6f127ef7aa5ca9413741861659f87c5d2122763a" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no upvalue with the given index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11dccabc4359a103d70b6a183c7d1b9e295f7d04" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no upvalue with the given index.</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve el nombre y el valor del upvalue con &amp;iacute;ndice &lt;code&gt;up&lt;/code&gt; de la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; . La funci&amp;oacute;n devuelve &lt;b&gt;nil&lt;/b&gt; si no hay ning&amp;uacute;n valor de subida con el &amp;iacute;ndice dado.</target>
        </trans-unit>
        <trans-unit id="dbabb13e68eb92f970ce1720014ee57a5f7be9a6" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdf-LUA_ERRFILE&quot;&gt;&lt;code&gt;LUA_ERRFILE&lt;/code&gt;&lt;/a&gt; for file-related errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebb641f92b0e70a08302c805cbf864b58b36eaf" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;, but it has an extra error code &lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt;&lt;code&gt;LUA_ERRFILE&lt;/code&gt;&lt;/a&gt; for file-related errors (e.g., it cannot open or read the file).</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve los mismos resultados que &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; , pero tiene un c&amp;oacute;digo de error adicional &lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt; &lt;code&gt;LUA_ERRFILE&lt;/code&gt; &lt;/a&gt; para errores relacionados con el archivo (por ejemplo, no puede abrir o leer el archivo).</target>
        </trans-unit>
        <trans-unit id="6596dd0254b38c840e56683db82740f29df06f33" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve los mismos resultados que &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0db593e94c92390f3357b35159d95eee2be2609" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the chunk name, used for debug information and error messages. The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve los mismos resultados que &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;name&lt;/code&gt; es el nombre del fragmento, que se utiliza para informaci&amp;oacute;n de depuraci&amp;oacute;n y mensajes de error. El &lt;code&gt;mode&lt;/code&gt; cadena funciona como en la funci&amp;oacute;n &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa91cf9c69a1d6d718bdf5a3abdd1697403c8a5e" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the chunk name, used for debug information and error messages. The string &lt;code&gt;mode&lt;/code&gt; works as in the function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf38c50a3f108c7ed76db3fdffae7549d0d9313a" translate="yes" xml:space="preserve">
          <source>This function returns the two seed components that were effectively used, so that setting them again repeats the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd05accb35e1396e632daa50237769ee36b8264" translate="yes" xml:space="preserve">
          <source>This function should not be called for an index that is equal to or below an active to-be-closed index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5412475350d1ee79055711d0c4350d66e69ffd6d" translate="yes" xml:space="preserve">
          <source>This function uses &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; to get its result, so all conversions and caveats of that function apply here.</source>
          <target state="translated">Esta funci&amp;oacute;n usa &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt; para obtener su resultado, por lo que todas las conversiones y advertencias de esa funci&amp;oacute;n se aplican aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="f440effb67a02807b5514a47b986fa3c896b974d" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;code&gt;xoshiro256**&lt;/code&gt; algorithm to produce pseudo-random 64-bit integers, which are the results of calls with argument 0. Other results (ranges and floats) are unbiased extracted from these integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d4ea61bcf0f5292e3f253adc7c53a2139d8438" translate="yes" xml:space="preserve">
          <source>This function works like &lt;a href=&quot;#luaL_checkudata&quot;&gt;&lt;code&gt;luaL_checkudata&lt;/code&gt;&lt;/a&gt;, except that, when the test fails, it returns &lt;code&gt;NULL&lt;/code&gt; instead of raising an error.</source>
          <target state="translated">Esta funci&amp;oacute;n funciona como &lt;a href=&quot;#luaL_checkudata&quot;&gt; &lt;code&gt;luaL_checkudata&lt;/code&gt; &lt;/a&gt; , excepto que, cuando la prueba falla, devuelve &lt;code&gt;NULL&lt;/code&gt; en lugar de generar un error.</target>
        </trans-unit>
        <trans-unit id="6563d8fb9cdba4b8e66ee93d7bd36fb67b77cff7" translate="yes" xml:space="preserve">
          <source>This is a low-level function. It completely bypasses the package and module system. Unlike &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;, it does not perform any path searching and does not automatically adds extensions. &lt;code&gt;libname&lt;/code&gt; must be the complete file name of the C library, including if necessary a path and an extension. &lt;code&gt;funcname&lt;/code&gt; must be the exact name exported by the C library (which may depend on the C compiler and linker used).</source>
          <target state="translated">Esta es una funci&amp;oacute;n de bajo nivel. Omite por completo el sistema de paquetes y m&amp;oacute;dulos. A diferencia de &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; , no realiza ninguna b&amp;uacute;squeda de ruta y no agrega extensiones autom&amp;aacute;ticamente. &lt;code&gt;libname&lt;/code&gt; debe ser el nombre de archivo completo de la biblioteca C, incluyendo si es necesario una ruta y una extensi&amp;oacute;n. &lt;code&gt;funcname&lt;/code&gt; debe ser el nombre exacto exportado por la biblioteca de C (que puede depender del compilador de C y del enlazador utilizado).</target>
        </trans-unit>
        <trans-unit id="fd11429b923b744979c7d1f098bd69f96f85f6c0" translate="yes" xml:space="preserve">
          <source>This is a useful function for mapping strings to C enums. (The usual convention in Lua libraries is to use strings instead of numbers to select options.)</source>
          <target state="translated">Esta es una función útil para mapear las cuerdas a los enums de C.(La convención usual en las bibliotecas de Lua es usar cadenas en lugar de números para seleccionar opciones).</target>
        </trans-unit>
        <trans-unit id="753037500c4fa6eda5c0c6251d0c5a1a859a582c" translate="yes" xml:space="preserve">
          <source>This is the only function on string buffers that can (and must) be called with an extra element on the stack, which is the value to be added to the buffer.</source>
          <target state="translated">Esta es la única función en los buffers de cadena que puede (y debe)ser llamada con un elemento extra en la pila,que es el valor a añadir al buffer.</target>
        </trans-unit>
        <trans-unit id="fc6eb47b441fdf44e1e8bc0429e02c5da92dec89" translate="yes" xml:space="preserve">
          <source>This is the only option that can raise a memory error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d6873741ea710dec0793ac5a59b32c0c418fac" translate="yes" xml:space="preserve">
          <source>This library comprises the operations to manipulate coroutines, which come inside the table &lt;a id=&quot;pdf-coroutine&quot;&gt;&lt;code&gt;coroutine&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt; for a general description of coroutines.</source>
          <target state="translated">Esta biblioteca comprende las operaciones para manipular corrutinas, que vienen dentro de la &lt;a id=&quot;pdf-coroutine&quot;&gt; &lt;code&gt;coroutine&lt;/code&gt; &lt;/a&gt; la tabla . Consulte &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt; para obtener una descripci&amp;oacute;n general de las corrutinas.</target>
        </trans-unit>
        <trans-unit id="90c1b961ab3b38c58be563362f0802d45e85c135" translate="yes" xml:space="preserve">
          <source>This library is implemented through table &lt;a id=&quot;pdf-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta biblioteca se implementa a trav&amp;eacute;s de table &lt;a id=&quot;pdf-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="677be47bd4a9ee27a5f7b1353939b6d0981e1e42" translate="yes" xml:space="preserve">
          <source>This library provides basic mathematical functions. It provides all its functions and constants inside the table &lt;a id=&quot;pdf-math&quot;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt;. Functions with the annotation &quot;&lt;code&gt;integer/float&lt;/code&gt;&quot; give integer results for integer arguments and float results for float (or mixed) arguments. Rounding functions (&lt;a href=&quot;#pdf-math.ceil&quot;&gt;&lt;code&gt;math.ceil&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-math.floor&quot;&gt;&lt;code&gt;math.floor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-math.modf&quot;&gt;&lt;code&gt;math.modf&lt;/code&gt;&lt;/a&gt;) return an integer when the result fits in the range of an integer, or a float otherwise.</source>
          <target state="translated">Esta biblioteca proporciona funciones matem&amp;aacute;ticas b&amp;aacute;sicas. Proporciona todas sus funciones y constantes dentro de la tabla &lt;a id=&quot;pdf-math&quot;&gt; &lt;code&gt;math&lt;/code&gt; &lt;/a&gt; . Las funciones con la anotaci&amp;oacute;n &quot; &lt;code&gt;integer/float&lt;/code&gt; &quot; dan resultados enteros para argumentos enteros y resultados flotantes para argumentos flotantes (o mixtos). Las funciones de redondeo ( &lt;a href=&quot;#pdf-math.ceil&quot;&gt; &lt;code&gt;math.ceil&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-math.floor&quot;&gt; &lt;code&gt;math.floor&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#pdf-math.modf&quot;&gt; &lt;code&gt;math.modf&lt;/code&gt; &lt;/a&gt; ) devuelven un n&amp;uacute;mero entero cuando el resultado encaja en el rango de un n&amp;uacute;mero entero, o un flotante de lo contrario.</target>
        </trans-unit>
        <trans-unit id="fda34771150302c5e6235e047b8a7d6f844dd96f" translate="yes" xml:space="preserve">
          <source>This library provides basic mathematical functions. It provides all its functions and constants inside the table &lt;a id=&quot;pdf-math&quot;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt;. Functions with the annotation &quot;&lt;code&gt;integer/float&lt;/code&gt;&quot; give integer results for integer arguments and float results for non-integer arguments. The rounding functions &lt;a href=&quot;#pdf-math.ceil&quot;&gt;&lt;code&gt;math.ceil&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-math.floor&quot;&gt;&lt;code&gt;math.floor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-math.modf&quot;&gt;&lt;code&gt;math.modf&lt;/code&gt;&lt;/a&gt; return an integer when the result fits in the range of an integer, or a float otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff61c8c99df8abb4cc617e0a788ed6e1d7a8ab8" translate="yes" xml:space="preserve">
          <source>This library provides basic support for UTF-8 encoding. It provides all its functions inside the table &lt;a id=&quot;pdf-utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt;. This library does not provide any support for Unicode other than the handling of the encoding. Any operation that needs the meaning of a character, such as character classification, is outside its scope.</source>
          <target state="translated">Esta biblioteca proporciona soporte b&amp;aacute;sico para la codificaci&amp;oacute;n UTF-8. Proporciona todas sus funciones dentro de la tabla &lt;a id=&quot;pdf-utf8&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt; . Esta biblioteca no proporciona ning&amp;uacute;n soporte para Unicode que no sea el manejo de la codificaci&amp;oacute;n. Cualquier operaci&amp;oacute;n que necesite el significado de un car&amp;aacute;cter, como la clasificaci&amp;oacute;n de caracteres, est&amp;aacute; fuera de su alcance.</target>
        </trans-unit>
        <trans-unit id="f54156236b7b08469a0920a829130d4325d9534b" translate="yes" xml:space="preserve">
          <source>This library provides generic functions for string manipulation, such as finding and extracting substrings, and pattern matching. When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string. Thus, the last character is at position -1, and so on.</source>
          <target state="translated">Esta biblioteca ofrece funciones genéricas para la manipulación de cadenas,como la búsqueda y extracción de subcadenas,y la comparación de patrones.Cuando se indexa una cadena en Lua,el primer carácter está en la posición 1 (no en 0,como en C).Se permite que los índices sean negativos y se interpretan como una indexación hacia atrás,desde el final de la cadena.Así,el último carácter está en la posición -1,y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="eaff80ded470719d876c589d5513c23d7a2d941b" translate="yes" xml:space="preserve">
          <source>This library provides generic functions for table manipulation. It provides all its functions inside the table &lt;a id=&quot;pdf-table&quot;&gt;&lt;code&gt;table&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta biblioteca proporciona funciones gen&amp;eacute;ricas para la manipulaci&amp;oacute;n de tablas. Proporciona todas sus funciones dentro de la tabla &lt;a id=&quot;pdf-table&quot;&gt; &lt;code&gt;table&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f4d4c7789cbf6727187aa434640210ed81d6661" translate="yes" xml:space="preserve">
          <source>This library provides the functionality of the debug interface (&lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;) to Lua programs. You should exert care when using this library. Several of its functions violate basic assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside; that userdata metatables cannot be changed by Lua code; that Lua programs do not crash) and therefore can compromise otherwise secure code. Moreover, some functions in this library may be slow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d51d524a82a8aae4d9f2e0292c35c2b4f100e81" translate="yes" xml:space="preserve">
          <source>This library provides the functionality of the debug interface (&lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;) to Lua programs. You should exert care when using this library. Several of its functions violate basic assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside; that userdata metatables cannot be changed by Lua code; that Lua programs do not crash) and therefore can compromise otherwise secure code. Moreover, some functions in this library may be slow.</source>
          <target state="translated">Esta biblioteca proporciona la funcionalidad de la interfaz de depuraci&amp;oacute;n ( &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt; ) a los programas Lua. Debe tener cuidado al utilizar esta biblioteca. Varias de sus funciones violan los supuestos b&amp;aacute;sicos sobre el c&amp;oacute;digo Lua (por ejemplo, que no se puede acceder a las variables locales de una funci&amp;oacute;n desde el exterior; que el c&amp;oacute;digo Lua no puede cambiar las metatablas de datos de usuario; que los programas Lua no fallan) y, por lo tanto, pueden comprometer el c&amp;oacute;digo seguro. Adem&amp;aacute;s, algunas funciones de esta biblioteca pueden ser lentas.</target>
        </trans-unit>
        <trans-unit id="aa99211cd2ffc6b2b1567c3fa58975b02bdbb57d" translate="yes" xml:space="preserve">
          <source>This macro is defined as follows:</source>
          <target state="translated">Esta macro se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="c062139aee69e54bd4a269563eddaa0f4e8798af" translate="yes" xml:space="preserve">
          <source>This macro is equivalent to &lt;a href=&quot;#lua_pushstring&quot;&gt;&lt;code&gt;lua_pushstring&lt;/code&gt;&lt;/a&gt;, but should be used only when &lt;code&gt;s&lt;/code&gt; is a literal string.</source>
          <target state="translated">Esta macro es equivalente a &lt;a href=&quot;#lua_pushstring&quot;&gt; &lt;code&gt;lua_pushstring&lt;/code&gt; &lt;/a&gt; , pero debe usarse solo cuando &lt;code&gt;s&lt;/code&gt; es una cadena literal.</target>
        </trans-unit>
        <trans-unit id="8a5828258eda09312844222f71451e9b5df31690" translate="yes" xml:space="preserve">
          <source>This macro is equivalent to &lt;a href=&quot;#lua_pushstring&quot;&gt;&lt;code&gt;lua_pushstring&lt;/code&gt;&lt;/a&gt;, but should be used only when &lt;code&gt;s&lt;/code&gt; is a literal string. (Lua may optimize this case.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fca2eb54a811850b7ad4e17b0d35bfe7cf0032" translate="yes" xml:space="preserve">
          <source>This macro may evaluate its arguments more than once.</source>
          <target state="translated">Esta macro puede evaluar sus argumentos más de una vez.</target>
        </trans-unit>
        <trans-unit id="05f26abbbd5d35b2d22d1c051a71569b0f900ee1" translate="yes" xml:space="preserve">
          <source>This section describes the C API for Lua, that is, the set of C functions available to the host program to communicate with Lua. All API functions and related types and constants are declared in the header file &lt;a id=&quot;pdf-lua.h&quot;&gt;&lt;code&gt;lua.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta secci&amp;oacute;n describe la API de C para Lua, es decir, el conjunto de funciones de C disponibles para que el programa anfitri&amp;oacute;n se comunique con Lua. Todas las funciones de la API y los tipos y constantes relacionadas se declaran en el archivo de cabecera &lt;a id=&quot;pdf-lua.h&quot;&gt; &lt;code&gt;lua.h&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f58c3cfe49431540420c4f54cf654f80f9192fd6" translate="yes" xml:space="preserve">
          <source>This section describes the basic concepts of the language.</source>
          <target state="translated">Esta sección describe los conceptos básicos del lenguaje.</target>
        </trans-unit>
        <trans-unit id="8fa659ee1a4beeab1fc33f883314eeb2cadc844d" translate="yes" xml:space="preserve">
          <source>This section describes the lexis, the syntax, and the semantics of Lua. In other words, this section describes which tokens are valid, how they can be combined, and what their combinations mean.</source>
          <target state="translated">Esta sección describe el léxico,la sintaxis y la semántica de Lua.En otras palabras,esta sección describe qué fichas son válidas,cómo pueden ser combinadas y qué significan sus combinaciones.</target>
        </trans-unit>
        <trans-unit id="db29de528ad1c90a96a681f72e450fef6b674bc0" translate="yes" xml:space="preserve">
          <source>This specifier does not support modifiers (flags, width, length).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278be3240fe4a7ea3d08f92baa83623d2ac8fe27" translate="yes" xml:space="preserve">
          <source>This userdata must start with the structure &lt;code&gt;luaL_Stream&lt;/code&gt;; it can contain other data after this initial structure. Field &lt;code&gt;f&lt;/code&gt; points to the corresponding C stream (or it can be &lt;code&gt;NULL&lt;/code&gt; to indicate an incompletely created handle). Field &lt;code&gt;closef&lt;/code&gt; points to a Lua function that will be called to close the stream when the handle is closed or collected; this function receives the file handle as its sole argument and must return either &lt;b&gt;true&lt;/b&gt; (in case of success) or &lt;b&gt;nil&lt;/b&gt; plus an error message (in case of error). Once Lua calls this field, it changes the field value to &lt;code&gt;NULL&lt;/code&gt; to signal that the handle is closed.</source>
          <target state="translated">Estos datos de usuario deben comenzar con la estructura &lt;code&gt;luaL_Stream&lt;/code&gt; ; puede contener otros datos despu&amp;eacute;s de esta estructura inicial. El campo &lt;code&gt;f&lt;/code&gt; apunta a la secuencia C correspondiente (o puede ser &lt;code&gt;NULL&lt;/code&gt; para indicar un identificador creado de forma incompleta). Field &lt;code&gt;closef&lt;/code&gt; apunta a una funci&amp;oacute;n Lua que se llamar&amp;aacute; para cerrar la secuencia cuando el identificador se cierre o se recopile; esta funci&amp;oacute;n recibe el identificador de archivo como su &amp;uacute;nico argumento y debe devolver &lt;b&gt;verdadero&lt;/b&gt; (en caso de &amp;eacute;xito) o &lt;b&gt;nulo&lt;/b&gt; m&amp;aacute;s un mensaje de error (en caso de error). Una vez que Lua llama a este campo, cambia el valor del campo a &lt;code&gt;NULL&lt;/code&gt; para indicar que el identificador est&amp;aacute; cerrado.</target>
        </trans-unit>
        <trans-unit id="e34f3769ad0807b3d6dc807de51658a5229c2a2c" translate="yes" xml:space="preserve">
          <source>This userdata must start with the structure &lt;code&gt;luaL_Stream&lt;/code&gt;; it can contain other data after this initial structure. The field &lt;code&gt;f&lt;/code&gt; points to the corresponding C stream (or it can be &lt;code&gt;NULL&lt;/code&gt; to indicate an incompletely created handle). The field &lt;code&gt;closef&lt;/code&gt; points to a Lua function that will be called to close the stream when the handle is closed or collected; this function receives the file handle as its sole argument and must return either a true value, in case of success, or a false value plus an error message, in case of error. Once Lua calls this field, it changes the field value to &lt;code&gt;NULL&lt;/code&gt; to signal that the handle is closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a38b5444cc9ef2204e61edb4d9f6307dc07f0ac4" translate="yes" xml:space="preserve">
          <source>This variable is only a reference to the real table; assignments to this variable do not change the table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta variable es solo una referencia a la tabla real; las asignaciones a esta variable no cambian la tabla utilizada por &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53329857ea4576424bb761eab97ba4d7a438b162" translate="yes" xml:space="preserve">
          <source>Threads are subject to garbage collection, like any Lua object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5b59d880561eb52ba3ed52be79a6fc246200cf" translate="yes" xml:space="preserve">
          <source>To allow possible side-effects, function calls can be executed as statements:</source>
          <target state="translated">Para permitir posibles efectos secundarios,las llamadas a funciones pueden ser ejecutadas como declaraciones:</target>
        </trans-unit>
        <trans-unit id="e5d4f137bc9e715e9e20a727cc9650777e835e92" translate="yes" xml:space="preserve">
          <source>To allow the use of Lua as a script interpreter in Unix systems, Lua skips the first line of a file chunk if it starts with &lt;code&gt;#&lt;/code&gt;. Therefore, Lua scripts can be made into executable programs by using &lt;code&gt;chmod +x&lt;/code&gt; and the &lt;code&gt;#!&lt;/code&gt; form, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888be864c9c88102be3a61e9065fc124fb157083" translate="yes" xml:space="preserve">
          <source>To allow the use of Lua as a script interpreter in Unix systems, the standalone interpreter skips the first line of a chunk if it starts with &lt;code&gt;#&lt;/code&gt;. Therefore, Lua scripts can be made into executable programs by using &lt;code&gt;chmod +x&lt;/code&gt; and the &lt;code&gt;#!&lt;/code&gt; form, as in</source>
          <target state="translated">Para permitir el uso de Lua como int&amp;eacute;rprete de scripts en sistemas Unix, el int&amp;eacute;rprete independiente salta la primera l&amp;iacute;nea de un fragmento si comienza con &lt;code&gt;#&lt;/code&gt; . Por lo tanto, los scripts Lua se pueden hacer en los programas ejecutables usando &lt;code&gt;chmod +x&lt;/code&gt; y el &lt;code&gt;#!&lt;/code&gt; forma, como en</target>
        </trans-unit>
        <trans-unit id="1e9c9099d2aea779a3a3f78d58160c9b66011127" translate="yes" xml:space="preserve">
          <source>To avoid this kind of problem, Lua raises an error whenever it tries to yield across an API call, except for three functions: &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;. All those functions receive a &lt;em&gt;continuation function&lt;/em&gt; (as a parameter named &lt;code&gt;k&lt;/code&gt;) to continue execution after a yield.</source>
          <target state="translated">Para evitar este tipo de problema, Lua genera un error cada vez que intenta ceder a trav&amp;eacute;s de una llamada a la API, excepto por tres funciones: &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; . Todas esas funciones reciben una &lt;em&gt;funci&amp;oacute;n de continuaci&amp;oacute;n&lt;/em&gt; (como un par&amp;aacute;metro llamado &lt;code&gt;k&lt;/code&gt; ) para continuar la ejecuci&amp;oacute;n despu&amp;eacute;s de un rendimiento.</target>
        </trans-unit>
        <trans-unit id="5bb0e844a26e80a97eddacec1b0d3209d0d96606" translate="yes" xml:space="preserve">
          <source>To call a function you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the function are pushed in direct order; that is, the first argument is pushed first. Finally you call &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;nargs&lt;/code&gt; is the number of arguments that you pushed onto the stack. All arguments and the function value are popped from the stack when the function is called. The function results are pushed onto the stack when the function returns. The number of results is adjusted to &lt;code&gt;nresults&lt;/code&gt;, unless &lt;code&gt;nresults&lt;/code&gt; is &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt;&lt;code&gt;LUA_MULTRET&lt;/code&gt;&lt;/a&gt;. In this case, all results from the function are pushed; Lua takes care that the returned values fit into the stack space, but it does not ensure any extra space in the stack. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.</source>
          <target state="translated">Para llamar a una funci&amp;oacute;n, debe utilizar el siguiente protocolo: primero, la funci&amp;oacute;n que se va a llamar se inserta en la pila; luego, los argumentos de la funci&amp;oacute;n se insertan en orden directo; es decir, el primer argumento se inserta primero. Finalmente llamas a &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; ; &lt;code&gt;nargs&lt;/code&gt; es el n&amp;uacute;mero de argumentos que introdujo en la pila. Todos los argumentos y el valor de la funci&amp;oacute;n se extraen de la pila cuando se llama a la funci&amp;oacute;n. Los resultados de la funci&amp;oacute;n se insertan en la pila cuando la funci&amp;oacute;n regresa. El n&amp;uacute;mero de resultados se ajusta a &lt;code&gt;nresults&lt;/code&gt; , a menos que &lt;code&gt;nresults&lt;/code&gt; sea &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt; &lt;code&gt;LUA_MULTRET&lt;/code&gt; &lt;/a&gt;. En este caso, se insertan todos los resultados de la funci&amp;oacute;n; Lua se encarga de que los valores devueltos quepan en el espacio de la pila, pero no garantiza ning&amp;uacute;n espacio adicional en la pila. Los resultados de la funci&amp;oacute;n se insertan en la pila en orden directo (el primer resultado se inserta primero), de modo que despu&amp;eacute;s de la llamada, el &amp;uacute;ltimo resultado est&amp;aacute; en la parte superior de la pila.</target>
        </trans-unit>
        <trans-unit id="6f927865cf7be60df11e5707f3fba807a308ae47" translate="yes" xml:space="preserve">
          <source>To catch errors in Lua, you can do a &lt;em&gt;protected call&lt;/em&gt;, using &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt;). The function &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt; calls a given function in &lt;em&gt;protected mode&lt;/em&gt;. Any error while running the function stops its execution, and control returns immediately to &lt;code&gt;pcall&lt;/code&gt;, which returns a status code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea99929cea20ed156e3c1b46c0e6d4b1e4d677a" translate="yes" xml:space="preserve">
          <source>To change the metatable of other types from Lua code, you must use the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6417128dbbbaad3ecee352f08e4fffebce841718" translate="yes" xml:space="preserve">
          <source>To do a call you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the call are pushed in direct order; that is, the first argument is pushed first. Finally you call &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;nargs&lt;/code&gt; is the number of arguments that you pushed onto the stack. When the function returns, all arguments and the function value are popped and the call results are pushed onto the stack. The number of results is adjusted to &lt;code&gt;nresults&lt;/code&gt;, unless &lt;code&gt;nresults&lt;/code&gt; is &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt;&lt;code&gt;LUA_MULTRET&lt;/code&gt;&lt;/a&gt;. In this case, all results from the function are pushed; Lua takes care that the returned values fit into the stack space, but it does not ensure any extra space in the stack. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1fdaa7f1c7b918f16975f1ca7b0d514c6f0f3a" translate="yes" xml:space="preserve">
          <source>To ensure a required level of randomness to the initial state (or contrarily, to have a deterministic sequence, for instance when debugging a program), you should call &lt;a href=&quot;#pdf-math.randomseed&quot;&gt;&lt;code&gt;math.randomseed&lt;/code&gt;&lt;/a&gt; with explicit arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1e6304705c324bc934187373072b763f1a1066" translate="yes" xml:space="preserve">
          <source>To find a loader, &lt;code&gt;require&lt;/code&gt; is guided by the &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt; sequence. By changing this sequence, we can change how &lt;code&gt;require&lt;/code&gt; looks for a module. The following explanation is based on the default configuration for &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para encontrar un cargador, &lt;code&gt;require&lt;/code&gt; se gu&amp;iacute;a por la secuencia &lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt; . Al cambiar esta secuencia, podemos cambiar c&amp;oacute;mo &lt;code&gt;require&lt;/code&gt; busca un m&amp;oacute;dulo. La siguiente explicaci&amp;oacute;n se basa en la configuraci&amp;oacute;n predeterminada de &lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e712bd9f9ff5cb85660101fcd07ff33cf506329" translate="yes" xml:space="preserve">
          <source>To find a loader, &lt;code&gt;require&lt;/code&gt; is guided by the table &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;. Each item in this table is a search function, that searches for the module in a particular way. By changing this table, we can change how &lt;code&gt;require&lt;/code&gt; looks for a module. The following explanation is based on the default configuration for &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d328425732a8a8cf219c051476f3d38be1088896" translate="yes" xml:space="preserve">
          <source>To get information about a function invocation, the parameter &lt;code&gt;ar&lt;/code&gt; must be a valid activation record that was filled by a previous call to &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; or given as argument to a hook (see &lt;a href=&quot;#lua_Hook&quot;&gt;&lt;code&gt;lua_Hook&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Para obtener informaci&amp;oacute;n sobre la invocaci&amp;oacute;n de una funci&amp;oacute;n, el par&amp;aacute;metro &lt;code&gt;ar&lt;/code&gt; debe ser un registro de activaci&amp;oacute;n v&amp;aacute;lido que fue llenado por una llamada anterior a &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; o dado como argumento a un gancho (ver &lt;a href=&quot;#lua_Hook&quot;&gt; &lt;code&gt;lua_Hook&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="259bf849c0380d37169ac9c2c5ed68eef86ed762" translate="yes" xml:space="preserve">
          <source>To get information about a function you push it onto the stack and start the &lt;code&gt;what&lt;/code&gt; string with the character '&lt;code&gt;&amp;gt;&lt;/code&gt;'. (In that case, &lt;code&gt;lua_getinfo&lt;/code&gt; pops the function from the top of the stack.) For instance, to know in which line a function &lt;code&gt;f&lt;/code&gt; was defined, you can write the following code:</source>
          <target state="translated">Para obtener informaci&amp;oacute;n sobre una funci&amp;oacute;n, la empuja a la pila y comienza la cadena &lt;code&gt;what&lt;/code&gt; con el car&amp;aacute;cter ' &lt;code&gt;&amp;gt;&lt;/code&gt; '. (En ese caso, &lt;code&gt;lua_getinfo&lt;/code&gt; saca la funci&amp;oacute;n de la parte superior de la pila). Por ejemplo, para saber en qu&amp;eacute; l&amp;iacute;nea se defini&amp;oacute; una funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; , puede escribir el siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="bbdfec85d3ce9d473ff7e0ea2279d69ff617c711" translate="yes" xml:space="preserve">
          <source>To get information about a function, you push it onto the stack and start the &lt;code&gt;what&lt;/code&gt; string with the character '&lt;code&gt;&amp;gt;&lt;/code&gt;'. (In that case, &lt;code&gt;lua_getinfo&lt;/code&gt; pops the function from the top of the stack.) For instance, to know in which line a function &lt;code&gt;f&lt;/code&gt; was defined, you can write the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c87754131cf9f2c3e4c8c44baabf65a58d386a2" translate="yes" xml:space="preserve">
          <source>To have access to these libraries, the C host program should call the &lt;a href=&quot;#luaL_openlibs&quot;&gt;&lt;code&gt;luaL_openlibs&lt;/code&gt;&lt;/a&gt; function, which opens all standard libraries. Alternatively, the host program can open them individually by using &lt;a href=&quot;#luaL_requiref&quot;&gt;&lt;code&gt;luaL_requiref&lt;/code&gt;&lt;/a&gt; to call &lt;a id=&quot;pdf-luaopen_base&quot;&gt;&lt;code&gt;luaopen_base&lt;/code&gt;&lt;/a&gt; (for the basic library), &lt;a id=&quot;pdf-luaopen_package&quot;&gt;&lt;code&gt;luaopen_package&lt;/code&gt;&lt;/a&gt; (for the package library), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt;&lt;code&gt;luaopen_coroutine&lt;/code&gt;&lt;/a&gt; (for the coroutine library), &lt;a id=&quot;pdf-luaopen_string&quot;&gt;&lt;code&gt;luaopen_string&lt;/code&gt;&lt;/a&gt; (for the string library), &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt;&lt;code&gt;luaopen_utf8&lt;/code&gt;&lt;/a&gt; (for the UTF-8 library), &lt;a id=&quot;pdf-luaopen_table&quot;&gt;&lt;code&gt;luaopen_table&lt;/code&gt;&lt;/a&gt; (for the table library), &lt;a id=&quot;pdf-luaopen_math&quot;&gt;&lt;code&gt;luaopen_math&lt;/code&gt;&lt;/a&gt; (for the mathematical library), &lt;a id=&quot;pdf-luaopen_io&quot;&gt;&lt;code&gt;luaopen_io&lt;/code&gt;&lt;/a&gt; (for the I/O library), &lt;a id=&quot;pdf-luaopen_os&quot;&gt;&lt;code&gt;luaopen_os&lt;/code&gt;&lt;/a&gt; (for the operating system library), and &lt;a id=&quot;pdf-luaopen_debug&quot;&gt;&lt;code&gt;luaopen_debug&lt;/code&gt;&lt;/a&gt; (for the debug library). These functions are declared in &lt;a id=&quot;pdf-lualib.h&quot;&gt;&lt;code&gt;lualib.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f65df24a4302e99c5805820ed2c9da17dcc1b4e" translate="yes" xml:space="preserve">
          <source>To have access to these libraries, the C host program should call the &lt;a href=&quot;#luaL_openlibs&quot;&gt;&lt;code&gt;luaL_openlibs&lt;/code&gt;&lt;/a&gt; function, which opens all standard libraries. Alternatively, the host program can open them individually by using &lt;a href=&quot;#luaL_requiref&quot;&gt;&lt;code&gt;luaL_requiref&lt;/code&gt;&lt;/a&gt; to call &lt;a id=&quot;pdf-luaopen_base&quot;&gt;&lt;code&gt;luaopen_base&lt;/code&gt;&lt;/a&gt; (for the basic library), &lt;a id=&quot;pdf-luaopen_package&quot;&gt;&lt;code&gt;luaopen_package&lt;/code&gt;&lt;/a&gt; (for the package library), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt;&lt;code&gt;luaopen_coroutine&lt;/code&gt;&lt;/a&gt; (for the coroutine library), &lt;a id=&quot;pdf-luaopen_string&quot;&gt;&lt;code&gt;luaopen_string&lt;/code&gt;&lt;/a&gt; (for the string library), &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt;&lt;code&gt;luaopen_utf8&lt;/code&gt;&lt;/a&gt; (for the UTF8 library), &lt;a id=&quot;pdf-luaopen_table&quot;&gt;&lt;code&gt;luaopen_table&lt;/code&gt;&lt;/a&gt; (for the table library), &lt;a id=&quot;pdf-luaopen_math&quot;&gt;&lt;code&gt;luaopen_math&lt;/code&gt;&lt;/a&gt; (for the mathematical library), &lt;a id=&quot;pdf-luaopen_io&quot;&gt;&lt;code&gt;luaopen_io&lt;/code&gt;&lt;/a&gt; (for the I/O library), &lt;a id=&quot;pdf-luaopen_os&quot;&gt;&lt;code&gt;luaopen_os&lt;/code&gt;&lt;/a&gt; (for the operating system library), and &lt;a id=&quot;pdf-luaopen_debug&quot;&gt;&lt;code&gt;luaopen_debug&lt;/code&gt;&lt;/a&gt; (for the debug library). These functions are declared in &lt;a id=&quot;pdf-lualib.h&quot;&gt;&lt;code&gt;lualib.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para tener acceso a estas bibliotecas, el programa anfitri&amp;oacute;n de C debe llamar a la funci&amp;oacute;n &lt;a href=&quot;#luaL_openlibs&quot;&gt; &lt;code&gt;luaL_openlibs&lt;/code&gt; &lt;/a&gt; , que abre todas las bibliotecas est&amp;aacute;ndar. Alternativamente, el programa anfitri&amp;oacute;n puede abrirlos individualmente usando &lt;a href=&quot;#luaL_requiref&quot;&gt; &lt;code&gt;luaL_requiref&lt;/code&gt; &lt;/a&gt; para llamar a &lt;a id=&quot;pdf-luaopen_base&quot;&gt; &lt;code&gt;luaopen_base&lt;/code&gt; &lt;/a&gt; (para la biblioteca b&amp;aacute;sica), &lt;a id=&quot;pdf-luaopen_package&quot;&gt; &lt;code&gt;luaopen_package&lt;/code&gt; &lt;/a&gt; (para la biblioteca de paquetes), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt; &lt;code&gt;luaopen_coroutine&lt;/code&gt; &lt;/a&gt; (para la biblioteca de rutinas), &lt;a id=&quot;pdf-luaopen_string&quot;&gt; &lt;code&gt;luaopen_string&lt;/code&gt; &lt;/a&gt; (para la biblioteca de cadenas), &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt; &lt;code&gt;luaopen_utf8&lt;/code&gt; &lt;/a&gt; (para la biblioteca de cadenas) Biblioteca UTF8), &lt;a id=&quot;pdf-luaopen_table&quot;&gt; &lt;code&gt;luaopen_table&lt;/code&gt; &lt;/a&gt; (para la biblioteca de tablas), &lt;a id=&quot;pdf-luaopen_math&quot;&gt; &lt;code&gt;luaopen_math&lt;/code&gt; &lt;/a&gt; (para la biblioteca matem&amp;aacute;tica), &lt;a id=&quot;pdf-luaopen_io&quot;&gt; &lt;code&gt;luaopen_io&lt;/code&gt; &lt;/a&gt; (para la biblioteca de E / S), &lt;a id=&quot;pdf-luaopen_os&quot;&gt; &lt;code&gt;luaopen_os&lt;/code&gt; &lt;/a&gt;(para la biblioteca del sistema operativo) y &lt;a id=&quot;pdf-luaopen_debug&quot;&gt; &lt;code&gt;luaopen_debug&lt;/code&gt; &lt;/a&gt; (para la biblioteca de depuraci&amp;oacute;n). Estas funciones est&amp;aacute;n declaradas en &lt;a id=&quot;pdf-lualib.h&quot;&gt; &lt;code&gt;lualib.h&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7497be5097473a583f39ec52ec425732f31d8c7" translate="yes" xml:space="preserve">
          <source>To resume a coroutine, you remove any results from the last &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;, put on its stack only the values to be passed as results from &lt;code&gt;yield&lt;/code&gt;, and then call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para reanudar una corrutina, elimine cualquier resultado del &amp;uacute;ltimo &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; , coloque en su pila solo los valores que se pasar&amp;aacute;n como resultados de &lt;code&gt;yield&lt;/code&gt; y luego llame a &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a9f2afcc694b7e6e7b0ece4b95a9b31851f835d" translate="yes" xml:space="preserve">
          <source>To resume a coroutine, you remove the &lt;code&gt;*nresults&lt;/code&gt; yielded values from its stack, push the values to be passed as results from &lt;code&gt;yield&lt;/code&gt;, and then call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5749af8d5e7fed727ed35d15b38114e430080b8" translate="yes" xml:space="preserve">
          <source>To start a coroutine, you push onto the thread stack the main function plus any arguments; then you call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, with &lt;code&gt;nargs&lt;/code&gt; being the number of arguments. This call returns when the coroutine suspends or finishes its execution. When it returns, the stack contains all values passed to &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;, or all values returned by the body function. &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the coroutine yields, &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; if the coroutine finishes its execution without errors, or an error code in case of errors (see &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Para iniciar una corrutina, empuja en la pila de subprocesos la funci&amp;oacute;n principal m&amp;aacute;s cualquier argumento; luego llama a &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; , siendo &lt;code&gt;nargs&lt;/code&gt; el n&amp;uacute;mero de argumentos. Esta llamada regresa cuando la corrutina suspende o finaliza su ejecuci&amp;oacute;n. Cuando regresa, la pila contiene todos los valores pasados ​​a &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; , o todos los valores devueltos por la funci&amp;oacute;n body. &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; devuelve &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; si la corrutina cede, &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; si la corrutina termina su ejecuci&amp;oacute;n sin errores, o un c&amp;oacute;digo de error en caso de errores (ver &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="76e8f3d7e170acca1d21ee8a1e8c4351dd451abd" translate="yes" xml:space="preserve">
          <source>To start a coroutine, you push the main function plus any arguments onto the empty stack of the thread. then you call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, with &lt;code&gt;nargs&lt;/code&gt; being the number of arguments. This call returns when the coroutine suspends or finishes its execution. When it returns, &lt;code&gt;*nresults&lt;/code&gt; is updated and the top of the stack contains the &lt;code&gt;*nresults&lt;/code&gt; values passed to &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt; or returned by the body function. &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the coroutine yields, &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; if the coroutine finishes its execution without errors, or an error code in case of errors (see &lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt;). In case of errors, the error object is on the top of the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a41adffb8d584e7921f8216490fc0912471c5b7" translate="yes" xml:space="preserve">
          <source>To-be-closed Variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cdc79b068557cc0be76c7d7fde8401dd4f7da9e" translate="yes" xml:space="preserve">
          <source>Tries to convert a Lua float to a Lua integer; the float &lt;code&gt;n&lt;/code&gt; must have an integral value. If that value is within the range of Lua integers, it is converted to an integer and assigned to &lt;code&gt;*p&lt;/code&gt;. The macro results in a boolean indicating whether the conversion was successful. (Note that this range test can be tricky to do correctly without this macro, due to rounding.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a3a0ec973c2479f00cc8910cb72beb238ed2cd" translate="yes" xml:space="preserve">
          <source>Type for C functions.</source>
          <target state="translated">Escriba para las funciones C.</target>
        </trans-unit>
        <trans-unit id="bbac79126ad582b607fa7de417480b28246073cf" translate="yes" xml:space="preserve">
          <source>Type for a &lt;em&gt;string buffer&lt;/em&gt;.</source>
          <target state="translated">Escriba para un &lt;em&gt;b&amp;uacute;fer de cadena&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="597df46ee98db369cefa88ec65178daff885f4c9" translate="yes" xml:space="preserve">
          <source>Type for arrays of functions to be registered by &lt;a href=&quot;#luaL_setfuncs&quot;&gt;&lt;code&gt;luaL_setfuncs&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the function name and &lt;code&gt;func&lt;/code&gt; is a pointer to the function. Any array of &lt;a href=&quot;#luaL_Reg&quot;&gt;&lt;code&gt;luaL_Reg&lt;/code&gt;&lt;/a&gt; must end with a sentinel entry in which both &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;func&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Escriba para las matrices de funciones que va a registrar &lt;a href=&quot;#luaL_setfuncs&quot;&gt; &lt;code&gt;luaL_setfuncs&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;name&lt;/code&gt; es el nombre de la funci&amp;oacute;n y &lt;code&gt;func&lt;/code&gt; es un puntero a la funci&amp;oacute;n. Cualquier matriz de &lt;a href=&quot;#luaL_Reg&quot;&gt; &lt;code&gt;luaL_Reg&lt;/code&gt; &lt;/a&gt; debe terminar con una entrada centinela en la que tanto el &lt;code&gt;name&lt;/code&gt; como la &lt;code&gt;func&lt;/code&gt; i&amp;oacute;n son &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7262eb2a012a409a0b60efe4a99f259fc3c90346" translate="yes" xml:space="preserve">
          <source>Type for continuation functions (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97624a7d15b8942c923346eb9827dfe7da1b1df0" translate="yes" xml:space="preserve">
          <source>Type for continuation functions (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">Escriba para funciones de continuaci&amp;oacute;n (consulte &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="24445b5aafedd0f5dd84a959ce49844260c89cd8" translate="yes" xml:space="preserve">
          <source>Type for debugging hook functions.</source>
          <target state="translated">Tipo para depurar las funciones de los ganchos.</target>
        </trans-unit>
        <trans-unit id="bd045f19fb648f6e2a8a5ad73d4fd1e6a85d7f43" translate="yes" xml:space="preserve">
          <source>Typically this function is used only for hashing and debug information.</source>
          <target state="translated">Típicamente,esta función se utiliza sólo para el hashing y la depuración de la información.</target>
        </trans-unit>
        <trans-unit id="82aace29da601638b56c7fcfaece961d82f801a3" translate="yes" xml:space="preserve">
          <source>Typically, the message handler is used to add more debug information to the error object, such as a stack traceback. Such information cannot be gathered after the return of &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, since by then the stack has unwound.</source>
          <target state="translated">Normalmente, el controlador de mensajes se utiliza para agregar m&amp;aacute;s informaci&amp;oacute;n de depuraci&amp;oacute;n al objeto de error, como un seguimiento de pila. Dicha informaci&amp;oacute;n no se puede recopilar despu&amp;eacute;s del retorno de &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; , ya que para entonces la pila se ha desenrollado.</target>
        </trans-unit>
        <trans-unit id="c9efe5a42434457d2c52ab4c0d1415d4bcf07916" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all I/O functions return &lt;b&gt;fail&lt;/b&gt; on failure, plus an error message as a second result and a system-dependent error code as a third result, and some non-false value on success. On non-POSIX systems, the computation of the error message and error code in case of errors may be not thread safe, because they rely on the global C variable &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31727baa3a70e03cfa1528c55a7acf86c6c0a582" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all I/O functions return &lt;b&gt;nil&lt;/b&gt; on failure (plus an error message as a second result and a system-dependent error code as a third result) and some value different from &lt;b&gt;nil&lt;/b&gt; on success. On non-POSIX systems, the computation of the error message and error code in case of errors may be not thread safe, because they rely on the global C variable &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">A menos que se indique lo contrario, todas las funciones de E / S devuelven &lt;b&gt;cero&lt;/b&gt; en caso de falla (m&amp;aacute;s un mensaje de error como segundo resultado y un c&amp;oacute;digo de error dependiente del sistema como tercer resultado) y alg&amp;uacute;n valor diferente de &lt;b&gt;cero&lt;/b&gt; en caso de &amp;eacute;xito. En sistemas que no son POSIX, el c&amp;aacute;lculo del mensaje de error y el c&amp;oacute;digo de error en caso de errores puede no ser seguro para subprocesos, ya que se basan en la variable C global &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b52e7d27a22d0d612f9608bbf1f1eccee941606" translate="yes" xml:space="preserve">
          <source>Unless stated otherwise, all functions that expect a byte position as a parameter assume that the given position is either the start of a byte sequence or one plus the length of the subject string. As in the string library, negative indices count from the end of the string.</source>
          <target state="translated">A menos que se indique lo contrario,todas las funciones que esperan una posición de byte como parámetro asumen que la posición dada es el comienzo de una secuencia de bytes o una más la longitud de la cadena del sujeto.Como en la biblioteca de cadenas,los índices negativos cuentan desde el final de la cadena.</target>
        </trans-unit>
        <trans-unit id="4b92e3ee7788b339628f8fb046cb8cb890dfc063" translate="yes" xml:space="preserve">
          <source>Unless stated otherwise, any overflow when manipulating integer values &lt;em&gt;wrap around&lt;/em&gt;, according to the usual rules of two-complement arithmetic. (In other words, the actual result is the unique representable integer that is equal modulo &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; to the mathematical result, where &lt;em&gt;n&lt;/em&gt; is the number of bits of the integer type.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b21f366bd62c88e740589d6190f38930d6eeac" translate="yes" xml:space="preserve">
          <source>Unlike other push functions, this function checks for the stack space it needs, including the slot for its result.</source>
          <target state="translated">A diferencia de otras funciones de empuje,esta función comprueba el espacio de pila que necesita,incluyendo la ranura para su resultado.</target>
        </trans-unit>
        <trans-unit id="2e42ec0a938ed392af0043f9b91ccccb6b8e5563" translate="yes" xml:space="preserve">
          <source>Upvalues have no particular order, as they are active through the whole function. They are numbered in an arbitrary order.</source>
          <target state="translated">Los valores ascendentes no tienen un orden particular,ya que están activos a través de toda la función.Están numerados en un orden arbitrario.</target>
        </trans-unit>
        <trans-unit id="76f521b6a8d60e44bede4ff94d2d23d25dcfafa8" translate="yes" xml:space="preserve">
          <source>Userdata represent C values in Lua. A &lt;em&gt;light userdata&lt;/em&gt; represents a pointer, a &lt;code&gt;void*&lt;/code&gt;. It is a value (like a number): you do not create it, it has no individual metatable, and it is not collected (as it was never created). A light userdata is equal to &quot;any&quot; light userdata with the same C address.</source>
          <target state="translated">Los datos de usuario representan valores C en Lua. Un &lt;em&gt;usuario claro&lt;/em&gt; representa un puntero, un &lt;code&gt;void*&lt;/code&gt; . Es un valor (como un n&amp;uacute;mero): no lo creas, no tiene metatabla individual y no se recopila (ya que nunca se cre&amp;oacute;). Un dato de usuario ligero es igual a &quot;cualquier&quot; dato de usuario ligero con la misma direcci&amp;oacute;n C.</target>
        </trans-unit>
        <trans-unit id="e39e23cf8cc12b3b818ae1cbbd67ab727cb6080a" translate="yes" xml:space="preserve">
          <source>Usually, &lt;code&gt;error&lt;/code&gt; adds some information about the error position at the beginning of the message, if the message is a string. The &lt;code&gt;level&lt;/code&gt; argument specifies how to get the error position. With level 1 (the default), the error position is where the &lt;code&gt;error&lt;/code&gt; function was called. Level 2 points the error to where the function that called &lt;code&gt;error&lt;/code&gt; was called; and so on. Passing a level 0 avoids the addition of error position information to the message.</source>
          <target state="translated">Normalmente, &lt;code&gt;error&lt;/code&gt; agrega informaci&amp;oacute;n sobre la posici&amp;oacute;n del error al principio del mensaje, si el mensaje es una cadena. El argumento de &lt;code&gt;level&lt;/code&gt; especifica c&amp;oacute;mo obtener la posici&amp;oacute;n del error. Con el nivel 1 (predeterminado), la posici&amp;oacute;n de error es donde se llam&amp;oacute; a la funci&amp;oacute;n de &lt;code&gt;error&lt;/code&gt; . El nivel 2 se&amp;ntilde;ala el error al lugar donde se llam&amp;oacute; a la funci&amp;oacute;n que llam&amp;oacute; al &lt;code&gt;error&lt;/code&gt; ; y as&amp;iacute;. Pasar un nivel 0 evita la adici&amp;oacute;n de informaci&amp;oacute;n de posici&amp;oacute;n de error al mensaje.</target>
        </trans-unit>
        <trans-unit id="a5ec00a8e6ea1cb6546f41d42ab21ccdd067623e" translate="yes" xml:space="preserve">
          <source>Usually, this function does not return; when the coroutine eventually resumes, it continues executing the continuation function. However, there is one special case, which is when this function is called from inside a line or a count hook (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). In that case, &lt;code&gt;lua_yieldk&lt;/code&gt; should be called with no continuation (probably in the form of &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;) and no results, and the hook should return immediately after the call. Lua will yield and, when the coroutine resumes again, it will continue the normal execution of the (Lua) function that triggered the hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede0ea911a1e4e16232a1c52be2e25bf93574b23" translate="yes" xml:space="preserve">
          <source>Usually, this function does not return; when the coroutine eventually resumes, it continues executing the continuation function. However, there is one special case, which is when this function is called from inside a line or a count hook (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;). In that case, &lt;code&gt;lua_yieldk&lt;/code&gt; should be called with no continuation (probably in the form of &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;) and no results, and the hook should return immediately after the call. Lua will yield and, when the coroutine resumes again, it will continue the normal execution of the (Lua) function that triggered the hook.</source>
          <target state="translated">Generalmente, esta funci&amp;oacute;n no regresa; cuando finalmente se reanuda la corrutina, contin&amp;uacute;a ejecutando la funci&amp;oacute;n de continuaci&amp;oacute;n. Sin embargo, hay un caso especial, que es cuando esta funci&amp;oacute;n se llama desde dentro de una l&amp;iacute;nea o un gancho de conteo (ver &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt; ). En ese caso, se deber&amp;iacute;a llamar a &lt;code&gt;lua_yieldk&lt;/code&gt; sin continuaci&amp;oacute;n (probablemente en forma de &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; ) y sin resultados, y el gancho deber&amp;iacute;a regresar inmediatamente despu&amp;eacute;s de la llamada. Lua ceder&amp;aacute; y, cuando la corrutina se reanude nuevamente, continuar&amp;aacute; la ejecuci&amp;oacute;n normal de la funci&amp;oacute;n (Lua) que activ&amp;oacute; el gancho.</target>
        </trans-unit>
        <trans-unit id="d093e0dbaa7c773904acc28ac0d7a51be7670739" translate="yes" xml:space="preserve">
          <source>Valid and Acceptable Indices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14347ed892514b4d69c3b3bf601cd9c8fb3e904b" translate="yes" xml:space="preserve">
          <source>Values and Types</source>
          <target state="translated">Valores y tipos</target>
        </trans-unit>
        <trans-unit id="f5b9087c637e2bfd3e2cf26a4d45a4be30f815bf" translate="yes" xml:space="preserve">
          <source>Variable name '&lt;code&gt;?&lt;/code&gt;' (interrogation mark) represents variables with no known names (variables from chunks saved without debug information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12bad2c7ac94b1eae85bb4982ce9b8d423815b52" translate="yes" xml:space="preserve">
          <source>Variable names starting with '&lt;code&gt;(&lt;/code&gt;' (open parenthesis) represent variables with no known names (internal variables such as loop control variables, and variables from chunks saved without debug information).</source>
          <target state="translated">Los nombres de variable que comienzan con ' &lt;code&gt;(&lt;/code&gt; ' (par&amp;eacute;ntesis abierto) representan variables sin nombres conocidos (variables internas como variables de control de bucle y variables de fragmentos guardados sin informaci&amp;oacute;n de depuraci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="91ca405a6bcded978537314760080c405ac3d0b7" translate="yes" xml:space="preserve">
          <source>Variable names starting with '&lt;code&gt;(&lt;/code&gt;' (open parenthesis) represent variables with no known names (variables from chunks saved without debug information).</source>
          <target state="translated">Los nombres de variables que comienzan con ' &lt;code&gt;(&lt;/code&gt; ' (par&amp;eacute;ntesis abierto) representan variables sin nombres conocidos (variables de fragmentos guardados sin informaci&amp;oacute;n de depuraci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="be26bb31c1703ed9ce7e9ecf54d6a6a8c765c6e5" translate="yes" xml:space="preserve">
          <source>Variables are places that store values. There are three kinds of variables in Lua: global variables, local variables, and table fields.</source>
          <target state="translated">Las variables son lugares que almacenan valores.Hay tres tipos de variables en Lua:variables globales,locales y campos de tablas.</target>
        </trans-unit>
        <trans-unit id="c95e5bb697c2902b5736feab85b400b53ef72faf" translate="yes" xml:space="preserve">
          <source>Visibility Rules</source>
          <target state="translated">Reglas de visibilidad</target>
        </trans-unit>
        <trans-unit id="e3ca3a5141d9967c701776eca46ec10c9e635787" translate="yes" xml:space="preserve">
          <source>We can specify any byte in a short literal string by its numeric value (including embedded zeros). This can be done with the escape sequence &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;XX&lt;/em&gt; is a sequence of exactly two hexadecimal digits, or with the escape sequence &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;ddd&lt;/em&gt; is a sequence of up to three decimal digits. (Note that if a decimal escape sequence is to be followed by a digit, it must be expressed using exactly three digits.)</source>
          <target state="translated">Podemos especificar cualquier byte en una cadena literal corta por su valor num&amp;eacute;rico (incluidos los ceros incrustados). Esto se puede hacer con la secuencia de escape &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt; , donde &lt;em&gt;XX&lt;/em&gt; es una secuencia de exactamente dos d&amp;iacute;gitos hexadecimales, o con la secuencia de escape &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt; , donde &lt;em&gt;ddd&lt;/em&gt; es una secuencia de hasta tres d&amp;iacute;gitos decimales. (Tenga en cuenta que si una secuencia de escape decimal debe ir seguida de un d&amp;iacute;gito, debe expresarse utilizando exactamente tres d&amp;iacute;gitos).</target>
        </trans-unit>
        <trans-unit id="588ae2cdfea2aa5958efa441455bc701b5efa923" translate="yes" xml:space="preserve">
          <source>We can specify any byte in a short literal string, including embedded zeros, by its numeric value. This can be done with the escape sequence &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;XX&lt;/em&gt; is a sequence of exactly two hexadecimal digits, or with the escape sequence &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;ddd&lt;/em&gt; is a sequence of up to three decimal digits. (Note that if a decimal escape sequence is to be followed by a digit, it must be expressed using exactly three digits.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75447b7504738d77e48aaf615cad9ff4faa5f14" translate="yes" xml:space="preserve">
          <source>We need to set some terminology to explain continuations. We have a C function called from Lua which we will call the &lt;em&gt;original function&lt;/em&gt;. This original function then calls one of those three functions in the C API, which we will call the &lt;em&gt;callee function&lt;/em&gt;, that then yields the current thread. (This can happen when the callee function is &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, or when the callee function is either &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; and the function called by them yields.)</source>
          <target state="translated">Necesitamos establecer alguna terminolog&amp;iacute;a para explicar las continuaciones. Tenemos una funci&amp;oacute;n en C llamada desde Lua a la que llamaremos la &lt;em&gt;funci&amp;oacute;n original&lt;/em&gt; . Esta funci&amp;oacute;n original luego llama a una de esas tres funciones en la API de C, que llamaremos la &lt;em&gt;funci&amp;oacute;n de&lt;/em&gt; llamada , que luego produce el hilo actual. (Esto puede suceder cuando la funci&amp;oacute;n llamada es &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; , o cuando la funci&amp;oacute;n llamada es &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; y la funci&amp;oacute;n llamada por ellos cede).</target>
        </trans-unit>
        <trans-unit id="50c12071f88d71d4186a342c705d8f1079d28abd" translate="yes" xml:space="preserve">
          <source>We need to set some terminology to explain continuations. We have a C function called from Lua which we will call the &lt;em&gt;original function&lt;/em&gt;. This original function then calls one of those three functions in the C API, which we will call the &lt;em&gt;callee function&lt;/em&gt;, that then yields the current thread. This can happen when the callee function is &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, or when the callee function is either &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; and the function called by them yields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41db10b358155f4f013d45b45675b34f33d9ed3" translate="yes" xml:space="preserve">
          <source>Weak Tables</source>
          <target state="translated">Tablas débiles</target>
        </trans-unit>
        <trans-unit id="b484eff0d117b27e8defcec4a0326a877ca574fe" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;n&lt;/code&gt; is zero, this function creates a &lt;em&gt;light C function&lt;/em&gt;, which is just a pointer to the C function. In that case, it never raises a memory error.</source>
          <target state="translated">Cuando &lt;code&gt;n&lt;/code&gt; es cero, esta funci&amp;oacute;n crea una &lt;em&gt;funci&amp;oacute;n C ligera&lt;/em&gt; , que es solo un puntero a la funci&amp;oacute;n C. En ese caso, nunca genera un error de memoria.</target>
        </trans-unit>
        <trans-unit id="341c8ac217813125623e3b1667a920259b68f995" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is not zero, the allocator must behave like &lt;code&gt;realloc&lt;/code&gt;. In particular, the allocator returns &lt;code&gt;NULL&lt;/code&gt; if and only if it cannot fulfill the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996f3bf8346e25b1239b5ab5057ae46c604d1002" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is not zero, the allocator must behave like &lt;code&gt;realloc&lt;/code&gt;. The allocator returns &lt;code&gt;NULL&lt;/code&gt; if and only if it cannot fulfill the request. Lua assumes that the allocator never fails when &lt;code&gt;osize &amp;gt;= nsize&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;nsize&lt;/code&gt; no es cero, el asignador debe comportarse como &lt;code&gt;realloc&lt;/code&gt; . El asignador devuelve &lt;code&gt;NULL&lt;/code&gt; si y solo si no puede cumplir con la solicitud. Lua asume que el asignador nunca falla cuando &lt;code&gt;osize &amp;gt;= nsize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be7cbd666142d4c0c3a8b1ac15f72ec90fcd56bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is zero, the allocator must behave like &lt;code&gt;free&lt;/code&gt; and return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;nsize&lt;/code&gt; es cero, el asignador debe comportarse como &lt;code&gt;free&lt;/code&gt; y devolver &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c59226f69b5bf9ddb3f25a1bd10f5e6547c8ad04" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is zero, the allocator must behave like &lt;code&gt;free&lt;/code&gt; and then return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63de127a2c08c3b5f3fa7d7ca6251d5614a09288" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nup&lt;/code&gt; is not zero, all functions are created sharing &lt;code&gt;nup&lt;/code&gt; upvalues, which must be previously pushed on the stack on top of the library table. These values are popped from the stack after the registration.</source>
          <target state="translated">Cuando &lt;code&gt;nup&lt;/code&gt; no es cero, todas las funciones se crean compartiendo &lt;code&gt;nup&lt;/code&gt; upvalues, que se deben colocar previamente en la pila en la parte superior de la tabla de la biblioteca. Estos valores se extraen de la pila despu&amp;eacute;s del registro.</target>
        </trans-unit>
        <trans-unit id="954632ad2b6013e35487b453af471fab7d911066" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nup&lt;/code&gt; is not zero, all functions are created with &lt;code&gt;nup&lt;/code&gt; upvalues, initialized with copies of the &lt;code&gt;nup&lt;/code&gt; values previously pushed on the stack on top of the library table. These values are popped from the stack after the registration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="335a5475dbcacbd9ecdd1054fd0513668a84ec31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ptr&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;osize&lt;/code&gt; encodes the kind of object that Lua is allocating. &lt;code&gt;osize&lt;/code&gt; is any of &lt;a href=&quot;#pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt; when (and only when) Lua is creating a new object of that type. When &lt;code&gt;osize&lt;/code&gt; is some other value, Lua is allocating memory for something else.</source>
          <target state="translated">Cuando &lt;code&gt;ptr&lt;/code&gt; es &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;osize&lt;/code&gt; codifica el tipo de objeto que Lua est&amp;aacute; asignando. &lt;code&gt;osize&lt;/code&gt; es cualquiera de &lt;a href=&quot;#pdf-LUA_TSTRING&quot;&gt; &lt;code&gt;LUA_TSTRING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_TTABLE&quot;&gt; &lt;code&gt;LUA_TTABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_TFUNCTION&quot;&gt; &lt;code&gt;LUA_TFUNCTION&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_TUSERDATA&quot;&gt; &lt;code&gt;LUA_TUSERDATA&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#pdf-LUA_TTHREAD&quot;&gt; &lt;code&gt;LUA_TTHREAD&lt;/code&gt; &lt;/a&gt; cuando (y solo cuando) Lua est&amp;aacute; creando un nuevo objeto de ese tipo. Cuando &lt;code&gt;osize&lt;/code&gt; es alg&amp;uacute;n otro valor, Lua est&amp;aacute; asignando memoria para otra cosa.</target>
        </trans-unit>
        <trans-unit id="46d45ecf04d4c4d9ebff91c3f78c309dab0e87ef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ptr&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;osize&lt;/code&gt; is the size of the block pointed by &lt;code&gt;ptr&lt;/code&gt;, that is, the size given when it was allocated or reallocated.</source>
          <target state="translated">Cuando &lt;code&gt;ptr&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;osize&lt;/code&gt; es el tama&amp;ntilde;o del bloque se&amp;ntilde;alado por &lt;code&gt;ptr&lt;/code&gt; , es decir, el tama&amp;ntilde;o dado cuando fue asignado o reasignado.</target>
        </trans-unit>
        <trans-unit id="0344be77d1524703e63d720dcdc36380a6d9b380" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;t&lt;/code&gt; is a sequence, &lt;code&gt;#t&lt;/code&gt; returns its only border, which corresponds to the intuitive notion of the length of the sequence. When &lt;code&gt;t&lt;/code&gt; is not a sequence, &lt;code&gt;#t&lt;/code&gt; can return any of its borders. (The exact one depends on details of the internal representation of the table, which in turn can depend on how the table was populated and the memory addresses of its non-numeric keys.)</source>
          <target state="translated">Cuando &lt;code&gt;t&lt;/code&gt; es una secuencia, &lt;code&gt;#t&lt;/code&gt; devuelve su &amp;uacute;nico borde, que corresponde a la noci&amp;oacute;n intuitiva de la longitud de la secuencia. Cuando &lt;code&gt;t&lt;/code&gt; no es una secuencia, &lt;code&gt;#t&lt;/code&gt; puede devolver cualquiera de sus bordes. (El exacto depende de los detalles de la representaci&amp;oacute;n interna de la tabla, que a su vez puede depender de c&amp;oacute;mo se llen&amp;oacute; la tabla y las direcciones de memoria de sus claves no num&amp;eacute;ricas).</target>
        </trans-unit>
        <trans-unit id="3c915266f11381b28c8d7b3533ebdd9fec110c77" translate="yes" xml:space="preserve">
          <source>When Lua loads a chunk, the default value for its &lt;code&gt;_ENV&lt;/code&gt; upvalue is the global environment (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;). Therefore, by default, free names in Lua code refer to entries in the global environment (and, therefore, they are also called &lt;em&gt;global variables&lt;/em&gt;). Moreover, all standard libraries are loaded in the global environment and some functions there operate on that environment. You can use &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#pdf-loadfile&quot;&gt;&lt;code&gt;loadfile&lt;/code&gt;&lt;/a&gt;) to load a chunk with a different environment. (In C, you have to load the chunk and then change the value of its first upvalue.)</source>
          <target state="translated">Cuando Lua carga un fragmento, el valor predeterminado para su valor de &lt;code&gt;_ENV&lt;/code&gt; _ENV es el entorno global (ver &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; ). Por lo tanto, de forma predeterminada, los nombres libres en el c&amp;oacute;digo Lua se refieren a entradas en el entorno global (y, por lo tanto, tambi&amp;eacute;n se denominan &lt;em&gt;variables globales&lt;/em&gt; ). Adem&amp;aacute;s, todas las bibliotecas est&amp;aacute;ndar se cargan en el entorno global y algunas funciones all&amp;iacute; operan en ese entorno. Puede usar &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; (o &lt;a href=&quot;#pdf-loadfile&quot;&gt; &lt;code&gt;loadfile&lt;/code&gt; &lt;/a&gt; ) para cargar un fragmento con un entorno diferente. (En C, debe cargar el fragmento y luego cambiar el valor de su primer valor ascendente).</target>
        </trans-unit>
        <trans-unit id="22c2aab30b39695e8a73be14337c6b9195ec6401" translate="yes" xml:space="preserve">
          <source>When Lua loads a chunk, the default value for its &lt;code&gt;_ENV&lt;/code&gt; variable is the global environment (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;). Therefore, by default, free names in Lua code refer to entries in the global environment and, therefore, they are also called &lt;em&gt;global variables&lt;/em&gt;. Moreover, all standard libraries are loaded in the global environment and some functions there operate on that environment. You can use &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#pdf-loadfile&quot;&gt;&lt;code&gt;loadfile&lt;/code&gt;&lt;/a&gt;) to load a chunk with a different environment. (In C, you have to load the chunk and then change the value of its first upvalue; see &lt;a href=&quot;#lua_setupvalue&quot;&gt;&lt;code&gt;lua_setupvalue&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf5cddf64fd956b790dcd47186d571d0648ca7d" translate="yes" xml:space="preserve">
          <source>When a C function calls &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, the running coroutine suspends its execution, and the call to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; that started this coroutine returns. The parameter &lt;code&gt;nresults&lt;/code&gt; is the number of values from the stack that will be passed as results to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cuando una funci&amp;oacute;n de C llama a &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; , la corrutina en ejecuci&amp;oacute;n suspende su ejecuci&amp;oacute;n y la llamada a &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; que inici&amp;oacute; esta corrutina regresa. El par&amp;aacute;metro &lt;code&gt;nresults&lt;/code&gt; es el n&amp;uacute;mero de valores de la pila que se pasar&amp;aacute;n como resultados a &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f9fd5a034919e5ee7025d158d3271b1427b5c02" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, the so called upvalues; these upvalues are then accessible to the function whenever it is called. This association is called a C closure (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;). To create a C closure, first the initial values for its upvalues must be pushed onto the stack. (When there are multiple upvalues, the first value is pushed first.) Then &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; is called to create and push the C function onto the stack, with the argument &lt;code&gt;n&lt;/code&gt; telling how many values will be associated with the function. &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; also pops these values from the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6587795ac24fa71cf1c2a7e27096b42bc7a40713" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, thus creating a &lt;em&gt;C closure&lt;/em&gt; (see &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt;); these values are called &lt;em&gt;upvalues&lt;/em&gt; and are accessible to the function whenever it is called.</source>
          <target state="translated">Cuando se crea una funci&amp;oacute;n en C, es posible asociar algunos valores con ella, creando as&amp;iacute; un &lt;em&gt;cierre C&lt;/em&gt; (ver &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; ); estos valores se denominan &lt;em&gt;upvalues&lt;/em&gt; y la funci&amp;oacute;n puede acceder a ellos siempre que se llame.</target>
        </trans-unit>
        <trans-unit id="11ab54e362e4ae46fe6b07e57d87eadd11f23cbe" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, thus creating a C closure (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;); these values are then accessible to the function whenever it is called. To associate values with a C function, first these values must be pushed onto the stack (when there are multiple values, the first value is pushed first). Then &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; is called to create and push the C function onto the stack, with the argument &lt;code&gt;n&lt;/code&gt; telling how many values will be associated with the function. &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; also pops these values from the stack.</source>
          <target state="translated">Cuando se crea una funci&amp;oacute;n C, es posible asociarle algunos valores, creando as&amp;iacute; un cierre C (ver &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; ); estos valores son accesibles a la funci&amp;oacute;n cada vez que se llama. Para asociar valores con una funci&amp;oacute;n C, primero estos valores deben insertarse en la pila (cuando hay varios valores, el primer valor se inserta primero). Luego, se llama a &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; para crear y enviar la funci&amp;oacute;n C a la pila, con el argumento &lt;code&gt;n&lt;/code&gt; indicando cu&amp;aacute;ntos valores se asociar&amp;aacute;n con la funci&amp;oacute;n. &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n extrae estos valores de la pila.</target>
        </trans-unit>
        <trans-unit id="f143d2ac13b52a6742b50e250fa83e180f7c76c7" translate="yes" xml:space="preserve">
          <source>When a Lua function is called, it adjusts its list of arguments to the length of its list of parameters, unless the function is a &lt;em&gt;vararg function&lt;/em&gt;, which is indicated by three dots ('&lt;code&gt;...&lt;/code&gt;') at the end of its parameter list. A vararg function does not adjust its argument list; instead, it collects all extra arguments and supplies them to the function through a &lt;em&gt;vararg expression&lt;/em&gt;, which is also written as three dots. The value of this expression is a list of all actual extra arguments, similar to a function with multiple results. If a vararg expression is used inside another expression or in the middle of a list of expressions, then its return list is adjusted to one element. If the expression is used as the last element of a list of expressions, then no adjustment is made (unless that last expression is enclosed in parentheses).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e078eea66272045084e3f01aa8c505b53aa0ead0" translate="yes" xml:space="preserve">
          <source>When a function is called, the list of arguments is adjusted to the length of the list of parameters, unless the function is a &lt;em&gt;vararg function&lt;/em&gt;, which is indicated by three dots ('&lt;code&gt;...&lt;/code&gt;') at the end of its parameter list. A vararg function does not adjust its argument list; instead, it collects all extra arguments and supplies them to the function through a &lt;em&gt;vararg expression&lt;/em&gt;, which is also written as three dots. The value of this expression is a list of all actual extra arguments, similar to a function with multiple results. If a vararg expression is used inside another expression or in the middle of a list of expressions, then its return list is adjusted to one element. If the expression is used as the last element of a list of expressions, then no adjustment is made (unless that last expression is enclosed in parentheses).</source>
          <target state="translated">Cuando se llama a una funci&amp;oacute;n, la lista de argumentos se ajusta a la longitud de la lista de par&amp;aacute;metros, a menos que la funci&amp;oacute;n sea una &lt;em&gt;funci&amp;oacute;n vararg&lt;/em&gt; , que se indica con tres puntos (' &lt;code&gt;...&lt;/code&gt; ') al final de su lista de par&amp;aacute;metros. Una funci&amp;oacute;n vararg no ajusta su lista de argumentos; en su lugar, recopila todos los argumentos adicionales y los proporciona a la funci&amp;oacute;n a trav&amp;eacute;s de una &lt;em&gt;expresi&amp;oacute;n vararg&lt;/em&gt;, que tambi&amp;eacute;n se escribe como tres puntos. El valor de esta expresi&amp;oacute;n es una lista de todos los argumentos adicionales reales, similar a una funci&amp;oacute;n con m&amp;uacute;ltiples resultados. Si se usa una expresi&amp;oacute;n vararg dentro de otra expresi&amp;oacute;n o en medio de una lista de expresiones, entonces su lista de retorno se ajusta a un elemento. Si la expresi&amp;oacute;n se utiliza como &amp;uacute;ltimo elemento de una lista de expresiones, no se realiza ning&amp;uacute;n ajuste (a menos que la &amp;uacute;ltima expresi&amp;oacute;n est&amp;eacute; entre par&amp;eacute;ntesis).</target>
        </trans-unit>
        <trans-unit id="a989335dc83d50af6f8884cd0fdec47036abae37" translate="yes" xml:space="preserve">
          <source>When a marked object becomes dead, it is not collected immediately by the garbage collector. Instead, Lua puts it in a list. After the collection, Lua goes through that list. For each object in the list, it checks the object's &lt;code&gt;__gc&lt;/code&gt; metamethod: If it is present, Lua calls it with the object as its single argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6fe573488f94135e6cdc83d520dc4a94e938c8" translate="yes" xml:space="preserve">
          <source>When a marked object becomes garbage, it is not collected immediately by the garbage collector. Instead, Lua puts it in a list. After the collection, Lua goes through that list. For each object in the list, it checks the object's &lt;code&gt;__gc&lt;/code&gt; metamethod: If it is a function, Lua calls it with the object as its single argument; if the metamethod is not a function, Lua simply ignores it.</source>
          <target state="translated">Cuando un objeto marcado se convierte en basura, el recolector de basura no lo recoge inmediatamente. En cambio, Lua lo pone en una lista. Despu&amp;eacute;s de la colecci&amp;oacute;n, Lua revisa esa lista. Para cada objeto en la lista, verifica el &lt;code&gt;__gc&lt;/code&gt; __gc del objeto : si es una funci&amp;oacute;n, Lua la llama con el objeto como su &amp;uacute;nico argumento; si el metam&amp;eacute;todo no es una funci&amp;oacute;n, Lua simplemente lo ignora.</target>
        </trans-unit>
        <trans-unit id="80897f837555b95f2cb104a59226a4a40d8e481f" translate="yes" xml:space="preserve">
          <source>When called with &lt;b&gt;nil&lt;/b&gt; as the first argument, this function only returns the name of the current locale for the given category.</source>
          <target state="translated">Cuando se llama con &lt;b&gt;nil&lt;/b&gt; como primer argumento, esta funci&amp;oacute;n solo devuelve el nombre de la configuraci&amp;oacute;n regional actual para la categor&amp;iacute;a dada.</target>
        </trans-unit>
        <trans-unit id="12503992ba3e7b779eee88f9ab72a6febed44f13" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;base&lt;/code&gt;, then &lt;code&gt;e&lt;/code&gt; must be a string to be interpreted as an integer numeral in that base. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter '&lt;code&gt;A&lt;/code&gt;' (in either upper or lower case) represents 10, '&lt;code&gt;B&lt;/code&gt;' represents 11, and so forth, with '&lt;code&gt;Z&lt;/code&gt;' representing 35. If the string &lt;code&gt;e&lt;/code&gt; is not a valid numeral in the given base, the function returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641f9e62059a652c6e39c5a7f8f27534a9246ba4" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;base&lt;/code&gt;, then &lt;code&gt;e&lt;/code&gt; must be a string to be interpreted as an integer numeral in that base. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter '&lt;code&gt;A&lt;/code&gt;' (in either upper or lower case) represents 10, '&lt;code&gt;B&lt;/code&gt;' represents 11, and so forth, with '&lt;code&gt;Z&lt;/code&gt;' representing 35. If the string &lt;code&gt;e&lt;/code&gt; is not a valid numeral in the given base, the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Cuando se llama con &lt;code&gt;base&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; debe ser una cadena para ser interpretada como un n&amp;uacute;mero entero en esa base. La base puede ser cualquier n&amp;uacute;mero entero entre 2 y 36, inclusive. En las bases por encima de 10, la letra ' &lt;code&gt;A&lt;/code&gt; ' (en may&amp;uacute;sculas o min&amp;uacute;sculas) representa 10, ' &lt;code&gt;B&lt;/code&gt; ' representa 11, y as&amp;iacute; sucesivamente, con ' &lt;code&gt;Z&lt;/code&gt; ' representando 35. Si la cadena &lt;code&gt;e&lt;/code&gt; no es un n&amp;uacute;mero v&amp;aacute;lido en el base, la funci&amp;oacute;n devuelve &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="388bcef0db67f7e381df66c3f7ee8cf9b5be28dc" translate="yes" xml:space="preserve">
          <source>When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without arguments, it returns the current default input file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1235a6e1b0d97767a88001b252dc354fc4428a" translate="yes" xml:space="preserve">
          <source>When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file.</source>
          <target state="translated">Cuando se llama con un nombre de archivo,abre el archivo nombrado (en modo de texto),y establece su manija como el archivo de entrada predeterminado.Cuando se le llama con un nombre de archivo,simplemente establece este nombre de archivo como el archivo de entrada predeterminado.Cuando se llama sin parámetros,devuelve el archivo de entrada predeterminado actual.</target>
        </trans-unit>
        <trans-unit id="861fad074ef63ba8ca7f9ab877254b943a4b7908" translate="yes" xml:space="preserve">
          <source>When called with a table, &lt;code&gt;os.time&lt;/code&gt; also normalizes all the fields documented in the &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; function, so that they represent the same time as before the call but with values inside their valid ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b8d68eea93133c352fa9c0560fcd4d022359aa" translate="yes" xml:space="preserve">
          <source>When called with at least one argument, the integer parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are joined into a 128-bit &lt;em&gt;seed&lt;/em&gt; that is used to reinitialize the pseudo-random generator; equal seeds produce equal sequences of numbers. The default for &lt;code&gt;y&lt;/code&gt; is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0d3b8cfb48505757d0b30079cef91155c8b44b" translate="yes" xml:space="preserve">
          <source>When called with no &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;tonumber&lt;/code&gt; tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then &lt;code&gt;tonumber&lt;/code&gt; returns this number; otherwise, it returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0331839def59d1c279589644566be45521e46878" translate="yes" xml:space="preserve">
          <source>When called with no &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;tonumber&lt;/code&gt; tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then &lt;code&gt;tonumber&lt;/code&gt; returns this number; otherwise, it returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Cuando se llama sin &lt;code&gt;base&lt;/code&gt; , &lt;code&gt;tonumber&lt;/code&gt; intenta convertir su argumento en un n&amp;uacute;mero. Si el argumento ya es un n&amp;uacute;mero o una cadena convertible en un n&amp;uacute;mero, &lt;code&gt;tonumber&lt;/code&gt; devuelve este n&amp;uacute;mero; de lo contrario, devuelve &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2cf361fe46fad3d672a6b7fc3deab505bdbf7127" translate="yes" xml:space="preserve">
          <source>When called with no arguments, Lua generates a seed with a weak attempt for randomness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e694403948e49c3cdfc8883a69a69e59e1e2c12c" translate="yes" xml:space="preserve">
          <source>When called with option &lt;code&gt;-E&lt;/code&gt;, besides ignoring &lt;code&gt;LUA_INIT&lt;/code&gt;, Lua also ignores the values of &lt;code&gt;LUA_PATH&lt;/code&gt; and &lt;code&gt;LUA_CPATH&lt;/code&gt;, setting the values of &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; with the default paths defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">Cuando se llama con la opci&amp;oacute;n &lt;code&gt;-E&lt;/code&gt; , adem&amp;aacute;s de ignorar &lt;code&gt;LUA_INIT&lt;/code&gt; , Lua tambi&amp;eacute;n ignora los valores de &lt;code&gt;LUA_PATH&lt;/code&gt; y &lt;code&gt;LUA_CPATH&lt;/code&gt; , estableciendo los valores de &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt; con las rutas predeterminadas definidas en &lt;code&gt;luaconf.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="595bc8625b546518b3559c5e580a4c82ef8058d6" translate="yes" xml:space="preserve">
          <source>When called with the option &lt;code&gt;-E&lt;/code&gt;, Lua does not consult any environment variables. In particular, the values of &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; are set with the default paths defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de667989e59831a06657a1b7bb1953b9b2690bfc" translate="yes" xml:space="preserve">
          <source>When called without a &lt;code&gt;command&lt;/code&gt;, &lt;code&gt;os.execute&lt;/code&gt; returns a boolean that is true if a shell is available.</source>
          <target state="translated">Cuando se llama sin un &lt;code&gt;command&lt;/code&gt; , &lt;code&gt;os.execute&lt;/code&gt; devuelve un booleano que es verdadero si hay un shell disponible.</target>
        </trans-unit>
        <trans-unit id="08516ebb937ecdc973de2d47f44995af938578a2" translate="yes" xml:space="preserve">
          <source>When called without arguments, &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; turns off the hook.</source>
          <target state="translated">Cuando se llama sin argumentos, &lt;a href=&quot;#pdf-debug.sethook&quot;&gt; &lt;code&gt;debug.sethook&lt;/code&gt; &lt;/a&gt; desactiva el gancho.</target>
        </trans-unit>
        <trans-unit id="8dfc7d66f66b8d42b0606debc6628a523caba4e4" translate="yes" xml:space="preserve">
          <source>When called without arguments, &lt;code&gt;date&lt;/code&gt; returns a reasonable date and time representation that depends on the host system and on the current locale. (More specifically, &lt;code&gt;os.date()&lt;/code&gt; is equivalent to &lt;code&gt;os.date(&quot;%c&quot;)&lt;/code&gt;.)</source>
          <target state="translated">Cuando se llama sin argumentos, &lt;code&gt;date&lt;/code&gt; devuelve una representaci&amp;oacute;n de fecha y hora razonable que depende del sistema host y del entorno local actual. (M&amp;aacute;s espec&amp;iacute;ficamente, &lt;code&gt;os.date()&lt;/code&gt; es equivalente a &lt;code&gt;os.date(&quot;%c&quot;)&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="c64be510d7a1b577fd35233990dcc39ace49bc5f" translate="yes" xml:space="preserve">
          <source>When called without arguments, returns a pseudo-random float with uniform distribution in the range &lt;em&gt;[0,1)&lt;/em&gt;. When called with two integers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;math.random&lt;/code&gt; returns a pseudo-random integer with uniform distribution in the range &lt;em&gt;[m, n]&lt;/em&gt;. (The value &lt;em&gt;n-m&lt;/em&gt; cannot be negative and must fit in a Lua integer.) The call &lt;code&gt;math.random(n)&lt;/code&gt; is equivalent to &lt;code&gt;math.random(1,n)&lt;/code&gt;.</source>
          <target state="translated">Cuando se llama sin argumentos, devuelve un flotante pseudoaleatorio con distribuci&amp;oacute;n uniforme en el rango &lt;em&gt;[0,1)&lt;/em&gt; . Cuando se llama con dos n&amp;uacute;meros enteros &lt;code&gt;m&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;math.random&lt;/code&gt; devuelve un entero pseudo-aleatorio con distribuci&amp;oacute;n uniforme en el intervalo &lt;em&gt;[m, n]&lt;/em&gt; . (El valor &lt;em&gt;nm&lt;/em&gt; no puede ser negativo y debe caber en un entero Lua). La llamada &lt;code&gt;math.random(n)&lt;/code&gt; es equivalente a &lt;code&gt;math.random(1,n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="960c42dc7bcd6f99e9cb92d7e9f07ec281c2bc3b" translate="yes" xml:space="preserve">
          <source>When called without arguments, returns a pseudo-random float with uniform distribution in the range &lt;em&gt;[0,1)&lt;/em&gt;. When called with two integers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;math.random&lt;/code&gt; returns a pseudo-random integer with uniform distribution in the range &lt;em&gt;[m, n]&lt;/em&gt;. The call &lt;code&gt;math.random(n)&lt;/code&gt;, for a positive &lt;code&gt;n&lt;/code&gt;, is equivalent to &lt;code&gt;math.random(1,n)&lt;/code&gt;. The call &lt;code&gt;math.random(0)&lt;/code&gt; produces an integer with all bits (pseudo)random.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29766b7237675cb97603d39839cfd67a198b7d0e" translate="yes" xml:space="preserve">
          <source>When called without option &lt;code&gt;-E&lt;/code&gt;, the interpreter checks for an environment variable &lt;a id=&quot;pdf-LUA_INIT_5_3&quot;&gt;&lt;code&gt;LUA_INIT_5_3&lt;/code&gt;&lt;/a&gt; (or &lt;a id=&quot;pdf-LUA_INIT&quot;&gt;&lt;code&gt;LUA_INIT&lt;/code&gt;&lt;/a&gt; if the versioned name is not defined) before running any argument. If the variable content has the format &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt;, then &lt;code&gt;lua&lt;/code&gt; executes the file. Otherwise, &lt;code&gt;lua&lt;/code&gt; executes the string itself.</source>
          <target state="translated">Cuando se llama sin la opci&amp;oacute;n &lt;code&gt;-E&lt;/code&gt; , el int&amp;eacute;rprete busca una variable de entorno &lt;a id=&quot;pdf-LUA_INIT_5_3&quot;&gt; &lt;code&gt;LUA_INIT_5_3&lt;/code&gt; &lt;/a&gt; (o &lt;a id=&quot;pdf-LUA_INIT&quot;&gt; &lt;code&gt;LUA_INIT&lt;/code&gt; &lt;/a&gt; si el nombre versionado no est&amp;aacute; definido) antes de ejecutar cualquier argumento. Si el contenido de la variable tiene el formato &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt; , entonces &lt;code&gt;lua&lt;/code&gt; ejecuta el archivo. De lo contrario, &lt;code&gt;lua&lt;/code&gt; ejecuta la cadena en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="af35e90ee5c0251ed92b8eb4bb70c55a27767934" translate="yes" xml:space="preserve">
          <source>When called without the option &lt;code&gt;-E&lt;/code&gt;, the interpreter checks for an environment variable &lt;a id=&quot;pdf-LUA_INIT_5_4&quot;&gt;&lt;code&gt;LUA_INIT_5_4&lt;/code&gt;&lt;/a&gt; (or &lt;a id=&quot;pdf-LUA_INIT&quot;&gt;&lt;code&gt;LUA_INIT&lt;/code&gt;&lt;/a&gt; if the versioned name is not defined) before running any argument. If the variable content has the format &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt;, then &lt;code&gt;lua&lt;/code&gt; executes the file. Otherwise, &lt;code&gt;lua&lt;/code&gt; executes the string itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a01c66de0f50f818dc4c5eb18a31a7ce0c4e4f" translate="yes" xml:space="preserve">
          <source>When closing a file handle created with &lt;a href=&quot;#pdf-io.popen&quot;&gt;&lt;code&gt;io.popen&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-file:close&quot;&gt;&lt;code&gt;file:close&lt;/code&gt;&lt;/a&gt; returns the same values returned by &lt;a href=&quot;#pdf-os.execute&quot;&gt;&lt;code&gt;os.execute&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Al cerrar un identificador de archivo creado con &lt;a href=&quot;#pdf-io.popen&quot;&gt; &lt;code&gt;io.popen&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-file:close&quot;&gt; &lt;code&gt;file:close&lt;/code&gt; &lt;/a&gt; devuelve los mismos valores devueltos por &lt;a href=&quot;#pdf-os.execute&quot;&gt; &lt;code&gt;os.execute&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7249fe8ac6ec7cee81ebe5d27b0ade52596d313" translate="yes" xml:space="preserve">
          <source>When finalizing an object, Lua does not ignore &lt;code&gt;__gc&lt;/code&gt; metamethods that are not functions. Any value will be called, if present. (Non-callable values will generate a warning, like any other error when calling a finalizer.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e9db54045b382cd01f62245d15a65082274498" translate="yes" xml:space="preserve">
          <source>When finishing normally, the interpreter closes its main Lua state (see &lt;a href=&quot;#lua_close&quot;&gt;&lt;code&gt;lua_close&lt;/code&gt;&lt;/a&gt;). The script can avoid this step by calling &lt;a href=&quot;#pdf-os.exit&quot;&gt;&lt;code&gt;os.exit&lt;/code&gt;&lt;/a&gt; to terminate.</source>
          <target state="translated">Al finalizar normalmente, el int&amp;eacute;rprete cierra su estado Lua principal (ver &lt;a href=&quot;#lua_close&quot;&gt; &lt;code&gt;lua_close&lt;/code&gt; &lt;/a&gt; ). El script puede evitar este paso llamando a &lt;a href=&quot;#pdf-os.exit&quot;&gt; &lt;code&gt;os.exit&lt;/code&gt; &lt;/a&gt; para terminar.</target>
        </trans-unit>
        <trans-unit id="05829140d113fda20398a82789b93e3ec1b75792" translate="yes" xml:space="preserve">
          <source>When possible, you may prefer to use &lt;a href=&quot;#pdf-io.tmpfile&quot;&gt;&lt;code&gt;io.tmpfile&lt;/code&gt;&lt;/a&gt;, which automatically removes the file when the program ends.</source>
          <target state="translated">Cuando sea posible, es posible que prefiera utilizar &lt;a href=&quot;#pdf-io.tmpfile&quot;&gt; &lt;code&gt;io.tmpfile&lt;/code&gt; &lt;/a&gt; , que elimina autom&amp;aacute;ticamente el archivo cuando finaliza el programa.</target>
        </trans-unit>
        <trans-unit id="8f55b3bc753eda1e33e754171321ae6cdf1d0c2b" translate="yes" xml:space="preserve">
          <source>When the coroutine is resumed again, Lua calls the given continuation function &lt;code&gt;k&lt;/code&gt; to continue the execution of the C function that yielded (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). This continuation function receives the same stack from the previous function, with the &lt;code&gt;n&lt;/code&gt; results removed and replaced by the arguments passed to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;. Moreover, the continuation function receives the value &lt;code&gt;ctx&lt;/code&gt; that was passed to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d813e63ce1dec1bf88d125498265fe1c745f04" translate="yes" xml:space="preserve">
          <source>When the coroutine is resumed again, Lua calls the given continuation function &lt;code&gt;k&lt;/code&gt; to continue the execution of the C function that yielded (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). This continuation function receives the same stack from the previous function, with the &lt;code&gt;n&lt;/code&gt; results removed and replaced by the arguments passed to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;. Moreover, the continuation function receives the value &lt;code&gt;ctx&lt;/code&gt; that was passed to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cuando la corrutina se reanuda nuevamente, Lua llama a la funci&amp;oacute;n de continuaci&amp;oacute;n dada &lt;code&gt;k&lt;/code&gt; para continuar la ejecuci&amp;oacute;n de la funci&amp;oacute;n C que produjo (ver &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; ). Esta funci&amp;oacute;n de continuaci&amp;oacute;n recibe la misma pila de la funci&amp;oacute;n anterior, con los &lt;code&gt;n&lt;/code&gt; resultados eliminados y reemplazados por los argumentos pasados ​​a &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; . Adem&amp;aacute;s, la funci&amp;oacute;n de continuaci&amp;oacute;n recibe el valor &lt;code&gt;ctx&lt;/code&gt; que se pas&amp;oacute; a &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a75209bbb2c2e6ad290df78bf5d0eed53f0f5ef0" translate="yes" xml:space="preserve">
          <source>When the function is called, the values in these fields do not need to be inside their valid ranges. For instance, if &lt;code&gt;sec&lt;/code&gt; is -10, it means 10 seconds before the time specified by the other fields; if &lt;code&gt;hour&lt;/code&gt; is 1000, it means 1000 hours after the time specified by the other fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6a10ad01c056a56db07a26afc7431181db765d" translate="yes" xml:space="preserve">
          <source>When the hook is called, its first parameter is a string describing the event that has triggered its call: &lt;code&gt;&quot;call&quot;&lt;/code&gt; (or &lt;code&gt;&quot;tail call&quot;&lt;/code&gt;), &lt;code&gt;&quot;return&quot;&lt;/code&gt;, &lt;code&gt;&quot;line&quot;&lt;/code&gt;, and &lt;code&gt;&quot;count&quot;&lt;/code&gt;. For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call &lt;code&gt;getinfo&lt;/code&gt; with level 2 to get more information about the running function (level 0 is the &lt;code&gt;getinfo&lt;/code&gt; function, and level 1 is the hook function).</source>
          <target state="translated">Cuando se llama al gancho, su primer par&amp;aacute;metro es una cadena que describe el evento que ha desencadenado su llamada: &lt;code&gt;&quot;call&quot;&lt;/code&gt; (o &lt;code&gt;&quot;tail call&quot;&lt;/code&gt; ), &lt;code&gt;&quot;return&quot;&lt;/code&gt; , &lt;code&gt;&quot;line&quot;&lt;/code&gt; y &lt;code&gt;&quot;count&quot;&lt;/code&gt; . Para eventos de l&amp;iacute;nea, el gancho tambi&amp;eacute;n obtiene el nuevo n&amp;uacute;mero de l&amp;iacute;nea como segundo par&amp;aacute;metro. Dentro de un gancho, puede llamar a &lt;code&gt;getinfo&lt;/code&gt; con el nivel 2 para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la funci&amp;oacute;n en ejecuci&amp;oacute;n (el nivel 0 es la funci&amp;oacute;n &lt;code&gt;getinfo&lt;/code&gt; y el nivel 1 es la funci&amp;oacute;n del gancho).</target>
        </trans-unit>
        <trans-unit id="8bbba941f15e3649b6735004f1fa9587fdc162c9" translate="yes" xml:space="preserve">
          <source>When the hook is called, its first parameter is a string describing the event that has triggered its call: &lt;code&gt;&quot;call&quot;&lt;/code&gt;, &lt;code&gt;&quot;tail call&quot;&lt;/code&gt;, &lt;code&gt;&quot;return&quot;&lt;/code&gt;, &lt;code&gt;&quot;line&quot;&lt;/code&gt;, and &lt;code&gt;&quot;count&quot;&lt;/code&gt;. For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call &lt;code&gt;getinfo&lt;/code&gt; with level 2 to get more information about the running function. (Level 0 is the &lt;code&gt;getinfo&lt;/code&gt; function, and level 1 is the hook function.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa8e9df04a952020bd076482c3d60135f7f329c" translate="yes" xml:space="preserve">
          <source>When using implicit file handles, all operations are supplied by table &lt;a id=&quot;pdf-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;. When using explicit file handles, the operation &lt;a href=&quot;#pdf-io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt; returns a file handle and then all operations are supplied as methods of the file handle.</source>
          <target state="translated">Cuando se utilizan identificadores de archivo impl&amp;iacute;citos, todas las operaciones las proporciona la tabla &lt;a id=&quot;pdf-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt; . Cuando se utilizan identificadores de archivo expl&amp;iacute;citos, la operaci&amp;oacute;n &lt;a href=&quot;#pdf-io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt; devuelve un identificador de archivo y luego todas las operaciones se proporcionan como m&amp;eacute;todos del identificador de archivo.</target>
        </trans-unit>
        <trans-unit id="66e7217ccc689c6dec071df236389bbeca36a0c9" translate="yes" xml:space="preserve">
          <source>When you call a Lua function without a fixed number of results (see &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;), Lua ensures that the stack has enough space for all results, but it does not ensure any extra space. So, before pushing anything in the stack after such a call you should use &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cuando llama a una funci&amp;oacute;n Lua sin un n&amp;uacute;mero fijo de resultados (vea &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; ), Lua asegura que la pila tenga suficiente espacio para todos los resultados, pero no asegura ning&amp;uacute;n espacio adicional. Entonces, antes de insertar algo en la pila despu&amp;eacute;s de una llamada de este tipo, debe usar &lt;a href=&quot;#lua_checkstack&quot;&gt; &lt;code&gt;lua_checkstack&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e87402f549363e6adea42f0d7521692e33eb5518" translate="yes" xml:space="preserve">
          <source>When you call a Lua function without a fixed number of results (see &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;), Lua ensures that the stack has enough space for all results, but it does not ensure any extra space. So, before pushing anything on the stack after such a call you should use &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fac89278e16d9cfb7afed920548790f04b59edb" translate="yes" xml:space="preserve">
          <source>When you close a state (see &lt;a href=&quot;#lua_close&quot;&gt;&lt;code&gt;lua_close&lt;/code&gt;&lt;/a&gt;), Lua calls the finalizers of all objects marked for finalization, following the reverse order that they were marked. If any finalizer marks objects for collection during that phase, these marks have no effect.</source>
          <target state="translated">Cuando cierra un estado (ver &lt;a href=&quot;#lua_close&quot;&gt; &lt;code&gt;lua_close&lt;/code&gt; &lt;/a&gt; ), Lua llama a los finalizadores de todos los objetos marcados para finalizaci&amp;oacute;n, siguiendo el orden inverso al que fueron marcados. Si alg&amp;uacute;n finalizador marca objetos para su colecci&amp;oacute;n durante esa fase, estas marcas no tienen ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="bfa2a1bee37ec1b8b5edb99fbbb2457d178207e5" translate="yes" xml:space="preserve">
          <source>When you create a new Lua state, its registry comes with some predefined values. These predefined values are indexed with integer keys defined as constants in &lt;code&gt;lua.h&lt;/code&gt;. The following constants are defined:</source>
          <target state="translated">Cuando crea un nuevo estado Lua, su registro viene con algunos valores predefinidos. Estos valores predefinidos se indexan con las teclas de n&amp;uacute;meros enteros definidos como constantes en &lt;code&gt;lua.h&lt;/code&gt; . Se definen las siguientes constantes:</target>
        </trans-unit>
        <trans-unit id="7355d5bd1b6984cb05bdf3acfb6f9c1a447b9f50" translate="yes" xml:space="preserve">
          <source>When you interact with the Lua API, you are responsible for ensuring consistency. In particular, &lt;em&gt;you are responsible for controlling stack overflow&lt;/em&gt;. You can use the function &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt; to ensure that the stack has enough space for pushing new elements.</source>
          <target state="translated">Cuando interact&amp;uacute;a con la API de Lua, es responsable de garantizar la coherencia. En particular, &lt;em&gt;usted es responsable de controlar el desbordamiento de la pila&lt;/em&gt; . Puede utilizar la funci&amp;oacute;n &lt;a href=&quot;#lua_checkstack&quot;&gt; &lt;code&gt;lua_checkstack&lt;/code&gt; &lt;/a&gt; para asegurarse de que la pila tenga suficiente espacio para insertar nuevos elementos.</target>
        </trans-unit>
        <trans-unit id="f3ce65bde15db7ea0ab6b60f199c33fedc361e77" translate="yes" xml:space="preserve">
          <source>When you load a main chunk, the resulting function will always have exactly one upvalue, the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). However, when you load a binary chunk created from a function (see &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt;), the resulting function can have an arbitrary number of upvalues, and there is no guarantee that its first upvalue will be the &lt;code&gt;_ENV&lt;/code&gt; variable. (A non-main function may not even have an &lt;code&gt;_ENV&lt;/code&gt; upvalue.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8b32f8352fd78bcc7ec48884a68493230c9360" translate="yes" xml:space="preserve">
          <source>When you run it, it produces the following output:</source>
          <target state="translated">Cuando lo ejecutas,produce la siguiente salida:</target>
        </trans-unit>
        <trans-unit id="a2fe48a4ba1fe6efea7e679ea6354ce71899c865" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, in C) you may give a &lt;em&gt;message handler&lt;/em&gt; to be called in case of errors. This function is called with the original error object and returns a new error object. It is called before the error unwinds the stack, so that it can gather more information about the error, for instance by inspecting the stack and creating a stack traceback. This message handler is still protected by the protected call; so, an error inside the message handler will call the message handler again. If this loop goes on for too long, Lua breaks it and returns an appropriate message. The message handler is called only for regular runtime errors. It is not called for memory-allocation errors nor for errors while running finalizers or other message handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59fc39a27b959170f68fd36bc3ff7103614c868a" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, you may give a &lt;em&gt;message handler&lt;/em&gt; to be called in case of errors. This function is called with the original error object and returns a new error object. It is called before the error unwinds the stack, so that it can gather more information about the error, for instance by inspecting the stack and creating a stack traceback. This message handler is still protected by the protected call; so, an error inside the message handler will call the message handler again. If this loop goes on for too long, Lua breaks it and returns an appropriate message. (The message handler is called only for regular runtime errors. It is not called for memory-allocation errors nor for errors while running finalizers.)</source>
          <target state="translated">Cuando usa &lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; , puede dar un &lt;em&gt;controlador de mensajes&lt;/em&gt; para que sea llamado en caso de errores. Esta funci&amp;oacute;n se llama con el objeto de error original y devuelve un nuevo objeto de error. Se llama antes de que el error desenrolle la pila, de modo que pueda recopilar m&amp;aacute;s informaci&amp;oacute;n sobre el error, por ejemplo, inspeccionando la pila y creando un rastreo de pila. Este gestor de mensajes todav&amp;iacute;a est&amp;aacute; protegido por la llamada protegida; entonces, un error dentro del manejador de mensajes llamar&amp;aacute; al manejador de mensajes nuevamente. Si este bucle dura demasiado, Lua lo rompe y devuelve un mensaje apropiado. (El controlador de mensajes se llama solo para errores de tiempo de ejecuci&amp;oacute;n regulares. No se llama para errores de asignaci&amp;oacute;n de memoria ni para errores al ejecutar finalizadores).</target>
        </trans-unit>
        <trans-unit id="3d4a440a8a54cb67f8b148f43a2a234b9432ff21" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, it ensures that the stack has space for at least &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt;&lt;code&gt;LUA_MINSTACK&lt;/code&gt;&lt;/a&gt; extra elements; that is, you can safely push up to &lt;code&gt;LUA_MINSTACK&lt;/code&gt; values into it. &lt;code&gt;LUA_MINSTACK&lt;/code&gt; is defined as 20, so that usually you do not have to worry about stack space unless your code has loops pushing elements onto the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a645bbcf65be028c994caf05ae49cc42785d58" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, it ensures that the stack has space for at least &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt;&lt;code&gt;LUA_MINSTACK&lt;/code&gt;&lt;/a&gt; extra slots. &lt;code&gt;LUA_MINSTACK&lt;/code&gt; is defined as 20, so that usually you do not have to worry about stack space unless your code has loops pushing elements onto the stack.</source>
          <target state="translated">Siempre que Lua llama a C, se asegura de que la pila tenga espacio para al menos ranuras adicionales &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt; &lt;code&gt;LUA_MINSTACK&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;LUA_MINSTACK&lt;/code&gt; se define como 20, por lo que normalmente no tiene que preocuparse por el espacio de la pila a menos que su c&amp;oacute;digo tenga bucles que empujan elementos a la pila.</target>
        </trans-unit>
        <trans-unit id="bc36795858181bb669bdb65cc9b9976ecc560ce7" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, the called function gets a new stack, which is independent of previous stacks and of stacks of C functions that are still active. This stack initially contains any arguments to the C function and it is where the C function can store temporary Lua values and must push its results to be returned to the caller (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Siempre que Lua llama a C, la funci&amp;oacute;n llamada obtiene una nueva pila, que es independiente de las pilas anteriores y de las pilas de funciones C que a&amp;uacute;n est&amp;aacute;n activas. Esta pila contiene inicialmente cualquier argumento para la funci&amp;oacute;n C y es donde la funci&amp;oacute;n C puede almacenar valores Lua temporales y debe enviar sus resultados para que se devuelvan al llamador (ver &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c2b43773a36392d35ca699c4fb17769ecd2dd7c2" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;code&gt;__newindex&lt;/code&gt; metavalue is invoked, Lua does not perform the primitive assignment. If needed, the metamethod itself can call &lt;a href=&quot;#pdf-rawset&quot;&gt;&lt;code&gt;rawset&lt;/code&gt;&lt;/a&gt; to do the assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0194275f7fed5a9af0589750161f145316d9d8f8" translate="yes" xml:space="preserve">
          <source>Whenever a C function is called, its upvalues are located at specific pseudo-indices. These pseudo-indices are produced by the macro &lt;a href=&quot;#lua_upvalueindex&quot;&gt;&lt;code&gt;lua_upvalueindex&lt;/code&gt;&lt;/a&gt;. The first upvalue associated with a function is at index &lt;code&gt;lua_upvalueindex(1)&lt;/code&gt;, and so on. Any access to &lt;code&gt;lua_upvalueindex(&lt;em&gt;n&lt;/em&gt;)&lt;/code&gt;, where &lt;em&gt;n&lt;/em&gt; is greater than the number of upvalues of the current function (but not greater than 256, which is one plus the maximum number of upvalues in a closure), produces an acceptable but invalid index.</source>
          <target state="translated">Siempre que se llama a una funci&amp;oacute;n C, sus valores de subida se ubican en pseudo&amp;iacute;ndices espec&amp;iacute;ficos. Estos &lt;a href=&quot;#lua_upvalueindex&quot;&gt; &lt;code&gt;lua_upvalueindex&lt;/code&gt; &lt;/a&gt; son producidos por la macro lua_upvalueindex . El primer upvalue asociado con una funci&amp;oacute;n est&amp;aacute; en el &amp;iacute;ndice &lt;code&gt;lua_upvalueindex(1)&lt;/code&gt; , y as&amp;iacute; sucesivamente. Cualquier acceso a &lt;code&gt;lua_upvalueindex(&lt;em&gt;n&lt;/em&gt;)&lt;/code&gt; , donde &lt;em&gt;n&lt;/em&gt; es mayor que el n&amp;uacute;mero de upvalues ​​de la funci&amp;oacute;n actual (pero no mayor que 256, que es uno m&amp;aacute;s el n&amp;uacute;mero m&amp;aacute;ximo de upvalues ​​en un cierre), produce un &amp;iacute;ndice aceptable pero no v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="7b599885fcde567666ae50c3832fa9901f1faa95" translate="yes" xml:space="preserve">
          <source>Whenever a hook is called, its &lt;code&gt;ar&lt;/code&gt; argument has its field &lt;code&gt;event&lt;/code&gt; set to the specific event that triggered the hook. Lua identifies these events with the following constants: &lt;a id=&quot;pdf-LUA_HOOKCALL&quot;&gt;&lt;code&gt;LUA_HOOKCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKRET&quot;&gt;&lt;code&gt;LUA_HOOKRET&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKTAILCALL&quot;&gt;&lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKLINE&quot;&gt;&lt;code&gt;LUA_HOOKLINE&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_HOOKCOUNT&quot;&gt;&lt;code&gt;LUA_HOOKCOUNT&lt;/code&gt;&lt;/a&gt;. Moreover, for line events, the field &lt;code&gt;currentline&lt;/code&gt; is also set. To get the value of any other field in &lt;code&gt;ar&lt;/code&gt;, the hook must call &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Siempre que se llama a un gancho, su argumento &lt;code&gt;ar&lt;/code&gt; tiene su &lt;code&gt;event&lt;/code&gt; o de campo establecido en el evento espec&amp;iacute;fico que desencaden&amp;oacute; el gancho. Lua identifica estos eventos con las siguientes constantes: &lt;a id=&quot;pdf-LUA_HOOKCALL&quot;&gt; &lt;code&gt;LUA_HOOKCALL&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_HOOKRET&quot;&gt; &lt;code&gt;LUA_HOOKRET&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_HOOKTAILCALL&quot;&gt; &lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_HOOKLINE&quot;&gt; &lt;code&gt;LUA_HOOKLINE&lt;/code&gt; &lt;/a&gt; y &lt;a id=&quot;pdf-LUA_HOOKCOUNT&quot;&gt; &lt;code&gt;LUA_HOOKCOUNT&lt;/code&gt; &lt;/a&gt; . Adem&amp;aacute;s, para eventos de l&amp;iacute;nea, tambi&amp;eacute;n se establece el campo &lt;code&gt;currentline&lt;/code&gt; . Para obtener el valor de cualquier otro campo en &lt;code&gt;ar&lt;/code&gt; , el gancho debe llamar a &lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77a4ffdfeb7ea6979c398f6e32e8da8ff060ce91" translate="yes" xml:space="preserve">
          <source>Whenever there is a &lt;code&gt;__newindex&lt;/code&gt; metamethod, Lua does not perform the primitive assignment. (If necessary, the metamethod itself can call &lt;a href=&quot;#pdf-rawset&quot;&gt;&lt;code&gt;rawset&lt;/code&gt;&lt;/a&gt; to do the assignment.)</source>
          <target state="translated">Siempre que hay un &lt;code&gt;__newindex&lt;/code&gt; __newindex, Lua no realiza la asignaci&amp;oacute;n primitiva. (Si es necesario, el metam&amp;eacute;todo en s&amp;iacute; puede llamar a &lt;a href=&quot;#pdf-rawset&quot;&gt; &lt;code&gt;rawset&lt;/code&gt; &lt;/a&gt; para realizar la asignaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="380018403674372e84fb15d5ec3167aa3cf9c5cb" translate="yes" xml:space="preserve">
          <source>Whenever there is an error, an &lt;em&gt;error object&lt;/em&gt; (also called an &lt;em&gt;error message&lt;/em&gt;) is propagated with information about the error. Lua itself only generates errors whose error object is a string, but programs may generate errors with any value as the error object. It is up to the Lua program or its host to handle such error objects.</source>
          <target state="translated">Siempre que hay un error, se propaga un &lt;em&gt;objeto de error&lt;/em&gt; (tambi&amp;eacute;n llamado &lt;em&gt;mensaje de error&lt;/em&gt; ) con informaci&amp;oacute;n sobre el error. Lua en s&amp;iacute; solo genera errores cuyo objeto de error es una cadena, pero los programas pueden generar errores con cualquier valor como objeto de error. Depende del programa Lua o de su anfitri&amp;oacute;n manejar tales objetos de error.</target>
        </trans-unit>
        <trans-unit id="846e0dd3b617fa3bf7db09630f23f0393a92f6a2" translate="yes" xml:space="preserve">
          <source>Whenever there is an error, an &lt;em&gt;error object&lt;/em&gt; is propagated with information about the error. Lua itself only generates errors whose error object is a string, but programs may generate errors with any value as the error object. It is up to the Lua program or its host to handle such error objects. For historical reasons, an error object is often called an &lt;em&gt;error message&lt;/em&gt;, even though it does not have to be a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272f9a8e241eb8a55a33970a98b804e3cbb2993b" translate="yes" xml:space="preserve">
          <source>While Lua is running a hook, it disables other calls to hooks. Therefore, if a hook calls back Lua to execute a function or a chunk, this execution occurs without any calls to hooks.</source>
          <target state="translated">Mientras Lua está ejecutando un gancho,desactiva otras llamadas a ganchos.Por lo tanto,si un gancho llama de nuevo a Lua para ejecutar una función o un trozo,esta ejecución se produce sin ninguna llamada a los ganchos.</target>
        </trans-unit>
        <trans-unit id="c55926fa7030f56d817d54fc38fc120f3c9f44c9" translate="yes" xml:space="preserve">
          <source>While traversing a table, avoid calling &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; directly on a key, unless you know that the key is actually a string. Recall that &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; may change the value at the given index; this confuses the next call to &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768488e627b06a1ccd84c86d3762c984059da019" translate="yes" xml:space="preserve">
          <source>While traversing a table, do not call &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; directly on a key, unless you know that the key is actually a string. Recall that &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; may change the value at the given index; this confuses the next call to &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mientras recorre una tabla, no llame a &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt; directamente en una clave, a menos que sepa que la clave es en realidad una cadena. Recuerde que &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt; puede cambiar el valor en el &amp;iacute;ndice dado; esto confunde la pr&amp;oacute;xima llamada a &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="518506b1bd272cc87115a976ea99ba83864b9064" translate="yes" xml:space="preserve">
          <source>With the exception of exponentiation and float division, the arithmetic operators work as follows: If both operands are integers, the operation is performed over integers and the result is an integer. Otherwise, if both operands are numbers or strings that can be converted to numbers (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;), then they are converted to floats, the operation is performed following the usual rules for floating-point arithmetic (usually the IEEE 754 standard), and the result is a float.</source>
          <target state="translated">Con la excepci&amp;oacute;n de la exponenciaci&amp;oacute;n y la divisi&amp;oacute;n flotante, los operadores aritm&amp;eacute;ticos funcionan de la siguiente manera: si ambos operandos son enteros, la operaci&amp;oacute;n se realiza sobre enteros y el resultado es un entero. De lo contrario, si ambos operandos son n&amp;uacute;meros o cadenas que se pueden convertir en n&amp;uacute;meros (ver &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; ), entonces se convierten en flotantes, la operaci&amp;oacute;n se realiza siguiendo las reglas habituales para la aritm&amp;eacute;tica de punto flotante (generalmente el est&amp;aacute;ndar IEEE 754) , y el resultado es un flotador.</target>
        </trans-unit>
        <trans-unit id="6d94057967a72a5d81edd6ae24d02d66cf0d57ab" translate="yes" xml:space="preserve">
          <source>With the exception of exponentiation and float division, the arithmetic operators work as follows: If both operands are integers, the operation is performed over integers and the result is an integer. Otherwise, if both operands are numbers, then they are converted to floats, the operation is performed following the machine's rules for floating-point arithmetic (usually the IEEE 754 standard), and the result is a float. (The string library coerces strings to numbers in arithmetic operations; see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; for details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef23cb793be6d01c5592ed37d41262accad311cc" translate="yes" xml:space="preserve">
          <source>Writes the value of each of its arguments to &lt;code&gt;file&lt;/code&gt;. The arguments must be strings or numbers.</source>
          <target state="translated">Escribe el valor de cada uno de sus argumentos en el &lt;code&gt;file&lt;/code&gt; . Los argumentos deben ser cadenas o n&amp;uacute;meros.</target>
        </trans-unit>
        <trans-unit id="4b2eb6ac09b984e213b2d26d7367f553447ec91c" translate="yes" xml:space="preserve">
          <source>Yields a coroutine (thread).</source>
          <target state="translated">Produce una corutina (hilo).</target>
        </trans-unit>
        <trans-unit id="4c14ae77965a71399e48d53e02bcb286bb93f6f2" translate="yes" xml:space="preserve">
          <source>You can also create and manipulate coroutines through the C API: see functions &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n puede crear y manipular corrutinas a trav&amp;eacute;s de la API de C: consulte las funciones &lt;a href=&quot;#lua_newthread&quot;&gt; &lt;code&gt;lua_newthread&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf65c06d67b704766199b9121e3b29a033e4c3cc" translate="yes" xml:space="preserve">
          <source>You can avoid some incompatibilities by compiling Lua with appropriate options (see file &lt;code&gt;luaconf.h&lt;/code&gt;). However, all these compatibility options will be removed in the future. More often than not, compatibility issues arise when these compatibility options are removed. So, whenever you have the chance, you should try to test your code with a version of Lua compiled with all compatibility options turned off. That will ease transitions to newer versions of Lua.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e17dda44cc7b49c20312b1b3f6c3280740896b" translate="yes" xml:space="preserve">
          <source>You can call functions only in threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;. You can resume threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (to start a new coroutine) or &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; (to resume a coroutine).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30acf487d4f39b1b32392092243899e125648aac" translate="yes" xml:space="preserve">
          <source>You can change the GC mode and parameters by calling &lt;a href=&quot;#lua_gc&quot;&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt; in C or &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt; in Lua. You can also use these functions to control the collector directly (e.g., to stop and restart it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7319a84c3be9c603d878df474f45dfa44f88afd" translate="yes" xml:space="preserve">
          <source>You can change the way that Lua compares tables and userdata by using the &quot;eq&quot; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Puede cambiar la forma en que Lua compara tablas y datos de usuario utilizando el metam&amp;eacute;todo &quot;eq&quot; (consulte &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfd38a5c874f3757df856f2f0fe3488def075bb2" translate="yes" xml:space="preserve">
          <source>You can change the way that Lua compares tables and userdata by using the &lt;code&gt;__eq&lt;/code&gt; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3102901d0caee19c958fcee9d58ed56ee554d4f9" translate="yes" xml:space="preserve">
          <source>You can change these numbers by calling &lt;a href=&quot;#lua_gc&quot;&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt; in C or &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt; in Lua. You can also use these functions to control the collector directly (e.g., stop and restart it).</source>
          <target state="translated">Puede cambiar estos n&amp;uacute;meros llamando a &lt;a href=&quot;#lua_gc&quot;&gt; &lt;code&gt;lua_gc&lt;/code&gt; &lt;/a&gt; en C o &lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; &lt;/a&gt; en Lua. Tambi&amp;eacute;n puede utilizar estas funciones para controlar el colector directamente (por ejemplo, detenerlo y reiniciarlo).</target>
        </trans-unit>
        <trans-unit id="1aa1c0455b97a9145781995effbd7a91d175f4dd" translate="yes" xml:space="preserve">
          <source>You can fix these differences by forcing a number to be a float (in Lua 5.2 all numbers were float), in particular writing constants with an ending &lt;code&gt;.0&lt;/code&gt; or using &lt;code&gt;x = x + 0.0&lt;/code&gt; to convert a variable. (This recommendation is only for a quick fix for an occasional incompatibility; it is not a general guideline for good programming. For good programming, use floats where you need floats and integers where you need integers.)</source>
          <target state="translated">Puede corregir estas diferencias obligando a que un n&amp;uacute;mero sea flotante (en Lua 5.2 todos los n&amp;uacute;meros eran flotantes), en particular escribiendo constantes con un final &lt;code&gt;.0&lt;/code&gt; o usando &lt;code&gt;x = x + 0.0&lt;/code&gt; para convertir una variable. (Esta recomendaci&amp;oacute;n es solo para una soluci&amp;oacute;n r&amp;aacute;pida para una incompatibilidad ocasional; no es una gu&amp;iacute;a general para una buena programaci&amp;oacute;n. Para una buena programaci&amp;oacute;n, use flotantes donde necesite flotantes y enteros donde necesite enteros).</target>
        </trans-unit>
        <trans-unit id="6b9f9c8aada12f19e8959797fbd200469c989aaf" translate="yes" xml:space="preserve">
          <source>You can only call functions in threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;. You can resume threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (to start a new coroutine) or &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; (to resume a coroutine).</source>
          <target state="translated">Solo puede llamar a funciones en subprocesos con estado &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; . Puede reanudar los hilos con el estado &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; (para iniciar una nueva corrutina) o &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; (para reanudar una corrutina).</target>
        </trans-unit>
        <trans-unit id="59f7d5bf15872a3901218a87816b69752280c691" translate="yes" xml:space="preserve">
          <source>You can put a closing square bracket in a set by positioning it as the first character in the set. You can put a hyphen in a set by positioning it as the first or the last character in the set. (You can also use an escape for both cases.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8061a68da1d074d2f5c5e92636b71ce2c9bfb53d" translate="yes" xml:space="preserve">
          <source>You can put a closing square bracket in a set by positioning it as the first character in the set. You can put an hyphen in a set by positioning it as the first or the last character in the set. (You can also use an escape for both cases.)</source>
          <target state="translated">Puedes poner un corchete de cierre en un conjunto posicionándolo como el primer personaje del conjunto.Puedes poner un guión en un conjunto posicionándolo como el primer o el último carácter del conjunto.(También puedes usar un escape para ambos casos).</target>
        </trans-unit>
        <trans-unit id="799d3c0c986643b2fb7ee878e60672115c276c33" translate="yes" xml:space="preserve">
          <source>You can query the metatable of any value using the &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt; function. Lua queries metamethods in metatables using a raw access (see &lt;a href=&quot;#pdf-rawget&quot;&gt;&lt;code&gt;rawget&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2781e61b519fd47b1d4f450639555b1c01907b6" translate="yes" xml:space="preserve">
          <source>You can query the metatable of any value using the &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt; function. Lua queries metamethods in metatables using a raw access (see &lt;a href=&quot;#pdf-rawget&quot;&gt;&lt;code&gt;rawget&lt;/code&gt;&lt;/a&gt;). So, to retrieve the metamethod for event &lt;code&gt;ev&lt;/code&gt; in object &lt;code&gt;o&lt;/code&gt;, Lua does the equivalent to the following code:</source>
          <target state="translated">Puede consultar la metatabla de cualquier valor utilizando la funci&amp;oacute;n &lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt; . Lua consulta metam&amp;eacute;todos en metatablas usando un acceso sin &lt;a href=&quot;#pdf-rawget&quot;&gt; &lt;code&gt;rawget&lt;/code&gt; &lt;/a&gt; (ver rawget ). Entonces, para recuperar el metam&amp;eacute;todo para event &lt;code&gt;ev&lt;/code&gt; en el objeto &lt;code&gt;o&lt;/code&gt; , Lua hace el equivalente al siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="d1dc46c8e9720bcf85f3abea3ac1cb55affdcb0d" translate="yes" xml:space="preserve">
          <source>You can replace the metatable of tables using the &lt;a href=&quot;#pdf-setmetatable&quot;&gt;&lt;code&gt;setmetatable&lt;/code&gt;&lt;/a&gt; function. You cannot change the metatable of other types from Lua code (except by using the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;)); you should use the C API for that.</source>
          <target state="translated">Puede reemplazar la metatabla de tablas usando la funci&amp;oacute;n &lt;a href=&quot;#pdf-setmetatable&quot;&gt; &lt;code&gt;setmetatable&lt;/code&gt; &lt;/a&gt; . No puede cambiar la metatabla de otros tipos del c&amp;oacute;digo Lua (excepto mediante el uso de la biblioteca de depuraci&amp;oacute;n ( &lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt; )); deber&amp;iacute;as usar la API C para eso.</target>
        </trans-unit>
        <trans-unit id="71035c95301acc8c192b359af22e6b3657788623" translate="yes" xml:space="preserve">
          <source>You can replace the metatable of tables using the &lt;a href=&quot;#pdf-setmetatable&quot;&gt;&lt;code&gt;setmetatable&lt;/code&gt;&lt;/a&gt; function. You cannot change the metatable of other types from Lua code, except by using the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e58a48a2bbf52e5804761968441fe7ea238d5cc" translate="yes" xml:space="preserve">
          <source>You can set garbage-collector metamethods for tables and, using the C API, for full userdata (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). These metamethods are also called &lt;em&gt;finalizers&lt;/em&gt;. Finalizers allow you to coordinate Lua's garbage collection with external resource management (such as closing files, network or database connections, or freeing your own memory).</source>
          <target state="translated">Puede establecer metam&amp;eacute;todos recolectores de basura para tablas y, utilizando la API de C, para datos de usuario completos (consulte &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ). Estos metam&amp;eacute;todos tambi&amp;eacute;n se denominan &lt;em&gt;finalizadores&lt;/em&gt; . Los finalizadores le permiten coordinar la recolecci&amp;oacute;n de basura de Lua con la administraci&amp;oacute;n de recursos externos (como cerrar archivos, conexiones de red o bases de datos, o liberar su propia memoria).</target>
        </trans-unit>
        <trans-unit id="bda59ef5aaee54d3f7530ea5520d18e9906d209b" translate="yes" xml:space="preserve">
          <source>You can set garbage-collector metamethods for tables and, using the C API, for full userdata (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). These metamethods, called &lt;em&gt;finalizers&lt;/em&gt;, are called when the garbage collector detects that the corresponding table or userdata is dead. Finalizers allow you to coordinate Lua's garbage collection with external resource management such as closing files, network or database connections, or freeing your own memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1a4e1dd00034824534614f2bda7911ae8431cd" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;break&lt;/b&gt; and &lt;b&gt;goto&lt;/b&gt; to exit a &lt;b&gt;for&lt;/b&gt; loop.</source>
          <target state="translated">Puede usar &lt;b&gt;break&lt;/b&gt; y &lt;b&gt;goto&lt;/b&gt; para salir de un bucle &lt;b&gt;for&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="b27cc8080576c27c1dd2a0afb3a34a7a52ff85b8" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;break&lt;/b&gt; to exit a &lt;b&gt;for&lt;/b&gt; loop.</source>
          <target state="translated">Puede usar &lt;b&gt;break&lt;/b&gt; para salir de un bucle &lt;b&gt;for&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d52df43ef083f76a03d8e01f3e9a36da3fc66f0d" translate="yes" xml:space="preserve">
          <source>You create a coroutine by calling &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;. Its sole argument is a function that is the main function of the coroutine. The &lt;code&gt;create&lt;/code&gt; function only creates a new coroutine and returns a handle to it (an object of type &lt;em&gt;thread&lt;/em&gt;); it does not start the coroutine.</source>
          <target state="translated">Cree una corrutina llamando a &lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; &lt;/a&gt; . Su &amp;uacute;nico argumento es una funci&amp;oacute;n que es la funci&amp;oacute;n principal de la corrutina. La funci&amp;oacute;n de &lt;code&gt;create&lt;/code&gt; solo crea una nueva corrutina y le devuelve un identificador (un objeto de tipo &lt;em&gt;hilo&lt;/em&gt; ); no inicia la corrutina.</target>
        </trans-unit>
        <trans-unit id="5ef445026cd0a146e81e995bc4681bfd5e57e5c5" translate="yes" xml:space="preserve">
          <source>You do not have to allocate space for the result: the result is a Lua string and Lua takes care of memory allocation (and deallocation, through garbage collection).</source>
          <target state="translated">No es necesario asignar espacio para el resultado:el resultado es una cadena de Lua y Lua se encarga de la asignación de memoria (y de la asignación,a través de la recogida de basura).</target>
        </trans-unit>
        <trans-unit id="76e561e2abeb8c3fca97fd50eca052b57e9c65f8" translate="yes" xml:space="preserve">
          <source>You execute a coroutine by calling &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. When you first call &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, passing as its first argument a thread returned by &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the coroutine starts its execution by calling its main function. Extra arguments passed to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; are passed as arguments to that function. After the coroutine starts running, it runs until it terminates or &lt;em&gt;yields&lt;/em&gt;.</source>
          <target state="translated">Ejecuta una corrutina llamando a &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; . Cuando llama por primera vez a &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; , pasando como primer argumento un hilo devuelto por &lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; &lt;/a&gt; , la coroutine comienza su ejecuci&amp;oacute;n llamando a su funci&amp;oacute;n principal. Los argumentos adicionales que se pasan a &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; se pasan como argumentos a esa funci&amp;oacute;n. Una vez que la corrutina comienza a ejecutarse, se ejecuta hasta que termina o &lt;em&gt;cede&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9517d537bb2cc69695684dbed19e521703190b55" translate="yes" xml:space="preserve">
          <source>You should not change the value of the control variable during the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beb90315d79ba8436d83c1621548dc0828a068ab" translate="yes" xml:space="preserve">
          <source>You should not change the value of the control variable during the loop. If you need its value after the loop, assign it to another variable before exiting the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53454c1d52c8e8625f900a3b2f28a52f9ab6262" translate="yes" xml:space="preserve">
          <source>_G</source>
          <target state="translated">_G</target>
        </trans-unit>
        <trans-unit id="2f7691c85ede2ffb322e774a60315181bf799f71" translate="yes" xml:space="preserve">
          <source>_VERSION</source>
          <target state="translated">_VERSION</target>
        </trans-unit>
        <trans-unit id="d361be99d87b0fd1757850b39df6dc818e066eec" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;*&lt;/code&gt;', which matches sequences of zero or more characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f22daca599d25013aaf6d4c6cefa12b839e072" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;*&lt;/code&gt;', which matches zero or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">una clase de un solo car&amp;aacute;cter seguida de ' &lt;code&gt;*&lt;/code&gt; ', que coincide con cero o m&amp;aacute;s repeticiones de caracteres en la clase. Estos elementos de repetici&amp;oacute;n siempre coincidir&amp;aacute;n con la secuencia m&amp;aacute;s larga posible;</target>
        </trans-unit>
        <trans-unit id="9f3711be8dd7bfb74572554b6c7626ae533f6527" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;+&lt;/code&gt;', which matches one or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">una clase de un solo car&amp;aacute;cter seguida de ' &lt;code&gt;+&lt;/code&gt; ', que coincide con una o m&amp;aacute;s repeticiones de caracteres en la clase. Estos elementos de repetici&amp;oacute;n siempre coincidir&amp;aacute;n con la secuencia m&amp;aacute;s larga posible;</target>
        </trans-unit>
        <trans-unit id="bc94c739274a89a02c004f804c812de321b43960" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;+&lt;/code&gt;', which matches sequences of one or more characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc742d84c8f95089303b3c1235798dad7894c243" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;-&lt;/code&gt;', which also matches sequences of zero or more characters in the class. Unlike '&lt;code&gt;*&lt;/code&gt;', these repetition items will always match the shortest possible sequence;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2c202847f17af45741edd719e4addc76505a81" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;-&lt;/code&gt;', which also matches zero or more repetitions of characters in the class. Unlike '&lt;code&gt;*&lt;/code&gt;', these repetition items will always match the shortest possible sequence;</source>
          <target state="translated">una clase de un solo car&amp;aacute;cter seguida de ' &lt;code&gt;-&lt;/code&gt; ', que tambi&amp;eacute;n coincide con cero o m&amp;aacute;s repeticiones de caracteres en la clase. A diferencia de ' &lt;code&gt;*&lt;/code&gt; ', estos elementos de repetici&amp;oacute;n siempre coincidir&amp;aacute;n con la secuencia m&amp;aacute;s corta posible;</target>
        </trans-unit>
        <trans-unit id="237b908d85fd5486211190c63284fa599c924a55" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;?&lt;/code&gt;', which matches zero or one occurrence of a character in the class. It always matches one occurrence if possible;</source>
          <target state="translated">una clase de un solo car&amp;aacute;cter seguida de ' &lt;code&gt;?&lt;/code&gt; ', que coincide con cero o una aparici&amp;oacute;n de un car&amp;aacute;cter en la clase. Siempre coincide con una ocurrencia si es posible;</target>
        </trans-unit>
        <trans-unit id="0c5e2141926ba6afbd01b9f0df61d70a7c93f57e" translate="yes" xml:space="preserve">
          <source>a single character class, which matches any single character in the class;</source>
          <target state="translated">una clase de un solo personaje,que coincide con cualquier personaje de la clase;</target>
        </trans-unit>
        <trans-unit id="63ae10d79f4a0c4781e4e9b2dacd5c9896a57556" translate="yes" xml:space="preserve">
          <source>assert()</source>
          <target state="translated">assert()</target>
        </trans-unit>
        <trans-unit id="d9b7850ae45b39d5960b24328cbe68f8d5986e4d" translate="yes" xml:space="preserve">
          <source>basic UTF-8 support (&lt;a href=&quot;#6.5&quot;&gt;&amp;sect;6.5&lt;/a&gt;);</source>
          <target state="translated">soporte b&amp;aacute;sico de UTF-8 ( &lt;a href=&quot;#6.5&quot;&gt;&amp;sect;6.5&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="fefa5c394d291465c545b09029d833606f910bf8" translate="yes" xml:space="preserve">
          <source>basic library (&lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt;);</source>
          <target state="translated">biblioteca b&amp;aacute;sica ( &lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="74dcaf5215a85f0f3fdfba06d8dc2140d162bce8" translate="yes" xml:space="preserve">
          <source>by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes</source>
          <target state="translated">por Roberto Ierusalimschy,Luiz Henrique de Figueiredo,Waldemar Celes</target>
        </trans-unit>
        <trans-unit id="85f91b3e97f2cf4928f588f868b5b56e41f46ac7" translate="yes" xml:space="preserve">
          <source>can be used to call &quot;methods&quot;. A call &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; is syntactic sugar for &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;, except that &lt;code&gt;v&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">se puede utilizar para llamar a &quot;m&amp;eacute;todos&quot;. Una llamada &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; es az&amp;uacute;car sint&amp;aacute;ctica para &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; , excepto que &lt;code&gt;v&lt;/code&gt; se eval&amp;uacute;a solo una vez.</target>
        </trans-unit>
        <trans-unit id="6d633e66cce93e82c599b2ed94b6975cd1983c8d" translate="yes" xml:space="preserve">
          <source>can be used to emulate methods. A call &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; is syntactic sugar for &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;, except that &lt;code&gt;v&lt;/code&gt; is evaluated only once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3586e1e0bcc962d7bc2f3fead617414fb7e605" translate="yes" xml:space="preserve">
          <source>collectgarbage()</source>
          <target state="translated">collectgarbage()</target>
        </trans-unit>
        <trans-unit id="2d524624e9fa583630d5fa0595340fdebfe37ef7" translate="yes" xml:space="preserve">
          <source>coroutine library (&lt;a href=&quot;#6.2&quot;&gt;&amp;sect;6.2&lt;/a&gt;);</source>
          <target state="translated">biblioteca de rutina ( &lt;a href=&quot;#6.2&quot;&gt;&amp;sect;6.2&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="eae27926b30edc4437a198e2711147c99c5e7fbe" translate="yes" xml:space="preserve">
          <source>coroutine.close()</source>
          <target state="translated">coroutine.close()</target>
        </trans-unit>
        <trans-unit id="20cd53c84ed6149d722a861cd300131fe78d55e2" translate="yes" xml:space="preserve">
          <source>coroutine.create()</source>
          <target state="translated">coroutine.create()</target>
        </trans-unit>
        <trans-unit id="6817fb4ac877543987e9d2cf2bfa960bd73b02b0" translate="yes" xml:space="preserve">
          <source>coroutine.isyieldable()</source>
          <target state="translated">coroutine.isyieldable()</target>
        </trans-unit>
        <trans-unit id="1c13fd77eddf40ec2374814bf03a272d614ac054" translate="yes" xml:space="preserve">
          <source>coroutine.resume()</source>
          <target state="translated">coroutine.resume()</target>
        </trans-unit>
        <trans-unit id="b96ab0d2970d06f0cea57e5eaa71cf5ecdd618a8" translate="yes" xml:space="preserve">
          <source>coroutine.running()</source>
          <target state="translated">coroutine.running()</target>
        </trans-unit>
        <trans-unit id="ba662b8414ef9e3a4eaa77d2c840fa4c12339222" translate="yes" xml:space="preserve">
          <source>coroutine.status()</source>
          <target state="translated">coroutine.status()</target>
        </trans-unit>
        <trans-unit id="bf3b61ea5fdfb1c6f4aa0021505b10377c2744b9" translate="yes" xml:space="preserve">
          <source>coroutine.wrap()</source>
          <target state="translated">coroutine.wrap()</target>
        </trans-unit>
        <trans-unit id="28fa9aab8f13eb98b7d555b1121c4e2f64da5b24" translate="yes" xml:space="preserve">
          <source>coroutine.yield()</source>
          <target state="translated">coroutine.yield()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
