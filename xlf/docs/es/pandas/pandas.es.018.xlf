<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="pandas">
    <body>
      <group id="pandas">
        <trans-unit id="280e0dcd01a74e9f2971dc15e9ea5e4fed9ba1e7" translate="yes" xml:space="preserve">
          <source>GroupBy objects are returned by groupby calls: &lt;a href=&quot;api/pandas.dataframe.groupby#pandas.DataFrame.groupby&quot;&gt;&lt;code&gt;pandas.DataFrame.groupby()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;api/pandas.series.groupby#pandas.Series.groupby&quot;&gt;&lt;code&gt;pandas.Series.groupby()&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">Los objetos GroupBy son devueltos por llamadas groupby: &lt;a href=&quot;api/pandas.dataframe.groupby#pandas.DataFrame.groupby&quot;&gt; &lt;code&gt;pandas.DataFrame.groupby()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;api/pandas.series.groupby#pandas.Series.groupby&quot;&gt; &lt;code&gt;pandas.Series.groupby()&lt;/code&gt; &lt;/a&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="ef1b77e5d75adde3306a51cdd096ed01e94f4b14" translate="yes" xml:space="preserve">
          <source>GroupBy sorting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf46240f856a5682954118b148c3e4fe55d034af" translate="yes" xml:space="preserve">
          <source>GroupBy with MultiIndex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32fdf78ac7e6bd8018e3271aa0c9d041f20f2211" translate="yes" xml:space="preserve">
          <source>Groupby a specific column with the desired frequency. This is like resampling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ee04b10dd8ef682ca6c7cdb964b01ff1e4723f" translate="yes" xml:space="preserve">
          <source>Groupby also works with some plotting methods. For example, suppose we suspect that some features in a DataFrame may differ by group, in this case, the values in column 1 where the group is &amp;ldquo;B&amp;rdquo; are 3 higher on average.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c96bea6efc5cf3346c84735e823e0034188931" translate="yes" xml:space="preserve">
          <source>Groupby by indexer to &amp;lsquo;resample&amp;rsquo; data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab29307976ccacc26ac65efc4e37aa349c72454e" translate="yes" xml:space="preserve">
          <source>Groupby iterator.</source>
          <target state="translated">Grupo por iterador.</target>
        </trans-unit>
        <trans-unit id="7b4bf5d82cf17787b55659f7a273347eac9f8902" translate="yes" xml:space="preserve">
          <source>Groupby key, which selects the grouping column of the target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918b5ad011a620824893a5734d02f858a6a13add" translate="yes" xml:space="preserve">
          <source>Groupby on a HDFStore with high group density</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf0c2abdd85fb648361a521b0d32db681754f91" translate="yes" xml:space="preserve">
          <source>Groupby on a HDFStore with low group density</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63f7dc74d42e24a6af9901ab8b42b7aa13d4a1a" translate="yes" xml:space="preserve">
          <source>Groupby one column and return the mean of only particular column in the group.</source>
          <target state="translated">Agrúpese por una columna y devuelva la media de sólo una columna particular del grupo.</target>
        </trans-unit>
        <trans-unit id="1791776b439188ec61725cdf5b05148568043324" translate="yes" xml:space="preserve">
          <source>Groupby one column and return the mean of the remaining columns in each group.</source>
          <target state="translated">Agrúpense por una columna y devuelvan la media de las columnas restantes de cada grupo.</target>
        </trans-unit>
        <trans-unit id="c23dcbebf567a5f1cbcee4e7dadfd7904a8b5717" translate="yes" xml:space="preserve">
          <source>Groupby operations on the index will preserve the index nature as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d720fc80687d90ae00e0ff29c33e68654b9f8d9c" translate="yes" xml:space="preserve">
          <source>Groupby two columns and return the mean of the remaining column.</source>
          <target state="translated">Agrúpense por dos columnas y devuelvan la media de la columna restante.</target>
        </trans-unit>
        <trans-unit id="b7936f6ac97d94069c7eac9bde37e7210dab8305" translate="yes" xml:space="preserve">
          <source>Groupby will also show &amp;ldquo;unused&amp;rdquo; categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c8f672af9a6da3268b6f4a99958d6e735607b1" translate="yes" xml:space="preserve">
          <source>Grouper</source>
          <target state="translated">Grouper</target>
        </trans-unit>
        <trans-unit id="439ef5b4855b51a20d486556cd3d53a3ceee4963" translate="yes" xml:space="preserve">
          <source>Grouper()</source>
          <target state="translated">Grouper()</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="bea5d4da543fa550ad0fc184bd837b179b3659cb" translate="yes" xml:space="preserve">
          <source>Grouping DataFrame with Index levels and columns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3360636443934b7226aa2d127f6a2ac58e7d4669" translate="yes" xml:space="preserve">
          <source>Grouping and summarizing</source>
          <target state="translated">Agrupar y resumir</target>
        </trans-unit>
        <trans-unit id="f8f359575ce3ab2a02a810c3b1782873145964fe" translate="yes" xml:space="preserve">
          <source>Grouping and then applying the &lt;a href=&quot;../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; function to the resulting groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afcadcfef8d4935dc588e61f6702eec50be51112" translate="yes" xml:space="preserve">
          <source>Grouping by a categorical column also shows empty categories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac86dfd20ea0c35fb856dec7c01ef9c8dbf27fa3" translate="yes" xml:space="preserve">
          <source>Grouping by multiple columns forms a hierarchical index, and again we can apply the &lt;a href=&quot;../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a25e97424d28d2b53606830a675cb2c5765592" translate="yes" xml:space="preserve">
          <source>Grouping like Python&amp;rsquo;s itertools.groupby</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6d5986d1d0890c74650296e8acadfc61d984d3" translate="yes" xml:space="preserve">
          <source>Grouping using a MultiIndex</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5125fd5e29c34786d3e8901ae40be86c001faeb2" translate="yes" xml:space="preserve">
          <source>Grouping with a grouper specification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbfa32bfae76816eb5fcd1ed109b80e107640b8d" translate="yes" xml:space="preserve">
          <source>Grouping with multiple levels is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d0d69e2faac3cba479930cd6f20092c9c0ea1a" translate="yes" xml:space="preserve">
          <source>Grouping with ordered factors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79300cb379b299ff45fb8750bc24f22896f49f6d" translate="yes" xml:space="preserve">
          <source>Guaranteed return of an indexer even when non-unique.</source>
          <target state="translated">Garantía de devolución de un indexador incluso cuando no es único.</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="7c1d0e621e0ca09058706d36a425fc4578904765" translate="yes" xml:space="preserve">
          <source>HDF5</source>
          <target state="translated">HDF5</target>
        </trans-unit>
        <trans-unit id="4d0784f9d9f96af76bb1f3d1e361bf164aa153e1" translate="yes" xml:space="preserve">
          <source>HDF5 (PyTables)</source>
          <target state="translated">HDF5 (PyTables)</target>
        </trans-unit>
        <trans-unit id="92aab64c23220250c4b7eff53be23edf32d43f26" translate="yes" xml:space="preserve">
          <source>HDF5 Format</source>
          <target state="translated">Formato HDF5</target>
        </trans-unit>
        <trans-unit id="13e3758fc9538b8efd6e347d1be18dbf1cbc68fd" translate="yes" xml:space="preserve">
          <source>HDF5 reading / writing</source>
          <target state="translated">HDF5 lectura/escritura</target>
        </trans-unit>
        <trans-unit id="2042ab10d2a6b286f6f10f05830da036077c6714" translate="yes" xml:space="preserve">
          <source>HDF5-based reading / writing</source>
          <target state="translated">Lectura/escritura basada en HDF5</target>
        </trans-unit>
        <trans-unit id="75fbd819b26ac15432c615f102871f48862eb405" translate="yes" xml:space="preserve">
          <source>HDFStore</source>
          <target state="translated">HDFStore</target>
        </trans-unit>
        <trans-unit id="1e6cc28b0699c70e48d3ba2bd954a3c1d6db4410" translate="yes" xml:space="preserve">
          <source>HDFStore will by default not drop rows that are all missing. This behavior can be changed by setting &lt;code&gt;dropna=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2315b78c90521194806e6ff15e4519be29290f8e" translate="yes" xml:space="preserve">
          <source>HDFStore.append()</source>
          <target state="translated">HDFStore.append()</target>
        </trans-unit>
        <trans-unit id="3c06f7762f6274d7f755a35a5ece2d1938d4d16f" translate="yes" xml:space="preserve">
          <source>HDFStore.get()</source>
          <target state="translated">HDFStore.get()</target>
        </trans-unit>
        <trans-unit id="cf1d970069f4505ca66af47560075f080d7fdebb" translate="yes" xml:space="preserve">
          <source>HDFStore.groups()</source>
          <target state="translated">HDFStore.groups()</target>
        </trans-unit>
        <trans-unit id="2ac4435c6ecd4445adfd51cc1924d3128de8464c" translate="yes" xml:space="preserve">
          <source>HDFStore.info()</source>
          <target state="translated">HDFStore.info()</target>
        </trans-unit>
        <trans-unit id="a63dab9ef218085a01b08427a9709a9da31fdd26" translate="yes" xml:space="preserve">
          <source>HDFStore.keys()</source>
          <target state="translated">HDFStore.keys()</target>
        </trans-unit>
        <trans-unit id="3adc308c4363c6063de35b9f347d5df2b4b2dd55" translate="yes" xml:space="preserve">
          <source>HDFStore.put()</source>
          <target state="translated">HDFStore.put()</target>
        </trans-unit>
        <trans-unit id="f47662db7950975a5ae22dcd0f80f911933903e7" translate="yes" xml:space="preserve">
          <source>HDFStore.select()</source>
          <target state="translated">HDFStore.select()</target>
        </trans-unit>
        <trans-unit id="1832f491303fd89a2974748d322daf584ae70a42" translate="yes" xml:space="preserve">
          <source>HDFStore.walk()</source>
          <target state="translated">HDFStore.walk()</target>
        </trans-unit>
        <trans-unit id="a7b6ae83f2cc25f8ad0ff53d17f8388b4154d54e" translate="yes" xml:space="preserve">
          <source>HDFStore: PyTables (HDF5)</source>
          <target state="translated">HDFStore:Tablas PyT (HDF5)</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="06c9f44f3e2be2f8c75b4052579d6903ad2edb30" translate="yes" xml:space="preserve">
          <source>HTML Table Parsing Gotchas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec8b87bbf1ceb04748df519c09bdd4a4242e7e8" translate="yes" xml:space="preserve">
          <source>HTML parser for read_html (see &lt;a href=&quot;#optional-html&quot;&gt;note&lt;/a&gt;)</source>
          <target state="translated">Analizador HTML para read_html (ver &lt;a href=&quot;#optional-html&quot;&gt;nota&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="5bd8e02b619f57af85ab307312adff41f7e01a52" translate="yes" xml:space="preserve">
          <source>HTML result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1bf76b1fca3d41efaf27152174bffcbb14206d" translate="yes" xml:space="preserve">
          <source>HTML result. These classes are added within specified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11dc542c0ffeed8b41bad901e2044f438e4ab0e5" translate="yes" xml:space="preserve">
          <source>HTML:</source>
          <target state="translated">HTML:</target>
        </trans-unit>
        <trans-unit id="dc1a076811de9231220364407db78fe7dff1efa1" translate="yes" xml:space="preserve">
          <source>Hadley Wickham&amp;rsquo;s &lt;a href=&quot;https://ggplot2.tidyverse.org/&quot;&gt;ggplot2&lt;/a&gt; is a foundational exploratory visualization package for the R language. Based on &lt;a href=&quot;https://www.cs.uic.edu/~wilkinson/TheGrammarOfGraphics/GOG.html&quot;&gt;&amp;ldquo;The Grammar of Graphics&amp;rdquo;&lt;/a&gt; it provides a powerful, declarative and extremely general way to generate bespoke plots of any kind of data. It&amp;rsquo;s really quite incredible. Various implementations to other languages are available, but a faithful implementation for Python users has long been missing. Although still young (as of Jan-2014), the &lt;a href=&quot;https://github.com/yhat/ggpy&quot;&gt;yhat/ggpy&lt;/a&gt; project has been progressing quickly in that direction.</source>
          <target state="translated">&lt;a href=&quot;https://ggplot2.tidyverse.org/&quot;&gt;Ggplot2 de&lt;/a&gt; Hadley Wickham es un paquete de visualizaci&amp;oacute;n exploratorio fundamental para el lenguaje R. Basado en &lt;a href=&quot;https://www.cs.uic.edu/~wilkinson/TheGrammarOfGraphics/GOG.html&quot;&gt;&amp;ldquo;La gram&amp;aacute;tica de los gr&amp;aacute;ficos&amp;rdquo;&lt;/a&gt; , proporciona una forma poderosa, declarativa y extremadamente general de generar gr&amp;aacute;ficos personalizados de cualquier tipo de datos. Es realmente incre&amp;iacute;ble. Est&amp;aacute;n disponibles varias implementaciones para otros lenguajes, pero hace mucho que falta una implementaci&amp;oacute;n fiel para los usuarios de Python. Aunque todav&amp;iacute;a es joven (en enero de 2014), el proyecto &lt;a href=&quot;https://github.com/yhat/ggpy&quot;&gt;yhat / ggpy&lt;/a&gt; ha progresado r&amp;aacute;pidamente en esa direcci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="58e12ddb14f6f822bcd8d3ae4e6bb3cbe96c7a13" translate="yes" xml:space="preserve">
          <source>Handle these ambiguous times by specifying the following.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c197bf13850693a62be0f9cbc4ad92a5ec806fd" translate="yes" xml:space="preserve">
          <source>Handler to call if object cannot otherwise be converted to a suitable format for JSON. Should receive a single argument which is the object to convert and return a serialisable object.</source>
          <target state="translated">Manejador para llamar si el objeto no puede ser convertido de otra manera a un formato adecuado para JSON.Debe recibir un único argumento que es el objeto a convertir y devolver un objeto serializable.</target>
        </trans-unit>
        <trans-unit id="1bc3b2505837662fcbdfc517f2a1895b70ef262d" translate="yes" xml:space="preserve">
          <source>Handles the leap year case as well:</source>
          <target state="translated">También se ocupa del caso del año bisiesto:</target>
        </trans-unit>
        <trans-unit id="46d71ad7a53d41e7f92c55501ff895dde5287631" translate="yes" xml:space="preserve">
          <source>Handling &amp;ldquo;bad&amp;rdquo; lines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90545bb5835723940b207d6d85a9b68c0212d6c8" translate="yes" xml:space="preserve">
          <source>Handling column names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b705fcddebca8a2e54628df55916f3a124b0fddf" translate="yes" xml:space="preserve">
          <source>Handling indexes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804fe0806cf830f124c1462f636392df61b369ab" translate="yes" xml:space="preserve">
          <source>Handling of (un)observed Categorical values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebd411c16de03f824e7e963a0ca15fcfc23c034" translate="yes" xml:space="preserve">
          <source>Has no effect but is accepted for compatibility with numpy.</source>
          <target state="translated">No tiene ningún efecto pero se acepta por su compatibilidad con el numpy.</target>
        </trans-unit>
        <trans-unit id="3008b93348839f05f66696fd64d26af09f702629" translate="yes" xml:space="preserve">
          <source>Has the correct &lt;code&gt;env&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; class attributes set.</source>
          <target state="translated">Tiene los atributos de clase de &lt;code&gt;template&lt;/code&gt; y &lt;code&gt;env&lt;/code&gt; correctos establecidos.</target>
        </trans-unit>
        <trans-unit id="38d2254d4a789d989c2b2664108442e3526a1101" translate="yes" xml:space="preserve">
          <source>Hash table-based unique.</source>
          <target state="translated">La mesa de hachís es única.</target>
        </trans-unit>
        <trans-unit id="6425f543a801b25f82203571fd175fdf4730a76a" translate="yes" xml:space="preserve">
          <source>Hash table-based unique. Uniques are returned in order of appearance. This does NOT sort.</source>
          <target state="translated">La mesa de hachís es única.Los únicos se devuelven en orden de aparición.Esto NO se ordena.</target>
        </trans-unit>
        <trans-unit id="e193cbedf5e701ce24af4ab6f04e23203933d9e8" translate="yes" xml:space="preserve">
          <source>Hash_key for string key to encode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="7ca230abf27a8d0783dda3e3a009514bc03f3dcc" translate="yes" xml:space="preserve">
          <source>Having a duplicated index will raise for a &lt;code&gt;.reindex()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880b58b88e88151082e731678ce3c724dafb7219" translate="yes" xml:space="preserve">
          <source>Head and tail</source>
          <target state="translated">Cabeza y cola</target>
        </trans-unit>
        <trans-unit id="1bb6d883feee979d1e59b94e521dd11f3e0a12d1" translate="yes" xml:space="preserve">
          <source>Helper function to convert DataFrame and Series to matplotlib.table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6feb04d2cc1517b1a7d23c7680888c4feb48d2" translate="yes" xml:space="preserve">
          <source>Helps style a DataFrame or Series according to the data with HTML and CSS.</source>
          <target state="translated">Ayuda a estilizar un DataFrame o una Serie de acuerdo a los datos con HTML y CSS.</target>
        </trans-unit>
        <trans-unit id="158ccd51d8c878205e5636d3f99db16bf05effe5" translate="yes" xml:space="preserve">
          <source>Here &amp;lsquo;c&amp;rsquo; and &amp;lsquo;f&amp;rsquo; are not represented in the data and will not be shown in the output because dropna is True by default. Set dropna=False to preserve categories with no data.</source>
          <target state="translated">Aqu&amp;iacute; 'c' y 'f' no est&amp;aacute;n representados en los datos y no se mostrar&amp;aacute;n en la salida porque dropna es True por defecto. Establezca dropna = False para conservar las categor&amp;iacute;as sin datos.</target>
        </trans-unit>
        <trans-unit id="8619034f5d8a24bc1e04110edf64b5187717db5d" translate="yes" xml:space="preserve">
          <source>Here &lt;a href=&quot;../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform&quot;&gt;&lt;code&gt;transform()&lt;/code&gt;&lt;/a&gt; received a single function; this is equivalent to a &lt;a href=&quot;https://numpy.org/doc/stable/reference/ufuncs.html&quot;&gt;ufunc&lt;/a&gt; application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb498dc0133a396e16fbab2a4cc64715ce635afe" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;'type'&lt;/code&gt; is optional, and can be a nested pandas type specification here (but not categorical)</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;'type'&lt;/code&gt; es opcional y puede ser una especificaci&amp;oacute;n de tipo pandas anidada aqu&amp;iacute; (pero no categ&amp;oacute;rica)</target>
        </trans-unit>
        <trans-unit id="1d0d20df741a19de9966e743d9965ede0d8c2325" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;origin&lt;/code&gt; is the default name given to your remote repository on GitHub. You can see the remote repositories:</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;origin&lt;/code&gt; es el nombre predeterminado que se le da a su repositorio remoto en GitHub. Puedes ver los repositorios remotos:</target>
        </trans-unit>
        <trans-unit id="dd7acc3d2934c47bf767aabcf0a0a1045090fcba" translate="yes" xml:space="preserve">
          <source>Here are a few interesting examples.</source>
          <target state="translated">Aquí hay algunos ejemplos interesantes.</target>
        </trans-unit>
        <trans-unit id="57c90bbd4cc0875781c24f250ae82def1a858909" translate="yes" xml:space="preserve">
          <source>Here are just a few of the things that pandas does well:</source>
          <target state="translated">Aquí hay algunas de las cosas que los pandas hacen bien:</target>
        </trans-unit>
        <trans-unit id="a48a53a3eeb7f35d9bd9ef58204ea375b22f3555" translate="yes" xml:space="preserve">
          <source>Here are some examples of datetime strings that can be guessed (All representing December 30th, 2011 at 00:00:00):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4aeaea13540388e074b786658dd6cb588265e66" translate="yes" xml:space="preserve">
          <source>Here is a basic tenet to keep in mind: &lt;strong&gt;data alignment is intrinsic&lt;/strong&gt;. The link between labels and data will not be broken unless done so explicitly by you.</source>
          <target state="translated">Aqu&amp;iacute; hay un principio b&amp;aacute;sico a tener en cuenta: &lt;strong&gt;la alineaci&amp;oacute;n de datos es intr&amp;iacute;nseca&lt;/strong&gt; . El v&amp;iacute;nculo entre las etiquetas y los datos no se romper&amp;aacute; a menos que usted lo haga expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="1ea58d8d9e42af87e8caa9d68ed8a547761d5bb4" translate="yes" xml:space="preserve">
          <source>Here is a more complicated example with multiple join keys. Only the keys appearing in &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; are present (the intersection), since &lt;code&gt;how='inner'&lt;/code&gt; by default.</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestra un ejemplo m&amp;aacute;s complicado con varias claves de combinaci&amp;oacute;n. Solo est&amp;aacute;n presentes las claves que aparecen a &lt;code&gt;left&lt;/code&gt; y &lt;code&gt;right&lt;/code&gt; (la intersecci&amp;oacute;n), ya que &lt;code&gt;how='inner'&lt;/code&gt; por defecto.</target>
        </trans-unit>
        <trans-unit id="ab8e8ea95ae7bf0defacc7692b79888576dc32c3" translate="yes" xml:space="preserve">
          <source>Here is a quick reference summary table of common functions. Each also takes an optional &lt;code&gt;level&lt;/code&gt; parameter which applies only if the object has a &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;hierarchical index&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d5643537f0f51a6854fc58eb3352e4428cfc1a6" translate="yes" xml:space="preserve">
          <source>Here is a real-world times-series example</source>
          <target state="translated">Aquí hay un ejemplo de una serie temporal en el mundo real</target>
        </trans-unit>
        <trans-unit id="2761aae2553cd60018f3fc88987941d00c347168" translate="yes" xml:space="preserve">
          <source>Here is a recipe for generating a query and using it to create equal sized return chunks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a5d5de06a3beca2e7b0755d842882c6d86b038" translate="yes" xml:space="preserve">
          <source>Here is a sample (using 100 column x 100,000 row &lt;code&gt;DataFrames&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb9fc3a406988ae21b268f402abd1ae6f24810e" translate="yes" xml:space="preserve">
          <source>Here is a typical use-case for using this type of indexing. Imagine that you have a somewhat irregular timedelta-like indexing scheme, but the data is recorded as floats. This could, for example, be millisecond offsets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c821efcdfcf141472c6dc48cb7fc32b0aa88f1" translate="yes" xml:space="preserve">
          <source>Here is a typical usecase. You have comma separated strings in a column and want to expand this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f944828834dd16d5151a4915c604fb981122b37" translate="yes" xml:space="preserve">
          <source>Here is an example of a self-contained set of tests that illustrate multiple features that we like to use.</source>
          <target state="translated">A continuación se presenta un ejemplo de un conjunto de pruebas autónomas que ilustran las múltiples características que nos gusta utilizar.</target>
        </trans-unit>
        <trans-unit id="23a618ab8a95adb5ee1b90429b7d557f8f970e97" translate="yes" xml:space="preserve">
          <source>Here is an example of each of these methods. First, the default &lt;code&gt;join='outer'&lt;/code&gt; behavior:</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestra un ejemplo de cada uno de estos m&amp;eacute;todos. Primero, el comportamiento predeterminado &lt;code&gt;join='outer'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f53355fe7427e04619d8bfd8d6d3f63a25299701" translate="yes" xml:space="preserve">
          <source>Here is an example of one way to easily plot group means with standard deviations from the raw data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ebc10164acf0daf0825fdd5c161702fb625bfa" translate="yes" xml:space="preserve">
          <source>Here is another example with duplicate join keys in DataFrames:</source>
          <target state="translated">Aquí hay otro ejemplo con claves de unión duplicadas en los DataFrames:</target>
        </trans-unit>
        <trans-unit id="f00ebbc96feac952e5b8441f93f7abf964a535a4" translate="yes" xml:space="preserve">
          <source>Here is how to view the top and bottom rows of the frame:</source>
          <target state="translated">Aquí está cómo ver las filas superiores e inferiores del marco:</target>
        </trans-unit>
        <trans-unit id="43a546924cfd7fc3d41ac31690e23053da201bb2" translate="yes" xml:space="preserve">
          <source>Here is the default behavior, notice how the x-axis tick labeling is performed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4bad7934460a80f863bfdba98774b48472faf0" translate="yes" xml:space="preserve">
          <source>Here is the same thing with &lt;code&gt;join='inner'&lt;/code&gt;:</source>
          <target state="translated">Aqu&amp;iacute; es lo mismo con &lt;code&gt;join='inner'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="16c36edb11aab952de7238aea1b16530fc5cb8f5" translate="yes" xml:space="preserve">
          <source>Here we can see that, when setting &lt;code&gt;origin&lt;/code&gt; to &lt;code&gt;'epoch'&lt;/code&gt;, the result after &lt;code&gt;'2000-10-02 00:00:00'&lt;/code&gt; are identical depending on the start of time series:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e8b6e3df62487c5013989ae5875e737adce772" translate="yes" xml:space="preserve">
          <source>Here we can see that, when using &lt;code&gt;origin&lt;/code&gt; with its default value (&lt;code&gt;'start_day'&lt;/code&gt;), the result after &lt;code&gt;'2000-10-02 00:00:00'&lt;/code&gt; are not identical depending on the start of time series:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a130bb6d2b269db357d8376f97e1107e7ce04d4c" translate="yes" xml:space="preserve">
          <source>Here we construct a simple time series data set to use for illustrating the indexing functionality:</source>
          <target state="translated">Aquí construimos un simple conjunto de datos de series temporales para usar para ilustrar la funcionalidad de indexación:</target>
        </trans-unit>
        <trans-unit id="fd9b2cf6332d18d9140f68e40ee723e9daac96ff" translate="yes" xml:space="preserve">
          <source>Here we discuss a lot of the essential functionality common to the pandas data structures. Here&amp;rsquo;s how to create some of the objects used in the examples from the previous section:</source>
          <target state="translated">Aqu&amp;iacute; discutimos gran parte de la funcionalidad esencial com&amp;uacute;n a las estructuras de datos de pandas. A continuaci&amp;oacute;n, se explica c&amp;oacute;mo crear algunos de los objetos utilizados en los ejemplos de la secci&amp;oacute;n anterior:</target>
        </trans-unit>
        <trans-unit id="520aaca96214b09c92db1a304a3c24a849e08087" translate="yes" xml:space="preserve">
          <source>Here we discuss a lot of the essential functionality common to the pandas data structures. To begin, let&amp;rsquo;s create some example objects like we did in the &lt;a href=&quot;10min#min&quot;&gt;10 minutes to pandas&lt;/a&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1962f1379801e34e3473e040d888c5d732cbc345" translate="yes" xml:space="preserve">
          <source>Here we multiply a DataFrame with a Series.</source>
          <target state="translated">Aquí multiplicamos un DataFrame por una Serie.</target>
        </trans-unit>
        <trans-unit id="217a16b260162c6b9ecb75aafaf0420285c29b8e" translate="yes" xml:space="preserve">
          <source>Here we multiply a DataFrame with another DataFrame.</source>
          <target state="translated">Aquí multiplicamos un DataFrame por otro DataFrame.</target>
        </trans-unit>
        <trans-unit id="901b74d6c5c2ab9f7fb4f6269ab16305edfca5b2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a boring example of rendering a DataFrame, without any (visible) styles:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo aburrido de renderizar un DataFrame, sin ning&amp;uacute;n estilo (visible):</target>
        </trans-unit>
        <trans-unit id="ade488284bcb2d315b9857b5a71d06a045b7e2a6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example implementation, which relies on casting the extension array to object dtype. This uses the helper method &lt;code&gt;pandas.api.extensions.take()&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; hay una implementaci&amp;oacute;n de ejemplo, que se basa en convertir la matriz de extensi&amp;oacute;n al objeto dtype. Esto usa el m&amp;eacute;todo auxiliar &lt;code&gt;pandas.api.extensions.take()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa4e641ba9561c10a3cc502bc8073154340d3577" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how the index metadata is structured in pyarrow:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo de c&amp;oacute;mo se estructuran los metadatos del &amp;iacute;ndice en pyarrow:</target>
        </trans-unit>
        <trans-unit id="f572a71811f0f563fe73dd42aa90e9196d2abf9f" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you can change the above with the new &lt;code&gt;align='mid'&lt;/code&gt; option:</source>
          <target state="translated">As&amp;iacute; es como puede cambiar lo anterior con la nueva opci&amp;oacute;n &lt;code&gt;align='mid'&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab62496d5c665ac1b5f50c1319d13221f4ea9788" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the function in pure Python:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la funci&amp;oacute;n en Python puro:</target>
        </trans-unit>
        <trans-unit id="8d56691ee65295aa8cd217efc5f1fb0ec7a019f8" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the template structure:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la estructura de la plantilla:</target>
        </trans-unit>
        <trans-unit id="cd5f260a168827626f78de5b53f7fbc115fd0ce9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;c0&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;ci0&amp;gt;&lt;/code&gt; and so forth are dictionaries containing the metadata for each column, &lt;em&gt;including the index columns&lt;/em&gt;. This has JSON form:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;&amp;lt;c0&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;ci0&amp;gt;&lt;/code&gt; y as&amp;iacute; sucesivamente son diccionarios que contienen los metadatos de cada columna, &lt;em&gt;incluidas las columnas de &amp;iacute;ndice&lt;/em&gt; . Esto tiene forma JSON:</target>
        </trans-unit>
        <trans-unit id="ea88593cb4a459ae35a505f3a4797efa4ba41e7d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;data&lt;/code&gt; can be many different things:</source>
          <target state="translated">Aqu&amp;iacute;, los &lt;code&gt;data&lt;/code&gt; pueden ser muchas cosas diferentes:</target>
        </trans-unit>
        <trans-unit id="2209d4a279c0f96f254c0f3985cac25e0c79d658" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;f&lt;/code&gt; label was not contained in the Series and hence appears as &lt;code&gt;NaN&lt;/code&gt; in the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367e96118a43c8abe35b5adc3684f98a88f4d169" translate="yes" xml:space="preserve">
          <source>Here, there are expressions on different lines, making it multiline, but the last line has no variable assigned to the output of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8578a243d227600659d59a488618d0fcbdeafb33" translate="yes" xml:space="preserve">
          <source>Here, there are expressions on different lines, making it multiline, but the last line has no variable assigned to the output of &lt;code&gt;a + 2&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, hay expresiones en diferentes l&amp;iacute;neas, por lo que es multil&amp;iacute;nea, pero la &amp;uacute;ltima l&amp;iacute;nea no tiene ninguna variable asignada a la salida de &lt;code&gt;a + 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="453713ccad6edfbc5405a61e004c0c1430893a5b" translate="yes" xml:space="preserve">
          <source>Hexagonal bin plot</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29aaaf58b1b7c87af3da68daa99b0dc678b41d70" translate="yes" xml:space="preserve">
          <source>Hexagonal binning plot using matplotlib, the matplotlib function that is used under the hood.</source>
          <target state="translated">Trazado hexagonal de binoculares usando matplotlib,la función matplotlib que se usa bajo el capó.</target>
        </trans-unit>
        <trans-unit id="e4ea59ac502bd091d6b3044bcc3a7e4faa7076ab" translate="yes" xml:space="preserve">
          <source>Hexbin</source>
          <target state="translated">Hexbin</target>
        </trans-unit>
        <trans-unit id="4b2faf5cd777f9e9a92fe8907b82dcdf0f0474e9" translate="yes" xml:space="preserve">
          <source>Hide any indices from rendering.</source>
          <target state="translated">Ocultar cualquier índice de la representación.</target>
        </trans-unit>
        <trans-unit id="78d0b0e4e9c34ece1c9f3157d86d6d1ecb4d874b" translate="yes" xml:space="preserve">
          <source>Hide columns from rendering.</source>
          <target state="translated">Ocultar las columnas de la representación.</target>
        </trans-unit>
        <trans-unit id="bd353e1c956b727376767cec3296c124209a3bf3" translate="yes" xml:space="preserve">
          <source>Hiding the Index or Columns</source>
          <target state="translated">Ocultar el índice o las columnas</target>
        </trans-unit>
        <trans-unit id="9bfcf47106d24e26c8f6da4717ec31b0b2fed3e9" translate="yes" xml:space="preserve">
          <source>Hierarchical / Multi-level indexing is very exciting as it opens the door to some quite sophisticated data analysis and manipulation, especially for working with higher dimensional data. In essence, it enables you to store and manipulate data with an arbitrary number of dimensions in lower dimensional data structures like &lt;code&gt;Series&lt;/code&gt; (1d) and &lt;code&gt;DataFrame&lt;/code&gt; (2d).</source>
          <target state="translated">La indexaci&amp;oacute;n jer&amp;aacute;rquica / multinivel es muy emocionante, ya que abre la puerta a un an&amp;aacute;lisis y manipulaci&amp;oacute;n de datos bastante sofisticados, especialmente para trabajar con datos de dimensiones superiores. En esencia, le permite almacenar y manipular datos con un n&amp;uacute;mero arbitrario de dimensiones en estructuras de datos de menor dimensi&amp;oacute;n como &lt;code&gt;Series&lt;/code&gt; (1d) y &lt;code&gt;DataFrame&lt;/code&gt; (2d).</target>
        </trans-unit>
        <trans-unit id="26c08f6047ab488a2eab24b98eb1681296096769" translate="yes" xml:space="preserve">
          <source>Hierarchical Data Format (HDF) is self-describing, allowing an application to interpret the structure and contents of a file with no outside information. One HDF file can hold a mix of related objects which can be accessed as a group or as individual objects.</source>
          <target state="translated">El formato de datos jerárquicos (HDF)se describe a sí mismo,permitiendo que una aplicación interprete la estructura y el contenido de un archivo sin información externa.Un archivo HDF puede contener una mezcla de objetos relacionados a los que se puede acceder como grupo o como objetos individuales.</target>
        </trans-unit>
        <trans-unit id="67724216d805a96555340d07e6d2a1f2633c2f46" translate="yes" xml:space="preserve">
          <source>Hierarchical indexing (MultiIndex)</source>
          <target state="translated">Indización jerárquica (MultiIndex)</target>
        </trans-unit>
        <trans-unit id="1a9f500d25e9b6e9fe7d2a3db8e7b8f2d7ac56fe" translate="yes" xml:space="preserve">
          <source>Hierarchical keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7fe953892ec885f20573b0003196c021532c0e" translate="yes" xml:space="preserve">
          <source>Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d5447bdfc0df1a34b46d8a2d1ee8d33f0c163c" translate="yes" xml:space="preserve">
          <source>Hierarchical queries on a HDFStore</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3837ce83f3d8a13c3570b62b1a2b446adaff328e" translate="yes" xml:space="preserve">
          <source>Highlight the maximum by shading the background.</source>
          <target state="translated">Resalta el máximo sombreando el fondo.</target>
        </trans-unit>
        <trans-unit id="95eeff0d7f01c83d8e331dfa7e0642eef83365e6" translate="yes" xml:space="preserve">
          <source>Highlight the minimum by shading the background.</source>
          <target state="translated">Resalta lo mínimo sombreando el fondo.</target>
        </trans-unit>
        <trans-unit id="28572094b6f31e2425178183c31a01aadfbfa89f" translate="yes" xml:space="preserve">
          <source>Hint to the hashtable sizer.</source>
          <target state="translated">Una pista para el clasificador de hachís.</target>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="0535ab5fb89daffb4f49da30bceb3bd47fb53e02" translate="yes" xml:space="preserve">
          <source>Histogramming</source>
          <target state="translated">Histogramming</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="63bf65c682511a4e911a035e53ebaec3bd640815" translate="yes" xml:space="preserve">
          <source>Histograms can be drawn by using the &lt;a href=&quot;../reference/api/pandas.dataframe.plot.hist#pandas.DataFrame.plot.hist&quot;&gt;&lt;code&gt;DataFrame.plot.hist()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.series.plot.hist#pandas.Series.plot.hist&quot;&gt;&lt;code&gt;Series.plot.hist()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">Los histogramas se pueden dibujar utilizando los &lt;a href=&quot;../reference/api/pandas.dataframe.plot.hist#pandas.DataFrame.plot.hist&quot;&gt; &lt;code&gt;DataFrame.plot.hist()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../reference/api/pandas.series.plot.hist#pandas.Series.plot.hist&quot;&gt; &lt;code&gt;Series.plot.hist()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27f0f11e6d450b6c48a57c7b24ced4711f75593d" translate="yes" xml:space="preserve">
          <source>Holiday calendars can be used to provide the list of holidays. See the &lt;a href=&quot;#timeseries-holiday&quot;&gt;holiday calendar&lt;/a&gt; section for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515694a72054239ce456c9d00c296205caabf8e9" translate="yes" xml:space="preserve">
          <source>Holidays / holiday calendars</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="616d8701b286696dac56ea5e0564f7f0664ba1a3" translate="yes" xml:space="preserve">
          <source>Holidays and calendars provide a simple way to define holiday rules to be used with &lt;code&gt;CustomBusinessDay&lt;/code&gt; or in other analysis that requires a predefined set of holidays. The &lt;code&gt;AbstractHolidayCalendar&lt;/code&gt; class provides all the necessary methods to return a list of holidays and only &lt;code&gt;rules&lt;/code&gt; need to be defined in a specific holiday calendar class. Furthermore, the &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; class attributes determine over what date range holidays are generated. These should be overwritten on the &lt;code&gt;AbstractHolidayCalendar&lt;/code&gt; class to have the range apply to all calendar subclasses. &lt;code&gt;USFederalHolidayCalendar&lt;/code&gt; is the only calendar that exists and primarily serves as an example for developing other calendars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9d332c80b88cbc5ba41e638f5ce24c1e73743a" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical error bars can be supplied to the &lt;code&gt;xerr&lt;/code&gt; and &lt;code&gt;yerr&lt;/code&gt; keyword arguments to &lt;a href=&quot;../reference/api/pandas.dataframe.plot#pandas.DataFrame.plot&quot;&gt;&lt;code&gt;plot()&lt;/code&gt;&lt;/a&gt;. The error values can be specified using a variety of formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798d45d4f1a4e0cb111c2c75f0fa48db95a41bbc" translate="yes" xml:space="preserve">
          <source>Horizontal bar plot.</source>
          <target state="translated">Trazado de barras horizontales.</target>
        </trans-unit>
        <trans-unit id="c37cf838b0b980da78f19ac1366359fb80951f62" translate="yes" xml:space="preserve">
          <source>Hour</source>
          <target state="translated">Hour</target>
        </trans-unit>
        <trans-unit id="425c6644ee61c9a230fcbf65d7494b117f494021" translate="yes" xml:space="preserve">
          <source>Hour (12-hour clock) as a decimal number [01,12].</source>
          <target state="translated">La hora (reloj de 12 horas)como número decimal [01,12].</target>
        </trans-unit>
        <trans-unit id="fb9eb08a7d5aa5786e2bc10ef029f16e805c8a84" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) as a decimal number [00,23].</source>
          <target state="translated">La hora (reloj de 24 horas)como número decimal [00,23].</target>
        </trans-unit>
        <trans-unit id="03a69bfc0ec29e28cb09c485868505a4c11f3bca" translate="yes" xml:space="preserve">
          <source>Hour value of the period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ac924a77d55d00e79592ebf70cc9ed9ee316d5" translate="yes" xml:space="preserve">
          <source>Hour.apply()</source>
          <target state="translated">Hour.apply()</target>
        </trans-unit>
        <trans-unit id="35bdb37831e82b82f92a864b1de84dce868b6263" translate="yes" xml:space="preserve">
          <source>Hour.apply_index()</source>
          <target state="translated">Hour.apply_index()</target>
        </trans-unit>
        <trans-unit id="1f7e570565de4188139ce1f495f0a4a767e428ee" translate="yes" xml:space="preserve">
          <source>Hour.base</source>
          <target state="translated">Hour.base</target>
        </trans-unit>
        <trans-unit id="8e585e3df04c4eec4de525fdca327fd2ba65e241" translate="yes" xml:space="preserve">
          <source>Hour.copy()</source>
          <target state="translated">Hour.copy()</target>
        </trans-unit>
        <trans-unit id="0b44862c33cc1a129b4117e0a1d4417ca66ca4c7" translate="yes" xml:space="preserve">
          <source>Hour.delta</source>
          <target state="translated">Hour.delta</target>
        </trans-unit>
        <trans-unit id="74c19e92ad107036eb344727623e1624200ae97c" translate="yes" xml:space="preserve">
          <source>Hour.freqstr</source>
          <target state="translated">Hour.freqstr</target>
        </trans-unit>
        <trans-unit id="691d0fbccd1823943092dfae8501b40efd199b1b" translate="yes" xml:space="preserve">
          <source>Hour.isAnchored()</source>
          <target state="translated">Hour.isAnchored()</target>
        </trans-unit>
        <trans-unit id="acea6d808fb787e2e979f0a7998c4c3df4d8fdd5" translate="yes" xml:space="preserve">
          <source>Hour.kwds</source>
          <target state="translated">Hour.kwds</target>
        </trans-unit>
        <trans-unit id="151d0e20cbd270cc7fb43e6f25553f0878a45a70" translate="yes" xml:space="preserve">
          <source>Hour.name</source>
          <target state="translated">Hour.name</target>
        </trans-unit>
        <trans-unit id="58d34fac168d93b38466a203549a3caebb9ae352" translate="yes" xml:space="preserve">
          <source>Hour.nanos</source>
          <target state="translated">Hour.nanos</target>
        </trans-unit>
        <trans-unit id="0105783696e6fdc9e5a7987c9699f50e93cff23e" translate="yes" xml:space="preserve">
          <source>Hour.normalize</source>
          <target state="translated">Hour.normalize</target>
        </trans-unit>
        <trans-unit id="739f2fb0b17377837145e941edbf36e33fdcc828" translate="yes" xml:space="preserve">
          <source>Hour.onOffset()</source>
          <target state="translated">Hour.onOffset()</target>
        </trans-unit>
        <trans-unit id="ef471ab00360fbd9ee97bd21ccfb08b1d39e4f2e" translate="yes" xml:space="preserve">
          <source>Hour.rollback()</source>
          <target state="translated">Hour.rollback()</target>
        </trans-unit>
        <trans-unit id="5f509dd688e4275ebcb58828f5df610b3c98968c" translate="yes" xml:space="preserve">
          <source>Hour.rollforward()</source>
          <target state="translated">Hour.rollforward()</target>
        </trans-unit>
        <trans-unit id="ab0f7f4231f94b918d559de375fb69ef0eca4951" translate="yes" xml:space="preserve">
          <source>Hour.rule_code</source>
          <target state="translated">Hour.rule_code</target>
        </trans-unit>
        <trans-unit id="2a3dfca25bfb019117c3cc536806011800c9abd7" translate="yes" xml:space="preserve">
          <source>Hours: &amp;lsquo;H&amp;rsquo;</source>
          <target state="translated">Horas: 'H'</target>
        </trans-unit>
        <trans-unit id="9242a5cf1124466c24859cdaf585816d21ba9d1b" translate="yes" xml:space="preserve">
          <source>Hover to highlight.</source>
          <target state="translated">Pase el cursor para resaltar.</target>
        </trans-unit>
        <trans-unit id="a49764fca3c1e25986ac974c8d8c40659e3823f6" translate="yes" xml:space="preserve">
          <source>Hover to magnify</source>
          <target state="translated">Colóquese en el aire para magnificar</target>
        </trans-unit>
        <trans-unit id="283b111b642f8a04124a8e358013df41d1234238" translate="yes" xml:space="preserve">
          <source>How to align the bars with the cells.</source>
          <target state="translated">Cómo alinear las barras con las células.</target>
        </trans-unit>
        <trans-unit id="db6e9be9081ca92d77c03fe26dd79592e8be869b" translate="yes" xml:space="preserve">
          <source>How to behave if the table already exists.</source>
          <target state="translated">Cómo comportarse si la mesa ya existe.</target>
        </trans-unit>
        <trans-unit id="5d737c62270b3a47acff25bef86300e61500eac8" translate="yes" xml:space="preserve">
          <source>How to build the pandas documentation</source>
          <target state="translated">Cómo construir la documentación de los pandas</target>
        </trans-unit>
        <trans-unit id="c0e83970905861dcc3c10030c88fffa02a03906c" translate="yes" xml:space="preserve">
          <source>How to find the values that will be replaced.</source>
          <target state="translated">Cómo encontrar los valores que serán reemplazados.</target>
        </trans-unit>
        <trans-unit id="ef1fa5b11035bf1f8ae6577f9a0c105ba2e2b145" translate="yes" xml:space="preserve">
          <source>How to handle NAs before computing percent changes.</source>
          <target state="translated">Cómo manejar los NAs antes de que cambie el porcentaje de computación.</target>
        </trans-unit>
        <trans-unit id="a27a42eb28b5e559a07433ac0d391873cf2dd91a" translate="yes" xml:space="preserve">
          <source>How to handle indexes on other axis (or axes).</source>
          <target state="translated">Cómo manejar los índices en otro eje (o ejes).</target>
        </trans-unit>
        <trans-unit id="02c8e011c1a6a4bdf7e57bb059c9a9c96c0cbcdb" translate="yes" xml:space="preserve">
          <source>How to handle negative values in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8266c50c74c6156dfafa87c97ec3af24485274c" translate="yes" xml:space="preserve">
          <source>How to handle negative values in &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">C&amp;oacute;mo manejar valores negativos en &lt;code&gt;indices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a517432712fa10fd0ef073277ee02f0df0c11e06" translate="yes" xml:space="preserve">
          <source>How to handle non-NA values for overlapping keys:</source>
          <target state="translated">Cómo manejar los valores de no-NA para las claves superpuestas:</target>
        </trans-unit>
        <trans-unit id="f43e18e889c91ca8e330be78e88e8778e041728c" translate="yes" xml:space="preserve">
          <source>How to handle the operation of the two objects.</source>
          <target state="translated">Cómo manejar el funcionamiento de los dos objetos.</target>
        </trans-unit>
        <trans-unit id="4216b24f1023ffed1547bba13339a0671760163f" translate="yes" xml:space="preserve">
          <source>How to justify the column labels. If None uses the option from the print configuration (controlled by set_option), &amp;lsquo;right&amp;rsquo; out of the box. Valid values are</source>
          <target state="translated">C&amp;oacute;mo justificar las etiquetas de las columnas. Si Ninguno usa la opci&amp;oacute;n de la configuraci&amp;oacute;n de impresi&amp;oacute;n (controlada por set_option), &quot;derecho&quot; fuera de la caja. Los valores v&amp;aacute;lidos son</target>
        </trans-unit>
        <trans-unit id="02811e68280934a244076bbee273988252e2decb" translate="yes" xml:space="preserve">
          <source>How to rank NaN values:</source>
          <target state="translated">Cómo clasificar los valores de NaN:</target>
        </trans-unit>
        <trans-unit id="c81e5ee5f61ddfa3a78d5f341fad4ecdb5dbf234" translate="yes" xml:space="preserve">
          <source>How to rank the group of records that have the same value (i.e. ties):</source>
          <target state="translated">Cómo clasificar el grupo de registros que tienen el mismo valor (es decir,empates):</target>
        </trans-unit>
        <trans-unit id="996d750728af9280fc018cea501ee9ee8bf33d71" translate="yes" xml:space="preserve">
          <source>How to represent null values as str. Not allowed with append=True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6355c14b385846a9957518e259e8b8d6d85c59" translate="yes" xml:space="preserve">
          <source>How to set the index and join</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471a170bf31c512c1a494dec35601a8a64ba6702" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; can directly also support the time component as data itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c0b091654e5dfa38cb05b8014dccae44bda9da" translate="yes" xml:space="preserve">
          <source>However, for many applications this estimate may not be acceptable because the estimate covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimate correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See &lt;a href=&quot;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;Estimation of covariance matrices&lt;/a&gt; for more details.</source>
          <target state="translated">Sin embargo, para muchas aplicaciones, esta estimaci&amp;oacute;n puede no ser aceptable porque no se garantiza que la matriz de covarianza estimada sea semidefinida positiva. Esto podr&amp;iacute;a llevar a estimar correlaciones con valores absolutos mayores que uno y / o una matriz de covarianza no invertible. Consulte &lt;a href=&quot;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;Estimaci&amp;oacute;n de matrices de covarianza&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="4f30dd2978cd54ab19f166292391c83028de9bc4" translate="yes" xml:space="preserve">
          <source>However, for many applications this estimate may not be acceptable because the estimate covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimate correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;Estimation of covariance matrices&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea8c38f3625a97d53eaf6bdfdf954504f10d29b" translate="yes" xml:space="preserve">
          <source>However, if at least one of the two is absent &lt;em&gt;and&lt;/em&gt; the index is not sorted, an error will be raised (since doing otherwise would be computationally expensive, as well as potentially ambiguous for mixed type indexes). For instance, in the above example, &lt;code&gt;s.loc[1:6]&lt;/code&gt; would raise &lt;code&gt;KeyError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97abfa2058c4b2b46bd77047bcea7c55ad0f19cb" translate="yes" xml:space="preserve">
          <source>However, if the same element in both dataframes is None, that None is preserved</source>
          <target state="translated">Sin embargo,si el mismo elemento en ambos cuadros de datos es Ninguno,ese Ninguno se conserva</target>
        </trans-unit>
        <trans-unit id="3a03dd4a4919d77e193bdd2d0336e4f5f7cdca3c" translate="yes" xml:space="preserve">
          <source>However, if the string is treated as an exact match, the selection in &lt;code&gt;DataFrame&lt;/code&gt;&amp;rsquo;s &lt;code&gt;[]&lt;/code&gt; will be column-wise and not row-wise, see &lt;a href=&quot;indexing#indexing-basics&quot;&gt;Indexing Basics&lt;/a&gt;. For example &lt;code&gt;dft_minute['2011-12-31 23:59']&lt;/code&gt; will raise &lt;code&gt;KeyError&lt;/code&gt; as &lt;code&gt;'2012-12-31 23:59'&lt;/code&gt; has the same resolution as the index and there is no column with such name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa5d15a357f215082d304b7f83dbf3174f57094b" translate="yes" xml:space="preserve">
          <source>However, if you have bs4 and html5lib installed and pass &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;['lxml',
'bs4']&lt;/code&gt; then the parse will most likely succeed. Note that &lt;em&gt;as soon as a parse succeeds, the function will return&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba5f87176c631128dde92954aea07df8626e674" translate="yes" xml:space="preserve">
          <source>However, if you only had &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, determining the next element in the index can be somewhat complicated. For example, the following does not work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99ae8e704303cfb147ca20954e7c5d706c860d9" translate="yes" xml:space="preserve">
          <source>However, if you want an actual NumPy &lt;code&gt;datetime64[ns]&lt;/code&gt; array (with the values converted to UTC) instead of an array of objects, you can specify the &lt;code&gt;dtype&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8586709902eda78307d43fe1d0d6e66bde6ac09" translate="yes" xml:space="preserve">
          <source>However, in many cases it is more natural to associate things like change variables with a time span instead. The span represented by &lt;code&gt;Period&lt;/code&gt; can be specified explicitly, or inferred from datetime string format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742d8f13359fd0f11624a3ccb6310e89fb9120cd" translate="yes" xml:space="preserve">
          <source>However, instantiating StringArrays directly with non-strings will raise an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16b5b78eb22ffbe381a9afe057b0f7ef78e76bb" translate="yes" xml:space="preserve">
          <source>However, it comes with it a couple of trade-offs which I most certainly have not ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9268bff9bf083e3d79e17753e03c59437d23b40c" translate="yes" xml:space="preserve">
          <source>However, setting this option incorrectly for your terminal will cause these characters to be aligned incorrectly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f0e71582f79bc80ae9961177bfc8e3b8868102" translate="yes" xml:space="preserve">
          <source>However, their presence is indicated in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069df0e9a71bb80b7b5eae23852a6a27ea3af22b" translate="yes" xml:space="preserve">
          <source>However, these can be filled in using &lt;a href=&quot;../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna&quot;&gt;&lt;code&gt;fillna()&lt;/code&gt;&lt;/a&gt; and it will work fine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c113642dd4aea7e48ebcf42a5463be4a78e7eb62" translate="yes" xml:space="preserve">
          <source>However, this would &lt;em&gt;still&lt;/em&gt; raise if your resulting index is duplicated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c40de3c7cecbc0d644bc9d73ad07fe90fe31ba6" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;to_string&lt;/code&gt; will return a string representation of the DataFrame in tabular form, though it won&amp;rsquo;t always fit the console width:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba7929059d6edf0d7eddc551cc797b90990c10c2" translate="yes" xml:space="preserve">
          <source>However, when an axis is integer based, ONLY label based access and not positional access is supported. Thus, in such cases, it&amp;rsquo;s usually better to be explicit and use &lt;code&gt;.iloc&lt;/code&gt; or &lt;code&gt;.loc&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, cuando un eje est&amp;aacute; basado en n&amp;uacute;meros enteros, SOLO se admite el acceso basado en etiquetas y no el acceso posicional. Por lo tanto, en tales casos, generalmente es mejor ser expl&amp;iacute;cito y usar &lt;code&gt;.iloc&lt;/code&gt; o &lt;code&gt;.loc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bffc9ca5ad36fbad3b3a0f25c38eeb95a3771bef" translate="yes" xml:space="preserve">
          <source>However, you can do (notice the comment that needs to be added)</source>
          <target state="translated">Sin embargo,puede hacer (note el comentario que debe ser añadido)</target>
        </trans-unit>
        <trans-unit id="f8ac6f61c1aa59daf66de62601615682e1049435" translate="yes" xml:space="preserve">
          <source>Hypothesis is a library for property-based testing. Instead of explicitly parametrizing a test, you can describe &lt;em&gt;all&lt;/em&gt; valid inputs and let Hypothesis try to find a failing input. Even better, no matter how many random examples it tries, Hypothesis always reports a single minimal counterexample to your assertions - often an example that you would never have thought to test.</source>
          <target state="translated">Hypothesis es una biblioteca para pruebas basadas en propiedades. En lugar de parametrizar expl&amp;iacute;citamente una prueba, puede describir &lt;em&gt;todas&lt;/em&gt; las entradas v&amp;aacute;lidas y dejar que Hypothesis intente encontrar una entrada fallida. A&amp;uacute;n mejor, no importa cu&amp;aacute;ntos ejemplos aleatorios intente, Hypothesis siempre informa un &amp;uacute;nico contraejemplo m&amp;iacute;nimo de sus afirmaciones, a menudo un ejemplo que nunca hubiera pensado probar.</target>
        </trans-unit>
        <trans-unit id="6b4059c9b5820041f826f688b6e57c7201e42d5f" translate="yes" xml:space="preserve">
          <source>IDE</source>
          <target state="translated">IDE</target>
        </trans-unit>
        <trans-unit id="f8fd4493c0520c4dc8242f0098e35eb107cc179d" translate="yes" xml:space="preserve">
          <source>IEX</source>
          <target state="translated">IEX</target>
        </trans-unit>
        <trans-unit id="ca6691485e94f29b172edd1428309ac2c47100cc" translate="yes" xml:space="preserve">
          <source>IO tools</source>
          <target state="translated">Herramientas IO</target>
        </trans-unit>
        <trans-unit id="a462e1e327253efa119d5a0e2286d8d8d84ef77d" translate="yes" xml:space="preserve">
          <source>IO tools (text, CSV, HDF5, &amp;hellip;)</source>
          <target state="translated">Herramientas IO (texto, CSV, HDF5,&amp;hellip;)</target>
        </trans-unit>
        <trans-unit id="571ae8f12e56e6a82f24791cda171d0b8fd05d68" translate="yes" xml:space="preserve">
          <source>IPython</source>
          <target state="translated">IPython</target>
        </trans-unit>
        <trans-unit id="e81acf4cb4ac2f9dfa0516461c3ce5a6c992dff8" translate="yes" xml:space="preserve">
          <source>IPython Vega</source>
          <target state="translated">IPython Vega</target>
        </trans-unit>
        <trans-unit id="991bf056dd16995f47856efd54d6471c32029dfb" translate="yes" xml:space="preserve">
          <source>IPython is an interactive command shell and distributed computing environment. IPython tab completion works with Pandas methods and also attributes like DataFrame columns.</source>
          <target state="translated">IPython es un shell de comando interactivo y un entorno de computación distribuido.La terminación de pestañas de IPython funciona con los métodos de Pandas y también con atributos como las columnas de DataFrame.</target>
        </trans-unit>
        <trans-unit id="7ce0c669ac9952944e64534615185377818bf4dd" translate="yes" xml:space="preserve">
          <source>IX indexer is deprecated</source>
          <target state="translated">El indexador IX está desaprobado</target>
        </trans-unit>
        <trans-unit id="837958207e911e1a986e234409c61e629d2c52b7" translate="yes" xml:space="preserve">
          <source>Ideally, the attributes in &lt;code&gt;_metadata&lt;/code&gt; will match the parameters to your &lt;code&gt;ExtensionDtype.__init__&lt;/code&gt; (if any). If any of the attributes in &lt;code&gt;_metadata&lt;/code&gt; don&amp;rsquo;t implement the standard &lt;code&gt;__eq__&lt;/code&gt; or &lt;code&gt;__hash__&lt;/code&gt;, the default implementations here will not work.</source>
          <target state="translated">Idealmente, los atributos en &lt;code&gt;_metadata&lt;/code&gt; coincidir&amp;aacute;n con los par&amp;aacute;metros de su &lt;code&gt;ExtensionDtype.__init__&lt;/code&gt; (si corresponde). Si alguno de los atributos en &lt;code&gt;_metadata&lt;/code&gt; no implementa el &lt;code&gt;__eq__&lt;/code&gt; o &lt;code&gt;__hash__&lt;/code&gt; est&amp;aacute;ndar , las implementaciones predeterminadas aqu&amp;iacute; no funcionar&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="ca9b496aede42137d37ed26eee610c0663585a70" translate="yes" xml:space="preserve">
          <source>Identical method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed000ba923e4837b5f64d072ac83b369b8bbc564" translate="yes" xml:space="preserve">
          <source>Identifier for the group in the store.</source>
          <target state="translated">Identificador del grupo en la tienda.</target>
        </trans-unit>
        <trans-unit id="cc70bdac5409cb9636fe71b4171d38f1636e5344" translate="yes" xml:space="preserve">
          <source>Identifier of column that should be used as index of the DataFrame.</source>
          <target state="translated">Identificador de la columna que debe ser usada como índice del DataFrame.</target>
        </trans-unit>
        <trans-unit id="d1693517b90bc1546304cd1fb892ae941d720a6b" translate="yes" xml:space="preserve">
          <source>Identifies data (i.e. provides &lt;em&gt;metadata&lt;/em&gt;) using known indicators, important for analysis, visualization, and interactive console display.</source>
          <target state="translated">Identifica datos (es decir, proporciona &lt;em&gt;metadatos&lt;/em&gt; ) mediante indicadores conocidos, importantes para el an&amp;aacute;lisis, la visualizaci&amp;oacute;n y la visualizaci&amp;oacute;n de la consola interactiva.</target>
        </trans-unit>
        <trans-unit id="7b2b315db6cb8b61d91ac6d610561c15d151098e" translate="yes" xml:space="preserve">
          <source>Identity method.</source>
          <target state="translated">Método de identificación.</target>
        </trans-unit>
        <trans-unit id="ec04bd386a626dbd6df1f3954dfd578f058ce091" translate="yes" xml:space="preserve">
          <source>Idioms</source>
          <target state="translated">Idioms</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="f6003bd8eabce8b7ff3690312b777fcfeb97f5b7" translate="yes" xml:space="preserve">
          <source>If #1 fails, &lt;code&gt;date_parser&lt;/code&gt; is called with all the columns concatenated row-wise into a single array (e.g., &lt;code&gt;date_parser(['2013 1', '2013 2'])&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8cae4bf30e27a1848901c64267dcac0e2ff75cd" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaN</source>
          <target state="translated">Si es 'forzado', entonces el an&amp;aacute;lisis no v&amp;aacute;lido se establecer&amp;aacute; como NaN</target>
        </trans-unit>
        <trans-unit id="16bba9351b97f05aabf6f317cfe45f93cda01afb" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6702a592aaa4545f91194718e2267ecc33a26886" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaT</source>
          <target state="translated">Si es 'coaccionar', el an&amp;aacute;lisis no v&amp;aacute;lido se establecer&amp;aacute; como NaT</target>
        </trans-unit>
        <trans-unit id="e327c3620244d73e8137e7777edd3944c79b840d" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaT.</source>
          <target state="translated">Si es 'forzado', el an&amp;aacute;lisis no v&amp;aacute;lido se establecer&amp;aacute; como NaT.</target>
        </trans-unit>
        <trans-unit id="a8cc6e9c326cf3572f065a17f177306c8775d049" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;first&amp;rsquo; puts NaNs at the beginning, &amp;lsquo;last&amp;rsquo; puts NaNs at the end. Not implemented for MultiIndex.</source>
          <target state="translated">Si 'first' pone NaN al principio, 'last' pone NaN al final. No implementado para MultiIndex.</target>
        </trans-unit>
        <trans-unit id="85a05c0ef3ed46dcadbc8af33ffe40bbea47052f" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NA values, without passing them to the mapping correspondence.</source>
          <target state="translated">Si 'ignora', propague los valores NA, sin pasarlos a la correspondencia de mapeo.</target>
        </trans-unit>
        <trans-unit id="1287f6267e3f7063b36811426aebcc8a1b393699" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NaN values, without passing them to func.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b7f9b117c829902f069c8250ee1dcbed71f06f" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NaN values, without passing them to the mapping correspondence.</source>
          <target state="translated">Si 'ignora', propague los valores NaN, sin pasarlos a la correspondencia de mapeo.</target>
        </trans-unit>
        <trans-unit id="22afdde341e33ad8a79ea55dc5be1cbcc7e96d01" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, suppress error and existing labels are dropped.</source>
          <target state="translated">Si 'ignora', suprime el error y las etiquetas existentes se descartan.</target>
        </trans-unit>
        <trans-unit id="d430013a0236928d816f5189528441973b498e09" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, suppress error and only existing labels are dropped.</source>
          <target state="translated">Si 'ignora', suprime el error y solo se descartan las etiquetas existentes.</target>
        </trans-unit>
        <trans-unit id="55ef49bb1d9190e26977a4e97151c2887af3928e" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, then invalid parsing will return the input</source>
          <target state="translated">Si 'ignora', el an&amp;aacute;lisis no v&amp;aacute;lido devolver&amp;aacute; la entrada</target>
        </trans-unit>
        <trans-unit id="cd3b02bde7d23065b5493af3d78edab92d8661c6" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, then invalid parsing will return the input.</source>
          <target state="translated">Si 'ignora', el an&amp;aacute;lisis no v&amp;aacute;lido devolver&amp;aacute; la entrada.</target>
        </trans-unit>
        <trans-unit id="1dc7b9597b7436e84a9fd5cd7c267d98ceeb4c95" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;infer&amp;rsquo; and &amp;lsquo;path_or_url&amp;rsquo; is path-like, then detect compression from the following extensions: &amp;lsquo;.gz&amp;rsquo;, &amp;lsquo;.bz2&amp;rsquo;, &amp;lsquo;.zip&amp;rsquo;, or &amp;lsquo;.xz&amp;rsquo; (otherwise no compression) If &amp;lsquo;infer&amp;rsquo; and &amp;lsquo;path_or_url&amp;rsquo; is not path-like, then use None (= no decompression).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff34e86f499a6da13800cd52b6acf8d0206bc8b4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;julian&amp;rsquo;, unit must be &amp;lsquo;D&amp;rsquo;, and origin is set to beginning of Julian Calendar. Julian day number 0 is assigned to the day starting at noon on January 1, 4713 BC.</source>
          <target state="translated">Si es 'julian', la unidad debe ser 'D' y el origen se establece en el comienzo del calendario juliano. El d&amp;iacute;a juliano n&amp;uacute;mero 0 se asigna al d&amp;iacute;a que comienza al mediod&amp;iacute;a del 1 de enero de 4713 a. C.</target>
        </trans-unit>
        <trans-unit id="b2092bae9f0ce3fc3810aa44034eb94fcaaf590d" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;label&amp;rsquo; does not exist in DataFrame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b20de98cc6d0b1c8d0f7085d3b7e17aedbf78e9b" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b55e654d50b8ad774057f6ba47ce5789398ba97" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;self&lt;/code&gt;).</source>
          <target state="translated">Si est&amp;aacute; &quot;izquierda&quot;, se proporciona el &amp;iacute;ndice de la primera ubicaci&amp;oacute;n adecuada encontrada. Si es 'correcto', devuelve el &amp;uacute;ltimo &amp;iacute;ndice de este tipo. Si no hay un &amp;iacute;ndice adecuado, devuelve 0 o N (donde N es la longitud de &lt;code&gt;self&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="14c9113bf406806dfc7fa4d776177c7889c78c60" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;limit&amp;rsquo; is not specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc24626be3d05b2f4b9cd06416847f88949fd27" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;method&amp;rsquo; is &amp;lsquo;backfill&amp;rsquo; or &amp;lsquo;bfill&amp;rsquo;, &amp;lsquo;limit_direction&amp;rsquo; must be &amp;lsquo;backwards&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198a8a08aee1bff5568a3c9bfad2801313ba81bb" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;method&amp;rsquo; is &amp;lsquo;backfill&amp;rsquo; or &amp;lsquo;bfill&amp;rsquo;, the default is &amp;lsquo;backward&amp;rsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970a0920f7495cbfcd494a86c1c52c95ec206136" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;method&amp;rsquo; is &amp;lsquo;pad&amp;rsquo; or &amp;lsquo;ffill&amp;rsquo;, &amp;lsquo;limit_direction&amp;rsquo; must be &amp;lsquo;forward&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199d3e9cf5e8512896d9d482541e87cadcde8682" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;orient&amp;rsquo; is &amp;lsquo;records&amp;rsquo; write out line delimited json format. Will throw ValueError if incorrect &amp;lsquo;orient&amp;rsquo; since others are not list like.</source>
          <target state="translated">Si 'orient' es 'registros', escriba el formato json delimitado por l&amp;iacute;neas. Lanzar&amp;aacute; ValueError si 'orient' incorrecto ya que otros no son como la lista.</target>
        </trans-unit>
        <trans-unit id="efece3541c7fce3c755b622642e6e00a9f5917b5" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, raise a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a715eced952aac9082838419cee8dbd64346a0c" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, raise a &lt;code&gt;KeyError&lt;/code&gt; when a dict-like &lt;code&gt;mapper&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, or &lt;code&gt;columns&lt;/code&gt; contains labels that are not present in the Index being transformed. If &amp;lsquo;ignore&amp;rsquo;, existing keys will be renamed and extra keys will be ignored.</source>
          <target state="translated">Si 'sube', &lt;code&gt;KeyError&lt;/code&gt; un KeyError cuando un &lt;code&gt;mapper&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; o &lt;code&gt;columns&lt;/code&gt; similares a dict contienen etiquetas que no est&amp;aacute;n presentes en el &amp;iacute;ndice que se est&amp;aacute; transformando. Si 'ignora', las claves existentes ser&amp;aacute;n renombradas y las claves adicionales ser&amp;aacute;n ignoradas.</target>
        </trans-unit>
        <trans-unit id="0485157b5ba13ba379ff6892b6733f96842f0855" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, then invalid parsing will raise an exception</source>
          <target state="translated">Si 'subir', entonces el an&amp;aacute;lisis no v&amp;aacute;lido generar&amp;aacute; una excepci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="00849af26e0f3b9e37f7a382187cd7e59f774f16" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, then invalid parsing will raise an exception.</source>
          <target state="translated">Si 'levanta', entonces el an&amp;aacute;lisis no v&amp;aacute;lido generar&amp;aacute; una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4e71c458e98a0c8dc01eef2182556595f5c145b3" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, will raise a ValueError if the DataFrame and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3839ee4020555f4a90cf6574c343569184832636" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, will raise a ValueError if the DataFrame and &lt;code&gt;other&lt;/code&gt; both contain non-NA data in the same place.</source>
          <target state="translated">Si 'raise', generar&amp;aacute; un ValueError si el DataFrame y &lt;code&gt;other&lt;/code&gt; contienen datos que no son NA en el mismo lugar.</target>
        </trans-unit>
        <trans-unit id="3dcbf99c91197fe50065b8c2d1bbfb5fb4697702" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;unix&amp;rsquo; (or POSIX) time; origin is set to 1970-01-01.</source>
          <target state="translated">Si es tiempo de 'unix' (o POSIX); el origen se establece en 1970-01-01.</target>
        </trans-unit>
        <trans-unit id="f3d61e029440c96cda1e26ffdb0c5f6446bc64ce" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo; counts are generated for each column. If 1 or &amp;lsquo;columns&amp;rsquo; counts are generated for each &lt;strong&gt;row&lt;/strong&gt;.</source>
          <target state="translated">Si se generan recuentos de 0 o '&amp;iacute;ndice' para cada columna. Si se generan recuentos de 1 o 'columnas' para cada &lt;strong&gt;fila&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="38c6dad808791fe5af42cd8974e115c8505961be" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo; counts are generated for each column. If 1 or &amp;lsquo;columns&amp;rsquo; counts are generated for each row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7da5c288c9e6258ab4bc7bde9bc7e6455b66f5" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo;: apply function to each column. If 1 or &amp;lsquo;columns&amp;rsquo;: apply function to each row.</source>
          <target state="translated">Si es 0 o '&amp;iacute;ndice': aplica la funci&amp;oacute;n a cada columna. Si es 1 o 'columnas': aplica la funci&amp;oacute;n a cada fila.</target>
        </trans-unit>
        <trans-unit id="6ae3f7be53f938183a6a6a7495ab5b0abb73ba73" translate="yes" xml:space="preserve">
          <source>If 1-D array like, a sequence with the same shape as the observations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d4cb4694f132bb429f38f873d8a3b68e48888e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;https://numba.pydata.org/&quot;&gt;Numba&lt;/a&gt; is installed as an optional dependency, the &lt;code&gt;transform&lt;/code&gt; and &lt;code&gt;aggregate&lt;/code&gt; methods support &lt;code&gt;engine='numba'&lt;/code&gt; and &lt;code&gt;engine_kwargs&lt;/code&gt; arguments. The &lt;code&gt;engine_kwargs&lt;/code&gt; argument is a dictionary of keyword arguments that will be passed into the &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/reference/jit-compilation.html#numba.jit&quot;&gt;numba.jit decorator&lt;/a&gt;. These keyword arguments will be applied to the passed function. Currently only &lt;code&gt;nogil&lt;/code&gt;, &lt;code&gt;nopython&lt;/code&gt;, and &lt;code&gt;parallel&lt;/code&gt; are supported, and their default values are set to &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78b0523719ecd8724561c4f3f88618255a6a160" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt;&lt;code&gt;CategoricalDtype&lt;/code&gt;&lt;/a&gt;, cannot be used together with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9100712e07a1a3144bf279ca0131c5328bb20fae" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt;&lt;code&gt;CategoricalDtype&lt;/code&gt;&lt;/a&gt;, cannot be used together with &lt;code&gt;categories&lt;/code&gt; or &lt;code&gt;ordered&lt;/code&gt;.</source>
          <target state="translated">Si es &lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt; &lt;code&gt;CategoricalDtype&lt;/code&gt; &lt;/a&gt; , no se puede usar junto con &lt;code&gt;categories&lt;/code&gt; ni &lt;code&gt;ordered&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="957f4921f3fe1f14cc5e0972c2a9f63db875fa60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is specified, specifies values at given coordinates &lt;code&gt;(x[i], y[i])&lt;/code&gt;. These values are accumulated for each hexagonal bin and then reduced according to &lt;code&gt;reduce_C_function&lt;/code&gt;, having as default the NumPy&amp;rsquo;s mean function (&lt;code&gt;numpy.mean()&lt;/code&gt;). (If &lt;code&gt;C&lt;/code&gt; is specified, it must also be a 1-D sequence of the same length as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or a column label.)</source>
          <target state="translated">Si se especifica &lt;code&gt;C&lt;/code&gt; , especifica valores en coordenadas dadas &lt;code&gt;(x[i], y[i])&lt;/code&gt; . Estos valores se acumulan para cada bin hexagonal y luego se reducen de acuerdo con &lt;code&gt;reduce_C_function&lt;/code&gt; , teniendo por defecto la funci&amp;oacute;n media de NumPy ( &lt;code&gt;numpy.mean()&lt;/code&gt; ). (Si &lt;code&gt;C&lt;/code&gt; se especifica, debe tambi&amp;eacute;n ser una secuencia de 1-D de la misma longitud que &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; , o una etiqueta de columna).</target>
        </trans-unit>
        <trans-unit id="6499e3dc9a031482752c69e5eecddd3f70eff0f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, return Series/Index, containing lists of strings.</source>
          <target state="translated">Si es &lt;code&gt;False&lt;/code&gt; , devuelve Series / Index, que contiene listas de cadenas.</target>
        </trans-unit>
        <trans-unit id="085b836cec77eb5bb263be486be44249eef786e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the resulting index will not drop any level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8ba51c7b0b90045082965fc49ef9200c0d1945" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; is one of the accepted values, it always needs to be the last in the list.</source>
          <target state="translated">Si &lt;code&gt;None&lt;/code&gt; es uno de los valores aceptados, siempre debe ser el &amp;uacute;ltimo de la lista.</target>
        </trans-unit>
        <trans-unit id="4f8282afef3786c655e62035f97e7e04ec1fca5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Period&lt;/code&gt; freq is daily or higher (&lt;code&gt;D&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;), &lt;code&gt;offsets&lt;/code&gt; and &lt;code&gt;timedelta&lt;/code&gt;-like can be added if the result can have the same freq. Otherwise, &lt;code&gt;ValueError&lt;/code&gt; will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2cedf361e06add2c01f64839ff01dfc5bc08b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Period&lt;/code&gt; has other frequencies, only the same &lt;code&gt;offsets&lt;/code&gt; can be added. Otherwise, &lt;code&gt;ValueError&lt;/code&gt; will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29422fd31262e0e9fc4f8605659e8b004decc893" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; -&amp;gt; try parsing the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d0c1bf5aebde721450027a33154f95136617245" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6363a0cc564b7e07b8b809c7a41ba46945ef3ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; and parse_dates specifies combining multiple columns then keep the original columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c1aba1752b18100abe103f9924f71075d0ee20b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, include the dataframe&amp;rsquo;s index(es) in the file output. If &lt;code&gt;False&lt;/code&gt;, they will not be written to the file. If &lt;code&gt;None&lt;/code&gt;, similar to &lt;code&gt;True&lt;/code&gt; the dataframe&amp;rsquo;s index(es) will be saved. However, instead of being saved as values, the RangeIndex will be stored as a range in the metadata so it doesn&amp;rsquo;t require much space and is faster. Other indexes will be included as columns in the file output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31355248f274c3070a84b13f60346c84b6ae353" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, include the dataframe&amp;rsquo;s index(es) in the file output. If &lt;code&gt;False&lt;/code&gt;, they will not be written to the file. If &lt;code&gt;None&lt;/code&gt;, the behavior depends on the chosen engine.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , incluya los &amp;iacute;ndices del marco de datos en la salida del archivo. Si es &lt;code&gt;False&lt;/code&gt; , no se escribir&amp;aacute;n en el archivo. Si es &lt;code&gt;None&lt;/code&gt; , el comportamiento depende del motor elegido.</target>
        </trans-unit>
        <trans-unit id="db9c68e2c0847c2648159936067c9e97bd68d778" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, performs operation inplace and returns None.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , realiza la operaci&amp;oacute;n en el lugar y devuelve None.</target>
        </trans-unit>
        <trans-unit id="4cb94c12a9c4ef4e915d043b0131ab965753c6c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, return DataFrame/MultiIndex expanding dimensionality.</source>
          <target state="translated">Si es &lt;code&gt;True&lt;/code&gt; , devuelve DataFrame / MultiIndex expandiendo la dimensionalidad.</target>
        </trans-unit>
        <trans-unit id="517a8e80d621d1f11e0a5937c0b56cff33456958" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, skip over blank lines rather than interpreting as NaN values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e2f07bf71d2ba4698109742fc9a9a2f3add4c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[1, 2, 3]&lt;/code&gt; -&amp;gt; try parsing columns 1, 2, 3 each as a separate date column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184af077a3aa944d3aa6d28e063d05e84f7b5e9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[[1, 3]]&lt;/code&gt; -&amp;gt; combine columns 1 and 3 and parse as a single date column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970376fd9f251fcf7442a3e8dc1c7f205bfd8a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; and/or &lt;code&gt;level&lt;/code&gt; are passed as keywords to both &lt;code&gt;Grouper&lt;/code&gt; and &lt;code&gt;groupby&lt;/code&gt;, the values passed to &lt;code&gt;Grouper&lt;/code&gt; take precedence.</source>
          <target state="translated">Si el &lt;code&gt;axis&lt;/code&gt; y / o el &lt;code&gt;level&lt;/code&gt; se pasan como palabras clave tanto a &lt;code&gt;Grouper&lt;/code&gt; como a &lt;code&gt;groupby&lt;/code&gt; , los valores pasados ​​a &lt;code&gt;Grouper&lt;/code&gt; tienen prioridad.</target>
        </trans-unit>
        <trans-unit id="937f7d2a44b813e6b8d92c1002659f32d8844922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;complib&lt;/code&gt; is defined as something other than the listed libraries a &lt;code&gt;ValueError&lt;/code&gt; exception is issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f1537f9831fb3154a33d877feb6f73352a3d42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;crosstab&lt;/code&gt; receives only two Series, it will provide a frequency table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db32402bbe8a4f901a9b37cd1cc804bf16b8f6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is a scalar value, an index must be provided. The value will be repeated to match the length of &lt;strong&gt;index&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bd838dfe683144e93c449ff32d03c1dfd018a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is an ndarray, &lt;strong&gt;index&lt;/strong&gt; must be the same length as &lt;strong&gt;data&lt;/strong&gt;. If no index is passed, one will be created having values &lt;code&gt;[0, ..., len(data) - 1]&lt;/code&gt;.</source>
          <target state="translated">Si los &lt;code&gt;data&lt;/code&gt; son ndarray, el &lt;strong&gt;&amp;iacute;ndice&lt;/strong&gt; debe tener la misma longitud que los &lt;strong&gt;datos&lt;/strong&gt; . Si no se pasa ning&amp;uacute;n &amp;iacute;ndice, se crear&amp;aacute; uno con los valores &lt;code&gt;[0, ..., len(data) - 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="256b2ec2109a10c2b922ec284f2aa6d0f4996ee1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dropna&lt;/code&gt; is False, &lt;strong&gt;THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES&lt;/strong&gt;. Remember that entirely &lt;code&gt;np.Nan&lt;/code&gt; rows are not written to the HDFStore, so if you choose to call &lt;code&gt;dropna=False&lt;/code&gt;, some tables may have more rows than others, and therefore &lt;code&gt;select_as_multiple&lt;/code&gt; may not work or it may return unexpected results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4efc8cfad113907e0158cf2bc9289ac516eb7f46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;formatter&lt;/code&gt; is None, the default formatter is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9939487b947ef8676c1bc3bbe3735bce7e975089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is a standard Python function, the engine will &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/overview.html&quot;&gt;JIT&lt;/a&gt; the passed function. &lt;code&gt;func&lt;/code&gt; can also be a JITed function in which case the engine will not JIT the function again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab813b7fd3b3d65ecd4fb06b280ae7968617f53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; have overlapping elements</source>
          <target state="translated">Si &lt;code&gt;include&lt;/code&gt; y &lt;code&gt;exclude&lt;/code&gt; tienen elementos superpuestos</target>
        </trans-unit>
        <trans-unit id="a7da045296675e29f8161fcdf9df7881d520bb33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;join != &amp;lsquo;left&amp;rsquo;&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;join != &amp;lsquo;left&amp;rsquo;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e408e50f4efff0be75273835ecad495f9e1afc4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are not specified, no strings will be parsed as NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd73a654c84b29616fb9b65fd07e1551ee72e146" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are specified, only the NaN values specified &lt;code&gt;na_values&lt;/code&gt; are used for parsing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4e153f94488bea1392d12a65c1e2c2599e5594" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are not specified, only the default NaN values are used for parsing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e25908c5c32fc206359705ce5477202d627c658a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are specified, &lt;code&gt;na_values&lt;/code&gt; is appended to the default NaN values used for parsing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f265a8f044bf232fffa85812d820574c8444bbe7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is False, and &lt;code&gt;na_values&lt;/code&gt; are not specified, no strings will be parsed as NaN.</source>
          <target state="translated">Si &lt;code&gt;keep_default_na&lt;/code&gt; es False y no se especifican &lt;code&gt;na_values&lt;/code&gt; , no se analizar&amp;aacute;n cadenas como NaN.</target>
        </trans-unit>
        <trans-unit id="8a282745eb357ce0d97179f43d5f0ca158631ab3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is False, and &lt;code&gt;na_values&lt;/code&gt; are specified, only the NaN values specified &lt;code&gt;na_values&lt;/code&gt; are used for parsing.</source>
          <target state="translated">Si &lt;code&gt;keep_default_na&lt;/code&gt; es False, y se especifican &lt;code&gt;na_values&lt;/code&gt; , solo los valores de NaN especificados &lt;code&gt;na_values&lt;/code&gt; se utilizan para el an&amp;aacute;lisis.</target>
        </trans-unit>
        <trans-unit id="e8ef3b4bb67919e2a3c220c269aec10ecbb92263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is True, and &lt;code&gt;na_values&lt;/code&gt; are not specified, only the default NaN values are used for parsing.</source>
          <target state="translated">Si &lt;code&gt;keep_default_na&lt;/code&gt; es True y no se especifican &lt;code&gt;na_values&lt;/code&gt; , solo se utilizan los valores predeterminados de NaN para el an&amp;aacute;lisis.</target>
        </trans-unit>
        <trans-unit id="4119b503697716799e0d3d53bb23a09257bc768a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is True, and &lt;code&gt;na_values&lt;/code&gt; are specified, &lt;code&gt;na_values&lt;/code&gt; is appended to the default NaN values used for parsing.</source>
          <target state="translated">Si &lt;code&gt;keep_default_na&lt;/code&gt; es cierto, y &lt;code&gt;na_values&lt;/code&gt; se especifican, &lt;code&gt;na_values&lt;/code&gt; se a&amp;ntilde;ade al valor predeterminado NaN Los valores utilizados para el an&amp;aacute;lisis.</target>
        </trans-unit>
        <trans-unit id="14eafb6125c72331ed6931749a85a2bfe869b0fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is not set, all levels are removed from the Index.</source>
          <target state="translated">Si &lt;code&gt;level&lt;/code&gt; no est&amp;aacute; establecido, todos los niveles se retiran del &amp;Iacute;ndice.</target>
        </trans-unit>
        <trans-unit id="bbb5a110126584a428bb870b81494275cb5c1371" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is specified:</source>
          <target state="translated">Si se especifica el &lt;code&gt;level&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="60f1e6635b0a341e3238693e8e1f6f09613ae56b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;na_rep&lt;/code&gt; is None, and &lt;code&gt;others&lt;/code&gt; is None, missing values in the Series/Index are omitted from the result.</source>
          <target state="translated">Si &lt;code&gt;na_rep&lt;/code&gt; es Ninguno y &lt;code&gt;others&lt;/code&gt; es Ninguno, los valores faltantes en la Serie / &amp;Iacute;ndice se omiten del resultado.</target>
        </trans-unit>
        <trans-unit id="444db6399518d3b249738d624701c4ac6b47e94e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;na_rep&lt;/code&gt; is None, and &lt;code&gt;others&lt;/code&gt; is not None, a row containing a missing value in any of the columns (before concatenation) will have a missing value in the result.</source>
          <target state="translated">Si &lt;code&gt;na_rep&lt;/code&gt; es Ninguno y &lt;code&gt;others&lt;/code&gt; no es Ninguno, una fila que contenga un valor faltante en cualquiera de las columnas (antes de la concatenaci&amp;oacute;n) tendr&amp;aacute; un valor faltante en el resultado.</target>
        </trans-unit>
        <trans-unit id="c1f385438de08840651ce957815b6972e0f16406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;numpy=True&lt;/code&gt; is passed to &lt;code&gt;read_json&lt;/code&gt; an attempt will be made to sniff an appropriate dtype during deserialization and to subsequently decode directly to NumPy arrays, bypassing the need for intermediate Python objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b7230c53dd34c840119bd5592d141943fc9eb82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains NaNs the corresponding values are not updated in the original Series.</source>
          <target state="translated">Si &lt;code&gt;other&lt;/code&gt; contiene NaN, los valores correspondientes no se actualizan en la Serie original.</target>
        </trans-unit>
        <trans-unit id="deb8809ee611aa9a981b6b0843436b17f4eb152b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains NaNs the corresponding values are not updated in the original dataframe.</source>
          <target state="translated">Si &lt;code&gt;other&lt;/code&gt; contiene NaN, los valores correspondientes no se actualizan en el marco de datos original.</target>
        </trans-unit>
        <trans-unit id="25b2a3bb2e641aa80e4bd798d256b6357269c5bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is None, &lt;code&gt;str&lt;/code&gt; is returned, otherwise a &lt;code&gt;Series/Index&lt;/code&gt; (same type as caller) of objects is returned.</source>
          <target state="translated">Si &lt;code&gt;others&lt;/code&gt; es Ninguno, se devuelve &lt;code&gt;str&lt;/code&gt; ; de lo contrario, se devuelve una &lt;code&gt;Series/Index&lt;/code&gt; (del mismo tipo que llamador) de objetos.</target>
        </trans-unit>
        <trans-unit id="09719fe597a3b1238ba510411ad64aa8b9b27a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is specified, corresponding values are concatenated with the separator. Result will be a Series of strings.</source>
          <target state="translated">Si se especifican &lt;code&gt;others&lt;/code&gt; , los valores correspondientes se concatenan con el separador. El resultado ser&amp;aacute; una serie de cadenas.</target>
        </trans-unit>
        <trans-unit id="403aef7dbc0efb83661ae14475ba2c1f617d536d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is specified, this function concatenates the Series/Index and elements of &lt;code&gt;others&lt;/code&gt; element-wise. If &lt;code&gt;others&lt;/code&gt; is not passed, then all values in the Series/Index are concatenated into a single string with a given &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="translated">Si se especifica &lt;code&gt;others&lt;/code&gt; , esta funci&amp;oacute;n concatena la Serie / &amp;Iacute;ndice y los elementos de &lt;code&gt;others&lt;/code&gt; elementos. Si &lt;code&gt;others&lt;/code&gt; no se pasa, todos los valores en el / Index Series se concatenan en una sola cadena con un determinado &lt;code&gt;sep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1abddbde8315f2084021872e6073c1be66d77681" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path_or_buffer&lt;/code&gt; is an OpenDocument format (.odf, .ods, .odt), then &lt;a href=&quot;https://pypi.org/project/odfpy/&quot;&gt;odf&lt;/a&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3baa765246b3745f60bd4ee59b2f98ce470debc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;periods &amp;gt; len(self)&lt;/code&gt;, then an array of size len(self) is returned, with all values filled with &lt;code&gt;self.dtype.na_value&lt;/code&gt;.</source>
          <target state="translated">Si los &lt;code&gt;periods &amp;gt; len(self)&lt;/code&gt; , se devuelve una matriz de tama&amp;ntilde;o len (self), con todos los valores rellenos con &lt;code&gt;self.dtype.na_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c112aa6403a164634d1416141466a683b493a868" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a float, a Series will be returned where the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea206fbf912a77c2c5baccfb75902c0063d921d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is an array, a DataFrame will be returned where the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961740cc92f0fc03f28c95a8a238e4dbbce71c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is an array, a Series will be returned where the index is &lt;code&gt;q&lt;/code&gt; and the values are the quantiles, otherwise a float will be returned.</source>
          <target state="translated">Si &lt;code&gt;q&lt;/code&gt; es una matriz, se devolver&amp;aacute; una Serie donde el &amp;iacute;ndice es &lt;code&gt;q&lt;/code&gt; y los valores son los cuantiles; de lo contrario, se devolver&amp;aacute; un flotante.</target>
        </trans-unit>
        <trans-unit id="50282aa940212018e61f3deecb959d20f87fb9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;regex&lt;/code&gt; is not a &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;to_replace&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;regex&lt;/code&gt; no es &lt;code&gt;bool&lt;/code&gt; y &lt;code&gt;to_replace&lt;/code&gt; no es &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b41c22f4efb9468b1cb6a930f4d6611ab107c8d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81766fdd49633266642838e7da2bdf12aca59fae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, a NumPy array of axes with the same shape as &lt;code&gt;layout&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;return_type&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; , se devuelve una matriz NumPy de ejes con la misma forma que el &lt;code&gt;layout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f81d6e8038a65cfec7ed666581c73e2227881317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, a NumPy array of axes with the same shape as &lt;code&gt;layout&lt;/code&gt; is returned:</source>
          <target state="translated">Si &lt;code&gt;return_type&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; , se devuelve una matriz NumPy de ejes con la misma forma que el &lt;code&gt;layout&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9403f65e0291ebfce3b893ca7ef9f39c4702bafd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is empty or &lt;code&gt;periods&lt;/code&gt; is 0, a copy of &lt;code&gt;self&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;self&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o o los &lt;code&gt;periods&lt;/code&gt; son 0, se devuelve una copia de &lt;code&gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c9ebf0aff8358da4c22aadcc4e5af5797dd0abb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified, the values are concatenated without separation.</source>
          <target state="translated">Si no se especifica &lt;code&gt;sep&lt;/code&gt; , los valores se concatenan sin separaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="42e82e5988245d4a3bb290ebd363efd4d9efea4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skip_blank_lines=False&lt;/code&gt;, then &lt;code&gt;read_csv&lt;/code&gt; will not ignore blank lines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be88e00b6cd2ee9590d0a2d751007eb4876a853c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipna&lt;/code&gt; is False and there is an NA value in the data, the function returns &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;skipna&lt;/code&gt; es False y hay un valor NA en los datos, la funci&amp;oacute;n devuelve &lt;code&gt;nan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8565c59edb64329c1ca271f30471849138be0bff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; are &lt;code&gt;Period&lt;/code&gt; objects, they will be used as anchor endpoints for a &lt;code&gt;PeriodIndex&lt;/code&gt; with frequency matching that of the &lt;code&gt;PeriodIndex&lt;/code&gt; constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d07c799aa985555aa80944ae394ade3e6e41e965" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; are &lt;code&gt;Period&lt;/code&gt; objects, they will be used as anchor endpoints for a &lt;code&gt;PeriodIndex&lt;/code&gt; with frequency matching that of the &lt;code&gt;period_range&lt;/code&gt; constructor.</source>
          <target state="translated">Si &lt;code&gt;start&lt;/code&gt; o &lt;code&gt;end&lt;/code&gt; son objetos &lt;code&gt;Period&lt;/code&gt; , se utilizar&amp;aacute;n como puntos finales de anclaje para un &lt;code&gt;PeriodIndex&lt;/code&gt; con una frecuencia que coincida con la del constructor &lt;code&gt;period_range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7b0a663d9250908bec356033f00f39037ab14b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;target&lt;/code&gt; is provided, and the expression mutates &lt;code&gt;target&lt;/code&gt;, whether to modify &lt;code&gt;target&lt;/code&gt; inplace. Otherwise, return a copy of &lt;code&gt;target&lt;/code&gt; with the mutation.</source>
          <target state="translated">Si se proporciona el &lt;code&gt;target&lt;/code&gt; y la expresi&amp;oacute;n muta al &lt;code&gt;target&lt;/code&gt; , si se modifica el &lt;code&gt;target&lt;/code&gt; lugar. De lo contrario, devuelva una copia del &lt;code&gt;target&lt;/code&gt; con la mutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e1e7c5e72393131f2654387c48d329fe2921498d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;text_color_threshold&lt;/code&gt; is not a value from 0 to 1.</source>
          <target state="translated">Si &lt;code&gt;text_color_threshold&lt;/code&gt; no es un valor de 0 a 1.</target>
        </trans-unit>
        <trans-unit id="535b234a64529b3677378d8dfde02546b2a249b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;times&lt;/code&gt; is specified, the time unit (str or timedelta) over which an observation decays to half its value. Only applicable to &lt;code&gt;mean()&lt;/code&gt; and halflife value will not apply to the other functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704cdb74002773b3b579c1c3d6d7936011db63ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to_replace&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;regex&lt;/code&gt; is not compilable into a regular expression or is a list, dict, ndarray, or Series.</source>
          <target state="translated">Si &lt;code&gt;to_replace&lt;/code&gt; es &lt;code&gt;None&lt;/code&gt; y &lt;code&gt;regex&lt;/code&gt; no se puede compilar en una expresi&amp;oacute;n regular o es una lista, dict, ndarray o Series.</target>
        </trans-unit>
        <trans-unit id="d03447781d080adef5a2a9380fc861eeabc92417" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to_replace&lt;/code&gt; is a &lt;code&gt;dict&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; is not a &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;ndarray&lt;/code&gt;, or &lt;code&gt;Series&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;to_replace&lt;/code&gt; es un &lt;code&gt;dict&lt;/code&gt; y el &lt;code&gt;value&lt;/code&gt; no es una &lt;code&gt;list&lt;/code&gt; a , &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;ndarray&lt;/code&gt; o &lt;code&gt;Series&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a1caaa2d26334416b23c7630389d536a0fad7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usecols&lt;/code&gt; is a list of integers, then it is assumed to be the file column indices to be parsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac4edea12a43fd31cf9476433f0b0a1a854909b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usecols&lt;/code&gt; is a list of strings, it is assumed that each string corresponds to a column name provided either by the user in &lt;code&gt;names&lt;/code&gt; or inferred from the document header row(s). Those strings define which columns will be parsed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e01b5dff3b67b87609e0579db43ccbda944e4e34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usecols&lt;/code&gt; is callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1de8e0a85b6ff84557f7ecae5437820577f3a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uuid&lt;/code&gt; is not specified, the length of the &lt;code&gt;uuid&lt;/code&gt; to randomly generate expressed in hex characters, in range [0, 32].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c278841e9bef34e1e1bd4a72a3426ae68586bd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is a string</source>
          <target state="translated">Si &lt;code&gt;values&lt;/code&gt; es una cadena</target>
        </trans-unit>
        <trans-unit id="d9b7a5e40e9f52d62b19692bf3dcad2166cfe945" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;win_type=None&lt;/code&gt; all points are evenly weighted. To learn more about different window types see &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.html#window-functions&quot;&gt;scipy.signal window functions&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;win_type=None&lt;/code&gt; , todos los puntos se ponderan uniformemente. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los diferentes tipos de ventanas, consulte &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.html#window-functions&quot;&gt;Funciones de ventana de scipy.signal&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7762da07ec115be44fc02765f9d76407b7404d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;win_type=None&lt;/code&gt;, all points are evenly weighted; otherwise, &lt;code&gt;win_type&lt;/code&gt; can accept a string of any &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows&quot;&gt;scipy.signal window function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71b0b95595f61d6f49ae04391e762a1155d81ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{'foo': [1, 3]}&lt;/code&gt; -&amp;gt; parse columns 1, 3 as date and call result &amp;lsquo;foo&amp;rsquo;. A fast-path exists for iso8601-formatted dates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a6323b295fa22008498d6df468eee6b83c1cb8" translate="yes" xml:space="preserve">
          <source>If DataFrame contains only NaNs, it is still not considered empty. See the example below.</source>
          <target state="translated">Si el DataFrame sólo contiene NaNs,aún no se considera vacío.Véase el ejemplo siguiente.</target>
        </trans-unit>
        <trans-unit id="dc64a7e5f7b013c75ec87dad61798a0bf364de27" translate="yes" xml:space="preserve">
          <source>If DataFrame is empty, return True, if not return False.</source>
          <target state="translated">Si el DataFrame está vacío,devuelva Verdadero,si no devuelva Falso.</target>
        </trans-unit>
        <trans-unit id="9db46c5d4b42b8c5a58b772328c51b664e184ae7" translate="yes" xml:space="preserve">
          <source>If Datetime Array/Index is tz-naive.</source>
          <target state="translated">Si la matriz/índice de fecha y hora es tz-nave.</target>
        </trans-unit>
        <trans-unit id="d1f885919f4b6084a26832cb39a10a880fe30e9f" translate="yes" xml:space="preserve">
          <source>If False (default), the SparseSeries index consists of only the coords of the non-null entries of the original coo_matrix. If True, the SparseSeries index consists of the full sorted (row, col) coordinates of the coo_matrix.</source>
          <target state="translated">Si es Falso (por defecto),el índice SparseSeries consiste sólo en los coords de las entradas no nulas de la coo_matrix original.Si es True,el índice SparseSeries consiste en las coordenadas ordenadas completas (fila,col)de la coo_matrix.</target>
        </trans-unit>
        <trans-unit id="af4968ab538593a91313d8dbcdb3666d290ea5ad" translate="yes" xml:space="preserve">
          <source>If False returns a numpy.timedelta64 or numpy.darray of values of dtype timedelta64[ns].</source>
          <target state="translated">Si False devuelve un numpy.timedelta64 o numpy.darray de valores de dtype timedelta64[ns].</target>
        </trans-unit>
        <trans-unit id="19cb14e4bedf8bda1fb770c21ea9563b40397a07" translate="yes" xml:space="preserve">
          <source>If False returns ndarray of values.</source>
          <target state="translated">Si False devuelve ndarray de valores.</target>
        </trans-unit>
        <trans-unit id="c4ef3d2ab2c9c4543800461df47e4edf64d59fdc" translate="yes" xml:space="preserve">
          <source>If False then only matching columns between self and other will be used and the output will be a DataFrame. If True then all pairwise combinations will be calculated and the output will be a MultiIndex DataFrame in the case of DataFrame inputs. In the case of missing elements, only complete pairwise observations will be used.</source>
          <target state="translated">Si es falso,entonces sólo se usarán las columnas de coincidencia entre uno y otro y la salida será un DataFrame.Si es Verdadero entonces todas las combinaciones de pares serán calculadas y la salida será un DataFrame Multi-Index en el caso de las entradas del DataFrame.En el caso de los elementos faltantes,sólo se utilizarán observaciones completas por pares.</target>
        </trans-unit>
        <trans-unit id="b5a787dc4a36cd7a1fb843fad1ef9b45ebd6788d" translate="yes" xml:space="preserve">
          <source>If False then only matching columns between self and other will be used and the output will be a DataFrame. If True then all pairwise combinations will be calculated and the output will be a MultiIndexed DataFrame in the case of DataFrame inputs. In the case of missing elements, only complete pairwise observations will be used.</source>
          <target state="translated">Si es falso,entonces sólo se usarán las columnas de coincidencia entre uno y otro y la salida será un DataFrame.Si es Verdadero entonces todas las combinaciones de pares serán calculadas y la salida será un DataFrame Multi-Index en el caso de las entradas del DataFrame.En el caso de los elementos faltantes,sólo se utilizarán observaciones completas por pares.</target>
        </trans-unit>
        <trans-unit id="a089d4a3cab4ec051531af18ca8716ac15f227f1" translate="yes" xml:space="preserve">
          <source>If False then underlying input data is not copied.</source>
          <target state="translated">Si es falso,entonces los datos de entrada subyacentes no se copian.</target>
        </trans-unit>
        <trans-unit id="7f4768ce69348aa654b6f78c372d4c73bce62c22" translate="yes" xml:space="preserve">
          <source>If False, allow the format to match anywhere in the target string.</source>
          <target state="translated">Si es falso,permite que el formato coincida con cualquier parte de la cadena de destino.</target>
        </trans-unit>
        <trans-unit id="30010fa9b0dacd4bae2d42840bc8bc8330f1bc61" translate="yes" xml:space="preserve">
          <source>If False, avoid copy if possible.</source>
          <target state="translated">Si es falso,evita la copia si es posible.</target>
        </trans-unit>
        <trans-unit id="291d4f114810ff3b85734eb9c885f67fb9461220" translate="yes" xml:space="preserve">
          <source>If False, do not copy data unnecessarily.</source>
          <target state="translated">Si es falso,no copie los datos innecesariamente.</target>
        </trans-unit>
        <trans-unit id="713b0af025da394c1dfc7bcc4b8e6a4fc01b89b5" translate="yes" xml:space="preserve">
          <source>If False, don&amp;rsquo;t match the same &amp;lsquo;on&amp;rsquo; value (i.e., strictly less-than / strictly greater-than)</source>
          <target state="translated">Si es Falso, no coincida con el mismo valor 'on' (es decir, estrictamente menor que / estrictamente mayor que)</target>
        </trans-unit>
        <trans-unit id="e90b5bec78f4ab7a4fe30e4eff0e3912178db8a9" translate="yes" xml:space="preserve">
          <source>If False, don&amp;rsquo;t match the same &amp;lsquo;on&amp;rsquo; value (i.e., strictly less-than / strictly greater-than).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b84b5f31bb2d6147a51b4eadc91b3e249c42dd9" translate="yes" xml:space="preserve">
          <source>If False, groups that evaluate False are filled with NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2899b63827cccc80ce7f0849090ad8a00a13fe" translate="yes" xml:space="preserve">
          <source>If False, number in reverse, from length of group - 1 to 0.</source>
          <target state="translated">Si es falso,numérelo al revés,desde la longitud del grupo-1 a 0.</target>
        </trans-unit>
        <trans-unit id="18d85815ef65505f4da3c47d9d292cf07677ec50" translate="yes" xml:space="preserve">
          <source>If False, number in reverse, from number of group - 1 to 0.</source>
          <target state="translated">Si es falso,numera al revés,desde el número del grupo-1 a 0.</target>
        </trans-unit>
        <trans-unit id="c66981ba95dd5d03a5bf5f115c2c1e1bc6df4b6d" translate="yes" xml:space="preserve">
          <source>If False, outputs info in a human readable form to the console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6ee337b37c7d79d6ff069d1d6be9c1ee63f16e" translate="yes" xml:space="preserve">
          <source>If False, return a copy. Otherwise, do operation inplace and return None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eee400988b3add06c7b8d82d92a5db12cafc5df8" translate="yes" xml:space="preserve">
          <source>If False, returns object with same levels as self.</source>
          <target state="translated">Si es falso,devuelve el objeto con los mismos niveles que el propio.</target>
        </trans-unit>
        <trans-unit id="93f8cbc94b6ecff2910e70c613725fd41f719aa1" translate="yes" xml:space="preserve">
          <source>If False, the quantile of datetime and timedelta data will be computed as well.</source>
          <target state="translated">Si es falso,también se computará el cuantil de datos de fecha y hora delta.</target>
        </trans-unit>
        <trans-unit id="1a855233ec9b42057ad4f3f0a22d197f5cc6c27a" translate="yes" xml:space="preserve">
          <source>If False, treats the pat as a literal string.</source>
          <target state="translated">Si es falso,trata la palmada como una cuerda literal.</target>
        </trans-unit>
        <trans-unit id="d42e87de00086a1c6e6f625064f6fded12c14393" translate="yes" xml:space="preserve">
          <source>If False, treats the pattern as a literal string</source>
          <target state="translated">Si es falso,trata el patrón como una cadena literal</target>
        </trans-unit>
        <trans-unit id="386a8df84344bc31d4acd3d0513c6b8223ed5e6c" translate="yes" xml:space="preserve">
          <source>If NaN is in the values, and we want to include NaN in the uniques of the values, it can be achieved by setting &lt;code&gt;na_sentinel=None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6823fe124c6d762f846db12c9b7eb432cef57e38" translate="yes" xml:space="preserve">
          <source>If None, defaults to 1</source>
          <target state="translated">Si no hay ninguno,el valor por defecto es 1</target>
        </trans-unit>
        <trans-unit id="0f5d6d9a47683654054d53fe83da6d519ea96659" translate="yes" xml:space="preserve">
          <source>If None, defaults to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a198b80d00181744c0b52dce1e2d43c14c2ff18" translate="yes" xml:space="preserve">
          <source>If None, defaults to the beginning</source>
          <target state="translated">Si no hay ninguno,por defecto al principio</target>
        </trans-unit>
        <trans-unit id="2228cf54c4d2a4d2730b3b9a52429df0614dd9bd" translate="yes" xml:space="preserve">
          <source>If None, defaults to the beginning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d75f9174710ceedaeffa648b72cbbd3e8b87a0b5" translate="yes" xml:space="preserve">
          <source>If None, defaults to the end</source>
          <target state="translated">Si no hay ninguno,por defecto hasta el final</target>
        </trans-unit>
        <trans-unit id="ed03605cbabb4c3045d9b32daba224dab5b90b57" translate="yes" xml:space="preserve">
          <source>If None, defaults to the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99befa70db36b844698b11450c67335fe8946fc0" translate="yes" xml:space="preserve">
          <source>If None, dtype will be inferred</source>
          <target state="translated">Si no hay ninguno,se deducirá el tipo</target>
        </trans-unit>
        <trans-unit id="305e45bf0f534becf08e10a608173f7b64e54cf0" translate="yes" xml:space="preserve">
          <source>If None, dtype will be inferred.</source>
          <target state="translated">Si no hay ninguno,se deducirá el tipo.</target>
        </trans-unit>
        <trans-unit id="33245c017268287ad9b24177b04ead223d178eae" translate="yes" xml:space="preserve">
          <source>If None, file format is inferred from file extension. If &amp;lsquo;xport&amp;rsquo; or &amp;lsquo;sas7bdat&amp;rsquo;, uses the corresponding format.</source>
          <target state="translated">Si es Ninguno, el formato de archivo se infiere de la extensi&amp;oacute;n del archivo. Si es 'xport' o 'sas7bdat', usa el formato correspondiente.</target>
        </trans-unit>
        <trans-unit id="e4bd68ed52ae06d305e0f091922ac01ec8be5f11" translate="yes" xml:space="preserve">
          <source>If None, pd.get_option(&amp;lsquo;io.hdf.default_format&amp;rsquo;) is checked, followed by fallback to &amp;ldquo;fixed&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40dfbb91453fe35b8691d9034b77ccdc78058b8" translate="yes" xml:space="preserve">
          <source>If None, return all columns, otherwise, returns specified columns.</source>
          <target state="translated">Si no hay ninguna,devuelve todas las columnas,si no,devuelve las columnas especificadas.</target>
        </trans-unit>
        <trans-unit id="9d3b9a2dcf0b8b571245f92f0d02282c76972d82" translate="yes" xml:space="preserve">
          <source>If None, then parse all columns.</source>
          <target state="translated">Si no hay ninguno,entonces analiza todas las columnas.</target>
        </trans-unit>
        <trans-unit id="cede37750460f29cb4fa52c7fec665577cfd52b2" translate="yes" xml:space="preserve">
          <source>If Numba is passed a function that includes something it doesn&amp;rsquo;t know how to work with &amp;ndash; a category that currently includes sets, lists, dictionaries, or string functions &amp;ndash; it will revert to &lt;code&gt;object mode&lt;/code&gt;. In &lt;code&gt;object mode&lt;/code&gt;, Numba will execute but your code will not speed up significantly. If you would prefer that Numba throw an error if it cannot compile a function in a way that speeds up your code, pass Numba the argument &lt;code&gt;nopython=True&lt;/code&gt; (e.g. &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt;). For more on troubleshooting Numba modes, see the &lt;a href=&quot;http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba troubleshooting page&lt;/a&gt;.</source>
          <target state="translated">Si a Numba se le pasa una funci&amp;oacute;n que incluye algo con lo que no sabe c&amp;oacute;mo trabajar, una categor&amp;iacute;a que actualmente incluye conjuntos, listas, diccionarios o funciones de cadena, volver&amp;aacute; al &lt;code&gt;object mode&lt;/code&gt; . En &lt;code&gt;object mode&lt;/code&gt; , Numba se ejecutar&amp;aacute; pero su c&amp;oacute;digo no se acelerar&amp;aacute; significativamente. Si prefiere que Numba arroje un error si no puede compilar una funci&amp;oacute;n de una manera que &lt;code&gt;nopython=True&lt;/code&gt; su c&amp;oacute;digo, pase a Numba el argumento nopython = True (por ejemplo, &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt; ). Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la resoluci&amp;oacute;n de problemas de los modos Numba, consulte la &lt;a href=&quot;http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;p&amp;aacute;gina de resoluci&amp;oacute;n de problemas de Numba&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cf83492c2f7d9b62bbeb8e6388f30b8fbfed606" translate="yes" xml:space="preserve">
          <source>If Numba is passed a function that includes something it doesn&amp;rsquo;t know how to work with &amp;ndash; a category that currently includes sets, lists, dictionaries, or string functions &amp;ndash; it will revert to &lt;code&gt;object mode&lt;/code&gt;. In &lt;code&gt;object mode&lt;/code&gt;, Numba will execute but your code will not speed up significantly. If you would prefer that Numba throw an error if it cannot compile a function in a way that speeds up your code, pass Numba the argument &lt;code&gt;nopython=True&lt;/code&gt; (e.g. &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt;). For more on troubleshooting Numba modes, see the &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba troubleshooting page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21738859f1a9792d732c95f50fc39e869d10cb29" translate="yes" xml:space="preserve">
          <source>If SQLAlchemy is not installed, a fallback is only provided for sqlite (and for mysql for backwards compatibility, but this is deprecated and will be removed in a future version). This mode requires a Python database adapter which respect the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249/&quot;&gt;Python DB-API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c1f8f822f180177bfde53d3b1ec7bf4e05cab5e" translate="yes" xml:space="preserve">
          <source>If Timestamp convertible, origin is set to Timestamp identified by origin.</source>
          <target state="translated">Si es un descapotable con sello de tiempo,el origen se establece con sello de tiempo identificado por el origen.</target>
        </trans-unit>
        <trans-unit id="302ec23d134fa94295f5a5b21bbe57333cc5ba71" translate="yes" xml:space="preserve">
          <source>If Timestamp is tz-naive.</source>
          <target state="translated">Si la marca de tiempo es tz-nave.</target>
        </trans-unit>
        <trans-unit id="877daf2c60c584794d63f9ddbf4bb796256b13ee" translate="yes" xml:space="preserve">
          <source>If True (default) the description(s) will be printed to stdout. Otherwise, the description(s) will be returned as a unicode string (for testing).</source>
          <target state="translated">Si es True (predeterminado)la(s)descripción(es)se imprimirá(n)en stdout.De lo contrario,la(s)descripción(es)será(n)devuelta(s)como una cadena de unicode (para prueba).</target>
        </trans-unit>
        <trans-unit id="79279f7b5a78bfc09767977781bcb3e7ef19efbc" translate="yes" xml:space="preserve">
          <source>If True and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d916b7ecf5b34c978b87a1cac148ea4e85e0797" translate="yes" xml:space="preserve">
          <source>If True and &lt;code&gt;parse_dates&lt;/code&gt; is enabled, pandas will attempt to infer the format of the datetime strings in the columns, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by 5-10x.</source>
          <target state="translated">Si True y &lt;code&gt;parse_dates&lt;/code&gt; est&amp;aacute;n habilitados, los pandas intentar&amp;aacute;n inferir el formato de las cadenas de fecha y hora en las columnas y, si se puede inferir, cambiar a un m&amp;eacute;todo m&amp;aacute;s r&amp;aacute;pido para analizarlas. En algunos casos, esto puede aumentar la velocidad de an&amp;aacute;lisis entre 5 y 10 veces.</target>
        </trans-unit>
        <trans-unit id="a6c1e57d23e26869dc0e2062acc23c857f4141f1" translate="yes" xml:space="preserve">
          <source>If True and &lt;code&gt;parse_dates&lt;/code&gt; specifies combining multiple columns then keep the original columns.</source>
          <target state="translated">Si True y &lt;code&gt;parse_dates&lt;/code&gt; especifica la combinaci&amp;oacute;n de varias columnas, mantenga las columnas originales.</target>
        </trans-unit>
        <trans-unit id="b1ba3921dc01d9fac0f5e6f97a8d6ec85f39852c" translate="yes" xml:space="preserve">
          <source>If True and no</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdbd44edb95eb1919d0e70e68013314a95652069" translate="yes" xml:space="preserve">
          <source>If True and no &lt;code&gt;format&lt;/code&gt; is given, attempt to infer the format of the datetime strings, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by ~5-10x.</source>
          <target state="translated">Si es True y no se proporciona ning&amp;uacute;n &lt;code&gt;format&lt;/code&gt; o , intente inferir el formato de las cadenas de fecha y hora y, si se puede inferir, cambie a un m&amp;eacute;todo m&amp;aacute;s r&amp;aacute;pido para analizarlas. En algunos casos, esto puede aumentar la velocidad de an&amp;aacute;lisis en ~ 5-10x.</target>
        </trans-unit>
        <trans-unit id="05ce3205c3816ae877ac9af3cf60622cf6b06aa7" translate="yes" xml:space="preserve">
          <source>If True and sorting by level and index is multilevel, sort by other levels too (in order) after sorting by specified level.</source>
          <target state="translated">Si True y la clasificación por nivel e índice es multinivel,ordene también por otros niveles (en orden)después de ordenar por el nivel especificado.</target>
        </trans-unit>
        <trans-unit id="c4da65c79c92e3c24cfc8f74ebd023389cdd2b17" translate="yes" xml:space="preserve">
          <source>If True parse dates in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="262d40ea87b315db865b2f76fe9cef275e5b9327" translate="yes" xml:space="preserve">
          <source>If True parse dates in &lt;code&gt;data&lt;/code&gt; with the year first order</source>
          <target state="translated">Si es verdadero, analizar las fechas en los &lt;code&gt;data&lt;/code&gt; con el primer orden del a&amp;ntilde;o</target>
        </trans-unit>
        <trans-unit id="d875c9e78a8f10c4070a76617db0aea9c9581c5c" translate="yes" xml:space="preserve">
          <source>If True parses dates with the year first, eg 10/11/12 is parsed as 2010-11-12.</source>
          <target state="translated">Si True analiza las fechas con el año primero,por ejemplo 10/11/12 se analiza como 2010-11-12.</target>
        </trans-unit>
        <trans-unit id="bb627fc931d5d5697f56d7a0202d4eeb9eb2c217" translate="yes" xml:space="preserve">
          <source>If True returns a DatetimeIndex or Index-like object</source>
          <target state="translated">Si True devuelve un objeto tipo DatetimeIndex o Index</target>
        </trans-unit>
        <trans-unit id="e55faf7a09074a6a866ad052dfba8d934e2a620c" translate="yes" xml:space="preserve">
          <source>If True returns a Timedelta/TimedeltaIndex of the results.</source>
          <target state="translated">Si True devuelve un Timedelta/TimedeltaIndex de los resultados.</target>
        </trans-unit>
        <trans-unit id="50b84049db5e2134804159a690e8517ba44f78e8" translate="yes" xml:space="preserve">
          <source>If True then default datelike columns may be converted (depending on keep_default_dates). If False, no dates will be converted. If a list of column names, then those columns will be converted and default datelike columns may also be converted (depending on keep_default_dates).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460a87b8b136bb4a2b3c54602f91c633b0e77bca" translate="yes" xml:space="preserve">
          <source>If True then the object returned will contain the relative frequencies of the unique values.</source>
          <target state="translated">Si es True,entonces el objeto devuelto contendrá las frecuencias relativas de los valores únicos.</target>
        </trans-unit>
        <trans-unit id="2f6899875f0d289bc3d7921ca50f8266c60d0690" translate="yes" xml:space="preserve">
          <source>If True, adds a column to output DataFrame called &amp;ldquo;_merge&amp;rdquo; with information on the source of each row. If string, column with information on source of each row will be added to output DataFrame, and column will be named value of string. Information column is Categorical-type and takes on a value of &amp;ldquo;left_only&amp;rdquo; for observations whose merge key only appears in &amp;lsquo;left&amp;rsquo; DataFrame, &amp;ldquo;right_only&amp;rdquo; for observations whose merge key only appears in &amp;lsquo;right&amp;rsquo; DataFrame, and &amp;ldquo;both&amp;rdquo; if the observation&amp;rsquo;s merge key is found in both.</source>
          <target state="translated">Si es verdadero, agrega una columna para generar DataFrame llamada &quot;_merge&quot; con informaci&amp;oacute;n sobre el origen de cada fila. Si es cadena, la columna con informaci&amp;oacute;n sobre el origen de cada fila se agregar&amp;aacute; al DataFrame de salida, y la columna se denominar&amp;aacute; valor de cadena. La columna de informaci&amp;oacute;n es de tipo categ&amp;oacute;rico y toma un valor de &quot;left_only&quot; para las observaciones cuya clave de combinaci&amp;oacute;n solo aparece en el DataFrame &quot;left&quot;, &quot;right_only&quot; para las observaciones cuya clave de combinaci&amp;oacute;n solo aparece en el DataFrame &quot;right&quot; y &quot;ambos&quot; si el La clave de combinaci&amp;oacute;n de la observaci&amp;oacute;n se encuentra en ambos.</target>
        </trans-unit>
        <trans-unit id="f47a60165f80019a2aacb8f49d7ce550df20d9ae" translate="yes" xml:space="preserve">
          <source>If True, adds a column to the output DataFrame called &amp;ldquo;_merge&amp;rdquo; with information on the source of each row. The column can be given a different name by providing a string argument. The column will have a Categorical type with the value of &amp;ldquo;left_only&amp;rdquo; for observations whose merge key only appears in the left DataFrame, &amp;ldquo;right_only&amp;rdquo; for observations whose merge key only appears in the right DataFrame, and &amp;ldquo;both&amp;rdquo; if the observation&amp;rsquo;s merge key is found in both DataFrames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a0d8d2165cdc25ae287fecadf2dc5419cb8c90" translate="yes" xml:space="preserve">
          <source>If True, allow matching with the same &amp;lsquo;on&amp;rsquo; value (i.e. less-than-or-equal-to / greater-than-or-equal-to)</source>
          <target state="translated">Si es Verdadero, permitir la coincidencia con el mismo valor &quot;activado&quot; (es decir, menor o igual a / mayor o igual que)</target>
        </trans-unit>
        <trans-unit id="1954fe0d26126090114d61aee388af1ae86e3bf1" translate="yes" xml:space="preserve">
          <source>If True, and if group keys contain NA values, NA values together with row/column will be dropped. If False, NA values will also be treated as the key in groups</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d19895ec0d15a9331df9ff0f2a55c57a6a58746" translate="yes" xml:space="preserve">
          <source>If True, and if group keys contain NA values, NA values together with row/column will be dropped. If False, NA values will also be treated as the key in groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4660645b9175a4b6c992d8f895126a90fe4a50a3" translate="yes" xml:space="preserve">
          <source>If True, assumes the passed-in pattern is a regular expression.</source>
          <target state="translated">Si es cierto,asume que el patrón de paso es una expresión regular.</target>
        </trans-unit>
        <trans-unit id="1e74a09f271b28537768cc8961b39d335e31e6de" translate="yes" xml:space="preserve">
          <source>If True, assumes the pat is a regular expression.</source>
          <target state="translated">Si es cierto,asume que la palmada es una expresión regular.</target>
        </trans-unit>
        <trans-unit id="467512e132775d71f6afd4e58bafe55b86f48864" translate="yes" xml:space="preserve">
          <source>If True, boolean values can be plotted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f3e2f20afae1e95c8a12af9612d6d458bd5a5a" translate="yes" xml:space="preserve">
          <source>If True, case sensitive (the default if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc051579ade2d30effac2d7f975b7af0eaf1117" translate="yes" xml:space="preserve">
          <source>If True, case sensitive (the default if &lt;code&gt;pat&lt;/code&gt; is a string)</source>
          <target state="translated">Si es verdadero, distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas (el valor predeterminado si &lt;code&gt;pat&lt;/code&gt; es una cadena)</target>
        </trans-unit>
        <trans-unit id="9f69db8a36129425d43c6f59fe632f1d4ad16ea5" translate="yes" xml:space="preserve">
          <source>If True, case sensitive.</source>
          <target state="translated">Si es cierto,distingue entre mayúsculas y minúsculas.</target>
        </trans-unit>
        <trans-unit id="849117a9db8ed6e6e51890ffed8b4fd6a41700fb" translate="yes" xml:space="preserve">
          <source>If True, checks that levels and codes are compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d154f805b1bfe50fc4462690ece065dd32c399b0" translate="yes" xml:space="preserve">
          <source>If True, columns in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="963a559726df468b6da10ccb14a21fec119cd396" translate="yes" xml:space="preserve">
          <source>If True, columns in &lt;code&gt;self&lt;/code&gt; that do not exist in &lt;code&gt;other&lt;/code&gt; will be overwritten with NaNs.</source>
          <target state="translated">Si es True, las columnas en &lt;code&gt;self&lt;/code&gt; que no existen en &lt;code&gt;other&lt;/code&gt; se sobrescribir&amp;aacute;n con NaN.</target>
        </trans-unit>
        <trans-unit id="0072997ec6faf6f05624c4fd43f7c2c5957f60e6" translate="yes" xml:space="preserve">
          <source>If True, copy the underlying data.</source>
          <target state="translated">Si es cierto,copie los datos subyacentes.</target>
        </trans-unit>
        <trans-unit id="3b1dcb5dd58fb08e7346d27ce52d23be1c63ae1c" translate="yes" xml:space="preserve">
          <source>If True, create stacked plot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beef21df15134efbd5ef8eaa6cfbb8bd6ce0957e" translate="yes" xml:space="preserve">
          <source>If True, do not use the index labels.</source>
          <target state="translated">Si es cierto,no utilice las etiquetas de índice.</target>
        </trans-unit>
        <trans-unit id="39eabebf10ef842b50bf2b46f976dd96a678bf6f" translate="yes" xml:space="preserve">
          <source>If True, do not use the index values along the concatenation axis. The resulting axis will be labeled 0, &amp;hellip;, n - 1. This is useful if you are concatenating objects where the concatenation axis does not have meaningful indexing information. Note the index values on the other axes are still respected in the join.</source>
          <target state="translated">Si es True, no utilice los valores de &amp;iacute;ndice a lo largo del eje de concatenaci&amp;oacute;n. El eje resultante se etiquetar&amp;aacute; como 0,&amp;hellip;, n - 1. Esto es &amp;uacute;til si est&amp;aacute; concatenando objetos donde el eje de concatenaci&amp;oacute;n no tiene informaci&amp;oacute;n de indexaci&amp;oacute;n significativa. Tenga en cuenta que los valores de &amp;iacute;ndice en los otros ejes a&amp;uacute;n se respetan en la combinaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2be78667d971f765edd09b5dcf231a83202213b7" translate="yes" xml:space="preserve">
          <source>If True, do operation inplace and return None.</source>
          <target state="translated">Si es cierto,haga la operación en el lugar y devuelva ninguna.</target>
        </trans-unit>
        <trans-unit id="02a05fbc517d0938e12546e82b1fa2c67e2f36f4" translate="yes" xml:space="preserve">
          <source>If True, draw a table using the data in the DataFrame and the data will be transposed to meet matplotlib&amp;rsquo;s default layout. If a Series or DataFrame is passed, use passed data to draw a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b1d2c85f895aef12f78ff43875c24af96a30a5" translate="yes" xml:space="preserve">
          <source>If True, each cell will have an &lt;code&gt;id&lt;/code&gt; attribute in their HTML tag. The &lt;code&gt;id&lt;/code&gt; takes the form &lt;code&gt;T_&amp;lt;uuid&amp;gt;_row&amp;lt;num_row&amp;gt;_col&amp;lt;num_col&amp;gt;&lt;/code&gt; where &lt;code&gt;&amp;lt;uuid&amp;gt;&lt;/code&gt; is the unique identifier, &lt;code&gt;&amp;lt;num_row&amp;gt;&lt;/code&gt; is the row number and &lt;code&gt;&amp;lt;num_col&amp;gt;&lt;/code&gt; is the column number.</source>
          <target state="translated">Si es True, cada celda tendr&amp;aacute; un atributo &lt;code&gt;id&lt;/code&gt; en su etiqueta HTML. El &lt;code&gt;id&lt;/code&gt; toma la forma &lt;code&gt;T_&amp;lt;uuid&amp;gt;_row&amp;lt;num_row&amp;gt;_col&amp;lt;num_col&amp;gt;&lt;/code&gt; donde &lt;code&gt;&amp;lt;uuid&amp;gt;&lt;/code&gt; es el identificador &amp;uacute;nico, &lt;code&gt;&amp;lt;num_row&amp;gt;&lt;/code&gt; es el n&amp;uacute;mero de fila y &lt;code&gt;&amp;lt;num_col&amp;gt;&lt;/code&gt; es el n&amp;uacute;mero de columna.</target>
        </trans-unit>
        <trans-unit id="c187de18efb1034db0f173b43d135203505eb0f2" translate="yes" xml:space="preserve">
          <source>If True, each whitespace character (as defined by string.whitespace) remaining after tab expansion will be replaced by a single space (default: True).</source>
          <target state="translated">Si es True,cada carácter de espacio en blanco (como se define en string.whitespace)que quede después de la expansión de la pestaña será reemplazado por un solo espacio (por defecto:True).</target>
        </trans-unit>
        <trans-unit id="7bc41a15bead4034e53881eb90092ca96d9054c1" translate="yes" xml:space="preserve">
          <source>If True, fill in-place. Note: this will modify any other views on this object (e.g., a no-copy slice for a column in a DataFrame).</source>
          <target state="translated">Si es cierto,rellene en el lugar.Nota:esto modificará cualquier otra vista de este objeto (por ejemplo,un trozo sin copiar para una columna en un DataFrame).</target>
        </trans-unit>
        <trans-unit id="779f470c819fe4b8c76c9ffe041585b2a57ed854" translate="yes" xml:space="preserve">
          <source>If True, ignore the order of index &amp;amp; columns. Note: index labels must match their respective rows (same as in columns) - same labels must be with the same data.</source>
          <target state="translated">Si es verdadero, ignore el orden de &amp;iacute;ndice y columnas. Nota: las etiquetas de &amp;iacute;ndice deben coincidir con sus respectivas filas (igual que en las columnas); las mismas etiquetas deben tener los mismos datos.</target>
        </trans-unit>
        <trans-unit id="c1fb42cadb1475602cce6ec757150306fd56fb02" translate="yes" xml:space="preserve">
          <source>If True, in place. Note: this will modify any other views on this object (e.g. a column from a DataFrame). Returns the caller if this is True.</source>
          <target state="translated">Si es cierto,en su lugar.Nota:esto modificará cualquier otra vista de este objeto (por ejemplo,una columna de un DataFrame).Devuelve la llamada si es True.</target>
        </trans-unit>
        <trans-unit id="7f32cc95594d1282134f1d68f351ad29dfeba40d" translate="yes" xml:space="preserve">
          <source>If True, infer dtypes; if a dict of column to dtype, then use those; if False, then don&amp;rsquo;t infer dtypes at all, applies only to the data.</source>
          <target state="translated">Si es True, infiera dtypes; si es un dict of column to dtype, util&amp;iacute;celos; si es False, entonces no infiera dtypes en absoluto, se aplica solo a los datos.</target>
        </trans-unit>
        <trans-unit id="7997ecfa519f0e9d11e8ccfaf5aa7070e2ac85d4" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a638dbfeb78f983bc652085d7b9c8a2d0bd1c8" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating &lt;code&gt;object&lt;/code&gt; dtypes for system-level memory consumption, and include it in the returned value.</source>
          <target state="translated">Si es True, realice una introspecci&amp;oacute;n profunda de los datos interrogando tipos d de &lt;code&gt;object&lt;/code&gt; para el consumo de memoria a nivel del sistema e incl&amp;uacute;yalo en el valor devuelto.</target>
        </trans-unit>
        <trans-unit id="11c935c8f1af11c12f350eee790d77bcc513b2a8" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating &lt;code&gt;object&lt;/code&gt; dtypes for system-level memory consumption, and include it in the returned values.</source>
          <target state="translated">Si es Verdadero, realice una introspecci&amp;oacute;n profunda de los datos interrogando tipos de &lt;code&gt;object&lt;/code&gt; para el consumo de memoria a nivel del sistema e incl&amp;uacute;yalos en los valores devueltos.</target>
        </trans-unit>
        <trans-unit id="c8196976ac650ceea0e3a5f6ce68de3af78ca762" translate="yes" xml:space="preserve">
          <source>If True, modifies the DataFrame in place (do not create a new object).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f616449e447dd01e651b655bec89b32f9f161a" translate="yes" xml:space="preserve">
          <source>If True, mutates in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79427f24ce68d71e994b467383dc8a5a268616c" translate="yes" xml:space="preserve">
          <source>If True, only apply to numeric columns.</source>
          <target state="translated">Si es cierto,sólo se aplica a las columnas numéricas.</target>
        </trans-unit>
        <trans-unit id="35ec09831bdd6b8649e000f3fff40e0f896b2493" translate="yes" xml:space="preserve">
          <source>If True, original index is ignored. If False, the original index is retained. Index labels will be repeated as necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ead6d9026e6e44fe03446f442da04f5bbd5558f" translate="yes" xml:space="preserve">
          <source>If True, outputs info in JSON format to the console.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35ba5920ddefac79cf35ea89415ec6c3aaa7827" translate="yes" xml:space="preserve">
          <source>If True, parse dates in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c714b402a0f7d59a93c0a1d85e385c49190143" translate="yes" xml:space="preserve">
          <source>If True, parse dates in &lt;code&gt;data&lt;/code&gt; with the day first order</source>
          <target state="translated">Si es True, analizar las fechas en los &lt;code&gt;data&lt;/code&gt; con el primer orden del d&amp;iacute;a</target>
        </trans-unit>
        <trans-unit id="11a6adfd18dc986d6ff6528d42e29ae888e6d526" translate="yes" xml:space="preserve">
          <source>If True, perform operation in-place.</source>
          <target state="translated">Si es cierto,realice la operación en el lugar.</target>
        </trans-unit>
        <trans-unit id="52083255d0c1625b5421b918b643ad39c3d91f57" translate="yes" xml:space="preserve">
          <source>If True, plot colorbar (only relevant for &amp;lsquo;scatter&amp;rsquo; and &amp;lsquo;hexbin&amp;rsquo; plots).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b35ea2160939c711232caacbe9ffc59471f5f6b" translate="yes" xml:space="preserve">
          <source>If True, prefix records with dotted (?) path, e.g. foo.bar.field if meta is [&amp;lsquo;foo&amp;rsquo;, &amp;lsquo;bar&amp;rsquo;].</source>
          <target state="translated">Si es Verdadero, prefija los registros con una ruta de puntos (?), Por ejemplo, foo.bar.field si meta es ['foo', 'bar'].</target>
        </trans-unit>
        <trans-unit id="918691faec44a66f1b1c5ddaf68832370f5563d0" translate="yes" xml:space="preserve">
          <source>If True, prefix records with dotted (?) path, e.g. foo.bar.field if path to records is [&amp;lsquo;foo&amp;rsquo;, &amp;lsquo;bar&amp;rsquo;].</source>
          <target state="translated">Si es Verdadero, prefija los registros con una ruta de puntos (?), Por ejemplo, foo.bar.field si la ruta a los registros es ['foo', 'bar'].</target>
        </trans-unit>
        <trans-unit id="1b787f2412a9a56f4f2d0a2789a8e490bc7bd97a" translate="yes" xml:space="preserve">
          <source>If True, raise Exception on creating index with duplicates.</source>
          <target state="translated">Si es cierto,aumentar la excepción al crear el índice con duplicados.</target>
        </trans-unit>
        <trans-unit id="f92c7eaff72b81ab6a7f6f3c046d665142253fca" translate="yes" xml:space="preserve">
          <source>If True, raise ValueError on creating index with duplicates.</source>
          <target state="translated">Si es cierto,aumente el ValueError al crear el índice con los duplicados.</target>
        </trans-unit>
        <trans-unit id="65688aa40ea915fb917db04985ab684fb4b0d10f" translate="yes" xml:space="preserve">
          <source>If True, require an exact format match.</source>
          <target state="translated">Si es cierto,requiere una coincidencia de formato exacta.</target>
        </trans-unit>
        <trans-unit id="a51ee754f13842cc1c7503238049ba90f6317028" translate="yes" xml:space="preserve">
          <source>If True, return DataFrame with one column per capture group. If False, return a Series/Index if there is one capture group or DataFrame if there are multiple capture groups.</source>
          <target state="translated">Si es cierto,devuelva el DataFrame con una columna por grupo de captura.Si es Falso,devuelva una Serie/Índice si hay un grupo de captura o un DataFrame si hay varios grupos de captura.</target>
        </trans-unit>
        <trans-unit id="752a06fc414514adb4cbae9fe15c30471375abcf" translate="yes" xml:space="preserve">
          <source>If True, return DataFrame/MultiIndex expanding dimensionality. If False, return Series/Index.</source>
          <target state="translated">Si es cierto,devuelva la dimensionalidad de expansión de DataFrame/MultiIndex.Si es falso,devuelve Series/Índice.</target>
        </trans-unit>
        <trans-unit id="fceb9f4dd2f49705ce97835f6760fabf3db79d64" translate="yes" xml:space="preserve">
          <source>If True, return the index as the first element of the tuple.</source>
          <target state="translated">Si es cierto,devuelve el índice como el primer elemento de la tupla.</target>
        </trans-unit>
        <trans-unit id="db6a2a7946d7a74ee079d7db1cd5033117192d16" translate="yes" xml:space="preserve">
          <source>If True, returns an iterator for reading the file incrementally.</source>
          <target state="translated">Si es cierto,devuelve un iterador para leer el archivo de forma incremental.</target>
        </trans-unit>
        <trans-unit id="8e9f098b0cebf828eaf4b7145977c959411d29fa" translate="yes" xml:space="preserve">
          <source>If True, skip NaN values.</source>
          <target state="translated">Si es cierto,salta los valores de NaN.</target>
        </trans-unit>
        <trans-unit id="2c7785df59be40ed32a0a30ad986c482f4b9104c" translate="yes" xml:space="preserve">
          <source>If True, skip over blank lines rather than interpreting as NaN values.</source>
          <target state="translated">Si es cierto,salta las líneas en blanco en lugar de interpretarlas como valores de NaN.</target>
        </trans-unit>
        <trans-unit id="45dc4286e28963ebfaf419f2ca82e19caa47ad55" translate="yes" xml:space="preserve">
          <source>If True, sort values in ascending order, otherwise descending.</source>
          <target state="translated">Si es cierto,ordene los valores en orden ascendente,de lo contrario descendente.</target>
        </trans-unit>
        <trans-unit id="b4c0dbb1de303429c5f1585939b0e85294386572" translate="yes" xml:space="preserve">
          <source>If True, tab characters will be expanded to spaces (default: True).</source>
          <target state="translated">Si es True,los caracteres de tabulación se expandirán a espacios (por defecto:True).</target>
        </trans-unit>
        <trans-unit id="f9b43baf827304c498c502484b0f8be2d39c6d28" translate="yes" xml:space="preserve">
          <source>If True, the resulting axis will be labeled 0, 1, &amp;hellip;, n - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d21f7b111187cb1a3ffe644e0758fb4ee939e9" translate="yes" xml:space="preserve">
          <source>If True, the resulting index will be labeled 0, 1, &amp;hellip;, n - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4133671064687e871d2078ebf94e5b70a1263d8" translate="yes" xml:space="preserve">
          <source>If True, the underlying data is copied. Otherwise (default), no copy is made if possible.</source>
          <target state="translated">Si es cierto,se copian los datos subyacentes.En caso contrario (por defecto),no se realiza ninguna copia si es posible.</target>
        </trans-unit>
        <trans-unit id="fdead9bb7da05f8a6a1234e7274e5a9b654351b0" translate="yes" xml:space="preserve">
          <source>If True, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width (default: True).</source>
          <target state="translated">Si es cierto,entonces las palabras más largas que el ancho se romperán para asegurar que ninguna línea sea más larga que el ancho.Si es falso,las palabras largas no se romperán,y algunas líneas pueden ser más largas que el ancho (por defecto:Verdadero).</target>
        </trans-unit>
        <trans-unit id="96caf78b1c5986e9400372061306220c9af20aa7" translate="yes" xml:space="preserve">
          <source>If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets.</source>
          <target state="translated">Si es cierto,utilice un caché de fechas únicas y convertidas para aplicar la conversión de fecha y hora.Puede producir una aceleración significativa al analizar cadenas de fechas duplicadas,especialmente las que tienen compensaciones de zonas horarias.</target>
        </trans-unit>
        <trans-unit id="850369ac77e896e440c30d1b4a94fb2f6cbfc17a" translate="yes" xml:space="preserve">
          <source>If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets. The cache is only used when there are at least 50 values. The presence of out-of-bounds values will render the cache unusable and may slow down parsing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cbf45354c267296e53e87ec9ae9077df026352c" translate="yes" xml:space="preserve">
          <source>If True, use dtypes that use &lt;code&gt;pd.NA&lt;/code&gt; as missing value indicator for the resulting DataFrame (only applicable for &lt;code&gt;engine=&quot;pyarrow&quot;&lt;/code&gt;). As new dtypes are added that support &lt;code&gt;pd.NA&lt;/code&gt; in the future, the output with this option will change to use those dtypes. Note: this is an experimental option, and behaviour (e.g. additional support dtypes) may change without notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc5966567744c9deec0817e54ad119ae9eb8051" translate="yes" xml:space="preserve">
          <source>If True, whitespace that, after wrapping, happens to end up at the beginning or end of a line is dropped (default: True).</source>
          <target state="translated">Si es True,se eliminan los espacios en blanco que,después de envolverse,terminan al principio o al final de una línea (por defecto:True).</target>
        </trans-unit>
        <trans-unit id="af63c1972ac9e275096f086bf4dbabfd22a77fc3" translate="yes" xml:space="preserve">
          <source>If True, wrapping will occur preferably on whitespace and right after hyphens in compound words, as it is customary in English. If false, only whitespaces will be considered as potentially good places for line breaks, but you need to set break_long_words to false if you want truly insecable words (default: True).</source>
          <target state="translated">Si es cierto,la envoltura se producirá preferentemente en espacio en blanco y justo después de los guiones en palabras compuestas,como es costumbre en inglés.Si es falso,sólo los espacios en blanco se considerarán como lugares potencialmente buenos para saltos de línea,pero es necesario establecer break_long_words en falso si se desea que las palabras verdaderamente inseguras (por defecto:True).</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a23d3725070e24cb533dd92a64738f0efc9eeb" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DataFrame&lt;/code&gt; does not have a datetimelike index, but instead you want to resample based on datetimelike column in the frame, it can passed to the &lt;code&gt;on&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b671a6d1db2b1bde6a5afb6d8028d31c59543e99" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;dict&lt;/code&gt; is used, all unmapped categories are mapped to &lt;code&gt;NaN&lt;/code&gt; and the result is an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Si se usa un &lt;code&gt;dict&lt;/code&gt; , todas las categor&amp;iacute;as no asignadas se asignan a &lt;code&gt;NaN&lt;/code&gt; y el resultado es un &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3fc417177302a9cebffe9152263446b535b47d84" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;dict&lt;/code&gt; or &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; is used any unmapped category is mapped to &lt;code&gt;NaN&lt;/code&gt;. Note that if this happens an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; will be returned.</source>
          <target state="translated">Si se utiliza un &lt;code&gt;dict&lt;/code&gt; o una &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; cualquier categor&amp;iacute;a no asignada se asigna a &lt;code&gt;NaN&lt;/code&gt; . Tenga en cuenta que si esto sucede , se devolver&amp;aacute; un &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a13d756489055d99c339c198cd08b153d3f1acb" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;list&lt;/code&gt; or an &lt;code&gt;ndarray&lt;/code&gt; is passed to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbad76c3179a700e058557a45022426a6d90e9b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;list&lt;/code&gt; or an &lt;code&gt;ndarray&lt;/code&gt; is passed to &lt;code&gt;to_replace&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; but they are not the same length.</source>
          <target state="translated">Si se pasa una &lt;code&gt;list&lt;/code&gt; a o un &lt;code&gt;ndarray&lt;/code&gt; a &lt;code&gt;to_replace&lt;/code&gt; y &lt;code&gt;value&lt;/code&gt; , pero no tienen la misma longitud.</target>
        </trans-unit>
        <trans-unit id="0839be279acdfe99dee443052560f05d4bdcf1b9" translate="yes" xml:space="preserve">
          <source>If a BaseIndexer subclass is passed, calculates the window boundaries based on the defined &lt;code&gt;get_window_bounds&lt;/code&gt; method. Additional rolling keyword arguments, namely</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22fc0dda91ce0c6cfb03015af03fb9aeb3abddac" translate="yes" xml:space="preserve">
          <source>If a DataFrame column label is a valid Python variable name, the column can be accessed like an attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ecaf8e0ca6ae047a74668fa9ea2d262449f1084" translate="yes" xml:space="preserve">
          <source>If a DataFrame contains homogeneously-typed data, the ndarray can actually be modified in-place, and the changes will be reflected in the data structure. For heterogeneous data (e.g. some of the DataFrame&amp;rsquo;s columns are not all the same dtype), this will not be the case. The values attribute itself, unlike the axis labels, cannot be assigned to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5059a3623e6ca9dc7f9b266d2608545843106902" translate="yes" xml:space="preserve">
          <source>If a class cannot be constructed from this &amp;lsquo;string&amp;rsquo;.</source>
          <target state="translated">Si no se puede construir una clase a partir de esta 'cadena'.</target>
        </trans-unit>
        <trans-unit id="f9cedd3dcea3a4e2001323d4fb82c0c2fdae21be" translate="yes" xml:space="preserve">
          <source>If a column or index cannot be represented as an array of datetimes, say because of an unparsable value or a mixture of timezones, the column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_csv&lt;/code&gt;. To parse an index or column with a mixture of timezones, specify &lt;code&gt;date_parser&lt;/code&gt; to be a partially-applied &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;utc=True&lt;/code&gt;. See &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;Parsing a CSV with mixed timezones&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c5f0454c9ec1fde1714f17e1d952b9f7a5cc52" translate="yes" xml:space="preserve">
          <source>If a column or index cannot be represented as an array of datetimes, say because of an unparseable value or a mixture of timezones, the column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_csv&lt;/code&gt;. To parse an index or column with a mixture of timezones, specify &lt;code&gt;date_parser&lt;/code&gt; to be a partially-applied &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;utc=True&lt;/code&gt;. See &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;Parsing a CSV with mixed timezones&lt;/a&gt; for more.</source>
          <target state="translated">Si una columna o &amp;iacute;ndice no se puede representar como una matriz de fechas y horas, digamos debido a un valor no analizable o una mezcla de zonas horarias, la columna o &amp;iacute;ndice se devolver&amp;aacute; inalterado como un tipo de datos de objeto. Para el an&amp;aacute;lisis de fecha y hora no est&amp;aacute;ndar, use &lt;code&gt;pd.to_datetime&lt;/code&gt; despu&amp;eacute;s de &lt;code&gt;pd.read_csv&lt;/code&gt; . Para analizar un &amp;iacute;ndice o columna con una combinaci&amp;oacute;n de zonas horarias, especifique &lt;code&gt;date_parser&lt;/code&gt; para que sea &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;pandas.to_datetime()&lt;/code&gt; &lt;/a&gt; parcialmente aplicado con &lt;code&gt;utc=True&lt;/code&gt; . Consulte &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;An&amp;aacute;lisis de un CSV con zonas horarias mixtas&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cb05dbd1a0c1f92f0ac524caef14f441578726d7" translate="yes" xml:space="preserve">
          <source>If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;to_datetime()&lt;/code&gt;&lt;/a&gt; after &lt;code&gt;pd.read_csv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024994997113b185624470243df16f27242d166f" translate="yes" xml:space="preserve">
          <source>If a column or index contains an unparseable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_excel&lt;/code&gt;.</source>
          <target state="translated">Si una columna o &amp;iacute;ndice contiene una fecha que no se puede analizar, la columna o &amp;iacute;ndice completo se devolver&amp;aacute; sin alterar como un tipo de datos de objeto. Para el an&amp;aacute;lisis de fecha y hora no est&amp;aacute;ndar, use &lt;code&gt;pd.to_datetime&lt;/code&gt; despu&amp;eacute;s de &lt;code&gt;pd.read_excel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e3d1c1348b7e96001002741ab684587a40cbd98" translate="yes" xml:space="preserve">
          <source>If a column or index contains an unparseable date, the entire column or index will be returned unaltered as an object data type. If you don`t want to parse some cells as date just change their type in Excel to &amp;ldquo;Text&amp;rdquo;. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_excel&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2a0936634decaa45bcdb1077adb50caa2399d8" translate="yes" xml:space="preserve">
          <source>If a date does not meet the &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;timestamp limitations&lt;/a&gt;, passing errors=&amp;rsquo;ignore&amp;rsquo; will return the original input instead of raising any exception.</source>
          <target state="translated">Si una fecha no cumple con las &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;limitaciones de&lt;/a&gt; la marca de tiempo , pasar errors = 'ignore' devolver&amp;aacute; la entrada original en lugar de generar una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="26d1dfa4eb8f3f636141624b253418278cce2bf6" translate="yes" xml:space="preserve">
          <source>If a date does not meet the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;timestamp limitations&lt;/a&gt;, passing errors=&amp;rsquo;ignore&amp;rsquo; will return the original input instead of raising any exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78077d7035e3e1bf386c562ad6a6026d3c197e60" translate="yes" xml:space="preserve">
          <source>If a date is not on a valid date, the rollback and rollforward methods can be used to roll the date to the nearest valid date before/after the date.</source>
          <target state="translated">Si una fecha no es válida,se pueden utilizar los métodos de retroceso y avance para pasar la fecha a la fecha válida más cercana antes o después de la fecha.</target>
        </trans-unit>
        <trans-unit id="8d1bab9d594a6b54ccef73be2232f54e1cae5a4c" translate="yes" xml:space="preserve">
          <source>If a dict is passed, the sorted keys will be used as the &lt;code&gt;keys&lt;/code&gt; argument, unless it is passed, in which case the values will be selected (see below). Any None objects will be dropped silently unless they are all None in which case a ValueError will be raised.</source>
          <target state="translated">Si se pasa un dictado, las claves ordenadas se utilizar&amp;aacute;n como argumento de &lt;code&gt;keys&lt;/code&gt; , a menos que se pase, en cuyo caso se seleccionar&amp;aacute;n los valores (ver m&amp;aacute;s abajo). Cualquier objeto None se eliminar&amp;aacute; silenciosamente a menos que todos sean None, en cuyo caso se generar&amp;aacute; un ValueError.</target>
        </trans-unit>
        <trans-unit id="c64f440bc1e2f9dad75b50704b6ed07e14d9e40e" translate="yes" xml:space="preserve">
          <source>If a dtype is not specified, &lt;code&gt;data&lt;/code&gt; is passed through to &lt;code&gt;numpy.array()&lt;/code&gt;, and a &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt;&lt;code&gt;arrays.PandasArray&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">Si no se especifica un dtype, los &lt;code&gt;data&lt;/code&gt; se pasan a &lt;code&gt;numpy.array()&lt;/code&gt; y se devuelve un &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt; &lt;code&gt;arrays.PandasArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a750fe1b1c8b035fa42fb2c24abeccf5e0da7e3" translate="yes" xml:space="preserve">
          <source>If a dtype is not specified, pandas will infer the best dtype from the values. See the description of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fe46615783e09d1c274ff3a49d146beb787260" translate="yes" xml:space="preserve">
          <source>If a file has one more column of data than the number of column names, the first column will be used as the &lt;code&gt;DataFrame&lt;/code&gt;&amp;rsquo;s row names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7d71bcc1d2c6a1d61b732ec612b9df1bce2c33" translate="yes" xml:space="preserve">
          <source>If a filepath is provided for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a6eb6c7d1e4657646b6302b848a8747082bbc0" translate="yes" xml:space="preserve">
          <source>If a filepath is provided for &lt;code&gt;filepath_or_buffer&lt;/code&gt;, map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead.</source>
          <target state="translated">Si se proporciona una ruta de &lt;code&gt;filepath_or_buffer&lt;/code&gt; para filepath_or_buffer , asigne el objeto de archivo directamente a la memoria y acceda a los datos directamente desde all&amp;iacute;. El uso de esta opci&amp;oacute;n puede mejorar el rendimiento porque ya no hay sobrecarga de E / S.</target>
        </trans-unit>
        <trans-unit id="f5b0e7c1c6bb842c26a2ad6521207d7b659ebca7" translate="yes" xml:space="preserve">
          <source>If a function with the same arguments as the one being deprecated exist, you can use the &lt;code&gt;pandas.util._decorators.deprecate&lt;/code&gt;:</source>
          <target state="translated">Si existe una funci&amp;oacute;n con los mismos argumentos que la que est&amp;aacute; en desuso, puede usar &lt;code&gt;pandas.util._decorators.deprecate&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7a55f5c7d16f500e6da16614d2adb42965248f34" translate="yes" xml:space="preserve">
          <source>If a label is in several intervals, you get the locations of all the relevant intervals.</source>
          <target state="translated">Si una etiqueta está en varios intervalos,se obtienen las ubicaciones de todos los intervalos relevantes.</target>
        </trans-unit>
        <trans-unit id="4f47b003de0809072edf3c049a0ce30a21e507fa" translate="yes" xml:space="preserve">
          <source>If a label is not contained, an exception is raised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0da20aab515eb31a5cffcf23bf1728563e5abe6" translate="yes" xml:space="preserve">
          <source>If a list of dict/series is passed and the keys are all contained in the DataFrame&amp;rsquo;s index, the order of the columns in the resulting DataFrame will be unchanged.</source>
          <target state="translated">Si se pasa una lista de dict / series y todas las claves est&amp;aacute;n contenidas en el &amp;iacute;ndice del DataFrame, el orden de las columnas en el DataFrame resultante no cambiar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="c2084be9d8e5985ceb2c1bbb180f91068c44c3ca" translate="yes" xml:space="preserve">
          <source>If a list/tuple of expressions is passed they will be combined via &lt;code&gt;&amp;amp;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e233f630f6e64777b8004e8848b98a69ced310c3" translate="yes" xml:space="preserve">
          <source>If a mapping is passed, the sorted keys will be used as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a57b14a0144398613fa46db6a643212d87f9fab6" translate="yes" xml:space="preserve">
          <source>If a non-default &lt;code&gt;orient&lt;/code&gt; was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see &lt;a href=&quot;#orient-options&quot;&gt;Orient Options&lt;/a&gt; for an overview.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f27dc120bd0cd0936d6ea3e2605fa14175aaad" translate="yes" xml:space="preserve">
          <source>If a pandas object contains data with multiple dtypes &lt;em&gt;in a single column&lt;/em&gt;, the dtype of the column will be chosen to accommodate all of the data types (&lt;code&gt;object&lt;/code&gt; is the most general).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a932b347122ba17dc03c8f35de7e3581545858f" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed it is used to fill all missing values. Alternatively, an array-like &amp;lsquo;value&amp;rsquo; can be given. It&amp;rsquo;s expected that the array-like have the same length as &amp;lsquo;self&amp;rsquo;.</source>
          <target state="translated">Si se pasa un valor escalar, se utiliza para completar todos los valores faltantes. Alternativamente, se puede dar un 'valor' similar a una matriz. Se espera que el tipo de matriz tenga la misma longitud que 'self'.</target>
        </trans-unit>
        <trans-unit id="f43ebe72554d837c1947c44cf9fbf7743e493fcf" translate="yes" xml:space="preserve">
          <source>If a str is passed, the color is the same for both negative and positive numbers. If 2-tuple/list is used, the first element is the color_negative and the second is the color_positive (eg: [&amp;lsquo;#d65f5f&amp;rsquo;, &amp;lsquo;#5fba7d&amp;rsquo;]).</source>
          <target state="translated">Si se pasa una cadena, el color es el mismo para los n&amp;uacute;meros negativos y positivos. Si se usa 2-tupla / lista, el primer elemento es color_negative y el segundo es color_positive (por ejemplo: ['# d65f5f', '# 5fba7d']).</target>
        </trans-unit>
        <trans-unit id="664c221db1d1a044cd6be831ba5898cec1c6e906" translate="yes" xml:space="preserve">
          <source>If a string is given, must be a name of the level If list-like must be names or ints of levels.</source>
          <target state="translated">Si se da una cadena,debe ser un nombre del nivel Si se da una lista,deben ser nombres o ints de niveles.</target>
        </trans-unit>
        <trans-unit id="cafbad4f4c6b2e30bd77049a6387059a8f8a90f9" translate="yes" xml:space="preserve">
          <source>If a string is given, must be a name of the level. If list-like must be names or ints of levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1949bae823faece7ef8021ce74e5c7a237a24cd" translate="yes" xml:space="preserve">
          <source>If a string is given, must be the name of a level If list-like, elements must be names or indexes of levels.</source>
          <target state="translated">Si se da una cadena,debe ser el nombre de un nivel Si se da una lista,los elementos deben ser nombres o índices de niveles.</target>
        </trans-unit>
        <trans-unit id="2bd170078f20dc52e06bd86e8da7a8f33d73c15a" translate="yes" xml:space="preserve">
          <source>If a string is given, must be the name of a level If list-like, elements must be names or positional indexes of levels.</source>
          <target state="translated">Si se da una cadena,debe ser el nombre de un nivel Si se da una lista,los elementos deben ser nombres o índices posicionales de niveles.</target>
        </trans-unit>
        <trans-unit id="0e11c8b3b91fdf70e4a950b5de81db4fc235d3c5" translate="yes" xml:space="preserve">
          <source>If a string matches both a column name and an index level name then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7917632f71f22a6298fe99afe8da3a61861e243" translate="yes" xml:space="preserve">
          <source>If a string matches both a column name and an index level name, then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab59153983f88bd3ac8734604519b5c38d644805" translate="yes" xml:space="preserve">
          <source>If a string or type, the data type to store all columns. If a dictionary, a mapping of column names and indices (zero-indexed) to specific data types.</source>
          <target state="translated">Si una cadena o tipo,el tipo de datos para almacenar todas las columnas.Si es un diccionario,un mapeo de los nombres de las columnas e índices (con índice cero)a tipos de datos específicos.</target>
        </trans-unit>
        <trans-unit id="2cbe87791c4a51a042d70e2afa4264d8fe2def9f" translate="yes" xml:space="preserve">
          <source>If a string or type, the data type to store all index levels. If a dictionary, a mapping of index level names and indices (zero-indexed) to specific data types.</source>
          <target state="translated">Si una cadena o tipo,el tipo de datos para almacenar todos los niveles de índice.Si es un diccionario,un mapeo de los nombres de los niveles de índice y los índices (con índice cero)a tipos de datos específicos.</target>
        </trans-unit>
        <trans-unit id="55a5950721810aaccc29839d233355a54a0b4274" translate="yes" xml:space="preserve">
          <source>If a string, it will be used as Root Directory path when writing a partitioned dataset. By file-like object, we refer to objects with a write() method, such as a file handle (e.g. via builtin open function) or io.BytesIO. The engine fastparquet does not accept file-like objects. If path is None, a bytes object is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d189c526d90e423b055887f39bc14e0c56d23d2a" translate="yes" xml:space="preserve">
          <source>If a string, it will be used as Root Directory path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5aa15d15858711058094f491e41747189d9c0b7" translate="yes" xml:space="preserve">
          <source>If a subset of data is being parsed using the &lt;code&gt;usecols&lt;/code&gt; option, the &lt;code&gt;index_col&lt;/code&gt; specification is based on that subset, not the original data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ceab91a6aa8289bb5b8021e866580a53c5a0f2" translate="yes" xml:space="preserve">
          <source>If all elements are non-NA/null, returns None. Also returns None for empty Series/DataFrame.</source>
          <target state="translated">Si todos los elementos son no-NA/nulos,devuelve Ninguno.También devuelve Ninguno para Serie/DataFrame vacío.</target>
        </trans-unit>
        <trans-unit id="8ff697a66f776f6bf9d5cb31605d3eecae945555" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than a label in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7703cb2a81c8223e4ff309ac97d763111e01337d" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than a label in &lt;code&gt;where&lt;/code&gt;, -1 is returned.</source>
          <target state="translated">Si todas las etiquetas del &amp;iacute;ndice son posteriores a una etiqueta en &lt;code&gt;where&lt;/code&gt; , se devuelve -1.</target>
        </trans-unit>
        <trans-unit id="ba174535c6272f0b997374d38b2209ea810429e1" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than the passed label, NaN is returned.</source>
          <target state="translated">Si todas las etiquetas del índice son posteriores a la etiqueta pasada,se devuelve NaN.</target>
        </trans-unit>
        <trans-unit id="c1e29cecb8deb1bb9249dfbe69e58b24b5165bd3" translate="yes" xml:space="preserve">
          <source>If allow_fill=True and fill_value is not None, indices specified by -1 is regarded as NA. If Index doesn&amp;rsquo;t hold NA, raise ValueError</source>
          <target state="translated">Si allow_fill = True y fill_value no es None, los &amp;iacute;ndices especificados por -1 se consideran NA. Si el &amp;iacute;ndice no tiene NA, aumente ValueError</target>
        </trans-unit>
        <trans-unit id="e1054a2c112cb5a2006f1be297346faf1ff6466b" translate="yes" xml:space="preserve">
          <source>If allow_fill=True and fill_value is not None, indices specified by -1 is regarded as NA. If Index doesn&amp;rsquo;t hold NA, raise ValueError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff14634826d79012ed764cfa8de5a9838978cc57" translate="yes" xml:space="preserve">
          <source>If an array is passed, it must be the same length as the data. The list can contain any of the other types (except list). Keys to group by on the pivot table column. If an array is passed, it is being used as the same manner as column values.</source>
          <target state="translated">Si se pasa una matriz,debe tener la misma longitud que los datos.La lista puede contener cualquiera de los otros tipos (excepto la lista).Claves para agrupar por en la columna de la tabla pivotante.Si se pasa una matriz,se utiliza de la misma manera que los valores de la columna.</target>
        </trans-unit>
        <trans-unit id="9c5ee36569ccce557bf8297b686d33c4ab619682" translate="yes" xml:space="preserve">
          <source>If an array is passed, it must be the same length as the data. The list can contain any of the other types (except list). Keys to group by on the pivot table index. If an array is passed, it is being used as the same manner as column values.</source>
          <target state="translated">Si se pasa una matriz,debe tener la misma longitud que los datos.La lista puede contener cualquiera de los otros tipos (excepto la lista).Claves para agrupar en el índice de la tabla pivotante.Si se pasa una matriz,se utiliza de la misma manera que los valores de las columnas.</target>
        </trans-unit>
        <trans-unit id="1e71a78ce13f5e4a60eac8f95606f6a518f5b879" translate="yes" xml:space="preserve">
          <source>If an explicit &lt;code&gt;ordered=True&lt;/code&gt; is given but no</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8c676f3147891a205dd28d61aaddbbe77519ec" translate="yes" xml:space="preserve">
          <source>If an explicit &lt;code&gt;ordered=True&lt;/code&gt; is given but no &lt;code&gt;categories&lt;/code&gt; and the &lt;code&gt;values&lt;/code&gt; are not sortable.</source>
          <target state="translated">Si se da un &lt;code&gt;ordered=True&lt;/code&gt; expl&amp;iacute;cito = Verdadero pero no hay &lt;code&gt;categories&lt;/code&gt; y los &lt;code&gt;values&lt;/code&gt; no se pueden ordenar.</target>
        </trans-unit>
        <trans-unit id="2e237695f0996c6449ac5d388a3e4cbbe78266cb" translate="yes" xml:space="preserve">
          <source>If an index is passed, the values in data corresponding to the labels in the index will be pulled out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8259a6d68eab8c19d5e0eabd67405da8ab57b1f5" translate="yes" xml:space="preserve">
          <source>If an indexed key is passed and its index is unalignable to the frame index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66446b4ed963dd0e69016b68d9c4e0f33d4ddf75" translate="yes" xml:space="preserve">
          <source>If any items are not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a811d63c53b8811ca58b647eaf1fc34cafb5488e" translate="yes" xml:space="preserve">
          <source>If any kind of string dtype is passed in.</source>
          <target state="translated">Si se pasa cualquier tipo de tipo de cuerda.</target>
        </trans-unit>
        <trans-unit id="737e8df6f3276db9f6615ef85a21d500c5c61d47" translate="yes" xml:space="preserve">
          <source>If any method argument other than the default of None is specified as these are not yet implemented.</source>
          <target state="translated">Si se especifica cualquier argumento de método que no sea el predeterminado de Ninguno,ya que éstos no se han implementado todavía.</target>
        </trans-unit>
        <trans-unit id="70c61d6e01ff0aae044349ecdba7bbb1250fe8c6" translate="yes" xml:space="preserve">
          <source>If any of the labels is not found in the selected axis and &amp;ldquo;errors=&amp;rsquo;raise&amp;rsquo;&amp;rdquo;.</source>
          <target state="translated">Si alguna de las etiquetas no se encuentra en el eje seleccionado y &amp;ldquo;errores = 'subir'&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="f11beca5c6ae8017f4b7406cc4296549080b22d3" translate="yes" xml:space="preserve">
          <source>If any of the labels is not found in the selected axis.</source>
          <target state="translated">Si alguna de las etiquetas no se encuentra en el eje seleccionado.</target>
        </trans-unit>
        <trans-unit id="2320b14f67eb9ec3b540a8bb24814b91f5c2d50d" translate="yes" xml:space="preserve">
          <source>If any of the levels passed to &lt;code&gt;set_levels()&lt;/code&gt; exceeds the existing length, all of the values from that argument will be stored in the MultiIndex levels, though the values will be truncated in the MultiIndex output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98671b51d92b145da7c4a68f0d6180b02179c533" translate="yes" xml:space="preserve">
          <source>If any of the list items is not a string object, the result of the join will be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47983fc844672129f9ac1881a49d6e66e982428b" translate="yes" xml:space="preserve">
          <source>If any of the list items is not a string object, the result of the join will be &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Si alguno de los elementos de la lista no es un objeto de cadena, el resultado de la combinaci&amp;oacute;n ser&amp;aacute; &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74b321536b7a61a75e369e0d3490288a3ea2fe2a" translate="yes" xml:space="preserve">
          <source>If any of these defaults are not what you want, or if you want to be explicit about how missing values are handled, consider using &lt;a href=&quot;../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna&quot;&gt;&lt;code&gt;fillna()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/api/pandas.dataframe.dropna#pandas.DataFrame.dropna&quot;&gt;&lt;code&gt;dropna()&lt;/code&gt;&lt;/a&gt; before plotting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc14636cf1e86ec565e13cf216055ad1c0f39df" translate="yes" xml:space="preserve">
          <source>If appending prefix, separator/delimiter to use. Or pass a list or dictionary as with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1979d89f7de4b9fbb39ec05f540083098724a80f" translate="yes" xml:space="preserve">
          <source>If appending prefix, separator/delimiter to use. Or pass a list or dictionary as with &lt;code&gt;prefix&lt;/code&gt;.</source>
          <target state="translated">Si agrega prefijo, separador / delimitador para usar. O pase una lista o diccionario con &lt;code&gt;prefix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a11a511e2ae2cc8424f72edc278dc39628207610" translate="yes" xml:space="preserve">
          <source>If applicable, we highly recommend that you implement &lt;code&gt;__array_ufunc__&lt;/code&gt; in your extension array to avoid coercion to an ndarray. See &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html&quot;&gt;the numpy documentation&lt;/a&gt; for an example.</source>
          <target state="translated">Si corresponde, le recomendamos que implemente &lt;code&gt;__array_ufunc__&lt;/code&gt; en su matriz de extensi&amp;oacute;n para evitar la coerci&amp;oacute;n a un ndarray. Consulte &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html&quot;&gt;la documentaci&amp;oacute;n de numpy&lt;/a&gt; para ver un ejemplo.</target>
        </trans-unit>
        <trans-unit id="072e26cb4593102e0bb6adf3546c35bd36d7bb05" translate="yes" xml:space="preserve">
          <source>If applying compression use the fletcher32 checksum.</source>
          <target state="translated">Si se aplica la compresión use la suma de comprobación fletcher32.</target>
        </trans-unit>
        <trans-unit id="53cfe1a79643b5445944cea852309386c3712f73" translate="yes" xml:space="preserve">
          <source>If at least one of the two is absent, but the index is sorted, and can be compared against start and stop labels, then slicing will still work as expected, by selecting labels which &lt;em&gt;rank&lt;/em&gt; between the two:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8772725018c792397868923cdb717ae3175a40" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, convert a specific level. Otherwise must be None</source>
          <target state="translated">Si el eje es un MultiÍndice,convierte un nivel específico.De lo contrario debe ser Ninguno</target>
        </trans-unit>
        <trans-unit id="87391f1e1e648bf058bee7a9654161130eecfc7b" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, localize a specific level. Otherwise must be None</source>
          <target state="translated">Si el eje es un Multi-Index,localiza un nivel específico.De lo contrario debe ser Ninguno</target>
        </trans-unit>
        <trans-unit id="8a50a2305a89159f20c3e526bded6db5fec79fba" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, localize a specific level. Otherwise must be None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1261ab8f79e64a44def90e5c786465d95ec434" translate="yes" xml:space="preserve">
          <source>If axis is 0 or &amp;lsquo;index&amp;rsquo; the result will be a Series. The resulting index will be a MultiIndex with &amp;lsquo;self&amp;rsquo; and &amp;lsquo;other&amp;rsquo; stacked alternately at the inner level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba63f643d6684b1fc4f7718c26beec37bedbe5f2" translate="yes" xml:space="preserve">
          <source>If axis is 1 or &amp;lsquo;columns&amp;rsquo; the result will be a DataFrame. It will have two columns namely &amp;lsquo;self&amp;rsquo; and &amp;lsquo;other&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dca845052cf9e007f580b3f733e1fac9e0281428" translate="yes" xml:space="preserve">
          <source>If axis is a MultiIndex, convert a specific level. Otherwise must be None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d63325924797f142a9e6c13d5c6dd030cce6e4" translate="yes" xml:space="preserve">
          <source>If axis labels are not passed, they will be constructed from the input data based on common sense rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69e66617e975b4f927b06bc80c35783ba32c625" translate="yes" xml:space="preserve">
          <source>If bin edges are not unique, raise ValueError or drop non-uniques.</source>
          <target state="translated">Si los bordes de los contenedores no son únicos,aumentar el error de valor o dejar los no únicos.</target>
        </trans-unit>
        <trans-unit id="8999a3f1324f4044aba9bb76851d3a780b4c0b9d" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;skiprows&lt;/code&gt; are specified, &lt;code&gt;header&lt;/code&gt; will be relative to the end of &lt;code&gt;skiprows&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253d364dc8215c289f304194e1235e5c7cb7fc6c" translate="yes" xml:space="preserve">
          <source>If both dayfirst and yearfirst are True, yearfirst is preceded (same as dateutil).</source>
          <target state="translated">Si tanto el día como el año son verdaderos,se precede el año (igual que la fecha).</target>
        </trans-unit>
        <trans-unit id="20ec4100e04e070e2add532e3371209cd96960d1" translate="yes" xml:space="preserve">
          <source>If both of &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; are empty</source>
          <target state="translated">Si tanto &lt;code&gt;include&lt;/code&gt; como &lt;code&gt;exclude&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os</target>
        </trans-unit>
        <trans-unit id="cc54c1baccafe31b1df94f88241fa0c566479663" translate="yes" xml:space="preserve">
          <source>If buf is None, returns the result as a string. Otherwise returns None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab952ef7ef22e79ae1ce8234aa416ed5979fad75" translate="yes" xml:space="preserve">
          <source>If buf is None, returns the resulting LateX format as a string. Otherwise returns None.</source>
          <target state="translated">Si buf es None,devuelve el formato LateX resultante como una cadena.En caso contrario,devuelve None.</target>
        </trans-unit>
        <trans-unit id="f9d07940e53f336322c19c2cd577417a583dce50" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True. An example of a valid callable argument would be &lt;code&gt;lambda x: x.upper() in
['AAA', 'BBB', 'DDD']&lt;/code&gt;. Using this parameter results in much faster parsing time and lower memory usage.</source>
          <target state="translated">Si es invocable, la funci&amp;oacute;n invocable se evaluar&amp;aacute; frente a los nombres de columna, devolviendo nombres donde la funci&amp;oacute;n invocable se eval&amp;uacute;a como True. Un ejemplo de un argumento invocable v&amp;aacute;lido ser&amp;iacute;a &lt;code&gt;lambda x: x.upper() in ['AAA', 'BBB', 'DDD']&lt;/code&gt; . El uso de este par&amp;aacute;metro da como resultado un tiempo de an&amp;aacute;lisis mucho m&amp;aacute;s r&amp;aacute;pido y un menor uso de memoria.</target>
        </trans-unit>
        <trans-unit id="f28da403364b3ca9b72b658dafe69a7d983229a8" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True:</source>
          <target state="translated">Si se puede llamar,la función llamable se evaluará con los nombres de las columnas,devolviendo los nombres en los que la función llamable se evalúa a True:</target>
        </trans-unit>
        <trans-unit id="9cc56eeda19feaa07d8092a737946e7c1b49b405" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise. An example of a valid callable argument would be &lt;code&gt;lambda x: x in [0, 2]&lt;/code&gt;.</source>
          <target state="translated">Si es invocable, la funci&amp;oacute;n invocable se evaluar&amp;aacute; frente a los &amp;iacute;ndices de fila, devolviendo True si la fila debe omitirse y False en caso contrario. Un ejemplo de un argumento invocable v&amp;aacute;lido ser&amp;iacute;a &lt;code&gt;lambda x: x in [0, 2]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e005dc46520dc329b9e3c5ee6c0162eb68f3a28a" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513ede3f3a8cf7e7586af86037ccc686ffc6ba4a" translate="yes" xml:space="preserve">
          <source>If callable, then evaluate each column name against it and parse the column if the callable returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">Si es invocable, eval&amp;uacute;e el nombre de cada columna y analice la columna si el invocable devuelve &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51a1daa823350ace6cba99a153f88fcde66e034b" translate="yes" xml:space="preserve">
          <source>If categorical data is ordered (&lt;code&gt;s.cat.ordered == True&lt;/code&gt;), then the order of the categories has a meaning and certain operations are possible. If the categorical is unordered, &lt;code&gt;.min()/.max()&lt;/code&gt; will raise a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685d3f02d43beae9f293bf9f8747df3c13b4c5c6" translate="yes" xml:space="preserve">
          <source>If columns are a MultiIndex then use this level to melt.</source>
          <target state="translated">Si las columnas son un Multiíndice,entonces usa este nivel para fundir.</target>
        </trans-unit>
        <trans-unit id="73f524f5a96443526a0f752ccc0a0f45d33e2689" translate="yes" xml:space="preserve">
          <source>If data is None, start is used as the start point in generating regular timedelta data.</source>
          <target state="translated">Si los datos son Ninguno,el inicio se utiliza como punto de partida en la generación de datos regulares de timedelta.</target>
        </trans-unit>
        <trans-unit id="ff093965800686fc456d1ec74cddd873c03a2a06" translate="yes" xml:space="preserve">
          <source>If data is None, start is used as the start point in generating regular timestamp data.</source>
          <target state="translated">Si los datos son Ninguno,el inicio se utiliza como punto de partida en la generación de datos de marca de tiempo regulares.</target>
        </trans-unit>
        <trans-unit id="dae62288e37f2c075b791322d9beac67a5a2965c" translate="yes" xml:space="preserve">
          <source>If data is None, used as the start point in generating regular period data.</source>
          <target state="translated">Si los datos son Ninguno,se utiliza como punto de partida en la generación de datos del período regular.</target>
        </trans-unit>
        <trans-unit id="f945356c77bbf782bb9b78eeeea13f0a8f770df9" translate="yes" xml:space="preserve">
          <source>If datetimes contain timezone information</source>
          <target state="translated">Si las fechas y horas contienen información de la zona horaria</target>
        </trans-unit>
        <trans-unit id="151a8d67020136db3746f6fd54d019f0751e502a" translate="yes" xml:space="preserve">
          <source>If dropna, will take the nth non-null row, dropna is either &amp;lsquo;all&amp;rsquo; or &amp;lsquo;any&amp;rsquo;; this is equivalent to calling dropna(how=dropna) before the groupby.</source>
          <target state="translated">Si dropna, tomar&amp;aacute; la en&amp;eacute;sima fila no nula, dropna es 'all' o 'any'; esto es equivalente a llamar a dropna (c&amp;oacute;mo = dropna) antes del groupby.</target>
        </trans-unit>
        <trans-unit id="ec063cf3e1fb3772513c2c6ae92ef2ab32d9ee75" translate="yes" xml:space="preserve">
          <source>If dtype is None, we find the dtype that best fits the data. If an actual dtype is provided, we coerce to that dtype if it&amp;rsquo;s safe. Otherwise, an error will be raised.</source>
          <target state="translated">Si dtype es None, buscamos el dtype que mejor se ajusta a los datos. Si se proporciona un dtype real, coaccionamos a ese dtype si es seguro. De lo contrario, se generar&amp;aacute; un error.</target>
        </trans-unit>
        <trans-unit id="c23c90863643c36250aa1190db0145034944681e" translate="yes" xml:space="preserve">
          <source>If error_bad_lines is &lt;code&gt;False&lt;/code&gt;, and warn_bad_lines is &lt;code&gt;True&lt;/code&gt;, a warning for each &amp;ldquo;bad line&amp;rdquo; will be output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5291444796253761cd9ba2fe4457299e7f8a08a6" translate="yes" xml:space="preserve">
          <source>If error_bad_lines is False, and warn_bad_lines is True, a warning for each &amp;ldquo;bad line&amp;rdquo; will be output.</source>
          <target state="translated">Si error_bad_lines es False y warn_bad_lines es True, se generar&amp;aacute; una advertencia por cada &quot;l&amp;iacute;nea defectuosa&quot;.</target>
        </trans-unit>
        <trans-unit id="f6c76ec1a67aef33e908ab260e62c8b2c8f08ade" translate="yes" xml:space="preserve">
          <source>If everything looks good, you are ready to make a pull request. A pull request is how code from a local repository becomes available to the GitHub community and can be looked at and eventually merged into the master version. This pull request and its associated changes will eventually be committed to the master branch and available in the next release. To submit a pull request:</source>
          <target state="translated">Si todo se ve bien,estás listo para hacer una solicitud de extracción.Una petición pull es la forma en que el código de un repositorio local se pone a disposición de la comunidad GitHub y puede ser visto y eventualmente fusionado en la versión maestra.Esta petición pull y sus cambios asociados serán eventualmente comprometidos con la rama maestra y estarán disponibles en la próxima versión.Para enviar una solicitud de extracción:</target>
        </trans-unit>
        <trans-unit id="6d2b4f1f9225dd4aceca893c869ab3d65bdb1668" translate="yes" xml:space="preserve">
          <source>If for a certain row the number of found splits &amp;lt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c9060c54c6bb6c39f0e98425258486180b9e59" translate="yes" xml:space="preserve">
          <source>If for a certain row the number of found splits &amp;lt; &lt;code&gt;n&lt;/code&gt;, append &lt;code&gt;None&lt;/code&gt; for padding up to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;expand=True&lt;/code&gt;</source>
          <target state="translated">Si para una determinada fila el n&amp;uacute;mero de divisiones encontradas &amp;lt; &lt;code&gt;n&lt;/code&gt; , agregue &lt;code&gt;None&lt;/code&gt; para completar hasta &lt;code&gt;n&lt;/code&gt; si &lt;code&gt;expand=True&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f1bbf12bd4be481a7b76931c444ac723ac7f23e" translate="yes" xml:space="preserve">
          <source>If for some reason you have a column named &lt;code&gt;index&lt;/code&gt;, then you can refer to the index as &lt;code&gt;ilevel_0&lt;/code&gt; as well, but at this point you should consider renaming your columns to something less ambiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332a16903c151c1ecb224e10fcac795483da5669" translate="yes" xml:space="preserve">
          <source>If found splits &amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6211ffb8fa3fb2fd37ec09f2b6296b76ea53b066" translate="yes" xml:space="preserve">
          <source>If found splits &amp;gt; &lt;code&gt;n&lt;/code&gt;, make first &lt;code&gt;n&lt;/code&gt; splits only</source>
          <target state="translated">Si encuentra divisiones&amp;gt; &lt;code&gt;n&lt;/code&gt; , haga las primeras &lt;code&gt;n&lt;/code&gt; divisiones solamente</target>
        </trans-unit>
        <trans-unit id="967baafdae5ca9570712f0e926ab45321d817a83" translate="yes" xml:space="preserve">
          <source>If found splits &amp;lt;=</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37fc31feaa05a56a504bc57a3dc5a6d1aa79bdc" translate="yes" xml:space="preserve">
          <source>If found splits &amp;lt;= &lt;code&gt;n&lt;/code&gt;, make all splits</source>
          <target state="translated">Si encuentra divisiones &amp;lt;= &lt;code&gt;n&lt;/code&gt; , haga todas las divisiones</target>
        </trans-unit>
        <trans-unit id="faedb07d74ab41f0e6f62f0f259b9779f728a236" translate="yes" xml:space="preserve">
          <source>If freq is an invalid frequency</source>
          <target state="translated">Si freq es una frecuencia inválida</target>
        </trans-unit>
        <trans-unit id="803c3a3090c279b46259470fbbb792974d7f901b" translate="yes" xml:space="preserve">
          <source>If freq is not specified then tries to use the freq or inferred_freq attributes of the index. If neither of those attributes exist, a ValueError is thrown</source>
          <target state="translated">Si no se especifica freq,entonces intenta utilizar los atributos freq o inferred_freq del índice.Si ninguno de esos atributos existe,se lanza un ValueError</target>
        </trans-unit>
        <trans-unit id="913b44532f3a53f43a3f8beb187957afcd4c09d7" translate="yes" xml:space="preserve">
          <source>If freq is passed, the index will be increased using the periods and the freq.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd7e199c3229ad1a29b7396ccb73cb9b8b33ec4f" translate="yes" xml:space="preserve">
          <source>If func returns a Series object the result will be a DataFrame.</source>
          <target state="translated">Si func devuelve un objeto de la serie,el resultado será un DataFrame.</target>
        </trans-unit>
        <trans-unit id="e05cd03bb9478611824232e1b320bc090b5b4903" translate="yes" xml:space="preserve">
          <source>If given, it will use the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e40162438268f3434fb42f4961c0381c5a410b" translate="yes" xml:space="preserve">
          <source>If given, it will use the &lt;code&gt;fig&lt;/code&gt; reference for plotting instead of creating a new one with default parameters.</source>
          <target state="translated">Si se proporciona, usar&amp;aacute; la referencia de &lt;code&gt;fig&lt;/code&gt; para trazar en lugar de crear una nueva con los par&amp;aacute;metros predeterminados.</target>
        </trans-unit>
        <trans-unit id="7c905670577eb23cd045f70e74e41dc154603058" translate="yes" xml:space="preserve">
          <source>If grouper is PeriodIndex and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f948fed8d6912efb15a4f875d827717c7e831f0" translate="yes" xml:space="preserve">
          <source>If grouper is PeriodIndex and &lt;code&gt;freq&lt;/code&gt; parameter is passed.</source>
          <target state="translated">Si mero es PeriodIndex y &lt;code&gt;freq&lt;/code&gt; se pasa par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="2153311a52299005ad6b900f85d75a5bc89c102d" translate="yes" xml:space="preserve">
          <source>If implementing NumPy&amp;rsquo;s &lt;code&gt;__array_ufunc__&lt;/code&gt; interface, pandas expects that</source>
          <target state="translated">Si implementa la interfaz &lt;code&gt;__array_ufunc__&lt;/code&gt; de NumPy , pandas espera que</target>
        </trans-unit>
        <trans-unit id="40c691f0e2bf83f7f8c92678a022cd114c946bdb" translate="yes" xml:space="preserve">
          <source>If index resolution is second, then the minute-accurate timestamp gives a &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b739f8adfb8ff0aa6b270221577514d1891e01fa" translate="yes" xml:space="preserve">
          <source>If instead you don&amp;rsquo;t want to or cannot name your index, you can use the name &lt;code&gt;index&lt;/code&gt; in your query expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5b6c6275ac36d8c29c9ef0f491f5feaa9d6ffc" translate="yes" xml:space="preserve">
          <source>If int and &amp;ldquo;stop&amp;rdquo; is not given, interpreted as &amp;ldquo;stop&amp;rdquo; instead.</source>
          <target state="translated">Si no se dan int y &quot;stop&quot;, se interpretan como &quot;stop&quot; en su lugar.</target>
        </trans-unit>
        <trans-unit id="6ef44adf7e998129a0e17630965a27165eef6f11" translate="yes" xml:space="preserve">
          <source>If int, array-like, or BitGenerator (NumPy&amp;gt;=1.17), seed for random number generator If np.random.RandomState, use as numpy RandomState object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7b2547e4136f8605b954d25571fea98abec426" translate="yes" xml:space="preserve">
          <source>If int, then indicates last column to be parsed.</source>
          <target state="translated">Si es &quot;int&quot;,indica la última columna a analizar.</target>
        </trans-unit>
        <trans-unit id="3bb72fad3e82acae71dc7993a1447557d62c8a5b" translate="yes" xml:space="preserve">
          <source>If io is not a buffer or path, this must be set to identify io. Acceptable values are None or xlrd.</source>
          <target state="translated">Si io no es un amortiguador o una ruta,esto debe ser configurado para identificar io.Los valores aceptables son Ninguno o xlrd.</target>
        </trans-unit>
        <trans-unit id="9263cf78203e7295e057b98deb02db9d1dd510c4" translate="yes" xml:space="preserve">
          <source>If io is not a buffer or path, this must be set to identify io. Supported engines: &amp;ldquo;xlrd&amp;rdquo;, &amp;ldquo;openpyxl&amp;rdquo;, &amp;ldquo;odf&amp;rdquo;, &amp;ldquo;pyxlsb&amp;rdquo;. Engine compatibility :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ca6d2682f5657f7e98ea4373774e219e824496" translate="yes" xml:space="preserve">
          <source>If its an offset then this will be the time period of each window. Each window will be a variable sized based on the observations included in the time-period. This is only valid for datetimelike indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b90b33df08c56801541d97b52863d5cc1a2208" translate="yes" xml:space="preserve">
          <source>If its an offset then this will be the time period of each window. Each window will be a variable sized based on the observations included in the time-period. This is only valid for datetimelike indexes. This is new in 0.19.0</source>
          <target state="translated">Si es un desplazamiento,entonces este será el período de tiempo de cada ventana.Cada ventana tendrá un tamaño variable basado en las observaciones incluidas en el período de tiempo.Esto sólo es válido para los índices parecidos a la fecha.Esto es nuevo en 0.19.0</target>
        </trans-unit>
        <trans-unit id="ad91bd2fcbc8853d5dc9cba2938f0dd911cf8a6d" translate="yes" xml:space="preserve">
          <source>If keep_tz is False:</source>
          <target state="translated">Si keep_tz es falso:</target>
        </trans-unit>
        <trans-unit id="baf1483fae1fac9f24a7c2ddac2906ea600716bb" translate="yes" xml:space="preserve">
          <source>If keep_tz is True:</source>
          <target state="translated">Si keep_tz es cierto:</target>
        </trans-unit>
        <trans-unit id="5bb59e5d8fa791e8b043037739659a61a93a3a51" translate="yes" xml:space="preserve">
          <source>If label is contained, will be reference to calling Series, otherwise a new object.</source>
          <target state="translated">Si la etiqueta está contenida,será la referencia para llamar a la Serie,de lo contrario un nuevo objeto.</target>
        </trans-unit>
        <trans-unit id="d8f134714528b444920506c4fe5aa496b4202bff" translate="yes" xml:space="preserve">
          <source>If label is not contained, a new object is created with the label placed at the end of the result index.</source>
          <target state="translated">Si la etiqueta no está contenida,se crea un nuevo objeto con la etiqueta colocada al final del índice de resultados.</target>
        </trans-unit>
        <trans-unit id="a824931c7f88c06d3b1aacfaeeb1337548e955e0" translate="yes" xml:space="preserve">
          <source>If label pair is contained, will be reference to calling DataFrame, otherwise a new object.</source>
          <target state="translated">Si el par de etiquetas está contenido,será la referencia para llamar al DataFrame,de lo contrario un nuevo objeto.</target>
        </trans-unit>
        <trans-unit id="c00e1450820324efbc32fd35d064eb356db799b1" translate="yes" xml:space="preserve">
          <source>If level is specified, then, DataFrame is returned; otherwise, Series is returned.</source>
          <target state="translated">Si se especifica el nivel,entonces,se devuelve el DataFrame;si no,se devuelve la Serie.</target>
        </trans-unit>
        <trans-unit id="7877da1e50e258680542b6af26d6fd85ecae2065" translate="yes" xml:space="preserve">
          <source>If level is specified, then, Series is returned; otherwise, scalar is returned.</source>
          <target state="translated">Si se especifica el nivel,entonces,se devuelve la Serie;de lo contrario,se devuelve el escalar.</target>
        </trans-unit>
        <trans-unit id="ca17fab71c58fc25bab74d5c9db224c9c0dc9b57" translate="yes" xml:space="preserve">
          <source>If limit is specified, consecutive NaNs will be filled in this direction.</source>
          <target state="translated">Si se especifica un límite,se rellenarán NaNs consecutivos en esta dirección.</target>
        </trans-unit>
        <trans-unit id="eed73a2e297bebfb2ce480434de0e2542a0badfc" translate="yes" xml:space="preserve">
          <source>If limit is specified, consecutive NaNs will be filled with this restriction.</source>
          <target state="translated">Si se especifica un límite,los NaNs consecutivos se llenarán con esta restricción.</target>
        </trans-unit>
        <trans-unit id="88c5560ab95765eb920a208bc7fb13404935ff90" translate="yes" xml:space="preserve">
          <source>If limit is specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7caf98f1a23fbe99f3eecc43311325e017b47681" translate="yes" xml:space="preserve">
          <source>If list of functions passed, the resulting pivot table will have hierarchical columns whose top level are the function names (inferred from the function objects themselves) If dict is passed, the key is column to aggregate and value is function or list of functions</source>
          <target state="translated">Si se pasa la lista de funciones,la tabla pivote resultante tendrá columnas jerárquicas cuyo nivel superior son los nombres de las funciones (deducidos de los propios objetos de la función)Si se pasa el dictado,la clave es la columna a agregar y el valor es la función o la lista de funciones</target>
        </trans-unit>
        <trans-unit id="50b3274a3da951ffb461e11c79f73edf459c48e7" translate="yes" xml:space="preserve">
          <source>If list of functions passed, the resulting pivot table will have hierarchical columns whose top level are the function names (inferred from the function objects themselves) If dict is passed, the key is column to aggregate and value is function or list of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d66f9c3628338003e89214bb889ccfda13c37c0" translate="yes" xml:space="preserve">
          <source>If list of int, then indicates list of column numbers to be parsed.</source>
          <target state="translated">Si es una lista de int,entonces indica la lista de números de columna que deben ser analizados.</target>
        </trans-unit>
        <trans-unit id="5fe49dea595acc90377978d171ab9c0a0e7439a2" translate="yes" xml:space="preserve">
          <source>If list of string, then indicates list of column names to be parsed.</source>
          <target state="translated">Si es una lista de cadenas,indica la lista de nombres de columnas que se deben analizar.</target>
        </trans-unit>
        <trans-unit id="68825ea1972a721fb38b022bcfd56c301bc54df2" translate="yes" xml:space="preserve">
          <source>If margins is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d433683ef161d07d541b7f8a919bcca2325d430" translate="yes" xml:space="preserve">
          <source>If margins is &lt;code&gt;True&lt;/code&gt;, will also normalize margin values.</source>
          <target state="translated">Si m&amp;aacute;rgenes es &lt;code&gt;True&lt;/code&gt; , tambi&amp;eacute;n normalizar&amp;aacute; los valores de los m&amp;aacute;rgenes.</target>
        </trans-unit>
        <trans-unit id="62646e174920cf65de16aa9a88e993e7c1b80354" translate="yes" xml:space="preserve">
          <source>If max_cols is exceeded, switch to truncate view. Depending on</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9fb1c596d81c3f532c5167f5855674a6532345" translate="yes" xml:space="preserve">
          <source>If max_rows is exceeded, switch to truncate view. Depending on</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a02a553bcee455a6ab31e5dbd189b43939c5bad" translate="yes" xml:space="preserve">
          <source>If method is specified, this is the maximum number of consecutive NaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled.</source>
          <target state="translated">Si se especifica el método,este es el número máximo de valores de NaN consecutivos a rellenar hacia adelante/atrás.En otras palabras,si hay un hueco con más de este número de NaNs consecutivos,sólo se llenará parcialmente.Si no se especifica el método,éste es el número máximo de entradas a lo largo de todo el eje en el que se llenarán las NaN.</target>
        </trans-unit>
        <trans-unit id="64b5d3200781c8ed371e1e797a995a4f75b1dcb3" translate="yes" xml:space="preserve">
          <source>If method is specified, this is the maximum number of consecutive NaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled. Must be greater than 0 if not None.</source>
          <target state="translated">Si se especifica el método,este es el número máximo de valores de NaN consecutivos a rellenar hacia adelante/atrás.En otras palabras,si hay un hueco con más de este número de NaNs consecutivos,sólo se llenará parcialmente.Si no se especifica el método,éste es el número máximo de entradas a lo largo de todo el eje en el que se llenarán las NaN.Debe ser mayor que 0 si no es ninguno.</target>
        </trans-unit>
        <trans-unit id="7f7d613c787dbb21e15f1dcf963bf265292c5edc" translate="yes" xml:space="preserve">
          <source>If more than one type is accepted, separate them by commas, except the last two types, that need to be separated by the word &amp;lsquo;or&amp;rsquo;:</source>
          <target state="translated">Si se acepta m&amp;aacute;s de un tipo, sep&amp;aacute;relos con comas, excepto los dos &amp;uacute;ltimos tipos, que deben estar separados por la palabra 'o':</target>
        </trans-unit>
        <trans-unit id="052f2f856a6dfb7a8830bd4e0484cb7b2be454e4" translate="yes" xml:space="preserve">
          <source>If multiple levels passed, should contain tuples. Construct hierarchical index using the passed keys as the outermost level.</source>
          <target state="translated">Si se pasan múltiples niveles,debe contener tuplas.Construye un índice jerárquico usando las claves pasadas como el nivel más externo.</target>
        </trans-unit>
        <trans-unit id="6501af21994846ec90e14ed89e7a813350f8d52c" translate="yes" xml:space="preserve">
          <source>If multiple object values have the highest count, then the &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; results will be arbitrarily chosen from among those with the highest count.</source>
          <target state="translated">Si varios valores de objeto tienen el recuento m&amp;aacute;s alto, entonces el &lt;code&gt;count&lt;/code&gt; y &lt;code&gt;top&lt;/code&gt; resultados principales se elegir&amp;aacute;n arbitrariamente entre los que tengan el recuento m&amp;aacute;s alto.</target>
        </trans-unit>
        <trans-unit id="34d7f3599c01ed87631ef489cca8da2b4308aa21" translate="yes" xml:space="preserve">
          <source>If multiple values equal the maximum, the first row label with that value is returned.</source>
          <target state="translated">Si varios valores son iguales al máximo,se devuelve la etiqueta de la primera fila con ese valor.</target>
        </trans-unit>
        <trans-unit id="12828981e6321f886a33ba30627df341eba8d652" translate="yes" xml:space="preserve">
          <source>If multiple values equal the minimum, the first row label with that value is returned.</source>
          <target state="translated">Si varios valores son iguales al mínimo,se devuelve la etiqueta de la primera fila con ese valor.</target>
        </trans-unit>
        <trans-unit id="22f182e9b6624459ce684e4c8ed64ff090a2529a" translate="yes" xml:space="preserve">
          <source>If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they&amp;rsquo;re appended to</source>
          <target state="translated">Si se especifican na_values ​​y keep_default_na es False, los valores NaN predeterminados se anulan; de lo contrario, se agregan a</target>
        </trans-unit>
        <trans-unit id="d6a517305158ceac1628f92ad56b945b90297339" translate="yes" xml:space="preserve">
          <source>If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they&amp;rsquo;re appended to.</source>
          <target state="translated">Si se especifican na_values ​​y keep_default_na es False, se anulan los valores predeterminados de NaN; de lo contrario, se agregan.</target>
        </trans-unit>
        <trans-unit id="f762185f104435345c74d2cdd090da0e1d42ac15" translate="yes" xml:space="preserve">
          <source>If ndarray-like but cannot infer the dtype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23113f2a52942ee42c83e1b254e8235537f3f63" translate="yes" xml:space="preserve">
          <source>If needed you can explicitly specify a format string, or a dict of arguments to pass to &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f4eb2917c5222b0d337bae6fbff3ef21460ab9a" translate="yes" xml:space="preserve">
          <source>If needed you can just adjust the bins with an &lt;code&gt;offset&lt;/code&gt; Timedelta that would be added to the default &lt;code&gt;origin&lt;/code&gt;. Those two examples are equivalent for this time series:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637d5696700a6df0a8baf6d3b140ebe5aff89341" translate="yes" xml:space="preserve">
          <source>If needed you can use a custom timestamp for &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7000054cf48292d0455a5b9aca5bf89643b6c472" translate="yes" xml:space="preserve">
          <source>If new categories are list-like and do not have the same number of items than the current categories or do not validate as categories</source>
          <target state="translated">Si las nuevas categorías son similares a una lista y no tienen el mismo número de artículos que las categorías actuales o no se validan como categorías</target>
        </trans-unit>
        <trans-unit id="56ab769c4964e541ce9265684d378bc3a0d09287" translate="yes" xml:space="preserve">
          <source>If new_categories does not validate as categories</source>
          <target state="translated">Si new_categories no se valida como categorías</target>
        </trans-unit>
        <trans-unit id="cbed0bbea58dcdb206a837899ad95a4ba77dcd33" translate="yes" xml:space="preserve">
          <source>If no names are provided, use the column names, or tuple of column names if the columns is a MultiIndex. If a sequence, overwrite names with the given sequence.</source>
          <target state="translated">Si no se proporcionan nombres,utilice los nombres de las columnas,o la tupla de nombres de las columnas si éstas son un Multiíndice.Si se trata de una secuencia,sobrescriba los nombres con la secuencia dada.</target>
        </trans-unit>
        <trans-unit id="5a5bad26bee04e3ba222956c2c796e863be42591" translate="yes" xml:space="preserve">
          <source>If none of the labels are found in the index.</source>
          <target state="translated">Si no se encuentra ninguna de las etiquetas en el índice.</target>
        </trans-unit>
        <trans-unit id="27841c0014abcd0463ff2861c53f354a6a34facc" translate="yes" xml:space="preserve">
          <source>If not None, and if the data has been successfully cast to a numerical dtype (or if the data was numeric to begin with), downcast that resulting data to the smallest numerical dtype possible according to the following rules:</source>
          <target state="translated">Si no hay ninguno,y si los datos se han fundido con éxito a un tipo numérico (o si los datos eran numéricos para empezar),baje los datos resultantes al tipo numérico más pequeño posible de acuerdo con las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="1e307ecdc7ecd59bd95757600bace6779421241e" translate="yes" xml:space="preserve">
          <source>If not None, apply the key function to the index values before sorting. This is similar to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ebf1d3140f80342f207320ff26cd6b1a32ef4f" translate="yes" xml:space="preserve">
          <source>If not None, apply the key function to the series values before sorting. This is similar to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e361817d859e555a419bc1371e6268617ba32d96" translate="yes" xml:space="preserve">
          <source>If not None, only these columns will be read from the file.</source>
          <target state="translated">Si no hay ninguno,sólo se leerán estas columnas del archivo.</target>
        </trans-unit>
        <trans-unit id="cfe9cce3f8330a3251ed95d788697677222e7323" translate="yes" xml:space="preserve">
          <source>If not None, sort on values in specified index level(s).</source>
          <target state="translated">Si no hay ninguno,ordene los valores en los niveles de índice especificados.</target>
        </trans-unit>
        <trans-unit id="9376aca00f183cc74c267ce0caa80bff2fb817d1" translate="yes" xml:space="preserve">
          <source>If not all of the labels are found in the selected axis</source>
          <target state="translated">Si no se encuentran todas las etiquetas en el eje seleccionado</target>
        </trans-unit>
        <trans-unit id="d0a22f48a5959f07a3692660fc0f335e8e4e36ac" translate="yes" xml:space="preserve">
          <source>If not passed, uses gca()</source>
          <target state="translated">Si no se aprueba,utiliza gca()</target>
        </trans-unit>
        <trans-unit id="c241cd23cfdf52a4bd48350a73a6738548d9b996" translate="yes" xml:space="preserve">
          <source>If not passed, uses gca().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605ce58ce37edd99b2cbc7ee655fc1a9f67c5f6c" translate="yes" xml:space="preserve">
          <source>If not provided, all columns are read.</source>
          <target state="translated">Si no se proporciona,se leen todas las columnas.</target>
        </trans-unit>
        <trans-unit id="c7adf8e39eb0b3d72eaf0f61526432eb5bfe7de6" translate="yes" xml:space="preserve">
          <source>If not specified, the keyword &lt;code&gt;sep&lt;/code&gt; for the separator defaults to the empty string, &lt;code&gt;sep=''&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29100beab681308f154ad5a4be5b3b89fb544c7" translate="yes" xml:space="preserve">
          <source>If not specified, there are two possibilities:</source>
          <target state="translated">Si no se especifica,hay dos posibilidades:</target>
        </trans-unit>
        <trans-unit id="67d8b502538e17d92597d391d70ada0247caada5" translate="yes" xml:space="preserve">
          <source>If not supplied then will default to self and produce pairwise output.</source>
          <target state="translated">Si no se suministra,entonces se autoprogramará y producirá una salida por pares.</target>
        </trans-unit>
        <trans-unit id="17e1ffdad774475011f6787cf4716965a7dadec6" translate="yes" xml:space="preserve">
          <source>If not supplied then will default to self.</source>
          <target state="translated">Si no se suministra,entonces se auto-incorporará.</target>
        </trans-unit>
        <trans-unit id="a7b3cbcd2ecfdfe645e2c20769e281ebccbcc3e3" translate="yes" xml:space="preserve">
          <source>If other is a Series, return the matrix product between self and other as a Serie. If other is a DataFrame or a numpy.array, return the matrix product of self and other in a DataFrame of a np.array.</source>
          <target state="translated">Si el otro es una Serie,devuelve el producto de la matriz entre el yo y el otro como una Serie.Si otro es un DataFrame o un numpy.array,devuelve el producto de la matriz entre uno mismo y otro en un DataFrame de un np.array.</target>
        </trans-unit>
        <trans-unit id="43623d69404123e7a6aac874029d1b30acdfa12e" translate="yes" xml:space="preserve">
          <source>If other is a Series, return the matrix product between self and other as a Series. If other is a DataFrame or a numpy.array, return the matrix product of self and other in a DataFrame of a np.array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236a44b890a6ba0afca4e7206977a422c9384304" translate="yes" xml:space="preserve">
          <source>If others is None, the method returns the concatenation of all strings in the calling Series/Index.</source>
          <target state="translated">Si otros son Ninguno,el método devuelve la concatenación de todas las cadenas en la llamada Serie/Índice.</target>
        </trans-unit>
        <trans-unit id="b6f15e903f0777b1e7f0e9efd0f00fdc7d5f16dc" translate="yes" xml:space="preserve">
          <source>If others is a list-like that contains a combination of Series, Index or np.ndarray (1-dim), then all elements will be unpacked and must satisfy the above criteria individually.</source>
          <target state="translated">Si otros son una lista que contiene una combinación de Series,Índices o np.ndarray (1-dim),entonces todos los elementos se desempacarán y deberán satisfacer los criterios anteriores de manera individual.</target>
        </trans-unit>
        <trans-unit id="44aa5702e4b920b2bf468228e7acc9cc6e30a8d3" translate="yes" xml:space="preserve">
          <source>If pandas does not infer a dedicated extension type a &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt;&lt;code&gt;arrays.PandasArray&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d6f5378543f5ad0bc487858af5d8d984e37eb8" translate="yes" xml:space="preserve">
          <source>If parsing dates (convert_dates is not False), then try to parse the default datelike columns. A column label is datelike if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa4696f9d9f11d69bd7c0bc73e4bd0736b1ad80" translate="yes" xml:space="preserve">
          <source>If parsing dates, then parse the default datelike columns.</source>
          <target state="translated">Si analizamos las fechas,entonces analizamos las columnas de datos predeterminadas.</target>
        </trans-unit>
        <trans-unit id="4884f91f4d98371473cdc16c244105fb8fec04f3" translate="yes" xml:space="preserve">
          <source>If parsing succeeded. Return type depends on input:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72335770581c60c00751461ab89cd0b5ee370293" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;all&amp;rsquo; or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab98323b9cd6c707ec25d2e47620cf585b844dc" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;all&amp;rsquo; or &lt;code&gt;True&lt;/code&gt;, will normalize over all values.</source>
          <target state="translated">Si se pasa 'todo' o &lt;code&gt;True&lt;/code&gt; , se normalizar&amp;aacute; sobre todos los valores.</target>
        </trans-unit>
        <trans-unit id="a89a0012ee03a22f72bd2860e27eba43a13982b3" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;columns&amp;rsquo; will normalize over each column.</source>
          <target state="translated">Si se pasan, las 'columnas' se normalizar&amp;aacute;n en cada columna.</target>
        </trans-unit>
        <trans-unit id="e234887ca1ae0a80fa1868664dd0238d5d04ba79" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;index&amp;rsquo; will normalize over each row.</source>
          <target state="translated">Si se pasa, el '&amp;iacute;ndice' se normalizar&amp;aacute; en cada fila.</target>
        </trans-unit>
        <trans-unit id="95e50caaa0069694aa1cc539c06f69fd598085ff" translate="yes" xml:space="preserve">
          <source>If passed a Series will use the values of the series (NOT THE INDEX).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdbafc7d17980ded598ce2f6b941b4de6b162f7f" translate="yes" xml:space="preserve">
          <source>If passed, must match number of column arrays passed.</source>
          <target state="translated">Si es aprobada,debe coincidir con el número de matrices de columnas aprobadas.</target>
        </trans-unit>
        <trans-unit id="f97f42e1389db9548ed46ba6d3fe5d917a8fa133" translate="yes" xml:space="preserve">
          <source>If passed, must match number of row arrays passed.</source>
          <target state="translated">Si es aprobado,debe coincidir con el número de filas aprobadas.</target>
        </trans-unit>
        <trans-unit id="9fa12f2a0ca4016bad2139234c3a9ac376f53792" translate="yes" xml:space="preserve">
          <source>If passed, then used to form histograms for separate groups</source>
          <target state="translated">Si se aprueba,se utiliza para formar histogramas para grupos separados</target>
        </trans-unit>
        <trans-unit id="2a4b782f57e19abcb2aa77b54645db0e489c6b42" translate="yes" xml:space="preserve">
          <source>If passed, then used to form histograms for separate groups.</source>
          <target state="translated">Si se aprueba,se utiliza para formar histogramas para grupos separados.</target>
        </trans-unit>
        <trans-unit id="3b1c91474589b55c524f8116422575c56dae40f7" translate="yes" xml:space="preserve">
          <source>If passed, will be used to limit data to a subset of columns.</source>
          <target state="translated">Si se pasa,se utilizará para limitar los datos a un subconjunto de columnas.</target>
        </trans-unit>
        <trans-unit id="cf13cb19b460c1c30c4e0e63d016fc04e393c052" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting csv format as a string. Otherwise returns None.</source>
          <target state="translated">Si path_or_buf es None,devuelve el formato csv resultante como una cadena.En caso contrario,devuelve None.</target>
        </trans-unit>
        <trans-unit id="467786b2cc9f24142a326f141e5e9998e551f79b" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting json format as a string. Otherwise returns None.</source>
          <target state="translated">Si path_or_buf es None,devuelve el formato json resultante como una cadena.En caso contrario,devuelve None.</target>
        </trans-unit>
        <trans-unit id="3ab35a4e69cd5e00e62bc40ef695d80398b3047f" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting msgpack format as a byte string. Otherwise returns None.</source>
          <target state="translated">Si path_or_buf es None,devuelve el formato msgpack resultante como una cadena de bytes.En caso contrario,devuelve None.</target>
        </trans-unit>
        <trans-unit id="0fe82b619e0bf64745c86d941d95a0506e74aff0" translate="yes" xml:space="preserve">
          <source>If periods is none, generated index will extend to first conforming period on or just past end argument</source>
          <target state="translated">Si los períodos no son ninguno,el índice generado se extenderá al primer período de conformidad con el argumento del final o simplemente pasado.</target>
        </trans-unit>
        <trans-unit id="d32965fa894336b076cce4f85e7e48d5894d1d82" translate="yes" xml:space="preserve">
          <source>If periods is none, generated index will extend to first conforming time on or just past end argument</source>
          <target state="translated">Si los períodos no son ninguno,el índice generado se extenderá al primer tiempo de conformidad con el argumento del final o justo después de él.</target>
        </trans-unit>
        <trans-unit id="9dd9779620b8974ba66618f8372fc57e4f8ce556" translate="yes" xml:space="preserve">
          <source>If provided, this parameter will override values (default or not) for the following parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f980c4e25c4e9da56d7674ad6dffd737c076ee" translate="yes" xml:space="preserve">
          <source>If provided, this parameter will override values (default or not) for the following parameters: &lt;code&gt;delimiter&lt;/code&gt;, &lt;code&gt;doublequote&lt;/code&gt;, &lt;code&gt;escapechar&lt;/code&gt;, &lt;code&gt;skipinitialspace&lt;/code&gt;, &lt;code&gt;quotechar&lt;/code&gt;, and &lt;code&gt;quoting&lt;/code&gt;. If it is necessary to override values, a ParserWarning will be issued. See &lt;a href=&quot;https://docs.python.org/3/library/csv.html#csv.Dialect&quot;&gt;&lt;code&gt;csv.Dialect&lt;/code&gt;&lt;/a&gt; documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9cd18b4c26564dea3305689f1e4726a3a1fb03" translate="yes" xml:space="preserve">
          <source>If provided, this parameter will override values (default or not) for the following parameters: &lt;code&gt;delimiter&lt;/code&gt;, &lt;code&gt;doublequote&lt;/code&gt;, &lt;code&gt;escapechar&lt;/code&gt;, &lt;code&gt;skipinitialspace&lt;/code&gt;, &lt;code&gt;quotechar&lt;/code&gt;, and &lt;code&gt;quoting&lt;/code&gt;. If it is necessary to override values, a ParserWarning will be issued. See csv.Dialect documentation for more details.</source>
          <target state="translated">Si se proporciona, este par&amp;aacute;metro anular&amp;aacute; los valores (predeterminados o no) para los siguientes par&amp;aacute;metros: &lt;code&gt;delimiter&lt;/code&gt; , &lt;code&gt;doublequote&lt;/code&gt; , &lt;code&gt;escapechar&lt;/code&gt; , &lt;code&gt;skipinitialspace&lt;/code&gt; , &lt;code&gt;quotechar&lt;/code&gt; y &lt;code&gt;quoting&lt;/code&gt; . Si es necesario anular los valores, se emitir&amp;aacute; un ParserWarning. Consulte la documentaci&amp;oacute;n de csv.Dialect para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="a05339991167e0e6c730f03164ad020504ffa9b3" translate="yes" xml:space="preserve">
          <source>If resulting index has only 1 level left, the result will be of Index type, not MultiIndex.</source>
          <target state="translated">Si al índice resultante sólo le queda un nivel,el resultado será de tipo índice,no multiíndice.</target>
        </trans-unit>
        <trans-unit id="1d17d6d3193f2c431cd73525c42fc1232029c3d2" translate="yes" xml:space="preserve">
          <source>If returning an ExtensionArray, then</source>
          <target state="translated">Si devolviendo un ExtensionArray,entonces</target>
        </trans-unit>
        <trans-unit id="3e064bce4d5d267a12f81f957574e39d35faa28b" translate="yes" xml:space="preserve">
          <source>If set to None, the number of items to be printed is unlimited. [default: 100] [currently: 100]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881d4fbdc1e7a8b7ba5ab81f1479cb45ced59e14" translate="yes" xml:space="preserve">
          <source>If set to None, the number of items to be printed is unlimited. [default: 100] [currently: 100]display.memory_usage : bool, string or None This specifies if the memory usage of a DataFrame should be displayed when df.info() is called. Valid values True,False,&amp;rsquo;deep&amp;rsquo; [default: True] [currently: True]display.min_rows : int The numbers of rows to show in a truncated view (when &lt;code&gt;max_rows&lt;/code&gt; is exceeded). Ignored when &lt;code&gt;max_rows&lt;/code&gt; is set to None or 0. When set to None, follows the value of &lt;code&gt;max_rows&lt;/code&gt;. [default: 10] [currently: 10]display.multi_sparse : boolean &amp;ldquo;sparsify&amp;rdquo; MultiIndex display (don&amp;rsquo;t display repeated elements in outer levels within groups) [default: True] [currently: True]display.notebook_repr_html : boolean When True, IPython notebook will use html representation for pandas objects (if it is available). [default: True] [currently: True]display.pprint_nest_depth : int Controls the number of nested levels to process when pretty-printing [default: 3] [currently: 3]display.precision : int Floating point output precision (number of significant digits). This is only a suggestion [default: 6] [currently: 6]display.show_dimensions : boolean or &amp;lsquo;truncate&amp;rsquo; Whether to print out dimensions at the end of DataFrame repr. If &amp;lsquo;truncate&amp;rsquo; is specified, only print out the dimensions if the frame is truncated (e.g. not display all rows and/or columns) [default: truncate] [currently: truncate]display.unicode.ambiguous_as_wide : boolean Whether to use the Unicode East Asian Width to calculate the display text width. Enabling this may affect to the performance (default: False) [default: False] [currently: False]display.unicode.east_asian_width : boolean Whether to use the Unicode East Asian Width to calculate the display text width. Enabling this may affect to the performance (default: False) [default: False] [currently: False]display.width : int Width of the display in characters. In case python/IPython is running in a terminal this can be set to None and pandas will correctly auto-detect the width. Note that the IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to correctly detect the width. [default: 80] [currently: 80]io.excel.ods.reader : string The default Excel reader engine for &amp;lsquo;ods&amp;rsquo; files. Available options: auto, odf. [default: auto] [currently: auto]io.excel.xls.reader : string The default Excel reader engine for &amp;lsquo;xls&amp;rsquo; files. Available options: auto, xlrd. [default: auto] [currently: auto]io.excel.xls.writer : string The default Excel writer engine for &amp;lsquo;xls&amp;rsquo; files. Available options: auto, xlwt. [default: auto] [currently: auto]io.excel.xlsm.reader : string The default Excel reader engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: auto, xlrd, openpyxl. [default: auto] [currently: auto]io.excel.xlsm.writer : string The default Excel writer engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: auto, openpyxl. [default: auto] [currently: auto]io.excel.xlsx.reader : string The default Excel reader engine for &amp;lsquo;xlsx&amp;rsquo; files. Available options: auto, xlrd, openpyxl. [default: auto] [currently: auto]io.excel.xlsx.writer : string The default Excel writer engine for &amp;lsquo;xlsx&amp;rsquo; files. Available options: auto, openpyxl, xlsxwriter. [default: auto] [currently: auto]io.hdf.default_format : format default format writing format, if None, then put will default to &amp;lsquo;fixed&amp;rsquo; and append will default to &amp;lsquo;table&amp;rsquo; [default: None] [currently: None]io.hdf.dropna_table : boolean drop ALL nan rows when appending to a table [default: False] [currently: False]io.parquet.engine : string The default parquet reader/writer engine. Available options: &amp;lsquo;auto&amp;rsquo;, &amp;lsquo;pyarrow&amp;rsquo;, &amp;lsquo;fastparquet&amp;rsquo;, the default is &amp;lsquo;auto&amp;rsquo; [default: auto] [currently: auto]mode.chained_assignment : string Raise an exception, warn, or no action if trying to use chained assignment, The default is warn [default: warn] [currently: warn]mode.sim_interactive : boolean Whether to simulate interactive mode for purposes of testing [default: False] [currently: False]mode.use_inf_as_na : boolean True means treat None, NaN, INF, -INF as NA (old way), False means None and NaN are null, but INF, -INF are not NA (new way). [default: False] [currently: False]mode.use_inf_as_null : boolean use_inf_as_null had been deprecated and will be removed in a future version. Use &lt;code&gt;use_inf_as_na&lt;/code&gt; instead. [default: False] [currently: False] (Deprecated, use &lt;code&gt;mode.use_inf_as_na&lt;/code&gt; instead.)plotting.backend : str The plotting backend to use. The default value is &amp;ldquo;matplotlib&amp;rdquo;, the backend provided with pandas. Other backends can be specified by prodiving the name of the module that implements the backend. [default: matplotlib] [currently: matplotlib]plotting.matplotlib.register_converters : bool Whether to register converters with matplotlib&amp;rsquo;s units registry for dates, times, datetimes, and Periods. Toggling to False will remove the converters, restoring any converters that pandas overwrote. [default: True] [currently: True]</source>
          <target state="translated">Si se establece en Ninguno, el n&amp;uacute;mero de elementos a imprimir es ilimitado. [predeterminado: 100] [actualmente: 100] display.memory_usage: bool, string o None Esto especifica si el uso de memoria de un DataFrame debe mostrarse cuando se llama a df.info (). Valores v&amp;aacute;lidos Verdadero, Falso, 'profundo' [predeterminado: Verdadero] [actualmente: Verdadero] display.min_rows: int El n&amp;uacute;mero de filas para mostrar en una vista truncada (cuando se excede &lt;code&gt;max_rows&lt;/code&gt; ). Se ignora cuando &lt;code&gt;max_rows&lt;/code&gt; se establece en None o 0. Cuando se establece en None, sigue el valor de &lt;code&gt;max_rows&lt;/code&gt; . [predeterminado: 10] [actualmente: 10] display.multi_sparse: booleano &quot;sparsify&quot; Pantalla MultiIndex (no muestra elementos repetidos en niveles externos dentro de los grupos) [predeterminado: True] [actualmente: True] display.notebook_repr_html: boolean Cuando es verdadero , El cuaderno de IPython utilizar&amp;aacute; la representaci&amp;oacute;n html para los objetos pandas (si est&amp;aacute; disponible). [predeterminado: Verdadero] [actualmente: Verdadero] display.pprint_nest_depth: int Controla el n&amp;uacute;mero de niveles anidados que se procesan cuando se imprime bastante [predeterminado: 3] [actualmente: 3] display.precision: int Precisi&amp;oacute;n de salida de punto flotante (n&amp;uacute;mero de d&amp;iacute;gitos). Esto es solo una sugerencia [predeterminado: 6] [actualmente: 6] display.show_dimensions: boolean o 'truncar' Ya sea que se impriman las dimensiones al final de DataFrame repr. Si se especifica 'truncar', solo imprima las dimensiones si el marco est&amp;aacute; truncado (p. Ej.no mostrar todas las filas y / o columnas) [predeterminado: truncar] [actualmente: truncar] display.unicode.ambiguous_as_wide: booleano Si se utilizar&amp;aacute; el ancho Unicode de Asia oriental para calcular el ancho del texto de visualizaci&amp;oacute;n. Habilitar esto puede afectar al rendimiento (predeterminado: Falso) [predeterminado: Falso] [actualmente: Falso] display.unicode.east_asian_width: boolean Si se utilizar&amp;aacute; el ancho Unicode de Asia oriental para calcular el ancho del texto de visualizaci&amp;oacute;n. Habilitar esto puede afectar al rendimiento (predeterminado: Falso) [predeterminado: Falso] [actualmente: Falso] display.width: int Ancho de la pantalla en caracteres. En caso de que python / IPython se est&amp;eacute; ejecutando en una terminal, esto se puede configurar en Ninguno y los pandas detectar&amp;aacute;n autom&amp;aacute;ticamente el ancho correctamente. Tenga en cuenta que el cuaderno IPython, IPython qtconsole o IDLE no se ejecutan en una terminal y, por lo tanto, no es posible detectar correctamente el ancho. [defecto:80] [actualmente: 80] io.excel.ods.reader: string El motor de lectura de Excel predeterminado para archivos 'ods'. Opciones disponibles: auto, odf. [predeterminado: auto] [actualmente: auto] io.excel.xls.reader: string El motor de lectura de Excel predeterminado para archivos 'xls'. Opciones disponibles: auto, xlrd. [predeterminado: auto] [actualmente: auto] io.excel.xls.writer: string El motor de escritura de Excel predeterminado para archivos 'xls'. Opciones disponibles: auto, xlwt. [predeterminado: auto] [actualmente: auto] io.excel.xlsm.reader: string El motor de lectura de Excel predeterminado para archivos 'xlsm'. Opciones disponibles: auto, xlrd, openpyxl. [predeterminado: auto] [actualmente: auto] io.excel.xlsm.writer: string El motor de escritura de Excel predeterminado para archivos 'xlsm'. Opciones disponibles: auto, openpyxl. [predeterminado: auto] [actualmente: auto] io.excel.xlsx.reader: string El motor de lectura de Excel predeterminado para archivos 'xlsx'. Opciones disponibles: auto, xlrd,openpyxl. [predeterminado: auto] [actualmente: auto] io.excel.xlsx.writer: string El motor de escritura de Excel predeterminado para archivos 'xlsx'. Opciones disponibles: auto, openpyxl, xlsxwriter. [predeterminado: auto] [actualmente: auto] io.hdf.default_format: formato de formato de escritura de formato predeterminado, si es Ninguno, entonces el valor predeterminado ser&amp;aacute; 'fijo' y el agregado ser&amp;aacute; predeterminado en 'tabla' [predeterminado: Ninguno] [actualmente: Ninguno ] io.hdf.dropna_table: booleano suelta TODAS las nan filas al agregarlas a una tabla [predeterminado: falso] [actualmente: falso] io.parquet.engine: string El motor de lectura / escritura de parquet predeterminado. Opciones disponibles: 'auto', 'pyarrow', 'fastparquet', el valor predeterminado es 'auto' [predeterminado: auto] [actualmente: auto] mode.chained_assignment: string Generar una excepci&amp;oacute;n, advertir o no realizar ninguna acci&amp;oacute;n si se intenta usar encadenado asignaci&amp;oacute;n, el valor predeterminado es advertir [predeterminado: advertir] [actualmente: advertir] mode.sim_interactive:booleano Ya sea para simular el modo interactivo para prop&amp;oacute;sitos de prueba [predeterminado: Falso] [actualmente: Falso] mode.use_inf_as_na: booleano Verdadero significa tratar Ninguno, NaN, INF, -INF como NA (m&amp;eacute;todo antiguo), Falso significa Ninguno y NaN son nulos , pero INF, -INF no son NA (nueva forma). [predeterminado: falso] [actualmente: falso] mode.use_inf_as_null: boolean use_inf_as_null hab&amp;iacute;a quedado obsoleto y se eliminar&amp;aacute; en una versi&amp;oacute;n futura. Utilizar &lt;code&gt;use_inf_as_na&lt;/code&gt; en su lugar. [predeterminado: falso] [actualmente: falso] (En &lt;code&gt;mode.use_inf_as_na&lt;/code&gt; , use mode.use_inf_as_na en su lugar.) plotting.backend: str El backend de trazado que se va a usar. El valor predeterminado es &quot;matplotlib&quot;, el backend provisto con pandas. Se pueden especificar otros backend proporcionando el nombre del m&amp;oacute;dulo que implementa el backend. [predeterminado: matplotlib] [actualmente: matplotlib] plotting.matplotlib.register_converters: bool Si se registran convertidores con el registro de unidades de matplotlib para fechas, horas, fechas y per&amp;iacute;odos. Cambiar a Falso eliminar&amp;aacute; los convertidores, restaurando cualquier convertidor que los pandas sobrescribieran. [predeterminado: verdadero] [actualmente: verdadero]</target>
        </trans-unit>
        <trans-unit id="4983fff342fff2155fda50539177d2d395cc41ca" translate="yes" xml:space="preserve">
          <source>If set to a float value, all float values smaller then the given threshold will be displayed as exactly 0 by repr and friends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae05e640370b98c99c2eb61bf5fe03e0f6a770c7" translate="yes" xml:space="preserve">
          <source>If set, limit the maximum number of rows to fetch from the query results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0453700b5f3a81a6b68576ac4ef69d3f6c097f" translate="yes" xml:space="preserve">
          <source>If set, use the &lt;a href=&quot;https://tqdm.github.io/&quot;&gt;tqdm&lt;/a&gt; library to display a progress bar while the data downloads. Install the &lt;code&gt;tqdm&lt;/code&gt; package to use this feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa12ba58c2be2f71104408a510d4489d9b0c6ffa" translate="yes" xml:space="preserve">
          <source>If specified changes the x-axis label size</source>
          <target state="translated">Si se especifica cambia el tamaño de la etiqueta del eje x</target>
        </trans-unit>
        <trans-unit id="97863624dbef3656142375cfc414d8c6db270d6b" translate="yes" xml:space="preserve">
          <source>If specified changes the x-axis label size.</source>
          <target state="translated">Si se especifica,cambia el tamaño de la etiqueta del eje x.</target>
        </trans-unit>
        <trans-unit id="9a7873740ccf0410b3fb0bea93346ff13ec92e92" translate="yes" xml:space="preserve">
          <source>If specified changes the y-axis label size</source>
          <target state="translated">Si se especifica cambia el tamaño de la etiqueta del eje y</target>
        </trans-unit>
        <trans-unit id="581f8ddceda8e96b28aea9467091a054fc8fcba4" translate="yes" xml:space="preserve">
          <source>If specified changes the y-axis label size.</source>
          <target state="translated">Si se especifica,cambia el tamaño de la etiqueta del eje Y.</target>
        </trans-unit>
        <trans-unit id="fc3648b96e279d94f92a6ee0971122e6704390a3" translate="yes" xml:space="preserve">
          <source>If specified only options matching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7820aaef54858d9fe6f835280f13f8d7b53a28bd" translate="yes" xml:space="preserve">
          <source>If specified only options matching &lt;code&gt;prefix*&lt;/code&gt; will be reset. Note: partial matches are supported for convenience, but unless you use the full option name (e.g. x.y.z.option_name), your code may break in future versions if new options with similar names are introduced.</source>
          <target state="translated">Si se especifica, solo se restablecer&amp;aacute;n las opciones que coincidan con el &lt;code&gt;prefix*&lt;/code&gt; . Nota: las coincidencias parciales son compatibles por conveniencia, pero a menos que use el nombre completo de la opci&amp;oacute;n (egxyzoption_name), su c&amp;oacute;digo puede fallar en versiones futuras si se introducen nuevas opciones con nombres similares.</target>
        </trans-unit>
        <trans-unit id="fbfd3a88eab2f247413e17f672c68ad4e5e49adc" translate="yes" xml:space="preserve">
          <source>If specified, &lt;strong&gt;fill&lt;/strong&gt; data for missing labels using logic (highly relevant to working with time series data)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2fd14b30360e01bd1925a87fecdb829dae8c45" translate="yes" xml:space="preserve">
          <source>If specified, checks if merge is of specified type.</source>
          <target state="translated">Si se especifica,comprueba si la fusión es del tipo especificado.</target>
        </trans-unit>
        <trans-unit id="72c2f9cefac58e113fc2c842ab3415610081df06" translate="yes" xml:space="preserve">
          <source>If specified, requires</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195f4d58de033a32ef9e0ed103f9771ba227ede5" translate="yes" xml:space="preserve">
          <source>If specified, requires &lt;code&gt;values&lt;/code&gt; be specified as well.</source>
          <target state="translated">Si se especifica, tambi&amp;eacute;n se requieren &lt;code&gt;values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8ff89eb07dddd54f2f0304a34009cfe5e81e653" translate="yes" xml:space="preserve">
          <source>If specified, return an iterator where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b212e57ff80a7164ca948bedf3a2c591bca4f5" translate="yes" xml:space="preserve">
          <source>If specified, return an iterator where &lt;code&gt;chunksize&lt;/code&gt; is the number of rows to include in each chunk.</source>
          <target state="translated">Si se especifica, devuelve un iterador donde &lt;code&gt;chunksize&lt;/code&gt; es el n&amp;uacute;mero de filas que se incluir&amp;aacute;n en cada fragmento.</target>
        </trans-unit>
        <trans-unit id="0082373421092da175dee8a9b93a4ccc4f6ac2a4" translate="yes" xml:space="preserve">
          <source>If specified, returns an iterator where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78439b54e5e60a975149f48cea5f22c188ad305b" translate="yes" xml:space="preserve">
          <source>If specified, returns an iterator where &lt;code&gt;chunksize&lt;/code&gt; is the number of rows to include in each chunk.</source>
          <target state="translated">Si se especifica, devuelve un iterador donde &lt;code&gt;chunksize&lt;/code&gt; es el n&amp;uacute;mero de filas que se incluir&amp;aacute;n en cada fragmento.</target>
        </trans-unit>
        <trans-unit id="999348edd253a275c024b1092f6c830ad7d41693" translate="yes" xml:space="preserve">
          <source>If str, it will be considered as a path to a file. Info will be written to that file in JSON format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce81a105f24afb5e0f2c0a1d42b5a9e99140d42" translate="yes" xml:space="preserve">
          <source>If str, represents compression mode. If dict, value at &amp;lsquo;method&amp;rsquo; is the compression mode. Compression mode may be any of the following possible values: {&amp;lsquo;infer&amp;rsquo;, &amp;lsquo;gzip&amp;rsquo;, &amp;lsquo;bz2&amp;rsquo;, &amp;lsquo;zip&amp;rsquo;, &amp;lsquo;xz&amp;rsquo;, None}. If compression mode is &amp;lsquo;infer&amp;rsquo; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657e48eb3a4d68a611327f580edbd21c7f670eb9" translate="yes" xml:space="preserve">
          <source>If str, the name of the column in the DataFrame representing the times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04bcdac7e76a787e1fbea8ae01f3869fac3ea6f8" translate="yes" xml:space="preserve">
          <source>If str, then indicates comma separated list of Excel column letters and column ranges (e.g. &amp;ldquo;A:E&amp;rdquo; or &amp;ldquo;A,C,E:F&amp;rdquo;). Ranges are inclusive of both sides.</source>
          <target state="translated">Si es str, indica una lista separada por comas de letras y rangos de columnas de Excel (por ejemplo, &amp;ldquo;A: E&amp;rdquo; o &amp;ldquo;A, C, E: F&amp;rdquo;). Los rangos incluyen ambos lados.</target>
        </trans-unit>
        <trans-unit id="9da6ca18cdc6eec7c4db6f8861692e993483053b" translate="yes" xml:space="preserve">
          <source>If such a function works, please file a bug at &lt;a href=&quot;https://github.com/pandas-dev/pandas&quot;&gt;https://github.com/pandas-dev/pandas&lt;/a&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00eda6030f8870181f3ae042945f9f88a8227cb5" translate="yes" xml:space="preserve">
          <source>If supplying a list, each individual table_style should be a dictionary with &lt;code&gt;selector&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt; keys. &lt;code&gt;selector&lt;/code&gt; should be a CSS selector that the style will be applied to (automatically prefixed by the table&amp;rsquo;s UUID) and &lt;code&gt;props&lt;/code&gt; should be a list of tuples with &lt;code&gt;(attribute, value)&lt;/code&gt;. If supplying a dict, the dict keys should correspond to column names or index values, depending upon the specified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e8edc6bf86da535a40f6cb6e96a6e8c7af0dcb" translate="yes" xml:space="preserve">
          <source>If table exists raise pandas_gbq.gbq.TableCreationError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a7f4d474e4d7426374eb27e2b8239df04809bb" translate="yes" xml:space="preserve">
          <source>If table exists, do nothing.</source>
          <target state="translated">Si la mesa existe,no hagas nada.</target>
        </trans-unit>
        <trans-unit id="2ca3b25179b041d34301bc35b333ae308c33e09c" translate="yes" xml:space="preserve">
          <source>If table exists, drop it, recreate it, and insert data.</source>
          <target state="translated">Si la tabla existe,suéltela,vuelva a crearla e inserte los datos.</target>
        </trans-unit>
        <trans-unit id="8c60747c3d8c8c498c4f7ba4c804063996419ee9" translate="yes" xml:space="preserve">
          <source>If table exists, insert data. Create if does not exist.</source>
          <target state="translated">Si la tabla existe,inserte los datos.Crear si no existe.</target>
        </trans-unit>
        <trans-unit id="2042ba3d5eaacecb710b9e13fa4e5db8076a696a" translate="yes" xml:space="preserve">
          <source>If that condition is not satisfied, a join with two multi-indexes can be done using the following code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7806b6b94836ae0ac10b4b506a0d107772af3b21" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'numba'&lt;/code&gt; engine is chosen, the function must be a user defined function with &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; as the first and second arguments respectively in the function signature. Each group&amp;rsquo;s index will be passed to the user defined function and optionally available for use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbdf454f40b0c45a027c499e77bdb6113f2b6c7d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Categorical&lt;/code&gt; is not ordered, &lt;a href=&quot;../reference/api/pandas.series.min#pandas.Series.min&quot;&gt;&lt;code&gt;Series.min()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.series.max#pandas.Series.max&quot;&gt;&lt;code&gt;Series.max()&lt;/code&gt;&lt;/a&gt; will raise &lt;code&gt;TypeError&lt;/code&gt;. Numeric operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and operations based on them (e.g. &lt;a href=&quot;../reference/api/pandas.series.median#pandas.Series.median&quot;&gt;&lt;code&gt;Series.median()&lt;/code&gt;&lt;/a&gt;, which would need to compute the mean between two values if the length of an array is even) do not work and raise a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3f807d7903fe4db8bb66d5321128e42d669a89" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MultiIndex&lt;/code&gt; levels names are &lt;code&gt;None&lt;/code&gt;, the levels are automatically made available via the &lt;code&gt;level_n&lt;/code&gt; keyword with &lt;code&gt;n&lt;/code&gt; the level of the &lt;code&gt;MultiIndex&lt;/code&gt; you want to select from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c94091f3e6317915c8bf08e4e19200411544ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;bins&lt;/code&gt; keyword is an &lt;code&gt;IntervalIndex&lt;/code&gt;, then these will be used to bin the passed data.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6fc9dc69af6ac9bd02208d524cc26f9590d304" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;bins&lt;/code&gt; keyword is an integer, then equal-width bins are formed. Alternatively we can specify custom bin-edges:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2283dad6d1e4f0ad9f7a475c923728b16127b882" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;comment&lt;/code&gt; parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="398ce981deb02bcf84891cf39753b3a46345bf90" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;join&lt;/code&gt; keyword is not passed, the method &lt;a href=&quot;../reference/api/pandas.series.str.cat#pandas.Series.str.cat&quot;&gt;&lt;code&gt;cat()&lt;/code&gt;&lt;/a&gt; will currently fall back to the behavior before version 0.23.0 (i.e. no alignment), but a &lt;code&gt;FutureWarning&lt;/code&gt; will be raised if any of the involved indexes differ, since this default will change to &lt;code&gt;join='left'&lt;/code&gt; in a future version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb65b84a0ed9ca7d9ee485a9567cc369b8c9fcac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;values&lt;/code&gt; argument is omitted, and the input &lt;code&gt;DataFrame&lt;/code&gt; has more than one column of values which are not used as column or index inputs to &lt;code&gt;pivot&lt;/code&gt;, then the resulting &amp;ldquo;pivoted&amp;rdquo; &lt;code&gt;DataFrame&lt;/code&gt; will have &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;hierarchical columns&lt;/a&gt; whose topmost level indicates the respective value column:</source>
          <target state="translated">Si se omite el argumento de &lt;code&gt;values&lt;/code&gt; y el &lt;code&gt;DataFrame&lt;/code&gt; de entrada tiene m&amp;aacute;s de una columna de valores que no se utilizan como entradas de &amp;iacute;ndice o columna para &lt;code&gt;pivot&lt;/code&gt; ar , entonces el &lt;code&gt;DataFrame&lt;/code&gt; &quot;pivotado&quot; resultante tendr&amp;aacute; &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;columnas jer&amp;aacute;rquicas&lt;/a&gt; cuyo nivel superior indica la columna de valor respectiva:</target>
        </trans-unit>
        <trans-unit id="fa8a2744eb24887cc6fb10a04b4424c9fbb9186e" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backward with a timedelta object or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6472e80c2a9dc53f51fd601d89084b2d1b47e172" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ecf87fc244588bee56119972b559fcabe156fa" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt;. &amp;gt;&amp;gt;&amp;gt; s = pd.Series(range(2), index=pd.DatetimeIndex([ &amp;hellip; &amp;lsquo;2015-03-29 02:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2015-03-29 03:30:00&amp;rsquo;])) &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_forward&amp;rsquo;) 2015-03-29 03:00:00+02:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_backward&amp;rsquo;) 2015-03-29 01:59:59.999999999+01:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=pd.Timedelta(&amp;lsquo;1H&amp;rsquo;)) 2015-03-29 03:30:00+02:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64</source>
          <target state="translated">Si la transici&amp;oacute;n del horario de verano provoca tiempos inexistentes, puede cambiar estas fechas hacia adelante o hacia atr&amp;aacute;s con un objeto timedelta o &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; o &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt; . &amp;gt;&amp;gt;&amp;gt; s = pd.Series (rango (2), &amp;iacute;ndice = pd.DatetimeIndex ([&amp;hellip; '2015-03-29 02:30:00',&amp;hellip; '2015-03-29 03:30:00']) ) &amp;gt;&amp;gt;&amp;gt; s.tz_localize ('Europa / Varsovia', inexistente = 'shift_forward') 2015-03-29 03: 00: 00 + 02: 00 0 2015-03-29 03: 30: 00 + 02: 00 1 dtype: int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize ('Europa / Varsovia', inexistente = 'shift_backward') 2015-03-29 01: 59: 59.999999999 + 01: 00 0 2015-03-29 03: 30: 00 + 02: 00 1 dtype: int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize ('Europa / Varsovia', inexistente = pd.Timedelta ('1H')) 2015-03-29 03: 30: 00 + 02: 00 0 2015-03-29 03 : 30: 00 + 02: 00 1 dtipo: int64</target>
        </trans-unit>
        <trans-unit id="1efef3e25f01393c1708b5d04424ad93e6acad6e" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt;. &amp;gt;&amp;gt;&amp;gt; s = pd.to_datetime(pd.Series([&amp;lsquo;2015-03-29 02:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2015-03-29 03:30:00&amp;rsquo;])) &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_forward&amp;rsquo;) 0 2015-03-29 03:00:00+02:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_backward&amp;rsquo;) 0 2015-03-29 01:59:59.999999999+01:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=pd.Timedelta(&amp;lsquo;1H&amp;rsquo;)) 0 2015-03-29 03:30:00+02:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;]</source>
          <target state="translated">Si la transici&amp;oacute;n del horario de verano provoca tiempos inexistentes, puede cambiar estas fechas hacia adelante o hacia atr&amp;aacute;s con un objeto timedelta o &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; o &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt; . &amp;gt;&amp;gt;&amp;gt; s = pd.to_datetime (pd.Series (['2015-03-29 02:30:00',&amp;hellip; '2015-03-29 03:30:00'])) &amp;gt;&amp;gt;&amp;gt; s.dt. tz_localize ('Europa / Varsovia', inexistente = 'shift_forward') 0 2015-03-29 03: 00: 00 + 02: 00 1 2015-03-29 03: 30: 00 + 02: 00 dtype: datetime64 [ns, 'Europa / Varsovia'] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize ('Europa / Varsovia', inexistente = 'shift_backward') 0 2015-03-29 01: 59: 59.999999999 + 01: 00 1 2015-03-29 03: 30: 00 + 02: 00 dtype: datetime64 [ns, 'Europa / Varsovia'] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize ('Europa / Varsovia', inexistente = pd.Timedelta ('1H')) 0 2015-03- 29 03: 30: 00 + 02: 00 1 2015-03-29 03: 30: 00 + 02: 00 dtype: datetime64 [ns, 'Europa / Varsovia']</target>
        </trans-unit>
        <trans-unit id="0cded44943bc29f11107a3fa48812fe3fd18029d" translate="yes" xml:space="preserve">
          <source>If the DataFrame index has no label then the recarray field name is set to &amp;lsquo;index&amp;rsquo;. If the index has a label then this is used as the field name:</source>
          <target state="translated">Si el &amp;iacute;ndice DataFrame no tiene etiqueta, entonces el nombre del campo recarray se establece en '&amp;iacute;ndice'. Si el &amp;iacute;ndice tiene una etiqueta, esta se utiliza como nombre de campo:</target>
        </trans-unit>
        <trans-unit id="d214ff5505dcc3df58ad0b05017eb7e67d620183" translate="yes" xml:space="preserve">
          <source>If the Datetime Array/Index is tz-aware and tz is not None.</source>
          <target state="translated">Si la matriz/índice de fecha y hora es tz-aware y tz no es None.</target>
        </trans-unit>
        <trans-unit id="b9d9791f0508f684363d699b80bee52d000f007a" translate="yes" xml:space="preserve">
          <source>If the Index is a MultiIndex, drop the value when any or all levels are NaN.</source>
          <target state="translated">Si el índice es un Multi-índice,baja el valor cuando alguno o todos los niveles son NaN.</target>
        </trans-unit>
        <trans-unit id="be05eaa0dbbfb873520e230604c6d5204e61826b" translate="yes" xml:space="preserve">
          <source>If the Index objects are incompatible, both Index objects will be cast to dtype(&amp;lsquo;object&amp;rsquo;) first.</source>
          <target state="translated">Si los objetos de &amp;iacute;ndice son incompatibles, ambos objetos de &amp;iacute;ndice se convertir&amp;aacute;n primero en dtype ('objeto').</target>
        </trans-unit>
        <trans-unit id="33e611dc7e8a5693ba6d67785cded9a86565fe9b" translate="yes" xml:space="preserve">
          <source>If the JSON serializer cannot handle the container contents directly it will fall back in the following manner:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40eecad766d670f6843c3a0267a49f5717901b35" translate="yes" xml:space="preserve">
          <source>If the MultiIndex has names specified, these can be passed instead of the level number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6155bdd87909d66e388cdbb2e09aeed48e81654e" translate="yes" xml:space="preserve">
          <source>If the Pearson correlation is not well defined return &amp;lsquo;NaN&amp;rsquo;.</source>
          <target state="translated">Si la correlaci&amp;oacute;n de Pearson no est&amp;aacute; bien definida, devuelva 'NaN'.</target>
        </trans-unit>
        <trans-unit id="5ef45e6ec64f5bd071dc24f8d1e69cc1e5cd8b83" translate="yes" xml:space="preserve">
          <source>If the Pearson correlation is not well defined, then &amp;lsquo;NaN&amp;rsquo; is returned.</source>
          <target state="translated">Si la correlaci&amp;oacute;n de Pearson no est&amp;aacute; bien definida, se devuelve 'NaN'.</target>
        </trans-unit>
        <trans-unit id="93c56163ba997d495339f68cf9109d1071720ba6" translate="yes" xml:space="preserve">
          <source>If the Series is empty.</source>
          <target state="translated">Si la Serie está vacía.</target>
        </trans-unit>
        <trans-unit id="a8f2ab2c508af24c8a42b9be04bbb0ee02647fda" translate="yes" xml:space="preserve">
          <source>If the Series is of dtype &lt;code&gt;CategoricalDtype&lt;/code&gt;, &lt;code&gt;Series.cat&lt;/code&gt; can be used to change the categorical data. See &lt;a href=&quot;series#api-series-cat&quot;&gt;Categorical accessor&lt;/a&gt; for more.</source>
          <target state="translated">Si la serie es de dtype &lt;code&gt;CategoricalDtype&lt;/code&gt; , se puede usar &lt;code&gt;Series.cat&lt;/code&gt; para cambiar los datos categ&amp;oacute;ricos. Consulte &lt;a href=&quot;series#api-series-cat&quot;&gt;Accesorio categ&amp;oacute;rico&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5c83fd268af8fe1a16e48c3a1ab2791b08629b1d" translate="yes" xml:space="preserve">
          <source>If the TimeSeries is tz-aware and tz is not None.</source>
          <target state="translated">Si la serie temporal es tz-aware y tz no es None.</target>
        </trans-unit>
        <trans-unit id="166773b46d18bb469c09bcac6b289439b56e7d14" translate="yes" xml:space="preserve">
          <source>If the Timestamp is tz-aware and tz is not None.</source>
          <target state="translated">Si la marca de tiempo es tz-aware y tz no es None.</target>
        </trans-unit>
        <trans-unit id="ed9393b2d06f7ca7196058734584b10915f7b7ef" translate="yes" xml:space="preserve">
          <source>If the applied function returns a &lt;code&gt;Series&lt;/code&gt;, the final output is a &lt;code&gt;DataFrame&lt;/code&gt;. The columns match the index of the &lt;code&gt;Series&lt;/code&gt; returned by the applied function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c554cfb74ad16eb30cb8acf707f73662f04504" translate="yes" xml:space="preserve">
          <source>If the applied function returns any other type, the final output is a &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57492f8aeb84c4c11084b50073db14b29faccfda" translate="yes" xml:space="preserve">
          <source>If the axis is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31df692ed74865cf46655ed034fdaf4f052a8d85" translate="yes" xml:space="preserve">
          <source>If the axis is a &lt;code&gt;MultiIndex&lt;/code&gt; (hierarchical), count along a particular &lt;code&gt;level&lt;/code&gt;, collapsing into a &lt;code&gt;DataFrame&lt;/code&gt;. A &lt;code&gt;str&lt;/code&gt; specifies the level name.</source>
          <target state="translated">Si el eje es un &lt;code&gt;MultiIndex&lt;/code&gt; (jer&amp;aacute;rquico), cuente a lo largo de un &lt;code&gt;level&lt;/code&gt; particular , colapsando en un &lt;code&gt;DataFrame&lt;/code&gt; . Una &lt;code&gt;str&lt;/code&gt; especifica el nombre del nivel.</target>
        </trans-unit>
        <trans-unit id="cb176b6dcd2c00fd60079bc8af02e9483c7b2358" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a Series</source>
          <target state="translated">Si el eje es un MultiÍndice (jerárquico),cuenta a lo largo de un nivel particular,colapsando en una Serie</target>
        </trans-unit>
        <trans-unit id="769c2b618c37d94ee04a6ed2f86ca3697aa771ee" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a Series.</source>
          <target state="translated">Si el eje es un MultiÍndice (jerárquico),cuenta a lo largo de un nivel particular,colapsando en una Serie.</target>
        </trans-unit>
        <trans-unit id="5c874bca9b0f22f8a1cb6ace88f3bf9ba4eb54d3" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar</source>
          <target state="translated">Si el eje es un Multi-Index (jerárquico),cuenta a lo largo de un nivel particular,colapsando en un escalar</target>
        </trans-unit>
        <trans-unit id="9cfa60e80d738cd1ce2e3e1ca125d513cb5b51b9" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar.</source>
          <target state="translated">Si el eje es un Multi-Index (jerárquico),cuenta a lo largo de un nivel particular,colapsando en un escalar.</target>
        </trans-unit>
        <trans-unit id="acc1c61e1d22ff923e52dd41f329881f26c8cde0" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a smaller Series.</source>
          <target state="translated">Si el eje es un MultiÍndice (jerárquico),cuenta a lo largo de un nivel particular,colapsando en una Serie más pequeña.</target>
        </trans-unit>
        <trans-unit id="4bde74fe49512814aa9175078e647d0e2833dc88" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a {name1}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fb26f3d36635371a47ec0c1a6253a35906fe24" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), group by a particular level or levels.</source>
          <target state="translated">Si el eje es un MultiÍndice (jerárquico),agrupar por un nivel o niveles particulares.</target>
        </trans-unit>
        <trans-unit id="b5361e8b12cba57093a4bca7b1ba4eecbc07f527" translate="yes" xml:space="preserve">
          <source>If the axis is tz-naive.</source>
          <target state="translated">Si el eje es tz-nave.</target>
        </trans-unit>
        <trans-unit id="b60526c69422bc15a4ea3ceaf37ce27ebe587a8b" translate="yes" xml:space="preserve">
          <source>If the backend is not the default matplotlib one, the return value will be the object returned by the backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeceb5d896fc9cb6f840f781402681ca9e0cca6b" translate="yes" xml:space="preserve">
          <source>If the caller is heterogeneous and contains booleans or objects, the result will be of dtype=object. See Notes.</source>
          <target state="translated">Si la llamada es heterogénea y contiene booleanos u objetos,el resultado será de dtype=objeto.Véase Notas.</target>
        </trans-unit>
        <trans-unit id="78dfb04301d7d11f06e3b14acf5990d58d0a43a0" translate="yes" xml:space="preserve">
          <source>If the categories do not validate.</source>
          <target state="translated">Si las categorías no son válidas.</target>
        </trans-unit>
        <trans-unit id="37b7a652ec11f0c6a680c6d296b342bf36963ce7" translate="yes" xml:space="preserve">
          <source>If the columns have a &lt;code&gt;MultiIndex&lt;/code&gt;, you can choose which level to stack. The stacked level becomes the new lowest level in a &lt;code&gt;MultiIndex&lt;/code&gt; on the columns:</source>
          <target state="translated">Si las columnas tienen un &lt;code&gt;MultiIndex&lt;/code&gt; , puede elegir qu&amp;eacute; nivel apilar. El nivel apilado se convierte en el nuevo nivel m&amp;aacute;s bajo en un &lt;code&gt;MultiIndex&lt;/code&gt; en las columnas:</target>
        </trans-unit>
        <trans-unit id="e6bab78d983e5853d00e346d9f3278a1b337046e" translate="yes" xml:space="preserve">
          <source>If the columns have multiple levels, determines how the other levels are named. If None then the index name is repeated.</source>
          <target state="translated">Si las columnas tienen múltiples niveles,determina cómo se nombran los otros niveles.Si no hay ninguno,entonces el nombre del índice se repite.</target>
        </trans-unit>
        <trans-unit id="16f324de3f6d44a6d155ca6a0800716c76d8fdf8" translate="yes" xml:space="preserve">
          <source>If the columns have multiple levels, determines which level the labels are inserted into. By default it is inserted into the first level.</source>
          <target state="translated">Si las columnas tienen múltiples niveles,determina en qué nivel se insertan las etiquetas.Por defecto se inserta en el primer nivel.</target>
        </trans-unit>
        <trans-unit id="b46261a6c2734b27734de6d0fcc60d9a4f9f2be6" translate="yes" xml:space="preserve">
          <source>If the data are all NA, the result will be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8d59c818fd41f1886de03e2a0e8206d7189f0d" translate="yes" xml:space="preserve">
          <source>If the data are tz-aware, then every value in the array must have the same timezone.</source>
          <target state="translated">Si los datos son sensibles a las tz,entonces cada valor de la matriz debe tener la misma zona horaria.</target>
        </trans-unit>
        <trans-unit id="751891dab5d046525fc44f6b2e68f95c51bfff3b" translate="yes" xml:space="preserve">
          <source>If the data is not length-1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39bced8875c9d4daed1623756606adbd29a4918" translate="yes" xml:space="preserve">
          <source>If the default template doesn&amp;rsquo;t quite suit your needs, you can subclass Styler and extend or override the template. We&amp;rsquo;ll show an example of extending the default template to insert a custom header before each table.</source>
          <target state="translated">Si la plantilla predeterminada no satisface sus necesidades, puede crear una subclase de Styler y extender o anular la plantilla. Mostraremos un ejemplo de c&amp;oacute;mo extender la plantilla predeterminada para insertar un encabezado personalizado antes de cada tabla.</target>
        </trans-unit>
        <trans-unit id="6fd8fd90d6a0d1abee70b7276ea680c627a14212" translate="yes" xml:space="preserve">
          <source>If the dtype is integer, convert to an appropriate integer extension type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9934081d7cb4f95460aa7414ef39e9099336c32f" translate="yes" xml:space="preserve">
          <source>If the dtype is numeric, and consists of all integers, convert to an appropriate integer extension type. Otherwise, convert to an appropriate floating extension type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b474e8292463ff3d6dc397cb12f9e866f037fd93" translate="yes" xml:space="preserve">
          <source>If the elements of a Series are lists themselves, join the content of these lists using the delimiter passed to the function. This function is an equivalent to &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.join&quot;&gt;&lt;code&gt;str.join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si los elementos de una Serie son listas en s&amp;iacute; mismos, une el contenido de estas listas usando el delimitador pasado a la funci&amp;oacute;n. Esta funci&amp;oacute;n es equivalente a &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.join&quot;&gt; &lt;code&gt;str.join()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5cd27d9aa0745a9023fb6c25cf1ae1d3bf731d3" translate="yes" xml:space="preserve">
          <source>If the exact type is not relevant, but must be compatible with a numpy array, array-like can be specified. If Any type that can be iterated is accepted, iterable can be used:</source>
          <target state="translated">Si el tipo exacto no es relevante,pero debe ser compatible con un arreglo numérico,se puede especificar el tipo de arreglo.Si se acepta cualquier tipo que pueda ser iterado,se puede utilizar iterable:</target>
        </trans-unit>
        <trans-unit id="be5ff8f8c878d0a8afe3f068aed76c34baa9e8b2" translate="yes" xml:space="preserve">
          <source>If the expression contains an assignment, whether to perform the operation inplace and mutate the existing DataFrame. Otherwise, a new DataFrame is returned.</source>
          <target state="translated">Si la expresión contiene una asignación,si realizar la operación en el lugar y mutar el DataFrame existente.De lo contrario,se devuelve un nuevo DataFrame.</target>
        </trans-unit>
        <trans-unit id="d26e067e645ae141c3a27a1e812db05453a5ed1b" translate="yes" xml:space="preserve">
          <source>If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58976636f12bfa2b230629347f075b16cf9d94be" translate="yes" xml:space="preserve">
          <source>If the fiscal year starts in April (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ff9c19369126c9e7394a827328229c91b340d6" translate="yes" xml:space="preserve">
          <source>If the fiscal year starts in April (&lt;code&gt;Q-MAR&lt;/code&gt;), the first quarter of 2018 will start in April 2017. &lt;code&gt;year&lt;/code&gt; will then be 2018, but &lt;code&gt;qyear&lt;/code&gt; will be the fiscal year, 2018.</source>
          <target state="translated">Si el a&amp;ntilde;o fiscal que comienza en abril ( &lt;code&gt;Q-MAR&lt;/code&gt; ), el primer trimestre de 2018 se pondr&amp;aacute; en marcha en abril de 2017. &lt;code&gt;year&lt;/code&gt; ser&amp;aacute; entonces 2018, pero &lt;code&gt;qyear&lt;/code&gt; ser&amp;aacute; el a&amp;ntilde;o fiscal 2018.</target>
        </trans-unit>
        <trans-unit id="b59db1d7abf5d61294ac0431e0b446551a515714" translate="yes" xml:space="preserve">
          <source>If the frequency is higher than daily (e.g. monthly), the last day of the period is used.</source>
          <target state="translated">Si la frecuencia es superior a la diaria (por ejemplo,mensual),se utiliza el último día del período.</target>
        </trans-unit>
        <trans-unit id="cbee9b96a09f286deac2451511a01eaea475791a" translate="yes" xml:space="preserve">
          <source>If the given date &lt;em&gt;is&lt;/em&gt; on an anchor point, it is moved &lt;code&gt;|n|&lt;/code&gt; points forwards or backwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251850cb5f40595dbfbfb399f7a94595a96e86d5" translate="yes" xml:space="preserve">
          <source>If the header is in a row other than the first, pass the row number to &lt;code&gt;header&lt;/code&gt;. This will skip the preceding rows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95726e1713352efccbe37d7bda0327d4e035e6e" translate="yes" xml:space="preserve">
          <source>If the index being truncated contains only datetime values,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d726bbcf68dc737c3aca6d41e599a28b3f5d3ff8" translate="yes" xml:space="preserve">
          <source>If the index being truncated contains only datetime values, &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; may be specified as strings instead of Timestamps.</source>
          <target state="translated">Si el &amp;iacute;ndice que se est&amp;aacute; truncando contiene solo valores de fecha y hora, &lt;code&gt;before&lt;/code&gt; y &lt;code&gt;after&lt;/code&gt; se pueden especificar como cadenas en lugar de marcas de tiempo.</target>
        </trans-unit>
        <trans-unit id="26ab44fcadd1b6b21a6d87e3f94d723582cab96b" translate="yes" xml:space="preserve">
          <source>If the index consists of dates, it calls &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.autofmt_xdate&quot;&gt;&lt;code&gt;gcf().autofmt_xdate()&lt;/code&gt;&lt;/a&gt; to try to format the x-axis nicely as per above.</source>
          <target state="translated">Si el &amp;iacute;ndice consta de fechas, llama a &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.autofmt_xdate&quot;&gt; &lt;code&gt;gcf().autofmt_xdate()&lt;/code&gt; &lt;/a&gt; para intentar formatear el eje x correctamente como se indica arriba.</target>
        </trans-unit>
        <trans-unit id="2264c92998892aeab7e100ff43c608c30c0b3eaf" translate="yes" xml:space="preserve">
          <source>If the index has level names, they will parsed as well, using the same parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62bf561852f13e8a7992a8390ffa6b918215b325" translate="yes" xml:space="preserve">
          <source>If the index has multiple levels, we can reset a subset of them:</source>
          <target state="translated">Si el índice tiene múltiples niveles,podemos reajustar un subconjunto de ellos:</target>
        </trans-unit>
        <trans-unit id="cda1d90ab4aeda16d9fd7875489389b8cf6ae137" translate="yes" xml:space="preserve">
          <source>If the index is a MultiIndex, level(s) to set (None for all levels). Otherwise level must be None.</source>
          <target state="translated">Si el índice es un Multi-índice,nivel(es)a establecer (Ninguno para todos los niveles).De lo contrario el nivel debe ser Ninguno.</target>
        </trans-unit>
        <trans-unit id="067743019a50efb3de30de5e7db206d81efd2bfc" translate="yes" xml:space="preserve">
          <source>If the index is not a &lt;a href=&quot;pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt;&lt;code&gt;DatetimeIndex&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Si el &amp;iacute;ndice no es un &lt;a href=&quot;pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt; &lt;code&gt;DatetimeIndex&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1927dd8f9c19eb08ec5a860837248b90f251a58b" translate="yes" xml:space="preserve">
          <source>If the index is not a MultiIndex, the output will be a Series (the analogue of stack when the columns are not a MultiIndex).</source>
          <target state="translated">Si el índice no es un Multiíndice,la salida será una Serie (el análogo de la pila cuando las columnas no son un Multiíndice).</target>
        </trans-unit>
        <trans-unit id="30fd49a077ae8a3b14098e6244c90ec8aaa36f10" translate="yes" xml:space="preserve">
          <source>If the index is not datetime-like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0474835e1da4e14d4e8fd21bedd592901f57b6d7" translate="yes" xml:space="preserve">
          <source>If the index is not sorted, an error is raised.</source>
          <target state="translated">Si el índice no se ordena,se produce un error.</target>
        </trans-unit>
        <trans-unit id="91a507c7cc7e55eec65d8adcd1430cebef29fade" translate="yes" xml:space="preserve">
          <source>If the index of a &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;DataFrame&lt;/code&gt; is monotonically increasing or decreasing, then the bounds of a label-based slice can be outside the range of the index, much like slice indexing a normal Python &lt;code&gt;list&lt;/code&gt;. Monotonicity of an index can be tested with the &lt;a href=&quot;../reference/api/pandas.index.is_monotonic_increasing#pandas.Index.is_monotonic_increasing&quot;&gt;&lt;code&gt;is_monotonic_increasing()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.index.is_monotonic_decreasing#pandas.Index.is_monotonic_decreasing&quot;&gt;&lt;code&gt;is_monotonic_decreasing()&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48b9e82a9c1b991449ed1f9627ad743db7ae93ac" translate="yes" xml:space="preserve">
          <source>If the indexes have names, you can use the level names instead of specifying the level numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6a27e99c67cc04b243466ae25a20129613f55a" translate="yes" xml:space="preserve">
          <source>If the key is past the lexsort depth, the return may be a boolean mask array, otherwise it is always a slice or int.</source>
          <target state="translated">Si la clave está más allá de la profundidad de lexsort,el retorno puede ser un arreglo de máscara booleana,de lo contrario siempre es una rebanada o int.</target>
        </trans-unit>
        <trans-unit id="23363d65d1a6bf0f3c3353ab3f1570ee49ce97bd" translate="yes" xml:space="preserve">
          <source>If the label is in the index, the method returns the passed label.</source>
          <target state="translated">Si la etiqueta está en el índice,el método devuelve la etiqueta pasada.</target>
        </trans-unit>
        <trans-unit id="62728247d7d94b3cd5df3bfeeee148f0c1c53570" translate="yes" xml:space="preserve">
          <source>If the levels of the &lt;code&gt;MultiIndex&lt;/code&gt; are unnamed, you can refer to them using special names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bace5351497c6afbd0b965925661935f3882c76" translate="yes" xml:space="preserve">
          <source>If the library specified with the &lt;code&gt;complib&lt;/code&gt; option is missing on your platform, compression defaults to &lt;code&gt;zlib&lt;/code&gt; without further ado.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621ef692e94d8c2c7ed3c141b773d4670d1901fd" translate="yes" xml:space="preserve">
          <source>If the mapping doesn&amp;rsquo;t include a column/index label, it isn&amp;rsquo;t renamed. Note that extra labels in the mapping don&amp;rsquo;t throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22dfc540b19512c01f76cdc319937a5edf13e1d7" translate="yes" xml:space="preserve">
          <source>If the mapping is not one-to-one an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; is returned:</source>
          <target state="translated">Si el mapeo no es uno a uno &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; se devuelve un &amp;iacute;ndice :</target>
        </trans-unit>
        <trans-unit id="f30e3b28f5a53e1916fb432f6e3f20ec400af36a" translate="yes" xml:space="preserve">
          <source>If the mapping is one-to-one the ordering of the categories is preserved:</source>
          <target state="translated">Si la cartografía es unívoca,se conserva el orden de las categorías:</target>
        </trans-unit>
        <trans-unit id="a768d5fc9004a5e554c6076edc84eab413d78b6d" translate="yes" xml:space="preserve">
          <source>If the maximum is achieved in multiple locations, the first row position is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29594b7fad55aba80e626335052ebbda64589beb" translate="yes" xml:space="preserve">
          <source>If the method returns a value, it will be documented in this section. Also if the method yields its output.</source>
          <target state="translated">Si el método devuelve un valor,se documentará en esta sección.También si el método devuelve su resultado.</target>
        </trans-unit>
        <trans-unit id="1c7fa85a4950fc4db50e956b853116480dbe2810" translate="yes" xml:space="preserve">
          <source>If the method yields its value:</source>
          <target state="translated">Si el método da su valor:</target>
        </trans-unit>
        <trans-unit id="6ea0723c633b98419ce3a16ae4f68fc08bf4f8d0" translate="yes" xml:space="preserve">
          <source>If the minimum is achieved in multiple locations, the first row position is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb76a7d2f4b9a5dfe28cdf6f1774a0fbdbb4d8d" translate="yes" xml:space="preserve">
          <source>If the name of your index overlaps with a column name, the column name is given precedence. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b88b10d573c557d524dfc87fd5f8d2b05a6035" translate="yes" xml:space="preserve">
          <source>If the natural and fiscal year are the same,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be314f975c703a2d0fb14d5a08ed837b5ac3d17" translate="yes" xml:space="preserve">
          <source>If the natural and fiscal year are the same, &lt;code&gt;qyear&lt;/code&gt; and &lt;code&gt;year&lt;/code&gt; will be the same.</source>
          <target state="translated">Si el a&amp;ntilde;o natural y el a&amp;ntilde;o fiscal son iguales, &lt;code&gt;qyear&lt;/code&gt; y &lt;code&gt;year&lt;/code&gt; ser&amp;aacute;n iguales.</target>
        </trans-unit>
        <trans-unit id="c2d7883a841125b807eecd00b3c3af4f438f2ede" translate="yes" xml:space="preserve">
          <source>If the new categories do not contain all old category items or any new ones</source>
          <target state="translated">Si las nuevas categorías no contienen todos los elementos de la antigua categoría o los nuevos</target>
        </trans-unit>
        <trans-unit id="b8ff9a9bc1a204944889d9f9ab64cff13098ce04" translate="yes" xml:space="preserve">
          <source>If the new categories do not validate as categories or if the number of new categories is unequal the number of old categories</source>
          <target state="translated">Si las nuevas categorías no se validan como categorías o si el número de nuevas categorías es desigual,el número de categorías antiguas</target>
        </trans-unit>
        <trans-unit id="e5bb30293ce2058c6ee007b1c0630a5f11c11af8" translate="yes" xml:space="preserve">
          <source>If the new categories include old categories or do not validate as categories</source>
          <target state="translated">Si las nuevas categorías incluyen las antiguas o no se validan como categorías</target>
        </trans-unit>
        <trans-unit id="fe951dca7785cedc66869cdb77e398f6c9c6fc86" translate="yes" xml:space="preserve">
          <source>If the number of categories approaches the length of the data, the &lt;code&gt;Categorical&lt;/code&gt; will use nearly the same or more memory than an equivalent &lt;code&gt;object&lt;/code&gt; dtype representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d42972fb825ba15c0b8fbd39cf2275d1d47464c" translate="yes" xml:space="preserve">
          <source>If the offset class maps directly to a &lt;code&gt;Timedelta&lt;/code&gt; (&lt;code&gt;Day&lt;/code&gt;, &lt;code&gt;Hour&lt;/code&gt;, &lt;code&gt;Minute&lt;/code&gt;, &lt;code&gt;Second&lt;/code&gt;, &lt;code&gt;Micro&lt;/code&gt;, &lt;code&gt;Milli&lt;/code&gt;, &lt;code&gt;Nano&lt;/code&gt;) it can be used exactly like a &lt;code&gt;Timedelta&lt;/code&gt; - see the &lt;a href=&quot;timedeltas#timedeltas-operations&quot;&gt;Timedelta section&lt;/a&gt; for more examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4e627ef93053b4aa69b81750fbb56a233374ba" translate="yes" xml:space="preserve">
          <source>If the parsed data only contains one column then return a &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc97c541d898a4ba589bd072c2b06a7b9a9ba55c" translate="yes" xml:space="preserve">
          <source>If the parsed data only contains one column then return a Series.</source>
          <target state="translated">Si los datos analizados sólo contienen una columna,entonces devuelve una serie.</target>
        </trans-unit>
        <trans-unit id="6fce5176c2e9226fd8f8db2e0305dd4e81c28cba" translate="yes" xml:space="preserve">
          <source>If the pattern is found more than once in the same string, then a list of multiple strings is returned:</source>
          <target state="translated">Si el patrón se encuentra más de una vez en la misma cadena,entonces se devuelve una lista de múltiples cadenas:</target>
        </trans-unit>
        <trans-unit id="862fb94e4f74981a38a343060cd76373e4ac1593" translate="yes" xml:space="preserve">
          <source>If the period frequency is lower than daily (e.g. hourly), and the period spans over multiple days, the day at the start of the period is used.</source>
          <target state="translated">Si la frecuencia del período es inferior a la diaria (por ejemplo,cada hora),y el período se extiende a lo largo de varios días,se utiliza el día de inicio del período.</target>
        </trans-unit>
        <trans-unit id="afacabf141fdf1a3c0b0db32b0df85742991ee4b" translate="yes" xml:space="preserve">
          <source>If the precision is higher than nanoseconds, the precision of the duration is truncated to nanoseconds for string inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc1edffb0f31fc99e3c48d2e32580c307e64c9a" translate="yes" xml:space="preserve">
          <source>If the precision is higher than nanoseconds, the precision of the duration is truncated to nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24931cba16f8d7d23729af82afc7b5cf33a8ab54" translate="yes" xml:space="preserve">
          <source>If the removals are not contained in the categories</source>
          <target state="translated">Si las expulsiones no están incluidas en las categorías</target>
        </trans-unit>
        <trans-unit id="a91b79ba0a48641f561804353a8466ad061c6ff1" translate="yes" xml:space="preserve">
          <source>If the row/column is empty</source>
          <target state="translated">Si la fila/columna está vacía</target>
        </trans-unit>
        <trans-unit id="c1275c4e20323c10096aa977b7395839bb87cb2c" translate="yes" xml:space="preserve">
          <source>If the slicing operation returns either a &lt;code&gt;DataFrame&lt;/code&gt; or a column of type &lt;code&gt;Series&lt;/code&gt;, the &lt;code&gt;category&lt;/code&gt; dtype is preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5afed770bb40cdc080e4e911d978019b4cc3a824" translate="yes" xml:space="preserve">
          <source>If the source file has both &lt;code&gt;MultiIndex&lt;/code&gt; index and columns, lists specifying each should be passed to &lt;code&gt;index_col&lt;/code&gt; and &lt;code&gt;header&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fbbcf4ba212002b0c61ef4fa072fb2a25199bd" translate="yes" xml:space="preserve">
          <source>If the supplied Series contains neither strings nor lists.</source>
          <target state="translated">Si la serie suministrada no contiene ni cadenas ni listas.</target>
        </trans-unit>
        <trans-unit id="e0f175e63735de751d2d7b89f97ca4eea1b0abeb" translate="yes" xml:space="preserve">
          <source>If the test generates a warning of class &lt;code&gt;category&lt;/code&gt; whose message starts with &lt;code&gt;msg&lt;/code&gt;, the warning will be ignored and the test will pass.</source>
          <target state="translated">Si la prueba genera una advertencia de &lt;code&gt;category&lt;/code&gt; de clase cuyo mensaje comienza con &lt;code&gt;msg&lt;/code&gt; , la advertencia se ignorar&amp;aacute; y la prueba pasar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="e13fc8bacc6ba344e6b7c59f5500846f60bb9f0f" translate="yes" xml:space="preserve">
          <source>If the timestamp string is treated as a slice, it can be used to index &lt;code&gt;DataFrame&lt;/code&gt; with &lt;code&gt;.loc[]&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14413eaf87552171ee2c64255914c3d985a6b0cb" translate="yes" xml:space="preserve">
          <source>If the timezone is not set, the resulting Series will have a datetime64[ns] dtype.</source>
          <target state="translated">Si no se establece la zona horaria,la Serie resultante tendrá un tipo de fecha-hora64[ns].</target>
        </trans-unit>
        <trans-unit id="55f68536b5e696d5ad33c88c279512e394794e07" translate="yes" xml:space="preserve">
          <source>If the type is a pandas type, also specify pandas except for Series and DataFrame:</source>
          <target state="translated">Si el tipo es un tipo de pandas,también especifica pandas excepto para la Serie y el DataFrame:</target>
        </trans-unit>
        <trans-unit id="2c463cab0f756d454178e69be623cfa933046f80" translate="yes" xml:space="preserve">
          <source>If the type is defined in a Python module, the module must be specified:</source>
          <target state="translated">Si el tipo está definido en un módulo Python,el módulo debe ser especificado:</target>
        </trans-unit>
        <trans-unit id="fa3ae3c0858082628b417918cb8ce07cd4ca5f45" translate="yes" xml:space="preserve">
          <source>If the type is in a package, the module must be also specified:</source>
          <target state="translated">Si el tipo está en un paquete,el módulo también debe ser especificado:</target>
        </trans-unit>
        <trans-unit id="7a03f05686c0d02f3139ecf76b3027fa808e62cc" translate="yes" xml:space="preserve">
          <source>If the user is aware of the duplicates in the right &lt;code&gt;DataFrame&lt;/code&gt; but wants to ensure there are no duplicates in the left DataFrame, one can use the &lt;code&gt;validate='one_to_many'&lt;/code&gt; argument instead, which will not raise an exception.</source>
          <target state="translated">Si el usuario est&amp;aacute; al tanto de los duplicados en el &lt;code&gt;DataFrame&lt;/code&gt; derecho pero quiere asegurarse de que no haya duplicados en el DataFrame izquierdo, se puede usar el argumento &lt;code&gt;validate='one_to_many'&lt;/code&gt; en su lugar, que no generar&amp;aacute; una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="40e3ffe708d7d382314e21166febe6fa597c1764" translate="yes" xml:space="preserve">
          <source>If the values are not monotonically sorted, wrong locations may be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8116189ef90a7c0ac0c0a3c8ff175ce609f080fc" translate="yes" xml:space="preserve">
          <source>If there are any NaN or NaT values in the grouping key, these will be automatically excluded. In other words, there will never be an &amp;ldquo;NA group&amp;rdquo; or &amp;ldquo;NaT group&amp;rdquo;. This was not the case in older versions of pandas, but users were generally discarding the NA group anyway (and supporting it was an implementation headache).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="682fbbd327f7dba66b881174932070842597549b" translate="yes" xml:space="preserve">
          <source>If there are fewer than three values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f25d66dfb27cdf7e82e3397b599f84e8bbd166" translate="yes" xml:space="preserve">
          <source>If there are merge conflicts, you need to solve those conflicts. See for example at &lt;a href=&quot;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&quot;&gt;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&lt;/a&gt; for an explanation on how to do this. Once the conflicts are merged and the files where the conflicts were solved are added, you can run &lt;code&gt;git commit&lt;/code&gt; to save those fixes.</source>
          <target state="translated">Si hay conflictos de fusi&amp;oacute;n, debe resolver esos conflictos. Consulte, por ejemplo, &lt;a href=&quot;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&quot;&gt;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&lt;/a&gt; para obtener una explicaci&amp;oacute;n sobre c&amp;oacute;mo hacer esto. Una vez que se fusionan los conflictos y se agregan los archivos donde se resolvieron los conflictos, puede ejecutar &lt;code&gt;git commit&lt;/code&gt; para guardar esas correcciones.</target>
        </trans-unit>
        <trans-unit id="f267a36da468b5ae5ceb8cafd473d483c3fe55df" translate="yes" xml:space="preserve">
          <source>If there are no conflicts (or they could be fixed automatically), a file with a default commit message will open, and you can simply save and quit this file.</source>
          <target state="translated">Si no hay conflictos (o podrían arreglarse automáticamente),se abrirá un archivo con un mensaje de confirmación predeterminado,y puedes simplemente guardar y salir de este archivo.</target>
        </trans-unit>
        <trans-unit id="f642e67158a066fd10cb787b665aedb36dbf5c3d" translate="yes" xml:space="preserve">
          <source>If there are people interested in continued support for Python 2.7 past December 31, 2018 (either backporting bug fixes or funding) please reach out to the maintainers on the issue tracker.</source>
          <target state="translated">Si hay personas interesadas en continuar apoyando a Python 2.7 más allá del 31 de diciembre de 2018 (ya sea corrigiendo errores en el backporting o financiando),por favor comuníquese con los encargados del seguimiento de la cuestión.</target>
        </trans-unit>
        <trans-unit id="df8b99601c3ccae4df1dcef1c8a935236cdb7582" translate="yes" xml:space="preserve">
          <source>If there is a small part of the result that can vary (e.g. a hash in an object representation), you can use &lt;code&gt;...&lt;/code&gt; to represent this part.</source>
          <target state="translated">Si hay una peque&amp;ntilde;a parte del resultado que puede variar (por ejemplo, un hash en la representaci&amp;oacute;n de un objeto), puede usar &lt;code&gt;...&lt;/code&gt; para representar esta parte.</target>
        </trans-unit>
        <trans-unit id="79166ffe4f486692983ad25c9bb5a734e08993de" translate="yes" xml:space="preserve">
          <source>If there is no good value, NaN is returned for a Series or a Series of NaN values for a DataFrame</source>
          <target state="translated">Si no hay un buen valor,se devuelve NaN para una serie o una serie de valores de NaN para un DataFrame</target>
        </trans-unit>
        <trans-unit id="9a50506ea7c3939131db7d78d6afca01537a49a9" translate="yes" xml:space="preserve">
          <source>If this behavior is surprising, keep in mind that using &lt;code&gt;in&lt;/code&gt; on a Python dictionary tests keys, not values, and &lt;code&gt;Series&lt;/code&gt; are dict-like. To test for membership in the values, use the method &lt;a href=&quot;../reference/api/pandas.series.isin#pandas.Series.isin&quot;&gt;&lt;code&gt;isin()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4e4a825180bf8808a64195ae6d697226e17fa3" translate="yes" xml:space="preserve">
          <source>If this parameter is False, sets will not be considered list-like</source>
          <target state="translated">Si este parámetro es falso,los conjuntos no se considerarán como una lista</target>
        </trans-unit>
        <trans-unit id="407299ada9b8eb20aa8ecf277a6368180bf252b5" translate="yes" xml:space="preserve">
          <source>If this parameter is False, sets will not be considered list-like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde86769fd29b3bc205b6c427ec8870bad01f3ff" translate="yes" xml:space="preserve">
          <source>If true, ALL nan rows will not be written to store.</source>
          <target state="translated">Si es cierto,TODAS las filas de las nanas no se escribirán para almacenar.</target>
        </trans-unit>
        <trans-unit id="47999fb8ac96a558b41fd99b5e696eccf4732cbe" translate="yes" xml:space="preserve">
          <source>If true, all rows and columns are kept. Otherwise, only the ones with different values are kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3282649a37ac55c74db8a5a1b1a27ca8c630f36d" translate="yes" xml:space="preserve">
          <source>If true, columns will be used as xticks</source>
          <target state="translated">Si es cierto,las columnas se usarán como xticks</target>
        </trans-unit>
        <trans-unit id="0a143ef8b9e23894e4227d511a2a634fc694a65a" translate="yes" xml:space="preserve">
          <source>If true, columns will be used as xticks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a761e46b1b0da1fd384002ba5d9bdd4de4efda77" translate="yes" xml:space="preserve">
          <source>If true, resulting categories will be lexsorted, otherwise they will be ordered as they appear in the data.</source>
          <target state="translated">Si es cierto,las categorías resultantes se lexcluirán,de lo contrario se ordenarán tal como aparecen en los datos.</target>
        </trans-unit>
        <trans-unit id="4fcaa7b2fe91e543e75e6441530fd4b5d810bb7f" translate="yes" xml:space="preserve">
          <source>If true, the ordered attribute of the Categoricals will be ignored. Results in an unordered categorical.</source>
          <target state="translated">Si es cierto,el atributo ordenado de los categóricos será ignorado.Resulta en un categórico no ordenado.</target>
        </trans-unit>
        <trans-unit id="bcaaeba8088f223fce415445cc2fe59773a45d3f" translate="yes" xml:space="preserve">
          <source>If true, the result keeps values that are equal. Otherwise, equal values are shown as NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1fe920431a3d41d651dfbcc77af70b504aee8c8" translate="yes" xml:space="preserve">
          <source>If true, vertical lines will be added at each xtick</source>
          <target state="translated">Si es cierto,se añadirán líneas verticales en cada xtick</target>
        </trans-unit>
        <trans-unit id="2c27e3a5063b9b94517959af47c02a3dd19fa2c3" translate="yes" xml:space="preserve">
          <source>If true, vertical lines will be added at each xtick.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce59a050f48126ce6320c30610faaa9c86fc199e" translate="yes" xml:space="preserve">
          <source>If two CategoricalIndex objects have equal elements True, otherwise False.</source>
          <target state="translated">Si dos objetos CategoricalIndex tienen elementos iguales,Verdadero,de lo contrario Falso.</target>
        </trans-unit>
        <trans-unit id="d639547142f390403b221695989f0de239dbb7b1" translate="yes" xml:space="preserve">
          <source>If two Index objects have equal elements and same type True, otherwise False.</source>
          <target state="translated">Si dos objetos del Índice tienen elementos iguales y el mismo tipo de Verdadero,de lo contrario Falso.</target>
        </trans-unit>
        <trans-unit id="626c6821778795ed6605d4fcfb4d554d4bb3ee62" translate="yes" xml:space="preserve">
          <source>If unnamed &lt;code&gt;Series&lt;/code&gt; are passed they will be numbered consecutively.</source>
          <target state="translated">Si se aprueban &lt;code&gt;Series&lt;/code&gt; sin nombre , se numerar&amp;aacute;n consecutivamente.</target>
        </trans-unit>
        <trans-unit id="952e2dee711cdb4ef88782a2cd0578a6a6843049" translate="yes" xml:space="preserve">
          <source>If using &lt;code&gt;expand=True&lt;/code&gt;, Series and Index callers return DataFrame and MultiIndex objects, respectively.</source>
          <target state="translated">Si usa &lt;code&gt;expand=True&lt;/code&gt; , las personas que llaman Series e Index devuelven objetos DataFrame y MultiIndex, respectivamente.</target>
        </trans-unit>
        <trans-unit id="4055d83a079c44709ace2481bdd4e3c1f48c7657" translate="yes" xml:space="preserve">
          <source>If using &lt;code&gt;join='right'&lt;/code&gt; on a list-like of &lt;code&gt;others&lt;/code&gt; that contains different indexes, the union of these indexes will be used as the basis for the final concatenation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1cf23a69f82311296b7504255332812bccf16b4" translate="yes" xml:space="preserve">
          <source>If using in the Jupyter notebook, Styler has defined a &lt;code&gt;_repr_html_&lt;/code&gt; to automatically render itself. Otherwise call Styler.render to get the generated HTML.</source>
          <target state="translated">Si se usa en el cuaderno de Jupyter, Styler ha definido un &lt;code&gt;_repr_html_&lt;/code&gt; para renderizarse autom&amp;aacute;ticamente. De lo contrario, llame a Styler.render para obtener el HTML generado.</target>
        </trans-unit>
        <trans-unit id="302e92543f3f0f75ce924bc7f9f8aa88c440b3a5" translate="yes" xml:space="preserve">
          <source>If warn=True, issue a warning if nanoseconds is nonzero.</source>
          <target state="translated">Si warn=True,emite una advertencia si los nanosegundos son distintos de cero.</target>
        </trans-unit>
        <trans-unit id="260f17759a03e9b11140d2b1e686eb99c682c39b" translate="yes" xml:space="preserve">
          <source>If we also have a MultiIndex on columns &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, we can group by all but the specified columns</source>
          <target state="translated">Si tambi&amp;eacute;n tenemos un MultiIndex en las columnas &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; , podemos agrupar por todas las columnas excepto las especificadas</target>
        </trans-unit>
        <trans-unit id="82061eba4d9b00cf01b3ade310c01171b0a5cc2f" translate="yes" xml:space="preserve">
          <source>If we are not dropping the index, by default, it is placed in the top level. We can place it in another level:</source>
          <target state="translated">Si no estamos bajando el índice,por defecto,se coloca en el nivel superior.Podemos colocarlo en otro nivel:</target>
        </trans-unit>
        <trans-unit id="b79fd67d25657db5cfcdb0ceff92c9e8f9633182" translate="yes" xml:space="preserve">
          <source>If we have many columns, we could also use a regex to find our stubnames and pass that list on to wide_to_long</source>
          <target state="translated">Si tenemos muchas columnas,también podríamos usar un regex para encontrar nuestros nombres y pasar esa lista a wide_to_long</target>
        </trans-unit>
        <trans-unit id="7958cdd41a3b26aba9f751c1c05f025c55b1c42f" translate="yes" xml:space="preserve">
          <source>If we need intervals on a regular frequency, we can use the &lt;a href=&quot;../reference/api/pandas.interval_range#pandas.interval_range&quot;&gt;&lt;code&gt;interval_range()&lt;/code&gt;&lt;/a&gt; function to create an &lt;code&gt;IntervalIndex&lt;/code&gt; using various combinations of &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;periods&lt;/code&gt;. The default frequency for &lt;code&gt;interval_range&lt;/code&gt; is a 1 for numeric intervals, and calendar day for datetime-like intervals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3059eebcb64938e4b7a073e1ffb4bda57975fc0" translate="yes" xml:space="preserve">
          <source>If we only have NaNs in our DataFrame, it is not considered empty! We will need to drop the NaNs to make the DataFrame empty:</source>
          <target state="translated">Si sólo tenemos NaNs en nuestro DataFrame,¡no se considera vacío! Tendremos que soltar los NaNs para que el DataFrame esté vacío:</target>
        </trans-unit>
        <trans-unit id="71867c41ff101e2dd9ed7493912c5eb77334366c" translate="yes" xml:space="preserve">
          <source>If we only want consecutive gaps filled up to a certain number of data points, we can use the &lt;code&gt;limit&lt;/code&gt; keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968348830bc4858358f68548de84b2c5a80500f0" translate="yes" xml:space="preserve">
          <source>If we specify a nonexistent level for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7bb5bb11f2ff2055c13b48cfec8d32f8a45a2e2" translate="yes" xml:space="preserve">
          <source>If we specify a nonexistent level for &lt;code&gt;col_fill&lt;/code&gt;, it is created:</source>
          <target state="translated">Si especificamos un nivel inexistente para &lt;code&gt;col_fill&lt;/code&gt; , se crea:</target>
        </trans-unit>
        <trans-unit id="f00dc1db037371153c550cb158eb937061016aea" translate="yes" xml:space="preserve">
          <source>If we want to join using the key columns, we need to set key to be the index in both</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ebde3340d88dc78a7515ebac165ad4cba048950" translate="yes" xml:space="preserve">
          <source>If we want to join using the key columns, we need to set key to be the index in both &lt;code&gt;df&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. The joined DataFrame will have key as its index.</source>
          <target state="translated">Si queremos unirnos usando las columnas de clave, debemos configurar la clave para que sea el &amp;iacute;ndice tanto en &lt;code&gt;df&lt;/code&gt; como en &lt;code&gt;other&lt;/code&gt; . El DataFrame unido tendr&amp;aacute; key como &amp;iacute;ndice.</target>
        </trans-unit>
        <trans-unit id="9837dbf801ccbd6d7e3a0358e252af7c064b1881" translate="yes" xml:space="preserve">
          <source>If we want to resample to the full range of the series:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="116d297e0a504b613424946f4af9dc6593eaa9dd" translate="yes" xml:space="preserve">
          <source>If we were to measure the memory usage of the two calls, we&amp;rsquo;d see that specifying &lt;code&gt;columns&lt;/code&gt; uses about 1/10th the memory in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e711c3bc9df9cb81190099d32dcc6f9c71c2292f" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;must&lt;/em&gt; interpolate, use the &lt;code&gt;'%r'&lt;/code&gt; format specifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f5b50b561b3e7aa33c127ffbfebf0a7133f79a8" translate="yes" xml:space="preserve">
          <source>If you added the upstream repository as described above you will see something like:</source>
          <target state="translated">Si añadió el repositorio upstream como se describe arriba,verá algo como:</target>
        </trans-unit>
        <trans-unit id="6dcbc8930cebc1be87b34e4cba1b548ad13195a7" translate="yes" xml:space="preserve">
          <source>If you already have &lt;code&gt;codes&lt;/code&gt; and &lt;code&gt;categories&lt;/code&gt;, you can use the &lt;a href=&quot;../reference/api/pandas.categorical.from_codes#pandas.Categorical.from_codes&quot;&gt;&lt;code&gt;from_codes()&lt;/code&gt;&lt;/a&gt; constructor to save the factorize step during normal constructor mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c85b3d61764da8be18d5d777eb530f704213c9" translate="yes" xml:space="preserve">
          <source>If you also want to index a specific column with &lt;code&gt;.loc&lt;/code&gt;, you must use a tuple like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65afa83f1a217fb5a6797c63c1a0429f4d6825c0" translate="yes" xml:space="preserve">
          <source>If you are attempting to perform an operation you might see an exception like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a901823fe7ea06c8a1cd9a222f4bb095acb15157" translate="yes" xml:space="preserve">
          <source>If you are brand new to pandas or open-source development, we recommend going through the &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues&quot;&gt;GitHub &amp;ldquo;issues&amp;rdquo; tab&lt;/a&gt; to find issues that interest you. There are a number of issues listed under &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=Docs&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;Docs&lt;/a&gt; and &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=good+first+issue&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;good first issue&lt;/a&gt; where you could start out. Once you&amp;rsquo;ve found an interesting issue, you can return here to get your development environment setup.</source>
          <target state="translated">Si es nuevo en pandas o en el desarrollo de c&amp;oacute;digo abierto, le recomendamos que vaya a la &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues&quot;&gt;pesta&amp;ntilde;a &quot;Problemas&quot; de GitHub&lt;/a&gt; para encontrar problemas que le interesen. Hay una serie de problemas enumerados en &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=Docs&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;Documentos&lt;/a&gt; y un &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=good+first+issue&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;buen primer n&amp;uacute;mero&lt;/a&gt; en el que puede comenzar. Una vez que haya encontrado un problema interesante, puede regresar aqu&amp;iacute; para configurar su entorno de desarrollo.</target>
        </trans-unit>
        <trans-unit id="465f837f95ed9e96291bb7885669730c62809aef" translate="yes" xml:space="preserve">
          <source>If you are dealing with a time series that is growing at an increasing rate, &lt;code&gt;method='quadratic'&lt;/code&gt; may be appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca624ad660100e102682b9a51c3848478a72f2ee" translate="yes" xml:space="preserve">
          <source>If you are not passing any &lt;code&gt;data_columns&lt;/code&gt;, then the &lt;code&gt;min_itemsize&lt;/code&gt; will be the maximum of the length of any string passed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c15a6f9c5535245e9be6fcbd4d03ed646264a348" translate="yes" xml:space="preserve">
          <source>If you are using Python &amp;lt; 3.6 or pandas &amp;lt; 0.23, and &lt;code&gt;columns&lt;/code&gt; is not specified, the &lt;code&gt;DataFrame&lt;/code&gt; columns will be the lexically ordered list of dict keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1734348d69969fd360e31fd62aca6442bca44f8" translate="yes" xml:space="preserve">
          <source>If you are using dates beyond 2038-01-18, due to current deficiencies in the underlying libraries caused by the year 2038 problem, daylight saving time (DST) adjustments to timezone aware dates will not be applied. If and when the underlying libraries are fixed, the DST transitions will be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b96b99bd90b15f960a8a1d823fd7572e68539985" translate="yes" xml:space="preserve">
          <source>If you are using the IPython environment, you may also use tab-completion to see these accessible attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104adf5a4c3ea5cc99dad3c496195368e599955a" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t using conda for your development environment, follow these instructions. You&amp;rsquo;ll need to have at least python3.5 installed on your system.</source>
          <target state="translated">Si no est&amp;aacute; utilizando conda para su entorno de desarrollo, siga estas instrucciones. Necesitar&amp;aacute; tener al menos python3.5 instalado en su sistema.</target>
        </trans-unit>
        <trans-unit id="1b5a95ce05a5137b543597ab970b813363417ec7" translate="yes" xml:space="preserve">
          <source>If you build a great library on top of this, let us know and we&amp;rsquo;ll &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;link&lt;/a&gt; to it.</source>
          <target state="translated">Si se construye una gran biblioteca en la parte superior de este, h&amp;aacute;ganoslo saber y vamos a &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;vincular&lt;/a&gt; a la misma.</target>
        </trans-unit>
        <trans-unit id="67704c3d1919945e86ee78d09fa2f38a50a2066f" translate="yes" xml:space="preserve">
          <source>If you build a great library on top of this, let us know and we&amp;rsquo;ll &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;link&lt;/a&gt; to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741a6d65c45aabc2da8321ecddb112f34bdca128" translate="yes" xml:space="preserve">
          <source>If you create an index yourself, you can just assign it to the &lt;code&gt;index&lt;/code&gt; field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2610e8594483b112bc2ba67861d9a8abeac5ec9c" translate="yes" xml:space="preserve">
          <source>If you do wish to include decimal or object columns in an aggregation with other non-nuisance data types, you must do so explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6076bc560cf97aea736a51a15e40cbe385b624" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t like the default colours, you can specify how you&amp;rsquo;d like each column to be colored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1d9ea7791dacf7b9c85b45bf9ae6bfbc250a85" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t prefix the local variable with &lt;code&gt;@&lt;/code&gt;, pandas will raise an exception telling you the variable is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417bb3c329e071119224d529f869bb0141b6dcf0" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;parse_dates&lt;/code&gt; enabled for some or all of your columns, and your datetime strings are all formatted the same way, you may get a large speed up by setting &lt;code&gt;infer_datetime_format=True&lt;/code&gt;. If set, pandas will attempt to guess the format of your datetime strings, and then use a faster means of parsing the strings. 5-10x parsing speeds have been observed. pandas will fallback to the usual parsing if either the format cannot be guessed or the format that was guessed cannot properly parse the entire column of strings. So in general, &lt;code&gt;infer_datetime_format&lt;/code&gt; should not have any negative consequences if enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121f2b3e5cfa3e20d0594c4ac58f6710888524e4" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;Series&lt;/code&gt; where lots of elements are repeated (i.e. the number of unique elements in the &lt;code&gt;Series&lt;/code&gt; is a lot smaller than the length of the &lt;code&gt;Series&lt;/code&gt;), it can be faster to convert the original &lt;code&gt;Series&lt;/code&gt; to one of type &lt;code&gt;category&lt;/code&gt; and then use &lt;code&gt;.str.&amp;lt;method&amp;gt;&lt;/code&gt; or &lt;code&gt;.dt.&amp;lt;property&amp;gt;&lt;/code&gt; on that. The performance difference comes from the fact that, for &lt;code&gt;Series&lt;/code&gt; of type &lt;code&gt;category&lt;/code&gt;, the string operations are done on the &lt;code&gt;.categories&lt;/code&gt; and not on each element of the &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c991175b9cdf3e6da785720a9bef9cdc38f17c27" translate="yes" xml:space="preserve">
          <source>If you have a DataFrame or Series using traditional types that have missing data represented using &lt;code&gt;np.nan&lt;/code&gt;, there are convenience methods &lt;a href=&quot;../reference/api/pandas.series.convert_dtypes#pandas.Series.convert_dtypes&quot;&gt;&lt;code&gt;convert_dtypes()&lt;/code&gt;&lt;/a&gt; in Series and &lt;a href=&quot;../reference/api/pandas.dataframe.convert_dtypes#pandas.DataFrame.convert_dtypes&quot;&gt;&lt;code&gt;convert_dtypes()&lt;/code&gt;&lt;/a&gt; in DataFrame that can convert data to use the newer dtypes for integers, strings and booleans listed &lt;a href=&quot;basics#basics-dtypes&quot;&gt;here&lt;/a&gt;. This is especially helpful after reading in data sets when letting the readers such as &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;read_csv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.read_excel#pandas.read_excel&quot;&gt;&lt;code&gt;read_excel()&lt;/code&gt;&lt;/a&gt; infer default dtypes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d12092a100fe501656091bdf566b30b2ed9abe" translate="yes" xml:space="preserve">
          <source>If you have a code snippet that wraps multiple lines, you need to use &amp;lsquo;&amp;hellip;&amp;rsquo; on the continued lines:</source>
          <target state="translated">Si tiene un fragmento de c&amp;oacute;digo que envuelve varias l&amp;iacute;neas, debe usar '...' en las l&amp;iacute;neas continuas:</target>
        </trans-unit>
        <trans-unit id="ce1c3f4a8b1303b2233ce9f8b61542133b12817a" translate="yes" xml:space="preserve">
          <source>If you have a function that takes the data as (say) the second argument, pass a tuple indicating which keyword expects the data. For example, suppose &lt;code&gt;f&lt;/code&gt; takes its data as &lt;code&gt;arg2&lt;/code&gt;:</source>
          <target state="translated">Si tiene una funci&amp;oacute;n que toma los datos como (digamos) el segundo argumento, pase una tupla que indique qu&amp;eacute; palabra clave espera los datos. Por ejemplo, supongamos que &lt;code&gt;f&lt;/code&gt; toma sus datos como &lt;code&gt;arg2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56a4c8962933a12e5a9e2a5d7dffcb9394a6134b" translate="yes" xml:space="preserve">
          <source>If you have a really non-standard format, use a custom &lt;code&gt;date_parser&lt;/code&gt; function. For optimal performance, this should be vectorized, i.e., it should accept arrays as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bce04d77a3695fe541ba97dbace1da91706c1a3" translate="yes" xml:space="preserve">
          <source>If you have a test that would emit a warning, but you aren&amp;rsquo;t actually testing the warning itself (say because it&amp;rsquo;s going to be removed in the future, or because we&amp;rsquo;re matching a 3rd-party library&amp;rsquo;s behavior), then use &lt;code&gt;pytest.mark.filterwarnings&lt;/code&gt; to ignore the error.</source>
          <target state="translated">Si tiene una prueba que emitir&amp;iacute;a una advertencia, pero en realidad no est&amp;aacute; probando la advertencia en s&amp;iacute; (digamos, porque se eliminar&amp;aacute; en el futuro o porque estamos haciendo coincidir el comportamiento de una biblioteca de terceros), entonces use &lt;code&gt;pytest.mark.filterwarnings&lt;/code&gt; para ignorar el error.</target>
        </trans-unit>
        <trans-unit id="71117c5bba102f9e8b43378fc40f53207cd5d122" translate="yes" xml:space="preserve">
          <source>If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e53b0f81dd0d27916b9567f3537fac3de69986c" translate="yes" xml:space="preserve">
          <source>If you have created a new file, it is not being tracked by git. Add it by typing:</source>
          <target state="translated">Si has creado un nuevo archivo,no está siendo rastreado por el imbécil.Añádelo tecleando:</target>
        </trans-unit>
        <trans-unit id="15be1e2a8dd36c4d3fa91d03c09bda6ba985f358" translate="yes" xml:space="preserve">
          <source>If you have data that is outside of the &lt;code&gt;Timestamp&lt;/code&gt; bounds, see &lt;a href=&quot;#timeseries-timestamp-limits&quot;&gt;Timestamp limitations&lt;/a&gt;, then you can use a &lt;code&gt;PeriodIndex&lt;/code&gt; and/or &lt;code&gt;Series&lt;/code&gt; of &lt;code&gt;Periods&lt;/code&gt; to do computations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd3e79e7aaca2c9a3799bfafe49c89cd6d0b4f3" translate="yes" xml:space="preserve">
          <source>If you have more than one plot that needs to be suppressed, the &lt;code&gt;use&lt;/code&gt; method in &lt;code&gt;pandas.plotting.plot_params&lt;/code&gt; can be used in a &lt;code&gt;with&lt;/code&gt; statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a4ccdcf75e8833f91575d8840de48cc6dfbca8" translate="yes" xml:space="preserve">
          <source>If you have multi-index columns:</source>
          <target state="translated">Si tienes columnas de múltiples índices:</target>
        </trans-unit>
        <trans-unit id="1610c5a9f274b426003a33163f560701a7d5688a" translate="yes" xml:space="preserve">
          <source>If you have multiple conditions, you can use &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.select.html#numpy.select&quot;&gt;&lt;code&gt;numpy.select()&lt;/code&gt;&lt;/a&gt; to achieve that. Say corresponding to three conditions there are three choice of colors, with a fourth color as a fallback, you can do the following.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad80e0520119e0bea6b4d13398628db73a1bdcc" translate="yes" xml:space="preserve">
          <source>If you have uncommitted changes at the moment you want to update the branch with master, you will need to &lt;code&gt;stash&lt;/code&gt; them prior to updating (see the &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning&quot;&gt;stash docs&lt;/a&gt;). This will effectively store your changes and they can be reapplied after updating.</source>
          <target state="translated">Si tiene cambios no confirmados en el momento que desee actualizar la rama con el maestro, tendr&amp;aacute; que &lt;code&gt;stash&lt;/code&gt; ellos antes de la actualizaci&amp;oacute;n (ver los &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning&quot;&gt;documentos escondite&lt;/a&gt; ). Esto almacenar&amp;aacute; sus cambios de manera efectiva y se pueden volver a aplicar despu&amp;eacute;s de la actualizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="247d69c8f2cc4de2283149f111517ab75bb87577" translate="yes" xml:space="preserve">
          <source>If you have values approximating a cumulative distribution function, then &lt;code&gt;method='pchip'&lt;/code&gt; should work well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d3bbb491c7ab50f4e3fb55087b95818a33a2bf" translate="yes" xml:space="preserve">
          <source>If you just want to handle one column as a categorical variable (like R&amp;rsquo;s factor), you can use &lt;code&gt;df[&quot;cat_col&quot;] = pd.Categorical(df[&quot;col&quot;])&lt;/code&gt; or &lt;code&gt;df[&quot;cat_col&quot;] = df[&quot;col&quot;].astype(&quot;category&quot;)&lt;/code&gt;. For full docs on &lt;a href=&quot;../reference/api/pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;Categorical&lt;/code&gt;&lt;/a&gt;, see the &lt;a href=&quot;categorical#categorical&quot;&gt;Categorical introduction&lt;/a&gt; and the &lt;a href=&quot;../reference/arrays#api-arrays-categorical&quot;&gt;API documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ea4b81cff5c89da5d8728c0c720182331aed2b" translate="yes" xml:space="preserve">
          <source>If you know the format, use &lt;code&gt;pd.to_datetime()&lt;/code&gt;: &lt;code&gt;date_parser=lambda x: pd.to_datetime(x, format=...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a716fc818c498688ccdf097fd60bb57e60c32a5" translate="yes" xml:space="preserve">
          <source>If you know you need a NumPy array, use &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt;&lt;code&gt;to_numpy()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;numpy.asarray()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadfdb34403ad34e86a99ae41be9ea1264eab6e2" translate="yes" xml:space="preserve">
          <source>If you need additional logic to handle duplicate labels, rather than just dropping the repeats, using &lt;code&gt;groupby()&lt;/code&gt; on the index is a common trick. For example, we&amp;rsquo;ll resolve duplicates by taking the average of all rows with the same label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1285b10e07e025b0f5ded4a959a18da26d5f6127" translate="yes" xml:space="preserve">
          <source>If you need finer-grained control, you can use Python&amp;rsquo;s usual &lt;a href=&quot;https://docs.python.org/3/library/warnings.html&quot;&gt;warnings module&lt;/a&gt; to control whether a warning is ignored / raised at different places within a single test.</source>
          <target state="translated">Si necesita un control m&amp;aacute;s detallado, puede usar el &lt;a href=&quot;https://docs.python.org/3/library/warnings.html&quot;&gt;m&amp;oacute;dulo de advertencias&lt;/a&gt; habitual de Python para controlar si una advertencia se ignora / genera en diferentes lugares dentro de una sola prueba.</target>
        </trans-unit>
        <trans-unit id="56e5fa9a528ad91081e25594019830af1e89d7a2" translate="yes" xml:space="preserve">
          <source>If you need integer based selection, you should use &lt;code&gt;iloc&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9abdfc1c00b5fd40564a95fa7255b69eb7054961" translate="yes" xml:space="preserve">
          <source>If you need packages that are available to pip but not conda, then install pip, and then use pip to install those packages:</source>
          <target state="translated">Si necesita paquetes disponibles para pip pero no conda,entonces instale pip,y luego use pip para instalar esos paquetes:</target>
        </trans-unit>
        <trans-unit id="f1e4f52552e9e7307e462d0dc56ddd6709abf810" translate="yes" xml:space="preserve">
          <source>If you need the actual array backing a &lt;code&gt;Series&lt;/code&gt;, use &lt;a href=&quot;../reference/api/pandas.series.array#pandas.Series.array&quot;&gt;&lt;code&gt;Series.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bc12041bab368ec20ccfaba0caed898614b818" translate="yes" xml:space="preserve">
          <source>If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the &lt;a href=&quot;enhancingperf#enhancingperf&quot;&gt;enhancing performance&lt;/a&gt; section for some examples of this approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2163ffd026f03007f2657d1aa45cced3b636cb62" translate="yes" xml:space="preserve">
          <source>If you need to represent integers with possibly missing values, use one of the nullable-integer extension dtypes provided by pandas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6464b5756b83cd90f8547c8b9746a2e4119403d" translate="yes" xml:space="preserve">
          <source>If you need to run a benchmark, change your directory to &lt;code&gt;asv_bench/&lt;/code&gt; and run:</source>
          <target state="translated">Si necesita ejecutar un &lt;code&gt;asv_bench/&lt;/code&gt; pruebas, cambie su directorio a asv_bench / y ejecute:</target>
        </trans-unit>
        <trans-unit id="5cd75591fba8c48a6ec96f77cf45ec1114588623" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;margins=True&lt;/code&gt; to &lt;code&gt;pivot_table&lt;/code&gt;, special &lt;code&gt;All&lt;/code&gt; columns and rows will be added with partial group aggregates across the categories on the rows and columns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976af2f6fab5f0ae12fdcf76be0120e4404254cf" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;orient='index'&lt;/code&gt;, the keys will be the row labels. In this case, you can also pass the desired column names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b70868c4ee48742da635c260d8cd9f3a080b210" translate="yes" xml:space="preserve">
          <source>If you pass a Series to &lt;a href=&quot;../reference/api/pandas.dataframe.align#pandas.DataFrame.align&quot;&gt;&lt;code&gt;DataFrame.align()&lt;/code&gt;&lt;/a&gt;, you can choose to align both objects either on the DataFrame&amp;rsquo;s index or columns using the &lt;code&gt;axis&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0a373c7cc571366c10185793baa20f98905f8d" translate="yes" xml:space="preserve">
          <source>If you pass a function, it must return a value when called with any of the labels (and must produce a set of unique values). A dict or Series can also be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31c6e882d9eb5401127c01282e6bbb98c5ee31ca" translate="yes" xml:space="preserve">
          <source>If you pass a single string to &lt;code&gt;to_datetime&lt;/code&gt;, it returns a single &lt;code&gt;Timestamp&lt;/code&gt;. &lt;code&gt;Timestamp&lt;/code&gt; can also accept string input, but it doesn&amp;rsquo;t accept string parsing options like &lt;code&gt;dayfirst&lt;/code&gt; or &lt;code&gt;format&lt;/code&gt;, so use &lt;code&gt;to_datetime&lt;/code&gt; if these are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f45d99e2ee0921bed375bc8861439fdec9a9792" translate="yes" xml:space="preserve">
          <source>If you pass values whose sum total is less than 1.0, matplotlib draws a semicircle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632406b5aa18fdb674faf69296473f0d12e452b9" translate="yes" xml:space="preserve">
          <source>If you see output like the below in &lt;a href=&quot;#contributing-ci&quot;&gt;Continuous Integration&lt;/a&gt; checks:</source>
          <target state="translated">Si ve un resultado como el siguiente en las comprobaciones de &lt;a href=&quot;#contributing-ci&quot;&gt;integraci&amp;oacute;n continua&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="288307bac0582bc58303b0b714a45cbb853bef32" translate="yes" xml:space="preserve">
          <source>If you select a label &lt;em&gt;contained&lt;/em&gt; within an interval, this will also select the interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97fe72667c3b81a7bfa27ffdd0cd1ec5b244cfc6" translate="yes" xml:space="preserve">
          <source>If you use dates which start with the day first (i.e. European style), you can pass the &lt;code&gt;dayfirst&lt;/code&gt; flag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826366db7d9516e4c1549c46a4ef6fe02c423fcb" translate="yes" xml:space="preserve">
          <source>If you use locks to manage write access between multiple processes, you may want to use &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fsync&quot;&gt;&lt;code&gt;fsync()&lt;/code&gt;&lt;/a&gt; before releasing write locks. For convenience you can use &lt;code&gt;store.flush(fsync=True)&lt;/code&gt; to do this for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b6748b33160c9896abd9c3b4018432b2fa8ff70" translate="yes" xml:space="preserve">
          <source>If you want a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ed4c27edf0b54fe936d124ccd9179b9a98665c" translate="yes" xml:space="preserve">
          <source>If you want a &lt;code&gt;defaultdict&lt;/code&gt;, you need to initialize it:</source>
          <target state="translated">Si desea un &lt;code&gt;defaultdict&lt;/code&gt; , debe inicializarlo:</target>
        </trans-unit>
        <trans-unit id="da78135cd296f262655fefcba77395d1f17b8c5b" translate="yes" xml:space="preserve">
          <source>If you want literal replacement of a string (equivalent to &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.replace&quot;&gt;&lt;code&gt;str.replace()&lt;/code&gt;&lt;/a&gt;), you can set the optional &lt;code&gt;regex&lt;/code&gt; parameter to &lt;code&gt;False&lt;/code&gt;, rather than escaping each character. In this case both &lt;code&gt;pat&lt;/code&gt; and &lt;code&gt;repl&lt;/code&gt; must be strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b94aa79bc7cda927f9dd9bef83486c02c863c7" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the maximum, use &lt;code&gt;idxmax&lt;/code&gt;. This is the equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="translated">Si desea el &lt;em&gt;&amp;iacute;ndice&lt;/em&gt; del m&amp;aacute;ximo, use &lt;code&gt;idxmax&lt;/code&gt; . Este es el equivalente al m&amp;eacute;todo &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;code&gt;argmax&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da99536b7cebadbafed991dfc4d1e9297843d4f2" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the maximum, use &lt;code&gt;idxmax&lt;/code&gt;. This isthe equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b950797521b756aeaf591d6f6cec56c5160f174" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the minimum, use &lt;code&gt;idxmin&lt;/code&gt;. This is the equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmin&lt;/code&gt;.</source>
          <target state="translated">Si quieres el &lt;em&gt;&amp;iacute;ndice&lt;/em&gt; del m&amp;iacute;nimo, usa &lt;code&gt;idxmin&lt;/code&gt; . Este es el equivalente de la &lt;code&gt;numpy.ndarray&lt;/code&gt; m&amp;eacute;todo &lt;code&gt;argmin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4215c4240d2b96b95049f942871fecaec754b8c9" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the minimum, use &lt;code&gt;idxmin&lt;/code&gt;. This isthe equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324b614ff3eac5f57300aa2b07bed38fd549fbcf" translate="yes" xml:space="preserve">
          <source>If you want to adjust the start of the bins based on a fixed timestamp:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48bf81b5b17c8f77d08206ccd9d4824d6c3996e" translate="yes" xml:space="preserve">
          <source>If you want to adjust the start of the bins with an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c72be389f57078f7031a3f750835e41af8a1e4" translate="yes" xml:space="preserve">
          <source>If you want to combine categoricals that do not necessarily have the same categories,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ceed891230ae542e55ffbac52ad427e321e79a" translate="yes" xml:space="preserve">
          <source>If you want to combine categoricals that do not necessarily have the same categories, &lt;code&gt;union_categoricals&lt;/code&gt; will combine a list-like of categoricals. The new categories will be the union of the categories being combined.</source>
          <target state="translated">Si desea combinar categor&amp;iacute;as que no necesariamente tienen las mismas categor&amp;iacute;as, &lt;code&gt;union_categoricals&lt;/code&gt; combinar&amp;aacute; una lista de categor&amp;iacute;as. Las nuevas categor&amp;iacute;as ser&amp;aacute;n la uni&amp;oacute;n de las categor&amp;iacute;as que se combinan.</target>
        </trans-unit>
        <trans-unit id="f70b3672763179b3ba5414e9cc915c8902e77cfd" translate="yes" xml:space="preserve">
          <source>If you want to combine categoricals that do not necessarily have the same categories, the &lt;a href=&quot;../reference/api/pandas.api.types.union_categoricals#pandas.api.types.union_categoricals&quot;&gt;&lt;code&gt;union_categoricals()&lt;/code&gt;&lt;/a&gt; function will combine a list-like of categoricals. The new categories will be the union of the categories being combined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb077c2288f1403c4b0ecbd42403a54af7be64aa" translate="yes" xml:space="preserve">
          <source>If you want to consider &lt;code&gt;inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; to be &amp;ldquo;NA&amp;rdquo; in computations, you can set &lt;code&gt;pandas.options.mode.use_inf_as_na = True&lt;/code&gt;.</source>
          <target state="translated">Si desea considerar &lt;code&gt;inf&lt;/code&gt; y &lt;code&gt;-inf&lt;/code&gt; como &amp;ldquo;NA&amp;rdquo; en los c&amp;aacute;lculos, puede establecer &lt;code&gt;pandas.options.mode.use_inf_as_na = True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="105ffd39b32076ebf1ebd3d7165f004063f83832" translate="yes" xml:space="preserve">
          <source>If you want to do a &amp;ldquo;non-equality&amp;rdquo; comparison of a categorical series with a list-like object which is not categorical data, you need to be explicit and convert the categorical data back to the original values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a494419aff90e75a65fca5fcb99703bd1e43872" translate="yes" xml:space="preserve">
          <source>If you want to do a full clean build, do:</source>
          <target state="translated">Si quieres hacer una construcción completa y limpia,hazlo:</target>
        </trans-unit>
        <trans-unit id="9364d4a7de813e6cc040e7514a87f830c1e52fa7" translate="yes" xml:space="preserve">
          <source>If you want to do remove and add new categories in one step (which has some speed advantage), or simply set the categories to a predefined scale, use &lt;code&gt;set_categories()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="496ed137ac195eaa0b96ba47dbede5d3d45026e0" translate="yes" xml:space="preserve">
          <source>If you want to get a buffer to the parquet content you can use a io.BytesIO object, as long as you don&amp;rsquo;t use partition_cols, which creates multiple files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca2aaf5871712e332fd47e4529e86f2d40fbf9d" translate="yes" xml:space="preserve">
          <source>If you want to have more control on which packages, or have a limited internet bandwidth, then installing pandas with &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;Miniconda&lt;/a&gt; may be a better solution.</source>
          <target state="translated">Si desea tener m&amp;aacute;s control sobre qu&amp;eacute; paquetes, o tiene un ancho de banda de Internet limitado, entonces instalar pandas con &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;Miniconda&lt;/a&gt; puede ser una mejor soluci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6e630d4535a19d2c51476c3a14031d74da486a01" translate="yes" xml:space="preserve">
          <source>If you want to hide wedge labels, specify &lt;code&gt;labels=None&lt;/code&gt;. If &lt;code&gt;fontsize&lt;/code&gt; is specified, the value will be applied to wedge labels. Also, other keywords supported by &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pie.html#matplotlib.pyplot.pie&quot;&gt;&lt;code&gt;matplotlib.pyplot.pie()&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="838c6416400ccef4da44e58e719db49e883edf34" translate="yes" xml:space="preserve">
          <source>If you want to identify and remove duplicate rows in a DataFrame, there are two methods that will help: &lt;code&gt;duplicated&lt;/code&gt; and &lt;code&gt;drop_duplicates&lt;/code&gt;. Each takes as an argument the columns to use to identify duplicated rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59364a4030877526c3fb43a1076dbe047f4ce00" translate="yes" xml:space="preserve">
          <source>If you want to include &lt;strong&gt;all&lt;/strong&gt; of data categories even if the actual data does not contain any instances of a particular category, you should set &lt;code&gt;dropna=False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba39bcec7f6db4e1b09827720ef4bb35fbb65050" translate="yes" xml:space="preserve">
          <source>If you want to inspect the stored object, retrieve via &lt;code&gt;get_storer&lt;/code&gt;. You could use this programmatically to say get the number of rows in an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0960af5a9c3a1fb441fc7e6e682d503ea6726c" translate="yes" xml:space="preserve">
          <source>If you want to manage your own connections you can pass one of those instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a5a881302f9b77f030472899c0c61a452bf781" translate="yes" xml:space="preserve">
          <source>If you want to omit a dataframe&amp;rsquo;s indexes when writing, pass &lt;code&gt;index=False&lt;/code&gt; to &lt;a href=&quot;../reference/api/pandas.dataframe.to_parquet#pandas.DataFrame.to_parquet&quot;&gt;&lt;code&gt;to_parquet()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39c7a5a2ebd376e45bc4789c9e32d770747fa47" translate="yes" xml:space="preserve">
          <source>If you want to only run a specific group of tests from a file, you can do it using &lt;code&gt;.&lt;/code&gt; as a separator. For example:</source>
          <target state="translated">Si solo desea ejecutar un grupo espec&amp;iacute;fico de pruebas desde un archivo, puede hacerlo usando &lt;code&gt;.&lt;/code&gt; como separador. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="431c2f4b44553a66b404402f29529cfcdabf6d56" translate="yes" xml:space="preserve">
          <source>If you want to pass in a path object, pandas accepts any &lt;code&gt;os.PathLike&lt;/code&gt;.</source>
          <target state="translated">Si desea pasar un objeto de ruta, pandas acepta cualquier &lt;code&gt;os.PathLike&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="260a6b638018f13e44320b83a5f3393470170f1f" translate="yes" xml:space="preserve">
          <source>If you want to select the nth not-null item, use the &lt;code&gt;dropna&lt;/code&gt; kwarg. For a DataFrame this should be either &lt;code&gt;'any'&lt;/code&gt; or &lt;code&gt;'all'&lt;/code&gt; just like you would pass to dropna:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e69cf53c2f90f63fca612ceaf55108d6a7645de" translate="yes" xml:space="preserve">
          <source>If you want to show a case where an exception is raised, you can do:</source>
          <target state="translated">Si quieres mostrar un caso en el que se plantea una excepción,puedes hacerlo:</target>
        </trans-unit>
        <trans-unit id="3444f60978a55340c6fd4266fe2afeb502624670" translate="yes" xml:space="preserve">
          <source>If you want to show that &lt;code&gt;s.plot()&lt;/code&gt; returns a matplotlib AxesSubplot object, this will fail the doctest</source>
          <target state="translated">Si desea mostrar que &lt;code&gt;s.plot()&lt;/code&gt; devuelve un objeto matplotlib AxesSubplot, esto fallar&amp;aacute; en el doctest</target>
        </trans-unit>
        <trans-unit id="8341aec896361ab00c05ae9a1482550fce8e4f42" translate="yes" xml:space="preserve">
          <source>If you wish to get the 0th and the 2nd elements from the index in the &amp;lsquo;A&amp;rsquo; column, you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b6a034b92c3c225415a2cbf07b02e0810a9cdc" translate="yes" xml:space="preserve">
          <source>If you wish to keep all original rows and columns, set &lt;code&gt;keep_shape&lt;/code&gt; argument to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6fca580ca146fe1287a019a063eff316214cd98" translate="yes" xml:space="preserve">
          <source>If you wish to specify other levels (as will occasionally be the case), you can do so using the &lt;code&gt;levels&lt;/code&gt; argument:</source>
          <target state="translated">Si desea especificar otros niveles (como suceder&amp;aacute; ocasionalmente), puede hacerlo usando el argumento de &lt;code&gt;levels&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5357656a53a0ea6cda290cc82e0cca1c51833255" translate="yes" xml:space="preserve">
          <source>If you wish to write to more than one sheet in the workbook, it is necessary to specify an ExcelWriter object:</source>
          <target state="translated">Si se desea escribir en más de una hoja del libro de trabajo,es necesario especificar un objeto ExcelWriter:</target>
        </trans-unit>
        <trans-unit id="c0ac4887afa33726cb4047a790d5d629409d0a01" translate="yes" xml:space="preserve">
          <source>If you wish, you may choose to stack the differences on rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c38761c27fc078a6f71bc308a6215ee7bb40a4" translate="yes" xml:space="preserve">
          <source>If you would like pandas to be more or less trusting about assignment to a chained indexing expression, you can set the &lt;a href=&quot;options#options&quot;&gt;option&lt;/a&gt;&lt;code&gt;mode.chained_assignment&lt;/code&gt; to one of these values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6f96245d6df3c307f3f4bfc1f0124b3effe146" translate="yes" xml:space="preserve">
          <source>If you would prefer to keep the &lt;code&gt;NA&lt;/code&gt; values you can manually fill them with &lt;code&gt;fillna(True)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603667115b7f0addd355740b600caf5f30806f25" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a library that implements the interface, please publicize it on &lt;a href=&quot;../ecosystem#ecosystem-extensions&quot;&gt;Extension data types&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; creando una biblioteca que implementa la interfaz, publ&amp;iacute;quela en &lt;a href=&quot;../ecosystem#ecosystem-extensions&quot;&gt;los tipos de datos de extensi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6c8245d9d9f1878751eb8d7ab972407703ff1cf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re having trouble pasting the above into your ipython, you may need to be using bleeding edge IPython for paste to play well with cell magics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab47c63b2d6927d1db8e796a8720b53461c8e93d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re having trouble pasting the above into your ipython, you may need to be using bleeding edge ipython for paste to play well with cell magics.</source>
          <target state="translated">Si tiene problemas para pegar lo anterior en su ipython, es posible que deba usar ipython de &amp;uacute;ltima generaci&amp;oacute;n para pegar para jugar bien con la magia celular.</target>
        </trans-unit>
        <trans-unit id="8179681b12d1079bcde2bda507f3523470acc9a8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in contributing, please visit the &lt;a href=&quot;../development/contributing#contributing&quot;&gt;contributing guide&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; interesado en contribuir, visite la &lt;a href=&quot;../development/contributing#contributing&quot;&gt;gu&amp;iacute;a de contribuciones&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="954e9c7dcd852245711eafdd97aac0e41254af2a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re new to pandas, you might want to first read through &lt;a href=&quot;../10min#min&quot;&gt;10 Minutes to pandas&lt;/a&gt; to familiarize yourself with the library.</source>
          <target state="translated">Si es nuevo en pandas, es posible que desee leer primero &lt;a href=&quot;../10min#min&quot;&gt;10 Minutes to pandas&lt;/a&gt; para familiarizarse con la biblioteca.</target>
        </trans-unit>
        <trans-unit id="cf4479cf67c908330f3502d0976c6b8c094f6f72" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using IPython, tab completion for column names (as well as public attributes) is automatically enabled. Here&amp;rsquo;s a subset of the attributes that will be completed:</source>
          <target state="translated">Si est&amp;aacute; utilizando IPython, la finalizaci&amp;oacute;n de tabulaci&amp;oacute;n para los nombres de columna (as&amp;iacute; como los atributos p&amp;uacute;blicos) se habilita autom&amp;aacute;ticamente. Aqu&amp;iacute; hay un subconjunto de los atributos que se completar&amp;aacute;n:</target>
        </trans-unit>
        <trans-unit id="20447cc89f3341970de8f262a8187e6f8b87da3f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Python &amp;lt; 3.6 or pandas &amp;lt; 0.23, and an index is not passed, the &lt;code&gt;Series&lt;/code&gt; index will be the lexically ordered list of dict keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea10e2f23c35ab01a19875e0da269fdf0c5585fe" translate="yes" xml:space="preserve">
          <source>If your change involves checking that a warning is actually emitted, use &lt;code&gt;tm.assert_produces_warning(ExpectedWarning)&lt;/code&gt;.</source>
          <target state="translated">Si su cambio implica verificar que se emite realmente una advertencia, use &lt;code&gt;tm.assert_produces_warning(ExpectedWarning)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55c057d9cb3f679f9d738d6ec8fbd7a104357a59" translate="yes" xml:space="preserve">
          <source>If your code is an enhancement, it is most likely necessary to add usage examples to the existing documentation. This can be done following the section regarding documentation &lt;a href=&quot;#contributing-documentation&quot;&gt;above&lt;/a&gt;. Further, to let users know when this feature was added, the &lt;code&gt;versionadded&lt;/code&gt; directive is used. The sphinx syntax for that is:</source>
          <target state="translated">Si su c&amp;oacute;digo es una mejora, lo m&amp;aacute;s probable es que sea necesario agregar ejemplos de uso a la documentaci&amp;oacute;n existente. Esto se puede hacer siguiendo la secci&amp;oacute;n relacionada con la documentaci&amp;oacute;n &lt;a href=&quot;#contributing-documentation&quot;&gt;anterior&lt;/a&gt; . Adem&amp;aacute;s, para que los usuarios sepan cu&amp;aacute;ndo se agreg&amp;oacute; esta funci&amp;oacute;n, se utiliza la directiva &lt;code&gt;versionadded&lt;/code&gt; . La sintaxis de la esfinge para eso es:</target>
        </trans-unit>
        <trans-unit id="17297cf285c7c41a2305959b1d4993f6c38dfb8b" translate="yes" xml:space="preserve">
          <source>If your data does not follow this convention, please use the normal constructor.</source>
          <target state="translated">Si sus datos no siguen esta convención,por favor use el constructor normal.</target>
        </trans-unit>
        <trans-unit id="24ad4ea1217ea5f3ca6628c5a502cceebb4edfb0" translate="yes" xml:space="preserve">
          <source>If your desired output column names are not valid Python keywords, construct a dictionary and unpack the keyword arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cbab20b6fb2abfa92fdc4fc1f66575059d0c3b" translate="yes" xml:space="preserve">
          <source>If your style function uses a &lt;code&gt;subset&lt;/code&gt; or &lt;code&gt;axis&lt;/code&gt; keyword argument, consider wrapping your function in a &lt;code&gt;functools.partial&lt;/code&gt;, partialing out that keyword.</source>
          <target state="translated">Si su funci&amp;oacute;n de estilo usa un argumento de palabra clave de &lt;code&gt;subset&lt;/code&gt; o &lt;code&gt;axis&lt;/code&gt; , considere envolver su funci&amp;oacute;n en un &lt;code&gt;functools.partial&lt;/code&gt; , separando esa palabra clave.</target>
        </trans-unit>
        <trans-unit id="0577eb9b0205a991abdc93cdc5c980e96a949c1e" translate="yes" xml:space="preserve">
          <source>If/then logic</source>
          <target state="translated">Si/luego la lógica</target>
        </trans-unit>
        <trans-unit id="537a32d1d7729f25747f50cd67c683b5fa307d78" translate="yes" xml:space="preserve">
          <source>Ignore NaN values when inferring the type.</source>
          <target state="translated">Ignoren los valores de NaN al inferir el tipo.</target>
        </trans-unit>
        <trans-unit id="0a84d018aa4bed7f09ba656bc9b54ababd117230" translate="yes" xml:space="preserve">
          <source>Ignore differing dtypes in columns with check_dtype.</source>
          <target state="translated">Ignore los diferentes tipos en las columnas con check_dtype.</target>
        </trans-unit>
        <trans-unit id="ad9ed1e274f3db919ec0acff031892fd9c7b7466" translate="yes" xml:space="preserve">
          <source>Ignore missing values when calculating weights; specify &lt;code&gt;True&lt;/code&gt; to reproduce pre-0.15.0 behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2705a7c2d2d0fbc6c769f7fda4a47ca8dc459762" translate="yes" xml:space="preserve">
          <source>Ignore missing values when calculating weights; specify True to reproduce pre-0.15.0 behavior.</source>
          <target state="translated">Ignoren los valores perdidos al calcular los pesos;especifiquen True para reproducir el comportamiento pre-0.15.0.</target>
        </trans-unit>
        <trans-unit id="c0ff52c3b715a732da704fc6f3adeec3e1261b21" translate="yes" xml:space="preserve">
          <source>Ignoring case sensitivity using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea19abc80c5f9b9a3d69ac6d138608e64b4eae7" translate="yes" xml:space="preserve">
          <source>Ignoring case sensitivity using &lt;code&gt;flags&lt;/code&gt; with regex.</source>
          <target state="translated">Ignorando la distinci&amp;oacute;n entre may&amp;uacute;sculas y min&amp;uacute;sculas usando &lt;code&gt;flags&lt;/code&gt; con expresiones regulares.</target>
        </trans-unit>
        <trans-unit id="15a016f34e155f11682e304c096f6e7fed15242d" translate="yes" xml:space="preserve">
          <source>Ignoring indexes on the concatenation axis</source>
          <target state="translated">Ignorar los índices en el eje de concatenación</target>
        </trans-unit>
        <trans-unit id="9ffd813cd81894c96ceecf900ec3ac39d754ec33" translate="yes" xml:space="preserve">
          <source>Ignoring line comments and empty lines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c48163e8e369cc932393aa060be7a71ab51f15db" translate="yes" xml:space="preserve">
          <source>Immutable Index for period data.</source>
          <target state="translated">Índice inmutable para los datos del período.</target>
        </trans-unit>
        <trans-unit id="fa675f0928ac3d188978d143601cfaef0581eebe" translate="yes" xml:space="preserve">
          <source>Immutable Index implementing a monotonic integer range.</source>
          <target state="translated">Índice Inmutable que implementa un rango entero monótono.</target>
        </trans-unit>
        <trans-unit id="77bb5b08e773dcc647c2137be13943f11993af3a" translate="yes" xml:space="preserve">
          <source>Immutable Index implementing an ordered, sliceable set.</source>
          <target state="translated">Índice Inmutable implementando un conjunto ordenado y rebanable.</target>
        </trans-unit>
        <trans-unit id="09666a0d15aa17eade5da13deaf4058fff5e91c0" translate="yes" xml:space="preserve">
          <source>Immutable index of intervals that are closed on the same side.</source>
          <target state="translated">Índice inmutable de intervalos que se cierran en el mismo lado.</target>
        </trans-unit>
        <trans-unit id="322432105222ac065c39c51c46ac7e62258f855b" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values indicating regular periods in time such as particular years, quarters, months, etc.</source>
          <target state="translated">Ndarray inmutable que contiene valores ordinales que indican períodos regulares en el tiempo como años,trimestres,meses,etc.particulares.</target>
        </trans-unit>
        <trans-unit id="337daa08831acb19d7ba65d5abaa56b4ada8d9e9" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values indicating regular periods in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ddec45685f37191edce0f9c049167f337a12e2" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values.</source>
          <target state="translated">Ndarray inmutable con valores ordinales.</target>
        </trans-unit>
        <trans-unit id="ff5fce9b61c2b7d306def659869f8a2d0e740987" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set.</source>
          <target state="translated">Immutable ndarray implementando un conjunto ordenado y rebanable.</target>
        </trans-unit>
        <trans-unit id="632aea5fb4e51ab537ce029dad7185968ea1903b" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects.</source>
          <target state="translated">Immutable ndarray implementando un conjunto ordenado y rebanable.El objeto básico que almacena las etiquetas de los ejes para todos los objetos de los pandas.</target>
        </trans-unit>
        <trans-unit id="a1d7735d372421181df84b4198539d11f0bd5288" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. Float64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely float labels.</source>
          <target state="translated">Ndarray inmutable implementando un conjunto ordenado y divisible. El objeto b&amp;aacute;sico que almacena etiquetas de eje para todos los objetos pandas. Float64Index es un caso especial de &lt;code&gt;Index&lt;/code&gt; con etiquetas puramente flotantes.</target>
        </trans-unit>
        <trans-unit id="a63505fab2255dbaad9e67cc969dee30b7999644" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. Int64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely integer labels.</source>
          <target state="translated">Ndarray inmutable implementando un conjunto ordenado y divisible. El objeto b&amp;aacute;sico que almacena etiquetas de eje para todos los objetos pandas. Int64Index es un caso especial de &lt;code&gt;Index&lt;/code&gt; con etiquetas puramente enteras.</target>
        </trans-unit>
        <trans-unit id="e2a7d783a146ccf2aebd945545d5c4801e5a2997" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. UInt64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely unsigned integer labels.</source>
          <target state="translated">Ndarray inmutable implementando un conjunto ordenado y divisible. El objeto b&amp;aacute;sico que almacena etiquetas de eje para todos los objetos pandas. UInt64Index es un caso especial de &lt;code&gt;Index&lt;/code&gt; con etiquetas enteras sin signo.</target>
        </trans-unit>
        <trans-unit id="3f9f35d14ce44451d11a45398cd4e7e33b22d52e" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of datetime64 data, represented internally as int64, and which can be boxed to Timestamp objects that are subclasses of datetime and carry metadata such as frequency information.</source>
          <target state="translated">Ndarray inmutable de datos de fecha y hora64,representado internamente como int64,y que puede ser encajonado a los objetos Timestamp que son subclases de fecha y hora y llevan metadatos como información de frecuencia.</target>
        </trans-unit>
        <trans-unit id="a0c7ddd23ba079b38767357bd06b67a58ed2ef16" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects</source>
          <target state="translated">Ndarray inmutable de datos de timedelta64,representado internamente como int64,y que puede ser encajonado a los objetos de timedelta</target>
        </trans-unit>
        <trans-unit id="5398d1add4bca5f5b7f2b03337b3d627dd293318" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d546a7e1c870efa75e1e47b90e1203b5c50b7ac2" translate="yes" xml:space="preserve">
          <source>Immutable ndarray-like of datetime64 data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4d9fb600d19bd44b1d23393cd235ddaf172e07" translate="yes" xml:space="preserve">
          <source>Immutable object implementing an Interval, a bounded slice-like interval.</source>
          <target state="translated">Objeto inamovible que implementa un Intervalo,un intervalo delimitado en forma de rebanada.</target>
        </trans-unit>
        <trans-unit id="505bb48d000edeee874dc5be5afd4732ecdf5ebd" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127cfce9c5b60f47493c14c12a2d15589ccdb84e" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f38f448ebc934c19cecd4c61d947b66ce618345" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects. Float64Index is a special case of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9732e001aecfcbbba7d1d2226b813ee863d077" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects. Int64Index is a special case of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d0cee96f82a003d95761bdb1bea6e5c8b8bb2c" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects. UInt64Index is a special case of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b7603ab9e328ac9ecd3a57b22b14f6ba634622" translate="yes" xml:space="preserve">
          <source>Implement the sparse version of the DataFrame meaning that any data matching a specific value it&amp;rsquo;s omitted in the representation. The sparse DataFrame allows for a more efficient storage.</source>
          <target state="translated">Implemente la versi&amp;oacute;n dispersa del DataFrame, lo que significa que cualquier dato que coincida con un valor espec&amp;iacute;fico se omite en la representaci&amp;oacute;n. El DataFrame disperso permite un almacenamiento m&amp;aacute;s eficiente.</target>
        </trans-unit>
        <trans-unit id="10a2799ea91e51525dea53960078f9f6f3203aa1" translate="yes" xml:space="preserve">
          <source>Implements datetime.replace, handles nanoseconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6745b96941850a92b0edba7a6c22b838293d405" translate="yes" xml:space="preserve">
          <source>Import Stata data files.</source>
          <target state="translated">Archivos de datos importados.</target>
        </trans-unit>
        <trans-unit id="1e5491997dd74b680ce524f97d0882e687569640" translate="yes" xml:space="preserve">
          <source>Import all needed libraries (except for pandas and numpy, those are already imported as &lt;code&gt;import pandas as pd&lt;/code&gt; and &lt;code&gt;import numpy as np&lt;/code&gt;) and define all variables you use in the example.</source>
          <target state="translated">Importe todas las bibliotecas necesarias (excepto pandas y numpy, que ya se importaron como &lt;code&gt;import pandas as pd&lt;/code&gt; e &lt;code&gt;import numpy as np&lt;/code&gt; ) y defina todas las variables que use en el ejemplo.</target>
        </trans-unit>
        <trans-unit id="d23dd8370347a27e8c15358e5d3021400237aac7" translate="yes" xml:space="preserve">
          <source>Import formatting</source>
          <target state="translated">Formato de importación</target>
        </trans-unit>
        <trans-unit id="72cab777e486bd355797f7e6fdade33e9f41fd52" translate="yes" xml:space="preserve">
          <source>Import required libraries (except &lt;code&gt;numpy&lt;/code&gt; and &lt;code&gt;pandas&lt;/code&gt;)</source>
          <target state="translated">Importar bibliotecas requeridas (excepto &lt;code&gt;numpy&lt;/code&gt; y &lt;code&gt;pandas&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="8e9f5299061cd70fa083abaf2a821d53b2bf0a35" translate="yes" xml:space="preserve">
          <source>Important to notice that &lt;code&gt;df2&lt;/code&gt; will contain both</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8caa460d7e776f14562e9da5c4c08d479a40d0c1" translate="yes" xml:space="preserve">
          <source>Important to notice that &lt;code&gt;df2&lt;/code&gt; will contain both &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; for the same input, &amp;lsquo;1&amp;rsquo;.</source>
          <target state="translated">Es importante notar que &lt;code&gt;df2&lt;/code&gt; contendr&amp;aacute; &lt;code&gt;str&lt;/code&gt; e &lt;code&gt;int&lt;/code&gt; para la misma entrada, '1'.</target>
        </trans-unit>
        <trans-unit id="5f3ec8323e548daf8dafc731adcf0f495f9f93cb" translate="yes" xml:space="preserve">
          <source>Importantly, a list of tuples indexes several complete &lt;code&gt;MultiIndex&lt;/code&gt; keys, whereas a tuple of lists refer to several values within a level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4595506130e2cf8db40b1b6430ef7e36fa5cf73" translate="yes" xml:space="preserve">
          <source>Imports are alphabetically sorted within these sections.</source>
          <target state="translated">Las importaciones están ordenadas alfabéticamente dentro de estas secciones.</target>
        </trans-unit>
        <trans-unit id="8982a4b2f79ddf31cda90fa02617abd56244f09b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;missing_data#missing-data&quot;&gt;Working with missing data&lt;/a&gt;, we saw that pandas primarily uses &lt;code&gt;NaN&lt;/code&gt; to represent missing data. Because &lt;code&gt;NaN&lt;/code&gt; is a float, this forces an array of integers with any missing values to become floating point. In some cases, this may not matter much. But if your integer column is, say, an identifier, casting to float can be problematic. Some integers cannot even be represented as floating point numbers.</source>
          <target state="translated">En &lt;a href=&quot;missing_data#missing-data&quot;&gt;Trabajar con datos faltantes&lt;/a&gt; , vimos que los pandas utilizan principalmente &lt;code&gt;NaN&lt;/code&gt; para representar los datos faltantes. Debido a que &lt;code&gt;NaN&lt;/code&gt; es un flotante, esto obliga a una matriz de enteros con cualquier valor perdido a convertirse en punto flotante. En algunos casos, esto puede no importar mucho. Pero si su columna de enteros es, digamos, un identificador, la conversi&amp;oacute;n a flotante puede ser problem&amp;aacute;tica. Algunos enteros ni siquiera se pueden representar como n&amp;uacute;meros de coma flotante.</target>
        </trans-unit>
        <trans-unit id="555d2dfae47903c8bd58329d13a61da63add288b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;and&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e52f1bacd4f24deb022009e6cbcfc6777c66aa9" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;boxplot&lt;/code&gt;, the return type can be controlled by the &lt;code&gt;return_type&lt;/code&gt;, keyword. The valid choices are &lt;code&gt;{&quot;axes&quot;, &quot;dict&quot;, &quot;both&quot;, None}&lt;/code&gt;. Faceting, created by &lt;code&gt;DataFrame.boxplot&lt;/code&gt; with the &lt;code&gt;by&lt;/code&gt; keyword, will affect the output type as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a852e68eeb631ade0cef03cf874abce1f81c9e7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;or&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097ba133ee7ab96717f7a5a56ab8a4beb1aa23eb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;pytz&lt;/code&gt; you can find a list of common (and less common) time zones using &lt;code&gt;from pytz import common_timezones, all_timezones&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe401f5c64aba5b5ac112f3a745ea229c800ebf" translate="yes" xml:space="preserve">
          <source>In Python 2 replacing the &lt;code&gt;range&lt;/code&gt; with its generator counterpart (&lt;code&gt;xrange&lt;/code&gt;) would mean the &lt;code&gt;range&lt;/code&gt; line would vanish. In Python 3 &lt;code&gt;range&lt;/code&gt; is already a generator.</source>
          <target state="translated">En Python 2, reemplazar el &lt;code&gt;range&lt;/code&gt; con su contraparte del generador ( &lt;code&gt;xrange&lt;/code&gt; ) significar&amp;iacute;a que la l&amp;iacute;nea de &lt;code&gt;range&lt;/code&gt; desaparecer&amp;iacute;a. En Python 3 el &lt;code&gt;range&lt;/code&gt; ya es un generador.</target>
        </trans-unit>
        <trans-unit id="da0a8b268dc3a515b0c25d7910a12354f6dbce4d" translate="yes" xml:space="preserve">
          <source>In Python 3.6+, you can create multiple columns within the same assign where one of the columns depends on another one defined within the same assign:</source>
          <target state="translated">En Python 3.6+,se pueden crear múltiples columnas dentro de la misma asignación donde una de las columnas depende de otra definida dentro de la misma asignación:</target>
        </trans-unit>
        <trans-unit id="907e8abd6c8723d202c63be6f377cf83483ea444" translate="yes" xml:space="preserve">
          <source>In R this file can be read into a &lt;code&gt;data.frame&lt;/code&gt; object using the &lt;code&gt;rhdf5&lt;/code&gt; library. The following example function reads the corresponding column names and data values from the values and assembles them into a &lt;code&gt;data.frame&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01750648f39249d22ad4fc3c3a3a8334f0b9fee0" translate="yes" xml:space="preserve">
          <source>In SAS, if/then logic can be used to create new columns.</source>
          <target state="translated">En el SAS,si/luego la lógica puede ser usada para crear nuevas columnas.</target>
        </trans-unit>
        <trans-unit id="ca39c6fc3d7d80268fd46f392c1dc4b249e34950" translate="yes" xml:space="preserve">
          <source>In SQL, selection is done using a comma-separated list of columns you&amp;rsquo;d like to select (or a &lt;code&gt;*&lt;/code&gt; to select all columns):</source>
          <target state="translated">En SQL, la selecci&amp;oacute;n se realiza mediante una lista de columnas separadas por comas que le gustar&amp;iacute;a seleccionar (o un &lt;code&gt;*&lt;/code&gt; para seleccionar todas las columnas):</target>
        </trans-unit>
        <trans-unit id="877c9547b65141215299da5fbdfe17f3178aa51f" translate="yes" xml:space="preserve">
          <source>In Series and DataFrame, the arithmetic functions have the option of inputting a &lt;em&gt;fill_value&lt;/em&gt;, namely a value to substitute when at most one of the values at a location are missing. For example, when adding two DataFrame objects, you may wish to treat NaN as 0 unless both DataFrames are missing that value, in which case the result will be NaN (you can later replace NaN with some other value using &lt;code&gt;fillna&lt;/code&gt; if you wish).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2683c2af6d69c783f5e1c2c60c2fb95add6385" translate="yes" xml:space="preserve">
          <source>In Stata, an &lt;code&gt;if&lt;/code&gt; clause can also be used to create new columns.</source>
          <target state="translated">En Stata, tambi&amp;eacute;n se puede utilizar una cl&amp;aacute;usula &lt;code&gt;if&lt;/code&gt; para crear nuevas columnas.</target>
        </trans-unit>
        <trans-unit id="4fca911336b8e64fe53b3d338ac822c1038ec5cd" translate="yes" xml:space="preserve">
          <source>In Stata, arbitrary math expressions can be used with the &lt;code&gt;generate&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; commands on new or existing columns. The &lt;code&gt;drop&lt;/code&gt; command drops the column from the data set.</source>
          <target state="translated">En Stata, se pueden usar expresiones matem&amp;aacute;ticas arbitrarias con los comandos de &lt;code&gt;generate&lt;/code&gt; y &lt;code&gt;replace&lt;/code&gt; en columnas nuevas o existentes. El comando &lt;code&gt;drop&lt;/code&gt; quita la columna del conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="a485b7b38ddc54d065958b69c383566407ee3e76" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SparseDataFrame&lt;/code&gt;, &lt;em&gt;all&lt;/em&gt; columns were sparse. A &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; can have a mixture of sparse and dense columns. As a consequence, assigning new columns to a &lt;code&gt;DataFrame&lt;/code&gt; with sparse values will not automatically convert the input to be sparse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25885b0cb342fdce61ba57e7af9bc59a044474ea" translate="yes" xml:space="preserve">
          <source>In a current or later Python session, you can retrieve stored objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c635720f72e69b069f2ad905af2503cd996e22" translate="yes" xml:space="preserve">
          <source>In a special case, quotes that make a pair around a backtick can confuse the parser. For example, &lt;code&gt;`it's` &amp;gt; `that's`&lt;/code&gt; will raise an error, as it forms a quoted string (&lt;code&gt;'s &amp;gt; `that'&lt;/code&gt;) with a backtick inside.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92016604a38d8c1c1b602e884aa0580151d6703" translate="yes" xml:space="preserve">
          <source>In addition to accepting an integer or offset as a &lt;code&gt;window&lt;/code&gt; argument, &lt;code&gt;rolling&lt;/code&gt; also accepts a &lt;code&gt;BaseIndexer&lt;/code&gt; subclass that allows a user to define a custom method for calculating window bounds. The &lt;code&gt;BaseIndexer&lt;/code&gt; subclass will need to define a &lt;code&gt;get_window_bounds&lt;/code&gt; method that returns a tuple of two arrays, the first being the starting indices of the windows and second being the ending indices of the windows. Additionally, &lt;code&gt;num_values&lt;/code&gt;, &lt;code&gt;min_periods&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, &lt;code&gt;closed&lt;/code&gt; and will automatically be passed to &lt;code&gt;get_window_bounds&lt;/code&gt; and the defined method must always accept these arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936eee8f2267eff6f3fed4ea5b56ef617d250c89" translate="yes" xml:space="preserve">
          <source>In addition to following the steps in this tutorial, users interested in enhancing performance are highly encouraged to install the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/getting_started/install.html#install-recommended-dependencies&quot;&gt;recommended dependencies&lt;/a&gt; for pandas. These dependencies are often not installed by default, but will offer speed improvements if present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63de287fe4a4658bb5a80280e4fa5c2bfd3ca20" translate="yes" xml:space="preserve">
          <source>In addition to object conversion, &lt;a href=&quot;../reference/api/pandas.to_numeric#pandas.to_numeric&quot;&gt;&lt;code&gt;to_numeric()&lt;/code&gt;&lt;/a&gt; provides another argument &lt;code&gt;downcast&lt;/code&gt;, which gives the option of downcasting the newly (or already) numeric data to a smaller dtype, which can conserve memory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d11d83548d7a8bd3e2260ac358ac93abc83c24" translate="yes" xml:space="preserve">
          <source>In addition to text/csv and Stata files, pandas supports a variety of other data formats such as Excel, SAS, HDF5, Parquet, and SQL databases. These are all read via a &lt;code&gt;pd.read_*&lt;/code&gt; function. See the &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Adem&amp;aacute;s de los archivos de texto / csv y Stata, pandas admite una variedad de otros formatos de datos como Excel, SAS, HDF5, Parquet y bases de datos SQL. Todos estos se leen mediante una funci&amp;oacute;n &lt;code&gt;pd.read_*&lt;/code&gt; . Consulte la &lt;a href=&quot;../../user_guide/io#io&quot;&gt;documentaci&amp;oacute;n de IO&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="4b35d4c53f87e1ec5baecbdbc6b0b27f79f9dad9" translate="yes" xml:space="preserve">
          <source>In addition to text/csv, pandas supports a variety of other data formats such as Excel, HDF5, and SQL databases. These are all read via a &lt;code&gt;pd.read_*&lt;/code&gt; function. See the &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Adem&amp;aacute;s de text / csv, pandas admite una variedad de otros formatos de datos como Excel, HDF5 y bases de datos SQL. Todos estos se leen mediante una funci&amp;oacute;n &lt;code&gt;pd.read_*&lt;/code&gt; . Consulte la &lt;a href=&quot;../../user_guide/io#io&quot;&gt;documentaci&amp;oacute;n de IO&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="2fa15bcbd59eff23d62eafdefa1f3a939cba9e8d" translate="yes" xml:space="preserve">
          <source>In addition to that, &lt;code&gt;MultiIndex&lt;/code&gt; allows selecting a separate level to use in the membership check:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e488502fc61ee071297be900543941c302873763" translate="yes" xml:space="preserve">
          <source>In addition to the required datetime string, a &lt;code&gt;format&lt;/code&gt; argument can be passed to ensure specific parsing. This could also potentially speed up the conversion considerably.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f194ff577d3246f42a365dc02ca65f2f46a8b57" translate="yes" xml:space="preserve">
          <source>In addition to the top level &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt; function you can also evaluate an expression in the &amp;ldquo;context&amp;rdquo; of a &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de la funci&amp;oacute;n &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; nivel superior, tambi&amp;eacute;n puede evaluar una expresi&amp;oacute;n en el &quot;contexto&quot; de un &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="344220efeaea8bac8f88606648dc5f32ff74a82e" translate="yes" xml:space="preserve">
          <source>In addition to these &lt;code&gt;kind&lt;/code&gt; s, there are the &lt;a href=&quot;#visualization-hist&quot;&gt;DataFrame.hist()&lt;/a&gt;, and &lt;a href=&quot;#visualization-box&quot;&gt;DataFrame.boxplot()&lt;/a&gt; methods, which use a separate interface.</source>
          <target state="translated">Adem&amp;aacute;s de estos &lt;code&gt;kind&lt;/code&gt; , existen los &lt;a href=&quot;#visualization-hist&quot;&gt;m&amp;eacute;todos DataFrame.hist ()&lt;/a&gt; y &lt;a href=&quot;#visualization-box&quot;&gt;DataFrame.boxplot ()&lt;/a&gt; , que utilizan una interfaz separada.</target>
        </trans-unit>
        <trans-unit id="2ef7225efe8be70a38588aff72833171774ac432" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;where&lt;/code&gt; takes an optional &lt;code&gt;other&lt;/code&gt; argument for replacement of values where the condition is False, in the returned copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7ff888cd67986fa3c15b5083cd5f831adcd6a1" translate="yes" xml:space="preserve">
          <source>In addition, Unicode characters whose width is &amp;ldquo;Ambiguous&amp;rdquo; can either be 1 or 2 characters wide depending on the terminal setting or encoding. The option &lt;code&gt;display.unicode.ambiguous_as_wide&lt;/code&gt; can be used to handle the ambiguity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461cd1c60765166195c8d8ff831032d5cc889866" translate="yes" xml:space="preserve">
          <source>In addition, because a lot of people use our library, it is important that we do not make sudden changes to the code that could have the potential to break a lot of user code as a result, that is, we need it to be as &lt;em&gt;backwards compatible&lt;/em&gt; as possible to avoid mass breakages.</source>
          <target state="translated">Adem&amp;aacute;s, debido a que mucha gente usa nuestra biblioteca, es importante que no hagamos cambios repentinos en el c&amp;oacute;digo que podr&amp;iacute;an tener el potencial de romper una gran cantidad de c&amp;oacute;digo de usuario como resultado, es decir, necesitamos que sea tan &lt;em&gt;compatible con versiones anteriores&lt;/em&gt; posible para evitar roturas masivas.</target>
        </trans-unit>
        <trans-unit id="6ec024bfe3b45af422e3ecb72973bb611c9bf681" translate="yes" xml:space="preserve">
          <source>In addition, downcasting will only occur if the size of the resulting data&amp;rsquo;s dtype is strictly larger than the dtype it is to be cast to, so if none of the dtypes checked satisfy that specification, no downcasting will be performed on the data.</source>
          <target state="translated">Adem&amp;aacute;s, el downcasting solo ocurrir&amp;aacute; si el tama&amp;ntilde;o del dtype de los datos resultantes es estrictamente mayor que el dtype al que se va a convertir, por lo que si ninguno de los dtypes marcados satisface esa especificaci&amp;oacute;n, no se realizar&amp;aacute; ning&amp;uacute;n downcasting en los datos.</target>
        </trans-unit>
        <trans-unit id="5fc9b4cee9d4013aab9b23ecb620605ef783cea3" translate="yes" xml:space="preserve">
          <source>In addition, pandas also provides utilities to compare two Series or DataFrame and summarize their differences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dd64e14727048112de8dad7d43482313ba396c" translate="yes" xml:space="preserve">
          <source>In addition, you can perform assignment of columns within an expression. This allows for &lt;em&gt;formulaic evaluation&lt;/em&gt;. The assignment target can be a new column name or an existing column name, and it must be a valid Python identifier.</source>
          <target state="translated">Adem&amp;aacute;s, puede realizar la asignaci&amp;oacute;n de columnas dentro de una expresi&amp;oacute;n. Esto permite una &lt;em&gt;evaluaci&amp;oacute;n formulada&lt;/em&gt; . El destino de la asignaci&amp;oacute;n puede ser un nombre de columna nuevo o un nombre de columna existente, y debe ser un identificador de Python v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="cbe0930be96da940e74db577618b77c18b9ac4bd" translate="yes" xml:space="preserve">
          <source>In all, we&amp;rsquo;ve reduced the in-memory footprint of this dataset to 1/5 of its original size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f5ff527a5832e386d2fa919bb55a7946b3f099b" translate="yes" xml:space="preserve">
          <source>In any of these cases, standard indexing will still work, e.g. &lt;code&gt;s['1']&lt;/code&gt;, &lt;code&gt;s['min']&lt;/code&gt;, and &lt;code&gt;s['index']&lt;/code&gt; will access the corresponding element or column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37f34cfe50312c2a03cda42e1c85d47a9f3b53e" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;subplots=True&lt;/code&gt;, share x axis and set some x axis labels to invisible; defaults to True if ax is None otherwise False if an ax is passed in; Be aware, that passing in both an ax and &lt;code&gt;sharex=True&lt;/code&gt; will alter all x axis labels for all axis in a figure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259ff876d5b3d5405f39041292d56dab1977340a" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;subplots=True&lt;/code&gt;, share y axis and set some y axis labels to invisible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd532ff8699d514dc2c1ce70655231461c01cdd0" translate="yes" xml:space="preserve">
          <source>In case of a MultiIndex, only rename labels in the specified level.</source>
          <target state="translated">En el caso de un MultiIndex,sólo renombra las etiquetas en el nivel especificado.</target>
        </trans-unit>
        <trans-unit id="82d44e95df31ef34cd50671cd671f7030bd91cea" translate="yes" xml:space="preserve">
          <source>In case of a key partially contained in a MultiIndex, indicate which levels are used. Levels can be referred by label or position.</source>
          <target state="translated">En el caso de una clave parcialmente contenida en un índice múltiple,indique los niveles que se utilizan.Los niveles pueden ser referidos por etiqueta o posición.</target>
        </trans-unit>
        <trans-unit id="fb7330f48df29ed5326f3bb15396cd90585fabe1" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1052f0d8e2c2e12c931a4c0074d4560c46bfb585" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and &lt;code&gt;large_repr&lt;/code&gt; equals &amp;lsquo;truncate&amp;rsquo; this can be set to 0 and pandas will auto-detect the height of the terminal and print a truncated object which fits the screen height. The IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to do correct auto-detection. [default: 60] [currently: 15]display.max_seq_items : int or None when pretty-printing a long sequence, no more then &lt;code&gt;max_seq_items&lt;/code&gt; will be printed. If items are omitted, they will be denoted by the addition of &amp;ldquo;&amp;hellip;&amp;rdquo; to the resulting string.</source>
          <target state="translated">En caso de que python / IPython se est&amp;eacute; ejecutando en una terminal y &lt;code&gt;large_repr&lt;/code&gt; sea igual a 'truncar', esto se puede configurar en 0 y los pandas detectar&amp;aacute;n autom&amp;aacute;ticamente la altura de la terminal e imprimir&amp;aacute;n un objeto truncado que se ajuste a la altura de la pantalla. El cuaderno IPython, IPython qtconsole o IDLE no se ejecutan en una terminal y, por lo tanto, no es posible realizar una detecci&amp;oacute;n autom&amp;aacute;tica correcta. [predeterminado: 60] [actualmente: 15] display.max_seq_items: int o None cuando se imprime con estilo una secuencia larga, no se &lt;code&gt;max_seq_items&lt;/code&gt; m&amp;aacute;s de max_seq_items . Si se omiten elementos, se indicar&amp;aacute;n mediante la adici&amp;oacute;n de &quot;...&quot; a la cadena resultante.</target>
        </trans-unit>
        <trans-unit id="88dc0ceb9b4e5ade156f2fb19973b762c584b547" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and &lt;code&gt;large_repr&lt;/code&gt; equals &amp;lsquo;truncate&amp;rsquo; this can be set to 0 and pandas will auto-detect the width of the terminal and print a truncated object which fits the screen width. The IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to do correct auto-detection. [default: 0] [currently: 0]display.max_colwidth : int The maximum width in characters of a column in the repr of a pandas data structure. When the column overflows, a &amp;ldquo;&amp;hellip;&amp;rdquo; placeholder is embedded in the output. [default: 50] [currently: 50]display.max_info_columns : int max_info_columns is used in DataFrame.info method to decide if per column information will be printed. [default: 100] [currently: 100]display.max_info_rows : int or None df.info() will usually show null-counts for each column. For large frames this can be quite slow. max_info_rows and max_info_cols limit this null check only to frames with smaller dimensions than specified. [default: 1690785] [currently: 1690785]display.max_rows : int If max_rows is exceeded, switch to truncate view. Depending on &lt;code&gt;large_repr&lt;/code&gt;, objects are either centrally truncated or printed as a summary view. &amp;lsquo;None&amp;rsquo; value means unlimited.</source>
          <target state="translated">En caso de que python / IPython se est&amp;eacute; ejecutando en una terminal y &lt;code&gt;large_repr&lt;/code&gt; es igual a 'truncar', esto se puede establecer en 0 y los pandas detectar&amp;aacute;n autom&amp;aacute;ticamente el ancho del terminal e imprimir&amp;aacute;n un objeto truncado que se ajuste al ancho de la pantalla. El cuaderno IPython, IPython qtconsole o IDLE no se ejecutan en una terminal y, por lo tanto, no es posible realizar una detecci&amp;oacute;n autom&amp;aacute;tica correcta. [predeterminado: 0] [actualmente: 0] display.max_colwidth: int El ancho m&amp;aacute;ximo en caracteres de una columna en la repr de una estructura de datos de pandas. Cuando la columna se desborda, se incrusta un marcador de posici&amp;oacute;n &quot;...&quot; en la salida. [predeterminado: 50] [actualmente: 50] display.max_info_columns: int max_info_columns se usa en el m&amp;eacute;todo DataFrame.info para decidir si se imprimir&amp;aacute; la informaci&amp;oacute;n por columna. [predeterminado: 100] [actualmente: 100] display.max_info_rows: int o None df.info () normalmente mostrar&amp;aacute; recuentos nulos para cada columna. Para cuadros grandes, esto puede ser bastante lento.max_info_rows y max_info_cols limitan esta verificaci&amp;oacute;n nula solo a marcos con dimensiones m&amp;aacute;s peque&amp;ntilde;as que las especificadas. [predeterminado: 1690785] [actualmente: 1690785] display.max_rows: int Si se excede max_rows, cambie a la vista truncada. Dependiendo de &lt;code&gt;large_repr&lt;/code&gt; , los objetos se truncan centralmente o se imprimen como una vista de resumen. El valor 'Ninguno' significa ilimitado.</target>
        </trans-unit>
        <trans-unit id="8e35d288cb0c579433cc89556209e4bed46e672a" translate="yes" xml:space="preserve">
          <source>In case subplots=True, share x axis and set some x axis labels to invisible; defaults to True if ax is None otherwise False if an ax is passed in. Note that passing in both an ax and sharex=True will alter all x axis labels for all subplots in a figure.</source>
          <target state="translated">En el caso de subtramas=True,comparte el eje x y establece algunas etiquetas del eje x como invisibles;por defecto es True si el eje es None,de lo contrario es False si se pasa un eje.Tenga en cuenta que al pasar un ax y sharex=True se alterarán todas las etiquetas del eje x de todas las subparcelas de una figura.</target>
        </trans-unit>
        <trans-unit id="13d4a95cd38f900c3ec733f1670b49419dc85c00" translate="yes" xml:space="preserve">
          <source>In case subplots=True, share y axis and set some y axis labels to invisible.</source>
          <target state="translated">En el caso de subtramas=Verdad,compartir el eje y y establecer algunas etiquetas del eje y como invisibles.</target>
        </trans-unit>
        <trans-unit id="0d9d818756c135822b8f3d3ecf8891eb81a47a9f" translate="yes" xml:space="preserve">
          <source>In case there is a tie, the lexicographical sorting looks at the next level of the MultiIndex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde29dc4b9128386ba4e2d708cd826477c4917e9" translate="yes" xml:space="preserve">
          <source>In case when it is not possible to return designated types (e.g. when any element of input is before Timestamp.min or after Timestamp.max) return will have datetime.datetime type (or corresponding array/Series).</source>
          <target state="translated">En caso de que no sea posible devolver los tipos designados (por ejemplo,cuando cualquier elemento de entrada es antes de Timestamp.min o después de Timestamp.max)la devolución tendrá el tipo datetime.datetime (o la matriz/serie correspondiente).</target>
        </trans-unit>
        <trans-unit id="2d98b509261df46a77d5170a3ea614953001361f" translate="yes" xml:space="preserve">
          <source>In case where there are just a set of values allowed, list them in curly brackets and separated by commas (followed by a space). If the values are ordinal and they have an order, list them in this order. Otherwise, list the default value first, if there is one:</source>
          <target state="translated">En caso de que sólo se permita un conjunto de valores,enumérelos entre corchetes y separados por comas (seguidos de un espacio).Si los valores son ordinales y tienen un orden,enumérelos en este orden.En caso contrario,enumere primero el valor por defecto,si lo hay:</target>
        </trans-unit>
        <trans-unit id="3faa60af9b3f807fffd055e96cd73d0da7d66524" translate="yes" xml:space="preserve">
          <source>In cases where the default value is &lt;code&gt;None&lt;/code&gt;, meaning that the value will not be used. Instead of &amp;ldquo;str, default None&amp;rdquo;, it is preferred to write &amp;ldquo;str, optional&amp;rdquo;. When &lt;code&gt;None&lt;/code&gt; is a value being used, we will keep the form &amp;ldquo;str, default None&amp;rdquo;. For example, in &lt;code&gt;df.to_csv(compression=None)&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is not a value being used, but means that compression is optional, and no compression is being used if not provided. In this case we will use &lt;code&gt;str, optional&lt;/code&gt;. Only in cases like &lt;code&gt;func(value=None)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; is being used in the same way as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;foo&lt;/code&gt; would be used, then we will specify &amp;ldquo;str, int or None, default None&amp;rdquo;.</source>
          <target state="translated">En los casos en que el valor predeterminado es &lt;code&gt;None&lt;/code&gt; , lo que significa que el valor no se utilizar&amp;aacute;. En lugar de &quot;str, por defecto Ninguno&quot;, se prefiere escribir &quot;str, opcional&quot;. Cuando &lt;code&gt;None&lt;/code&gt; es un valor que se est&amp;aacute; utilizando, mantendremos el formato &quot;str, predeterminado Ninguno&quot;. Por ejemplo, en &lt;code&gt;df.to_csv(compression=None)&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; no es un valor que se utiliza, pero significa que la compresi&amp;oacute;n es opcional y no se utiliza compresi&amp;oacute;n si no se proporciona. En este caso usaremos &lt;code&gt;str, optional&lt;/code&gt; . Solo en casos como &lt;code&gt;func(value=None)&lt;/code&gt; y &lt;code&gt;None&lt;/code&gt; se est&amp;aacute; usando de la misma manera que se usar&amp;iacute;a &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;foo&lt;/code&gt; , entonces especificaremos &amp;ldquo;str, int o None, por defecto None&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="31fa9361b97b46ead5543693c00a21a41800c4f9" translate="yes" xml:space="preserve">
          <source>In comparison operations, &lt;a href=&quot;../reference/api/pandas.arrays.stringarray#pandas.arrays.StringArray&quot;&gt;&lt;code&gt;arrays.StringArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Series&lt;/code&gt; backed by a &lt;code&gt;StringArray&lt;/code&gt; will return an object with &lt;a href=&quot;../reference/api/pandas.booleandtype#pandas.BooleanDtype&quot;&gt;&lt;code&gt;BooleanDtype&lt;/code&gt;&lt;/a&gt;, rather than a &lt;code&gt;bool&lt;/code&gt; dtype object. Missing values in a &lt;code&gt;StringArray&lt;/code&gt; will propagate in comparison operations, rather than always comparing unequal like &lt;code&gt;numpy.nan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
