<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="d174eaad0823043371c5b288b8705217853f594b" translate="yes" xml:space="preserve">
          <source>While middleware can be used for a variety of things, including asynchronous API calls, it's really important that you understand where it comes from. We'll guide you through the thought process leading to middleware, by using logging and crash reporting as examples.</source>
          <target state="translated">Aunque el middleware se puede usar para una variedad de cosas,incluyendo llamadas asincrónicas a la API,es realmente importante que entiendas de dónde viene.Le guiaremos a través del proceso de pensamiento que conduce al middleware,utilizando el registro y el informe de fallos como ejemplos.</target>
        </trans-unit>
        <trans-unit id="5ad63caddc89503ad9515ff6b17c9b9ddad8c44b" translate="yes" xml:space="preserve">
          <source>While there's no single definitive answer to this, most of the time this should not be a concern in either case.</source>
          <target state="translated">Aunque no hay una única respuesta definitiva a esto,la mayoría de las veces no debería ser una preocupación en ninguno de los dos casos.</target>
        </trans-unit>
        <trans-unit id="baecaba85a30f210b6df40e0df3b4579a527b679" translate="yes" xml:space="preserve">
          <source>Why do we even overwrite &lt;code&gt;dispatch&lt;/code&gt;? Of course, to be able to call it later, but there's also another reason: so that every middleware can access (and call) the previously wrapped &lt;code&gt;store.dispatch&lt;/code&gt;:</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; incluso sobrescribimos el &lt;code&gt;dispatch&lt;/code&gt; ? Por supuesto, para poder llamarlo m&amp;aacute;s tarde, pero tambi&amp;eacute;n hay otra raz&amp;oacute;n: para que cada middleware pueda acceder (y llamar) al &lt;code&gt;store.dispatch&lt;/code&gt; empaquetado previamente :</target>
        </trans-unit>
        <trans-unit id="8f16b35538e53672818a41ec6538a37dcb3ab3da" translate="yes" xml:space="preserve">
          <source>Why does React-Redux shallowly check each value within the props object returned from &lt;code&gt;mapStateToProp&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; React-Redux verifica superficialmente cada valor dentro del objeto props devuelto por &lt;code&gt;mapStateToProp&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="94db3c68fc052fe95a3526f89400cbf7608c18b8" translate="yes" xml:space="preserve">
          <source>Why does Redux&amp;rsquo;s use of shallow equality checking require immutability?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; el uso de Redux de verificaci&amp;oacute;n de igualdad superficial requiere inmutabilidad?</target>
        </trans-unit>
        <trans-unit id="1e3c854da8974033215e1fa6680270278cfeb926" translate="yes" xml:space="preserve">
          <source>Why does a reducer mutating the state prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="translated">¿Por qué un reductor que muta el estado impide que React-Redux vuelva a fabricar un componente envuelto?</target>
        </trans-unit>
        <trans-unit id="8ee3c091a66db76035f8a4ca74463446e1e64e6a" translate="yes" xml:space="preserve">
          <source>Why does a selector mutating and returning a persistent object to &lt;code&gt;mapStateToProps&lt;/code&gt; prevent React-Redux from re-rendering a wrapped component?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; un selector que muta y devuelve un objeto persistente a &lt;code&gt;mapStateToProps&lt;/code&gt; evita que React-Redux vuelva a renderizar un componente empaquetado?</target>
        </trans-unit>
        <trans-unit id="644fb85f7f965c72f4406c2ac164f794580f3172" translate="yes" xml:space="preserve">
          <source>Why don't I have &lt;code&gt;this.props.dispatch&lt;/code&gt; available in my connected component?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; no tengo &lt;code&gt;this.props.dispatch&lt;/code&gt; disponible en mi componente conectado?</target>
        </trans-unit>
        <trans-unit id="9070dbd8c65265905f9ee4a7b2376e7eafe21a53" translate="yes" xml:space="preserve">
          <source>Why don't I have this.props.dispatch available in my connected component?</source>
          <target state="translated">¿Por qué no tengo este despacho de utilería disponible en mi componente conectado?</target>
        </trans-unit>
        <trans-unit id="187fff4819a25361b7b72220761e6b7a66afabd9" translate="yes" xml:space="preserve">
          <source>Why is immutability required by Redux?</source>
          <target state="translated">¿Por qué se requiere la inmutabilidad en el Redux?</target>
        </trans-unit>
        <trans-unit id="ef930e2cf88a5db6b834d3fe1be3317cae525972" translate="yes" xml:space="preserve">
          <source>Why is immutability required in Redux?</source>
          <target state="translated">¿Por qué se requiere la inmutabilidad en el Redux?</target>
        </trans-unit>
        <trans-unit id="8bcdba5809f1620e1841e83e3768ab2d2842bcd2" translate="yes" xml:space="preserve">
          <source>Why is it &lt;code&gt;42&lt;/code&gt;, and not &lt;code&gt;0&lt;/code&gt;, this time? Because &lt;code&gt;createStore&lt;/code&gt; was called with &lt;code&gt;42&lt;/code&gt; as the second argument. This argument becomes the &lt;code&gt;state&lt;/code&gt; passed to your reducer along with the dummy action. &lt;strong&gt;This time, &lt;code&gt;state&lt;/code&gt; is not undefined (it's &lt;code&gt;42&lt;/code&gt;!), so ES6 default argument syntax has no effect.&lt;/strong&gt; The &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;42&lt;/code&gt;, and &lt;code&gt;42&lt;/code&gt; is returned from the reducer.</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; es &lt;code&gt;42&lt;/code&gt; , y no &lt;code&gt;0&lt;/code&gt; , esta vez? Porque se llam&amp;oacute; a &lt;code&gt;createStore&lt;/code&gt; con &lt;code&gt;42&lt;/code&gt; como segundo argumento. Este argumento se convierte en el &lt;code&gt;state&lt;/code&gt; pasado a su reductor junto con la acci&amp;oacute;n ficticia. &lt;strong&gt;Esta vez, el &lt;code&gt;state&lt;/code&gt; no est&amp;aacute; indefinido (&amp;iexcl;es &lt;code&gt;42&lt;/code&gt; !), Por lo que la sintaxis del argumento predeterminado de ES6 no tiene ning&amp;uacute;n efecto. &lt;/strong&gt;El &lt;code&gt;state&lt;/code&gt; es &lt;code&gt;42&lt;/code&gt; , y el reductor devuelve &lt;code&gt;42&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d09f931d0864d72b3013ba7e135c68d6b2c0d13" translate="yes" xml:space="preserve">
          <source>Why is my component re-rendering too often?</source>
          <target state="translated">¿Por qué mi componente se vuelve a reproducir con demasiada frecuencia?</target>
        </trans-unit>
        <trans-unit id="77273d55a2a0fbeee2220902bad56163a526b540" translate="yes" xml:space="preserve">
          <source>Why is this beneficial? &lt;strong&gt;It is often claimed that constants are unnecessary, and for small projects, this might be correct.&lt;/strong&gt; For larger projects, there are some benefits to defining action types as constants:</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; es esto beneficioso? &lt;strong&gt;A menudo se afirma que las constantes son innecesarias y, para proyectos peque&amp;ntilde;os, esto podr&amp;iacute;a ser correcto. &lt;/strong&gt;Para proyectos m&amp;aacute;s grandes, existen algunos beneficios al definir los tipos de acci&amp;oacute;n como constantes:</target>
        </trans-unit>
        <trans-unit id="ff0296d28f6b024408ea92b7c1ed963cf8a64adf" translate="yes" xml:space="preserve">
          <source>Why isn't my component re-rendering, or my mapStateToProps running?</source>
          <target state="translated">¿Por qué no se está reproduciendo mi componente o mi mapStateToProps?</target>
        </trans-unit>
        <trans-unit id="67ac165008f4be935481141e41f5ad4f0e445971" translate="yes" xml:space="preserve">
          <source>Why should &lt;code&gt;type&lt;/code&gt; be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; el &lt;code&gt;type&lt;/code&gt; deber&amp;iacute;a ser una cadena, o al menos serializable? &amp;iquest;Por qu&amp;eacute; mis tipos de acci&amp;oacute;n deber&amp;iacute;an ser constantes?</target>
        </trans-unit>
        <trans-unit id="6250d26c1c06d76575d238d1fd90a39d732b6647" translate="yes" xml:space="preserve">
          <source>Why should I choose Immutable.JS as an immutable library?</source>
          <target state="translated">¿Por qué debo elegir Immutable.JS como una biblioteca inmutable?</target>
        </trans-unit>
        <trans-unit id="36a89fdc5d2eadc3e614ad18a6f439b16e06ba2e" translate="yes" xml:space="preserve">
          <source>Why should I use an immutable-focused library such as Immutable.JS?</source>
          <target state="translated">¿Por qué debería usar una biblioteca de enfoque inmutable como Immutable.JS?</target>
        </trans-unit>
        <trans-unit id="f9c9ff5d2aa97da2f3c187af80701dfecc789475" translate="yes" xml:space="preserve">
          <source>Why should type be a string, or at least serializable? Why should my action types be constants?</source>
          <target state="translated">¿Por qué el tipo de letra debe ser una cadena,o al menos serializable? ¿Por qué mis tipos de acción deben ser constantes?</target>
        </trans-unit>
        <trans-unit id="dab3df4bfeab70c04e3398ba91567702008bac36" translate="yes" xml:space="preserve">
          <source>Why will shallow equality checking not work with mutable objects?</source>
          <target state="translated">¿Por qué la comprobación de igualdad superficial no funcionará con objetos mutables?</target>
        </trans-unit>
        <trans-unit id="478cc11a21f0ce66c20e68a01399e12557bac4a6" translate="yes" xml:space="preserve">
          <source>Wikipedia: Associative Entity</source>
          <target state="translated">Wikipedia:Entidad asociativa</target>
        </trans-unit>
        <trans-unit id="923fc7415b6af8016333316d63e41417d9181e99" translate="yes" xml:space="preserve">
          <source>Will having &amp;ldquo;one state tree&amp;rdquo; cause memory problems? Will dispatching many actions take up memory?</source>
          <target state="translated">&amp;iquest;Tener &quot;un &amp;aacute;rbol de estado&quot; causar&amp;aacute; problemas de memoria? &amp;iquest;Despachar muchas acciones ocupar&amp;aacute; memoria?</target>
        </trans-unit>
        <trans-unit id="1ca4941ae83a69d23ea4d39fc06d98dc6f0b9802" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, the wrapper classes generated by the &lt;code&gt;connect()&lt;/code&gt; function do actually look for &lt;code&gt;props.store&lt;/code&gt; if it exists, but it's best if you wrap your root component in &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; and let React Redux worry about passing the store down. This way components don't need to worry about importing a store module, and isolating a Redux app or enabling server rendering is much easier to do later.</source>
          <target state="translated">Con &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; , las clases contenedoras generadas por la funci&amp;oacute;n &lt;code&gt;connect()&lt;/code&gt; realidad buscan &lt;code&gt;props.store&lt;/code&gt; si existe, pero es mejor si envuelve su componente ra&amp;iacute;z en &lt;code&gt;&amp;lt;Provider store={store}&amp;gt;&lt;/code&gt; y deja que React Redux se preocupe por pasar la tienda abajo. De esta manera, los componentes no necesitan preocuparse por importar un m&amp;oacute;dulo de tienda, y aislar una aplicaci&amp;oacute;n Redux o habilitar la representaci&amp;oacute;n del servidor es mucho m&amp;aacute;s f&amp;aacute;cil de hacer m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="fb5a653a3a5bc160a77a07e48c7fddec333e9161" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;combineReducers()&lt;/code&gt; the behavior is more nuanced. Those reducers whose state is specified in &lt;code&gt;preloadedState&lt;/code&gt; will receive that state. Other reducers will receive &lt;code&gt;undefined&lt;/code&gt;&lt;em&gt;and because of that&lt;/em&gt; will fall back to the &lt;code&gt;state = ...&lt;/code&gt; default argument they specify.</source>
          <target state="translated">Con &lt;code&gt;combineReducers()&lt;/code&gt; el comportamiento es m&amp;aacute;s matizado. Aquellos reductores cuyo estado se especifique en &lt;code&gt;preloadedState&lt;/code&gt; recibir&amp;aacute;n ese estado. Otros reductores recibir&amp;aacute;n &lt;code&gt;undefined&lt;/code&gt; &lt;em&gt;y por eso&lt;/em&gt; volver&amp;aacute;n al argumento &lt;code&gt;state = ...&lt;/code&gt; default que especifican.</target>
        </trans-unit>
        <trans-unit id="dcb12ee583209b8bb9b311e92be2aa73c59c20e7" translate="yes" xml:space="preserve">
          <source>With JavaScript, you can accidentally mutate an object (such as the Redux state tree) quite easily without realising it. For example, updating deeply nested properties, creating a new &lt;em&gt;reference&lt;/em&gt; to an object instead of a new object, or performing a shallow copy rather than a deep copy, can all lead to inadvertent object mutations, and can trip up even the most experienced JavaScript coder.</source>
          <target state="translated">Con JavaScript, puede mutar accidentalmente un objeto (como el &amp;aacute;rbol de estado de Redux) con bastante facilidad sin darse cuenta. Por ejemplo, actualizar propiedades profundamente anidadas, crear una nueva &lt;em&gt;referencia&lt;/em&gt; a un objeto en lugar de un nuevo objeto, o realizar una copia superficial en lugar de una copia profunda, pueden llevar a mutaciones de objetos inadvertidas y pueden hacer tropezar incluso al codificador de JavaScript m&amp;aacute;s experimentado. .</target>
        </trans-unit>
        <trans-unit id="c279bb3233aaa1e17c77c8a143b0f1883f9cd4d7" translate="yes" xml:space="preserve">
          <source>With Redux, however, implementing undo history is a breeze. There are three reasons for this:</source>
          <target state="translated">Con Redux,sin embargo,implementar deshacer la historia es pan comido.Hay tres razones para esto:</target>
        </trans-unit>
        <trans-unit id="30a10f999841101d22cd135f2d787dcfd7a220dd" translate="yes" xml:space="preserve">
          <source>With Redux, the same update logic can be described as a reducing function:</source>
          <target state="translated">Con Redux,la misma lógica de actualización puede describirse como una función reductora:</target>
        </trans-unit>
        <trans-unit id="c60d5cf0665575903c5afa25eb7d3eed7b4fc200" translate="yes" xml:space="preserve">
          <source>With this out of the way, let's start writing our reducer by gradually teaching it to understand the &lt;a href=&quot;actions&quot;&gt;actions&lt;/a&gt; we defined earlier.</source>
          <target state="translated">Con esto fuera del camino, comencemos a escribir nuestro reductor ense&amp;ntilde;&amp;aacute;ndole gradualmente a comprender las &lt;a href=&quot;actions&quot;&gt;acciones&lt;/a&gt; que definimos anteriormente.</target>
        </trans-unit>
        <trans-unit id="fee9030454f12e22bef2b8be7208f6154da76739" translate="yes" xml:space="preserve">
          <source>Without &lt;a href=&quot;middleware&quot;&gt;middleware&lt;/a&gt;, Redux store only supports &lt;a href=&quot;../basics/dataflow&quot;&gt;synchronous data flow&lt;/a&gt;. This is what you get by default with &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Sin &lt;a href=&quot;middleware&quot;&gt;middleware&lt;/a&gt; , la tienda Redux solo admite &lt;a href=&quot;../basics/dataflow&quot;&gt;el flujo de datos sincr&amp;oacute;nico&lt;/a&gt; . Esto es lo que obtiene de forma predeterminada con &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b879db99111e27d801d9201a249f4ff8dadbc225" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;combineReducers()&lt;/code&gt; or similar manual code, &lt;code&gt;preloadedState&lt;/code&gt; always wins over &lt;code&gt;state = ...&lt;/code&gt; in the reducer because the &lt;code&gt;state&lt;/code&gt; passed to the reducer &lt;em&gt;is&lt;/em&gt;&lt;code&gt;preloadedState&lt;/code&gt; and &lt;em&gt;is not&lt;/em&gt;&lt;code&gt;undefined&lt;/code&gt;, so the ES6 argument syntax doesn't apply.</source>
          <target state="translated">Sin &lt;code&gt;combineReducers()&lt;/code&gt; o c&amp;oacute;digo manual similar, &lt;code&gt;preloadedState&lt;/code&gt; siempre gana sobre &lt;code&gt;state = ...&lt;/code&gt; en el reductor porque el &lt;code&gt;state&lt;/code&gt; pasado al reductor &lt;em&gt;es &lt;/em&gt; &lt;code&gt;preloadedState&lt;/code&gt; y &lt;em&gt;no est&amp;aacute; &lt;/em&gt; &lt;code&gt;undefined&lt;/code&gt; , por lo que la sintaxis del argumento ES6 no se aplica.</target>
        </trans-unit>
        <trans-unit id="93111501bb024fd914d89cdba95cef4a48a41268" translate="yes" xml:space="preserve">
          <source>Without any middleware, &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; only accepts a plain object, so we have to perform AJAX calls inside our components:</source>
          <target state="translated">Sin ning&amp;uacute;n middleware, el &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; solo acepta un objeto simple, por lo que tenemos que realizar llamadas AJAX dentro de nuestros componentes:</target>
        </trans-unit>
        <trans-unit id="3eaee8c6d91975cebb24c4050db09591d953bf58" translate="yes" xml:space="preserve">
          <source>Won't calling &amp;ldquo;all my reducers&amp;rdquo; for each action be slow?</source>
          <target state="translated">&amp;iquest;No ser&amp;aacute; lento llamar a &quot;todos mis reductores&quot; para cada acci&amp;oacute;n?</target>
        </trans-unit>
        <trans-unit id="6136c4a62a84feac2443e18a9f39e199c0a98340" translate="yes" xml:space="preserve">
          <source>Wordpress's new admin page</source>
          <target state="translated">La nueva página de administración de Wordpress</target>
        </trans-unit>
        <trans-unit id="69c79c2885e8ffba979a60fb509366f84a77cc7d" translate="yes" xml:space="preserve">
          <source>Working with VK API (in Russian)</source>
          <target state="translated">Trabajando con VK API (en ruso)</target>
        </trans-unit>
        <trans-unit id="1a31d58278381294346a4e44a8fa95eea8b2e991" translate="yes" xml:space="preserve">
          <source>Wouldn't it be nice if we logged every action that happens in the app, together with the state computed after it? When something goes wrong, we can look back at our log, and figure out which action corrupted the state.</source>
          <target state="translated">¿No sería bueno que registráramos cada acción que ocurre en la aplicación,junto con el estado calculado después de ella? Cuando algo va mal,podemos mirar atrás en nuestro registro,y averiguar qué acción corrompió el estado.</target>
        </trans-unit>
        <trans-unit id="287cf4a678ff4e9d1ea3555ab140fc6d89ea8b80" translate="yes" xml:space="preserve">
          <source>Wouldn't it be useful if, any time an error is thrown as a result of dispatching an action, we would send it to a crash reporting service like &lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;Sentry&lt;/a&gt; with the stack trace, the action that caused the error, and the current state? This way it's much easier to reproduce the error in development.</source>
          <target state="translated">&amp;iquest;No ser&amp;iacute;a &amp;uacute;til si, cada vez que se arroja un error como resultado del env&amp;iacute;o de una acci&amp;oacute;n, lo envi&amp;aacute;ramos a un servicio de informes de &lt;a href=&quot;https://getsentry.com/welcome/&quot;&gt;fallas&lt;/a&gt; como Sentry con el seguimiento de la pila, la acci&amp;oacute;n que caus&amp;oacute; el error y el estado actual? De esta forma es mucho m&amp;aacute;s f&amp;aacute;cil reproducir el error en desarrollo.</target>
        </trans-unit>
        <trans-unit id="411ddc1bcac2f709ddb631f9805e03c11ac7e355" translate="yes" xml:space="preserve">
          <source>Wrapping the Reducer</source>
          <target state="translated">Envolviendo el reductor</target>
        </trans-unit>
        <trans-unit id="ba0e9312c8cb9cd6ef1a61e5d88575514a7ba12b" translate="yes" xml:space="preserve">
          <source>Writing Tests</source>
          <target state="translated">Pruebas de escritura</target>
        </trans-unit>
        <trans-unit id="e92ef945f3ed541f8b7064bd91824ad741ef1405" translate="yes" xml:space="preserve">
          <source>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:</source>
          <target state="translated">Escribir creadores de acciones simples puede ser agotador y a menudo termina generando un código redundante:</target>
        </trans-unit>
        <trans-unit id="80dc0881b1c90b466a5ebf41c749b8683c142f76" translate="yes" xml:space="preserve">
          <source>Ximedes</source>
          <target state="translated">Ximedes</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="885f3940d9ce7913d6e6d671fe072b2efd348d82" translate="yes" xml:space="preserve">
          <source>Yes, lots of them! To name just a few:</source>
          <target state="translated">Sí,muchos de ellos! Por nombrar sólo algunos:</target>
        </trans-unit>
        <trans-unit id="677676d61dff082b230a183ba82de368a4fd2ae9" translate="yes" xml:space="preserve">
          <source>You Might Not Need Redux</source>
          <target state="translated">Puede que no necesites el Redux</target>
        </trans-unit>
        <trans-unit id="b5debd85103d524869a8aafb925b357862c1933e" translate="yes" xml:space="preserve">
          <source>You can also enable the &lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; for a more succinct syntax:</source>
          <target state="translated">Tambi&amp;eacute;n puede habilitar la &lt;a href=&quot;recipes/usingobjectspreadoperator&quot;&gt;propuesta del operador de extensi&amp;oacute;n de objetos&lt;/a&gt; para una sintaxis m&amp;aacute;s sucinta:</target>
        </trans-unit>
        <trans-unit id="ea3d01095c6b6725a225b7568204932eba587586" translate="yes" xml:space="preserve">
          <source>You can always write a function that generates an action creator:</source>
          <target state="translated">Siempre se puede escribir una función que genere un creador de acciones:</target>
        </trans-unit>
        <trans-unit id="ebedd29e20c0b181d70ffe15f5988d119d67516f" translate="yes" xml:space="preserve">
          <source>You can call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt; from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.</source>
          <target state="translated">Puede llamar a &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt; desde cualquier lugar de su aplicaci&amp;oacute;n, incluidos los componentes y las devoluciones de llamada XHR, o incluso a intervalos programados.</target>
        </trans-unit>
        <trans-unit id="870b3b70e7feab01dc48305e33a3f7b71d9e003a" translate="yes" xml:space="preserve">
          <source>You can control state key names by using different keys for the reducers in the passed object. For example, you may call &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; for the state shape to be &lt;code&gt;{ todos, counter }&lt;/code&gt;.</source>
          <target state="translated">Puede controlar los nombres de las claves de estado utilizando diferentes claves para los reductores en el objeto pasado. Por ejemplo, puede llamar a &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; para que la forma del estado sea &lt;code&gt;{ todos, counter }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84b80aff840c6b3c2cb0814711f2e90fb9add9aa" translate="yes" xml:space="preserve">
          <source>You can even write a custom middleware to describe calls to your API, like the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; does.</source>
          <target state="translated">Incluso puede escribir un middleware personalizado para describir las llamadas a su API, como lo hace el &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;ejemplo del mundo real&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bcfc87ae98655e6e4c23b31a5690541a13ff642" translate="yes" xml:space="preserve">
          <source>You can extract logging into a function:</source>
          <target state="translated">Puedes extraer el registro de una función:</target>
        </trans-unit>
        <trans-unit id="1306a831686a52c567f5d3446dae27226d983c27" translate="yes" xml:space="preserve">
          <source>You can find more examples in &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;.</source>
          <target state="translated">Puede encontrar m&amp;aacute;s ejemplos en &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1db4cdd68a98570c03ba8a576e981e8641ef738b" translate="yes" xml:space="preserve">
          <source>You can find the official logo &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;on GitHub&lt;/a&gt;.</source>
          <target state="translated">Puedes encontrar el logo oficial &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;en GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb1259c8d739932d68e05103d65deeafc4b13b1" translate="yes" xml:space="preserve">
          <source>You can see how this causes the state held by the store to change:</source>
          <target state="translated">Puedes ver cómo esto hace que cambie el estado que tiene la tienda:</target>
        </trans-unit>
        <trans-unit id="a4eddcb9e81b002608a7bf4ef875c82738729233" translate="yes" xml:space="preserve">
          <source>You can set up your build tool of choice (Webpack, Browserify, etc.) to compile a bundle file into &lt;code&gt;static/bundle.js&lt;/code&gt;.</source>
          <target state="translated">Puede configurar la herramienta de compilaci&amp;oacute;n que desee (Webpack, Browserify, etc.) para compilar un archivo de paquete en &lt;code&gt;static/bundle.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23310ba75752c6caee4c2c18e21c9fe454bf81a2" translate="yes" xml:space="preserve">
          <source>You can then pass &lt;code&gt;dispatch&lt;/code&gt; down to other components manually, if you want to.</source>
          <target state="translated">A continuaci&amp;oacute;n, puede pasar el &lt;code&gt;dispatch&lt;/code&gt; a otros componentes manualmente, si lo desea.</target>
        </trans-unit>
        <trans-unit id="f95f737abcdb30e78aa13a25f5076e2ef6dc3676" translate="yes" xml:space="preserve">
          <source>You can then use it everywhere instead of &lt;code&gt;store.dispatch()&lt;/code&gt;:</source>
          <target state="translated">Luego puede usarlo en todas partes en lugar de &lt;code&gt;store.dispatch()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bfbaa58ba5417a98c5d0d32b5ce14eba1d4e2fef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; or &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt; to dispatch Promises instead of functions.</source>
          <target state="translated">Puede usar &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; o &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt; para enviar promesas en lugar de funciones.</target>
        </trans-unit>
        <trans-unit id="9d98266f375d43672febffb46f3ed5355675dc5b" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; to dispatch Observables.</source>
          <target state="translated">Puede usar &lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; para enviar Observables.</target>
        </trans-unit>
        <trans-unit id="8d9c266f69d53ba1763af2ada1d6653210151773" translate="yes" xml:space="preserve">
          <source>You can use Redux together with &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;, or with any other view library.</source>
          <target state="translated">Puede usar Redux junto con &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; o con cualquier otra biblioteca de vistas.</target>
        </trans-unit>
        <trans-unit id="28d3cd95f0d488448a63a6b338cb50068a95d5d9" translate="yes" xml:space="preserve">
          <source>You can use it at all levels of your reducer structure, not just to create the root reducer. It's very common to have multiple combined reducers in various places, which are composed together to create the root reducer.</source>
          <target state="translated">Puedes usarlo en todos los niveles de tu estructura reductora,no sólo para crear el reductor de la raíz.Es muy común tener múltiples reductores combinados en varios lugares,que se componen juntos para crear el reductor raíz.</target>
        </trans-unit>
        <trans-unit id="490b5a07e2c5aad3ad0c9fd7a27a52665898f60e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; middleware to dispatch promise-based asynchronous actions.</source>
          <target state="translated">Puede utilizar el middleware &lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; para enviar acciones asincr&amp;oacute;nicas basadas en promesas.</target>
        </trans-unit>
        <trans-unit id="df0e299c97c2207cdace456ccd47c72d8b63f087" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; middleware to build more complex asynchronous actions.</source>
          <target state="translated">Puede utilizar el middleware &lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; para crear acciones asincr&amp;oacute;nicas m&amp;aacute;s complejas.</target>
        </trans-unit>
        <trans-unit id="2be61aa399225330ac3c7c8f8b6d9263d4b58435" translate="yes" xml:space="preserve">
          <source>You cannot mutate an immutable object; instead, you must mutate a copy of it, leaving the original intact.</source>
          <target state="translated">No se puede mutar un objeto inmutable,sino una copia del mismo,dejando el original intacto.</target>
        </trans-unit>
        <trans-unit id="9002cfc3dd43f6e0951811e8e815e8e77752e185" translate="yes" xml:space="preserve">
          <source>You could also give them different keys, or call functions differently. These two ways to write a combined reducer are equivalent:</source>
          <target state="translated">También podrías darles diferentes teclas,o llamar a las funciones de manera diferente.Estas dos formas de escribir un reductor combinado son equivalentes:</target>
        </trans-unit>
        <trans-unit id="1be388744a3e109fec6dfea1a28f5eb27d9ed9a9" translate="yes" xml:space="preserve">
          <source>You could even go as far as to make a generic filtering higher-order reducer:</source>
          <target state="translated">Incluso se podría llegar a hacer un reductor genérico de filtrado de alto orden:</target>
        </trans-unit>
        <trans-unit id="1e73413f8379bbd8e9bb56a500c7eb3c5f375e13" translate="yes" xml:space="preserve">
          <source>You do not need to use Immutable.JS with Redux. Plain JavaScript, if written correctly, is perfectly capable of providing immutability without having to use an immutable-focused library.</source>
          <target state="translated">No necesitas usar Immutable.JS con Redux.El Javascript simple,si se escribe correctamente,es perfectamente capaz de proporcionar inmutabilidad sin tener que usar una biblioteca enfocada en la inmutabilidad.</target>
        </trans-unit>
        <trans-unit id="9581e0ed51066ff103253aa77beee1d1478416ea" translate="yes" xml:space="preserve">
          <source>You don't have to define action type constants in a separate file, or even to define them at all. For a small project, it might be easier to just use string literals for action types. However, there are some benefits to explicitly declaring constants in larger codebases. Read &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;Reducing Boilerplate&lt;/a&gt; for more practical tips on keeping your codebase clean.</source>
          <target state="translated">No tiene que definir constantes de tipo de acci&amp;oacute;n en un archivo separado, ni siquiera definirlas en absoluto. Para un proyecto peque&amp;ntilde;o, podr&amp;iacute;a ser m&amp;aacute;s f&amp;aacute;cil usar literales de cadena para los tipos de acci&amp;oacute;n. Sin embargo, hay algunos beneficios de declarar expl&amp;iacute;citamente constantes en bases de c&amp;oacute;digo m&amp;aacute;s grandes. Lea &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;Reducing Boilerplate&lt;/a&gt; para obtener m&amp;aacute;s consejos pr&amp;aacute;cticos sobre c&amp;oacute;mo mantener limpio su c&amp;oacute;digo base.</target>
        </trans-unit>
        <trans-unit id="199448d814bc5e9584035a52d2115857f50dad49" translate="yes" xml:space="preserve">
          <source>You have two reducers:</source>
          <target state="translated">Tienes dos reductores:</target>
        </trans-unit>
        <trans-unit id="192eb5ae977897417943647ddbcb6a6f3d4104d2" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="translated">Puede llamar a &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; desde un detector de cambios, con las siguientes advertencias:</target>
        </trans-unit>
        <trans-unit id="b929863aa2c2de96072c024f0b1ab365c66cfa6b" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatchaction&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebca9d5f96869ed296e545e937054edc0f8c94d" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;combineReducers&lt;/code&gt; at any level of the reducer hierarchy. It doesn't have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.</source>
          <target state="translated">Puede llamar a &lt;code&gt;combineReducers&lt;/code&gt; en cualquier nivel de la jerarqu&amp;iacute;a de reductores. No tiene por qu&amp;eacute; suceder en la cima. De hecho, puede usarlo nuevamente para dividir los reductores infantiles que se vuelven demasiado complicados en nietos independientes, y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="3644afb1fd9b1feb972c2dc856f2ca012f2fd6b3" translate="yes" xml:space="preserve">
          <source>You may enhance &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;. It is not required, but it lets you &lt;a href=&quot;asyncactions&quot;&gt;express asynchronous actions in a convenient way&lt;/a&gt;.</source>
          <target state="translated">Puede mejorar &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; con &lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt; . No es obligatorio, pero le permite &lt;a href=&quot;asyncactions&quot;&gt;expresar acciones asincr&amp;oacute;nicas de una manera conveniente&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d912b7407f7325b0f1291dd95c400a5024e9614d" translate="yes" xml:space="preserve">
          <source>You may need to write some custom functions for handling some of these actions. This may require replacing &lt;code&gt;combineReducers&lt;/code&gt; with your own top-level reducer function. You can also use a utility such as &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; to run &lt;code&gt;combineReducers&lt;/code&gt; to handle most actions, but also run a more specialized reducer for specific actions that cross state slices.</source>
          <target state="translated">Es posible que deba escribir algunas funciones personalizadas para manejar algunas de estas acciones. Esto puede requerir reemplazar los &lt;code&gt;combineReducers&lt;/code&gt; con su propia funci&amp;oacute;n reductora de nivel superior. Tambi&amp;eacute;n puede usar una utilidad como &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reductores&lt;/a&gt; para ejecutar &lt;code&gt;combineReducers&lt;/code&gt; para manejar la mayor&amp;iacute;a de las acciones, pero tambi&amp;eacute;n puede ejecutar un reductor m&amp;aacute;s especializado para acciones espec&amp;iacute;ficas que cruzan segmentos de estado.</target>
        </trans-unit>
        <trans-unit id="09059cc37b1193dbc15c30252c07daa76e286f64" translate="yes" xml:space="preserve">
          <source>You may optionally specify the initial state as the second argument to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;. This is useful for hydrating the state of the client to match the state of a Redux application running on the server.</source>
          <target state="translated">Opcionalmente, puede especificar el estado inicial como segundo argumento para &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; . Esto es &amp;uacute;til para hidratar el estado del cliente para que coincida con el estado de una aplicaci&amp;oacute;n Redux que se ejecuta en el servidor.</target>
        </trans-unit>
        <trans-unit id="3ee0e53b45fb2fa831d9c837168e8230281cd9d8" translate="yes" xml:space="preserve">
          <source>You may use a dedicated &lt;code&gt;status&lt;/code&gt; field in your actions:</source>
          <target state="translated">Puede utilizar un campo de &lt;code&gt;status&lt;/code&gt; dedicado en sus acciones:</target>
        </trans-unit>
        <trans-unit id="db87382954c55c5d2ee83adf7f38146a50266b8e" translate="yes" xml:space="preserve">
          <source>You may want to read &lt;a href=&quot;../advanced/asyncactions&quot;&gt;Async Actions&lt;/a&gt; to learn more about expressing asynchronous flow in Redux with async primitives such as Promises and thunks. Keep in mind that anything you learn there can also be applied to universal rendering.</source>
          <target state="translated">Es posible que desee leer &lt;a href=&quot;../advanced/asyncactions&quot;&gt;Acciones&lt;/a&gt; as&amp;iacute;ncronas para obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo expresar el flujo as&amp;iacute;ncrono en Redux con primitivas as&amp;iacute;ncronas como Promesas y procesadores. Tenga en cuenta que todo lo que aprenda all&amp;iacute; tambi&amp;eacute;n se puede aplicar al renderizado universal.</target>
        </trans-unit>
        <trans-unit id="ec6c69e4ca4e0cce6a488148dc045be49daaf6a8" translate="yes" xml:space="preserve">
          <source>You may wrap one or more reducers in &lt;code&gt;undoable&lt;/code&gt; at any level of the reducer composition hierarchy. We choose to wrap &lt;code&gt;todos&lt;/code&gt; instead of the top-level combined reducer so that changes to &lt;code&gt;visibilityFilter&lt;/code&gt; are not reflected in the undo history.</source>
          <target state="translated">Puede envolver uno o m&amp;aacute;s reductores en &lt;code&gt;undoable&lt;/code&gt; en cualquier nivel de la jerarqu&amp;iacute;a de composici&amp;oacute;n de reductores. Elegimos envolver &lt;code&gt;todos&lt;/code&gt; en lugar del reductor combinado de nivel superior para que los cambios en el &lt;code&gt;visibilityFilter&lt;/code&gt; de visibilidad no se reflejen en el historial de deshacer.</target>
        </trans-unit>
        <trans-unit id="b5dbd93add81c61b1e16815b79f40079a123eba8" translate="yes" xml:space="preserve">
          <source>You might ask: why don't we bind the action creators to the store instance right away, like in classical Flux? The problem is that this won't work well with universal apps that need to render on the server. Most likely you want to have a separate store instance per request so you can prepare them with different data, but binding action creators during their definition means you're stuck with a single store instance for all requests.</source>
          <target state="translated">Podrías preguntarte:¿por qué no vinculamos a los creadores de acción a la instancia de la tienda de inmediato,como en el clásico Flux? El problema es que esto no funcionará bien con aplicaciones universales que necesitan ser renderizadas en el servidor.Lo más probable es que quieras tener una instancia de tienda separada por petición para poder prepararla con datos diferentes,pero vincular los creadores de acciones durante su definición significa que estás atascado con una única instancia de tienda para todas las peticiones.</target>
        </trans-unit>
        <trans-unit id="2896f8f64f8c4e00e8362d43f027ff694ea34032" translate="yes" xml:space="preserve">
          <source>You might be familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;higher order functions&lt;/a&gt;. If you use React, you might be familiar with &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher order components&lt;/a&gt;. Here is a variation on the same pattern, applied to reducers.</source>
          <target state="translated">Es posible que est&amp;eacute; familiarizado con &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;funciones de orden superior&lt;/a&gt; . Si usa React, es posible que est&amp;eacute; familiarizado con &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;componentes de orden superior&lt;/a&gt; . Aqu&amp;iacute; hay una variaci&amp;oacute;n del mismo patr&amp;oacute;n, aplicado a reductores.</target>
        </trans-unit>
        <trans-unit id="fc80378efa78f4250982b149969a4e4206388634" translate="yes" xml:space="preserve">
          <source>You might have heard that Redux was influenced by &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture&lt;/a&gt;. It shouldn't come as a surprise that this example is very similar to &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redo package&lt;/a&gt;.</source>
          <target state="translated">Es posible que haya escuchado que Redux fue influenciado por &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture&lt;/a&gt; . No deber&amp;iacute;a sorprendernos que este ejemplo sea muy similar al &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;paquete elm-undo-redo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be8f897b9ef506870651387b41362b89ab366329" translate="yes" xml:space="preserve">
          <source>You might want to use it to apply several &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; in a row.</source>
          <target state="translated">Es posible que desee utilizarlo para aplicar varios &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;potenciadores de tienda&lt;/a&gt; seguidos.</target>
        </trans-unit>
        <trans-unit id="cb8edb49caaa697733e02d643699b140e0476f6b" translate="yes" xml:space="preserve">
          <source>You might write an action creator in a separate file, and import it into your component:</source>
          <target state="translated">Podrías escribir un creador de acciones en un archivo separado,e importarlo a tu componente:</target>
        </trans-unit>
        <trans-unit id="5012c361d888ca9c67b230342b72327b08a9b0ab" translate="yes" xml:space="preserve">
          <source>You never see this, of course - the data you give to an Immutable.JS object is never mutated. Rather, it&amp;rsquo;s the &lt;em&gt;intermediate&lt;/em&gt; data generated within Immutable.JS from a chained sequence of method calls that is free to be mutated. You therefore get all the benefits of immutable data structures with none (or very little) of the potential performance hits.</source>
          <target state="translated">Por supuesto, nunca ve esto: los datos que le da a un objeto Immutable.JS nunca se modifican. M&amp;aacute;s bien, son los datos &lt;em&gt;intermedios&lt;/em&gt; generados dentro de Immutable.JS a partir de una secuencia encadenada de llamadas a m&amp;eacute;todos que est&amp;aacute;n libres de mutaciones. Por lo tanto, obtiene todos los beneficios de las estructuras de datos inmutables con ninguno (o muy poco) de los posibles impactos de rendimiento.</target>
        </trans-unit>
        <trans-unit id="536f6105b2c796a51f197bb3552df6076809a08a" translate="yes" xml:space="preserve">
          <source>You will need to wrap the reducer you wish to enhance with &lt;code&gt;undoable&lt;/code&gt; function. For example, if you exported a &lt;code&gt;todos&lt;/code&gt; reducer from a dedicated file, you will want to change it to export the result of calling &lt;code&gt;undoable()&lt;/code&gt; with the reducer you wrote:</source>
          <target state="translated">Deber&amp;aacute; envolver el reductor que desea mejorar con &lt;code&gt;undoable&lt;/code&gt; funci&amp;oacute;n que se puede deshacer . Por ejemplo, si export&amp;oacute; un reductor de &lt;code&gt;todos&lt;/code&gt; desde un archivo dedicado, querr&amp;aacute; cambiarlo para exportar el resultado de llamar a &lt;code&gt;undoable()&lt;/code&gt; con el reductor que escribi&amp;oacute;:</target>
        </trans-unit>
        <trans-unit id="0d71f702363520e8d52cd5cf66c6865dbac24253" translate="yes" xml:space="preserve">
          <source>You will probably want to remove the hash from the URL (e.g: &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt;). For doing this, you will need to also import &lt;code&gt;browserHistory&lt;/code&gt; from React Router:</source>
          <target state="translated">Probablemente desee eliminar el hash de la URL (por ejemplo: &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt; ). Para hacer esto, tambi&amp;eacute;n necesitar&amp;aacute; importar &lt;code&gt;browserHistory&lt;/code&gt; desde React Router:</target>
        </trans-unit>
        <trans-unit id="847e7a43a897e6825651ba6a7171789bd4f8c993" translate="yes" xml:space="preserve">
          <source>You will use &lt;code&gt;connect()&lt;/code&gt; from &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate a container component. To determine whether to enable Undo and Redo buttons, you can check &lt;code&gt;state.todos.past.length&lt;/code&gt; and &lt;code&gt;state.todos.future.length&lt;/code&gt;. You won't need to write action creators for performing undo and redo because Redux Undo already provides them:</source>
          <target state="translated">Utilizar&amp;aacute; &lt;code&gt;connect()&lt;/code&gt; de &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; para generar un componente contenedor. Para determinar si habilitar los botones Deshacer y Rehacer, puede verificar &lt;code&gt;state.todos.past.length&lt;/code&gt; y &lt;code&gt;state.todos.future.length&lt;/code&gt; . No necesitar&amp;aacute; escribir creadores de acciones para realizar deshacer y rehacer porque Redux Undo ya los proporciona:</target>
        </trans-unit>
        <trans-unit id="ced3f60087b9c7dc7b64e901bea63d5a41a88099" translate="yes" xml:space="preserve">
          <source>You would only use the named export for tests.</source>
          <target state="translated">Sólo usaría la exportación nombrada para las pruebas.</target>
        </trans-unit>
        <trans-unit id="f002654c7b958bdea2528eaaa9c1e1ce5d2cfe9d" translate="yes" xml:space="preserve">
          <source>You'll know when you need Flux. If you aren't sure if you need it, you don't need it.</source>
          <target state="translated">Sabrás cuándo necesitas Flux.Si no estás seguro de si lo necesitas,no lo necesitas.</target>
        </trans-unit>
        <trans-unit id="9e4884b4000a8d2ac41ed531bf7a37bd6a9faaa2" translate="yes" xml:space="preserve">
          <source>You'll often find that you need to store some data, as well as some UI state, in the state tree. This is fine, but try to keep the data separate from the UI state.</source>
          <target state="translated">A menudo encontrarás que necesitas almacenar algunos datos,así como algún estado de UI,en el árbol de estados.Esto está bien,pero trata de mantener los datos separados del estado de UI.</target>
        </trans-unit>
        <trans-unit id="483dc0e6baee4af78f1c3f12ab8f28dda9a34453" translate="yes" xml:space="preserve">
          <source>You've seen middleware in action in the &lt;a href=&quot;asyncactions&quot;&gt;Async Actions&lt;/a&gt; example. If you've used server-side libraries like &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; and &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt;, you were also probably already familiar with the concept of &lt;em&gt;middleware&lt;/em&gt;. In these frameworks, middleware is some code you can put between the framework receiving a request, and the framework generating a response. For example, Express or Koa middleware may add CORS headers, logging, compression, and more. The best feature of middleware is that it's composable in a chain. You can use multiple independent third-party middleware in a single project.</source>
          <target state="translated">Ha visto middleware en acci&amp;oacute;n en el ejemplo de &lt;a href=&quot;asyncactions&quot;&gt;acciones as&amp;iacute;ncronas&lt;/a&gt; . Si ha utilizado bibliotecas del lado del servidor como &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; y &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt; , probablemente tambi&amp;eacute;n estaba familiarizado con el concepto de &lt;em&gt;middleware&lt;/em&gt; . En estos marcos, el middleware es un c&amp;oacute;digo que puede colocar entre el marco que recibe una solicitud y el marco que genera una respuesta. Por ejemplo, el middleware Express o Koa puede agregar encabezados CORS, registro, compresi&amp;oacute;n y m&amp;aacute;s. La mejor caracter&amp;iacute;stica del middleware es que se puede componer en cadena. Puede utilizar varios middleware de terceros independientes en un solo proyecto.</target>
        </trans-unit>
        <trans-unit id="7028f3891ebf7e4827d5eaddfa0e16584b0b4466" translate="yes" xml:space="preserve">
          <source>Your dumb components should be pure; that is, they should produce the same output given the same input, and have no external dependencies. If you pass such a component an Immutable.JS object as a prop, you make it dependent upon Immutable.JS to extract the prop&amp;rsquo;s value and otherwise manipulate it.</source>
          <target state="translated">Tus componentes tontos deben ser puros; es decir, deber&amp;iacute;an producir la misma salida dada la misma entrada y no tener dependencias externas. Si pasa un componente de este tipo un objeto Immutable.JS como accesorio, lo hace dependiente de Immutable.JS para extraer el valor del accesorio y manipularlo.</target>
        </trans-unit>
        <trans-unit id="395dd2fb0c94aec217ae48791e24ace04816fc89" translate="yes" xml:space="preserve">
          <source>Your process will look like this:</source>
          <target state="translated">Su proceso se verá así:</target>
        </trans-unit>
        <trans-unit id="2b13a159884d03a53c5b0abbb9540e28b3419ef7" translate="yes" xml:space="preserve">
          <source>Your selectors should return Immutable.JS objects</source>
          <target state="translated">Sus selectores deben devolver los objetos Immutable.JS</target>
        </trans-unit>
        <trans-unit id="281e35c0465b8b3d761e36f053ead41086e72367" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;enhancer&lt;/code&gt;] &lt;em&gt;(Function)&lt;/em&gt;: The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">[ &lt;code&gt;enhancer&lt;/code&gt; ] &lt;em&gt;(Funci&amp;oacute;n)&lt;/em&gt; : El potenciador de la tienda. Opcionalmente, puede especificarlo para mejorar la tienda con capacidades de terceros como middleware, viajes en el tiempo, persistencia, etc. El &amp;uacute;nico potenciador de la tienda que se env&amp;iacute;a con Redux es &lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87286375e4668a58823fba92d2b07b7a44fc0be4" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;preloadedState&lt;/code&gt;] &lt;em&gt;(any)&lt;/em&gt;: The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced &lt;code&gt;reducer&lt;/code&gt; with &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt;, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your &lt;code&gt;reducer&lt;/code&gt; can understand.</source>
          <target state="translated">[ &lt;code&gt;preloadedState&lt;/code&gt; ] &lt;em&gt;(cualquiera)&lt;/em&gt; : el estado inicial. Opcionalmente, puede especificarlo para hidratar el estado del servidor en aplicaciones universales o para restaurar una sesi&amp;oacute;n de usuario previamente serializada. Si produjo &lt;code&gt;reducer&lt;/code&gt; con &lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; , este debe ser un objeto simple con la misma forma que las llaves que se le pasaron. De lo contrario, puede pasar cualquier cosa que su &lt;code&gt;reducer&lt;/code&gt; pueda entender.</target>
        </trans-unit>
        <trans-unit id="c70c7e915a4a2b3601daa15f9ed309a470505e50" translate="yes" xml:space="preserve">
          <source>and configure it to use ES2015 features in &lt;code&gt;.babelrc&lt;/code&gt;:</source>
          <target state="translated">y config&amp;uacute;relo para usar las funciones de &lt;code&gt;.babelrc&lt;/code&gt; en .babelrc :</target>
        </trans-unit>
        <trans-unit id="fd3ab734b4fb4c62257230890e59143d0e998962" translate="yes" xml:space="preserve">
          <source>and pass it to the &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in order to remove the hash from the URL:</source>
          <target state="translated">y pasarlo al &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; para eliminar el hash de la URL:</target>
        </trans-unit>
        <trans-unit id="5f432ecbf9e6a7a5c1f170d992e60626ab120d96" translate="yes" xml:space="preserve">
          <source>and run &lt;code&gt;npm test&lt;/code&gt; to run it once, or &lt;code&gt;npm run test:watch&lt;/code&gt; to test on every file change.</source>
          <target state="translated">y ejecute &lt;code&gt;npm test&lt;/code&gt; para ejecutarlo una vez, o &lt;code&gt;npm run test:watch&lt;/code&gt; para probar cada cambio de archivo.</target>
        </trans-unit>
        <trans-unit id="f81edf81cd89734f8439987c58e09f5451875a46" translate="yes" xml:space="preserve">
          <source>and then pass the state along to the client.</source>
          <target state="translated">y luego pasar el estado al cliente.</target>
        </trans-unit>
        <trans-unit id="f3894228d526596c3cf53c57bbed5aae8b11537a" translate="yes" xml:space="preserve">
          <source>applyMiddleware()</source>
          <target state="translated">applyMiddleware()</target>
        </trans-unit>
        <trans-unit id="b6ad41cdd6bf4c2b18169a773d483861384cd204" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middleware)</source>
          <target state="translated">applyMiddleware(...middleware)</target>
        </trans-unit>
        <trans-unit id="7fedb9730abc492e1bcf1596264f044b04661aab" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middlewares)</source>
          <target state="translated">applyMiddleware(...middlewares)</target>
        </trans-unit>
        <trans-unit id="3f5c37526331395762baf88047f99e6d8b619f94" translate="yes" xml:space="preserve">
          <source>bindActionCreators()</source>
          <target state="translated">bindActionCreators()</target>
        </trans-unit>
        <trans-unit id="88e632a0686333c0fcc1b71ebd9b524a2ddd992d" translate="yes" xml:space="preserve">
          <source>bindActionCreators(actionCreators, dispatch)</source>
          <target state="translated">bindActionCreators(actionCreators,dispatch)</target>
        </trans-unit>
        <trans-unit id="3042d6bd02c4ca7273effadee7e63bf42bed16c9" translate="yes" xml:space="preserve">
          <source>calls the appropriate reducer and passes it the slice;</source>
          <target state="translated">llama al reductor apropiado y le pasa la rebanada;</target>
        </trans-unit>
        <trans-unit id="c3cf4ce11b3b5577a3871fe5b3cd80587b04a46c" translate="yes" xml:space="preserve">
          <source>can be tested like:</source>
          <target state="translated">puede ser probado como:</target>
        </trans-unit>
        <trans-unit id="991b9417df7c9c174211ba006b7edc0195725286" translate="yes" xml:space="preserve">
          <source>combineReducers()</source>
          <target state="translated">combineReducers()</target>
        </trans-unit>
        <trans-unit id="50f164696008c84fbdf8d8f93fe6bbfa9b14e143" translate="yes" xml:space="preserve">
          <source>combineReducers(reducers)</source>
          <target state="translated">combineReducers(reducers)</target>
        </trans-unit>
        <trans-unit id="c8dc852570744e8e3067cca75ce9fe7af17afec8" translate="yes" xml:space="preserve">
          <source>compose()</source>
          <target state="translated">compose()</target>
        </trans-unit>
        <trans-unit id="5745a141fb4592e3d9eb885924e51235574f61c6" translate="yes" xml:space="preserve">
          <source>compose(...functions)</source>
          <target state="translated">compose(...functions)</target>
        </trans-unit>
        <trans-unit id="112d9f2631778cd8a08a4296c2ccbf312712f2b3" translate="yes" xml:space="preserve">
          <source>cpsubrian: React decorators for redux/react-router/immutable &amp;lsquo;smart&amp;rsquo; components</source>
          <target state="translated">cpsubrian: decoradores React para componentes redux / react-router / inmutables 'inteligentes'</target>
        </trans-unit>
        <trans-unit id="94ba045109577a1f4ae2fedc6ca6e16e7cec8d37" translate="yes" xml:space="preserve">
          <source>create a fresh, new Redux store instance on every request;</source>
          <target state="translated">crear una nueva y fresca instancia de la tienda Redux en cada solicitud;</target>
        </trans-unit>
        <trans-unit id="b44915cfa2285ca11f257a840e99d4d3f28fc3a7" translate="yes" xml:space="preserve">
          <source>createStore()</source>
          <target state="translated">createStore()</target>
        </trans-unit>
        <trans-unit id="6ab01e2a484c9683cca2393d2ba3c93180699ee0" translate="yes" xml:space="preserve">
          <source>createStore(reducer, [preloadedState], [enhancer])</source>
          <target state="translated">createStore(reductor,[preloadedState],[enhancer])</target>
        </trans-unit>
        <trans-unit id="8fa33131b6a660bc8d77fd4bb48a66d021301526" translate="yes" xml:space="preserve">
          <source>creates a reference to the current state slice referred to by each key;</source>
          <target state="translated">crea una referencia al trozo de estado actual al que se refiere cada clave;</target>
        </trans-unit>
        <trans-unit id="e3a4682977bb863d850d9eae5d719e2585e731e5" translate="yes" xml:space="preserve">
          <source>creates a reference to the possibly-mutated state slice that's returned by the reducer.</source>
          <target state="translated">crea una referencia a la rebanada de estado posiblemente mutado que es devuelta por el reductor.</target>
        </trans-unit>
        <trans-unit id="280c1cc5f52574880ff013357b30094632bcbd78" translate="yes" xml:space="preserve">
          <source>dispatch(action)</source>
          <target state="translated">dispatch(action)</target>
        </trans-unit>
        <trans-unit id="b6e86cff86751f0236e17d84f44ac6dc44060213" translate="yes" xml:space="preserve">
          <source>for scale, we have ~500 action types, ~400 reducer cases, ~150 components, 5 middlewares, ~200 actions, ~2300 tests</source>
          <target state="translated">para la escala,tenemos ~500 tipos de acción,~400 cajas reductoras,~150 componentes,5 intermediarios,~200 acciones,~2300 pruebas</target>
        </trans-unit>
        <trans-unit id="5fe375f56e9a0fa7dc88b61b3c4b3425c5636e79" translate="yes" xml:space="preserve">
          <source>getState()</source>
          <target state="translated">getState()</target>
        </trans-unit>
        <trans-unit id="5cffe5ee80305aeabc52048276f1acf872533639" translate="yes" xml:space="preserve">
          <source>is equivalent to this:</source>
          <target state="translated">es equivalente a esto:</target>
        </trans-unit>
        <trans-unit id="1c0bbc97bd6780fb3baf83d4730c736904a39e76" translate="yes" xml:space="preserve">
          <source>optionally dispatch some actions;</source>
          <target state="translated">opcionalmente despachar algunas acciones;</target>
        </trans-unit>
        <trans-unit id="e7916345e570f1bcf19d018b0792a5db68935506" translate="yes" xml:space="preserve">
          <source>pull the state out of store;</source>
          <target state="translated">sacar el estado de la tienda;</target>
        </trans-unit>
        <trans-unit id="71ad63d785b9b9fdb536fac77ce747b9c5a69bc1" translate="yes" xml:space="preserve">
          <source>react-redux-jwt-auth-example</source>
          <target state="translated">react-redux-jwt-auth-example</target>
        </trans-unit>
        <trans-unit id="52295e92a7867dd2bf6e329dcebd064d09c14653" translate="yes" xml:space="preserve">
          <source>redux-immutable</source>
          <target state="translated">redux-immutable</target>
        </trans-unit>
        <trans-unit id="a88f184d5bfff1ab2b78bc41b8b30999ba677a10" translate="yes" xml:space="preserve">
          <source>replaceReducer(nextReducer)</source>
          <target state="translated">replaceReducer(nextReducer)</target>
        </trans-unit>
        <trans-unit id="9a9bbe4119c43d2a84a043196b4690c761b01d0a" translate="yes" xml:space="preserve">
          <source>subscribe(listener)</source>
          <target state="translated">subscribe(listener)</target>
        </trans-unit>
        <trans-unit id="26c8253fda7262249d6aacde189c2d069461b383" translate="yes" xml:space="preserve">
          <source>the keys &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; each refer to a separate state slice;</source>
          <target state="translated">las teclas &lt;code&gt;todos&lt;/code&gt; y &lt;code&gt;counter&lt;/code&gt; se refieren cada una a un segmento de estado independiente;</target>
        </trans-unit>
        <trans-unit id="afd2b6bf0fb616dda82e8ec1df11d135e0adf003" translate="yes" xml:space="preserve">
          <source>the values &lt;code&gt;myTodosReducer&lt;/code&gt; and &lt;code&gt;myCounterReducer&lt;/code&gt; are reducer functions, with each acting on the state slice identified by the respective key.</source>
          <target state="translated">los valores &lt;code&gt;myTodosReducer&lt;/code&gt; y &lt;code&gt;myCounterReducer&lt;/code&gt; son funciones reductoras, y cada una act&amp;uacute;a sobre el segmento de estado identificado por la clave respectiva.</target>
        </trans-unit>
        <trans-unit id="365862a50c0682caa8baa6f30edca76e3e5f81ed" translate="yes" xml:space="preserve">
          <source>where:</source>
          <target state="translated">where:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
