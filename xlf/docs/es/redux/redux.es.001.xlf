<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="30d4829117610e90feb15aaa2afa4a03b8acf085" translate="yes" xml:space="preserve">
          <source>#1024: Proposal: Declarative reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b615433f4ff0d26c5fa5b193e0e7d0cc3e80d05" translate="yes" xml:space="preserve">
          <source>#1051: Shortcomings of the current applyMiddleware and composing createStore</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e1f9116a8ad70c48d717384dff4c3d9ed0b8d4" translate="yes" xml:space="preserve">
          <source>#1057: subscribe listener can get action param?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc2d46618e57ca5f5cd58ca24a444b2e3962cbd" translate="yes" xml:space="preserve">
          <source>#1098: Using Redux in reusable React component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1172766c55389d23293c28bd580351638a8b05bb" translate="yes" xml:space="preserve">
          <source>#1139: An alternative side effect model based on generators and sagas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277db1c86685b6e2ab3da794c5499c7fdcf8c74e" translate="yes" xml:space="preserve">
          <source>#1165: Where to put business logic / validation?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a3cbd838b24d5f189d009b179a62c97ae2d04c" translate="yes" xml:space="preserve">
          <source>#1167: Reducer without switch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13afaff66dc7b23e3b11883862fef5f53054aed" translate="yes" xml:space="preserve">
          <source>#1171: Recommendations for best practices regarding action-creators, reducers, and selectors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66dd37b1d3975be52ce9c12bd63d02993da859c1" translate="yes" xml:space="preserve">
          <source>#1176: Redux+React with only stateless components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed8de88174cb4015a9a40feb1eb36d44bdfc115" translate="yes" xml:space="preserve">
          <source>#1185: Question: Should I use immutable data structures?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36502c2af1991f87b5ec953b1ce29619a393fcb7" translate="yes" xml:space="preserve">
          <source>#1248: Is it ok and possible to store a react component in a reducer?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="882566f27d0e15811a3d2222e5b3e7be9f37c3e6" translate="yes" xml:space="preserve">
          <source>#1255: Normalizr usage with nested objects in React/Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2442136b9e5a150b1df77be37dfaf76f081455" translate="yes" xml:space="preserve">
          <source>#125: Strategy for avoiding cascading renders</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37bec3c108aab23faa29d1d3ccc744b38e02030" translate="yes" xml:space="preserve">
          <source>#1262: Immutable data + bad performance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be52b6008b5e36ca13d546156068f2e0681de57" translate="yes" xml:space="preserve">
          <source>#1269: Add tree view example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbe916b0a42eeb4f1b8b1ce74cfca5a8c904167" translate="yes" xml:space="preserve">
          <source>#1279: Have any suggestions for where to put a Map Component in Flux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdbf83cd3a993497d417bb7aaf52383244a21b5" translate="yes" xml:space="preserve">
          <source>#1287: How to choose between Redux's store and React's state?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e852f115018d5807316e922246599c080b0e9503" translate="yes" xml:space="preserve">
          <source>#1300: Redux is great but major feature is missing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679eeec344129ad16e78231797b18b81de9a1726" translate="yes" xml:space="preserve">
          <source>#1303: Redux Performance with Large Store and frequent updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40ad0efcf8cdfb74359b9dcaaf30ad0e5d65061" translate="yes" xml:space="preserve">
          <source>#1346: Is it bad practice to just have a 'stores' directory?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076aa3253e92bf9223eb24af002f0bbe44e75f44" translate="yes" xml:space="preserve">
          <source>#1385: What are the disadvantages of storing all your state in a single immutable atom?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd76865437e3ee0e6eaa04e445cee157feda0101" translate="yes" xml:space="preserve">
          <source>#1390: Component Loading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926fcdba9fb2889fc5ab58719f3a2fe43b8cefa6" translate="yes" xml:space="preserve">
          <source>#1400: Is passing top-level state object to branch reducer an anti-pattern?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec86494988d387006d280e6de7e36c662cc84df" translate="yes" xml:space="preserve">
          <source>#1407: Just sharing a great base class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34f2137559dfc202961ddb79fca5d33772da57e" translate="yes" xml:space="preserve">
          <source>#159: Investigate using Redux for pseudo-local component state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="533d7a7280b4ebb1710db8562d8d14ac793fb437" translate="yes" xml:space="preserve">
          <source>#1751: Performance issues with large collections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f36989dd4b17b3997aaf72ac822de75218cc1ba" translate="yes" xml:space="preserve">
          <source>#1793: React Elements in Redux State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ded754edd99b8eb3c5dbc5f56be7e245c5cfff" translate="yes" xml:space="preserve">
          <source>#1813: Use a loop to support dispatching arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cbd9dbf9bd45f23169fcf1b9cac28e3ed46577e" translate="yes" xml:space="preserve">
          <source>#1816: Component connected to state with &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4db3c5c28aaed5936c26bc809377a941220207" translate="yes" xml:space="preserve">
          <source>#1824: Normalising state and garbage collection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a295c20bf7be400de7f0b760d0ab71f013297048" translate="yes" xml:space="preserve">
          <source>#1948: Is getMappedItems an anti-pattern in mapStateToProps?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd83ae1e93d8c72cc8d0d72bed074df91fdb5711" translate="yes" xml:space="preserve">
          <source>#291: Trying to put API calls in the right place</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e0c71a2076886c367dfe6a54f48c62f34d629f" translate="yes" xml:space="preserve">
          <source>#300: Potential connect() optimization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cca150f0353618d865ab736549a024eaf25e9b6" translate="yes" xml:space="preserve">
          <source>#303: subscribe API with state as an argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347d6847f32071d342aaec6151006d6975576724" translate="yes" xml:space="preserve">
          <source>#310: Who uses Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a857746379c5bd1fd15069f90a6730fd9d8c03f" translate="yes" xml:space="preserve">
          <source>#316: How to create nested reducers?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241aa7e523baa3daf169c16235be0831a07cca24" translate="yes" xml:space="preserve">
          <source>#384: Recommend that Action constants be named in the past tense</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b1eee56ce67b7a61408324df972292a71042952" translate="yes" xml:space="preserve">
          <source>#419: Recommended usage of connect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2935aef53d71adace83e50c33214eaca426a95e9" translate="yes" xml:space="preserve">
          <source>#454: Handling big states in reducer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0699a6d49cd70e922b35198761a2a07c83e5a3d" translate="yes" xml:space="preserve">
          <source>#455: Modeling side effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772964529153c4d154180791f6cbd68a862db7bc" translate="yes" xml:space="preserve">
          <source>#533: Simpler introduction to async action creators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebec8f05fa20d12e79e8cd586923a111d387212c" translate="yes" xml:space="preserve">
          <source>#542: Idea: batching actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c9c3ac3d68aab87e326de2f2c865ef2276a101" translate="yes" xml:space="preserve">
          <source>#569: Proposal: API for explicit side effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d6fe14a99ccdaf8dc393654376b48c92963a25" translate="yes" xml:space="preserve">
          <source>#580: Is it possible to get action and state in store.subscribe?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd9c0a060e7d71bfba68ba623da0d23c2d2537f5" translate="yes" xml:space="preserve">
          <source>#597: Valid to dispatch multiple actions from an event handler?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995165a4900367cea544bc6a5f22ed8ee0144461" translate="yes" xml:space="preserve">
          <source>#601: A concern on combineReducers, when an action is related to multiple reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91700ab890c5f08a2647bb350f68184b32a47f9" translate="yes" xml:space="preserve">
          <source>#628: Solution for simple action creation with less boilerplate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6cef416c1c4ce452dcbd4fff0470556c4b9881" translate="yes" xml:space="preserve">
          <source>#756: container vs component?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21340ba20a259634064d57cf626624fa2d15391a" translate="yes" xml:space="preserve">
          <source>#758: Why can't state be mutated?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c184b8b56c254a2d2a7ccf4adc774a774fe33d" translate="yes" xml:space="preserve">
          <source>#815: Working with Data Structures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ded1489a6f088808483a04ff55a1208ffe9541" translate="yes" xml:space="preserve">
          <source>#839: Emphasize defining selectors alongside reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20452e871be0ef029dee99c519ace41f4725804e" translate="yes" xml:space="preserve">
          <source>#883: take away the huge switch block</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f094ae5359226b707fd44e5f2a280f7467e4726" translate="yes" xml:space="preserve">
          <source>#911: Batching actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26f477aae1edf0347eb6f7ffa53f8db84ef966f" translate="yes" xml:space="preserve">
          <source>#912: Proposal: action filter utility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e67540fe79d19b36724130f44d7607e8859b33" translate="yes" xml:space="preserve">
          <source>#922: Proposal: add subscribe to middleware API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5501fbbcf1d607aa36fc7ed852657153c5e12ddf" translate="yes" xml:space="preserve">
          <source>#943: Reducer querying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680e2a0ba15353fa00a6904ce08286dab08d5d1e" translate="yes" xml:space="preserve">
          <source>#946: Best way to update related state fields with split reducers?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578d4af46b83796b576f50939eeddbe2b86f09a5" translate="yes" xml:space="preserve">
          <source>#959: Multiple actions one dispatch?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d53170003985aba57c3cbb54042a1048dbe5904" translate="yes" xml:space="preserve">
          <source>#994: How to cut the boilerplate when updating nested entities?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf535818991eda0fe486afd20e7daa2d14518b95" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;2017 Dan Abramov</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6b7f639f884be7fcd9fb980e496b6c33d5d3e1" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Come for the name hype. Stay for the rock solid fundamentals. (Thanks, and great job @dan_abramov and @eggheadio!)&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df384f33284e21430b07f18596d262ec19ba170f" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Ducks&amp;rdquo;: similar to domain style, but explicitly tying together actions and reducers, often by defining them in the same file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5150dc5211c6d06fcaf7e065f841bb023696c70e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Great course on egghead.io by @dan_abramov - instead of just showing you how to use #redux, it also shows how and why redux was built!&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3d7e088d7386301b6520d1c80203336070f21a" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;I asked for comments on Redux in FB's internal JS discussion group, and it was universally praised. Really awesome work.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805734d014075effe4c9f9a252eb9def2a6db8e5" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;It's cool that you are inventing a better Flux by not doing Flux at all.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3596109d016ac6d1e24cf6ef8b5eb8a444a3f3a" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Love what you're doing with Redux&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938ed1352f0e24ad85ff59d880eeac5332693aad" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Plowing through @dan_abramov 'Getting Started with Redux' - its amazing how much simpler concepts get with video.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa28d7323e70567c92735260eea7a08b3567882e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;This series of videos on Redux by @dan_abramov is repeatedly blowing my mind - gunna do some serious refactoring&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bbdab09b1bad7d1411229e6706b9074b9acbc26" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;This video series on Redux by @dan_abramov on @eggheadio is spectacular!&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f716d4a6d6d1dd6c2816b0a3468596f9af7981" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;store&quot;&gt;&lt;em&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;): An object that holds the complete state of your app. The only way to change its state is by &lt;a href=&quot;store#dispatch&quot;&gt;dispatching actions&lt;/a&gt;. You may also &lt;a href=&quot;store#subscribe&quot;&gt;subscribe&lt;/a&gt; to the changes to its state to update the UI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecee604ad68b289f8d3c800340d2c2c4d94ec4db" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt; or &lt;em&gt;Object&lt;/em&gt;): An object mimicking the original object, but with each function immediately dispatching the action returned by the corresponding action creator. If you passed a function as &lt;code&gt;actionCreators&lt;/code&gt;, the return value will also be a single function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb3da3936f993327ba39a8dd43015351fe83823" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;) A store enhancer that applies the given middleware. The store enhancer signature is &lt;code&gt;createStore =&amp;gt; createStore'&lt;/code&gt; but the easiest way to apply it is to pass it to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; as the last &lt;code&gt;enhancer&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f6b6bfc4538002cddbd1fd5e4e370dff6c9c1be" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): A function that unsubscribes the change listener.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c10b5a4481c57b2d2f9edfc1c63be79f798472" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): A reducer that invokes every reducer inside the &lt;code&gt;reducers&lt;/code&gt; object, and constructs a state object with the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389d55a260500f16717ac0d3a94350b27cba66e0" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): The final function obtained by composing the given functions from right to left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6cbf2c01213c134b40ec8c3596771ac0fe718c7" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;arguments&lt;/em&gt;): The functions to compose. Each function is expected to accept a single parameter. Its return value will be provided as an argument to the function standing to the left, and so on. The exception is the right-most argument which can accept multiple parameters, as it will provide the signature for the resulting composed function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5016311decd476dac1c440e0e52c02e0e3d85575" translate="yes" xml:space="preserve">
          <source>(Don't worry, &lt;a href=&quot;https://twitter.com/jingc/status/616608251463909376&quot;&gt;Flux creators&lt;/a&gt;&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616286955693682688&quot;&gt;approve of it&lt;/a&gt;, if that's all you wanted to know.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d324236cbf7b2c5b411e6901ceaf0426c57a961e" translate="yes" xml:space="preserve">
          <source>(If you're looking for a WordPress framework, check out &lt;a href=&quot;https://reduxframework.com/&quot;&gt;Redux Framework&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edae0b5981e0002b30818364c8a1389176fcb0ee" translate="yes" xml:space="preserve">
          <source>(Object&lt;sup&gt;&amp;dagger;&lt;/sup&gt;): The dispatched action (see notes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0be13084aba8adc3d7b205aaf4e927e25fa0408" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#middleware&quot;&gt;Middleware&lt;/a&gt; wraps the base dispatch function. It allows the dispatch function to handle &lt;a href=&quot;#async-action&quot;&gt;async actions&lt;/a&gt; in addition to actions. Middleware may transform, delay, ignore, or otherwise interpret actions or async actions before passing them to the next middleware. See below for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107b3ce80a3c02523b93e5b4d695a60fd20c2f63" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../glossary#middleware&quot;&gt;Middleware&lt;/a&gt; lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd07de91063da45b75bbcacd8cd309f14a69d740" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../glossary#reducer&quot;&gt;Reducers&lt;/a&gt; capture &amp;ldquo;the essence&amp;rdquo; of Flux Stores, so it's possible to gradually migrate an existing Flux project towards Redux, whether you are using &lt;a href=&quot;http://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt;, &lt;a href=&quot;http://github.com/goatslacker/alt&quot;&gt;Alt&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/flux&quot;&gt;traditional Flux&lt;/a&gt;, or any other Flux library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb64b4bed7a97c418523d4ffdb6288fb015adc1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt; describe the fact that &lt;em&gt;something happened&lt;/em&gt;, but don't specify how the application's state changes in response. This is the job of reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8dfe31e2797d17be898c68c93f8a46cba6d9313" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;advanced/asyncactions.md&quot;&gt;Async action creators&lt;/a&gt; such as &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; have access to the entire state through &lt;code&gt;getState()&lt;/code&gt;. An action creator can retrieve additional data from the state and put it in an action, so that each reducer has enough information to update its own state slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5742965a8a7e105526f64e826619bea7901c44" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt; is the base dispatch function described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a233ff3ae6a630832e9d6e12074eca1e882d9857" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; returns the current state of the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc71ff1690cdf43dbe0920fa906f24d0396f18eb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#replaceReducer&quot;&gt;&lt;code&gt;replaceReducer(nextReducer)&lt;/code&gt;&lt;/a&gt; can be used to implement hot reloading and code splitting. Most likely you won't use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3233aa220cb3c100f9d6ac87a89259afc4cae6e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt; registers a function to be called on state changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67aa063cda369295b907b7e537689d94e06b2f62" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;examples&quot;&gt;Official Examples&lt;/a&gt; &amp;mdash; A few official examples covering different Redux techniques</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2181ce81664ba928672afb23b8a32ab80e213e8a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;: Enzyme is a JavaScript Testing utility for React that makes it easier to assert, manipulate, and traverse your React Components' output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326058ae349999870d6aced66c0de2b764c93797" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow rendering&lt;/a&gt;: Shallow rendering lets you instantiate a component and effectively get the result of its &lt;code&gt;render&lt;/code&gt; method just a single level deep instead of rendering components recursively to a DOM. Shallow rendering is useful for unit tests, where you test a particular component only, and importantly not its children. This also means that changing a child component won't affect the tests for the parent component. Testing a component and all its children can be accomplished with &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/mount.html&quot;&gt;Enzyme's &lt;code&gt;mount()&lt;/code&gt; method&lt;/a&gt;, aka full DOM rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61241f2e9ceb67ae4dfccf7cc9ca1f400093495e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://camsong.github.io/redux-in-chinese/&quot;&gt;中文文档&lt;/a&gt; &amp;mdash; Chinese</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77565bb24c563c6df104040d230310edcfb00145" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://elm-lang.org/&quot;&gt;Elm&lt;/a&gt; is a functional programming language inspired by Haskell and created by &lt;a href=&quot;https://twitter.com/czaplic&quot;&gt;Evan Czaplicki&lt;/a&gt;. It enforces &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;a &amp;ldquo;model view update&amp;rdquo; architecture&lt;/a&gt;, where the update has the following signature: &lt;code&gt;(action, state) =&amp;gt; state&lt;/code&gt;. Elm &amp;ldquo;updaters&amp;rdquo; serve the same purpose as reducers in Redux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d2c2107aca181c46e778f07e56614a8133b8c1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://es.redux.js.org/&quot;&gt;Redux en Espa&amp;ntilde;ol&lt;/a&gt; - Spanish</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff86a93740e76f0a9a588dfc7edd94627d0b6065" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utils&lt;/a&gt;: Test Utilities for React. Used by Enzyme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa318edcedf300020034617867e41d3d7d461c6b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;Redux DevTools&lt;/a&gt; &amp;mdash; An action logger with time travel UI, hot reloading and error handling for the reducers, &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;first demoed at React Europe&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8169d6309556697be51098425caaa8733bba177f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; &amp;mdash; The easiest way to write async action creators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27a8933220f7b51407b0697067eeebc832de481" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/&quot;&gt;Turning the database inside-out&lt;/a&gt; for blowing my mind;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b2722ca06d7e3809116a97bf38d37832bcb0ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://youtube.com/watch?v=xsSnOQynTHs&quot;&gt;Live React: Hot Reloading and Time Travel&lt;/a&gt; &amp;mdash; See how constraints enforced by Redux make hot reloading with time travel easy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bc316623c9deb9e9034f7d23637072db15a0f28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; is a part of ES6, but is not implemented by most browsers yet. You'll need to either use a polyfill, a &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-object-assign&quot;&gt;Babel plugin&lt;/a&gt;, or a helper from another library like &lt;a href=&quot;https://lodash.com/docs#assign&quot;&gt;&lt;code&gt;_.assign()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bee8f422e4c2ab236c312da17a9c38cac75683" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Getting Started with Redux&lt;/a&gt; is a video course consisting of 30 videos narrated by Dan Abramov, author of Redux. It is designed to complement the &amp;ldquo;Basics&amp;rdquo; part of the docs while bringing additional insights about immutability, testing, Redux best practices, and using Redux with React. &lt;strong&gt;This course is free and will always be.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2950e131e272fe84d311faa920bbd6acbf06f7a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt; is a JavaScript library implementing persistent data structures. It is performant and has an idiomatic JavaScript API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5833afba76ada5ae020425be0bb3df43c4f7430" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ForbesLindesay/redux-optimist&quot;&gt;redux-optimist&lt;/a&gt; &amp;mdash; Optimistically apply actions that can be later committed or reverted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246e34aae7982e56bc50e3cae1f0ce328818b50c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt; is a superb way to manage the complexity of asynchronous apps. In fact &lt;a href=&quot;http://cycle.js.org&quot;&gt;there is an effort to create a library that models human-computer interaction as interdependent observables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1628bafccfa550b14477fdcb8a2880af27d670" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Yomguithereal/baobab&quot;&gt;Baobab&lt;/a&gt; is another popular library implementing immutable API for updating plain JavaScript objects. While you can use it with Redux, there is little benefit in using them together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca68c66f6b4c6a980738b0b474b7797724c475ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; for teaching me to approach Flux without boilerplate or singletons;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462c24fee4dc0ea20edf2fb2bcab21199e928183" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; &amp;mdash; A human-friendly standard for Flux action objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6681847f5ac1aebff1682d6668c0423aa44ef28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt; &amp;mdash; Reduces the boilerplate in writing reducers and action creators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e21d89989e6407db8130754d1c8cc4ea48c320c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; &amp;mdash; &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;FSA&lt;/a&gt;-compliant promise middleware</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc32c5ec0e57af144b709327c464173a6558f7a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-transducers&quot;&gt;redux-transducers&lt;/a&gt; &amp;mdash; Transducer utilities for Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635f1546df5dc27cea670f0285cbf50019b2608f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/alexkuz/redux-devtools-inspector&quot;&gt;Inspector&lt;/a&gt; &amp;mdash; A custom monitor for Redux DevTools that lets you filter actions, inspect diffs, and pin deep paths in the state to observe their changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5392440f66a0b62817730b32d7e87386d20ed41e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/andrewngu/sound-redux&quot;&gt;SoundRedux&lt;/a&gt; &amp;mdash; A SoundCloud client built with Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="671366abacb074ef67f4cf3094e172cad3c7de19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/apollostack/apollo-client&quot;&gt;apollo-client&lt;/a&gt; &amp;mdash; A simple caching client for any GraphQL server and UI framework built on top of Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e948c295aecd2de19653c56dd37e6164bc205c0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt; &amp;mdash; Mock redux store for testing your app</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a572eea1e304e2b4d1765dc1dd8e7e6d040fb4a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/bvaughn/redux-devtools-filterable-log-monitor/&quot;&gt;Filterable Log Monitor&lt;/a&gt; &amp;mdash; Filterable tree view monitor for Redux DevTools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738b91de5b474d6632d5e4c6ca13f26cbbbfe538" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/calesce/redux-slider-monitor&quot;&gt;Slider Monitor&lt;/a&gt; &amp;mdash; A custom monitor for Redux DevTools to replay recorded Redux actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b82050d15ff636cab86ab964babce485a0a59e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cerebral/redux-action-tree&quot;&gt;redux-action-tree&lt;/a&gt; &amp;mdash; Composable Cerebral-style signals for Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cb45ad1ce1a52403984ab13791a016bacbef87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/chentsulin/redux&quot;&gt;繁體中文文件&lt;/a&gt; &amp;mdash; Traditional Chinese</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7237f437351893c36e43e30f1a66cf47ac72460d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cyclejs-community/redux-cycles&quot;&gt;redux-cycles&lt;/a&gt; &amp;mdash; Handle Redux async actions using Cycle.js</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d850aef967058fa2b6d38c9b44bb6100d7ef473" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cyclejs/cycle-core&quot;&gt;Cycle&lt;/a&gt; for showing how often a function is the best tool;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b646bb52b5ada7949ead74ceb015522a73c82f52" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/davidkpiano/react-redux-form&quot;&gt;react-redux-form&lt;/a&gt; &amp;mdash; Create forms easily in React with Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b485a9343cd81ce214624d7ee75dd8b5f957f28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/dmitry-zaets/redux-actions-assertions&quot;&gt;redux-actions-assertions&lt;/a&gt; &amp;mdash; Assertions for Redux actions testing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d0704f90d9fc9bec2f6289de5455def009259f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ekosz/redux-falcor&quot;&gt;redux-falcor&lt;/a&gt; &amp;mdash; Falcor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7052bc5ca61cda06f2e818249aab92d0c11f8df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikras/ducks-modular-redux&quot;&gt;Ducks: Redux Reducer Bundles&lt;/a&gt; &amp;mdash; A proposal for bundling reducers, action types and actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad64f1b1acf59b7989610892266e94fa9a6e64b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikras/redux-form&quot;&gt;redux-form&lt;/a&gt; &amp;mdash; Keep React form state in Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a49ddf7651bd6d746fee97f180340c5c22b41b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial&quot;&gt;The Elm Architecture&lt;/a&gt; for a great intro to modeling state updates with reducers;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4545fd7b6adf364efdbb91002ae394c5e58615" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; &amp;mdash; Efficient derived data selectors inspired by NuclearJS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7708a46f9be2f564980d4e5bda78b4c5d35dc9de" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;React&lt;/a&gt; for the pragmatic innovation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a476b863690c612db3b916dce5198f075291ef2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;redux-logger&lt;/a&gt; &amp;mdash; Log every Redux action and the next state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2168fa4ca440f276c71b288e63a7bd560f0d0edb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; &amp;mdash; React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49be928336c3ea70b586e1e0221f5209809256da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-devtools-dock-monitor&quot;&gt;Dock Monitor&lt;/a&gt; &amp;mdash; A resizable and movable dock for Redux DevTools monitors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77e5d33e4cdf47037c30e1ca512f37cfeb999700" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-devtools-log-monitor&quot;&gt;Log Monitor&lt;/a&gt; &amp;mdash; The default monitor for Redux DevTools with a tree view</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54d5349a1205ea2a9b173fd0057e9c134ab4d2d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Thunk middleware&lt;/a&gt; isn't the only way to orchestrate asynchronous actions in Redux:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a086cebb6f586cfe6a594cda767089a867b08af" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gajus/canonical-reducer-composition&quot;&gt;Canonical Reducer Composition&lt;/a&gt; &amp;mdash; An opinionated standard for nested reducer composition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e745d89480c38f6937d9c622112c47d79aaa31e4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; &amp;mdash; Used to create an equivalent function of Redux &lt;code&gt;combineReducers&lt;/code&gt; that works with &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c52fcd9623ac00993923a629ce837ba45e51c0e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gcanti/redux-tcomb&quot;&gt;redux-tcomb&lt;/a&gt; &amp;mdash; Immutable and type-checked state and actions for Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af81282584d63bf8638d0e9e5cc4817051b43838" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/johanneslumpe/redux-history-transitions&quot;&gt;redux-history-transitions&lt;/a&gt; &amp;mdash; History transitions based on arbitrary actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec6e8ad705f1aceaf230c55020882fad996b178" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/leoasis/redux-immutable-state-invariant&quot;&gt;redux-immutable-state-invariant&lt;/a&gt; &amp;mdash; Warns about state mutations in development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7905dff698bee7543c15da2228433d7b1d6a338f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markdalgleish/redial&quot;&gt;redial&lt;/a&gt; &amp;mdash; Universal data fetching and route lifecycle management for React that works great with Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e9eaeab55b0c8cd498c9f208fca819c29ea328" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markdalgleish/redux-analytics&quot;&gt;redux-analytics&lt;/a&gt; &amp;mdash; Analytics middleware for Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76bd67d8f88905517eed83dafa3047921d206f66" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React-Redux Links&lt;/a&gt; is a curated list of high-quality articles, tutorials, and related content for React, Redux, ES6, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7458fee6ef27b6ea44de14b58a088b3d484787c5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Ecosystem Links&lt;/a&gt; is a categorized collection of Redux-related libraries, addons, and utilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c521f74e329344dfada627572d0439c5ce27980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/mattkrick/redux-optimistic-ui&quot;&gt;redux-optimistic-ui&lt;/a&gt; &amp;mdash; A reducer enhancer to enable type-agnostic optimistic updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a22d71db7bc4a31e59f65f17a1c4390b8be913" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/mohebifar/grafgiti&quot;&gt;grafgiti&lt;/a&gt; &amp;mdash; Create graffiti on your GitHub contributions wall</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcdd90fbe1bce5cda821db0cbb40e37a05bb4838" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om&lt;/a&gt; for popularizing the idea of a single state atom;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126f6dcd5981219780c79f04dab128927a0c526e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; &amp;mdash; Ignore redux actions by array or filter function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="522c27cd295aa2f0b11343353b70bfe170950f50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-recycle&quot;&gt;redux-recycle&lt;/a&gt; &amp;mdash; Reset the redux state on certain actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e04e334289a63c7eb319c457b7a701b7a18d175" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;redux-undo&lt;/a&gt; &amp;mdash; Effortless undo/redo and action history for your reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6afe4d71b345b389ea720ccf3e22bb58ff5fe1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/optimizely/nuclear-js&quot;&gt;NuclearJS&lt;/a&gt; for proving this architecture can be performant;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a0eceb1b164ebfa98d862358a8699dd0e2f1b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; &amp;mdash; Normalize nested API responses for easier consumption by the reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f9399982e1960cfde9ce2d4776f97eff213665" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; &amp;mdash; An opinionated library for making reducers and action creators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e142b1d7524dc9418bc9105b107102a2fd757747" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/peter-mouland/react-lego&quot;&gt;React-lego&lt;/a&gt; &amp;mdash; How to plug into React, one block at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7170877b7e65113318685e20beab1c145c3d9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;redux-loop&lt;/a&gt; &amp;mdash; Sequence effects purely and naturally by returning them from your reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e82f58dea0ceacdd0d73fa2c46474f99faa32f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/rajdee/redux-in-russian&quot;&gt;Redux in Russian&lt;/a&gt; &amp;mdash; Russian</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="911ae2c57d05e9d855f2f55ff67275735c340d15" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React bindings&lt;/a&gt; are not included in Redux by default. You need to install them explicitly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668aa71ef061f4bf5fb388597bd4ba6608d4c54b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/react-router-redux&quot;&gt;react-router-redux&lt;/a&gt; &amp;mdash; Ruthlessly simple bindings to keep React Router and Redux in sync</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c27d0e05c340bb3f9aef884df7dc33cd70121a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt; is a simple library for creating memoized, composable &lt;strong&gt;selector&lt;/strong&gt; functions. Reselect selectors can be used to efficiently compute derived data from the Redux store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba8f921a9c78cafaacaa6ee8c5f98b20c97a3b5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;backbone-redux&lt;/a&gt; &amp;mdash; Backbone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77488ca5a784aa384877c247d815112efb36766" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/redux-observable/redux-observable/&quot;&gt;redux-observable&lt;/a&gt; &amp;mdash; RxJS middleware for action side effects using &quot;Epics&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828ba846080beeaf8593a911bc08a82eae111e4c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/remojansen/redux-bootstrap&quot;&gt;redux-bootstrap&lt;/a&gt; &amp;mdash; Bootstrapping function for Redux applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7feaf455447814c0b1409ee14b19a53959a4aa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/romseguy/redux-devtools-chart-monitor&quot;&gt;Chart Monitor&lt;/a&gt; &amp;mdash; A chart monitor for Redux DevTools</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a2a8fab7f2253f7754f7fddd44616ca6818b07" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/salsita/redux-side-effects&quot;&gt;redux-side-effects&lt;/a&gt; &amp;mdash; Utilize Generators for declarative yielding of side effects from your pure reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff5b0a547b627bfa68c17e7844cedfb2ed89258" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/samiskin/redux-electron-store&quot;&gt;redux-electron-store&lt;/a&gt; &amp;mdash; Store enhancers that synchronize Redux stores across Electron processes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead5dd38514e378fce4086ebe8dd69902a5b98c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/socialtables/redux-unhandled-action&quot;&gt;redux-unhandled-action&lt;/a&gt; &amp;mdash; Warns about actions that produced no state changes in development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf95415084cc2980fc6fc410238771c666d7e934" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/svrcekmichal/redux-axios-middleware&quot;&gt;redux-axios-middleware&lt;/a&gt; &amp;mdash; Redux middleware for fetching data with axios HTTP client</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="488dc9a66e0ee669bd6c2836ade49d817496c75f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt; &amp;mdash; Customize batching and debouncing calls to the store subscribers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62d13ae7d772ba57c13adb46a8d192d8b354469" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/threepointone/disto&quot;&gt;disto&lt;/a&gt; for a proof of concept of hot reloadable Stores;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912430794c537f9a04fb5544fe58c82ee48c26e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/toranb/ember-redux&quot;&gt;ember-redux&lt;/a&gt; - Ember.js</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2212eb90d319aca256b12839bd5d9dcd2540c5d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/treasure-data/redux-search&quot;&gt;redux-search&lt;/a&gt; &amp;mdash; Automatically index resources in a web worker and search them without blocking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e82c33a3fc3f5c23b3991ac9deca81f6412a661" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/troch/deku-redux&quot;&gt;deku-redux&lt;/a&gt; &amp;mdash; Deku</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99aa71b3cf414c2d077d231fe32a1a8b772e1744" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; &amp;mdash; Dispatch several actions with a single subscriber notification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1f69116287116136f16831edea2d4b75387cad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tur-nr/polymer-redux&quot;&gt;polymer-redux&lt;/a&gt; - Polymer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e8533e56143915a47d6d3230814c97d167fc30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/wbuchwalter/ng-redux&quot;&gt;ng-redux&lt;/a&gt; &amp;mdash; Angular</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1adb84ec0d3fedd9d8140dcfd21cfdaba981e57e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/wbuchwalter/ng2-redux&quot;&gt;ng2-redux&lt;/a&gt; &amp;mdash; Angular 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd42afd688fd3993d131ac58c470db0ca64d0ed6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/weo-edu/redux-gen&quot;&gt;redux-gen&lt;/a&gt; &amp;mdash; Generator middleware for Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cebbfc649b40e0fa8771d195a93b9007758c40f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/whetstone/redux-devtools-diff-monitor&quot;&gt;Diff Monitor&lt;/a&gt; &amp;mdash; A monitor for Redux Devtools that diffs the Redux store mutations between actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="884a589c3e5de51191487d1c59f1e5b7ee3a0166" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt; is an extensive list of Redux-related repositories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce41d2fa6e7a2ae377463a862099fc7ee043817" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;redux-saga&lt;/a&gt; &amp;mdash; An alternative side effect model for Redux apps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542f399508a2cf17f958319802f4280895a81ac0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-extension&quot;&gt;Redux DevTools Extension&lt;/a&gt; &amp;mdash; A Chrome extension wrapping Redux DevTools and providing additional functionality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff1493331d9a72ee214aa8584a7e46f854bd6c8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-filter-actions&quot;&gt;Filter Actions&lt;/a&gt; &amp;mdash; Redux DevTools composable monitor with the ability to filter actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="610aadc45610fd3178ec1a4d0f1659f86c3a4382" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616278911886884864&quot;&gt;Yes&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/andrestaltz/status/616270755605708800&quot;&gt;no&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281d252a27e2a0e50333c0c16988433e3ea99926" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;Webpack&lt;/a&gt; for Hot Module Replacement;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d362f1adc4636a71a99777bb9d42676751de79ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.smashingmagazine.com/2016/09/how-to-scale-react-applications/&quot;&gt;How to Scale React Applications&lt;/a&gt; (accompanying talk: &lt;a href=&quot;https://vimeo.com/168648012&quot;&gt;Scaling React Applications&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f14c153057f3e5ff2c682e211890c3c01452d71" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=j-kj2qwJa_E&quot;&gt;Developing ClojureScript with Figwheel&lt;/a&gt; for convincing me that re-evaluation should &amp;ldquo;just work&amp;rdquo;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d62e70b9137a15eb36c4bfaf278d14decfd6a4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=okdC5gcD-dM&quot;&gt;Redux: Simplifying Application State&lt;/a&gt; &amp;mdash; An intro to Redux architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad10d1cb466100f8a4ae95925886bfea9a5588ad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=qUlRpybs7_c&quot;&gt;Cleaning the Tar: Using React within the Firefox Developer Tools&lt;/a&gt; &amp;mdash; Learn how to gradually migrate existing MVC applications to Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b737ab7c1094f632e450d8432a9c9e16474bd23" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#async&quot;&gt;Async&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34453405ef6fc18e6e87655693ec2a2bb89f30b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#counter&quot;&gt;Counter&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b547e4f69fe31aac6b4dafd6e1ff2c05b103e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;source&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a364d666ad866f057b55528bf8003b6e7a3980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#real-world&quot;&gt;Real World&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96efe2982c4c1669ba1a120bc8297246cc6203f9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#shopping-cart&quot;&gt;Shopping Cart&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eca3dbaee744d35d31909fa899561a59637eca0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todomvc&quot;&gt;TodoMVC&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e7c6464db15c19011138bab173c2e287d2a6fe" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todos&quot;&gt;Todos&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ed13dde4ab11bda58a26439a12403c10a6ca595" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todos-with-undo&quot;&gt;Todos with Undo&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99bbfebce7fe9d012028712df4b3acc2554bdba1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#tree-view&quot;&gt;Tree View&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f056bfcb955f7740e3c0f64a948b832302b714" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#universal&quot;&gt;Universal&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;source&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c38888890f5f4205fd2f24afd87133d7819484f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;patrons&quot;&gt;See the full list of Redux patrons.&lt;/a&gt;, as well as the always-growing list of &lt;a href=&quot;https://github.com/reactjs/redux/issues/310&quot;&gt;people and companies that use Redux&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e873131fc93496281859118adf805655ac8f12d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;...middleware&lt;/code&gt; (&lt;em&gt;arguments&lt;/em&gt;): Functions that conform to the Redux &lt;em&gt;middleware API&lt;/em&gt;. Each middleware receives &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;store#getState&quot;&gt;&lt;code&gt;getState&lt;/code&gt;&lt;/a&gt; functions as named arguments, and returns a function. That function will be given the &lt;code&gt;next&lt;/code&gt; middleware's dispatch method, and is expected to return a function of &lt;code&gt;action&lt;/code&gt; calling &lt;code&gt;next(action)&lt;/code&gt; with a potentially different argument, or at a different time, or maybe not calling it at all. The last middleware in the chain will receive the real store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method as the &lt;code&gt;next&lt;/code&gt; parameter, thus ending the chain. So, the middleware signature is &lt;code&gt;({ getState, dispatch }) =&amp;gt; next =&amp;gt; action&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14c94077eedb0b2bbe472c3d6a0d0b3e627f008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;action&lt;/code&gt; (&lt;em&gt;Object&lt;/em&gt;&lt;sup&gt;&amp;dagger;&lt;/sup&gt;): A plain object describing the change that makes sense for your application. Actions are the only way to get data into the store, so any data, whether from the UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions. Actions must have a &lt;code&gt;type&lt;/code&gt; field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for &lt;code&gt;type&lt;/code&gt; than &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; because strings are serializable. Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions could be constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9170163c0ef5281c7dbedc853c03ad10d33e30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;actionCreators&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt; or &lt;em&gt;Object&lt;/em&gt;): An &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creator&lt;/a&gt;, or an object whose values are action creators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd26650aa014fa2c77d3b47529964816520f847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; iterates through each of these key/value pairs. For each iteration, it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c91341660edf136591696dc683b24608c892dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; makes working with this style of structure easier by taking a &lt;code&gt;reducers&lt;/code&gt; argument that&amp;rsquo;s defined as a hash table comprising a set of key/value pairs, where each key is the name of a state slice, and the corresponding value is the reducer function that will act on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cb7dfb9552a2aace784e7bb958b5e547adeb025" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; takes an object full of slice reducer functions, and creates a function that outputs a corresponding state object with the same keys. This means that if no preloaded state is provided to &lt;code&gt;createStore&lt;/code&gt;, the naming of the keys in the input slice reducer object will define the naming of the keys in the output state object. The correlation between these names is not always apparent, especially when using ES6 features such as default module exports and object literal shorthands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afff2e083a32e71d2b99b63e31beee97a7bf5a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; will then return this new root state object to the store. The new object will have the same values as the current root state object, but because it's a different object, it will cause the store to be updated, which will ultimately cause all connected components to be re-rendered unnecessarily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d31c37d476a705be9d16ab99876f6f29a2911bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;completed: boolean&lt;/code&gt; is whether todo should appear crossed out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87ab9b4028e9a3e848f1e21390753d01e0de961" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dispatch&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;): A &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function available on the &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6065950184dca89f8adacb36f987e88b944855d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter: string&lt;/code&gt; is the visibility filter it represents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c642488e3cbd80e5e05acd841612af9ec636679" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;listener&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;): The callback to be invoked any time an action has been dispatched, and the state tree might have changed. You may call &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; inside this callback to read the current state tree. It is reasonable to expect that the store's reducer is a pure function, so you may compare references to some deep path in the state tree to learn whether its value has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60274854b8fc4c1adc45a0ccb85c9a471e84a06a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onClick()&lt;/code&gt; is a callback to invoke when a todo is clicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cabc66d0691eba5e97140d97c5af0c9e8160ca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onClick()&lt;/code&gt; is a callback to invoke when link is clicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041c016fc6813b17f1192148484f830acd43af01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onTodoClick(id: number)&lt;/code&gt; is a callback to invoke when a todo is clicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcbab3611a4b8e613b2b4cd09f9c1e9fb3baffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; property is an object with every param specified in the url. &lt;em&gt;e.g: &lt;code&gt;params&lt;/code&gt; will be equal to &lt;code&gt;{ filter: 'SHOW_COMPLETED' }&lt;/code&gt; if we are navigating to &lt;code&gt;localhost:3000/SHOW_COMPLETED&lt;/code&gt;. We can now read the URL from &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c2d7b03d06140fe6460c00b3e6ecceb3671905" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt; can be passed to &lt;code&gt;getVisibleTodos&lt;/code&gt; from &lt;code&gt;mapStateToProps&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c4b65f91bd45a4fc2fd57806ac6f36f1219c00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-router&lt;/code&gt; is available on npm . This guides assumes you are using &lt;code&gt;react-router@^2.7.0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1634dcd7c4b99901d4395c7f2e41abeb6383d21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducer&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;) The next reducer for the store to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c54c07a7b5f3ced1e0ad2afedb5ec66a8340b8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducer&lt;/code&gt;&lt;em&gt;(Function)&lt;/em&gt;: A &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; that returns the next &lt;a href=&quot;../glossary#state&quot;&gt;state tree&lt;/a&gt;, given the current state tree and an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt; to handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d247728fbc49f91b9cff3325a75f4fc504af79e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducers&lt;/code&gt; (&lt;em&gt;Object&lt;/em&gt;): An object whose values correspond to different reducing functions that need to be combined into one. See the notes below for some rules every passed reducer must follow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071297430dead4ef02608be9950bc0295007dab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;text: string&lt;/code&gt; is the text to show.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6601fc4649e95805e9085e851baecfbd9ca422e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toJS()&lt;/code&gt; is an expensive function and negates the purpose of using Immutable.JS. Avoid its use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5ee50dffe4060b939c67419ae23402ff2acb67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todos: Array&lt;/code&gt; is an array of todo items with &lt;code&gt;{ id, text, completed }&lt;/code&gt; shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52137cb27c8b0fda0f705acc5c2ab7d8fc83ac69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(any)&lt;/em&gt;: The current state tree of your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="546eefda4ace04ce1c70ef03ebe11baee59caa52" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;App state&lt;/em&gt;: data that is specific to the application's behavior (such as &quot;Todo #5 is currently selected&quot;, or &quot;there is a request in progress to fetch Todos&quot;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b84d5c7e9792f8e68b0e853bd33475fc3cf76b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do not put API calls into reducers.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7c7ebbf9d9f5dafd8f0eb2d9dee6e376c7e325" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Domain data&lt;/em&gt;: data that the application needs to show, use, or modify (such as &quot;all of the Todos retrieved from the server&quot;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103bdb5aaf028813664904c0a9712c441ff4dc83" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In addition, using &lt;code&gt;toJS&lt;/code&gt; in a Higher Order Component should not cause much, if any, performance degradation, as the component will only be called when the connected component&amp;rsquo;s props change. As with any performance issue, conduct performance checks first before deciding what to optimise.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f56da89fe63f5b0fdf50e9b3857e6d4e807205" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Reducers whose initial state is populated using &lt;code&gt;preloadedState&lt;/code&gt; will &lt;strong&gt;still need to provide a default value&lt;/strong&gt; to handle when passed a &lt;code&gt;state&lt;/code&gt; of &lt;code&gt;undefined&lt;/code&gt;. All reducers are passed &lt;code&gt;undefined&lt;/code&gt; on initialization, so they should be written such that when given &lt;code&gt;undefined&lt;/code&gt;, some value should be returned. This can be any non-&lt;code&gt;undefined&lt;/code&gt; value; there's no need to duplicate the section of &lt;code&gt;preloadedState&lt;/code&gt; here as the default.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ccd8f599d654d3c1988dcb7203039733cc9621" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: if your app requires high performance, you may need to avoid &lt;code&gt;toJS()&lt;/code&gt; altogether, and so will have to use Immutable.JS in your dumb components. However, for most apps this will not be the case, and the benefits of keeping Immutable.JS out of your dumb components (maintainability, portability and easier testing) will far outweigh any perceived performance improvements of keeping it in.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abce7fc4fc891211f9c2137610c7e67cd852170" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;React Router Redux&lt;/em&gt; creates a binding between your redux app and react-router and it keeps them in sync. Without this binding, you will not be able to rewind the actions with Time Travel. Unless you need this, React Router and Redux can operate completely apart.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db05ad144fe5ebf42ad286bef8f68f32d9f005f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Redux Router&lt;/em&gt; is an experimental library, it lets you keep entirely the state of your URL inside your redux store. It has the same API with React Router API but has a smaller community support than react-router.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f76be52041957c10fa3ece1ff9a6500b8a7f3130" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;State&lt;/em&gt; (also called the &lt;em&gt;state tree&lt;/em&gt;) is a broad term, but in the Redux API it usually refers to the single state value that is managed by the store and returned by &lt;a href=&quot;api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;. It represents the entire state of a Redux application, which is often a deeply nested object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e8d43be73f1edbce45221c84c8c093b0749d2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UI state&lt;/em&gt;: data that represents how the UI is currently displayed (such as &quot;The EditTodo modal dialog is currently open&quot;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf81a4c713219d00d15e705d738b32facd1c3ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; Discussions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; Discussions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9845432ee2811761e6bcff4526db436968becae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/courses/building-react-applications-with-idiomatic-redux&quot;&gt;Part 2: Building React Applications with Idiomatic Redux&lt;/a&gt; (27 free videos)&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdd52a88d7f6ae78b01e354f352bfb2f0dff656" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Getting Started with Redux&lt;/a&gt;&lt;/strong&gt; &amp;mdash; Learn the basics of Redux directly from its creator (30 free videos)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1235adb50ceb12211d0e304f950e2cb2539aca3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Part 1: Getting Started with Redux&lt;/a&gt; (30 free videos)&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65008044925d251beee2e760bdbf7d352cad495e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://learnredux.com&quot;&gt;Learn Redux&lt;/a&gt;&lt;/strong&gt; &amp;mdash; Build a simple photo app that will simplify the core ideas behind Redux, React Router and React.js</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f4ac2e2def8c3f5a536a05b0329a56f22f7adbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367&quot;&gt;You Might Not Need Redux&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d385341a00466471baf6bf0402c35cb513b738" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;AddTodo&lt;/code&gt;&lt;/strong&gt; is an input field with an &amp;ldquo;Add&amp;rdquo; button</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628abe199572c722710292d70c1925abc91676dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;App&lt;/code&gt;&lt;/strong&gt; is the root component that renders everything else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7b3701bac16523885d284f75957faf7ea4389c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;FilterLink&lt;/code&gt;&lt;/strong&gt; gets the current visibility filter and renders a &lt;code&gt;Link&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a71acf6c031a4f24eed213eed02c5416da7ab1dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Footer&lt;/code&gt;&lt;/strong&gt; is where we let the user change currently visible todos.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e4d8ed2a6c4ce299050d24a32e6f7c64862715e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/strong&gt; is a link with a callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81649898f991e4665328250d8eea26cc2edbc98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Todo&lt;/code&gt;&lt;/strong&gt; is a single todo item.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f96f74e7301539bacf1f9c6bd718980a2d9daf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;TodoList&lt;/code&gt;&lt;/strong&gt; is a list showing visible todos.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ec9d638aa6d81f7ef6d2682f120d0fd13ab2a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;VisibleTodoList&lt;/code&gt;&lt;/strong&gt; filters the todos according to the current visibility filter and renders a &lt;code&gt;TodoList&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d0712239a704041ee112eaeba6a14ab513b61e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Using local component state is fine&lt;/em&gt;&lt;/strong&gt;. As a developer, it is &lt;em&gt;your&lt;/em&gt; job to determine what kinds of state make up your application, and where each piece of state should live. Find a balance that works for you, and go with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5889d668f635907ed9dfa122cde5a199a20be785" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;case function&lt;/em&gt;&lt;/strong&gt;: a function that is being used to handle the update logic for a specific action. This may actually be a reducer function, or it may require other parameters to do its work properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e0dfdc33c924359812aab966fcb011eaef8e7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;higher-order reducer&lt;/em&gt;&lt;/strong&gt;: a function that takes a reducer function as an argument, and/or returns a new reducer function as a result (such as &lt;code&gt;combineReducers&lt;/code&gt;, or &lt;code&gt;redux-undo&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401ed42d073adeb6ecd950168ad981e271a2b5a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;reducer&lt;/em&gt;&lt;/strong&gt;: any function with the signature &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; (ie, any function that &lt;em&gt;could&lt;/em&gt; be used as an argument to &lt;code&gt;Array.prototype.reduce&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b0e566a3672de250a1434def164d63af6cba98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;root reducer&lt;/em&gt;&lt;/strong&gt;: the reducer function that is actually passed as the first argument to &lt;code&gt;createStore&lt;/code&gt;. This is the only part of the reducer logic that &lt;em&gt;must&lt;/em&gt; have the &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a64e360c4d5878942159990e891828399749146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;slice reducer&lt;/em&gt;&lt;/strong&gt;: a reducer that is being used to handle updates to one specific slice of the state tree, usually done by passing it to &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2551e86cf6417db6bf5798c49bdf5292397b5d4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Action creators&lt;/strong&gt; are exactly that&amp;mdash;functions that create actions. It's easy to conflate the terms &amp;ldquo;action&amp;rdquo; and &amp;ldquo;action creator,&amp;rdquo; so do your best to use the proper term.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da8e22fc9c738da2f9e48212ed18a6dba30b50c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Actions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Actions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19d9668859b20c765c85260461deb4090e7c90c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Actions&lt;/strong&gt; are payloads of information that send data from your application to your store. They are the &lt;em&gt;only&lt;/em&gt; source of information for the store. You send them to the store using &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2a8e7b602c9f54e206267bc8541a8f186454fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Also read:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39113b04f672edb3817c5d406408774e2e082af0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request began.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994001ceb8ce97cddf25a8c05987ea9c83e99a47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request failed.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7648023b0f97bbd162694c4bb9ebb7f2898c3bca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request finished successfully.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990d6bce9d1a24f59b9efaf18dc81a2290c580f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Articles&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Articles&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e169e5d7d50b4c65d5eb45d17d2193a3d3fe48c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But there is a problem!&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b54c7910d861b8a3eca842a30a66fd0932de39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Chrome Extension&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80cf8bc624de85df678b42470029fc4d69f07a66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code Structure&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3318cdef256aecde044aa8d93fc255bf75f49a52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discussion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Discussion&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41fc516c487bc5c3b496e3bd45dc251647980f5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discussions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Discussions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9a56caeef5914fb0e23b98d65cf00abd25d9b22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Documentation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Documentation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c28df48234b0e1020c84b073dd49644f35f59ab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finally, you can write your own middleware.&lt;/strong&gt; Let's say you want to generalize the pattern above and describe your async action creators like this instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e850b9ecbb25492de24c73963c25bba203a9b8f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;General&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;General&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a426959f751e24e2f5918ae148f99e35ec8ec248" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Gists&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Gists&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b835ddfaad1c3b1909f0f1f8838c00992cdebd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the &lt;code&gt;mapStateToProps&lt;/code&gt; argument supplied to &lt;code&gt;connect&lt;/code&gt; returns a function instead of an object, it will be used to create an individual &lt;code&gt;mapStateToProps&lt;/code&gt; function for each instance of the container.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3529f38f1732dd9f8dde4fa1c2954e730482cd3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Immutable Data&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f813b4dc0b9eb9217d5b61ec52b5ac9f1ef177d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In general, &lt;code&gt;preloadedState&lt;/code&gt; wins over the state specified by the reducer. This lets reducers specify initial data that makes sense &lt;em&gt;to them&lt;/em&gt; as default arguments, but also allows loading existing data (fully or partially) when you're hydrating the store from some persistent storage or the server.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630d2928116ed006d43b0e103005e502467a2bd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Concepts&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="177d318924b7fa70e3cefd19afe9a19a2e28bd31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key concepts&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af40680dea48a4f1aadecc6d0a580f293be76302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Learn Redux from its creator:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24d8f44e0ff187836ea30a46af3fa4eae82a5814" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Libraries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Libraries&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40f69f52a2524079b625a242912cdd7403598e0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Middleware lets us write more expressive, potentially async action creators.&lt;/strong&gt; It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can &amp;ldquo;catch&amp;rdquo; dispatched Promises and turn them into a pair of request and success/failure actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8714d9061814fc6644471ebf65e80673c74fbf2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Miscellaneous&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Miscellaneous&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aba37422ce93d442e229cdf88aefd1289e7a0ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that each of these reducers is managing its own part of the global state. The &lt;code&gt;state&lt;/code&gt; parameter is different for every reducer, and corresponds to the part of the state it manages.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428baf6d60cd9f08dad452710b2d0853a0611819" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this example is deliberately written in a verbose style in order to illustrate the concepts and the process of refactoring, rather than perfectly concise code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cbd86caa1de0f5ed851d50bc59d467e542c9b43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Organizing State&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48bf5499e3ac63560ca0e0106a29021adb072bfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5467c8d8afabc0b3e1dae4c2485529c53412f57a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React Redux&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a646a6010d9b1f0d5fd5b00988f7164e7d8f806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reading List&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f87ea91cacfbae403f6d54b8d0956ef3fc4100f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reading list&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026e47e10ea129bc5e718a865b1c71228f70d1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reducers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reducers&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="463c2d07ea9bf2ad77b66d873753301b6924a007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Redux doesn't care &lt;em&gt;how&lt;/em&gt; you store the state&amp;mdash;it can be a plain object, an Immutable object, or anything else.&lt;/strong&gt; You'll probably want a (de)serialization mechanism for writing universal apps and hydrating their state from the server, but other than that, you can use any data storage library &lt;em&gt;as long as it supports immutability&lt;/em&gt;. For example, it doesn't make sense to use Backbone for Redux state, because Backbone models are mutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f99c682875e5330991bcf2249db3e897d5de6b10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Store Setup&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adf27317bc0760c4fef5a11f3e4243d9c2dea6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;a href=&quot;../glossary#state&quot;&gt;state&lt;/a&gt; of your whole application is stored in an object tree within a single &lt;a href=&quot;../glossary#store&quot;&gt;store&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4155b94bfe17bf25fe0157204c773ff981821e3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Redux store calls the reducer function you gave it.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3830df7c81157ba8c707d873fd73f6f0cdb0f81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Redux store saves the complete state tree returned by the root reducer.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7aa48ecb73dff1c83c59ee1b15f802da34287b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The only way to change the state is to emit an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt;, an object describing what happened.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c9a991ab2ae928e8e00868d0eba489d79e40a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The root reducer may combine the output of multiple reducers into a single state tree.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e49059d9b4193d453aca3973e78f45f15c2c3d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is exactly what Redux middleware looks like.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76be9cf756727c3afc31669a1734af0a6b6997c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To specify how the state tree is transformed by actions, you write pure &lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef565370cf3245efa7f66d5b780fcb67eebf3a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using Immutable.JS with Redux&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581be5c9a50c413f04d51268170098e3b7d44abb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Video&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Video&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7086101439d0140de8af057ae87cdfb81255c2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We don't mutate the &lt;code&gt;state&lt;/code&gt;.&lt;/strong&gt; We create a copy with &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Object.assign(state, { visibilityFilter: action.filter })&lt;/code&gt; is also wrong: it will mutate the first argument. You &lt;strong&gt;must&lt;/strong&gt; supply an empty object as the first parameter. You can also enable the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; to write &lt;code&gt;{ ...state, ...newState }&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee5f2fe633882a55b56c42023653a1999e34048" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We return the previous &lt;code&gt;state&lt;/code&gt; in the &lt;code&gt;default&lt;/code&gt; case.&lt;/strong&gt; It's important to return the previous &lt;code&gt;state&lt;/code&gt; for any unknown action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e435f9e093dd6f82c9230b9232861cf3d23f3321" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You call&lt;/strong&gt;&lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f4e7a77e49b844e6d09e31eed53faed808efc94" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&amp;dagger;&lt;/sup&gt; The &amp;ldquo;vanilla&amp;rdquo; store implementation you get by calling &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; only supports plain object actions and hands them immediately to the reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c279ff6853909cda37bddfb350ceef56e21365" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dispatching function&lt;/em&gt; (or simply &lt;em&gt;dispatch function&lt;/em&gt;) is a function that accepts an action or an &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt;; it then may or may not dispatch one or more actions to the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec526b8fa830efd01fb591e76b77adf20e29497" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reducer enhancer&lt;/em&gt; (or a &lt;em&gt;higher order reducer&lt;/em&gt;) is a function that takes a reducer, and returns a new reducer that is able to handle new actions, or to hold more state, delegating control to the inner reducer for the actions it doesn't understand. This isn't a new pattern&amp;mdash;technically, &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; is also a reducer enhancer because it takes reducers and returns a new reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f6e31c957bc32bf7205d27b105533b64b11e59" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reducer&lt;/em&gt; (also called a &lt;em&gt;reducing function&lt;/em&gt;) is a function that accepts an accumulation and a value and returns a new accumulation. They are used to reduce a collection of values down to a single value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eba9d63a46e1040299343c1cba8ee39cab099e4" translate="yes" xml:space="preserve">
          <source>A Better File Structure for React/Redux Applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0db97b3caad08800e67bceba3655a16a4f42cb" translate="yes" xml:space="preserve">
          <source>A Case for setState</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c12a94fc1ee1fe47d7abe792ff5a9b7def031d" translate="yes" xml:space="preserve">
          <source>A Deep Dive into React Perf Debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5b0d4140e816f05523e9bb1e2dcd4ec9a913dc" translate="yes" xml:space="preserve">
          <source>A Note for Flux Users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779923a9da175253b9122887cfa0972c4cb74e6e" translate="yes" xml:space="preserve">
          <source>A Note on Mixing ES6 Modules and CommonJS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db41c4cd245302803e94359aaa69cba0b0f06284" translate="yes" xml:space="preserve">
          <source>A Redux state usually has a plain Javascript object as the top of the state tree. (It is certainly possible to have another type of data instead, such as a single number, an array, or a specialized data structure, but most libraries assume that the top-level value is a plain object.) The most common way to organize data within that top-level object is to further divide data into sub-trees, where each top-level key represents some &quot;domain&quot; or &quot;slice&quot; of related data. For example, a basic Todo app's state might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95746f061e18147c8c2a55d13555d7725bb143b" translate="yes" xml:space="preserve">
          <source>A better usage might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b48f874d11bc5b272adec4dc58721d09af5d10c0" translate="yes" xml:space="preserve">
          <source>A cartoon intro to Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9bf7de4be37a17f5d19505f713bd1be6f33e3ac" translate="yes" xml:space="preserve">
          <source>A deep dive into Clojure&amp;rsquo;s data structures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0451b576bd71ffbe13c32dc53912051fc439260e" translate="yes" xml:space="preserve">
          <source>A different useful transformation that comes to my mind is reporting JavaScript errors in production. The global &lt;code&gt;window.onerror&lt;/code&gt; event is not reliable because it doesn't provide stack information in some older browsers, which is crucial to understand why an error is happening.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4484c12f25bb46be91193117c01544958d6300" translate="yes" xml:space="preserve">
          <source>A good first step might be to break out a utility function to return a new object with updated fields. There's also a repeated pattern with trying to update a specific item in an array that we could extract to a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a086635bdf1493f65c3720a831f2e56113ebce" translate="yes" xml:space="preserve">
          <source>A list of many immutable update utilities can be found in the &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities&quot;&gt;Immutable Data#Immutable Update Utilities&lt;/a&gt; section of the &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5180d4d6c3b37f40d01a33af1b0f3baa180c07" translate="yes" xml:space="preserve">
          <source>A memoized selector can itself be an input-selector to another memoized selector. Here is &lt;code&gt;getVisibleTodos&lt;/code&gt; being used as an input-selector to a selector that further filters the todos by keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1715344fa5f33e240f9d1d585beffe859e05b0df" translate="yes" xml:space="preserve">
          <source>A middleware is a higher-order function that composes a &lt;a href=&quot;#dispatching-function&quot;&gt;dispatch function&lt;/a&gt; to return a new dispatch function. It often turns &lt;a href=&quot;#async-action&quot;&gt;async actions&lt;/a&gt; into actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b81652bf02ff7bf772129a812fc4e04bf51ded" translate="yes" xml:space="preserve">
          <source>A nice thing about React components is that they are usually small and only rely on their props. That makes them easy to test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66c5775c8d40ff721fc8d112637246b185d62e5b" translate="yes" xml:space="preserve">
          <source>A popular convention is to name reducers after the state slices they manage, so you can use ES6 property shorthand notation: &lt;code&gt;combineReducers({ counter, todos })&lt;/code&gt;. This is equivalent to writing &lt;code&gt;combineReducers({ counter: counter, todos: todos })&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6142fea1802b9d891098496555324f048dfc4ab1" translate="yes" xml:space="preserve">
          <source>A reducer enhancer that combines other reducers might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85855b61915007bb41ecf73529b533adae4a769a" translate="yes" xml:space="preserve">
          <source>A reducer enhancer that doesn't do anything looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2848c8d31433a5257b89be2c33d6bbc13ce44e" translate="yes" xml:space="preserve">
          <source>A reducer should return the new state after applying the action to the previous state, and that's the behavior tested below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6bc5c6b208bc72c706a97b8ea7f4de3a455d2c" translate="yes" xml:space="preserve">
          <source>A selector created with &lt;code&gt;createSelector&lt;/code&gt; only returns the cached value when its set of arguments is the same as its previous set of arguments. If we alternate between rendering &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;1&quot; /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;2&quot; /&amp;gt;&lt;/code&gt;, the shared selector will alternate between receiving &lt;code&gt;{listId: 1}&lt;/code&gt; and &lt;code&gt;{listId: 2}&lt;/code&gt; as its &lt;code&gt;props&lt;/code&gt; argument. This will cause the arguments to be different on each call, so the selector will always recompute instead of returning the cached value. We'll see how to overcome this limitation in the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7fdd19e31d4aa5c08f59368d084b0cdd3afe5c5" translate="yes" xml:space="preserve">
          <source>A shallow equality check is therefore as simple (and as fast) as &lt;code&gt;a === b&lt;/code&gt;, whereas a deep equality check involves a recursive traversal through the properties of two objects, comparing the value of each property at each step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bba7fd75614daa0e3f257e0f35cbfa400838a5b" translate="yes" xml:space="preserve">
          <source>A store creator is a function that creates a Redux store. Like with dispatching function, we must distinguish the base store creator, &lt;a href=&quot;api/createstore&quot;&gt;&lt;code&gt;createStore(reducer, preloadedState)&lt;/code&gt;&lt;/a&gt; exported from the Redux package, from store creators that are returned from the store enhancers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0498b8c765baf0d793d01093c2d3938c7acad2d2" translate="yes" xml:space="preserve">
          <source>A store enhancer is a higher-order function that composes a store creator to return a new, enhanced store creator. This is similar to middleware in that it allows you to alter the store interface in a composable way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ff26cb12d9ecc5ea599ca905718232908db10a" translate="yes" xml:space="preserve">
          <source>A store holds the whole &lt;a href=&quot;../glossary#state&quot;&gt;state tree&lt;/a&gt; of your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db90563ef06aad2359ba2b820d66958cfae253aa" translate="yes" xml:space="preserve">
          <source>A store is an object that holds the application's state tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8139366b65a6efd49fd2de96e65c9cf4f80822d2" translate="yes" xml:space="preserve">
          <source>A store is not a class. It's just an object with a few methods on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd2226f91b259d8b3ba9075e912f9f1b756eb73" translate="yes" xml:space="preserve">
          <source>A third approach would be to use the reducer generated by &lt;code&gt;combineReducers&lt;/code&gt; to handle the &quot;simple&quot; cases where each slice reducer can update itself independently, but also use another reducer to handle the &quot;special&quot; cases where data needs to be shared across slices. Then, a wrapping function could call both of those reducers in turn to generate the final result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a29a2d5178bbb1dcd22edfd2b4d56832e62a760" translate="yes" xml:space="preserve">
          <source>A typical app's state shape might look roughly like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7f5eb9f1f3f2372ac3b7d3fc72f9fa655d209b" translate="yes" xml:space="preserve">
          <source>A typical application will likely have a mixture of relational data and non-relational data. While there is no single rule for exactly how those different types of data should be organized, one common pattern is to put the relational &quot;tables&quot; under a common parent key, such as &quot;entities&quot;. A state structure using this approach might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0682f7888392082612529e79e90a8568fdf278b" translate="yes" xml:space="preserve">
          <source>API: React-Redux&amp;rsquo;s connect function and &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b79cd36dd33f71f26f84428e7993c489d7d7b4" translate="yes" xml:space="preserve">
          <source>API: Store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c9492b063857505209dc57c11cd7626823a1e5" translate="yes" xml:space="preserve">
          <source>API: applyMiddleware</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933d49b5bdf3528c648138b4bc997b3bd1ee051d" translate="yes" xml:space="preserve">
          <source>API: combineReducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2257d3cbebe55ab5120cd90126477209348170" translate="yes" xml:space="preserve">
          <source>Accessing React Props in Selectors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3702d1af5b6f51067a97e15b727d6bb1e395e0" translate="yes" xml:space="preserve">
          <source>Accidental Object Mutation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bcac5b1b8316670488ac51d4cfe888b1904b8d" translate="yes" xml:space="preserve">
          <source>Accidentally mutating or modifying your state directly is by far the most common reason why components do not re-render after an action has been dispatched. Redux expects that your reducers will update their state &amp;ldquo;immutably&amp;rdquo;, which effectively means always making copies of your data, and applying your changes to the copies. If you return the same object from a reducer, Redux assumes that nothing has been changed, even if you made changes to its contents. Similarly, React Redux tries to improve performance by doing shallow equality reference checks on incoming props in &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, and if all references are the same, returns &lt;code&gt;false&lt;/code&gt; to skip actually updating your original component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ededef69001678f2e3f055f1fda34f301acb3bdc" translate="yes" xml:space="preserve">
          <source>Accordingly, &lt;code&gt;combineReducers&lt;/code&gt; will not set its &lt;code&gt;hasChanged&lt;/code&gt; flag, even though the state has changed. If none of the other reducers return a new, updated state slice, the &lt;code&gt;hasChanged&lt;/code&gt; flag will remain set to false, causing &lt;code&gt;combineReducers&lt;/code&gt; to return the &lt;em&gt;existing&lt;/em&gt; root state object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9938fccff603464933303296454dffcb6d16f1" translate="yes" xml:space="preserve">
          <source>Accordingly, calling &lt;code&gt;toJS()&lt;/code&gt; twice, for example, and assigning the result to two different variables will cause an equality check on those two variables to fail, even though the object values themselves haven&amp;rsquo;t changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="240f485623391e5c1075e5725ad30c67ed287ffe" translate="yes" xml:space="preserve">
          <source>Action Creator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b6c7e08efa20fb3393d8ac535f3d3c740a070d" translate="yes" xml:space="preserve">
          <source>Action Creators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ec85940f13d4f2b78e391b686bbb091564ba03e" translate="yes" xml:space="preserve">
          <source>Action Creators and Constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a119c0a9e7c1a3dda7791541c11f9924b37c7992" translate="yes" xml:space="preserve">
          <source>Action creators can also be asynchronous and have side-effects. You can read about &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt; in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how to handle AJAX responses and compose action creators into async control flow. Don't skip ahead to async actions until you've completed the basics tutorial, as it covers other important concepts that are prerequisite for the advanced tutorial and async actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38b2a78d2a362985ab2383462db85f699d11a8bc" translate="yes" xml:space="preserve">
          <source>Action creators have often been criticized as boilerplate. Well, you don't have to write them! &lt;strong&gt;You can use object literals if you feel this better suits your project.&lt;/strong&gt; There are, however, some benefits for writing action creators you should know about.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="e8ae9384ae9248e5ddbc032e08b2557629723918" translate="yes" xml:space="preserve">
          <source>Actions are plain JavaScript objects. Actions must have a &lt;code&gt;type&lt;/code&gt; property that indicates the type of action being performed. Types should typically be defined as string constants. Once your app is large enough, you may want to move them into a separate module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c6835b1a6b3824f0c14c55211c697ec783ced1" translate="yes" xml:space="preserve">
          <source>Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It's important that &lt;strong&gt;actions being objects you have to dispatch is not boilerplate, but one of the &lt;a href=&quot;../introduction/threeprinciples&quot;&gt;fundamental design choices&lt;/a&gt; of Redux&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d61d75382f4f34d26d503abba6068279c8ea603" translate="yes" xml:space="preserve">
          <source>Actions look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ec7f0f4e16258c3a0d1d14cd731f00efda02b1" translate="yes" xml:space="preserve">
          <source>Actions must have a &lt;code&gt;type&lt;/code&gt; field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for &lt;code&gt;type&lt;/code&gt; than &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; because strings are serializable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88de3a2870fc9eb038ea75c3422acc4a151defa3" translate="yes" xml:space="preserve">
          <source>Adding the Buttons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c737672ab2cc3d4caaa793fa73dc88d6e8d45119" translate="yes" xml:space="preserve">
          <source>Additionally, as we are using ES6 and JSX syntax, we will need to compile with &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; (see &lt;a href=&quot;https://github.com/babel/example-node-server&quot;&gt;this example of a Node Server with Babel&lt;/a&gt;) and the &lt;a href=&quot;https://babeljs.io/docs/plugins/preset-react/&quot;&gt;React preset&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18596de4375fc946c5b097f81e74982a60e9c894" translate="yes" xml:space="preserve">
          <source>Adds a change listener. It will be called any time an action is dispatched, and some part of the state tree may potentially have changed. You may then call &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; to read the current state tree inside the callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d064726954a17487f94e931f5b157b733ec22ed" translate="yes" xml:space="preserve">
          <source>Advanced</source>
          <target state="translated">Advanced</target>
        </trans-unit>
        <trans-unit id="16857f7bab141f13aed36aec58498499bddb6833" translate="yes" xml:space="preserve">
          <source>Advanced: Async Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025dce227eca0ed35e21358aac9e6536fedf70ed" translate="yes" xml:space="preserve">
          <source>Advanced: Async Flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f20532e3af1b93336b6e71dbaacd3a2435abd0" translate="yes" xml:space="preserve">
          <source>Advanced: Middleware</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25069391f8b74b286f02804c1347be029afe7715" translate="yes" xml:space="preserve">
          <source>After passing it once to &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt;&lt;/a&gt;, you can write all your API-calling action creators the same way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53e43e635db37f09dab8f6423d79953c28e59e8e" translate="yes" xml:space="preserve">
          <source>After the iterations have completed, &lt;code&gt;combineReducers&lt;/code&gt; will check the state of the &lt;code&gt;hasChanged&lt;/code&gt; flag. If it&amp;rsquo;s true, the newly-constructed state object will be returned. If it&amp;rsquo;s false, the &lt;em&gt;current&lt;/em&gt; state object is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc595812793ab6bb9b28c25bb6e33f011754ef4a" translate="yes" xml:space="preserve">
          <source>Again, it's important to understand that Redux reducers are &lt;em&gt;just&lt;/em&gt; functions. While &lt;code&gt;combineReducers&lt;/code&gt; is useful, it's just one tool in the toolbox. Functions can contain conditional logic other than switch statements, functions can be composed to wrap each other, and functions can call other functions. Maybe you need one of your slice reducers to be able to reset its state, and to only respond to specific actions overall. You could do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b948d24fd1c5855cef6418255f90cedfe918ce37" translate="yes" xml:space="preserve">
          <source>Again, this is just a mock API, so we use &lt;code&gt;setTimeout&lt;/code&gt; to simulate a network request that takes 500 milliseconds to respond (this should be much faster with a real world API). We pass in a callback that returns a random number asynchronously. If you're using a Promise-based API client, then you would issue this callback in your &lt;code&gt;then&lt;/code&gt; handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79aa101c36a75c4f0aa52bd08ce3b2d8cdc7f9d8" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; does is generate a function that calls your reducers &lt;strong&gt;with the slices of state selected according to their keys&lt;/strong&gt;, and combining their results into a single object again. &lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;It's not magic.&lt;/a&gt; And like other reducers, &lt;code&gt;combineReducers()&lt;/code&gt; does not create a new object if all of the reducers provided to it do not change state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbeeac1b96757e9c7e7b9ce98e03b49b2143629c" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;compose&lt;/code&gt; does is let you write deeply nested function transformations without the rightward drift of the code. Don't give it too much credit!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9352846dec2290d9ee10aeb06144a932791349b8" translate="yes" xml:space="preserve">
          <source>All container components need access to the Redux store so they can subscribe to it. One option would be to pass it as a prop to every container component. However it gets tedious, as you have to wire &lt;code&gt;store&lt;/code&gt; even through presentational components just because they happen to render a container deep in the component tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff23711ae579d38170f51f062fe9549d4a371f8" translate="yes" xml:space="preserve">
          <source>Allows access to state via &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a12034e563003a9eca9331500b3b60b340ce34f" translate="yes" xml:space="preserve">
          <source>Allows state to be updated via &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc5484ef3a628ddd51e1319c03088024b0016ab" translate="yes" xml:space="preserve">
          <source>Almost all examples have a corresponding CodeSandbox sandbox. This is an interactive version of the code that you can play with online.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a555920679381ca5e42f41dbd1af93c1e69228" translate="yes" xml:space="preserve">
          <source>Along this chapter, we will be using the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; example. We recommend you to clone it while reading this chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9166c2a546b7eba6781eda1ddb48ac422e9c9900" translate="yes" xml:space="preserve">
          <source>Also keep an eye out for nested state objects that need to be deeply copied. Both &lt;code&gt;_.extend&lt;/code&gt; and &lt;code&gt;Object.assign&lt;/code&gt; make a shallow copy of the state. See &lt;a href=&quot;recipes/reducers/immutableupdatepatterns#updating-nested-objects&quot;&gt;Updating Nested Objects&lt;/a&gt; for suggestions on how to deal with nested state objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d280006e11c722e08ab0ef3901f105ba1f89c495" translate="yes" xml:space="preserve">
          <source>Also, the resulting names are a bit odd. It's generally not a good practice to actually include words like &quot;reducer&quot; in your state key names - the keys should simply reflect the domain or type of data they hold. This means we should either explicitly specify the names of the keys in the slice reducer object to define the keys in the output state object, or carefully rename the variables for the imported slice reducers to set up the keys when using the shorthand object literal syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92743996305e4fee546be1bf5a260da6bb485c9" translate="yes" xml:space="preserve">
          <source>Also, while &lt;code&gt;combineReducers&lt;/code&gt; is the one reducer utility function that's built into Redux, there's a wide variety of third-party reducer utilities that have published for reuse. The &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt; lists many of the third-party utilities that are available. Or, if none of the published utilities solve your use case, you can always write a function yourself that does just exactly what you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8b3627c269aa139cc46adb58b39f1f40a3959a" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a &lt;strong&gt;bound action creator&lt;/strong&gt; that automatically dispatches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d168d8850f955b7e9e3d0a064ebea1d8ecaae72" translate="yes" xml:space="preserve">
          <source>Although powerful, Immutable.JS needs to be used carefully, as it comes with issues of its own. Note, however, that all of these issues can be overcome quite easily with careful coding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d209720249965a438eaa6d74c36ac6d53a3230a" translate="yes" xml:space="preserve">
          <source>Although the final result in this example is noticeably longer than the original version, this is primarily due to the extraction of the utility functions, the addition of comments, and some deliberate verbosity for the sake of clarity, such as separate return statements. Looking at each function individually, the amount of responsibility is now smaller, and the intent is hopefully clearer. Also, in a real application, these functions would probably then be split into separate files such as &lt;code&gt;reducerUtilities.js&lt;/code&gt;, &lt;code&gt;visibilityReducer.js&lt;/code&gt;, &lt;code&gt;todosReducer.js&lt;/code&gt;, and &lt;code&gt;rootReducer.js&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11420cf980650fbffa2655206c7e7f0d6f693730" translate="yes" xml:space="preserve">
          <source>Always.</source>
          <target state="translated">Always.</target>
        </trans-unit>
        <trans-unit id="ae42e396c07650791a08d3bbeb56dcf9d4f16480" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;actions&quot;&gt;action&lt;/a&gt; is a plain object describing &lt;em&gt;what happened&lt;/em&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3348883e6b709273b1588a140f0ad640ffa7901" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action creator&lt;/em&gt; is, quite simply, a function that creates an action. Do not confuse the two terms&amp;mdash;again, an action is a payload of information, and an action creator is a factory that creates an action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dbd2dc1e57dbf1a690c626bcf14369d4d0f24ee" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action&lt;/em&gt; is a plain object that represents an intention to change the state. Actions are the only way to get data into the store. Any data, whether from UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5753c579ec0c6f7a4e01deb683ed860b056f3db7" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async action&lt;/em&gt; is a value that is sent to a dispatching function, but is not yet ready for consumption by the reducer. It will be transformed by &lt;a href=&quot;#middleware&quot;&gt;middleware&lt;/a&gt; into an action (or a series of actions) before being sent to the base &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; function. Async actions may have different types, depending on the middleware you use. They are often asynchronous primitives, like a Promise or a thunk, which are not passed to the reducer immediately, but trigger action dispatches once an operation has completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7059ea52b9fe7cd64e9c1eb12fbae0e27f1fbf10" translate="yes" xml:space="preserve">
          <source>An Introduction to Reasonably Pure Functional Programming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027aa8fd687cde00ad56b360989176d53d8f5088" translate="yes" xml:space="preserve">
          <source>An alternative approach is to use the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread syntax&lt;/a&gt; proposed for the next versions of JavaScript which lets you use the spread (&lt;code&gt;...&lt;/code&gt;) operator to copy enumerable properties from one object to another in a more succinct way. The object spread operator is conceptually similar to the ES6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;array spread operator&lt;/a&gt;. We can simplify the &lt;code&gt;todoApp&lt;/code&gt; example above by using the object spread syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9140efa7e4fd077860c74984e025f41073161a33" translate="yes" xml:space="preserve">
          <source>An example of a normalized state structure for the blog example above might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f5f4aca90e751fb4943bf0f75cdcb58b3045de7" translate="yes" xml:space="preserve">
          <source>And further yet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042ece2a59b966fa0a3746efb8c09215e767bd18" translate="yes" xml:space="preserve">
          <source>And if you need both:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9796d47a0c430111a17f97990051bc1f0bd25b7" translate="yes" xml:space="preserve">
          <source>And many, many more! The Redux Addons Catalog has &lt;strong&gt;&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/apps-and-examples.md&quot;&gt;a list of Redux-based applications and examples&lt;/a&gt;&lt;/strong&gt; that points to a variety of actual applications, large and small.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38147ba676724ae6f61a0d7f338d7350e8929314" translate="yes" xml:space="preserve">
          <source>And that's it! That is all we need to do to implement server side rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f36f5dbc061dc0b41ff32b3fcf5454dd4737242" translate="yes" xml:space="preserve">
          <source>And this is how you would use it in your Smart Component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7821f53eb6540ced1a441c7c8a5afc57915f7472" translate="yes" xml:space="preserve">
          <source>And we write another reducer that manages the complete state of our app by calling those two reducers for the corresponding state keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035d8336ff091d8317b65369c8f7a5fba5c1e1a6" translate="yes" xml:space="preserve">
          <source>Andr&amp;eacute; Staltz, creator of Cycle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87d12fc4df56487f9cea8c793885037c6bb50fc" translate="yes" xml:space="preserve">
          <source>Angular 2 &amp;mdash; Introduction to Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3e9743695c2147abea82ed6210c9b8769e1aff" translate="yes" xml:space="preserve">
          <source>Another alternative to the &quot;shared-slice updates&quot; issue would be to simply put more data into the action. This is easily accomplished using thunk functions or a similar approach, per this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54508f8783d239a03fbfc708d7eb0721cdb09e88" translate="yes" xml:space="preserve">
          <source>Another common version of this error looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7d294fca6f772f407a0c0a76df3b9678dec13a" translate="yes" xml:space="preserve">
          <source>Another important difference from Flux is that &lt;strong&gt;Redux assumes you never mutate your data&lt;/strong&gt;. You can use plain objects and arrays for your state just fine, but mutating them inside the reducers is strongly discouraged. You should always return a new object, which is easy with the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt;, or with a library like &lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327dd80631e264f16ad2cae2c1d1c364a6353cd0" translate="yes" xml:space="preserve">
          <source>Another variation on this is to use Redux-ORM as an abstraction layer within a single case reducer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dca810c72389e39d7ae3adc87f949b161cb67aa" translate="yes" xml:space="preserve">
          <source>Any meaningful web app needs to execute complex logic, usually including asynchronous work such as making AJAX requests. That code is no longer purely a function of its inputs, and the interactions with the outside world are known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;&amp;ldquo;side effects&amp;rdquo;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a95b9c7d131a13dd7681ee829c7309078b3577" translate="yes" xml:space="preserve">
          <source>Any reducer passed to &lt;code&gt;combineReducers&lt;/code&gt; must satisfy these rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fdbb15360b3088d82f5dfe1a14a15d468cb58cd" translate="yes" xml:space="preserve">
          <source>Any references to individual items should be done by storing the item's ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206a7715eef6f00c93aebc49d2e9182d87517249" translate="yes" xml:space="preserve">
          <source>Apollo Client: GraphQL with React and Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9005318bff4ea7c0d752cddae4ff458b6e1a0913" translate="yes" xml:space="preserve">
          <source>Are there any larger, &amp;ldquo;real&amp;rdquo; Redux projects?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc44e7f8ef0dbd0f0399aed6b078549d32a1bc08" translate="yes" xml:space="preserve">
          <source>Are written</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="49daae7bc3193b4ffbf057d1ce571f648d334335" translate="yes" xml:space="preserve">
          <source>Arrays of IDs should be used to indicate ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678560a52b48d8df9cc01483f2c09d287f1730ed" translate="yes" xml:space="preserve">
          <source>As an application grows, common patterns in reducer logic will start to emerge. You may find several parts of your reducer logic doing the same kinds of work for different types of data, and want to reduce duplication by reusing the same common logic for each data type. Or, you may want to have multiple &quot;instances&quot; of a certain type of data being handled in the store. However, the global structure of a Redux store comes with some trade-offs: it makes it easy to track the overall state of an application, but can also make it harder to &quot;target&quot; actions that need to update a specific piece of state, particularly if you are using &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8dfe1588c786f88cd39b5e2f752576b7bb0f10" translate="yes" xml:space="preserve">
          <source>As an example, let's say that we want to track multiple counters in our application, named A, B, and C. We define our initial &lt;code&gt;counter&lt;/code&gt; reducer, and we use &lt;code&gt;combineReducers&lt;/code&gt; to set up our state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709fd50216cd72e5e5a781b80b45c62c308c61de" translate="yes" xml:space="preserve">
          <source>As defined in &lt;a href=&quot;splittingreducerlogic&quot;&gt;Splitting Reducer Logic&lt;/a&gt;, a &lt;em&gt;higher-order reducer&lt;/em&gt; is a function that takes a reducer function as an argument, and/or returns a new reducer function as a result. It can also be viewed as a &quot;reducer factory&quot;. &lt;code&gt;combineReducers&lt;/code&gt; is one example of a higher-order reducer. We can use this pattern to create specialized versions of our own reducer functions, with each version only responding to specific actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef475fd072b3bead2a85a3d7e365ffb13bfaca5" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../../basics/reducers&quot;&gt;Reducers&lt;/a&gt;, a Redux reducer function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef35726a994739e304113b383deb26575f5ff1ba" translate="yes" xml:space="preserve">
          <source>As for architecture, anecdotal evidence is that Redux works well for varying project and team sizes. Redux is currently used by hundreds of companies and thousands of developers, with several hundred thousand monthly installations from NPM. One developer reported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e814716838438ec84d1615becea35368a2e66458" translate="yes" xml:space="preserve">
          <source>As if this wasn't bad enough, consider the &lt;strong&gt;new requirements becoming common in front-end product development&lt;/strong&gt;. As developers, we are expected to handle optimistic updates, server-side rendering, fetching data before performing route transitions, and so on. We find ourselves trying to manage a complexity that we have never had to deal with before, and we inevitably ask the question: &lt;a href=&quot;http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html&quot;&gt;is it time to give up?&lt;/a&gt; The answer is &lt;em&gt;no&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb977642e09fe68de908d000ae815bd23c6664f" translate="yes" xml:space="preserve">
          <source>As it continues through the iterations, &lt;code&gt;combineReducers&lt;/code&gt; will construct a new state object with the state slices returned from each reducer. This new state object may or may not be different from the current state object. It is here that &lt;code&gt;combineReducers&lt;/code&gt; uses shallow equality checking to determine whether the state has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c31c6475cbfd62456b208b3c6e1e67d8fcfdab31" translate="yes" xml:space="preserve">
          <source>As it turns out, there's a useful utility called &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; that can make that process easier. It simply takes multiple reducers and runs &lt;code&gt;reduce()&lt;/code&gt; on them, passing the intermediate state values to the next reducer in line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abf8ce0941afdd199232022cabbf076e6057848" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;normalizingstateshape&quot;&gt;Normalizing State Shape&lt;/a&gt;, the Normalizr library is frequently used to transform nested response data into a normalized shape suitable for integration into the store. However, that doesn't address the issue of executing further updates to that normalized data as it's being used elsewhere in the application. There are a variety of different approaches that you can use, based on your own preference. We'll use the example of adding a new Comment to a Post.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4b60f1e31e4c57161fb7758305113397c7a5c3a" translate="yes" xml:space="preserve">
          <source>As our last step, we can now use Redux's built-in &lt;code&gt;combineReducers&lt;/code&gt; utility to handle the &quot;slice-of-state&quot; logic for our top-level app reducer. Here's the final result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4496173ef998c4da8d0db366e9bb7a00db7fcd" translate="yes" xml:space="preserve">
          <source>As such, a shallow equality check of the props object returned from repeated calls to &lt;code&gt;mapStateToProps&lt;/code&gt; would always fail, as a new object would be returned each time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf23dc07f110dd0af0f0a020f2623e1f59b9566" translate="yes" xml:space="preserve">
          <source>As such, even though the values of that new object have not changed, the wrapped component will always be re-rendered,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a041a5b277767ea9c2a31b986eec75aca67d859c" translate="yes" xml:space="preserve">
          <source>As the requirements for JavaScript single-page applications have become increasingly complicated, &lt;strong&gt;our code must manage more state than ever before&lt;/strong&gt;. This state can include server responses and cached data, as well as locally created data that has not yet been persisted to the server. UI state is also increasing in complexity, as we need to manage active routes, selected tabs, spinners, pagination controls, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14d76fefd06040ae416dab582f026209ce57474" translate="yes" xml:space="preserve">
          <source>As we&amp;rsquo;ve seen, the values in the mutable object returned by the selector function may have changed, but the object itself has not, and shallow equality checking only compares the objects themselves, not their values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81dc352109a60e2a91dd724ab47b76ebe7decc71" translate="yes" xml:space="preserve">
          <source>As with several other questions, it is &lt;em&gt;possible&lt;/em&gt; to create multiple distinct Redux stores in a page, but the intended pattern is to have only a single store. Having a single store enables using the Redux DevTools, makes persisting and rehydrating data simpler, and simplifies the subscription logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02308c61548a99934707da188eb85ef748a5cb4" translate="yes" xml:space="preserve">
          <source>As with state, serializable actions enable several of Redux's defining features, such as time travel debugging, and recording and replaying actions. Using something like a &lt;code&gt;Symbol&lt;/code&gt; for the &lt;code&gt;type&lt;/code&gt; value or using &lt;code&gt;instanceof&lt;/code&gt; checks for actions themselves would break that. Strings are serializable and easily self-descriptive, and so are a better choice. Note that it &lt;em&gt;is&lt;/em&gt; okay to use Symbols, Promises, or other non-serializable values in an action if the action is intended for use by middleware. Actions only need to be serializable by the time they actually reach the store and are passed to the reducers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d90438423a5d564145ee745315cbd04ef8f5d9" translate="yes" xml:space="preserve">
          <source>As you rewrite your Stores, you will find that you need to avoid certain Flux anti-patterns such as fetching API inside the Store, or triggering actions inside the Stores. Your Flux code will be easier to follow once you port it to be based on reducers!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a2c484c73d6daa09647c6197ccf515d0e0786e" translate="yes" xml:space="preserve">
          <source>As your app grows more complex, you'll want to split your &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; into separate functions, each managing independent parts of the &lt;a href=&quot;../glossary#state&quot;&gt;state&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cff388be99f52b685be17cb7f6b80f2a1084bc0" translate="yes" xml:space="preserve">
          <source>Ask around on the &lt;strong&gt;#redux&lt;/strong&gt;&lt;a href=&quot;http://reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; Discord channel, or &lt;a href=&quot;https://github.com/reactjs/redux/issues&quot;&gt;create an issue&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd90ea9965306b973ad750889f0a4b9e3769518a" translate="yes" xml:space="preserve">
          <source>Associating items in relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f243e92a1117cab31114a44424d26658eeb2d079" translate="yes" xml:space="preserve">
          <source>Assuming actual changes need to occur, it needs to create new objects and arrays with the updated data and return those</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db37f55867798c63094a75db06886660e91436bf" translate="yes" xml:space="preserve">
          <source>Async</source>
          <target state="translated">Async</target>
        </trans-unit>
        <trans-unit id="90722b7f9d2e813acdd905ce6a728ce981a33ec4" translate="yes" xml:space="preserve">
          <source>Async Action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167b050aac66ff4723e2e1e409f28704074758c3" translate="yes" xml:space="preserve">
          <source>Async Action Creators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91eebc38df11fd82beeb837efd263578c88fd532" translate="yes" xml:space="preserve">
          <source>Async Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f1c859609130246bfcce156061b4ffce4ac287" translate="yes" xml:space="preserve">
          <source>Async Flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c040239385214a8e17389f47ba7d20d7ef489c" translate="yes" xml:space="preserve">
          <source>Async State Fetching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886ac17e24bc12f98154c913a55fad29ab13e686" translate="yes" xml:space="preserve">
          <source>Async action creators are especially convenient for server rendering. You can create a store, dispatch a single async action creator that dispatches other async action creators to fetch data for a whole section of your app, and only render after the Promise it returns, completes. Then your store will already be hydrated with the state you need before rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1b1c578f34b8d9eb909781b58a2f94d6f371c68" translate="yes" xml:space="preserve">
          <source>Asynchronous middleware like &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; or &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; wraps the store's &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method and allows you to dispatch something other than actions, for example, functions or Promises. Any middleware you use can then interpret anything you dispatch, and in turn, can pass actions to the next middleware in the chain. For example, a Promise middleware can intercept Promises and dispatch a pair of begin/end actions asynchronously in response to each Promise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb0dcef5fba599c316c78c309f567d83281170d" translate="yes" xml:space="preserve">
          <source>At its core, Redux is really a fairly simple design pattern: all your &quot;write&quot; logic goes into a single function, and the only way to run that logic is to give Redux a plain object that describes something that has happened. The Redux store calls that write logic function and passes in the current state tree and the descriptive object, the write logic function returns some new state tree, and the Redux store notifies any subscribers that the state tree has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c55c70af3e1a8f861110d1c7eecd86c69c1d55" translate="yes" xml:space="preserve">
          <source>Attempt #1: Logging Manually</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf041cf27718908810ead0d2f91d0171d49b9b85" translate="yes" xml:space="preserve">
          <source>Attempt #2: Wrapping Dispatch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77db9a04efffdb3012b23e3322da962156c4a860" translate="yes" xml:space="preserve">
          <source>Attempt #3: Monkeypatching Dispatch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f2148510a51d59cf3a8e564eed4a0c3c1d86f5f" translate="yes" xml:space="preserve">
          <source>Attempt #4: Hiding Monkeypatching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2cc7378629716a29578d9874dd2b25fc5a8c9d" translate="yes" xml:space="preserve">
          <source>Attempt #5: Removing Monkeypatching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73546da71df70edaa82a5330e2ce70fd8845ff54" translate="yes" xml:space="preserve">
          <source>Attempt #6: Na&amp;iuml;vely Applying the Middleware</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5678d8ff8964be781758624218ca67e6eccfdd1b" translate="yes" xml:space="preserve">
          <source>Authentication is essential to any real application. When going about authentication you must keep in mind that nothing changes with how you should organize your application and you should implement authentication in the same way you would any other feature. It is relatively straightforward:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9566fa2885d46ca757c9af88ac84f85bb1d56e51" translate="yes" xml:space="preserve">
          <source>Authentication with JWT by Auth0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122e59e628a93b853a47af4cfa8433a11386c564" translate="yes" xml:space="preserve">
          <source>Avoiding Accidental Complexity When Structuring Your App State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e81d3aaff1562199dada2cff7c06a38e4c2294f" translate="yes" xml:space="preserve">
          <source>Avoiding functions and statements that mutate state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aae17642d53cdbcf10d6748c5122f8d3443a256" translate="yes" xml:space="preserve">
          <source>Aware of Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9410a51d85ad489b23f91e3413ee16c00a3aada5" translate="yes" xml:space="preserve">
          <source>Backbone's model layer is quite different from Redux, so we don't suggest mixing them. If possible, it is best that you rewrite your app's model layer from scratch instead of connecting Backbone to Redux. However, if a rewrite is not feasible, you may use &lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;backbone-redux&lt;/a&gt; to migrate gradually, and keep the Redux store in sync with Backbone models and collections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed27f94322cfd2585f69fd4faaf883777c565fb1" translate="yes" xml:space="preserve">
          <source>Baobab</source>
          <target state="translated">Baobab</target>
        </trans-unit>
        <trans-unit id="22e42af3c93af18697862c91d897419ff315b287" translate="yes" xml:space="preserve">
          <source>Basic Reducer Structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6c9bee78e234130cb00e796115605ccb9c9356" translate="yes" xml:space="preserve">
          <source>Basic Reducer Structure and State Shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ecb36ff00519ea4d9111bf2ac2c38ce3e8ee19" translate="yes" xml:space="preserve">
          <source>Basic State Shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="67b560207b812ce235458b82ba3b3eea9cb85612" translate="yes" xml:space="preserve">
          <source>Basics: Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2961743fb82ac508ead6cd89af32cac336e899e" translate="yes" xml:space="preserve">
          <source>Basics: Store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6b5a053fcc90c8ddd2441e52e91ec4ca304fa6" translate="yes" xml:space="preserve">
          <source>Basics: Usage with React</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef57ae03011c7a88309c71ac3de4cd66803fca0f" translate="yes" xml:space="preserve">
          <source>Be aware that any &lt;code&gt;fetch&lt;/code&gt; polyfill assumes a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; polyfill is already present. The easiest way to ensure you have a Promise polyfill is to enable Babel's ES6 polyfill in your entry point before any other code runs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8836be1ed6d14271d3616086c1165b69f0c93f5a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;combineReducers&lt;/code&gt; expects an object, we can put all top-level reducers into a separate file, &lt;code&gt;export&lt;/code&gt; each reducer function, and use &lt;code&gt;import * as reducers&lt;/code&gt; to get them as an object with their names as the keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e147dcc69ce5b11254e20a3d4069c3882333d6b2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;import *&lt;/code&gt; is still new syntax, we don't use it anymore in the documentation to avoid &lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;confusion&lt;/a&gt;, but you may encounter it in some community examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaded217a4fa5a0be4aafbaa6515cc015511e79a" translate="yes" xml:space="preserve">
          <source>Because APIs frequently send back data in a nested form, that data needs to be transformed into a normalized shape before it can be included in the state tree. The &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;Normalizr&lt;/a&gt; library is usually used for this task. You can define schema types and relations, feed the schema and the response data to Normalizr, and it will output a normalized transformation of the response. That output can then be included in an action and used to update the store. See the Normalizr documentation for more details on its usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a6dc2449dbb96d53ee9fa9e5275f29a7f8733e" translate="yes" xml:space="preserve">
          <source>Because React-Redux performs a shallow check on the root state object to determine if its wrapped components need re-rendering or not, it will not be able to detect the state mutation, and so will not trigger a re-rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4a1ac2348c56cde050b358a3589a1c8f14e121" translate="yes" xml:space="preserve">
          <source>Because a store is not an instance, but rather a plain-object collection of functions, copies can be easily created and modified without mutating the original store. There is an example in &lt;a href=&quot;api/compose&quot;&gt;&lt;code&gt;compose&lt;/code&gt;&lt;/a&gt; documentation demonstrating that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efed700df65d7fe9ccdceab1e7043b1b623a8ecf" translate="yes" xml:space="preserve">
          <source>Because each item is only defined in one place, we don't have to try to make changes in multiple places if that item is updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b2b72f48655aebb62d18b4c1e639b210169092" translate="yes" xml:space="preserve">
          <source>Because it is cumbersome to apply functions to &lt;code&gt;createStore()&lt;/code&gt; before using it, &lt;code&gt;createStore()&lt;/code&gt; accepts an optional last argument to specify such functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7374d49a3a0384818d249cff5d9279f55237ab50" translate="yes" xml:space="preserve">
          <source>Because most of the Redux code you write are functions, and many of them are pure, they are easy to test without mocking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2db4769be19da76af1b03eaa76cbae8155e656b" translate="yes" xml:space="preserve">
          <source>Because of these rules, it's important that the following core concepts are fully understood before moving on to other specific techniques for organizing Redux reducers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a3e08abcf6f4447aa880f7591ce54acac1d67d8" translate="yes" xml:space="preserve">
          <source>Because of this, the recommended approach to managing relational or nested data in a Redux store is to treat a portion of your store as if it were a database, and keep that data in a &lt;em&gt;normalized&lt;/em&gt; form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6e614f93198c638fa57d23714abc7c8a4c5fe3" translate="yes" xml:space="preserve">
          <source>Because the client side executes ongoing code, it can start with an empty initial state and obtain any necessary state on demand and over time. On the server side, rendering is synchronous and we only get one shot to render our view. We need to be able to compile our initial state during the request, which will have to react to input and obtain external state (such as that from an API or database).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dad2f7397c12d16dc5080663b0fb4ff158a875b" translate="yes" xml:space="preserve">
          <source>Because the data from B's slice is already in the action, the parent reducer doesn't have to do anything special to make that data available to &lt;code&gt;sliceReducerA&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800eb8a2fa295362af6cbe9bc4b63ea94371aa6a" translate="yes" xml:space="preserve">
          <source>Because the store represents the core of your application, you should &lt;strong&gt;define your state shape in terms of your domain data and app state, not your UI component tree&lt;/strong&gt;. As an example, a shape of &lt;code&gt;state.leftPane.todoList.todos&lt;/code&gt; would be a bad idea, because the idea of &quot;todos&quot; is central to the whole application, not just a single part of the UI. The &lt;code&gt;todos&lt;/code&gt; slice should be at the top of the state tree instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67eccbeca2c6be1c80e66072cbdb7d5d3d171333" translate="yes" xml:space="preserve">
          <source>Because this pattern is so common, Redux provides the &lt;code&gt;combineReducers&lt;/code&gt; utility to implement that behavior. It is an example of a &lt;em&gt;higher-order reducer&lt;/em&gt;, which takes an object full of slice reducer functions, and returns a new reducer function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cc4aaf99d902742f5080c22e4e5772ca05908e" translate="yes" xml:space="preserve">
          <source>Because we call &lt;code&gt;res.send()&lt;/code&gt; inside of the callback, the server will hold open the connection and won't send any data until that callback executes. You'll notice a 500ms delay is now added to each server request as a result of our new API call. A more advanced usage would handle errors in the API gracefully, such as a bad response or timeout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa8ca1f396e8cbad0408af4d219889981520bc2" translate="yes" xml:space="preserve">
          <source>Because we have introduced more code that relies on user generated content (UGC) and input, we have increased our attack surface area for our application. It is important for any application that you ensure your input is properly sanitized to prevent things like cross-site scripting (XSS) attacks or code injections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b5658d0d258fae8a0f70dae9f8f133bd91b874" translate="yes" xml:space="preserve">
          <source>Because we want to update a specific item in the array without resorting to mutations, we have to create a new array with the same items except the item at the index. If you find yourself often writing such operations, it's a good idea to use a helper like &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;, &lt;a href=&quot;https://github.com/substantial/updeep&quot;&gt;updeep&lt;/a&gt;, or even a library like &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt; that has native support for deep updates. Just remember to never assign to anything inside the &lt;code&gt;state&lt;/code&gt; unless you clone it first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="455e818de94ba32708285358e0d09ee9d740229c" translate="yes" xml:space="preserve">
          <source>Because we're treating a portion of our Redux store as a &quot;database&quot;, many of the principles of database design also apply here as well. For example, if we have a many-to-many relationship, we can model that using an intermediate table that stores the IDs of the corresponding items (often known as a &quot;join table&quot; or an &quot;associative table&quot;). For consistency, we would probably also want to use the same &lt;code&gt;byId&lt;/code&gt; and &lt;code&gt;allIds&lt;/code&gt; approach that we used for the actual item tables, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1304b4245c2ff85f0675fea297cb7677812a916" translate="yes" xml:space="preserve">
          <source>Because writing immutable update code can become tedious, there are a number of utility libraries that try to abstract out the process. These libraries vary in APIs and usage, but all try to provide a shorter and more succinct way of writing these updates. Some, like &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt;, take string paths for commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3e7f54e625439ca3447fdc7a9117ae5fab1524" translate="yes" xml:space="preserve">
          <source>Because you must access your data via Immutable.JS&amp;rsquo;s own &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;getIn()&lt;/code&gt; methods, you can no longer use JavaScript&amp;rsquo;s destructuring operator (or the proposed Object spread operator), making your code more verbose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1437822723995215deb0d2e2fac29d0d0f12fcf2" translate="yes" xml:space="preserve">
          <source>Before Proceeding Further</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6d48764a855d1815031363486f3cea75e828c9" translate="yes" xml:space="preserve">
          <source>Before creating a UI for our todo app, we will take a detour to see &lt;a href=&quot;dataflow&quot;&gt;how the data flows in a Redux application&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e97a45859979361b3d87b280bcc08eee9084a8f" translate="yes" xml:space="preserve">
          <source>Before going into the details of dispatching actions together with network requests, we will write the reducers for the actions we defined above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89cb49f87c14fc3ef664ffd5fd8fb507d546a513" translate="yes" xml:space="preserve">
          <source>Before integrating React Router, we need to configure our development server. Indeed, our development server may be unaware of the declared routes in React Router configuration. For example, if you access &lt;code&gt;/todos&lt;/code&gt; and refresh, your development server needs to be instructed to serve &lt;code&gt;index.html&lt;/code&gt; because it is a single-page app. Here's how to enable this with popular development servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f29fca44a9a66689242d9b6ac45e9273f69c5781" translate="yes" xml:space="preserve">
          <source>Before proceeding, make sure you have worked through the &lt;a href=&quot;../basics/index&quot;&gt;basics tutorial&lt;/a&gt; and understand &lt;a href=&quot;../basics/reducers&quot;&gt;reducer composition&lt;/a&gt; well. This recipe will build on top of the example described in the &lt;a href=&quot;../basics/index&quot;&gt;basics tutorial&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d28bda5a65bfffaaaaaeb2efbace54d5ae5ed7" translate="yes" xml:space="preserve">
          <source>Below is a sub-app's root connected component. As usual, it can render more components, connected or not, as children. Usually we'd render it in &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; and be done with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e9f60bf8e76871398ccbe5dae2fb65d17f44468" translate="yes" xml:space="preserve">
          <source>Below our imports, let's use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 Object Destructuring&lt;/a&gt; to declare &lt;code&gt;SHOW_ALL&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1091ed2655d47790d04e490d5a912d61726fb58" translate="yes" xml:space="preserve">
          <source>Beyond &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9a230925015b13c4b708f594107fd333941631" translate="yes" xml:space="preserve">
          <source>Beyond combineReducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edb5455f2581d21229bb831350698f3307569b49" translate="yes" xml:space="preserve">
          <source>Beyond that, Redux does not really care how you actually structure your logic inside that reducer function, as long as it obeys those basic rules. This is both a source of freedom and a source of confusion. However, there are a number of common patterns that are widely used when writing reducers, as well as a number of related topics and concepts to be aware of. As an application grows, these patterns play a crucial role in managing reducer code complexity, handling real-world data, and optimizing UI performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ce0037a118cd7c3ccf4f303af279bf29aedd37" translate="yes" xml:space="preserve">
          <source>Bill Fisher, author of Flux documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="5d13d6793ab60c41828ba3fe82788c57381b56b3" translate="yes" xml:space="preserve">
          <source>Both Redux and React-Redux employ &lt;a href=&quot;#shallow-and-deep-equality-checking&quot;&gt;shallow equality checking&lt;/a&gt;. In particular:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fcb9748d292f2d6edabc1dd2871e078a69f72c" translate="yes" xml:space="preserve">
          <source>Breaking down a complex process into smaller, more understandable parts is usually described with the term &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://stackoverflow.com/questions/947874/what-is-functional-decomposition&quot;&gt;functional decomposition&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;. This term and concept can be applied generically to any code. However, in Redux it is &lt;em&gt;very&lt;/em&gt; common to structure reducer logic using approach #3, where update logic is delegated to other functions based on slice of state. Redux refers to this concept as &lt;strong&gt;&lt;em&gt;reducer composition&lt;/em&gt;&lt;/strong&gt;, and it is by far the most widely-used approach to structuring reducer logic. In fact, it's so common that Redux includes a utility function called &lt;a href=&quot;../../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt;, which specifically abstracts the process of delegating work to other reducer functions based on slices of state. However, it's important to note that it is not the &lt;em&gt;only&lt;/em&gt; pattern that can be used. In fact, it's entirely possible to use all three approaches for splitting up logic into functions, and usually a good idea as well. The &lt;a href=&quot;refactoringreducersexample&quot;&gt;Refactoring Reducers&lt;/a&gt; section shows some examples of this in action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a2bc21cb4d822c367054d8beedc9e473cb922f" translate="yes" xml:space="preserve">
          <source>Breaks object references, causing poor performance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef955a1c06a7555c0b9124c858d0b7015c595f2" translate="yes" xml:space="preserve">
          <source>Build an Image Gallery Using Redux Saga</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044820df0cc9603893652b00eab09f2633843854" translate="yes" xml:space="preserve">
          <source>Building Efficient UI with React and Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52676a6b3cadf32f94e36a184ab697e39fb7e4cf" translate="yes" xml:space="preserve">
          <source>Building an Undo and Redo functionality into an app has traditionally required conscious effort from the developer. It is not an easy problem with classical MVC frameworks because you need to keep track of every past state by cloning all relevant models. In addition, you need to be mindful of the undo stack because the user-initiated changes should be undoable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5216ed259778329413571d3d5d7a100b3609532a" translate="yes" xml:space="preserve">
          <source>But the result is pretty vanilla. It essentially renders a static view from dynamic code. What we need to do next is build an initial state dynamically to allow that rendered view to be dynamic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6630c4ba113b66e638acb13afa2a0da5838bc4c" translate="yes" xml:space="preserve">
          <source>But there's also a different way to enable chaining. The middleware could accept the &lt;code&gt;next()&lt;/code&gt; dispatch function as a parameter instead of reading it from the &lt;code&gt;store&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dee896ae234e12cac8b3cbc6f4a57f568f7c5f7" translate="yes" xml:space="preserve">
          <source>By assuming the wrapped component is pure, it need only check whether the root state object or the values returned from &lt;code&gt;mapStateToProps&lt;/code&gt; have changed. If they haven&amp;rsquo;t, the wrapped component does not need re-rendering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04d1941187625b0fce5ba887317fb2d3821a0a2" translate="yes" xml:space="preserve">
          <source>By convention, the top-level state is an object or some other key-value collection like a Map, but technically it can be any type. Still, you should do your best to keep the state serializable. Don't put anything inside it that you can't easily turn into JSON.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee52434982b2c6a75c2a9dc316e303887dd2c213" translate="yes" xml:space="preserve">
          <source>By converting Immutable.JS objects to plain JavaScript values within a HOC, we achieve Dumb Component portability, but without the performance hits of using &lt;code&gt;toJS()&lt;/code&gt; in the Smart Component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c208d300198acc2bee9f79ece564c973b4032d" translate="yes" xml:space="preserve">
          <source>By hand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="678ffdd0e7329a441eacb0cada63caaeb00de544" translate="yes" xml:space="preserve">
          <source>Call non-pure functions, e.g. &lt;code&gt;Date.now()&lt;/code&gt; or &lt;code&gt;Math.random()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514ecbbb081ae5bb804b5d148470b70893486e4e" translate="yes" xml:space="preserve">
          <source>Calling an action creator only produces an action, but does not dispatch it. You need to call the store's &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function to actually cause the mutation. Sometimes we say &lt;em&gt;bound action creators&lt;/em&gt; to mean functions that call an action creator and immediately dispatch its result to a specific store instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc88550e4ec686048f4441cff525112f12fef17b" translate="yes" xml:space="preserve">
          <source>Can I put functions, promises, or other non-serializable items in my store state?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9efb799599b448719604b39fc5d1dd267fac1f" translate="yes" xml:space="preserve">
          <source>Can Redux be considered a &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; implementation?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8f18450288bb51e46e5292d22da2305a2ead78" translate="yes" xml:space="preserve">
          <source>Can Redux only be used with React?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac9b06faebbc4bb435ce5bb7eca38ff4df6ae262" translate="yes" xml:space="preserve">
          <source>Can or should I create multiple stores? Can I import my store directly, and use it in components myself?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc46e42066f8c38a155fdc1d793218fd0742077" translate="yes" xml:space="preserve">
          <source>Certain immutable operations, such as an Array filter, will always return a new object, even if the values themselves have not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c74fb571984d7f3e781ea8b013e5f74bcd16389" translate="yes" xml:space="preserve">
          <source>Change Log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d62200bb4808e2c757f43ffc9e34e38db2f83c" translate="yes" xml:space="preserve">
          <source>Changes are made with pure functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e5e5888a0251d8e42a2303b77a969291cfff57" translate="yes" xml:space="preserve">
          <source>Chat log: React/Redux perf - single connection vs many connections</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02882aae8c97d845e545938dbe2741732079d319" translate="yes" xml:space="preserve">
          <source>Chat log: React/Redux perf - updating a 10K-item Todo list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590f1d62228e7b6962e715956c59522b152fc9a5" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;exampleredditapi&quot;&gt;the full source code for the async example&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca51c480d481c131ddccd6e3c2ee749821089b7" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;official documentation&lt;/a&gt; of Reselect as well as its &lt;a href=&quot;https://github.com/reactjs/reselect#faq&quot;&gt;FAQ&lt;/a&gt;. Most Redux projects start using Reselect when they have performance problems because of too many derived computations and wasted re-renders, so make sure you are familiar with it before you build something big. It can also be useful to study &lt;a href=&quot;https://github.com/reactjs/reselect/blob/master/src/index.js&quot;&gt;its source code&lt;/a&gt; so you don't think it's magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7064940db7a1d0a8ad078f4933ca03bdf4384538" translate="yes" xml:space="preserve">
          <source>Choosing whether to use a single action type with flags, or multiple action types, is up to you. It's a convention you need to decide with your team. Multiple types leave less room for a mistake, but this is not an issue if you generate action creators and reducers with a helper library like &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35b138959cf52724c7ecc764f2581e2505e1033" translate="yes" xml:space="preserve">
          <source>Chris Dhanaraj</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da30b8b6589341c1c5097e2b6d732339256659a" translate="yes" xml:space="preserve">
          <source>Clear the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794ceaaa1771a4243afa4d673ab5434968292b2a" translate="yes" xml:space="preserve">
          <source>Cloning Objects in JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6b5f970ace9ba53ad9e45c0384561f1183fe5b" translate="yes" xml:space="preserve">
          <source>Code Structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a44af612fdee0de4619ce06d349d983c763c717" translate="yes" xml:space="preserve">
          <source>Combined Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138eb4fb8cbab09f3102a4bdc497d150d119b26b" translate="yes" xml:space="preserve">
          <source>Combining Reducers by Slice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fca950b17f3d83e4dea581789d811359b5f26a" translate="yes" xml:space="preserve">
          <source>Common Mistake #1: New variables that point to the same objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bac9c6f37df3c3c4497667d13578b5087f6d70e" translate="yes" xml:space="preserve">
          <source>Common Mistake #2: Only making a shallow copy of one level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3d6c44bf5df710ea25006914bb1e40d2ecbb97" translate="yes" xml:space="preserve">
          <source>Common Redux misconception: you need to deeply clone the state. Reality: if something inside doesn't change, keep its reference the same!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b43008657b57fe78508382a4b9fb02fb7841e4e" translate="yes" xml:space="preserve">
          <source>Community Conventions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba5570bcfc57cb0bf4fe0a9702c06fc5228b4ab" translate="yes" xml:space="preserve">
          <source>Complementary Packages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="32506a4d4827f751f805be2f6a54fe8754849b64" translate="yes" xml:space="preserve">
          <source>Components will both re-render when they shouldn&amp;rsquo;t, and refuse to render when they should, and tracking down the bug causing the rendering issue is hard, as the component rendering incorrectly is not necessarily the one whose properties are being accidentally mutated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837b57a8ec5e9af95ffd6545daebb1d24962188f" translate="yes" xml:space="preserve">
          <source>Composes functions from right to left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0c107b8e98df1c854ed1c7dcb3a98dc7c2ca76" translate="yes" xml:space="preserve">
          <source>Composing Selectors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d42401ef57fab1331c6965711b20a87c5ddbf4" translate="yes" xml:space="preserve">
          <source>Computing Derived Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7daf13b1f60fb4af3d6921cd3bc4aced67ab5a7a" translate="yes" xml:space="preserve">
          <source>Configuring Express</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a9e1acb14192d9b8d0b21f21976859dd578df3" translate="yes" xml:space="preserve">
          <source>Configuring WebpackDevServer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde5035ac1fcc8de232b7bed3503337cd6eb9f66" translate="yes" xml:space="preserve">
          <source>Configuring the Fallback URL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a9853dc1b73b96e2f86ff4c803e9204d6d4b12" translate="yes" xml:space="preserve">
          <source>Connected Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e80b5ae124a108d4cae25b4b8f529572912388e" translate="yes" xml:space="preserve">
          <source>Connecting React Router with Redux App</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a0e3b241efd3e93742236b45d8493d0e6fee30" translate="yes" xml:space="preserve">
          <source>Connecting a Selector to the Redux Store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87209e0d1e9b53b5fe4772baab86c7a792f26231" translate="yes" xml:space="preserve">
          <source>Connecting to UI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a52a37a64378cb1a98da0406ef6404fd0218774" translate="yes" xml:space="preserve">
          <source>Consequently, the state object will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b825bc561f6b5b1f75c29d0f875286a593d7b365" translate="yes" xml:space="preserve">
          <source>Consider the case of a &amp;ldquo;big&amp;rdquo; app (contained in a &lt;code&gt;&amp;lt;BigApp&amp;gt;&lt;/code&gt; component) that embeds smaller &amp;ldquo;sub-apps&amp;rdquo; (contained in &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; components):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b9b7c93fb54ebed199da9fee98590876d2817b" translate="yes" xml:space="preserve">
          <source>Consider the code above rewritten with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca273c094d939aa568e917155d75b414ea13292" translate="yes" xml:space="preserve">
          <source>Consider the following &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e99e62d50531f0a2f738cbf8aa0173b646e44a" translate="yes" xml:space="preserve">
          <source>Consider this Flux store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9f7bad9d1734680439f0676a170b5a673dfd79" translate="yes" xml:space="preserve">
          <source>Container Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dfb089b89fb29b825328110a2e11b4f94fb034" translate="yes" xml:space="preserve">
          <source>Conversely, in this next example (below), the component will &lt;em&gt;always&lt;/em&gt; re-render, as the value of &lt;code&gt;todos&lt;/code&gt; is always a new object, regardless of whether or not its values change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29636c1eb55c51788d0bfe80405463c52281956d" translate="yes" xml:space="preserve">
          <source>Converting an Immutable.JS object to a JavaScript object using &lt;code&gt;toJS()&lt;/code&gt; will return a new object every time. If you do this in &lt;code&gt;mapStateToProps&lt;/code&gt;, you will cause the component to believe that the object has changed every time the state tree changes, and so trigger an unnecessary re-render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93a1d53292581775a7aefd7eb2070e8afcd74765" translate="yes" xml:space="preserve">
          <source>Copying objects using functions like &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;, and array functions such as &lt;code&gt;slice()&lt;/code&gt; and &lt;code&gt;concat()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c872753511d558c4ce512746cf585786dd025a3c" translate="yes" xml:space="preserve">
          <source>Core Concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8e6e4e0586b33e3404668e2c83565be91e5463" translate="yes" xml:space="preserve">
          <source>Correct Approach: Copying All Levels of Nested Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4018045cfb458b2734d2b09cf762c2567878c41" translate="yes" xml:space="preserve">
          <source>Counter</source>
          <target state="translated">Counter</target>
        </trans-unit>
        <trans-unit id="ee249667a9d59781bd41e030d27e2c1188c37ed0" translate="yes" xml:space="preserve">
          <source>Counter Vanilla</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626a2643ba405040e97390410d4230e265e4259f" translate="yes" xml:space="preserve">
          <source>Create a function called &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; that creates a Flux store compatible with your existing app from a reducer function. Internally it might look similar to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/blob/master/src/createStore.js&quot;&gt;source&lt;/a&gt;) implementation from Redux. Its dispatch handler should just call the &lt;code&gt;reducer&lt;/code&gt; for any action, store the next state, and emit change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00d5c6bc58d02ae5cd2c0877a6310c7f5c5ba39" translate="yes" xml:space="preserve">
          <source>Create a reducer that returns the next state for each possible authentication case (&lt;code&gt;LOGIN_SUCCESS&lt;/code&gt;, &lt;code&gt;LOGIN_FAILURE&lt;/code&gt;, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eda9a696d062cf8392d53f7f2f71e67915d36d6" translate="yes" xml:space="preserve">
          <source>Create action constants for &lt;code&gt;LOGIN_SUCCESS&lt;/code&gt;, &lt;code&gt;LOGIN_FAILURE&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="324a3f11e3a6b0488c13a615c4cc2fb9250a827e" translate="yes" xml:space="preserve">
          <source>Create action creators that take in credentials, a flag that signifies whether authentication succeeded, a token, or an error message as the payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4da47671463db87fe5e42276d8cdd320a2a393a" translate="yes" xml:space="preserve">
          <source>Create an async action creator with Redux Thunk middleware or any middleware you see fit to fire a network request to an API that returns a token if the credentials are valid. Then save the token in the local storage or show a response to the user if it failed. You can perform these side effects from the action creators you wrote in the previous step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e918651270b4a8e2572409f93c5b24f05fb8646" translate="yes" xml:space="preserve">
          <source>Create the tree using Immutable.JS&amp;rsquo;s &lt;code&gt;fromJS()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f8eb3701e2ecf3db6a0a48de0c67b288bcb04f" translate="yes" xml:space="preserve">
          <source>Creates a Redux &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; that holds the complete state tree of your app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d02ebd7a04879d6977b29605f7193c5cf5707d" translate="yes" xml:space="preserve">
          <source>Creating a Memoized Selector</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bc225ae0a45426787680231ada8a6f564133c3" translate="yes" xml:space="preserve">
          <source>Currently, the todo list is not filtered even after the URL changed. This is because we are filtering from &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;'s &lt;code&gt;mapStateToProps()&lt;/code&gt; is still bound to the &lt;code&gt;state&lt;/code&gt; and not to the URL. &lt;code&gt;mapStateToProps&lt;/code&gt; has an optional second argument &lt;code&gt;ownProps&lt;/code&gt; that is an object with every props passed to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c61307a6709c8c66ca641e98184dcc9259bd594" translate="yes" xml:space="preserve">
          <source>Customizing Behavior with Higher-Order Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b543bfaaf4e1677077510d003f94bafdf0c999" translate="yes" xml:space="preserve">
          <source>Dan</source>
          <target state="translated">Dan</target>
        </trans-unit>
        <trans-unit id="d3ef9a304a148420eba3a55c129f2235b1f9e1ec" translate="yes" xml:space="preserve">
          <source>Data Flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb55896eb93bcb68cbc23ed6fae3b63100404b9f" translate="yes" xml:space="preserve">
          <source>Data encapsulated in an Immutable.JS object is never mutated. A new copy is always returned. This contrasts with JavaScript, in which some operations do not mutate your data (e.g. some Array methods, including map, filter, concat, forEach, etc.), but some do (Array&amp;rsquo;s pop, push, splice, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7593569c991b58f5d6a41f860519f79c89ac7d64" translate="yes" xml:space="preserve">
          <source>Data with IDs, nesting, or relationships should generally be stored in a &amp;ldquo;normalized&amp;rdquo; fashion: each object should be stored once, keyed by ID, and other objects that reference it should only store the ID rather than a copy of the entire object. It may help to think of parts of your store as a database, with individual &amp;ldquo;tables&amp;rdquo; per item type. Libraries such as &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; and &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;redux-orm&lt;/a&gt; can provide help and abstractions in managing normalized data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65fce8bd8c421447a1dd474490698e1a12d0c27c" translate="yes" xml:space="preserve">
          <source>Database Design: Many-to-Many</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa63f66a3e39dbf462410620328fa6a5c9da175" translate="yes" xml:space="preserve">
          <source>Database Normalization in Simple English</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32877593ffc83fe4317187fc6ecc5223533036b1" translate="yes" xml:space="preserve">
          <source>Database structure and organization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6caf1f8d03433b6b3dbc198392d72cd0763d04" translate="yes" xml:space="preserve">
          <source>Defining State Shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49314fcc5d1e120d1d0902f4474a5db8b799f9b6" translate="yes" xml:space="preserve">
          <source>Defining a new variable does &lt;em&gt;not&lt;/em&gt; create a new actual object - it only creates another reference to the same object. An example of this error would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4da65ee5f20805d0bb44ddd368a4514e6d0453" translate="yes" xml:space="preserve">
          <source>Defining reducer initial state</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f78359ef1da5a7d707b4be19086cd7ea706ec2f" translate="yes" xml:space="preserve">
          <source>Delegating update responsibility by slice of state (&lt;em&gt;reducer composition&lt;/em&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1296d584b1abd6003d9e6416a0989753f553b128" translate="yes" xml:space="preserve">
          <source>Designing Component Hierarchy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f93012b13a7122f93f6b433f36e83f1b2dfb67" translate="yes" xml:space="preserve">
          <source>Designing Container Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7810471483b121e68f2ab23125107a8e8d67064c" translate="yes" xml:space="preserve">
          <source>Designing Other Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095ba0b64724cee5424170abe9d2369a1356993a" translate="yes" xml:space="preserve">
          <source>Designing Presentational Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f307d5da7a84124c96764da2d65924d5f68585cd" translate="yes" xml:space="preserve">
          <source>Designing a Normalized State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b64b8cd5e20eb2ba80ed64b203752e415148ae" translate="yes" xml:space="preserve">
          <source>Designing the Algorithm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35f6f1ba63bafce6306862fed8e4ab702901f90" translate="yes" xml:space="preserve">
          <source>Designing the State Shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c55bbe367ca8fb0838485f031ff1f37f152f0b" translate="yes" xml:space="preserve">
          <source>DevTools</source>
          <target state="translated">DevTools</target>
        </trans-unit>
        <trans-unit id="f2384c55c1021ace4ef6037926b470b0095b309e" translate="yes" xml:space="preserve">
          <source>DevTools Monitors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed5637154269fe9a6be1732f927c29a0887441d" translate="yes" xml:space="preserve">
          <source>Developer Experience</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1972dacb696b8fcf81bb0f74e9d8f176d7b71600" translate="yes" xml:space="preserve">
          <source>Difficult to Debug</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5353aaf7c5188baebbcacaf0df24469e5eb208" translate="yes" xml:space="preserve">
          <source>Difficult to interoperate with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="ba63f5884c366cac612c111e65bfbc1bb0d9c688" translate="yes" xml:space="preserve">
          <source>Dispatch Redux actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a79a9e77ebead14cffe5188d0410f1e586d1501" translate="yes" xml:space="preserve">
          <source>Dispatches an action. This is the only way to trigger a state change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5de1b3bf84cda5dd071c256e4397b905445d1ed" translate="yes" xml:space="preserve">
          <source>Dispatching Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee258d3de8054840d9dbb2c1e3c54e55b09089fd" translate="yes" xml:space="preserve">
          <source>Dispatching Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2940c23366cfc9866cf0dedabc5e7de427363110" translate="yes" xml:space="preserve">
          <source>Dispatching async actions is no different from dispatching synchronous actions, so we won't discuss this in detail. See &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt; for an introduction into using Redux from React components. See &lt;a href=&quot;exampleredditapi&quot;&gt;Example: Reddit API&lt;/a&gt; for the complete source code discussed in this example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d068c8a57b05988a99ec9db89530ed96daebd1f4" translate="yes" xml:space="preserve">
          <source>Do I have to deep-clone my state in a reducer? Isn't copying my state going to be slow?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa79d0829b0d4f0c975b203f736245e67eda1ac" translate="yes" xml:space="preserve">
          <source>Do I have to put all my state into Redux? Should I ever use React's &lt;code&gt;setState()&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3636bc59ec04bd17d42ee7274e5e3eb724ddb4f2" translate="yes" xml:space="preserve">
          <source>Do I have to put all my state into Redux? Should I ever use React's setState()?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7486a68c2117f403c3ca95e7a147f4be8fdc9437" translate="yes" xml:space="preserve">
          <source>Do I have to use Immutable.JS?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e019a0f0b682311d1ef5e7b44aa30ef9a7eb403" translate="yes" xml:space="preserve">
          <source>Do I have to use the &lt;code&gt;switch&lt;/code&gt; statement to handle actions?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b739025b617dfa813fa405e23c0277f969c273f" translate="yes" xml:space="preserve">
          <source>Do I have to use the switch statement to handle actions?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04dfaeca86278099773342d666073f6978321758" translate="yes" xml:space="preserve">
          <source>Do I need to have a particular build tool to use Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b60ee4844578949ccecf13536855592c60fe12e" translate="yes" xml:space="preserve">
          <source>Do not, however, use Immutable.JS in your dumb components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8b5e6217f9ee788c8250a9d130537eb4c43e5f" translate="yes" xml:space="preserve">
          <source>Do other parts of the application care about this data?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c60268b9a702d1f66d359ec783eeff4c903f73" translate="yes" xml:space="preserve">
          <source>Do you need to be able to create further derived data based on this original data?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7b10f54d6c1236b3c9f64a98cb069e05bfcec5" translate="yes" xml:space="preserve">
          <source>Do you want to cache the data (ie, use what's in state if it's already there instead of re-requesting it)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cfcf7555c4a87f604bf343228e431e941928a19" translate="yes" xml:space="preserve">
          <source>Docs: Async Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="8181fac4ec0bea3cecb41f787698bf543db5208d" translate="yes" xml:space="preserve">
          <source>Does it make sense to use Redux together with RxJS? Sure! They work great together. For example, it is easy to expose a Redux store as an observable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1305d9a919be6e6f9ecdeed5c7f2f2e478ed670" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;call non-pure functions&lt;/em&gt; (like &lt;code&gt;Date.now&lt;/code&gt; or &lt;code&gt;Math.random&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308816fda77ecb92fa0de1e1d751c4e3693e8be6" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;mutate&lt;/em&gt; its arguments. If the reducer updates state, it should not &lt;em&gt;modify&lt;/em&gt; the &lt;strong&gt;existing&lt;/strong&gt; state object in-place. Instead, it should generate a &lt;strong&gt;new&lt;/strong&gt; object containing the necessary changes. The same approach should be used for any sub-objects within state that the reducer updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22b1d9946b43200b9db286efe37087e730da043" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;perform side effects&lt;/em&gt; (such as calling API's or modifying non-local objects or variables).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901adbd801774ee77110f7fe930f88786af2ec3e" translate="yes" xml:space="preserve">
          <source>Does shallow equality checking with a mutable object cause problems with Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbce74552f0dc7776acd620559f6ae39660da73" translate="yes" xml:space="preserve">
          <source>Doing a shallow copy of the top level is &lt;em&gt;not&lt;/em&gt; sufficient - the &lt;code&gt;nestedState&lt;/code&gt; object should be copied as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd72a551e03c242c187b72b86ec827595d6e90b6" translate="yes" xml:space="preserve">
          <source>Domain-style: separate folders per feature or domain, possibly with sub-folders per file type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b32a297d0fa3a03eb8b498f0629572a9c1acda3" translate="yes" xml:space="preserve">
          <source>Don't be fooled by all the fancy talk about reducers, middleware, store enhancers&amp;mdash;Redux is incredibly simple. If you've ever built a Flux application, you will feel right at home. If you're new to Flux, it's easy too!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60dca1e1c4e8a1060f3f909eb0e179e31b4080d" translate="yes" xml:space="preserve">
          <source>Don't create more than one store in an application! Instead, use &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; to create a single root reducer out of many.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dffae83d98e05f1f4c0b98f460a952b65b10e233" translate="yes" xml:space="preserve">
          <source>Don't forget to call &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495284d10f80785f137d2b0ebaf638b1a961c65d" translate="yes" xml:space="preserve">
          <source>ES5 (CommonJS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="745ddb845c45ed0aef6da5a7c40b9250b9a325e0" translate="yes" xml:space="preserve">
          <source>ES5 (UMD build)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f340712260381d35a53813a65d261137ac25e7e6" translate="yes" xml:space="preserve">
          <source>ES6</source>
          <target state="translated">ES6</target>
        </trans-unit>
        <trans-unit id="ce35c00a38ecfe2f4b7ca71185bfb3dae5d5f370" translate="yes" xml:space="preserve">
          <source>Each &quot;data table&quot; should store the individual items in an object, with the IDs of the items as keys and the items themselves as the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789740bc75be7ca6e2b1e0c1d3adb891edb730c5" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;VisibleTodoList&lt;/code&gt; container should select a different slice of the state depending on the value of the &lt;code&gt;listId&lt;/code&gt; prop, so let's modify &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; to accept a props argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9118903269eef24fd5dbfa80396b4917cc79e2" translate="yes" xml:space="preserve">
          <source>Each function below is a valid Redux middleware. They are not equally useful, but at least they are equally fun.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aef125e7da3027756ffee796bf82b1ad655ceee" translate="yes" xml:space="preserve">
          <source>Each of these two moments usually require a change in the application state; to do that, you need to dispatch normal actions that will be processed by reducers synchronously. Usually, for any API request you'll want to dispatch at least three different kinds of actions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94061bea8551ce9cef03e7d29d9b7bc74bb6280" translate="yes" xml:space="preserve">
          <source>Each time React-Redux&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function is called, it will perform a shallow equality check on its stored reference to the root state object, and the current root state object passed to it from the store. If the check passes, the root state object has not been updated, and so there is no need to re-render the component, or even call &lt;code&gt;mapStateToProps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac62ddd16da80245d0cc537482a69476b215083" translate="yes" xml:space="preserve">
          <source>Each type of data gets its own &quot;table&quot; in the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f0d5e4c1ae9f4f2cda609ae918e95f2ac644be" translate="yes" xml:space="preserve">
          <source>Earlier documentation suggested the use of the ES6 &lt;code&gt;import * as reducers&lt;/code&gt; syntax to obtain the reducers object. This was the source of a lot of confusion, which is why we now recommend exporting a single reducer obtained using &lt;code&gt;combineReducers()&lt;/code&gt; from &lt;code&gt;reducers/index.js&lt;/code&gt; instead. An example is included below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ebf8c054640eac7707617ac6e4bacc793e0e77" translate="yes" xml:space="preserve">
          <source>Early Redux documentation advised that you should only have a few connected components near the top of your component tree. However, time and experience has shown that that generally requires a few components to know too much about the data requirements of all their descendants, and forces them to pass down a confusing number of props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f12cdfc5423f3f8f4b141824700661516b50d41" translate="yes" xml:space="preserve">
          <source>Ecosystem</source>
          <target state="translated">Ecosystem</target>
        </trans-unit>
        <trans-unit id="80499668424a593b571c96afb7bfa53680db9225" translate="yes" xml:space="preserve">
          <source>Eddie Zaneski</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78c0f2575bc2cbbd58e1c8e6bfbabc097fdacf8" translate="yes" xml:space="preserve">
          <source>Egghead.io: Redux: Implementing combineReducers() from Scratch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bfc7a7b3d59e7e7fc34f2665c9e5ecf3f615b6" translate="yes" xml:space="preserve">
          <source>Elm</source>
          <target state="translated">Elm</target>
        </trans-unit>
        <trans-unit id="b0e68be5c4150141a8b181ac2f45237a837582b3" translate="yes" xml:space="preserve">
          <source>Emphasizing &amp;ldquo;one container component at the top&amp;rdquo; in Redux examples was a mistake. Don't take this as a maxim. Try to keep your presentation components separate. Create container components by connecting them when it's convenient. Whenever you feel like you're duplicating code in parent components to provide data for same kinds of children, time to extract a container. Generally as soon as you feel a parent knows too much about &amp;ldquo;personal&amp;rdquo; data or actions of its children, time to extract a container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1a0998563346ad2e48c38b39741bb352b08e65" translate="yes" xml:space="preserve">
          <source>Encapsulating and centralizing commonly used pieces of code is a key concept in programming. While it is certainly possible to manually create action objects everywhere, and write each &lt;code&gt;type&lt;/code&gt; value by hand, defining reusable constants makes maintaining code easier. If you put constants in a separate file, you can &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-import&quot;&gt;check your &lt;code&gt;import&lt;/code&gt; statements against typos&lt;/a&gt; so you can't accidentally use the wrong string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2f465254c1894a55c4eae9816aef0a576c3b88" translate="yes" xml:space="preserve">
          <source>Encapsulating the Redux State Tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd530f3fb4530f659965d7db1794f6c9a3831280" translate="yes" xml:space="preserve">
          <source>Enforcing that every change is described as an action lets us have a clear understanding of what&amp;rsquo;s going on in the app. If something changed, we know why it changed. Actions are like breadcrumbs of what has happened. Finally, to tie state and actions together, we write a function called a reducer. Again, nothing magical about it&amp;mdash;it&amp;rsquo;s just a function that takes state and action as arguments, and returns the next state of the app. It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465e88db20c49fa14df715ad3c0631b26ca590c4" translate="yes" xml:space="preserve">
          <source>Enhancers</source>
          <target state="translated">Enhancers</target>
        </trans-unit>
        <trans-unit id="a88e7a573b0a77f73eb1f2a5e5b8de48275a7af8" translate="yes" xml:space="preserve">
          <source>Entry Point</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1552f36ee13c5c4910ec207795eb05b9e58ae679" translate="yes" xml:space="preserve">
          <source>Even though the array might contain the exact same object references each time, the array itself is a different reference, so the shallow equality check fails and React Redux would re-render the wrapped component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a853804467e62df08fd20ca2def253cd121c2e" translate="yes" xml:space="preserve">
          <source>Ever wondered what &lt;code&gt;applyMiddleware&lt;/code&gt; itself is? It ought to be an extension mechanism more powerful than the middleware itself. Indeed, &lt;code&gt;applyMiddleware&lt;/code&gt; is an example of the most powerful Redux extension mechanism called &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt;. It is highly unlikely you'll ever want to write a store enhancer yourself. Another example of a store enhancer is &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;. Middleware is less powerful than a store enhancer, but it is easier to write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc61f5aead67e5d9613283a1a13842ab6b6cf6dd" translate="yes" xml:space="preserve">
          <source>Every function described above is a top-level export. You can import any of them like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ee7559d25a08d85f86a3eafc206977946b6a08" translate="yes" xml:space="preserve">
          <source>Every release, along with the migration instructions, is documented on the Github &lt;a href=&quot;https://github.com/reactjs/redux/releases&quot;&gt;Releases&lt;/a&gt; page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="e3199316bf69a183958e485b0e3d61bc9694e2fb" translate="yes" xml:space="preserve">
          <source>Example Apps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f523dd5956d4673cb690577c1f546426cc73cb" translate="yes" xml:space="preserve">
          <source>Example: Custom Logger Middleware</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2624afd8c460d6518734431bfb5d77b64cd9d60b" translate="yes" xml:space="preserve">
          <source>Example: Reddit API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa9b551b74932054b2efb6c627693e8d27f541a" translate="yes" xml:space="preserve">
          <source>Example: Todo List</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a4c17cabc25fb419d3b53e5dbaa4dd4a5664bd" translate="yes" xml:space="preserve">
          <source>Example: Using Thunk Middleware for Async Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="5f96798ae5ca58a4c6c508043f2d289c9f41fbff" translate="yes" xml:space="preserve">
          <source>Examples: Real World example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0cf0d774ed2b3b87b2898557f897bfef233151" translate="yes" xml:space="preserve">
          <source>Examples: Tree View</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032263383a22a1454a019ce94b7dce90ebcad1e2" translate="yes" xml:space="preserve">
          <source>Exploring Redux Middleware</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b171f7143f21268e520b74f4f5ead4fcb82ce831" translate="yes" xml:space="preserve">
          <source>Extracting Case Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be76799495bdf5c930a8ddd44f5e9d6d64c47cb" translate="yes" xml:space="preserve">
          <source>Extracting Utility Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="e38e4017ee383168752e8a33c5d6022a9a406df4" translate="yes" xml:space="preserve">
          <source>FAQ: Actions - &quot;1:1 mapping between reducers and actions?&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7e17066220bc43c820094351b4e2c42bbba769" translate="yes" xml:space="preserve">
          <source>FAQ: Immutable Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a41b860bf1ee467edbac48fd846ae33b759b787" translate="yes" xml:space="preserve">
          <source>FAQ: Performance - Reducing Update Events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0854a17ba3e0b5e9e9e1c578ac31d5ab4c9027" translate="yes" xml:space="preserve">
          <source>FAQ: Performance - Scaling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ab661908a8748685e7811083bdaf66ba18c68b" translate="yes" xml:space="preserve">
          <source>Finally, Redux provides a utility called &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; that does the same boilerplate logic that the &lt;code&gt;todoApp&lt;/code&gt; above currently does. With its help, we can rewrite &lt;code&gt;todoApp&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d847a6b9dee3deeeb8620787402b3a6277cb077" translate="yes" xml:space="preserve">
          <source>Finally, how do we use the synchronous action creators we &lt;a href=&quot;#synchronous-action-creators&quot;&gt;defined earlier&lt;/a&gt; together with network requests? The standard way to do it with Redux is to use the &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk middleware&lt;/a&gt;. It comes in a separate package called &lt;code&gt;redux-thunk&lt;/code&gt;. We'll explain how middleware works in general &lt;a href=&quot;middleware&quot;&gt;later&lt;/a&gt;; for now, there is just one important thing you need to know: by using this specific middleware, an action creator can return a function instead of an action object. This way, the action creator becomes a &lt;a href=&quot;https://en.wikipedia.org/wiki/Thunk&quot;&gt;thunk&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe6ba28d43370e1a707260f9b15d1702f3f2d3e" translate="yes" xml:space="preserve">
          <source>Finally, if the user performs an action (e.g. decrement the counter) while we're in the middle of the undo stack, we're going to discard the existing future:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11194f10e6abbfaba6e4a214b87b681a0b877527" translate="yes" xml:space="preserve">
          <source>Finally, the implementation of the &lt;code&gt;TOGGLE_TODO&lt;/code&gt; handler shouldn't come as a complete surprise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36e5836f13cd173c594e9d1ae569e82cd4fcdf5" translate="yes" xml:space="preserve">
          <source>Finally, to update objects, you'll need something like &lt;code&gt;_.extend&lt;/code&gt; from Underscore, or better, an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign&lt;/code&gt;&lt;/a&gt; polyfill.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199eca41911960b98af69aa50c0333310e9f9b48" translate="yes" xml:space="preserve">
          <source>Finally, we create the &lt;code&gt;VisibleTodoList&lt;/code&gt; by calling &lt;code&gt;connect()&lt;/code&gt; and passing these two functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca381bfbf08ee78348d1eccdc53ec800366da008" translate="yes" xml:space="preserve">
          <source>Finally, we'll add one more action type for changing the currently visible todos.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="905199d1f6693b173b187362217e8ceaf7447b9d" translate="yes" xml:space="preserve">
          <source>Finally, when the network request comes through, we will dispatch &lt;code&gt;RECEIVE_POSTS&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d68b76ad804092f57e99c9239a27fd692ed5c9b" translate="yes" xml:space="preserve">
          <source>Finally, you might want to begin using some Redux idioms like middleware to further simplify your asynchronous code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909dbfd3043edaf382cc7e5528d1f59884ba5ee8" translate="yes" xml:space="preserve">
          <source>Find the balance between these two extremes, and you will master Redux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f07a78d30b7ff474926fd0dc8957f55aa822b17" translate="yes" xml:space="preserve">
          <source>Find the rest of the container components defined below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f6506477b8650e1de1bd943b9bd705e36a074e2" translate="yes" xml:space="preserve">
          <source>Finding &lt;code&gt;state&lt;/code&gt;'s place with React and Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d1849effa55d228df19c7e131b0d22e859600d" translate="yes" xml:space="preserve">
          <source>Finished reading the article? Let's recount their differences:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="083f5d4f5390de8b339a7e0d1bcbede9836be5c8" translate="yes" xml:space="preserve">
          <source>Firefox's new debugger</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac6033d8edd65bf451fde639fbb2062cd288167" translate="yes" xml:space="preserve">
          <source>First Attempt: Writing a Reducer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63efbd7ad3629ab9570dc20eea84696652d1fe6" translate="yes" xml:space="preserve">
          <source>First and foremost, &lt;code&gt;combineReducers&lt;/code&gt; is simply &lt;strong&gt;a utility function to simplify the most common use case when writing Redux reducers&lt;/strong&gt;. You are &lt;em&gt;not&lt;/em&gt; required to use it in your own application, and it does &lt;em&gt;not&lt;/em&gt; handle every possible scenario. It is entirely possible to write reducer logic without using it, and it is quite common to need to write custom reducer logic for cases that &lt;code&gt;combineReducer&lt;/code&gt; does not handle. (See &lt;a href=&quot;beyondcombinereducers&quot;&gt;Beyond &lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; for examples and suggestions.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928aade909ab97ef47ad692458ac7b1733155f4f" translate="yes" xml:space="preserve">
          <source>First and foremost, it's important to understand that your entire application really only has &lt;strong&gt;one single reducer function&lt;/strong&gt;: the function that you've passed into &lt;code&gt;createStore&lt;/code&gt; as the first argument. That one single reducer function ultimately needs to do several things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3ce87bff6a9cf7a60a80fd1b3760fbe7caf2c7" translate="yes" xml:space="preserve">
          <source>First let's consider a case where you have a single reducer. Say you don't use &lt;code&gt;combineReducers()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7060a8772c7ed50446a754b52b327f7921592892" translate="yes" xml:space="preserve">
          <source>First of all, you need to run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fced756f7f0c570facc991f413283a69b01ef80e" translate="yes" xml:space="preserve">
          <source>First we will need to import &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; from React Router. Here's how to do it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928541190af20f02ef3132ea1dc14770650e0586" translate="yes" xml:space="preserve">
          <source>First, create a new container component called &lt;code&gt;UndoRedo&lt;/code&gt; for these buttons. We won't bother to split the presentational part into a separate file because it is very small:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066e50b38844dd1b5b820eb86ad656704f58e5eb" translate="yes" xml:space="preserve">
          <source>First, in terms of raw memory usage, Redux is no different than any other JavaScript library. The only difference is that all the various object references are nested together into one tree, instead of maybe saved in various independent model instances such as in Backbone. Second, a typical Redux app would probably have somewhat &lt;em&gt;less&lt;/em&gt; memory usage than an equivalent Backbone app because Redux encourages use of plain JavaScript objects and arrays rather than creating instances of Models and Collections. Finally, Redux only holds onto a single state tree reference at a time. Objects that are no longer referenced in that tree will be garbage collected, as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147db38719fb360e8ff8a98d1999647a14de68aa" translate="yes" xml:space="preserve">
          <source>First, let's define some actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d50b1a37307b503b16d51ae5983d1f25a15405ee" translate="yes" xml:space="preserve">
          <source>First, we will install &lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;. Enzyme uses the &lt;a href=&quot;https://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utilities&lt;/a&gt; underneath, but is more convenient, readable, and powerful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b752ccff5aae9d198427fafe188894e7b4c4185f" translate="yes" xml:space="preserve">
          <source>First, we'll need a middleware function. This is similar to the real &lt;a href=&quot;https://github.com/gaearon/redux-thunk/blob/master/src/index.js&quot;&gt;redux-thunk&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889e1c2f5289eea716835fde0adffaefad64d56f" translate="yes" xml:space="preserve">
          <source>Flux</source>
          <target state="translated">Flux</target>
        </trans-unit>
        <trans-unit id="2a436f0a330413dcad542ab5cfe9f14d15c70a1e" translate="yes" xml:space="preserve">
          <source>Following in the steps of &lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://martinfowler.com/bliki/CQRS.html&quot;&gt;CQRS&lt;/a&gt;, and &lt;a href=&quot;http://martinfowler.com/eaaDev/EventSourcing.html&quot;&gt;Event Sourcing&lt;/a&gt;, &lt;strong&gt;Redux attempts to make state mutations predictable&lt;/strong&gt; by imposing certain restrictions on how and when updates can happen. These restrictions are reflected in the &lt;a href=&quot;threeprinciples&quot;&gt;three principles&lt;/a&gt; of Redux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac52571ae4d35859cbf2d2ebb033839ab2f50f8" translate="yes" xml:space="preserve">
          <source>For Offline docs, please see: &lt;a href=&quot;http://devdocs.io/redux/&quot;&gt;devdocs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da99abcd0c1ecdf884964d566bca5697a74e01e" translate="yes" xml:space="preserve">
          <source>For PDF, ePub, and MOBI exports for offline reading, and instructions on how to create them, please see: &lt;a href=&quot;https://github.com/paulkogel/redux-offline-docs&quot;&gt;paulkogel/redux-offline-docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1569bd4eacec55d8eceb1c2595d3b535c8d3d3cf" translate="yes" xml:space="preserve">
          <source>For React Redux, &lt;code&gt;connect&lt;/code&gt; checks to see if the props returned from a &lt;code&gt;mapStateToProps&lt;/code&gt; function have changed in order to determine if a component needs to update. To improve performance, &lt;code&gt;connect&lt;/code&gt; takes some shortcuts that rely on the state being immutable, and uses shallow reference equality checks to detect changes. This means that &lt;strong&gt;changes made to objects and arrays by direct mutation will not be detected, and components will not re-render&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c36a66a555508cc950b3f16c937117a95df81ef" translate="yes" xml:space="preserve">
          <source>For a Redux app, your entire state tree should be an Immutable.JS object, with no plain JavaScript objects used at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="373c63c01af4767c75ccf47739d4a3ed95ce0716" translate="yes" xml:space="preserve">
          <source>For an extensive list of everything related to Redux, we recommend &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;. It contains examples, boilerplates, middleware, utility libraries, and more. &lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React/Redux Links&lt;/a&gt; contains tutorials and other useful resources for anyone learning React or Redux, and &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Ecosystem Links&lt;/a&gt; lists many Redux-related libraries and addons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b99470d4a1567b0670d5920564c85b87e32721b" translate="yes" xml:space="preserve">
          <source>For any action that is not recognized, it must return the &lt;code&gt;state&lt;/code&gt; given to it as the first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c64b95d623e1af01c5fa554a02283a92526e40" translate="yes" xml:space="preserve">
          <source>For any meaningful application, putting &lt;em&gt;all&lt;/em&gt; your update logic into a single reducer function is quickly going to become unmaintainable. While there's no single rule for how long a function should be, it's generally agreed that functions should be relatively short and ideally only do one specific thing. Because of this, it's good programming practice to take pieces of code that are very long or do many different things, and break them into smaller pieces that are easier to understand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce91fabee949d5ba66d92e41ee08124438c9737" translate="yes" xml:space="preserve">
          <source>For async action creators using &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; or other middleware, it's best to completely mock the Redux store for tests. You can apply the middleware to a mock store using &lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt;. You can also use &lt;a href=&quot;https://github.com/pgte/nock&quot;&gt;nock&lt;/a&gt; to mock the HTTP requests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd7c213802a3dd8c216e494ed4fd0e167b08890" translate="yes" xml:space="preserve">
          <source>For clarity, these terms will be used to distinguish between different types of functions and different use cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264e5e569126bec0eceb43b84e1205a13c4b6e76" translate="yes" xml:space="preserve">
          <source>For convenience, you can also pass a single function as the first argument, and get a function in return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90bf7f5a9bb0b7bee51eca7178498d0496d1d7b" translate="yes" xml:space="preserve">
          <source>For copying very large objects, &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;plain JavaScript can be over 100 times slower&lt;/a&gt; than an optimized immutable library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7525b69cd07a6f2ad0ac830aafa7a477337193ed" translate="yes" xml:space="preserve">
          <source>For every list of items, you'll want to store &lt;code&gt;isFetching&lt;/code&gt; to show a spinner, &lt;code&gt;didInvalidate&lt;/code&gt; so you can later toggle it when the data is stale, &lt;code&gt;lastUpdated&lt;/code&gt; so you know when it was fetched the last time, and the &lt;code&gt;items&lt;/code&gt; themselves. In a real app, you'll also want to store pagination state like &lt;code&gt;fetchedPageCount&lt;/code&gt; and &lt;code&gt;nextPageUrl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5da791bf1d292d4b08f432961ce1f7ce752416" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; lets the action creators invert control by dispatching functions. They would receive &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; as an argument and may call it asynchronously. Such functions are called &lt;em&gt;thunks&lt;/em&gt;. Another example of middleware is &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;. It lets you dispatch a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; async action, and dispatches a normal action when the Promise resolves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10a32bf34bb234c4f4d4ea0c462233658b63285" translate="yes" xml:space="preserve">
          <source>For example, a reducer like this is wrong because it mutates the state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9e2d4355c30145cce077b91c60d63448e5aed4" translate="yes" xml:space="preserve">
          <source>For example, instead of &lt;code&gt;myObj.prop1.prop2.prop3&lt;/code&gt;, you would use &lt;code&gt;myImmutableMap.getIn([&amp;lsquo;prop1&amp;rsquo;, &amp;lsquo;prop2&amp;rsquo;, &amp;lsquo;prop3&amp;rsquo;])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8910597d94358b44fab63079f57037fc6eedac16" translate="yes" xml:space="preserve">
          <source>For example, instead of calling &lt;code&gt;dispatch&lt;/code&gt; with an object literal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36409b0b5da0fd93351cad56b27c2cc459ec9cbc" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;code&gt;mapStateToProps&lt;/code&gt; function will never trigger a re-render:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405aef87040b2f5fe3183ef8ee7aaa8b9e2f3921" translate="yes" xml:space="preserve">
          <source>For example, the following will always trigger a re-render:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b08550f3233d89fd265c7a809fdb23fce5207d" translate="yes" xml:space="preserve">
          <source>For example, the state shape of a counter app might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4676e5ae615d02cd767e41c0d9c575c5c5363047" translate="yes" xml:space="preserve">
          <source>For example, you will no longer be able to reference an object&amp;rsquo;s properties through standard JavaScript dot or bracket notation. Instead, you must reference them via Immutable.JS&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; or &lt;code&gt;getIn()&lt;/code&gt; methods, which use an awkward syntax that accesses properties via an array of strings, each of which represents a property key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b6ef57734c544f1e210f261517935088c63d17" translate="yes" xml:space="preserve">
          <source>For non-connected components, you may want to check what props are being passed in. A common issue is having a parent component re-bind a callback inside its render function, like &lt;code&gt;&amp;lt;Child onClick={this.handleClick.bind(this)} /&amp;gt;&lt;/code&gt;. That creates a new function reference every time the parent re-renders. It's generally good practice to only bind callbacks once in the parent component's constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37294e7b86a5fec1ad730201ca1b51e170da12c" translate="yes" xml:space="preserve">
          <source>For our example, we'll imagine there is an external datastore that contains the counter's initial value (Counter As A Service, or CaaS). We'll make a mock call over to them and build our initial state from the result. We'll start by building out our API call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995f52d4ef9a4c2e7bfadd425b73b546c07eadfc" translate="yes" xml:space="preserve">
          <source>For our simplistic example, coercing our input into a number is sufficiently secure. If you're handling more complex input, such as freeform text, then you should run that input through an appropriate sanitization function, such as &lt;a href=&quot;https://www.npmjs.com/package/validator&quot;&gt;validator.js&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7396dc033a9d17308dac01b1e6d7aa01bc7866e7" translate="yes" xml:space="preserve">
          <source>For our todo app, we want to store two different things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b88fefd81c01717012ff82bfc5ac24328d967a87" translate="yes" xml:space="preserve">
          <source>For this example, we'll be using &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; as a simple web server. We also need to install the React bindings for Redux, since they are not included in Redux by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f714199c4cde247b055dd1036923fa69c491b814" translate="yes" xml:space="preserve">
          <source>For time traveling, the Redux DevTools expect that replaying recorded actions would output a state value, but not change anything else. &lt;strong&gt;Side effects like mutation or asynchronous behavior will cause time travel to alter behavior between steps, breaking the application&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1154ea57349682fcc3f891e405a8a167837c09" translate="yes" xml:space="preserve">
          <source>For universal apps that run on the server, create a store instance with every request so that they are isolated. Dispatch a few data fetching actions to a store instance and wait for them to complete before rendering the app on the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c80d0eb6a19f502dd39ce9e0007f6cec7683d4" translate="yes" xml:space="preserve">
          <source>Four Strategies for Organizing Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76682a747378edf323eb6fca480334e44800121b" translate="yes" xml:space="preserve">
          <source>Frequently, yes. There are various tradeoffs and opinions to consider, but there are many good reasons to use Immutable.JS. Do not underestimate the difficulty of trying to track down a property of your state tree that has been inadvertently mutated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46dc46fc099af2967e7cb377eb917390bbe8d91f" translate="yes" xml:space="preserve">
          <source>From Backbone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f765f89e7e86977403237359a10b70b8245b636" translate="yes" xml:space="preserve">
          <source>From Flux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbacf3ec560ee96572c8e953a6aff0a1a3667b3" translate="yes" xml:space="preserve">
          <source>From Flux to Redux: Async Actions the easy way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75482a47184505a4b6fae82571885f1d4ef06ba7" translate="yes" xml:space="preserve">
          <source>From the very beginning, we need to stress that Redux has no relation to React. You can write Redux apps with React, Angular, Ember, jQuery, or vanilla JavaScript.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224f84dc1c16ed87eb23acbffde43619f014060d" translate="yes" xml:space="preserve">
          <source>Full-Stack Redux Tutorial</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3823c3e33f7c5c6aab3e4cafa98d3b53883fbcdd" translate="yes" xml:space="preserve">
          <source>Functions for handling a specific update case, which often need parameters other than the typical &lt;code&gt;(state, action)&lt;/code&gt; pair</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881a7f4ab6d6cdbe058390dcfebb91eedae46fb5" translate="yes" xml:space="preserve">
          <source>Functions which handle &lt;em&gt;all&lt;/em&gt; updates for a given slice of state. These functions do generally have the typical &lt;code&gt;(state, action)&lt;/code&gt; parameter signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669174087b9bbb07e556f8eda6679016d67b42c9" translate="yes" xml:space="preserve">
          <source>Further Information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285d7a1408b289b80750e52c797a605ffba295ee" translate="yes" xml:space="preserve">
          <source>Further Suggestions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2268c82bc8b73813924087eddf93b3d9fbf05d" translate="yes" xml:space="preserve">
          <source>Further information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d69e595b386dcd4b71cc9ff73b11b2154e10dd8" translate="yes" xml:space="preserve">
          <source>Furthermore, you can add additional layers of security by sanitizing your state output. &lt;code&gt;JSON.stringify&lt;/code&gt; can be subject to script injections. To counter this, you can scrub the JSON string of HTML tags and other dangerous characters. This can be done with either a simple text replacement on the string, e.g. &lt;code&gt;JSON.stringify(state).replace(/&amp;lt;/g, '\\u003c')&lt;/code&gt;, or via more sophisticated libraries such as &lt;a href=&quot;https://github.com/yahoo/serialize-javascript&quot;&gt;serialize-javascript&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="c4692b39bf633417d53521cb512f44dbc259440a" translate="yes" xml:space="preserve">
          <source>Generating Action Creators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179c9a970856be2ac8a72de045cb7b6d6b4b6c90" translate="yes" xml:space="preserve">
          <source>Generating Reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c1ccf8c4dcce798c8264f04e642d8a0159063d" translate="yes" xml:space="preserve">
          <source>Getting Started with React, Redux, and Immutable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3185ff60f7a746675039a0e069131de1e5f61876" translate="yes" xml:space="preserve">
          <source>Gist: Breaking out of Redux paradigm to isolate apps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ae5196eb35af7600e4766e0ded323420cfe70a" translate="yes" xml:space="preserve">
          <source>Gist: Redux-Thunk examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244ed27647275ec13c3db28bb136d4743fa6b213" translate="yes" xml:space="preserve">
          <source>Gist: state mutations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8269375bc0d8516c14e2645a941c5fefb4b9c0" translate="yes" xml:space="preserve">
          <source>Given this middleware we just wrote:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="6236cf415b3887e7fa20a5499f765aa16f7720ff" translate="yes" xml:space="preserve">
          <source>Guaranteed immutability</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229bbdd56d74f7206cf36e6c06a296b111d18641" translate="yes" xml:space="preserve">
          <source>HN: Is there any huge web application built using Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74133e32e5bca2a26d927cd61a1825ca6cda78f2" translate="yes" xml:space="preserve">
          <source>Handcrafting an Isomorphic Redux Application (With Love)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc392181cc37736073babefa3f6b0cbb53acb816" translate="yes" xml:space="preserve">
          <source>Handles unregistering of listeners via the function returned by &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d811048186a91e33bc9331b69a6d594a01ea8e" translate="yes" xml:space="preserve">
          <source>Handling Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7e8e8b24ce8d7679b9a35675bb0a5a7fc840b3" translate="yes" xml:space="preserve">
          <source>Handling More Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="953d7b032c3bd0ac312412488e804519480a1aca" translate="yes" xml:space="preserve">
          <source>Handling Other Actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97703fb2d2356eb6114659a0c343d14449211c9" translate="yes" xml:space="preserve">
          <source>Handling Redo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f326b5a21b8a49169e4839d3f63669543242d741" translate="yes" xml:space="preserve">
          <source>Handling Undo</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="988ce2e99df35e16eb481b727e182b8b8087a2b5" translate="yes" xml:space="preserve">
          <source>Handling the Request</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e05fe2ae332d92f70e77aaf42eb727d3dd91277" translate="yes" xml:space="preserve">
          <source>Here is an &lt;code&gt;App&lt;/code&gt; component that renders three &lt;code&gt;VisibleTodoList&lt;/code&gt; components, each of which has a &lt;code&gt;listId&lt;/code&gt; prop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ae030423c3a4339c6c0b04d05978042792f95c" translate="yes" xml:space="preserve">
          <source>Here is an example of such a HOC:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8446f01d6be3b14bffe6480fb53ea4f664e0a65d" translate="yes" xml:space="preserve">
          <source>Here is our code so far. It is rather verbose:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a60734010e587fd0830a7e888c7853a46bf0c7" translate="yes" xml:space="preserve">
          <source>Here's an example action which represents adding a new todo item:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58052dece84922788386c735487e1b86cccdad36" translate="yes" xml:space="preserve">
          <source>Here's an example of how use of ES6 object literal shorthand with &lt;code&gt;combineReducers&lt;/code&gt; can define the state shape:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2070c6c8e07ed8692f85545a5ee98fc311bf9af4" translate="yes" xml:space="preserve">
          <source>Here's how &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; works. Let's say you have two reducers, one for a list of todos, and another for the currently selected filter setting:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184bf60ef71f5a65467a6a7e96127cd713b7a9bf" translate="yes" xml:space="preserve">
          <source>Here's how to apply it to a Redux store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90015c747ff3bb6a4ca0fc41c0c7d1de4924c13" translate="yes" xml:space="preserve">
          <source>Here's what the state shape for our &amp;ldquo;Reddit headlines&amp;rdquo; app might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e2ce3154db89332ee8e9029cbb43d7deffada1" translate="yes" xml:space="preserve">
          <source>Here, we assume that you understand reducer composition with &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt;, as described in the &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;Splitting Reducers&lt;/a&gt; section on the &lt;a href=&quot;../basics/index&quot;&gt;basics guide&lt;/a&gt;. If you don't, please &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;read it first&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47fb358d9a27b7f7c208a41f405f09df333fd295" translate="yes" xml:space="preserve">
          <source>High Performance Redux Apps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6176fc50b39dc51f67828e874d1a9c381927a9" translate="yes" xml:space="preserve">
          <source>High-Performance Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0aade7f036690bfbe818641db114550adf02045" translate="yes" xml:space="preserve">
          <source>Higher order reducers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661e90fbdb35e42cd0f11c03ad2413796fd99f73" translate="yes" xml:space="preserve">
          <source>Holds application state;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70558178e9ca9037c4306a5560966893b2ba1623" translate="yes" xml:space="preserve">
          <source>How can I implement authentication in Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbe1f27c0ff1e15f55cf992eaea12f8ad35811b" translate="yes" xml:space="preserve">
          <source>How can I reduce the number of store update events?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6d20f2240e1c560f741e78debd31b4eea339de" translate="yes" xml:space="preserve">
          <source>How can I represent &amp;ldquo;side effects&amp;rdquo; such as AJAX calls? Why do we need things like &amp;ldquo;action creators&amp;rdquo;, &amp;ldquo;thunks&amp;rdquo;, and &amp;ldquo;middleware&amp;rdquo; to do async behavior?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8281d5ee1ef4deaaed00468f7711255feaa03216" translate="yes" xml:space="preserve">
          <source>How can I speed up my &lt;code&gt;mapStateToProps&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341af2b298ee968641c89dc8fc39d6a76071ec0f" translate="yes" xml:space="preserve">
          <source>How can I speed up my mapStateToProps?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074c1f363f6a663f824f52ea0c32767c57407e9c" translate="yes" xml:space="preserve">
          <source>How can immutability in &lt;code&gt;mapStateToProps&lt;/code&gt; cause components to render unnecessarily?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b224cf4298710c4b3d505de8354cfc9ba8c010d0" translate="yes" xml:space="preserve">
          <source>How can immutability in mapStateToProps cause components to render unnecessarily?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afd69541aac46a2c40250df385736019b6c57fc" translate="yes" xml:space="preserve">
          <source>How can immutability in your reducers cause components to render unnecessarily?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c2da4eb5dd93b3bf52e21145059bf09d5e25b4" translate="yes" xml:space="preserve">
          <source>How do I organize nested or duplicate data in my state?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37efe0864de2a013d86c02169f816af32cb5f56" translate="yes" xml:space="preserve">
          <source>How do I share state between two reducers? Do I have to use &lt;code&gt;combineReducers&lt;/code&gt;?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2bb6943dc8bbb29ceaf8280fcfbee59990be7f" translate="yes" xml:space="preserve">
          <source>How do I share state between two reducers? Do I have to use combineReducers?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39a19a487dfb8b0307ebc780f2d744e66346a60f" translate="yes" xml:space="preserve">
          <source>How do I subscribe to only a portion of the state? Can I get the dispatched action as part of the subscription?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="970d13e8ba247d72a23a1227b9eb76ab329d86fd" translate="yes" xml:space="preserve">
          <source>How do Shallow and Deep Equality Checking differ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c2d5d8451c047bc1a0f4cecf88ad6567282a2d" translate="yes" xml:space="preserve">
          <source>How do shallow and deep equality checking differ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ccec8f1ac279469a0f68091311d50666024b89" translate="yes" xml:space="preserve">
          <source>How do we actually delegate the control over the &lt;code&gt;present&lt;/code&gt; state to a custom reducer?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fff3cc86a8e920d14e4b6d08ec84a36cf3ae1884" translate="yes" xml:space="preserve">
          <source>How do we approach this with Redux?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c14f55ced4d84011da65e3315eb866d4d9ce19" translate="yes" xml:space="preserve">
          <source>How do we include the Redux Thunk middleware in the dispatch mechanism? We use the &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt; store enhancer from Redux, as shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8959099626f271882311c3c243bbfdda634b6be4" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;combineReducers&lt;/code&gt; use shallow equality checking?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e264f190d3a7100ff16f8e0b792baf3242dd0158" translate="yes" xml:space="preserve">
          <source>How does React-Redux use shallow equality checking to determine whether a component needs re-rendering?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f4f9bb8ec7adca1dffda3a094e04eb9bf81ce9" translate="yes" xml:space="preserve">
          <source>How does React-Redux use shallow equality checking?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5cc6209f66bc3c55e7f41aa1d6494bbd46dc8e9" translate="yes" xml:space="preserve">
          <source>How does Redux use shallow equality checking?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96952132f67badca2ba5bab5e41044f8fb225996" translate="yes" xml:space="preserve">
          <source>How does immutability enable a shallow check to detect object mutations?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258f5cf42a9d12d463ef4f13ff6a4e2964d9748d" translate="yes" xml:space="preserve">
          <source>How putting too much logic in action creators could affect debugging</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c23c5f78cdee9be5d0a8aa246f623d02051202" translate="yes" xml:space="preserve">
          <source>How should I split my logic between reducers and action creators? Where should my &amp;ldquo;business logic&amp;rdquo; go?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844c750f088f6ec26d17f13bffa791aa0381caa4" translate="yes" xml:space="preserve">
          <source>How things look (markup, styles)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4042ce0bd829dee86f5f8db37a02e8a871f8f88" translate="yes" xml:space="preserve">
          <source>How things work (data fetching, state updates)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa346393f4fb3e9654b9c58c84d9e7de2aec74bf" translate="yes" xml:space="preserve">
          <source>How to Scale React Applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47937596549577004fa72bfb56667e643c361800" translate="yes" xml:space="preserve">
          <source>How to handle state in React: the missing FAQ</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49dee5bfff40b97a93bb5e0172be4f4d25ffb4f5" translate="yes" xml:space="preserve">
          <source>How to think in terms of combining functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a44fd27737b51871064dcba886fdf85182ed8ca" translate="yes" xml:space="preserve">
          <source>How well does Redux &amp;ldquo;scale&amp;rdquo; in terms of performance and architecture?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5049bfb2117becfff285cdc67dde0f10a6d2171" translate="yes" xml:space="preserve">
          <source>How you structure the root reducer is completely up to you. Redux ships with a &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; helper function, useful for &amp;ldquo;splitting&amp;rdquo; the root reducer into separate functions that each manage one branch of the state tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d072600a3b53bb4cfed12bc142b48432221674c" translate="yes" xml:space="preserve">
          <source>However, creating new stores shouldn't be your first instinct, especially if you come from a Flux background. Try reducer composition first, and only use multiple stores if it doesn't solve your problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27352aa59f7116a388d254a03cb3ffe5f2f70e56" translate="yes" xml:space="preserve">
          <source>However, even if you happen to have many different reducer functions composed together, and even with deeply nested state, reducer speed is unlikely to be a problem. JavaScript engines are capable of running a very large number of function calls per second, and most of your reducers are probably just using a &lt;code&gt;switch&lt;/code&gt; statement and returning the existing state by default in response to most actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="209c7d1b896b9b48924c44438236581d9ba02ccc" translate="yes" xml:space="preserve">
          <source>However, guaranteeing immutability with JavaScript is difficult, and it can be easy to mutate an object accidentally, causing bugs in your app that are extremely difficult to locate. For this reason, using an immutable update utility library such as Immutable.JS can significantly improve the reliability of your app, and make your app&amp;rsquo;s development much easier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007edd469aeadd3134e72ff280534f419b360c63" translate="yes" xml:space="preserve">
          <source>However, if you wrap &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt;, the middleware can interpret actions differently, and provide support for dispatching &lt;a href=&quot;../glossary#async-action&quot;&gt;async actions&lt;/a&gt;. Async actions are usually asynchronous primitives like Promises, Observables, or thunks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6ac0b7fe7b68443642555f387d0a08b371f125" translate="yes" xml:space="preserve">
          <source>However, in our Redux App we will still need &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; is the higher-order component provided by React Redux that lets you bind Redux to React (see &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf708fc8c3314c936b8e0786f74c3d98798623d" translate="yes" xml:space="preserve">
          <source>However, it is important that we keep logging and crash reporting separate. Ideally we want them to be different modules, potentially in different packages. Otherwise we can't have an ecosystem of such utilities. (Hint: we're slowly getting to what middleware is!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d31965c3ec47c4faba43c57bec50a234ddcbc5a" translate="yes" xml:space="preserve">
          <source>However, it is still monkeypatching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97da1c31078988cc6aa942ce9cf7c26c29a6edc" translate="yes" xml:space="preserve">
          <source>However, it's also important to understand that using Redux comes with tradeoffs. It's not designed to be the shortest or fastest way to write code. It's intended to help answer the question &quot;When did a certain slice of state change, and where did the data come from?&quot;, with predictable behavior. It does so by asking you to follow specific constraints in your application: store your application's state as plain data, describe changes as plain objects, and handle those changes with pure functions that apply updates immutably. This is often the source of complaints about &quot;boilerplate&quot;. These constraints require effort on the part of a developer, but also open up a number of additional possibilities (such as store persistence and synchronization).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c39c3a93928d93c157bb221e087802a4b99e7d" translate="yes" xml:space="preserve">
          <source>However, remember that the key is that the &lt;em&gt;original in-memory reference&lt;/em&gt; is not modified. &lt;strong&gt;As long as we make a copy first, we can safely mutate the copy&lt;/strong&gt;. Note that this is true for both arrays and objects, but nested values still must be updated using the same rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b3dc33e56385563b9249f48fd1c5fc362f06f4" translate="yes" xml:space="preserve">
          <source>However, shallow checking will not work if your data encapsulated within an Immutable.JS object is itself an object. This is because Immutable.JS&amp;rsquo;s &lt;code&gt;toJS()&lt;/code&gt; method, which returns the data contained within an Immutable.JS object as a JavaScript value, will create a new object every time it&amp;rsquo;s called, and so break the reference with the encapsulated data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b519a9362c1955561b3e4941334f49ea0df524a1" translate="yes" xml:space="preserve">
          <source>However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8c9304fae62928333a51a2b537a686e6b3a79a" translate="yes" xml:space="preserve">
          <source>However, we don't have to call &lt;code&gt;ReactDOM.render(&amp;lt;Provider&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;)&lt;/code&gt; if we're interested in hiding the fact that the sub-app component is a Redux app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c62654e7682bc0051c67f69252368a8aa8daf0" translate="yes" xml:space="preserve">
          <source>However, when you import it, you're actually holding the wrapper component returned by &lt;code&gt;connect()&lt;/code&gt;, and not the &lt;code&gt;App&lt;/code&gt; component itself. If you want to test its interaction with Redux, this is good news: you can wrap it in a &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt;&lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt;&lt;/a&gt; with a store created specifically for this unit test. But sometimes you want to test just the rendering of the component, without a Redux store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34092e543dd93b03e651093a3d7a3b5a60f9550" translate="yes" xml:space="preserve">
          <source>However, you &lt;em&gt;do&lt;/em&gt; need to create a copied and updated object for each level of nesting that is affected. Although that shouldn't be particularly expensive, it's another good reason why you should keep your state normalized and shallow if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637b51ba07484e27e5e6b55d068f2f69a042cefb" translate="yes" xml:space="preserve">
          <source>I see the following presentational components and their props emerge from this brief:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc27465fc6ceedd55291ea4f132c806be70591bb" translate="yes" xml:space="preserve">
          <source>I would like to amend this: don't use Redux until you have problems with vanilla React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad18fcf9dd2ee8a9f5ea170593bb2c6bee68d60d" translate="yes" xml:space="preserve">
          <source>I wrote Redux while working on my React Europe talk called &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;&amp;ldquo;Hot Reloading with Time Travel&amp;rdquo;&lt;/a&gt;. My goal was to create a state management library with minimal API but completely predictable behavior, so it is possible to implement logging, hot reloading, time travel, universal apps, record and replay, without any buy-in from the developer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618b7ca25386b5f5436f346c2ed5051a72f4a73a" translate="yes" xml:space="preserve">
          <source>Idiomatic Redux: Normalizing the State Shape</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe91fe24d5f9dd8e770fad3a725bc0cec34aab62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;applyMiddlewareByMonkeypatching&lt;/code&gt; doesn't assign &lt;code&gt;store.dispatch&lt;/code&gt; immediately after processing the first middleware, &lt;code&gt;store.dispatch&lt;/code&gt; will keep pointing to the original &lt;code&gt;dispatch&lt;/code&gt; function. Then the second middleware will also be bound to the original &lt;code&gt;dispatch&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f456ed22b65b432754496a635957ff1170346a" translate="yes" xml:space="preserve">
          <source>If a Redux reducer directly mutates, and returns, the state object passed into it, the values of the root state object will change, but the object itself will not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a08f5491a0b259f6b66f794074ee1e3a74e48f7" translate="yes" xml:space="preserve">
          <source>If a reducer needs to know data from another slice of state, the state tree shape may need to be reorganized so that a single reducer is handling more of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9faa62e0446c64c2b5f25f17a54da0f020cabc00" translate="yes" xml:space="preserve">
          <source>If an action creator needs to read the current state, perform an API call, or cause a side effect, like a routing transition, it should return an &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt; instead of an action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e288fd9913bf6a8a74842392c22a2dd0b95c7906" translate="yes" xml:space="preserve">
          <source>If an object is immutable, any changes that need to be made to it within a function must be made to a &lt;em&gt;copy&lt;/em&gt; of the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3b9f89d6838d129b565fe3186a16b253684268" translate="yes" xml:space="preserve">
          <source>If it does, the shallow equality check that &lt;code&gt;combineReducers&lt;/code&gt; performs will always pass, as the values of the state slice returned by the reducer may have been mutated, but the object itself has not - it&amp;rsquo;s still the same object that was passed to the reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb66a4049905816e9b1a9b102420a18f13b1512" translate="yes" xml:space="preserve">
          <source>If logging and crash reporting are separate utilities, they might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d10f3d1de6596be190d60a9a58973fddf0a134c" translate="yes" xml:space="preserve">
          <source>If no changes are needed, it should return the existing state as-is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9ad27c90229a42dd677eb94e9afe7a27ff90c9" translate="yes" xml:space="preserve">
          <source>If one of the values of the props object returned from &lt;code&gt;mapStateToProps&lt;/code&gt; is an object that persists across calls to &lt;code&gt;connect&lt;/code&gt; (such as, potentially, the root state object), yet is directly mutated and returned by a selector function, React-Redux will not be able to detect the mutation, and so will not trigger a re-render of the wrapped component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d728b3f7c8756b0e1d6727b86ff4b7f986fb4b" translate="yes" xml:space="preserve">
          <source>If such an operation is used as a selector function in &lt;code&gt;mapStateToProps&lt;/code&gt;, the shallow equality check that React-Redux performs on each value in the props object that&amp;rsquo;s returned will always fail, as the selector is returning a new object each time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ceb90dff402277125291134484216343d65527" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;state&lt;/code&gt; given to it is &lt;code&gt;undefined&lt;/code&gt;, it must return the initial state for this specific reducer. According to the previous rule, the initial state must not be &lt;code&gt;undefined&lt;/code&gt; either. It is handy to specify it with ES6 optional arguments syntax, but you can also explicitly check the first argument for being &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a886e11c2cb542f0ecf3d252296e52fe4603bb" translate="yes" xml:space="preserve">
          <source>If the check fails, however, the root state object &lt;em&gt;has&lt;/em&gt; been updated, and so &lt;code&gt;connect&lt;/code&gt; will call &lt;code&gt;mapStateToProps&lt;/code&gt;to see if the props for the wrapped component have been updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ddbf9b8aa21e91694b18c1515d700c56e251753" translate="yes" xml:space="preserve">
          <source>If the shallow equality check fails between the new values returned from &lt;code&gt;mapStateToProps&lt;/code&gt; and the previous values that React-Redux kept a reference to, then a re-rendering of the component will be triggered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5775e4e8ec131359e210f027aac76d6574f7fe" translate="yes" xml:space="preserve">
          <source>If these functions are published as separate modules, we can later use them to patch our store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d3eb0d142a4003073ed1cec6a2f5fd9c278548" translate="yes" xml:space="preserve">
          <source>If two different variables reference the same immutable object, then a simple equality check of the two variables is enough to determine that they are equal, and that the object they both reference is unchanged. The equality check never has to check the values of any of the object&amp;rsquo;s properties, as it is, of course, immutable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ff3107eee34b9cab68e06d253a65fa91028026" translate="yes" xml:space="preserve">
          <source>If we call &lt;code&gt;createStore&lt;/code&gt; without the &lt;code&gt;preloadedState&lt;/code&gt;, it's going to initialize the &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;{}&lt;/code&gt;. Therefore, &lt;code&gt;state.a&lt;/code&gt; and &lt;code&gt;state.b&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; by the time it calls &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reducers. &lt;strong&gt;Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reducers will receive &lt;code&gt;undefined&lt;/code&gt; as &lt;em&gt;their&lt;/em&gt; &lt;code&gt;state&lt;/code&gt; arguments, and if they specify default &lt;code&gt;state&lt;/code&gt; values, those will be returned.&lt;/strong&gt; This is how the combined reducer returns a &lt;code&gt;{ a: 'lol', b: 'wat' }&lt;/code&gt; state object on the first invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df247b3c417208103f01c75fc35280be43fc622" translate="yes" xml:space="preserve">
          <source>If we have a nested tree of slice reducers, each slice reducer will need to know how to respond to this action appropriately. We will need to include all the relevant data in the action. We need to update the correct Post object with the comment's ID, create a new Comment object using that ID as a key, and include the Comment's ID in the list of all Comment IDs. Here's how the pieces for this might fit together:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9835b5068457c01cd0ee22c6f2d1f319535710" translate="yes" xml:space="preserve">
          <source>If we pass &lt;code&gt;makeMapStateToProps&lt;/code&gt; to &lt;code&gt;connect&lt;/code&gt;, each instance of the &lt;code&gt;VisibleTodosList&lt;/code&gt; container will get its own &lt;code&gt;mapStateToProps&lt;/code&gt; function with a private &lt;code&gt;getVisibleTodos&lt;/code&gt; selector. Memoization will now work correctly regardless of the render order of the &lt;code&gt;VisibleTodoList&lt;/code&gt; containers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f7ebaf8e95ed592e947bea2433fe217182ccf7" translate="yes" xml:space="preserve">
          <source>If we wanted to implement Undo and Redo in such an app, we'd need to store more state so we can answer the following questions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e391178bee157d67e539832bad15008f2621985" translate="yes" xml:space="preserve">
          <source>If you actually are concerned about reducer performance, you can use a utility such as &lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; or &lt;a href=&quot;https://github.com/chrisdavies/reduxr-scoped-reducer&quot;&gt;reduxr-scoped-reducer&lt;/a&gt; to ensure that only certain reducers listen to specific actions. You can also use &lt;a href=&quot;https://github.com/michaelcontento/redux-log-slow-reducers&quot;&gt;redux-log-slow-reducers&lt;/a&gt; to do some performance benchmarking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="199562b5deb45f1013629dc76cd0a79e09f79a5f" translate="yes" xml:space="preserve">
          <source>If you are okay with things like persistence and time-travel debugging potentially not working as intended, then you are totally welcome to put non-serializable items into your Redux store. Ultimately, it's &lt;em&gt;your&lt;/em&gt; application, and how you implement it is up to you. As with many other things about Redux, just be sure you understand what tradeoffs are involved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932e447c8721986d2617272ec0cb57f8fa838b1b" translate="yes" xml:space="preserve">
          <source>If you are serving your &lt;code&gt;index.html&lt;/code&gt; from Express:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e044138df780189a8da20f4e5abaa151739142" translate="yes" xml:space="preserve">
          <source>If you are serving your &lt;code&gt;index.html&lt;/code&gt; from WebpackDevServer: You can add to your webpack.config.dev.js:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c971a979a1e736d56294d1498dc9977ed0a0326" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, you can call selectors as regular functions inside &lt;code&gt;mapStateToProps()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b429d41b92c2a713e5a488236e816823364d7151" translate="yes" xml:space="preserve">
          <source>If you are using Create React App, you won't need to configure a fallback URL, it is automatically done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2bbb0e9ddb72ba973272562f236d089b4f6c651" translate="yes" xml:space="preserve">
          <source>If you are using ES6 in your application source, but write your tests in ES5, you should know that Babel handles the interchangeable use of ES6 &lt;code&gt;import&lt;/code&gt; and CommonJS &lt;code&gt;require&lt;/code&gt; through its &lt;a href=&quot;http://babeljs.io/docs/usage/modules/#interop&quot;&gt;interop&lt;/a&gt; capability to run two module formats side-by-side, but the behavior is &lt;a href=&quot;https://github.com/babel/babel/issues/2047&quot;&gt;slightly different&lt;/a&gt;. If you add a second export beside your default export, you can no longer import the default using &lt;code&gt;require('./App')&lt;/code&gt;. Instead you have to use &lt;code&gt;require('./App').default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036337c885ec3cef3b7191a050a9577f4c076991" translate="yes" xml:space="preserve">
          <source>If you attempt to call &lt;code&gt;dispatch&lt;/code&gt; from inside the &lt;a href=&quot;../glossary#reducer&quot;&gt;reducer&lt;/a&gt;, it will throw with an error saying &amp;ldquo;Reducers may not dispatch actions.&amp;rdquo; This is similar to &amp;ldquo;Cannot dispatch in a middle of dispatch&amp;rdquo; error in Flux, but doesn't cause the problems associated with it. In Flux, a dispatch is forbidden while Stores are handling the action and emitting updates. This is unfortunate because it makes it impossible to dispatch actions from component lifecycle hooks or other benign places.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a26433b9beefd0c99622c27b6f8d2d577a33f8" translate="yes" xml:space="preserve">
          <source>If you define an action creator, calling it will &lt;em&gt;not&lt;/em&gt; automatically dispatch the action. For example, this code will do nothing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30875373163ba2a0b61d1b93ce3b8577d3f0b61f" translate="yes" xml:space="preserve">
          <source>If you do not provide your own &lt;code&gt;mapDispatchToProps&lt;/code&gt; function when calling &lt;code&gt;connect()&lt;/code&gt;, React Redux will provide a default version, which simply returns the &lt;code&gt;dispatch&lt;/code&gt; function as a prop. That means that if you &lt;em&gt;do&lt;/em&gt; provide your own function, &lt;code&gt;dispatch&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; automatically provided. If you still want it available as a prop, you need to explicitly return it yourself in your &lt;code&gt;mapDispatchToProps&lt;/code&gt; implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9737b1fd992921039384e8e5be9f5b18af16860f" translate="yes" xml:space="preserve">
          <source>If you don't use a module bundler, it's also fine. The &lt;code&gt;redux&lt;/code&gt; npm package includes precompiled production and development &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; builds in the &lt;a href=&quot;https://unpkg.com/redux/dist/&quot;&gt;&lt;code&gt;dist&lt;/code&gt; folder&lt;/a&gt;. They can be used directly without a bundler and are thus compatible with many popular JavaScript module loaders and environments. For example, you can drop a UMD build as a &lt;a href=&quot;https://unpkg.com/redux/dist/redux.js&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag&lt;/a&gt; on the page, or &lt;a href=&quot;https://github.com/reactjs/redux/pull/1181#issuecomment-167361975&quot;&gt;tell Bower to install it&lt;/a&gt;. The UMD builds make Redux available as a &lt;code&gt;window.Redux&lt;/code&gt; global variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd567ddaa1825598645d89fa68d6db13748ff49" translate="yes" xml:space="preserve">
          <source>If you don't use npm, you may grab the latest UMD build from unpkg (either a &lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.js&quot;&gt;development&lt;/a&gt; or a &lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.min.js&quot;&gt;production&lt;/a&gt; build). The UMD build exports a global called &lt;code&gt;window.ReactRedux&lt;/code&gt; if you add it to your page via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc59110c4fe5748abe56530a6ab2f4825ec53fe" translate="yes" xml:space="preserve">
          <source>If you enjoyed my course, consider supporting Egghead by &lt;a href=&quot;https://egghead.io/pricing&quot;&gt;buying a subscription&lt;/a&gt;. Subscribers have access to the source code for the example in every one of my videos, as well as to tons of advanced lessons on other topics, including JavaScript in depth, React, Angular, and more. Many &lt;a href=&quot;https://egghead.io/instructors&quot;&gt;Egghead instructors&lt;/a&gt; are also open source library authors, so buying a subscription is a nice way to thank them for the work that they've done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a385f2b719ab2caac4808cd62fba207c8acd6d" translate="yes" xml:space="preserve">
          <source>If you figure it out, &lt;a href=&quot;https://github.com/reactjs/redux/edit/master/docs/Troubleshooting.md&quot;&gt;edit this document&lt;/a&gt; as a courtesy to the next person having the same problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c54f24f34f6294fae047991edc9eee543297c8" translate="yes" xml:space="preserve">
          <source>If you have nested entities, or if you let users edit received entities, you should keep them separately in the state as if it was a database. In pagination information, you would only refer to them by their IDs. This lets you always keep them up to date. The &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; shows this approach, together with &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; to normalize the nested API responses. With this approach, your state might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8b6dfa0ebcbb78dc0a91f22c821a3a280371e2" translate="yes" xml:space="preserve">
          <source>If you make a typo when importing an action constant, you will get &lt;code&gt;undefined&lt;/code&gt;. Redux will immediately throw when dispatching such an action, and you'll find the mistake sooner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73befc0dc9f970460cd3aed6b1aca8d76525c521" translate="yes" xml:space="preserve">
          <source>If you use ES5, instead of &lt;code&gt;import * as&lt;/code&gt; syntax you can just pass &lt;code&gt;require('./TodoActionCreators')&lt;/code&gt; to &lt;code&gt;bindActionCreators&lt;/code&gt; as the first argument. The only thing it cares about is that the values of the &lt;code&gt;actionCreators&lt;/code&gt; arguments are functions. The module system doesn't matter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df0e81af972f49797fdb77dbfa3675c8af338b1" translate="yes" xml:space="preserve">
          <source>If you use React, note that you can improve performance of multiple synchronous dispatches by wrapping them in &lt;code&gt;ReactDOM.unstable_batchedUpdates()&lt;/code&gt;, but this API is experimental and may be removed in any React release so don't rely on it too heavily. Take a look at &lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; (a higher-order reducer that lets you dispatch several actions as if it was one and &amp;ldquo;unpack&amp;rdquo; them in the reducer), &lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt; (a store enhancer that lets you debounce subscriber calls for multiple dispatches), or &lt;a href=&quot;https://github.com/manaflair/redux-batch&quot;&gt;redux-batch&lt;/a&gt; (a store enhancer that handles dispatching an array of actions with a single subscriber notification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9271dc344ed7ad99882268b8d2eb8bf8888f3412" translate="yes" xml:space="preserve">
          <source>If you use a library like &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, you might be using &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher-order components&lt;/a&gt; like &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt;. This lets you inject Redux state into a regular React component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd635904f7059bfcd20e75164dcce6a3c6db39b" translate="yes" xml:space="preserve">
          <source>If you use other store enhancers in addition to &lt;code&gt;applyMiddleware&lt;/code&gt;, make sure to put &lt;code&gt;applyMiddleware&lt;/code&gt; before them in the composition chain because the middleware is potentially asynchronous. For example, it should go before &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; because otherwise the DevTools won't see the raw actions emitted by the Promise middleware and such.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b994687ed5da06c8ff7d250360e547dbe6399b8" translate="yes" xml:space="preserve">
          <source>If you use something like &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;, you might also want to express your data fetching dependencies as static &lt;code&gt;fetchData()&lt;/code&gt; methods on your route handler components. They may return &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt;, so that your &lt;code&gt;handleRender&lt;/code&gt; function can match the route to the route handler component classes, dispatch &lt;code&gt;fetchData()&lt;/code&gt; result for each of them, and render only after the Promises have resolved. This way the specific API calls required for different routes are colocated with the route handler component definitions. You can also use the same technique on the client side to prevent the router from switching the page until its data has been loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28ac508cdd88eefae0fc560e0d0772276239bef" translate="yes" xml:space="preserve">
          <source>If you want to conditionally apply a middleware, make sure to only import it when it's needed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e7d35f34c8cafb2605b96694ac400ffa75f61c6" translate="yes" xml:space="preserve">
          <source>If you're already familiar with the basic concepts and have previously completed this tutorial, don't forget to check out &lt;a href=&quot;../advanced/asyncflow&quot;&gt;async flow&lt;/a&gt; in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how middleware transforms &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt; before they reach the reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="816a6eef450003d62c904a3bd887b32f4e650f73" translate="yes" xml:space="preserve">
          <source>If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. &lt;strong&gt;Instead, there is just a single store with a single root &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt;.&lt;/strong&gt; As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. You can use a helper like &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; to combine them. This is similar to how there is just one root component in a React app, but it is composed out of many small components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428736da48a00e318f6b5e97ec36e76a4fb9754a" translate="yes" xml:space="preserve">
          <source>If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. Instead, there is just a single store with a single root reducing function. As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. This is exactly like how there is just one root component in a React app, but it is composed out of many small components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0cc9c7c3b559caffbbd11ca7ac8b9023f058297" translate="yes" xml:space="preserve">
          <source>If you're in doubt, check out the Redux source code (there isn't much going on there), as well as its ecosystem (for example, &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;the developer tools&lt;/a&gt;). If you don't care too much about it and want to go with the reactive data flow all the way, you might want to explore something like &lt;a href=&quot;http://cycle.js.org&quot;&gt;Cycle&lt;/a&gt; instead, or even combine it with Redux. Let us know how it goes!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3ca8f9048bbc67b3c079811024df3868485a73" translate="yes" xml:space="preserve">
          <source>If you're just learning React, you should probably focus on thinking in React first, then look at Redux once you better understand React and how Redux might fit into your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56294c132212d734163e82c754555af03986a8f4" translate="yes" xml:space="preserve">
          <source>If you're new to the NPM ecosystem and have troubles getting a project up and running, or aren't sure where to paste the gist above, check out &lt;a href=&quot;https://github.com/jackielii/simplest-redux-example&quot;&gt;simplest-redux-example&lt;/a&gt; that uses Redux together with React and Browserify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0d749eb693db3084a30e822fa61e81b13144b8" translate="yes" xml:space="preserve">
          <source>If you're not, you can &lt;a href=&quot;https://unpkg.com/redux/&quot;&gt;access these files on unpkg&lt;/a&gt;, download them, or point your package manager to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89793009075a44d386caea025880b6492221229c" translate="yes" xml:space="preserve">
          <source>If you're somewhere deep in the component hierarchy, it is cumbersome to pass the store down manually. This is why &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; lets you use a &lt;code&gt;connect&lt;/code&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher-order component&lt;/a&gt; that will, apart from subscribing you to a Redux store, inject &lt;code&gt;dispatch&lt;/code&gt; into your component's props.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9847b990c2956da3cc4e51d7455ae0fd5c2d3799" translate="yes" xml:space="preserve">
          <source>If you're still not convinced, read &lt;a href=&quot;../introduction/motivation&quot;&gt;Motivation&lt;/a&gt; and &lt;a href=&quot;https://medium.com/@dan_abramov/the-case-for-flux-379b7d1982c6&quot;&gt;The Case for Flux&lt;/a&gt; for a compelling argument in favor of unidirectional data flow. Although &lt;a href=&quot;../introduction/priorart&quot;&gt;Redux is not exactly Flux&lt;/a&gt;, it shares the same key benefits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c63a9398fd378c51f8bf9e677e8aa928203398f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; or similar bindings, you likely won't have direct access to the store instance in your components. For the next few paragraphs, just assume you pass the store down explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cdd0731454ffd1d20cd96f11a3d32664207b62" translate="yes" xml:space="preserve">
          <source>If your Backbone codebase is too big for a quick rewrite or you don't want to manage interactions between store and models, use &lt;a href=&quot;https://github.com/naugtur/backbone-redux-migrator&quot;&gt;backbone-redux-migrator&lt;/a&gt; to help your two codebases coexist while keeping healthy separation. Once your rewrite finishes, Backbone code can be discarded and your Redux application can work on its own once you configure router.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe98ef98166939af239eed6b2d81cd88bea35531" translate="yes" xml:space="preserve">
          <source>If your head boiled from reading the above section, imagine what it was like to write it. This section is meant to be a relaxation for you and me, and will help get your gears turning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a439ce92e30ef4f0c974a7c73870d7c4912681d" translate="yes" xml:space="preserve">
          <source>If your state is a plain object, make sure you never mutate it! For example, instead of returning something like &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; from your reducers, return &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt;. This way you don't override the previous &lt;code&gt;state&lt;/code&gt;. You can also write &lt;code&gt;return { ...state, ...newData }&lt;/code&gt; if you enable the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6373833358e0059931cc766a20497e267d0055c4" translate="yes" xml:space="preserve">
          <source>Imagine your app&amp;rsquo;s state is described as a plain object. For example, the state of a todo app might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d512cb13653145d5f418624490cb11a59c20835" translate="yes" xml:space="preserve">
          <source>Immutability can bring increased performance to your app, and leads to simpler programming and debugging, as data that never changes is easier to reason about than data that is free to be changed arbitrarily throughout your app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7748d3ba70c7e8503005d5183b42db995cf3479a" translate="yes" xml:space="preserve">
          <source>Immutability is what lets &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; efficiently subscribe to fine-grained updates of your state. It also enables great developer experience features such as time travel with &lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5a32a1bd41d5b21404f176ae361427aff05142" translate="yes" xml:space="preserve">
          <source>Immutable</source>
          <target state="translated">Immutable</target>
        </trans-unit>
        <trans-unit id="674da9972545b8a3d30b18b2b631a253089574ce" translate="yes" xml:space="preserve">
          <source>Immutable Data Management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f194c27186d4d976f210a867f1b7493fc5734e87" translate="yes" xml:space="preserve">
          <source>Immutable Data Structures and JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f337e1757211d31f0134ce96582c18a500ad82d" translate="yes" xml:space="preserve">
          <source>Immutable Data from Scratch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69f6aa84f66db9f8ef96ac695cc3f24fae1dc21" translate="yes" xml:space="preserve">
          <source>Immutable Data using ES6 and Beyond</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda456672d3ee4fa81f3ddcd2803e3ee0a8d4c04" translate="yes" xml:space="preserve">
          <source>Immutable Javascript using ES6 and beyond</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973175b7f3b4ff6e4efbc6ead54d53aad1a95619" translate="yes" xml:space="preserve">
          <source>Immutable Object Formatter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8acc5408d603ab59b3c9faed6a7e6bc40e90b10" translate="yes" xml:space="preserve">
          <source>Immutable Update Patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7453da6cbc7da4258fe3287ac0a6c8690fe9793c" translate="yes" xml:space="preserve">
          <source>Immutable Update Patterns for ES6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ff07243fabffc0f9f1077cf8800e362ccb5eaa" translate="yes" xml:space="preserve">
          <source>Immutable Update Utility Libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd90f13857bde1d7e445ee9ceeba04700668e97" translate="yes" xml:space="preserve">
          <source>Immutable and most similar libraries are orthogonal to Redux. Feel free to use them together!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea78c55982bab7f948fd4ba6bc2bd11c80ae37ff" translate="yes" xml:space="preserve">
          <source>Immutable data management ultimately makes data handling safer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e9a327a00ad002de1d25ee12aec93959806cd7" translate="yes" xml:space="preserve">
          <source>Immutable-focused libraries such as Immutable.JS have been designed to overcome the issues with immutability inherent within JavaScript, providing all the benefits of immutability with the performance your app requires.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6fbec38c5ba31d45e4cbd8958dc74112ebd4b2" translate="yes" xml:space="preserve">
          <source>Immutable.JS avoids this by &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;cleverly sharing data structures&lt;/a&gt; under the surface, minimizing the need to copy data. It also enables complex chains of operations to be carried out without creating unnecessary (and costly) cloned intermediate data that will quickly be thrown away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4bca118ae44915dde169b1e2c52c2a3216d820a" translate="yes" xml:space="preserve">
          <source>Immutable.JS can provide significant reliability and performance improvements to your app, but it must be used correctly. If you choose to use Immutable.JS (and remember, you are not required to, and there are other immutable libraries you can use), follow these opinionated best practices, and you&amp;rsquo;ll be able to get the most out of it, without tripping up on any of the issues it can potentially cause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c874460a6804e3b2c27f9b25a6746d6bfb6f9b" translate="yes" xml:space="preserve">
          <source>Immutable.JS does a lot work behind the scenes to optimize performance. This is the key to its power, as using immutable data structures can involve a lot of expensive copying. In particular, immutably manipulating large, complex data sets, such as a nested Redux state tree, can generate many intermediate copies of objects, which consume memory and slow down performance as the browser&amp;rsquo;s garbage collector fights to clean things up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc90700452643c9a9c0e8f4b109806ca1907669" translate="yes" xml:space="preserve">
          <source>Immutable.JS objects, such as &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, etc., can be difficult to debug, as inspecting such an object will reveal an entire nested hierarchy of Immutable.JS-specific properties that you don&amp;rsquo;t care about, while your actual data that you do care about is encapsulated several layers deep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b728994e17e8c21ef4849874d50ee39e9635a6f5" translate="yes" xml:space="preserve">
          <source>Immutable.JS provides a rich set of immutable objects to encapsulate your data (e.g. Maps, Lists, Sets, Records, etc.), and an extensive set of methods to manipulate it, including methods to sort, filter, and group the data, reverse it, flatten it, and create subsets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d99c53713fdd9ecf08a9eeb1a70e8a2964a5cf1" translate="yes" xml:space="preserve">
          <source>Immutable.JS was designed to provide immutability in a performant manner in an effort to overcome the limitations of immutability with JavaScript. Its principle advantages include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b492caa1430f9e67bef5127ef78bb8219dbd86c" translate="yes" xml:space="preserve">
          <source>Immutable.JS works best for collections of data, and the larger the better. It can be slow when your data comprises lots of small, simple JavaScript objects, with each comprising a few keys of primitive values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fed6b895cf747a93a21ea8add3ba23effdc034a" translate="yes" xml:space="preserve">
          <source>Immutable.js - Immutable Collections for JavaScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50598f7dc9386f9779647be8fdfdf65fd92fe212" translate="yes" xml:space="preserve">
          <source>Immutable.js, persistent data structures and structural sharing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7e1350aad385c556192ea311d3f9f4440b4840" translate="yes" xml:space="preserve">
          <source>ImmutableJS: worth the price?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879b24a430b9ab1f4e8c76b4dfa0887fc3c04d07" translate="yes" xml:space="preserve">
          <source>Immutably updating objects and arrays safely</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37f816825de6623c275fae3ddf78ea2ec8ca471" translate="yes" xml:space="preserve">
          <source>Immutably updating state generally means making shallow copies, not deep copies. Shallow copies are much faster than deep copies, because fewer objects and fields have to be copied, and it effectively comes down to moving some pointers around.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6446305b39453eb5282988df8de2320a57875d" translate="yes" xml:space="preserve">
          <source>Implementing Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56aeb896976173293390de95c9507133f3d2e7e4" translate="yes" xml:space="preserve">
          <source>Implementing Container Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43492db8e2cb0ccb4f69d638a38af639d790168e" translate="yes" xml:space="preserve">
          <source>Implementing Other Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c1c997da2a03119d1777770189d8c530547e28" translate="yes" xml:space="preserve">
          <source>Implementing Presentational Components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7e5554c6cc65b0860b475288581cda33e0f76b" translate="yes" xml:space="preserve">
          <source>Implementing Undo History</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="461dfd2a69948b84d92969ac1b9fc39ee72ff9b8" translate="yes" xml:space="preserve">
          <source>Improving React and Redux Perf with Reselect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6ff2f3e12ce6aab10b9bec9cab6d60b64497ea" translate="yes" xml:space="preserve">
          <source>Improving React and Redux Performance with Reselect</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831e8524a43e2feb49c2742ea27fbb2612cd63b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;traditional Flux&lt;/a&gt;, action creators often trigger a dispatch when invoked, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40dceb766db3717cd4f328d563428fe98260c2e5" translate="yes" xml:space="preserve">
          <source>In Depth</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d1fa6c5616fe360b5c666020ecae8fe2e73764" translate="yes" xml:space="preserve">
          <source>In Flux, it is traditionally thought that you would define every action type as a string constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c614b1de37c0649d85e4de6785709030fe57b0ee" translate="yes" xml:space="preserve">
          <source>In Redux action creators simply return an action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d908827ee0f85cbdbc48b6e6b0f4b0ba7e1ede" translate="yes" xml:space="preserve">
          <source>In Redux this is &lt;em&gt;not&lt;/em&gt; the case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb7413db62de4f3ba71879e02b2f0337a6068408" translate="yes" xml:space="preserve">
          <source>In Redux, action creators are functions which return plain objects. When testing action creators we want to test whether the correct action creator was called and also whether the right action was returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0927ace523de150037e069de9e99b9a0427c743" translate="yes" xml:space="preserve">
          <source>In Redux, all the application state is stored as a single object. It's a good idea to think of its shape before writing any code. What's the minimal representation of your app's state as an object?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8579ec417a0f350980bbd379e3d451d4be5f432" translate="yes" xml:space="preserve">
          <source>In Redux, subscriptions are called after the root reducer has returned the new state, so you &lt;em&gt;may&lt;/em&gt; dispatch in the subscription listeners. You are only disallowed to dispatch inside the reducers because they must have no side effects. If you want to cause a side effect in response to an action, the right place to do this is in the potentially async &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025a5c8609578dcf3fbad95a8468e74d10860635" translate="yes" xml:space="preserve">
          <source>In Redux, the accumulated value is the state object, and the values being accumulated are actions. Reducers calculate a new state given the previous state and an action. They must be &lt;em&gt;pure functions&lt;/em&gt;&amp;mdash;functions that return the exact same output for given inputs. They should also be free of side-effects. This is what enables exciting features like hot reloading and time travel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e26ebe19ef325c1ead334671d67cb972dd9b0b" translate="yes" xml:space="preserve">
          <source>In a React app, usually you would wrap &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; so that when the URL changes, &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; will match a branch of its routes, and render their configured components. &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; is used to declaratively map routes to your application's component hierarchy. You would declare in &lt;code&gt;path&lt;/code&gt; the path used in the URL and in &lt;code&gt;component&lt;/code&gt; the single component to be rendered when the route matches the URL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552d20c35b7a19e38fbb041cf812c68e0d31ccf1" translate="yes" xml:space="preserve">
          <source>In a more complex app, you're going to want different entities to reference each other. We suggest that you keep your state as normalized as possible, without any nesting. Keep every entity in an object stored with an ID as a key, and use IDs to reference it from other entities, or lists. Think of the app's state as a database. This approach is described in &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr's&lt;/a&gt; documentation in detail. For example, keeping &lt;code&gt;todosById: { id -&amp;gt; todo }&lt;/code&gt; and &lt;code&gt;todos: array&amp;lt;id&amp;gt;&lt;/code&gt; inside the state would be a better idea in a real app, but we're keeping the example simple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7529398006305ace4f3aedcbda960fbff2edf9" translate="yes" xml:space="preserve">
          <source>In a real app, you'd also want to dispatch an action on request failure. We won't implement error handling in this tutorial, but the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; shows one of the possible approaches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc5515a15d4d57aff8873c1659dd4ea00cfc4cf6" translate="yes" xml:space="preserve">
          <source>In a unit test, you would normally import the &lt;code&gt;App&lt;/code&gt; component like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d7d394023da3e8367ec8a78e584be34cff3bc0" translate="yes" xml:space="preserve">
          <source>In addition to reading the state, container components can dispatch actions. In a similar fashion, you can define a function called &lt;code&gt;mapDispatchToProps()&lt;/code&gt; that receives the &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method and returns callback props that you want to inject into the presentational component. For example, we want the &lt;code&gt;VisibleTodoList&lt;/code&gt; to inject a prop called &lt;code&gt;onTodoClick&lt;/code&gt; into the &lt;code&gt;TodoList&lt;/code&gt; component, and we want &lt;code&gt;onTodoClick&lt;/code&gt; to dispatch a &lt;code&gt;TOGGLE_TODO&lt;/code&gt; action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43300067fd4f93325fe0edeb1855206b18b46712" translate="yes" xml:space="preserve">
          <source>In contrast, immutable libraries such as Immutable.JS can employ sophisticated optimization techniques such as &lt;a href=&quot;http://www.slideshare.net/mohitthatte/a-deep-dive-into-clojures-data-structures-euroclojure-2015&quot;&gt;structural sharing&lt;/a&gt; , which effectively returns a new object that reuses much of the existing object being copied from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ff2a8b0f9d11d36b350ca4a91fa734773c9d7a" translate="yes" xml:space="preserve">
          <source>In fact, benchmarks have shown that more connected components generally leads to better performance than fewer connected components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99060159575d5e17d9887f3b127903e3ce8600c6" translate="yes" xml:space="preserve">
          <source>In general, Redux suggests that code with side effects should be part of the action creation process. While that logic &lt;em&gt;can&lt;/em&gt; be performed inside of a UI component, it generally makes sense to extract that logic into a reusable function so that the same logic can be called from multiple places&amp;mdash;in other words, an action creator function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2c413ba873419804cdd854ba00b2ace6bb914c" translate="yes" xml:space="preserve">
          <source>In general, ask if these actions are related but independent, or should actually be represented as one action. Do what makes sense for your own situation but try to balance the readability of reducers with readability of the action log. For example, an action that includes the whole new state tree would make your reducer a one-liner, but the downside is now you have no history of &lt;em&gt;why&lt;/em&gt; the changes are happening, so debugging gets really difficult. On the other hand, if you emit actions in a loop to keep them granular, it's a sign that you might want to introduce a new action type that is handled in a different way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9ba084eaa1fa2c8e34fad4286a77182f2d2144" translate="yes" xml:space="preserve">
          <source>In general, it looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f22c2593249db901262ae0d0b5a9dc7e8b78af5" translate="yes" xml:space="preserve">
          <source>In general, remember that reducers are just functions&amp;mdash;you can organize them and subdivide them any way you want, and you are encouraged to break them down into smaller, reusable functions (&amp;ldquo;reducer composition&amp;rdquo;). While you do so, you may pass a custom third argument from a parent reducer if a child reducer needs additional data to calculate its next state. You just need to make sure that together they follow the basic rules of reducers: &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;, and update state immutably rather than mutating it directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d63121f6c921270caadcee04ea945bd0333108c2" translate="yes" xml:space="preserve">
          <source>In general, try to find a balance between understandable data flow and areas of responsibility with your components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c2fa7138486d88b5fa18d2475648afe59d02ed" translate="yes" xml:space="preserve">
          <source>In general, use Redux when you have reasonable amounts of data changing over time, you need a single source of truth, and you find that approaches like keeping everything in a top-level React component's state are no longer sufficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c79e3652fe883445e9b3cd96eb5f575b10fb17" translate="yes" xml:space="preserve">
          <source>In order to be able to test the App component itself without having to deal with the decorator, we recommend you to also export the undecorated component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1a7092fe1aea25b944efebbf5658054ed3643a" translate="yes" xml:space="preserve">
          <source>In order to share a selector across multiple &lt;code&gt;VisibleTodoList&lt;/code&gt; components &lt;strong&gt;and&lt;/strong&gt; retain memoization, each instance of the component needs its own private copy of the selector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff57866679ccf8351cc1283dd5651be401dbe088" translate="yes" xml:space="preserve">
          <source>In our example, we take a rudimentary approach to security. When we obtain the parameters from the request, we use &lt;code&gt;parseInt&lt;/code&gt; on the &lt;code&gt;counter&lt;/code&gt; parameter to ensure this value is a number. If we did not do this, you could easily get dangerous data into the rendered HTML by providing a script tag in the request. That might look like this: &lt;code&gt;?counter=&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;doSomethingBad();&amp;lt;/script&amp;gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45d519ec7092557332a21b4f95c7890f59d8c28" translate="yes" xml:space="preserve">
          <source>In particular, immutability in the context of a Web app enables sophisticated change detection techniques to be implemented simply and cheaply, ensuring the computationally expensive process of updating the DOM occurs only when it absolutely has to (a cornerstone of React&amp;rsquo;s performance improvements over other libraries).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea8b1a13105717d19bf6d13ca29baf9d351fc73" translate="yes" xml:space="preserve">
          <source>In some cases, you will need to modify the &lt;code&gt;create&lt;/code&gt; function to use different mock implementations of &lt;code&gt;getState&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a560778ff92a1d751e213c0779836fe6174dc6b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../basics/index&quot;&gt;basics guide&lt;/a&gt;, we built a simple todo application. It was fully synchronous. Every time an action was dispatched, the state was updated immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d35265d513681e328e0eff05e802f8cb476ce9d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../basics/index&quot;&gt;basics walkthrough&lt;/a&gt;, we explored how to structure a simple Redux application. In this walkthrough, we will explore how AJAX and routing fit into the picture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7465b6d942c4e067cd6e80afe069da00300c514" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;mapStateToProps&lt;/code&gt; calls &lt;code&gt;getVisibleTodos&lt;/code&gt; to calculate &lt;code&gt;todos&lt;/code&gt;. This works great, but there is a drawback: &lt;code&gt;todos&lt;/code&gt; is calculated every time the component is updated. If the state tree is large, or the calculation expensive, repeating the calculation on every update may cause performance problems. Reselect can help to avoid these unnecessary recalculations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b79c0e319782fa1b2ce1286be0efeb546c9fb7" translate="yes" xml:space="preserve">
          <source>In the app itself, you would still import it normally:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f755748aa6d0df9f0a90fd85dea6dc752d6246" translate="yes" xml:space="preserve">
          <source>In the end, Redux is just a tool. It's a great tool, and there's some great reasons to use it, but there's also reasons you might not want to use it. Make informed decisions about your tools, and understand the tradeoffs involved in each decision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a5d759ba12e2ce01d8df1300b5865e8a1aceec" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; are input-selectors. They are created as ordinary non-memoized selector functions because they do not transform the data they select. &lt;code&gt;getVisibleTodos&lt;/code&gt; on the other hand is a memoized selector. It takes &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; as input-selectors, and a transform function that calculates the filtered todos list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd7412498e7c4b8984657c38f0316bc34913128" translate="yes" xml:space="preserve">
          <source>In the example below &lt;code&gt;makeMapStateToProps&lt;/code&gt; creates a new &lt;code&gt;getVisibleTodos&lt;/code&gt; selector, and returns a &lt;code&gt;mapStateToProps&lt;/code&gt; function that has exclusive access to the new selector:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02549e5da1d96280abf9f8af834de7e02b0480e3" translate="yes" xml:space="preserve">
          <source>In the example below, if &lt;code&gt;state.todos&lt;/code&gt; and the value returned from &lt;code&gt;getVisibleTodos()&lt;/code&gt; do not change on successive calls to &lt;code&gt;connect&lt;/code&gt;, then the component will not re-render .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ee9c48a9c85ce991273312632d3dd6b926ea53" translate="yes" xml:space="preserve">
          <source>In the first part of this recipe, we will explain the underlying concepts that make Undo and Redo possible to implement in a generic way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2243bc74f11442cdf674f937bd6d1c08c6272ae" translate="yes" xml:space="preserve">
          <source>In the following recipe, we are going to look at how to set up server-side rendering. We'll use the simplistic &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counter app&lt;/a&gt; as a guide and show how the server can render state ahead of time based on the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cd11df4343550d7d4e43af17f049e566352685" translate="yes" xml:space="preserve">
          <source>In the previous sections, we defined the &lt;a href=&quot;actions&quot;&gt;actions&lt;/a&gt; that represent the facts about &amp;ldquo;what happened&amp;rdquo; and the &lt;a href=&quot;reducers&quot;&gt;reducers&lt;/a&gt; that update the state according to those actions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93726cac65849e4d12ae302dc65296290899ed8" translate="yes" xml:space="preserve">
          <source>In the second part of this recipe, we will show how to use &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; package that provides this functionality out of the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa485784e2157411990893a973a8bd333ffb697" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;state&lt;/code&gt; was specified so it didn't fall back to &lt;code&gt;{}&lt;/code&gt;. It was an object with &lt;code&gt;a&lt;/code&gt; field equal to &lt;code&gt;'horse'&lt;/code&gt;, but without the &lt;code&gt;b&lt;/code&gt; field. This is why the &lt;code&gt;a&lt;/code&gt; reducer received &lt;code&gt;'horse'&lt;/code&gt; as its &lt;code&gt;state&lt;/code&gt; and gladly returned it, but the &lt;code&gt;b&lt;/code&gt; reducer received &lt;code&gt;undefined&lt;/code&gt; as its &lt;code&gt;state&lt;/code&gt; and thus returned &lt;em&gt;its idea&lt;/em&gt; of the default &lt;code&gt;state&lt;/code&gt; (in our example, &lt;code&gt;'wat'&lt;/code&gt;). This is how we get &lt;code&gt;{ a: 'horse', b: 'wat' }&lt;/code&gt; in return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f092b4bf36ca89a0195ff54516fa10e82e7e403d" translate="yes" xml:space="preserve">
          <source>In this code, there are two interesting parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ff63357cd40c92d16604f3aa798bf1944dff1e" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;visibilityFilter&lt;/code&gt; are both top-level keys in the state, and each represents a &quot;slice&quot; of data for some particular concept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b5dc7b5ea1bc39335dc8d9e264ade04c2338c5" translate="yes" xml:space="preserve">
          <source>In this example, we store the received items together with the pagination information. However, this approach won't work well if you have nested entities referencing each other, or if you let the user edit items. Imagine the user wants to edit a fetched post, but this post is duplicated in several places in the state tree. This would be really painful to implement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38453f2982934a0e4a9ceb3c56a5bc2171aeeca" translate="yes" xml:space="preserve">
          <source>In this guide, we will build a different, asynchronous application. It will use the Reddit API to show the current headlines for a selected subreddit. How does asynchronicity fit into Redux flow?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6560c487884e558589c10deb770162dd33a72a4b" translate="yes" xml:space="preserve">
          <source>In this guide, we won't normalize entities, but it's something you should consider for a more dynamic application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a84d91992fe1ee4ade8af66d135912f74026aac" translate="yes" xml:space="preserve">
          <source>In this guide, we'll walk through the process of creating a simple Todo app.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3264d98279777fdf4abb2ddc1f6f9425eb13ec" translate="yes" xml:space="preserve">
          <source>In this part of the recipe, you will learn how to make the &lt;a href=&quot;../basics/exampletodolist&quot;&gt;Todo List example&lt;/a&gt; undoable. You can find the full source of this recipe in the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;&lt;code&gt;todos-with-undo&lt;/code&gt; example that comes with Redux&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="de155c1609b33aab2a421d885b10f58302427667" translate="yes" xml:space="preserve">
          <source>Initial Reducer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ff8f213c0a10779a370cddf8f0fc33be27fbc0" translate="yes" xml:space="preserve">
          <source>Initializing State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ff420ada3c0a5605a30920772184b34ab3a629" translate="yes" xml:space="preserve">
          <source>Inject Initial Component HTML and State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d86177949674f0d3d6f94fa38a597fbce828a69" translate="yes" xml:space="preserve">
          <source>Insert the &lt;code&gt;present&lt;/code&gt; at the end of the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcab0294df72cd75ef5a6d54589ea4dce06c352f" translate="yes" xml:space="preserve">
          <source>Insert the old &lt;code&gt;present&lt;/code&gt; state at the &lt;em&gt;beginning&lt;/em&gt; of the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ec847a17c9bdb6126cb0938660b383ecf56d95" translate="yes" xml:space="preserve">
          <source>Insert the old &lt;code&gt;present&lt;/code&gt; state at the &lt;em&gt;end&lt;/em&gt; of the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83e33670ddd1909319192f3e6c17aaca9a84645" translate="yes" xml:space="preserve">
          <source>Inserting and Removing Items in Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0907ce47d7d9097da0f4a803702823b572700f6" translate="yes" xml:space="preserve">
          <source>Install Packages</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3270b4b51ff970f769df9e395c358dbef395d0" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable Object Formatter&lt;/a&gt; , and inspect your Immutable.JS data without seeing the noise of Immutable.JS's own object properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="a2b7d6ff7d322426c52bf0336937cb1f5f83cc7e" translate="yes" xml:space="preserve">
          <source>Installing React Redux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919e9c6771a9e147109378578b2ca429689f31e8" translate="yes" xml:space="preserve">
          <source>Installing React Router</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d01c0e156f524f6033babf6a65fdfe5fbe227c04" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;applyMiddlewareByMonkeypatching()&lt;/code&gt;, we could write &lt;code&gt;applyMiddleware()&lt;/code&gt; that first obtains the final, fully wrapped &lt;code&gt;dispatch()&lt;/code&gt; function, and returns a copy of the store using it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d59912d07b0c1523625f9aa8c4564aa281316e" translate="yes" xml:space="preserve">
          <source>Instead of mutating the state directly, you specify the mutations you want to happen with plain objects called &lt;em&gt;actions&lt;/em&gt;. Then you write a special function called a &lt;em&gt;reducer&lt;/em&gt; to decide how every action transforms the entire application's state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc634e20909b40b70243f5387f4971fcef12462" translate="yes" xml:space="preserve">
          <source>Instead, to actually initiate a dispatch, pass the result to the &lt;code&gt;dispatch()&lt;/code&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b4700d865a6bc3050b6238ea39ea11326ddf5b" translate="yes" xml:space="preserve">
          <source>Integrating Data with React Native</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94ff5f5157ce93e1e54097b202ed106931426a0" translate="yes" xml:space="preserve">
          <source>Internally, it uses &lt;a href=&quot;https://github.com/github/fetch&quot;&gt;&lt;code&gt;whatwg-fetch&lt;/code&gt; polyfill&lt;/a&gt; on the client, and &lt;a href=&quot;https://github.com/bitinn/node-fetch&quot;&gt;&lt;code&gt;node-fetch&lt;/code&gt;&lt;/a&gt; on the server, so you won't need to change API calls if you change your app to be &lt;a href=&quot;https://medium.com/@mjackson/universal-javascript-4761051b7ae9&quot;&gt;universal&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="8a6f1a995da229b02edaf632a5ace565c8ee09ce" translate="yes" xml:space="preserve">
          <source>Introduction to Immutable.js and Functional Programming Concepts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b5b8bcb22926ae89618f485d25977d251671eb" translate="yes" xml:space="preserve">
          <source>Introduction: Examples</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4209082024c9cd9683fea7a0702e849132c096c7" translate="yes" xml:space="preserve">
          <source>Introduction: Motivation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7833c7c1e348dea95d2da014ccfe35f763549815" translate="yes" xml:space="preserve">
          <source>Invoke callbacks from props</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b224be093f507de08ead59d030ff9b7f95ab8d1" translate="yes" xml:space="preserve">
          <source>Is Immutable.JS worth the effort?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da302071395dfdf468568428a985f282b79b0804" translate="yes" xml:space="preserve">
          <source>Is Using Immutable.JS worth the effort?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b995ff411e93b919b4cdc03f6d0002c9968e7f" translate="yes" xml:space="preserve">
          <source>Is it OK to have more than one middleware chain in my store enhancer? What is the difference between &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt; in a middleware function?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a28ea665464bd96297075646b171f933e455eb" translate="yes" xml:space="preserve">
          <source>Is it OK to have more than one middleware chain in my store enhancer? What is the difference between next and dispatch in a middleware function?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9383cd73080d3bf5501f85e4702d23a4e04ad13" translate="yes" xml:space="preserve">
          <source>Is the same data being used to drive multiple components?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4741570a3bb3f7779f15075dab9fd931487a3a" translate="yes" xml:space="preserve">
          <source>Is there a way to make it easier to comprehend? It seems like &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;visibilityFilter&lt;/code&gt; are updated completely independently. Sometimes state fields depend on one another and more consideration is required, but in our case we can easily split updating &lt;code&gt;todos&lt;/code&gt; into a separate function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e83fd15d92fbc9418b683c0d9790a7c6248751" translate="yes" xml:space="preserve">
          <source>Is there always a one-to-one mapping between reducers and actions?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84984bdef5380f48f6df27ee47064798ca74e062" translate="yes" xml:space="preserve">
          <source>Is there anything left to undo or redo?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f289628c32a4808458fe68440054d194866e8e5c" translate="yes" xml:space="preserve">
          <source>Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4cec2a5adc22a33671afe8c2442bda5e76ae5a" translate="yes" xml:space="preserve">
          <source>Isolating Redux Sub-Apps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce286d263926cfdb1859da7cb4876ed9e5c9ba84" translate="yes" xml:space="preserve">
          <source>Isolating Subapps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03cd03c1cbbbb49e2d53831a74d4f4cbf478570" translate="yes" xml:space="preserve">
          <source>Isolating a Redux app as a component in a bigger application, in which case you might want to create a store per root component instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e2da235921f2dc98b67a3405af6d4d8b66644a3" translate="yes" xml:space="preserve">
          <source>It detects a change by keeping a reference to the root state object, and a reference to &lt;em&gt;each value&lt;/em&gt; in the props object that's returned from the &lt;code&gt;mapStateToProps&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0678b386548901ffe5796fba691a7dd7a055517b" translate="yes" xml:space="preserve">
          <source>It does a bit of trickery to make sure that if you call &lt;code&gt;store.dispatch(action)&lt;/code&gt; from your middleware instead of &lt;code&gt;next(action)&lt;/code&gt;, the action will actually travel the whole middleware chain again, including the current middleware. This is useful for asynchronous middleware, as we have seen &lt;a href=&quot;asyncactions&quot;&gt;previously&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c838975ff8bc1485249cfc27d4ffd7a7c7eba961" translate="yes" xml:space="preserve">
          <source>It does not require a build system or a view framework and exists to show the raw Redux API used with ES5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72186694410e16c516c9d596656e81807bdc0ee2" translate="yes" xml:space="preserve">
          <source>It does so because the props object is actually a hash of prop names and their values (or selector functions that are used to retrieve or generate the values), such as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd40f9379225350f73c28d7d8b350321206fccb5" translate="yes" xml:space="preserve">
          <source>It does this by performing a shallow equality check on each value within the object individually, and will only trigger a re-render if one of those checks fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc8c262fccc1fd13b37e15839544d8f0e42b7f17" translate="yes" xml:space="preserve">
          <source>It doesn't work because your action creator is just a function that &lt;em&gt;returns&lt;/em&gt; an action. It is up to you to actually dispatch it. We can't bind your action creators to a particular Store instance during the definition because apps that render on the server need a separate Redux store for every request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50bdebff8f75748e8eb5b1028b6f9e739d1e11eb" translate="yes" xml:space="preserve">
          <source>It helps keep the naming consistent because all action types are gathered in a single place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e39e70b7c42af694874a6eb695630593111193" translate="yes" xml:space="preserve">
          <source>It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;live code editing combined with a time traveling debugger&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94502169236559f86f242ead05d16d88d3912a58" translate="yes" xml:space="preserve">
          <source>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c76ff225751e91aabc5dfc794a50b75a44444c" translate="yes" xml:space="preserve">
          <source>It is a low-level API. Most likely, instead of using it directly, you'll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to &lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;write a custom &lt;code&gt;observeStore&lt;/code&gt; utility&lt;/a&gt;. The &lt;code&gt;Store&lt;/code&gt; is also an &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, so you can &lt;code&gt;subscribe&lt;/code&gt; to changes with libraries like &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b86f7926b42042d8d9540bde7f55a9d1fbef0e9" translate="yes" xml:space="preserve">
          <source>It is also possible to do the reverse and migrate from Redux to any of these libraries following the same steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f367ba512c5331d9b1a4dc415838a8c2dbcc6d80" translate="yes" xml:space="preserve">
          <source>It is also up to us whether to keep a single top-level history:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837f9f9a88a29e4f25a6eaa8ea75e703183100af" translate="yes" xml:space="preserve">
          <source>It is an advanced API. You might need this if your app implements code splitting, and you want to load some of the reducers dynamically. You might also need this if you implement a hot reloading mechanism for Redux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79971d102866cc7813eb74dfec64bdc730b286c2" translate="yes" xml:space="preserve">
          <source>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249542e851b7d943285bfc44e6d5f0e85e9977ed" translate="yes" xml:space="preserve">
          <source>It is equal to the last value returned by the store's reducer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312b7c808648f4df7cabafd144e579400360a08e" translate="yes" xml:space="preserve">
          <source>It is essential to chaining middleware!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda50451faae254a9269dbf26176ea6006fc9b9e" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you only put plain serializable objects, arrays, and primitives into your store. It's &lt;em&gt;technically&lt;/em&gt; possible to insert non-serializable items into the store, but doing so can break the ability to persist and rehydrate the contents of a store, as well as interfere with time-travel debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d99f22665bd7c5155d03f21570bcb486fa6b3cf" translate="yes" xml:space="preserve">
          <source>It is important for it to be separate from &lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; or &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt;. While they may occur one after another, as the app grows more complex, you might want to fetch some data independently of the user action (for example, to prefetch the most popular subreddits, or to refresh stale data once in a while). You may also want to fetch in response to a route change, so it's not wise to couple fetching to some particular UI event early on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e208a1f7d32f64abf692053d9b4ade71eacca6" translate="yes" xml:space="preserve">
          <source>It is reasonable to suggest that our state shape should change to answer these questions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2826728cd3002c85132f865368ccf2dfda1f035c" translate="yes" xml:space="preserve">
          <source>It is tempting to modify the &lt;code&gt;state&lt;/code&gt; or &lt;code&gt;action&lt;/code&gt; passed to you by Redux. Don't do this!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e2ea8d61178d3cf1c5299a500dca66ebcdf724" translate="yes" xml:space="preserve">
          <source>It is tiny (2kB, including dependencies).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c823da484f24ab1a299266700f4f493b22a5d4" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05093663f45944f4c69e8ddf69de181df8a06f66" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the state format. You can use plain objects or something like &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;. If you're not sure, start with plain objects.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
