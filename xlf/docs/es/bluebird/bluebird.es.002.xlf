<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="bluebird">
    <body>
      <group id="bluebird">
        <trans-unit id="d5b43ccfa15a68ea76732113925885a846a983e2" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and &lt;a href=&quot;http://en.wikipedia.org/wiki/Map_(higher-order_function)&quot;&gt;map the array to another&lt;/a&gt; using the given &lt;code&gt;mapper&lt;/code&gt; function.</source>
          <target state="translated">Dado un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt; (las matrices son &lt;code&gt;Iterable&lt;/code&gt; ), o una promesa de un &lt;code&gt;Iterable&lt;/code&gt; , que produce promesas (o una combinaci&amp;oacute;n de promesas y valores), repita todos los valores de &lt;code&gt;Iterable&lt;/code&gt; en una matriz y &lt;a href=&quot;http://en.wikipedia.org/wiki/Map_(higher-order_function)&quot;&gt;asigne la matriz a otra&lt;/a&gt; usando el &lt;code&gt;mapper&lt;/code&gt; dado funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5e99be03578b916bd80ede8ae2a2062901092637" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and iterate over the array serially, in-order.</source>
          <target state="translated">Dado un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt; (las matrices son &lt;code&gt;Iterable&lt;/code&gt; ), o una promesa de un &lt;code&gt;Iterable&lt;/code&gt; , que produce promesas (o una combinaci&amp;oacute;n de promesas y valores), repita todos los valores en &lt;code&gt;Iterable&lt;/code&gt; en una matriz e itere sobre la matriz en serie, en orden .</target>
        </trans-unit>
        <trans-unit id="1f8e9d0b39417bd51e7781fa7d8ff0682741fabe" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and return a promise that is fulfilled as soon as &lt;code&gt;count&lt;/code&gt; promises are fulfilled in the array. The fulfillment value is an array with &lt;code&gt;count&lt;/code&gt; values in the order they were fulfilled.</source>
          <target state="translated">Dado un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt; (las matrices son &lt;code&gt;Iterable&lt;/code&gt; ), o una promesa de un &lt;code&gt;Iterable&lt;/code&gt; , que produce promesas (o una combinaci&amp;oacute;n de promesas y valores), repita todos los valores en &lt;code&gt;Iterable&lt;/code&gt; en una matriz y devuelva una promesa que se cumple tan pronto como sea posible. &lt;code&gt;count&lt;/code&gt; promesas de conteo se cumplen en la matriz. El valor de cumplimiento es una matriz con valores de &lt;code&gt;count&lt;/code&gt; en el orden en que se cumplieron.</target>
        </trans-unit>
        <trans-unit id="857f3458334e4f2213e0a21ea4b51230697211bb" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and return a promise that is fulfilled or rejected as soon as a promise in the array is fulfilled or rejected with the respective rejection reason or fulfillment value.</source>
          <target state="translated">Dado un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt; (las matrices son &lt;code&gt;Iterable&lt;/code&gt; ), o una promesa de un &lt;code&gt;Iterable&lt;/code&gt; , que produce promesas (o una combinaci&amp;oacute;n de promesas y valores), repita todos los valores en &lt;code&gt;Iterable&lt;/code&gt; en una matriz y devuelva una promesa que se cumple o rechaza como tan pronto como se cumpla o rechace una promesa en la matriz con el motivo de rechazo respectivo o el valor de cumplimiento.</target>
        </trans-unit>
        <trans-unit id="69cab8471b98016cf118f04639071683711e51b8" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;&lt;code&gt;Iterable&lt;/code&gt;&lt;/a&gt;(arrays are &lt;code&gt;Iterable&lt;/code&gt;), or a promise of an &lt;code&gt;Iterable&lt;/code&gt;, which produces promises (or a mix of promises and values), iterate over all the values in the &lt;code&gt;Iterable&lt;/code&gt; into an array and return a promise that is fulfilled when all the items in the array are fulfilled. The promise's fulfillment value is an array with fulfillment values at respective positions to the original array. If any promise in the array rejects, the returned promise is rejected with the rejection reason.</source>
          <target state="translated">Dado un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt; &lt;code&gt;Iterable&lt;/code&gt; &lt;/a&gt; (las matrices son &lt;code&gt;Iterable&lt;/code&gt; ), o una promesa de un &lt;code&gt;Iterable&lt;/code&gt; , que produce promesas (o una combinaci&amp;oacute;n de promesas y valores), repita todos los valores en &lt;code&gt;Iterable&lt;/code&gt; en una matriz y devuelva una promesa que se cumple cuando todos Se cumplen los elementos de la matriz. El valor de cumplimiento de la promesa es una matriz con valores de cumplimiento en las posiciones respectivas de la matriz original. Si alguna promesa en la matriz rechaza, la promesa devuelta se rechaza con el motivo de rechazo.</target>
        </trans-unit>
        <trans-unit id="ba72cdcdd80c07ac4fdce4644a5bd2dcebb0c4dd" translate="yes" xml:space="preserve">
          <source>Gives</source>
          <target state="translated">Gives</target>
        </trans-unit>
        <trans-unit id="dd8ed7e2a547ceb0fcc1dd88e8912c6fe49d6651" translate="yes" xml:space="preserve">
          <source>Global rejection events</source>
          <target state="translated">Eventos de rechazo global</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="eecad68c8e79b4757501bd51103a0fe41d4c17f1" translate="yes" xml:space="preserve">
          <source>Happy coding, &lt;a href=&quot;https://github.com/sukima&quot;&gt;@sukima&lt;/a&gt;.</source>
          <target state="translated">Feliz codificaci&amp;oacute;n, &lt;a href=&quot;https://github.com/sukima&quot;&gt;@sukima&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="8886c5567b21fd2984bb26867070a05a64fb4320" translate="yes" xml:space="preserve">
          <source>Here is a simple example (where &lt;code&gt;getConnection()&lt;/code&gt; has been defined to return a proper Disposer object)</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo simple (donde &lt;code&gt;getConnection()&lt;/code&gt; se ha definido para devolver un objeto Disposer adecuado)</target>
        </trans-unit>
        <trans-unit id="26f58fc7b427a0eccff2284be30066c7abd9204c" translate="yes" xml:space="preserve">
          <source>Here is another example with an API that lets us know when a connection is ready. The attempt here is imperfect and we'll describe why soon:</source>
          <target state="translated">Aquí hay otro ejemplo con una API que nos permite saber cuando una conexión está lista.El intento aquí es imperfecto y pronto describiremos por qué:</target>
        </trans-unit>
        <trans-unit id="e65979c6ef8becc2e43f319defd5989fed1be73a" translate="yes" xml:space="preserve">
          <source>Here is another example with an API that lets us know when when a connection is ready. The attempt here is imperfect and we'll describe why soon:</source>
          <target state="translated">Aquí hay otro ejemplo con una API que nos permite saber cuando una conexión está lista.El intento aquí es imperfecto y pronto describiremos por qué:</target>
        </trans-unit>
        <trans-unit id="4ba16b105db298af09af0af0a8b19da53c43e1d3" translate="yes" xml:space="preserve">
          <source>Here is how to create a disposer for the MySQL driver:</source>
          <target state="translated">Aquí está cómo crear un eliminador para el controlador de MySQL:</target>
        </trans-unit>
        <trans-unit id="74bcba50f0bf4efbc2a611c31d423e7be3cb7101" translate="yes" xml:space="preserve">
          <source>Here is how to create a disposer for the PostgreSQL driver:</source>
          <target state="translated">Aquí está cómo crear un eliminador para el controlador PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="27bacef699ed8cc8da7b95cbf6d769cd8c4fda27" translate="yes" xml:space="preserve">
          <source>Here is some example HTML for the Progress Dialog:</source>
          <target state="translated">Aquí hay un ejemplo de HTML para el Diálogo de Progreso:</target>
        </trans-unit>
        <trans-unit id="7718e6b52e055c2b6bb02d338b08d91075171e40" translate="yes" xml:space="preserve">
          <source>Here's an example of &lt;code&gt;fs.readFile&lt;/code&gt; with or without promises:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo de &lt;code&gt;fs.readFile&lt;/code&gt; con o sin promesas:</target>
        </trans-unit>
        <trans-unit id="be1eea5cafc8d8f3342d7b87a0e1c5e1c6e75fa0" translate="yes" xml:space="preserve">
          <source>However because it is possible to handle a rejected promise at any time in the indeterminate future, some programming patterns will result in false positives. Because such programming patterns are not necessary and can always be refactored to never cause false positives, we recommend doing that to keep debugging as easy as possible . You may however feel differently so bluebird provides hooks to implement more complex failure policies.</source>
          <target state="translated">Sin embargo,debido a que es posible manejar una promesa rechazada en cualquier momento en un futuro indeterminado,algunos patrones de programación resultarán en falsos positivos.Debido a que tales patrones de programación no son necesarios y siempre pueden ser refactorizados para no causar nunca falsos positivos,recomendamos hacerlo para mantener la depuración lo más fácil posible.Sin embargo,usted puede sentir de manera diferente,por lo que Bluebird proporciona ganchos para implementar políticas de fallo más complejas.</target>
        </trans-unit>
        <trans-unit id="13c4ea634e9c241cc16a70243b1aa4d2e0af9262" translate="yes" xml:space="preserve">
          <source>However if you want stack traces and cleaner string output, then you should do:</source>
          <target state="translated">Sin embargo,si quieres rastros de la pila y una salida más limpia de la cadena,entonces deberías hacerlo:</target>
        </trans-unit>
        <trans-unit id="43fb3aa6954ef56f7c44e1242c17a1fae9ea1ce7" translate="yes" xml:space="preserve">
          <source>However, a bluebird promise is more powerful than the current implementation of &lt;code&gt;std::future&lt;/code&gt; since while chaining has been discussed it is not yet implemented. Promises can be chained together.</source>
          <target state="translated">Sin embargo, una promesa de bluebird es m&amp;aacute;s poderosa que la implementaci&amp;oacute;n actual de &lt;code&gt;std::future&lt;/code&gt; ya que mientras se ha discutido el encadenamiento a&amp;uacute;n no se ha implementado. Las promesas se pueden encadenar juntas.</target>
        </trans-unit>
        <trans-unit id="3ead241876e467071326c285d4a421554cfb1153" translate="yes" xml:space="preserve">
          <source>However, if the second &lt;code&gt;getConnection&lt;/code&gt; throws &lt;strong&gt;synchronously&lt;/strong&gt;, the first connection is leaked. This will not happen when using APIs through bluebird promisified methods though. You can wrap functions that could throw in &lt;a href=&quot;promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt; which will turn synchronous rejections into rejected promises.</source>
          <target state="translated">Sin embargo, si el segundo &lt;code&gt;getConnection&lt;/code&gt; se lanza &lt;strong&gt;sincr&amp;oacute;nicamente&lt;/strong&gt; , la primera conexi&amp;oacute;n se pierde. Sin embargo, esto no suceder&amp;aacute; cuando se utilicen API a trav&amp;eacute;s de m&amp;eacute;todos promovidos por bluebird. Puede ajustar funciones que podr&amp;iacute;an &lt;a href=&quot;promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt; que convertir&amp;aacute; los rechazos sincr&amp;oacute;nicos en promesas rechazadas.</target>
        </trans-unit>
        <trans-unit id="c6545029e669f49f67f406d14c0ceb316e3ab45f" translate="yes" xml:space="preserve">
          <source>However, if you are utilizing the full bluebird API offering, you will &lt;em&gt;almost never&lt;/em&gt; need to resort to nesting promises in the first place. The above should be written more like:</source>
          <target state="translated">Sin embargo, si est&amp;aacute; utilizando la oferta completa de API de bluebird, &lt;em&gt;casi nunca&lt;/em&gt; tendr&amp;aacute; que recurrir a las promesas de anidaci&amp;oacute;n en primer lugar. Lo anterior deber&amp;iacute;a escribirse m&amp;aacute;s como:</target>
        </trans-unit>
        <trans-unit id="0e98b78455e3426551238440ba2fef34bfa9f53b" translate="yes" xml:space="preserve">
          <source>However, there are many differences when you look closer:</source>
          <target state="translated">Sin embargo,hay muchas diferencias cuando se mira más de cerca:</target>
        </trans-unit>
        <trans-unit id="0cae8b925e624929841b55477c73030393e870ed" translate="yes" xml:space="preserve">
          <source>I hope this helps illustrate some concepts available with Promises and a different perspective on how promises can represent more then just AJAX data.</source>
          <target state="translated">Espero que esto ayude a ilustrar algunos conceptos disponibles con Promesas y una perspectiva diferente de cómo las promesas pueden representar más que sólo datos AJAX.</target>
        </trans-unit>
        <trans-unit id="6de1ea5d0581cc815a017782a4875ebd7b42beb9" translate="yes" xml:space="preserve">
          <source>IE7 and IE8 do not support using keywords as property names, so if supporting these browsers is required you need to use the compatibility aliases:</source>
          <target state="translated">IE7 e IE8 no son compatibles con el uso de palabras clave como nombres de propiedades,por lo que si se requiere la compatibilidad con estos navegadores es necesario utilizar los alias de compatibilidad:</target>
        </trans-unit>
        <trans-unit id="5a58805bb7bfd807b86a57ffc79cb53fbd8d908e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index&lt;/code&gt; is negative, the indexed load will become &lt;code&gt;obj.length + index&lt;/code&gt;. So that -1 can be used to read last item in the array, -2 to read the second last and so on. For example:</source>
          <target state="translated">Si el &lt;code&gt;index&lt;/code&gt; es negativo, la carga indexada se convertir&amp;aacute; en &lt;code&gt;obj.length + index&lt;/code&gt; . Para que -1 se pueda usar para leer el &amp;uacute;ltimo elemento de la matriz, -2 para leer el &amp;uacute;ltimo &amp;uacute;ltimo y as&amp;iacute; sucesivamente. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="48754e7d553962c152a84287f9d6e3171c36cf69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;object&lt;/code&gt; is a trusted &lt;code&gt;Promise&lt;/code&gt;, then it will be treated as a promise for object rather than for its properties. All other objects (except &lt;code&gt;Map&lt;/code&gt;s) are treated for their properties as is returned by &lt;code&gt;Object.keys&lt;/code&gt; - the object's own enumerable properties.</source>
          <target state="translated">Si el &lt;code&gt;object&lt;/code&gt; es una &lt;code&gt;Promise&lt;/code&gt; confianza , se tratar&amp;aacute; como una promesa para el objeto en lugar de sus propiedades. Todos los dem&amp;aacute;s objetos (excepto &lt;code&gt;Map&lt;/code&gt; s) se tratan por sus propiedades tal como lo devuelven &lt;code&gt;Object.keys&lt;/code&gt; , las propias propiedades enumerables del objeto.</target>
        </trans-unit>
        <trans-unit id="5e792131e2122a704cd149f5cb06c842a0d1f08e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;thisArg&lt;/code&gt; is a promise or thenable, its resolution will be awaited for and the bound value will be the promise's fulfillment value. If &lt;code&gt;thisArg&lt;/code&gt; rejects then the returned promise is rejected with the &lt;code&gt;thisArg's&lt;/code&gt; rejection reason. Note that this means you cannot use &lt;code&gt;this&lt;/code&gt; without checking inside catch handlers for promises that bind to promise because in case of rejection of &lt;code&gt;thisArg&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;thisArg&lt;/code&gt; es una promesa o una promesa, se esperar&amp;aacute; su resoluci&amp;oacute;n y el valor consolidado ser&amp;aacute; el valor de cumplimiento de la promesa. Si &lt;code&gt;thisArg&lt;/code&gt; rechaza, la promesa devuelta se rechaza con el &lt;code&gt;thisArg's&lt;/code&gt; rechazo de thisArg . Tenga en cuenta que esto significa que no puede usar &lt;code&gt;this&lt;/code&gt; sin verificar dentro de los controladores de captura las promesas que se comprometen a prometer porque en caso de rechazo de &lt;code&gt;thisArg&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; ser&amp;aacute; &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17736fb74e4b535caabcc3cb12766cd80da44a84" translate="yes" xml:space="preserve">
          <source>If a bound promise is returned by the callback to &lt;a href=&quot;api/promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/promise.try&quot;&gt;&lt;code&gt;Promise.try&lt;/code&gt;&lt;/a&gt;, the returned promise will be bound to the same value</source>
          <target state="translated">Si la devoluci&amp;oacute;n de llamada devuelve una promesa vinculada a &lt;a href=&quot;api/promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;api/promise.try&quot;&gt; &lt;code&gt;Promise.try&lt;/code&gt; &lt;/a&gt; , la promesa devuelta estar&amp;aacute; vinculada al mismo valor</target>
        </trans-unit>
        <trans-unit id="ef5dc1064fadc46c525a97dba4427bc7dea4bdd5" translate="yes" xml:space="preserve">
          <source>If a disposer method throws or returns a rejected promise, it's highly likely that it failed to dispose of the resource. In that case, Bluebird has two options - it can either ignore the error and continue with program execution or throw an exception (crashing the process in node.js).</source>
          <target state="translated">Si un método de eliminación arroja o devuelve una promesa rechazada,es muy probable que no haya podido deshacerse del recurso.En ese caso,Bluebird tiene dos opciones:puede ignorar el error y continuar con la ejecución del programa o lanzar una excepción (bloqueando el proceso en node.js).</target>
        </trans-unit>
        <trans-unit id="043349c3f8c506768b7d9272ca348300465fc593" translate="yes" xml:space="preserve">
          <source>If a method name already has an &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix, an exception will be thrown.</source>
          <target state="translated">Si el nombre de un m&amp;eacute;todo ya tiene un sufijo &lt;code&gt;&quot;Async&quot;&lt;/code&gt; , se lanzar&amp;aacute; una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ea797b951ef4dd11b65a893a9dcb482b48c90fe6" translate="yes" xml:space="preserve">
          <source>If a method name already has an &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix, it will be duplicated. E.g. &lt;code&gt;getAsync&lt;/code&gt;'s promisified name is &lt;code&gt;getAsyncAsync&lt;/code&gt;.</source>
          <target state="translated">Si el nombre de un m&amp;eacute;todo ya tiene un sufijo &lt;code&gt;&quot;Async&quot;&lt;/code&gt; , se duplicar&amp;aacute;. Por &lt;code&gt;getAsync&lt;/code&gt; , el nombre &lt;code&gt;getAsyncAsync&lt;/code&gt; es getAsyncAsync .</target>
        </trans-unit>
        <trans-unit id="00ca6822bc67d26b0bb8b67bfe840b57c60568ab" translate="yes" xml:space="preserve">
          <source>If a module has multiple argument callbacks as an exception rather than the rule, you can filter out the multiple argument methods in first go and then promisify rest of the module in second go:</source>
          <target state="translated">Si un módulo tiene múltiples llamadas de argumento como excepción en lugar de la regla,puede filtrar los múltiples métodos de argumento en la primera pasada y luego prometer el resto del módulo en la segunda pasada:</target>
        </trans-unit>
        <trans-unit id="39d2831120e0fc914a1f915ed431ccee51054c24" translate="yes" xml:space="preserve">
          <source>If all iterations resolve successfully, the &lt;code&gt;Promise.each&lt;/code&gt; call resolves to a new array containing the resolved values of the original input elements.</source>
          <target state="translated">Si todas las iteraciones se resuelven correctamente, la llamada a &lt;code&gt;Promise.each&lt;/code&gt; se resuelve en una nueva matriz que contiene los valores resueltos de los elementos de entrada originales.</target>
        </trans-unit>
        <trans-unit id="129cbea3a99c2245487d23413194e397b8dee441" translate="yes" xml:space="preserve">
          <source>If all iterations resolve successfully, the &lt;code&gt;Promise.mapSeries&lt;/code&gt; call resolves to a new array containing the results of each &lt;code&gt;mapper&lt;/code&gt; execution, in order.</source>
          <target state="translated">Si todas las iteraciones se resuelven correctamente, la llamada &lt;code&gt;Promise.mapSeries&lt;/code&gt; se resuelve en una nueva matriz que contiene los resultados de cada ejecuci&amp;oacute;n del &lt;code&gt;mapper&lt;/code&gt; , en orden.</target>
        </trans-unit>
        <trans-unit id="72964c7b91aee68d8763c1b1f6924364f8c00e31" translate="yes" xml:space="preserve">
          <source>If any promise in the input array is rejected or any promise returned by the iterator function is rejected, the result will be rejected as well.</source>
          <target state="translated">Si se rechaza cualquier promesa de la matriz de entrada o cualquier promesa devuelta por la función de iterador,el resultado también será rechazado.</target>
        </trans-unit>
        <trans-unit id="962010428071535fe6f8370fa09691795307bc72" translate="yes" xml:space="preserve">
          <source>If destructuring parameters are supported, &lt;code&gt;.spread(function(arg1, arg2) {})&lt;/code&gt; can be replaced with &lt;code&gt;.then(function([arg1, arg2]){})&lt;/code&gt;.</source>
          <target state="translated">Si se admiten par&amp;aacute;metros de desestructuraci&amp;oacute;n, &lt;code&gt;.spread(function(arg1, arg2) {})&lt;/code&gt; se puede reemplazar con &lt;code&gt;.then(function([arg1, arg2]){})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9bcd1a977e9bc00ed376c144fd15da6e11e726d" translate="yes" xml:space="preserve">
          <source>If fetching tweets fails before the document is ready the rejection is reported as unhandled even though it will be eventually handled when the document is ready. This is of course impossible to determine automatically, but you can explicitly do so using &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt;:</source>
          <target state="translated">Si la b&amp;uacute;squeda de tweets falla antes de que el documento est&amp;eacute; listo, el rechazo se informa como no manejado, aunque finalmente se manejar&amp;aacute; cuando el documento est&amp;eacute; listo. Por supuesto, esto es imposible de determinar autom&amp;aacute;ticamente, pero puede hacerlo expl&amp;iacute;citamente usando &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d135771ca2084fbac51f59a830fdefe27d1f73a3" translate="yes" xml:space="preserve">
          <source>If not there already, an additional wrapper function is required to undefined leaking or sharing &lt;code&gt;scope&lt;/code&gt;</source>
          <target state="translated">Si a&amp;uacute;n no existe, se requiere una funci&amp;oacute;n de contenedor adicional para filtrar o compartir el &lt;code&gt;scope&lt;/code&gt; indefinido</target>
        </trans-unit>
        <trans-unit id="2702634b1adf7d64f121049f0317c538e848c615" translate="yes" xml:space="preserve">
          <source>If that ES6 import &lt;a href=&quot;https://github.com/petkaantonov/bluebird/pull/1594&quot;&gt;doesn't work&lt;/a&gt;</source>
          <target state="translated">Si esa importaci&amp;oacute;n de ES6 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/pull/1594&quot;&gt;no funciona&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd08bf528d1b25718f075d1d36c59b224befab3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;index&lt;/code&gt; is still negative after &lt;code&gt;obj.length + index&lt;/code&gt;, it will be clamped to 0.</source>
          <target state="translated">Si el &lt;code&gt;index&lt;/code&gt; sigue siendo negativo despu&amp;eacute;s de &lt;code&gt;obj.length + index&lt;/code&gt; , se fijar&amp;aacute; a 0.</target>
        </trans-unit>
        <trans-unit id="a9c21a6c272866c083275685b7da39922c4ca853" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nodeFunction&lt;/code&gt; calls its callback with multiple success values, the fulfillment value will be the first fulfillment item.</source>
          <target state="translated">Si &lt;code&gt;nodeFunction&lt;/code&gt; llama a su devoluci&amp;oacute;n de llamada con m&amp;uacute;ltiples valores de &amp;eacute;xito, el valor de cumplimiento ser&amp;aacute; el primer elemento de cumplimiento.</target>
        </trans-unit>
        <trans-unit id="f04284cbd4e7048ff2d892690b33de55e02378db" translate="yes" xml:space="preserve">
          <source>If the fade out completes successfully, the returned promise will be fulfilled or rejected with the value from &lt;code&gt;xhr&lt;/code&gt;. If &lt;code&gt;.fadeOut&lt;/code&gt; throws an exception or passes an error to the callback, the returned promise will be rejected with the error from &lt;code&gt;.fadeOut&lt;/code&gt;.</source>
          <target state="translated">Si el desvanecimiento se completa con &amp;eacute;xito, la promesa devuelta se cumplir&amp;aacute; o rechazar&amp;aacute; con el valor de &lt;code&gt;xhr&lt;/code&gt; . Si &lt;code&gt;.fadeOut&lt;/code&gt; arroja una excepci&amp;oacute;n o pasa un error a la devoluci&amp;oacute;n de llamada, la promesa devuelta ser&amp;aacute; rechazada con el error de &lt;code&gt;.fadeOut&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="361168b0ad7608978a2fce0c19d538f5024c4a7e" translate="yes" xml:space="preserve">
          <source>If the handler function passed to &lt;code&gt;.finally&lt;/code&gt; returns a promise, the promise returned by &lt;code&gt;.finally&lt;/code&gt; will not be settled until the promise returned by the handler is settled. If the handler fulfills its promise, the returned promise will be fulfilled or rejected with the original value. If the handler rejects its promise, the returned promise will be rejected with the handler's value. This is similar to throwing an exception in a synchronous &lt;code&gt;finally&lt;/code&gt; block, causing the original value or exception to be forgotten. This delay can be useful if the actions performed by the handler are done asynchronously. For example:</source>
          <target state="translated">Si la funci&amp;oacute;n de controlador pasada a &lt;code&gt;.finally&lt;/code&gt; devuelve una promesa, la promesa devuelta por &lt;code&gt;.finally&lt;/code&gt; no se liquidar&amp;aacute; hasta que se resuelva la promesa devuelta por el controlador. Si el controlador cumple su promesa, la promesa devuelta se cumplir&amp;aacute; o rechazar&amp;aacute; con el valor original. Si el manejador rechaza su promesa, la promesa devuelta ser&amp;aacute; rechazada con el valor del manejador. Esto es similar a lanzar una excepci&amp;oacute;n en un bloque &lt;code&gt;finally&lt;/code&gt; sincr&amp;oacute;nico , haciendo que se olvide el valor original o la excepci&amp;oacute;n. Este retraso puede ser &amp;uacute;til si las acciones realizadas por el controlador se realizan de forma asincr&amp;oacute;nica. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="01c2d4f954ef5c2b127397874ff03e84be89fce3" translate="yes" xml:space="preserve">
          <source>If the reducer function returns a promise, then the result of the promise is awaited, before continuing with next iteration. If any promise in the array is rejected or a promise returned by the reducer function is rejected, the result is rejected as well.</source>
          <target state="translated">Si la función reductora devuelve una promesa,entonces se espera el resultado de la promesa,antes de continuar con la siguiente iteración.Si alguna promesa de la matriz es rechazada o una promesa devuelta por la función reductora es rechazada,el resultado también es rechazado.</target>
        </trans-unit>
        <trans-unit id="9a8efabed45049c7b109e41750da5ffac5adcb88" translate="yes" xml:space="preserve">
          <source>If the waterfall elements are static, you can just replace it with a normal promise chain. For waterfalls with dynamic steps, use &lt;a href=&quot;api/promise.each&quot;&gt;&lt;code&gt;Promise.each&lt;/code&gt;&lt;/a&gt;. Multiple arguments can be ferried in an array.</source>
          <target state="translated">Si los elementos de la cascada son est&amp;aacute;ticos, puede reemplazarlos con una cadena de promesa normal. Para cascadas con pasos din&amp;aacute;micos, use &lt;a href=&quot;api/promise.each&quot;&gt; &lt;code&gt;Promise.each&lt;/code&gt; &lt;/a&gt; . Se pueden transportar m&amp;uacute;ltiples argumentos en una matriz.</target>
        </trans-unit>
        <trans-unit id="6feea941cd7828f9478631d06744c6dde53e3bff" translate="yes" xml:space="preserve">
          <source>If too many promises are rejected so that the promise can never become fulfilled, it will be immediately rejected with an &lt;a href=&quot;aggregateerror&quot;&gt;&lt;code&gt;AggregateError&lt;/code&gt;&lt;/a&gt; of the rejection reasons in the order they were thrown in.</source>
          <target state="translated">Si se rechazan demasiadas promesas para que la promesa nunca se pueda cumplir, se rechazar&amp;aacute; inmediatamente con un &lt;a href=&quot;aggregateerror&quot;&gt; &lt;code&gt;AggregateError&lt;/code&gt; &lt;/a&gt; de los motivos de rechazo en el orden en que se lanzaron.</target>
        </trans-unit>
        <trans-unit id="c2cf94f34d6e1d8b4f98bef3770ba3552f18a017" translate="yes" xml:space="preserve">
          <source>If you cannot do static promisification (promisify and promisifyAll perform too slowly to use at runtime), you may use &lt;a href=&quot;api/promise.fromcallback&quot;&gt;&lt;code&gt;Promise.fromCallback&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si no puede hacer una promisificaci&amp;oacute;n est&amp;aacute;tica (promisify y promisifyAll se realiza muy lentamente para usar en tiempo de ejecuci&amp;oacute;n), puede usar &lt;a href=&quot;api/promise.fromcallback&quot;&gt; &lt;code&gt;Promise.fromCallback&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4aad0286aecb732eace47330d3eb9225ba7439ee" translate="yes" xml:space="preserve">
          <source>If you do have some code using jQuery deferred methods extensively try to see if some of these jQuery deferred patterns and their replacements can be applied:</source>
          <target state="translated">Si tiene algún código que utilice métodos de jQuery diferido,trate de ver si algunos de estos patrones de jQuery diferido y sus reemplazos pueden ser aplicados:</target>
        </trans-unit>
        <trans-unit id="ee3233f06ac157e8dbc09dc2625b57a65257f7e1" translate="yes" xml:space="preserve">
          <source>If you don't want to return a bound promise to the consumers of a promise, you can rebind the chain at the end:</source>
          <target state="translated">Si no quieres devolver una promesa atada a los consumidores de una promesa,puedes volver a atar la cadena al final:</target>
        </trans-unit>
        <trans-unit id="4a1d38286aed9fdb4ea56d22e0878f2efd4afec6" translate="yes" xml:space="preserve">
          <source>If you find this issue in a common library please &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/new&quot;&gt;open an issue&lt;/a&gt;.</source>
          <target state="translated">Si encuentra este problema en una biblioteca com&amp;uacute;n, &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/new&quot;&gt;abra un problema&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2c92c43afa270ba31f20fa3a4fd3f374ada753" translate="yes" xml:space="preserve">
          <source>If you know what you're doing and don't want to silence all warnings, you can create runaway promises without causing this warning by returning e.g. &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="translated">Si sabe lo que est&amp;aacute; haciendo y no quiere silenciar todas las advertencias, puede crear promesas fugitivas sin causar esta advertencia devolviendo, por ejemplo, &lt;code&gt;null&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4317fd792e9166b0fb459f84f12ac0c69c772134" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;code&gt;context&lt;/code&gt;, the &lt;code&gt;nodeFunction&lt;/code&gt; will be called as a method on the &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">Si pasa un &lt;code&gt;context&lt;/code&gt; o , se &lt;code&gt;nodeFunction&lt;/code&gt; a nodeFunction como m&amp;eacute;todo en el &lt;code&gt;context&lt;/code&gt; o .</target>
        </trans-unit>
        <trans-unit id="725473ba1a25ffa9ed75e25bf705064099a7373d" translate="yes" xml:space="preserve">
          <source>If you pass a promise object to the &lt;code&gt;resolve&lt;/code&gt; function, the created promise will follow the state of that promise.</source>
          <target state="translated">Si pasa un objeto de promesa a la funci&amp;oacute;n de &lt;code&gt;resolve&lt;/code&gt; , la promesa creada seguir&amp;aacute; el estado de esa promesa.</target>
        </trans-unit>
        <trans-unit id="c8c7f36a8c78ffc855273674eee0d9d279347fca" translate="yes" xml:space="preserve">
          <source>If you see this warning your code is probably not doing what you expect it to, the most common reason is passing the &lt;em&gt;result&lt;/em&gt; of calling a function to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; instead of the function &lt;em&gt;itself&lt;/em&gt;:</source>
          <target state="translated">Si ve esta advertencia, su c&amp;oacute;digo probablemente no est&amp;aacute; haciendo lo que espera que haga, la raz&amp;oacute;n m&amp;aacute;s com&amp;uacute;n es pasar el &lt;em&gt;resultado&lt;/em&gt; de llamar a una funci&amp;oacute;n a &lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; lugar de la funci&amp;oacute;n en &lt;em&gt;s&amp;iacute;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="209a23ebfb5748a6ab8f80e05376ebdb5ccf11de" translate="yes" xml:space="preserve">
          <source>If you want to coordinate several discrete concurrent promises, use &lt;a href=&quot;promise.join&quot;&gt;&lt;code&gt;Promise.join&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Si desea coordinar varias promesas simult&amp;aacute;neas discretas, use &lt;a href=&quot;promise.join&quot;&gt; &lt;code&gt;Promise.join&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b76d752c005430b67f6283cff61f81e57d83ce0" translate="yes" xml:space="preserve">
          <source>If you want to wrap an API with a promise manually, the correct syntax is:</source>
          <target state="translated">Si quieres envolver una API con una promesa manualmente,la sintaxis correcta es:</target>
        </trans-unit>
        <trans-unit id="700d4beb4e694e797eaff4fa5778aa5c5d7f5298" translate="yes" xml:space="preserve">
          <source>If you're familiar with PromiseKit, it is based on a same specification bluebird is based on so the API should feel familiar right away.</source>
          <target state="translated">Si estás familiarizado con PromiseKit,está basado en una misma especificación en la que se basa bluebird,por lo que la API debería resultarte familiar de inmediato.</target>
        </trans-unit>
        <trans-unit id="966394e4086caa71b33f7995eed9fbcc4b6e2187" translate="yes" xml:space="preserve">
          <source>If your library needs to do something obtrusive like adding or modifying methods on the &lt;code&gt;Promise&lt;/code&gt; prototype, uses long stack traces or uses a custom unhandled rejection handler then... that's totally ok as long as you don't use &lt;code&gt;require(&quot;bluebird&quot;)&lt;/code&gt;. Instead you should create a file that creates an isolated copy. For example, creating a file called &lt;code&gt;bluebird-extended.js&lt;/code&gt; that contains:</source>
          <target state="translated">Si su biblioteca necesita hacer algo molesto, como agregar o modificar m&amp;eacute;todos en el prototipo de &lt;code&gt;Promise&lt;/code&gt; , utiliza trazas de pila largas o utiliza un controlador de rechazo personalizado no controlado, entonces ... est&amp;aacute; totalmente bien siempre que no use &lt;code&gt;require(&quot;bluebird&quot;)&lt;/code&gt; . En su lugar, debe crear un archivo que cree una copia aislada. Por ejemplo, crear un archivo llamado &lt;code&gt;bluebird-extended.js&lt;/code&gt; que contiene:</target>
        </trans-unit>
        <trans-unit id="cbc582b62a43024af9610875e2f1c1a993555795" translate="yes" xml:space="preserve">
          <source>If your'e familiar with Java 8 lambdas, you can think of a promise as a &lt;code&gt;Future&lt;/code&gt; you can &lt;code&gt;map&lt;/code&gt; to another future.</source>
          <target state="translated">Si est&amp;aacute; familiarizado con Java 8 lambdas, puede pensar en una promesa como un &lt;code&gt;Future&lt;/code&gt; que puede &lt;code&gt;map&lt;/code&gt; a otro futuro.</target>
        </trans-unit>
        <trans-unit id="834102510a799a81df534fb9d6f8cdb91d442836" translate="yes" xml:space="preserve">
          <source>If, at any step:</source>
          <target state="translated">Si,en cualquier momento:</target>
        </trans-unit>
        <trans-unit id="f76b9571c2fa26f1c9c053453e48baf3102b175e" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;api/reflect&quot;&gt;&lt;code&gt;.reflect()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Implementar &lt;a href=&quot;api/reflect&quot;&gt; &lt;code&gt;.reflect()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0de27db7a173e23bc1b1a951c986b9e75189651d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutineaddyieldhandlerfunction-handler---void&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Implemente &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promisecoroutineaddyieldhandlerfunction-handler---void&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="debaea1257108cf0777761addbfa5ec8ad866a63" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#tapfunction-handler---promise&quot;&gt;&lt;code&gt;Promise.prototype.tap()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Implementar &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#tapfunction-handler---promise&quot;&gt; &lt;code&gt;Promise.prototype.tap()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a1c43a24101780f93b51137f52374d22e70596b" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.bind&lt;/code&gt; and &lt;code&gt;Promise.bind&lt;/code&gt;</source>
          <target state="translated">Implemente &lt;code&gt;.bind&lt;/code&gt; y &lt;code&gt;Promise.bind&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f380a273aee2d6cf970a6fe45244632c5d9b4cc" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.return()&lt;/code&gt;</source>
          <target state="translated">Implementar &lt;code&gt;.return()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4c72d943e49cf756fcbd5f12144b514c9e719f9" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;.throw()&lt;/code&gt;</source>
          <target state="translated">Implementar &lt;code&gt;.throw()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae49e6671f17e74abdd91283eaaa890a378ca81b" translate="yes" xml:space="preserve">
          <source>Implement &lt;code&gt;Promise.method()&lt;/code&gt;</source>
          <target state="translated">Implementar &lt;code&gt;Promise.method()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d181fb40191fdf3fe9541cbc7a61c14dc076b35" translate="yes" xml:space="preserve">
          <source>Implement RejectionError wrapping and &lt;code&gt;.error()&lt;/code&gt; method</source>
          <target state="translated">Implemente el m&amp;eacute;todo de &lt;code&gt;.error()&lt;/code&gt; RejectionError y .error ()</target>
        </trans-unit>
        <trans-unit id="ff1c32750ed475d16c2e3d6ee2570476a4351b7a" translate="yes" xml:space="preserve">
          <source>Implemented &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#global-rejection-events&quot;&gt;global rejection events&lt;/a&gt; (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/428&quot;&gt;#428&lt;/a&gt;, &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/357&quot;&gt;#357&lt;/a&gt;)</source>
          <target state="translated">Implementado &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#global-rejection-events&quot;&gt;eventos de rechazo global&lt;/a&gt; ( &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/428&quot;&gt;# 428&lt;/a&gt; , &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/357&quot;&gt;# 357&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6677e178a6bc2ac6cc38cee7e51212de4486b2b2" translate="yes" xml:space="preserve">
          <source>Implementing general progress interfaces like in C#:</source>
          <target state="translated">Implementando interfaces de progreso general como en C#:</target>
        </trans-unit>
        <trans-unit id="733eea0f9f3a4d9f23332caa166015a4f890c124" translate="yes" xml:space="preserve">
          <source>Implementing the example from &lt;a href=&quot;https://github.com/caolan/async#waterfalltasks-callback&quot;&gt;async homepage&lt;/a&gt;</source>
          <target state="translated">Implementando el ejemplo de la &lt;a href=&quot;https://github.com/caolan/async#waterfalltasks-callback&quot;&gt;p&amp;aacute;gina de inicio as&amp;iacute;ncrona&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97ecdd3f427cfc303e767bb0913667606529c860" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;Promise.all()&lt;/code&gt; when yielding an array from generators</source>
          <target state="translated">&lt;code&gt;Promise.all()&lt;/code&gt; impl&amp;iacute;cito al generar una matriz de generadores</target>
        </trans-unit>
        <trans-unit id="1dd411a1bd6013312e12e897a0c51cd4f4318ca0" translate="yes" xml:space="preserve">
          <source>Improve &lt;code&gt;promisifyAll&lt;/code&gt; detection of functions that are class constructors. Fixes mongodb 2.x promisification.</source>
          <target state="translated">Mejore &lt;code&gt;promisifyAll&lt;/code&gt; detecci&amp;oacute;n de funciones que son constructores de clases. Corrige la promisificaci&amp;oacute;n de mongodb 2.x.</target>
        </trans-unit>
        <trans-unit id="213e96bdfb4a128bc3bd87f532efaf90f14c5e6a" translate="yes" xml:space="preserve">
          <source>Improve output of reporting unhandled non-errors</source>
          <target state="translated">Mejorar el resultado de la notificación de los no errores no manejados</target>
        </trans-unit>
        <trans-unit id="21437ff0b7933ce8b58f0d38d668c7b9602b5664" translate="yes" xml:space="preserve">
          <source>Improve overall performance when not using &lt;code&gt;.bind()&lt;/code&gt; or cancellation.</source>
          <target state="translated">Mejore el rendimiento general cuando no use &lt;code&gt;.bind()&lt;/code&gt; o cancelaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a3cd986d15205ea786fe95cf148b685b17a4a66b" translate="yes" xml:space="preserve">
          <source>Improve overall performance.</source>
          <target state="translated">Mejorar el rendimiento general.</target>
        </trans-unit>
        <trans-unit id="d91321dac872eb3a4ecd05762060d481636fa793" translate="yes" xml:space="preserve">
          <source>Improve overall performance. Be able to sustain infinite recursion when using promises.</source>
          <target state="translated">Mejorar el rendimiento general.Ser capaz de sostener una recursividad infinita cuando se usan las promesas.</target>
        </trans-unit>
        <trans-unit id="23dc55298841549083703a0dc975bff9f3e5d5fc" translate="yes" xml:space="preserve">
          <source>Improve performance of .finally.</source>
          <target state="translated">Mejorar el rendimiento de .finally.</target>
        </trans-unit>
        <trans-unit id="b5cef6dcb86b0975f111f8f1d79bf5d753600cad" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.props()&lt;/code&gt; and collection methods when used with immediate values</source>
          <target state="translated">Mejore el rendimiento de &lt;code&gt;.props()&lt;/code&gt; y los m&amp;eacute;todos de recopilaci&amp;oacute;n cuando se usan con valores inmediatos</target>
        </trans-unit>
        <trans-unit id="6533fb39d2c4b52d57bf0b0080357de93b567761" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.reduce()&lt;/code&gt; when &lt;code&gt;initialValue&lt;/code&gt; can be synchronously cast to a value</source>
          <target state="translated">Mejore el rendimiento de &lt;code&gt;.reduce()&lt;/code&gt; cuando &lt;code&gt;initialValue&lt;/code&gt; se puede convertir sincr&amp;oacute;nicamente a un valor</target>
        </trans-unit>
        <trans-unit id="b79e5ce64b3cc6df23f96da6189a55cda2f3a24b" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;.some()&lt;/code&gt;</source>
          <target state="translated">Mejora el rendimiento de &lt;code&gt;.some()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6605838414ae4861872117f11458f4f7c032e53b" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.method&lt;/code&gt;</source>
          <target state="translated">Mejore el rendimiento del &lt;code&gt;Promise.method&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1801c2ab62399342798816e151c62d526a208232" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.race&lt;/code&gt;</source>
          <target state="translated">Mejora el rendimiento de &lt;code&gt;Promise.race&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b47c1066dd0e09e1dc6291709e049b1a62126113" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;Promise.try&lt;/code&gt;</source>
          <target state="translated">Mejora el rendimiento de &lt;code&gt;Promise.try&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0221a27976575e573ab343e0c7bf4e30199750e" translate="yes" xml:space="preserve">
          <source>Improve performance of all collection methods</source>
          <target state="translated">Mejorar el rendimiento de todos los métodos de recolección</target>
        </trans-unit>
        <trans-unit id="69bc40cef74e6b8ed6de0d57bc11088841731b08" translate="yes" xml:space="preserve">
          <source>Improve performance of catch filters.</source>
          <target state="translated">Mejorar el rendimiento de los filtros de captura.</target>
        </trans-unit>
        <trans-unit id="493b04565b586c443227bda9dba7b5733786d595" translate="yes" xml:space="preserve">
          <source>Improve performance of collection methods</source>
          <target state="translated">Mejorar el rendimiento de los métodos de recolección</target>
        </trans-unit>
        <trans-unit id="f3e709b44915764f7a5d40fc9df801ca2e482471" translate="yes" xml:space="preserve">
          <source>Improve performance of generators</source>
          <target state="translated">Mejorar el rendimiento de los generadores</target>
        </trans-unit>
        <trans-unit id="f2f07a6efaf7192742177f90f38e34f5cffb946a" translate="yes" xml:space="preserve">
          <source>Improve performance of promise chains</source>
          <target state="translated">Mejorar el rendimiento de las cadenas de promesa</target>
        </trans-unit>
        <trans-unit id="ab32070153659d73fbda42374c3ef4d00f9c1281" translate="yes" xml:space="preserve">
          <source>Improve performance of promisified functions on V8</source>
          <target state="translated">Mejorar el rendimiento de las funciones prometidas en el V8</target>
        </trans-unit>
        <trans-unit id="9c964cafe501b6c71e57bfaecc51d7213a1f33ad" translate="yes" xml:space="preserve">
          <source>Improve performance of promisified functions.</source>
          <target state="translated">Mejorar el desempeño de las funciones prometidas.</target>
        </trans-unit>
        <trans-unit id="d0964ce694308926e6cce53db966d728b2dd5ab4" translate="yes" xml:space="preserve">
          <source>Improved performance and readability</source>
          <target state="translated">Mejora del rendimiento y la legibilidad</target>
        </trans-unit>
        <trans-unit id="70e80457a02f473b417d800f6ebe8e2a3e15d72c" translate="yes" xml:space="preserve">
          <source>In 2.x, promise cancellation looked very differently. Promise cancellation received a major overhaul for version 3 in order to create a sound variant of cancellable promises. You can still use 2.x cancellation with bluebird 2.x (which is still supported - but not recommended). See &lt;a href=&quot;http://bluebirdjs.com/cancellation.html&quot;&gt;Cancellation&lt;/a&gt; for more details. The 2.x docs are &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/2.x/API.md&quot;&gt;still accessible under the 2.x branch&lt;/a&gt;.</source>
          <target state="translated">En 2.x, la cancelaci&amp;oacute;n de la promesa se ve&amp;iacute;a de manera muy diferente. La cancelaci&amp;oacute;n de la promesa recibi&amp;oacute; una revisi&amp;oacute;n importante para la versi&amp;oacute;n 3 con el fin de crear una variante de sonido de las promesas cancelables. Todav&amp;iacute;a puede usar la cancelaci&amp;oacute;n 2.x con bluebird 2.x (que todav&amp;iacute;a es compatible, pero no se recomienda). Ver &lt;a href=&quot;http://bluebirdjs.com/cancellation.html&quot;&gt;Cancelaci&amp;oacute;n&lt;/a&gt; para m&amp;aacute;s detalles. Los documentos 2.x son &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/2.x/API.md&quot;&gt;todav&amp;iacute;a accesibles en la rama 2.x&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8fc7d5be5578254c3c3ba0dde3ab83e463051fa" translate="yes" xml:space="preserve">
          <source>In Node.js you may configure warnings and long stack traces for the entire process using environment variables:</source>
          <target state="translated">En Node.js se pueden configurar advertencias y largos rastros de pila para todo el proceso usando variables de entorno:</target>
        </trans-unit>
        <trans-unit id="361446f42424e75edad97d144b32a1e290e72cc3" translate="yes" xml:space="preserve">
          <source>In Node/io.js most APIs follow a convention of &lt;a href=&quot;https://gist.github.com/CrabDude/10907185&quot;&gt;'error-first, single-parameter'&lt;/a&gt; as such:</source>
          <target state="translated">En Node / io.js, la mayor&amp;iacute;a de las API siguen una convenci&amp;oacute;n de &lt;a href=&quot;https://gist.github.com/CrabDude/10907185&quot;&gt;'error-first, single-parameter'&lt;/a&gt; como tal:</target>
        </trans-unit>
        <trans-unit id="20a81f38445f0a6f17f84f7b1c945721cfb38a3e" translate="yes" xml:space="preserve">
          <source>In Web Workers you may use &lt;code&gt;self.addEventListener&lt;/code&gt;.</source>
          <target state="translated">En Web Workers puede usar &lt;code&gt;self.addEventListener&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b759cd2431b6c3f52be7951a07c24cc5f5b3b96" translate="yes" xml:space="preserve">
          <source>In addition promises are always unwrapped. A promise implicitly has &lt;code&gt;Task.Unwrap&lt;/code&gt; called on it - that is, promises perform recursive assimilation of promises within them.</source>
          <target state="translated">Adem&amp;aacute;s, las promesas siempre se desenvuelven. Una promesa impl&amp;iacute;citamente tiene &lt;code&gt;Task.Unwrap&lt;/code&gt; invocada , es decir, las promesas realizan una asimilaci&amp;oacute;n recursiva de las promesas dentro de ellas.</target>
        </trans-unit>
        <trans-unit id="da70284ad0b5f811fe8223b6b3d83e713568a28f" translate="yes" xml:space="preserve">
          <source>In addition promises are always unwrapped. That is, promises perform recursive assimilation of promises within them. You can't have a &lt;code&gt;Promise&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; where a &lt;code&gt;Future[Future[T]]&lt;/code&gt; is valid in Scala.</source>
          <target state="translated">Adem&amp;aacute;s, las promesas siempre se desenvuelven. Es decir, las promesas realizan una asimilaci&amp;oacute;n recursiva de las promesas dentro de ellas. No puede tener una &lt;code&gt;Promise&amp;lt;Promise&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; donde un &lt;code&gt;Future[Future[T]]&lt;/code&gt; es v&amp;aacute;lido en Scala.</target>
        </trans-unit>
        <trans-unit id="b3db467e4305c26c33d91d438b39bab7913a7d8d" translate="yes" xml:space="preserve">
          <source>In all of the above cases the library made its classes available in one way or another. If this is not the case, you can still promisify by creating a throwaway instance:</source>
          <target state="translated">En todos los casos anteriores la biblioteca puso sus clases a disposición de una manera u otra.Si este no es el caso,todavía puede prometer creando una instancia desechable:</target>
        </trans-unit>
        <trans-unit id="a37bb782f65c2292150ec12a9ec0ac667bbafa9d" translate="yes" xml:space="preserve">
          <source>In bluebird we've chosen to do the latter because resources are typically scarce. For example, if a database connection cannot be disposed of and Bluebird ignores that, the connection pool will be quickly depleted and the process will become unusable (all requests that query the database will wait forever). Since Bluebird doesn't know how to handle that, the only sensible default is to crash the process. That way, rather than getting a useless process that cannot fulfill more requests, we can swap the faulty worker with a new one letting the OS clean up the resources for us.</source>
          <target state="translated">En Bluebird hemos elegido hacer lo último porque los recursos son típicamente escasos.Por ejemplo,si no se puede deshacerse de una conexión a la base de datos y Bluebird lo ignora,la reserva de conexiones se agotará rápidamente y el proceso se volverá inutilizable (todas las solicitudes que consulten la base de datos esperarán para siempre).Dado que Bluebird no sabe cómo manejar eso,la única opción predeterminada sensata es bloquear el proceso.De esta manera,en lugar de obtener un proceso inútil que no puede satisfacer más solicitudes,podemos cambiar el trabajador defectuoso por uno nuevo dejando que el sistema operativo limpie los recursos por nosotros.</target>
        </trans-unit>
        <trans-unit id="ca0b3dbad60939fa3e3338aec5bf46570e2d8a1a" translate="yes" xml:space="preserve">
          <source>In conjunction with &lt;a href=&quot;disposer&quot;&gt;&lt;code&gt;.disposer&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;using&lt;/code&gt; will make sure that no matter what, the specified disposer will be called when the promise returned by the callback passed to &lt;code&gt;using&lt;/code&gt; has settled. The disposer is necessary because there is no standard interface in node for disposing resources.</source>
          <target state="translated">En conjunto con &lt;a href=&quot;disposer&quot;&gt; &lt;code&gt;.disposer&lt;/code&gt; &lt;/a&gt; , el &lt;code&gt;using&lt;/code&gt; se asegurar&amp;aacute; de que pase lo que pase , se llamar&amp;aacute; al eliminador especificado cuando se haya liquidado la promesa devuelta por la devoluci&amp;oacute;n de llamada pasada al &lt;code&gt;using&lt;/code&gt; . El eliminador es necesario porque no hay una interfaz est&amp;aacute;ndar en el nodo para eliminar recursos.</target>
        </trans-unit>
        <trans-unit id="879b1a8e6173fcc0fe684d08d132ce1871ae3253" translate="yes" xml:space="preserve">
          <source>In general, the usage of &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; is along the lines of &lt;code&gt;var fs = Promise.promisifyAll(require(&quot;fs&quot;))&lt;/code&gt;.</source>
          <target state="translated">En general, el uso de &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; es similar a &lt;code&gt;var fs = Promise.promisifyAll(require(&quot;fs&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8efb8cf18cab76bf61b065fcc2def10c9ed9fac9" translate="yes" xml:space="preserve">
          <source>In our dialog example perhaps we want to differentiate between a rejected promise because of some problem (bad AJAX, programming error, etc.) or because the user pressed the cancel button.</source>
          <target state="translated">En nuestro ejemplo de diálogo tal vez queramos diferenciar entre una promesa rechazada por algún problema (mal AJAX,error de programación,etc.)o porque el usuario presionó el botón de cancelar.</target>
        </trans-unit>
        <trans-unit id="b6bbd69af3538cceaf0f293038d0f3eaed462ca8" translate="yes" xml:space="preserve">
          <source>In practice:</source>
          <target state="translated">En la práctica:</target>
        </trans-unit>
        <trans-unit id="21b9f4a2f2ffcaff8935b98b291fdfb43db81e8c" translate="yes" xml:space="preserve">
          <source>In recent versions generator libraries started abandoning old ideas of special tokens passed to callbacks and started using promises for what's being yielded.</source>
          <target state="translated">En versiones recientes las librerías generadoras comenzaron a abandonar las viejas ideas de fichas especiales pasadas a las devoluciones de llamada y comenzaron a usar promesas para lo que se está rindiendo.</target>
        </trans-unit>
        <trans-unit id="90361caad2f10101ee0f756a8ebd2978182891e3" translate="yes" xml:space="preserve">
          <source>In the above example, the connection returned by &lt;code&gt;getConnection&lt;/code&gt; can only be used via &lt;code&gt;Promise.using&lt;/code&gt;, like so:</source>
          <target state="translated">En el ejemplo anterior, la conexi&amp;oacute;n devuelta por &lt;code&gt;getConnection&lt;/code&gt; solo se puede usar a trav&amp;eacute;s de &lt;code&gt;Promise.using&lt;/code&gt; , as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="cb64939e278ff57bb52a7c44ea2a2cbd428cb81a" translate="yes" xml:space="preserve">
          <source>In the explicit construction anti-pattern, promise objects are created for no reason, complicating code.</source>
          <target state="translated">En la construcción explícita anti-patrón,los objetos de promesa son creados sin razón,complicando el código.</target>
        </trans-unit>
        <trans-unit id="b0070e87ecff77ecb23ce611e38aac089e617332" translate="yes" xml:space="preserve">
          <source>In the following example you might want to handle just the &lt;code&gt;SyntaxError&lt;/code&gt; from JSON.parse and Filesystem errors from &lt;code&gt;fs&lt;/code&gt; but let programmer errors bubble as unhandled rejections:</source>
          <target state="translated">En el siguiente ejemplo, es posible que desee manejar solo el &lt;code&gt;SyntaxError&lt;/code&gt; de JSON.parse y los errores del sistema de archivos de &lt;code&gt;fs&lt;/code&gt; , pero permita que los errores del programador burbujeen como rechazos no controlados:</target>
        </trans-unit>
        <trans-unit id="73d3bed94715ad4383569042f35e985547cd7283" translate="yes" xml:space="preserve">
          <source>In the latter the indentation stays flat no matter how many previous variables you need, whereas with the former each additional previous value would require an additional nesting level.</source>
          <target state="translated">En el segundo,la indentación se mantiene plana sin importar cuántas variables previas se necesiten,mientras que en el primero cada valor previo adicional requeriría un nivel de anidación adicional.</target>
        </trans-unit>
        <trans-unit id="dd6afd7e774c8e6fdacd9e8f55a35e835be8f939" translate="yes" xml:space="preserve">
          <source>In this case, the promise resolves with itself which was is not intended.</source>
          <target state="translated">En este caso,la promesa se resuelve por sí misma,lo que no se pretendía.</target>
        </trans-unit>
        <trans-unit id="30b4d4283864d46d2836b690ac2cbfeafa74746b" translate="yes" xml:space="preserve">
          <source>Individual promisifcation uses current &lt;code&gt;this&lt;/code&gt; if no explicit receiver is given</source>
          <target state="translated">La promisifcaci&amp;oacute;n individual usa &lt;code&gt;this&lt;/code&gt; actual si no se proporciona un receptor expl&amp;iacute;cito</target>
        </trans-unit>
        <trans-unit id="68c8caa0f2f33563e5d4c95632e8edaafba86244" translate="yes" xml:space="preserve">
          <source>Initially the Dialog class sets the two callbacks to &lt;em&gt;noop&lt;/em&gt; functions. It is up to the child class to call them when necessary. We break down the promise creation to one function &lt;code&gt;waitForUser()&lt;/code&gt; that sets the callbacks and returns a promise. At this level the &lt;code&gt;show()&lt;/code&gt; and &lt;code&gt;hide()&lt;/code&gt; are just &lt;em&gt;noop&lt;/em&gt; functions as well and will be implemented by the child classes.</source>
          <target state="translated">Inicialmente, la clase Dialog establece las dos devoluciones de llamada en funciones &lt;em&gt;noop&lt;/em&gt; . Depende de la clase infantil llamarlos cuando sea necesario. &lt;code&gt;waitForUser()&lt;/code&gt; la creaci&amp;oacute;n de la promesa en una funci&amp;oacute;n waitForUser () que establece las devoluciones de llamada y devuelve una promesa. En este nivel, &lt;code&gt;show()&lt;/code&gt; y &lt;code&gt;hide()&lt;/code&gt; son funciones &lt;em&gt;noop&lt;/em&gt; y ser&amp;aacute;n implementadas por las clases secundarias.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="d84677d86357a2c0115e2ed2adb5f6ec133b7f26" translate="yes" xml:space="preserve">
          <source>Instead of using the Deferred anti-pattern, the code should simply return the promise it already has and propagate values using &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="translated">En lugar de utilizar el antipatr&amp;oacute;n diferido, el c&amp;oacute;digo simplemente debe devolver la promesa que ya tiene y propagar valores utilizando &lt;code&gt;return&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1aed780a746f68d28a85c473dd835c234712b990" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; :</source>
          <target state="translated">En su lugar, use &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="659525747c675f26d0d0761f93182ab5228cbc26" translate="yes" xml:space="preserve">
          <source>Into this:</source>
          <target state="translated">En esto:</target>
        </trans-unit>
        <trans-unit id="a66cb4039287c802cdc27ed98f34dc1c2d5d9411" translate="yes" xml:space="preserve">
          <source>It also works on singletons or specific instances:</source>
          <target state="translated">También funciona en los solteros o en casos específicos:</target>
        </trans-unit>
        <trans-unit id="6b5d95eeedfe49016755274286b46a188fd09776" translate="yes" xml:space="preserve">
          <source>It comes in two variants. - A tapCatch-all variant similar to &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; block. This variant is compatible with native promises. - A filtered variant (like other non-JS languages typically have) that lets you only handle specific errors. &lt;strong&gt;This variant is usually preferable&lt;/strong&gt;.</source>
          <target state="translated">Viene en dos variantes. - Una variante tapCatch-all similar al bloque &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt; . Esta variante es compatible con las promesas nativas. - Una variante filtrada (como suelen tener otros lenguajes que no son JS) que le permite manejar solo errores espec&amp;iacute;ficos. &lt;strong&gt;Esta variante suele ser preferible&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e2a3866a72ba04bc9a62fa718c486091a65f59f8" translate="yes" xml:space="preserve">
          <source>It is equivalent to the following &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; pattern:</source>
          <target state="translated">Es equivalente al siguiente patr&amp;oacute;n &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0b0ded67bc5c7c35daa1f171d80dccf1a33e74e4" translate="yes" xml:space="preserve">
          <source>It is essentially an efficient shortcut for doing a &lt;a href=&quot;map&quot;&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/a&gt; and then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;&lt;code&gt;Array#filter&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Es esencialmente un atajo eficiente para hacer un &lt;a href=&quot;map&quot;&gt; &lt;code&gt;.map&lt;/code&gt; &lt;/a&gt; y luego un &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt; &lt;code&gt;Array#filter&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="67ad0cadb6c3a5671744781f608f9a02e1c5a392" translate="yes" xml:space="preserve">
          <source>It is more likely that you would write this instead in the sync world:</source>
          <target state="translated">Es más probable que escribas esto en el mundo de la sincronización:</target>
        </trans-unit>
        <trans-unit id="53a01add8c2bcb3ae05a334c130487578987c686" translate="yes" xml:space="preserve">
          <source>It is often said that promises cannot be cancellable because they can have multiple consumers.</source>
          <target state="translated">Se suele decir que las promesas no pueden ser anulables porque pueden tener múltiples consumidores.</target>
        </trans-unit>
        <trans-unit id="6b0e7d44695db980a8f0ed40ee055bb11d90c7f7" translate="yes" xml:space="preserve">
          <source>It is very subtle but over time this code will exhaust the entire connection pool and the server needs to be restarted. This is because reading the file may fail and then of course &lt;code&gt;.spread&lt;/code&gt; is not called at all and thus the connection is not closed.</source>
          <target state="translated">Es muy sutil, pero con el tiempo este c&amp;oacute;digo agotar&amp;aacute; todo el conjunto de conexiones y el servidor debe reiniciarse. Esto se debe a que la lectura del archivo puede fallar y, por supuesto, no se llama a &lt;code&gt;.spread&lt;/code&gt; y, por lo tanto, la conexi&amp;oacute;n no se cierra.</target>
        </trans-unit>
        <trans-unit id="25e4aad38b66ae4f579919e5442c2f87282d298e" translate="yes" xml:space="preserve">
          <source>It might look like this:</source>
          <target state="translated">Podría parecerse a esto:</target>
        </trans-unit>
        <trans-unit id="f3201aa0565e8be1e1547bcb52a2f64c00b2bc44" translate="yes" xml:space="preserve">
          <source>It should be noted that there is no real need to attach the handlers asynchronously. Exactly the same effect can be achieved with:</source>
          <target state="translated">Cabe señalar que no hay una necesidad real de colocar los manipuladores de forma asincrónica.Exactamente el mismo efecto se puede lograr con:</target>
        </trans-unit>
        <trans-unit id="f25d9aa71a1aef724d7f8d933c376e203e6ccfd0" translate="yes" xml:space="preserve">
          <source>It's also possible to use a disposer pattern (but not actual disposers) for transaction management:</source>
          <target state="translated">También es posible utilizar una pauta de eliminación de desechos (pero no de eliminación propiamente dicha)para la gestión de las transacciones:</target>
        </trans-unit>
        <trans-unit id="a3b38a83ae257f40976a60195f877e73b38d539c" translate="yes" xml:space="preserve">
          <source>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given &lt;code&gt;iterator&lt;/code&gt; function with the signature &lt;code&gt;(value, index, length)&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the resolved value of a respective promise in the input array. &lt;strong&gt;Iteration happens serially&lt;/strong&gt;. If the iterator function returns a promise or a thenable, then the result of the promise is awaited before continuing with next iteration. If any promise in the input array is rejected, then the returned promise is rejected as well.</source>
          <target state="translated">Iterar sobre una matriz, o una promesa de una matriz, que contiene promesas (o una combinaci&amp;oacute;n de promesas y valores) con la funci&amp;oacute;n &lt;code&gt;iterator&lt;/code&gt; dada con la firma &lt;code&gt;(value, index, length)&lt;/code&gt; donde &lt;code&gt;value&lt;/code&gt; es el valor resuelto de una promesa respectiva en La matriz de entrada. &lt;strong&gt;La iteraci&amp;oacute;n ocurre en serie&lt;/strong&gt; . Si la funci&amp;oacute;n de iterador devuelve una promesa o un thenable, entonces se espera el resultado de la promesa antes de continuar con la pr&amp;oacute;xima iteraci&amp;oacute;n. Si se rechaza cualquier promesa en la matriz de entrada, tambi&amp;eacute;n se rechaza la promesa devuelta.</target>
        </trans-unit>
        <trans-unit id="d889900760cbb5576feda8db1d4c5015016f6e85" translate="yes" xml:space="preserve">
          <source>Iterate over an array, or a promise of an array, which contains promises (or a mix of promises and values) with the given &lt;code&gt;iterator&lt;/code&gt; function with the signature &lt;code&gt;(value, index, length)&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the resolved value of a respective promise in the input array. Iteration happens serially. If any promise in the input array is rejected the returned promise is rejected as well.</source>
          <target state="translated">Iterar sobre una matriz, o una promesa de una matriz, que contiene promesas (o una combinaci&amp;oacute;n de promesas y valores) con la funci&amp;oacute;n &lt;code&gt;iterator&lt;/code&gt; dada con la firma &lt;code&gt;(value, index, length)&lt;/code&gt; donde &lt;code&gt;value&lt;/code&gt; es el valor resuelto de una promesa respectiva en La matriz de entrada. La iteraci&amp;oacute;n ocurre en serie. Si se rechaza cualquier promesa en la matriz de entrada, la promesa devuelta tambi&amp;eacute;n se rechaza.</target>
        </trans-unit>
        <trans-unit id="e027e57610f85225767aafbbf23fed7457e55828" translate="yes" xml:space="preserve">
          <source>Java</source>
          <target state="translated">Java</target>
        </trans-unit>
        <trans-unit id="769460330d98abc38d4f157088d641889b8e080c" translate="yes" xml:space="preserve">
          <source>Just like a future, a promise represents a value over time. The value can resolve to either a fulfilled (ok completion) or rejected (error completion) state.</source>
          <target state="translated">Al igual que un futuro,una promesa representa un valor a lo largo del tiempo.El valor puede resolverse en un estado de cumplimiento (cumplimiento correcto)o de rechazo (cumplimiento erróneo).</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Con licencia del MIT.</target>
        </trans-unit>
        <trans-unit id="d2b04d056ad9ef4e9bfb796dceb8c12c3d2724b7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;all&quot;&gt;&lt;code&gt;.all&lt;/code&gt;&lt;/a&gt; but for object properties or &lt;code&gt;Map&lt;/code&gt;s* entries instead of iterated values. Returns a promise that is fulfilled when all the properties of the object or the &lt;code&gt;Map&lt;/code&gt;'s' values** are fulfilled. The promise's fulfillment value is an object or a &lt;code&gt;Map&lt;/code&gt; with fulfillment values at respective keys to the original object or a &lt;code&gt;Map&lt;/code&gt;. If any promise in the object or &lt;code&gt;Map&lt;/code&gt; rejects, the returned promise is rejected with the rejection reason.</source>
          <target state="translated">Como &lt;a href=&quot;all&quot;&gt; &lt;code&gt;.all&lt;/code&gt; &lt;/a&gt; pero para propiedades de objeto o entradas de &lt;code&gt;Map&lt;/code&gt; s * en lugar de valores iterados. Devuelve una promesa que se cumple cuando se cumplen todas las propiedades del objeto o los valores del &lt;code&gt;Map&lt;/code&gt; a **. El valor de cumplimiento de la promesa es un objeto o un &lt;code&gt;Map&lt;/code&gt; a con valores de cumplimiento en las claves respectivas del objeto original o un &lt;code&gt;Map&lt;/code&gt; a . Si alguna promesa en el objeto o &lt;code&gt;Map&lt;/code&gt; a rechaza, la promesa devuelta se rechaza con el motivo del rechazo.</target>
        </trans-unit>
        <trans-unit id="0868022eae9754566ebce8819ba10c34f00156c4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; but instead of catching all types of exceptions, it only catches operational errors.</source>
          <target state="translated">Al igual que &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; ,&lt;/a&gt; pero en lugar de detectar todo tipo de excepciones, solo detecta errores operativos.</target>
        </trans-unit>
        <trans-unit id="f7724ecb2f95d5397a59e0da7c44a35554300566" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; that is not called for fulfillments.</source>
          <target state="translated">Como &lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt; eso no se requiere para cumplimientos.</target>
        </trans-unit>
        <trans-unit id="4b705bae03f08f49a3c59a2a4c3c23676360ce32" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;promise.some&quot;&gt;&lt;code&gt;Promise.some&lt;/code&gt;&lt;/a&gt;, with 1 as &lt;code&gt;count&lt;/code&gt;. However, if the promise fulfills, the fulfillment value is not an array of 1 but the value directly.</source>
          <target state="translated">Como &lt;a href=&quot;promise.some&quot;&gt; &lt;code&gt;Promise.some&lt;/code&gt; &lt;/a&gt; , con 1 como &lt;code&gt;count&lt;/code&gt; . Sin embargo, si la promesa se cumple, el valor de cumplimiento no es una matriz de 1 sino el valor directamente.</target>
        </trans-unit>
        <trans-unit id="a0572842c5b510f6b6c6d450ffa47af7bfa19546" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt;, but any unhandled rejection that ends up here will crash the process (in node) or be thrown as an error (in browsers). The use of this method is heavily discouraged and it only exists for historical reasons.</source>
          <target state="translated">Como &lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt; , pero cualquier rechazo no controlado que termine aqu&amp;iacute; bloquear&amp;aacute; el proceso (en el nodo) o ser&amp;aacute; arrojado como un error (en los navegadores). El uso de este m&amp;eacute;todo est&amp;aacute; muy desaconsejado y solo existe por razones hist&amp;oacute;ricas.</target>
        </trans-unit>
        <trans-unit id="1d64e920d46f5914cb7b3fc3949b2df8768d761d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.map&lt;/code&gt; and &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.reduce&lt;/code&gt; now allows returning promises and thenables from the iteration function.</source>
          <target state="translated">Al igual que &lt;code&gt;.map&lt;/code&gt; y &lt;code&gt;.filter&lt;/code&gt; , &lt;code&gt;.reduce&lt;/code&gt; ahora permite devolver promesas y thenables de la funci&amp;oacute;n de iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f9b88079f4caa0345add2b49d7a0be51ed016806" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;.then()&lt;/code&gt;, but any unhandled rejection that ends up here will be thrown as an error. Again, only the variant with the progression handler is deprecated here. &lt;code&gt;.done&lt;/code&gt; is still fully supported.</source>
          <target state="translated">Como &lt;code&gt;.then()&lt;/code&gt; , pero cualquier rechazo no controlado que termine aqu&amp;iacute; ser&amp;aacute; arrojado como un error. De nuevo, solo la variante con el controlador de progresi&amp;oacute;n est&amp;aacute; en desuso aqu&amp;iacute;. &lt;code&gt;.done&lt;/code&gt; todav&amp;iacute;a es totalmente compatible.</target>
        </trans-unit>
        <trans-unit id="eaab59843408be17f1182d2a7ba7d498c9751120" translate="yes" xml:space="preserve">
          <source>Like calling &lt;code&gt;.then&lt;/code&gt;, but the fulfillment value &lt;em&gt;must be&lt;/em&gt; an array, which is flattened to the formal parameters of the fulfillment handler.</source>
          <target state="translated">Como llamar a &lt;code&gt;.then&lt;/code&gt; , pero el valor de cumplimiento &lt;em&gt;debe ser&lt;/em&gt; una matriz, que se aplana a los par&amp;aacute;metros formales del controlador de cumplimiento.</target>
        </trans-unit>
        <trans-unit id="4d46fec21cdff120fbce1d5c81043ed187891e17" translate="yes" xml:space="preserve">
          <source>Local rejection events</source>
          <target state="translated">Eventos locales de rechazo</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="25c9bdc07ce0dfdf61f61c6ce40dbedeb1c6dd8e" translate="yes" xml:space="preserve">
          <source>Logging after the promise became GCd (requires a native node.js module)</source>
          <target state="translated">Registro después de que la promesa se convirtiera en GCd (requiere un módulo nativo node.js)</target>
        </trans-unit>
        <trans-unit id="44413342754143aa1961f15d95ef6db04a6b6098" translate="yes" xml:space="preserve">
          <source>Long stack traces</source>
          <target state="translated">Largos rastros de pila</target>
        </trans-unit>
        <trans-unit id="4d0119ac596cae5eba4e7c9ece07c3d282260f3e" translate="yes" xml:space="preserve">
          <source>Long stack traces are enabled by default in the debug build.</source>
          <target state="translated">Los rastros de pila larga están habilitados por defecto en la construcción de la depuración.</target>
        </trans-unit>
        <trans-unit id="5585738e86f015af086921d0b41e009a6fb65e3d" translate="yes" xml:space="preserve">
          <source>Long stack traces are only supported in Chrome, recent Firefoxes and Internet Explorer 10+</source>
          <target state="translated">Los rastros de pila larga sólo son compatibles con Chrome,los recientes Firefoxes e Internet Explorer 10+.</target>
        </trans-unit>
        <trans-unit id="9aba1e438bce5b03f5ff76a06150c5afd0f112d5" translate="yes" xml:space="preserve">
          <source>Long stack traces are supported now in IE10+</source>
          <target state="translated">Los rastros de pila larga son ahora soportados en IE10+</target>
        </trans-unit>
        <trans-unit id="0d4e72958bdd71df94bdc91c2471299f772d9de9" translate="yes" xml:space="preserve">
          <source>Long stack traces have been re-designed. They are now much more readable, succint, relevant and consistent across bluebird features.</source>
          <target state="translated">Se han rediseñado los rastros de la pila larga.Ahora son mucho más legibles,sucintas,relevantes y consistentes a través de los rasgos del pájaro azul.</target>
        </trans-unit>
        <trans-unit id="4d32bb2f1ca24d68c701d853a17b879746200c1e" translate="yes" xml:space="preserve">
          <source>Major debuggability improvements:</source>
          <target state="translated">Mejoras importantes en la depuración:</target>
        </trans-unit>
        <trans-unit id="4e7cd8e3e2364f713fb55eb6da548439b6487c93" translate="yes" xml:space="preserve">
          <source>Major internal refactoring related to testing code and source code file layout</source>
          <target state="translated">Refactorización interna importante relacionada con la prueba del código y la disposición de los archivos de código fuente</target>
        </trans-unit>
        <trans-unit id="7d05db1f390d07e6c3780eb841599459e0bc86db" translate="yes" xml:space="preserve">
          <source>Make .race() and Promise.race() forever pending on empty collections</source>
          <target state="translated">Hacer .race()y Promise.race()para siempre pendientes de colecciones vacías</target>
        </trans-unit>
        <trans-unit id="a958e3fae41091d69ad2857f0e309f4e5d0123cb" translate="yes" xml:space="preserve">
          <source>Make PromiseRejectionEvent confrom to spec (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1509&quot;&gt;&lt;code&gt;#1509&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Hacer PromiseRejectionEvent conforme a la especificaci&amp;oacute;n ( &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1509&quot;&gt; &lt;code&gt;#1509&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f545f488c8e51d1bcb95f6e96e06f76a78762db7" translate="yes" xml:space="preserve">
          <source>Make build script's output work without TTY</source>
          <target state="translated">Hacer que la salida del guión de construcción funcione sin TTY</target>
        </trans-unit>
        <trans-unit id="6de105dd31451a68ffa7b10edcdad659c72911a0" translate="yes" xml:space="preserve">
          <source>Make progress a core feature. Fixes &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/535&quot;&gt;&lt;code&gt;#535&lt;/code&gt;&lt;/a&gt; Note that progress has been removed in 3.x - this is only a fix necessary for 2.x custom builds.</source>
          <target state="translated">Haga del progreso una caracter&amp;iacute;stica central. Correcciones &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/535&quot;&gt; &lt;code&gt;#535&lt;/code&gt; &lt;/a&gt; Tenga en cuenta que el progreso se ha eliminado en 3.x: esta es solo una correcci&amp;oacute;n necesaria para las compilaciones personalizadas 2.x.</target>
        </trans-unit>
        <trans-unit id="d25de34f144aaa815f7ee100219c0875ec327f00" translate="yes" xml:space="preserve">
          <source>Make tests pass Internet Explorer 8</source>
          <target state="translated">Hacer que las pruebas pasen Internet Explorer 8</target>
        </trans-unit>
        <trans-unit id="2ae67022300ef1cd200bf479b96deb439531bc00" translate="yes" xml:space="preserve">
          <source>Managing resources properly without leaks can be challenging. Simply using &lt;code&gt;.finally&lt;/code&gt; is not enough as the following example demonstrates:</source>
          <target state="translated">Administrar los recursos adecuadamente sin fugas puede ser un desaf&amp;iacute;o. Simplemente usar &lt;code&gt;.finally&lt;/code&gt; no es suficiente como lo demuestra el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="107b1032597492e8483d652c4a4ce608f171eba8" translate="yes" xml:space="preserve">
          <source>Map Option: concurrency</source>
          <target state="translated">Opción de mapa:concurrencia</target>
        </trans-unit>
        <trans-unit id="a50a46e16b741d58429e4aa0f944bc0391ee46f8" translate="yes" xml:space="preserve">
          <source>Methods of &lt;code&gt;Promise&lt;/code&gt; instances and core static methods of the Promise class to deal with collections of promises or mixed promises and values.</source>
          <target state="translated">M&amp;eacute;todos de instancias de &lt;code&gt;Promise&lt;/code&gt; y m&amp;eacute;todos est&amp;aacute;ticos centrales de la clase Promise para tratar con colecciones de promesas o promesas y valores mixtos.</target>
        </trans-unit>
        <trans-unit id="ae38184c5e1cc02a77f22646c0e9e6fb64bf94fd" translate="yes" xml:space="preserve">
          <source>Methods on &lt;code&gt;Function.prototype&lt;/code&gt; are no longer promisified (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/680&quot;&gt;&lt;code&gt;#680&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Los m&amp;eacute;todos en &lt;code&gt;Function.prototype&lt;/code&gt; ya no se prometen ( &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/680&quot;&gt; &lt;code&gt;#680&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="af7ee6528f585594a5d8dbab3c9c2ad5078d7461" translate="yes" xml:space="preserve">
          <source>Minified source file meant to be used in production. Warnings and long straces are disabled. The gzipped size is 17.76KB.</source>
          <target state="translated">Un archivo de fuente minúsculo destinado a ser utilizado en la producción.Las advertencias y las largas rayas están desactivadas.El tamaño del gzip es de 17.76KB.</target>
        </trans-unit>
        <trans-unit id="cddf33528c938c1495240e1ee5dc6ea07a8ea077" translate="yes" xml:space="preserve">
          <source>Misc:</source>
          <target state="translated">Misc:</target>
        </trans-unit>
        <trans-unit id="cbb2eaaf602b7e2cec410e3a49e5f52907359976" translate="yes" xml:space="preserve">
          <source>Mongoose works with persistent connections and the driver takes care of reconnections/disposals. For this reason using &lt;code&gt;using&lt;/code&gt; with it isn't required - instead connect on server startup and use promisification to expose promises.</source>
          <target state="translated">Mongoose funciona con conexiones persistentes y el conductor se encarga de las reconexiones / disposiciones. Por esta raz&amp;oacute;n, no es necesario &lt;code&gt;using&lt;/code&gt; con &amp;eacute;l; en su lugar, con&amp;eacute;ctese al inicio del servidor y use la promisificaci&amp;oacute;n para exponer las promesas.</target>
        </trans-unit>
        <trans-unit id="bc8341442a59c4454f469778737b7b06e02ad229" translate="yes" xml:space="preserve">
          <source>Mongoose/MongoDB</source>
          <target state="translated">Mongoose/MongoDB</target>
        </trans-unit>
        <trans-unit id="331f3f9f6d3697a3169ac32b4263f8b1778c3e97" translate="yes" xml:space="preserve">
          <source>More Common Examples</source>
          <target state="translated">Más ejemplos comunes</target>
        </trans-unit>
        <trans-unit id="5623f76074955ea9ab1db3ab04c9bff15d87a6c2" translate="yes" xml:space="preserve">
          <source>More common examples</source>
          <target state="translated">Más ejemplos comunes</target>
        </trans-unit>
        <trans-unit id="eb77d4b0690c471c302bf76046f4c7afa76f3db6" translate="yes" xml:space="preserve">
          <source>More performance improvements when long stack traces are enabled</source>
          <target state="translated">Más mejoras en el rendimiento cuando se habilitan los rastros de pila larga</target>
        </trans-unit>
        <trans-unit id="3a7a86c3c7bb6f061ed4b7dd4612a07ea2e55494" translate="yes" xml:space="preserve">
          <source>More reading:</source>
          <target state="translated">Más lectura:</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="63cd8ad40499d81ac4cfa72cb023f0f0e2a46fc4" translate="yes" xml:space="preserve">
          <source>New in bluebird 3.0</source>
          <target state="translated">Nuevo en bluebird 3.0</target>
        </trans-unit>
        <trans-unit id="4c06116ec441fcbe51fa98c044bc02e5a87998c7" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promiseonunhandledrejectionhandledfunction-handler---undefined&quot;&gt;&lt;code&gt;Promise.onUnhandledRejectionHandled()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Nuevo m&amp;eacute;todo: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#promiseonunhandledrejectionhandledfunction-handler---undefined&quot;&gt; &lt;code&gt;Promise.onUnhandledRejectionHandled()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98ef7df279344d4e364f9fc4312d95513017e539" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#reason---dynamic&quot;&gt;&lt;code&gt;.reason()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Nuevo m&amp;eacute;todo: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#reason---dynamic&quot;&gt; &lt;code&gt;.reason()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7244a976bd562fa5bdab260bfa92ffb53b2f75df" translate="yes" xml:space="preserve">
          <source>New method: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#value---dynamic&quot;&gt;&lt;code&gt;.value()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Nuevo m&amp;eacute;todo: &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#value---dynamic&quot;&gt; &lt;code&gt;.value()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e97753de8b2fb704fe13fb56eee1b6956901e28" translate="yes" xml:space="preserve">
          <source>Node environment detection can no longer be fooled</source>
          <target state="translated">La detección del entorno del nodo ya no puede ser engañada</target>
        </trans-unit>
        <trans-unit id="36f139c394850c9c9489f54e55411c65c03b1e5e" translate="yes" xml:space="preserve">
          <source>Node installation</source>
          <target state="translated">Instalación del nodo</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="973a79d67e462fcd740058903de5ac75c5e42ed4" translate="yes" xml:space="preserve">
          <source>Node.js performance: promisified functions try to check amount of passed arguments in most optimal order</source>
          <target state="translated">Rendimiento de Node.js:las funciones prometidas intentan comprobar la cantidad de argumentos pasados en el orden más óptimo</target>
        </trans-unit>
        <trans-unit id="21d569f35ecd5c10a6a6f1ab8aec8e1753640885" translate="yes" xml:space="preserve">
          <source>Node.js promisified functions will have same &lt;code&gt;.length&lt;/code&gt; as the original function minus one (for the callback parameter)</source>
          <target state="translated">Las funciones prometidas de Node.js tendr&amp;aacute;n la misma &lt;code&gt;.length&lt;/code&gt; que la funci&amp;oacute;n original menos una (para el par&amp;aacute;metro de devoluci&amp;oacute;n de llamada)</target>
        </trans-unit>
        <trans-unit id="6c8c6cfa65668d483f7a4b264c38fc353e937af3" translate="yes" xml:space="preserve">
          <source>Nodeify doesn't pass second argument to the callback if the promise is fulfilled with &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">Nodeify no pasa el segundo argumento a la devoluci&amp;oacute;n de llamada si la promesa se cumple con &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5673141cf57847c5379b8f84249704a24a566a4" translate="yes" xml:space="preserve">
          <source>None of the collection methods modify the original input. Holes in arrays are treated as if they were defined with the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Ninguno de los m&amp;eacute;todos de recopilaci&amp;oacute;n modifica la entrada original. Los agujeros en las matrices se tratan como si estuvieran definidos con el valor &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e35ac0a9b7c71da68e4e0db0a51a9c2cf39da4d" translate="yes" xml:space="preserve">
          <source>Normal callbacks:</source>
          <target state="translated">Llamadas normales:</target>
        </trans-unit>
        <trans-unit id="0d7e35c7b10d9ccf8a2e395ca44cbdd4ab1c9fb3" translate="yes" xml:space="preserve">
          <source>Normally stack traces don't go beyond asynchronous boundaries so their utility is greatly reduced in asynchronous code:</source>
          <target state="translated">Normalmente los rastros apilados no van más allá de los límites asíncronos,por lo que su utilidad es muy reducida en el código asíncrono:</target>
        </trans-unit>
        <trans-unit id="5bbef690c10dd98cdafb9fad511260630850d165" translate="yes" xml:space="preserve">
          <source>Not only is the code shorter but more importantly, if there is any error it will propagate properly to the final consumer.</source>
          <target state="translated">El código no sólo es más corto,sino que,lo que es más importante,si hay algún error se propagará adecuadamente al consumidor final.</target>
        </trans-unit>
        <trans-unit id="601e20ca34667b0a121fe532f625d50ac9e32a89" translate="yes" xml:space="preserve">
          <source>Note - in order to get full stack traces with warnings in Node 6.x+ you need to enable to &lt;code&gt;--trace-warnings&lt;/code&gt; flag which will give you a full stack trace of where the warning is coming from.</source>
          <target state="translated">Nota: para obtener rastreos completos de la pila con advertencias en el Nodo 6.x +, debe habilitar el &lt;code&gt;--trace-warnings&lt;/code&gt; que le dar&amp;aacute; un rastro completo de la pila de donde proviene la advertencia.</target>
        </trans-unit>
        <trans-unit id="14f4f32d734d4dde2357de9c28aa2e9db4f442b8" translate="yes" xml:space="preserve">
          <source>Note about disposers in node</source>
          <target state="translated">Nota sobre los eliminadores en el nodo</target>
        </trans-unit>
        <trans-unit id="628368b01a8c147d7adbe65259137f54770d74df" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;spread&quot;&gt;&lt;code&gt;.spread()&lt;/code&gt;&lt;/a&gt; implicitly does &lt;a href=&quot;all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; but the ES6 destructuring syntax doesn't, hence the manual &lt;code&gt;.all()&lt;/code&gt; call in the above code.</source>
          <target state="translated">Tenga en cuenta que &lt;a href=&quot;spread&quot;&gt; &lt;code&gt;.spread()&lt;/code&gt; &lt;/a&gt; impl&amp;iacute;citamente hace &lt;a href=&quot;all&quot;&gt; &lt;code&gt;.all()&lt;/code&gt; &lt;/a&gt; pero la sintaxis de desestructuraci&amp;oacute;n ES6 no, de ah&amp;iacute; que la llamada manual &lt;code&gt;.all()&lt;/code&gt; en el c&amp;oacute;digo anterior.</target>
        </trans-unit>
        <trans-unit id="4f4cc52a9da922cd3c5be1d218aeb2480ead589e" translate="yes" xml:space="preserve">
          <source>Note that Mongoose already ships with promise support but the promises it offers are significantly slower and don't report unhandled rejections so it is recommended to use automatic promisification with it anyway:</source>
          <target state="translated">Nótese que Mangosta ya se embarca con el apoyo de la promesa,pero las promesas que ofrece son significativamente más lentas y no informan de rechazos no manejados,por lo que se recomienda utilizar la promesa automática con ella de todos modos:</target>
        </trans-unit>
        <trans-unit id="29e8a3550207f0693fbe258a0b408370b65284bd" translate="yes" xml:space="preserve">
          <source>Note that bind is only propagated with promise transformation. If you create new promise chains inside a handler, those chains are not bound to the &quot;upper&quot; &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Tenga en cuenta que la vinculaci&amp;oacute;n solo se propaga con la transformaci&amp;oacute;n de promesa. Si crea nuevas cadenas de promesa dentro de un controlador, esas cadenas no est&amp;aacute;n vinculadas al &quot;superior&quot; &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e18ae6fc287a535de54a7ef47226f40baba44a5f" translate="yes" xml:space="preserve">
          <source>Note that if the node function is a method of some object, you can pass the object as the second argument like so:</source>
          <target state="translated">Tenga en cuenta que si la función de nodo es un método de algún objeto,puede pasar el objeto como segundo argumento así:</target>
        </trans-unit>
        <trans-unit id="049b2f103da24d1cdf9b651db0f13464d2a62368" translate="yes" xml:space="preserve">
          <source>Note that if using ES6, the above can be replaced with &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; and destructuring:</source>
          <target state="translated">Tenga en cuenta que si usa ES6, lo anterior se puede reemplazar con &lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; y la desestructuraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e0a368b621b24c61956a2d40d7353ec38ebe9f4e" translate="yes" xml:space="preserve">
          <source>Note that if you have no use for the result object other than retrieving the properties, it is more convenient to use &lt;a href=&quot;promise.join&quot;&gt;&lt;code&gt;Promise.join&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Tenga en cuenta que si no utiliza el objeto de resultado que no sea recuperar las propiedades, es m&amp;aacute;s conveniente usar &lt;a href=&quot;promise.join&quot;&gt; &lt;code&gt;Promise.join&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3de0bd0db4f60bc1b355d5d97bda28262272a5e5" translate="yes" xml:space="preserve">
          <source>Note that it is an error to consume an already cancelled promise, doing such a thing will give you a promise that is rejected with &lt;code&gt;new CancellationError(&quot;late cancellation observer&quot;)&lt;/code&gt; as the rejection reason.</source>
          <target state="translated">Tenga en cuenta que es un error consumir una promesa ya cancelada, hacer tal cosa le dar&amp;aacute; una promesa que se rechaza con el &lt;code&gt;new CancellationError(&quot;late cancellation observer&quot;)&lt;/code&gt; como motivo de rechazo.</target>
        </trans-unit>
        <trans-unit id="7fba6dfbb297631502284b27e815e4abd333271d" translate="yes" xml:space="preserve">
          <source>Note that promises model a &lt;em&gt;single value through time&lt;/em&gt;, they only resolve &lt;em&gt;once&lt;/em&gt; - so while they're a good fit for a single event, they are not recommended for multiple event APIs.</source>
          <target state="translated">Tenga en cuenta que las promesas modelan un &lt;em&gt;valor &amp;uacute;nico a lo largo del tiempo&lt;/em&gt; , solo se resuelven &lt;em&gt;una vez&lt;/em&gt; , por lo que si bien son adecuadas para un solo evento, no se recomiendan para API de eventos m&amp;uacute;ltiples.</target>
        </trans-unit>
        <trans-unit id="6c0a18493f92a9cdbebf344b13ce97703f7982f1" translate="yes" xml:space="preserve">
          <source>Note that the 3.0.1 update is strictly speaking backward-incompatible with 3.0.0. Version 3.0.0 changed the previous behavior of the &lt;code&gt;.each&lt;/code&gt; method and made it work more same as the new &lt;code&gt;.mapSeries&lt;/code&gt; - 3.0.1 unrolls this change by reverting to the &lt;code&gt;.tap&lt;/code&gt;-like behavior found in 2.x However, this would only affect users who updated to 3.0.0 during the short time that it wasn't deprecated and started relying on the new &lt;code&gt;.each&lt;/code&gt; behavior. This seems unlikely, and therefore the major version was not changed.</source>
          <target state="translated">Tenga en cuenta que la actualizaci&amp;oacute;n 3.0.1 es estrictamente incompatible con versiones anteriores de 3.0.0. La versi&amp;oacute;n 3.0.0 cambi&amp;oacute; el comportamiento anterior del m&amp;eacute;todo &lt;code&gt;.each&lt;/code&gt; y lo hizo funcionar m&amp;aacute;s igual que el nuevo &lt;code&gt;.mapSeries&lt;/code&gt; - 3.0.1 desenrolla este cambio volviendo al comportamiento similar a &lt;code&gt;.tap&lt;/code&gt; que se encuentra en 2.x Sin embargo, esto solo afectar&amp;aacute; a los usuarios que actualizaron a 3.0.0 durante el breve per&amp;iacute;odo de tiempo que no fue desaprobado y comenzaron a confiar en el nuevo comportamiento &lt;code&gt;.each&lt;/code&gt; . Esto parece poco probable y, por lo tanto, la versi&amp;oacute;n principal no se modific&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="11cceaa640eecb54100f4808cad7ab17b5e595d4" translate="yes" xml:space="preserve">
          <source>Note that the 3.0.1 update is strictly speaking backward-incompatible with 3.0.0. Version 3.0.0 changed the previous behavior of the &lt;code&gt;.each&lt;/code&gt; method and made it work the same as the new &lt;code&gt;.mapSeries&lt;/code&gt; - 3.0.1 unrolls this change by reverting to the &lt;code&gt;.tap&lt;/code&gt;-like behavior found in 2.x However, this would only affect users who updated to 3.0.0 during the short time that it wasn't deprecated and started relying on the new &lt;code&gt;.each&lt;/code&gt; behavior. This seems unlikely, and therefore the major version was not changed.</source>
          <target state="translated">Tenga en cuenta que la actualizaci&amp;oacute;n 3.0.1 es, estrictamente hablando, incompatible con versiones anteriores de 3.0.0. La versi&amp;oacute;n 3.0.0 cambi&amp;oacute; el comportamiento anterior del m&amp;eacute;todo &lt;code&gt;.each&lt;/code&gt; y lo hizo funcionar igual que el nuevo &lt;code&gt;.mapSeries&lt;/code&gt; - 3.0.1 desenrolla este cambio volviendo al comportamiento similar a &lt;code&gt;.tap&lt;/code&gt; encontrado en 2.x Sin embargo, esto solo afectar a los usuarios que actualizaron a 3.0.0 durante el corto tiempo en que no estaba en desuso y comenzaron a confiar en el nuevo comportamiento de &lt;code&gt;.each&lt;/code&gt; . Esto parece poco probable y, por lo tanto, no se modific&amp;oacute; la versi&amp;oacute;n principal.</target>
        </trans-unit>
        <trans-unit id="ddb0ec4c290533d8d13b5512c50f3aff8444246e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;onCancel&lt;/code&gt; hook is really an optional disconnected optimization, there is no real requirement to register any cancellation hooks for cancellation to work. As such, any errors that may occur while inside the &lt;code&gt;onCancel&lt;/code&gt; callback are not caught and turned into rejections.</source>
          <target state="translated">Tenga en cuenta que el &lt;code&gt;onCancel&lt;/code&gt; es realmente una optimizaci&amp;oacute;n desconectada opcional, no existe un requisito real para registrar ning&amp;uacute;n enlace de cancelaci&amp;oacute;n para que la cancelaci&amp;oacute;n funcione. Como tal, cualquier error que pueda ocurrir mientras est&amp;aacute; dentro de la &lt;code&gt;onCancel&lt;/code&gt; llamada onCancel no se detecta y se convierte en rechazo.</target>
        </trans-unit>
        <trans-unit id="1635db28b0639fbcd8af0cf2d7a5c771bbc04b90" translate="yes" xml:space="preserve">
          <source>Note that the above is an exceptional case because &lt;code&gt;fs&lt;/code&gt; is a singleton instance. Most libraries can be promisified by requiring the library's classes (constructor functions) and calling promisifyAll on the &lt;code&gt;.prototype&lt;/code&gt;. This only needs to be done once in the entire application's lifetime and after that you may use the library's methods exactly as they are documented, except by appending the &lt;code&gt;&quot;Async&quot;&lt;/code&gt;-suffix to method calls and using the promise interface instead of the callback interface.</source>
          <target state="translated">Tenga en cuenta que lo anterior es un caso excepcional porque &lt;code&gt;fs&lt;/code&gt; es una instancia &amp;uacute;nica. La mayor&amp;iacute;a de las bibliotecas pueden ser promisificadas requiriendo las clases de la biblioteca (funciones de constructor) y llamando a promisifyAll en el &lt;code&gt;.prototype&lt;/code&gt; . Esto solo debe hacerse una vez durante toda la vida &amp;uacute;til de la aplicaci&amp;oacute;n y luego puede usar los m&amp;eacute;todos de la biblioteca exactamente como est&amp;aacute;n documentados, excepto agregando el sufijo &lt;code&gt;&quot;Async&quot;&lt;/code&gt; a las llamadas de m&amp;eacute;todo y usando la interfaz de promesa en lugar de la interfaz de devoluci&amp;oacute;n de llamada.</target>
        </trans-unit>
        <trans-unit id="684fbd25281e8e786735f4d9605ff396ce6c04e1" translate="yes" xml:space="preserve">
          <source>Note that the original methods on the object are not overwritten but new methods are created with the &lt;code&gt;Async&lt;/code&gt;-suffix. For example, if you &lt;code&gt;promisifyAll&lt;/code&gt; the node.js &lt;code&gt;fs&lt;/code&gt; object use &lt;code&gt;fs.statAsync&lt;/code&gt; to call the promisified &lt;code&gt;stat&lt;/code&gt; method.</source>
          <target state="translated">Tenga en cuenta que los m&amp;eacute;todos originales en el objeto no se sobrescriben, pero se crean m&amp;eacute;todos nuevos con &lt;code&gt;Async&lt;/code&gt; -suffix. Por ejemplo, si &lt;code&gt;promisifyAll&lt;/code&gt; el objeto node.js &lt;code&gt;fs&lt;/code&gt; , use &lt;code&gt;fs.statAsync&lt;/code&gt; para llamar al m&amp;eacute;todo &lt;code&gt;stat&lt;/code&gt; prometido .</target>
        </trans-unit>
        <trans-unit id="8918cb785368659b0f7041103fcbbc46ea52e50b" translate="yes" xml:space="preserve">
          <source>Note that you can mix promises and disposers, so that you can acquire all the things you need in parallel instead of sequentially</source>
          <target state="translated">Note que puede mezclar promesas y disposiciones,para que pueda adquirir todas las cosas que necesita en paralelo en vez de secuencialmente</target>
        </trans-unit>
        <trans-unit id="2203e249f5db0b7bf8e8cc90b06047ef5edc44d9" translate="yes" xml:space="preserve">
          <source>Note the new method is suffixed with &lt;code&gt;Async&lt;/code&gt;, as in &lt;code&gt;fs.readFileAsync&lt;/code&gt;. It did not replace the &lt;code&gt;fs.readFile&lt;/code&gt; function. Single functions can also be promisified for example:</source>
          <target state="translated">Tenga en cuenta que el nuevo m&amp;eacute;todo tiene el sufijo &lt;code&gt;Async&lt;/code&gt; , como en &lt;code&gt;fs.readFileAsync&lt;/code&gt; . No reemplaz&amp;oacute; la funci&amp;oacute;n &lt;code&gt;fs.readFile&lt;/code&gt; . Las funciones individuales tambi&amp;eacute;n pueden ser prometidas, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c1642a8259cf0bac4672e4af1533d8b457f9d5a0" translate="yes" xml:space="preserve">
          <source>Notice that use of &lt;code&gt;return this;&lt;/code&gt; in most of the functions? That pattern will allow method chaining as you'll see shortly.</source>
          <target state="translated">Tenga en cuenta que el uso de &lt;code&gt;return this;&lt;/code&gt; en la mayor&amp;iacute;a de las funciones? Ese patr&amp;oacute;n permitir&amp;aacute; el encadenamiento del m&amp;eacute;todo, como ver&amp;aacute; en breve.</target>
        </trans-unit>
        <trans-unit id="28b7a468a3970ae2784b6d1486ec7ed0a21533b5" translate="yes" xml:space="preserve">
          <source>Now if someone uses this function, they will catch all errors in their Promise &lt;code&gt;.catch&lt;/code&gt; handlers instead of having to handle both synchronous and asynchronous exception flows.</source>
          <target state="translated">Ahora, si alguien usa esta funci&amp;oacute;n, detectar&amp;aacute; todos los errores en sus controladores &lt;code&gt;.catch&lt;/code&gt; de Promise en lugar de tener que manejar los flujos de excepci&amp;oacute;n s&amp;iacute;ncronos y as&amp;iacute;ncronos.</target>
        </trans-unit>
        <trans-unit id="ae7be4be424720d6a240c42d8e70d90f0de37f8e" translate="yes" xml:space="preserve">
          <source>Now the animation is hidden but, unless it throws an exception, the function has no effect on the fulfilled or rejected value of the returned promise. This is similar to how the synchronous &lt;code&gt;finally&lt;/code&gt; keyword behaves.</source>
          <target state="translated">Ahora la animaci&amp;oacute;n est&amp;aacute; oculta pero, a menos que arroje una excepci&amp;oacute;n, la funci&amp;oacute;n no tiene efecto sobre el valor cumplido o rechazado de la promesa devuelta. Esto es similar a c&amp;oacute;mo &lt;code&gt;finally&lt;/code&gt; comporta finalmente la palabra clave s&amp;iacute;ncrona .</target>
        </trans-unit>
        <trans-unit id="fdea957426d725edc153e2fdbdd6516cd7a9e40a" translate="yes" xml:space="preserve">
          <source>Now to the fun part. For this tutorial we will &lt;em&gt;fake&lt;/em&gt; a lengthy file upload by using &lt;code&gt;setTimeout&lt;/code&gt;. The intent is to provide a promise and to allow a progress to be periodically ticked away. We will expect a function to be passed which is called whenever the progress needs updating. And it returns a promise.</source>
          <target state="translated">Ahora la parte divertida. Para este tutorial &lt;em&gt;falsificaremos la&lt;/em&gt; carga de un archivo largo usando &lt;code&gt;setTimeout&lt;/code&gt; . La intenci&amp;oacute;n es proporcionar una promesa y permitir que se marque peri&amp;oacute;dicamente un progreso. Esperaremos que se pase una funci&amp;oacute;n que se llama cada vez que se necesita actualizar el progreso. Y devuelve una promesa.</target>
        </trans-unit>
        <trans-unit id="f511b5b4eefa1fbd39717d9bca91d08c89eb55c8" translate="yes" xml:space="preserve">
          <source>Now we can add a &lt;code&gt;cancel()&lt;/code&gt; reject with this in our event listener:</source>
          <target state="translated">Ahora podemos agregar un rechazo &lt;code&gt;cancel()&lt;/code&gt; con esto en nuestro detector de eventos:</target>
        </trans-unit>
        <trans-unit id="dd58dca3cb5c00590780331e30aa954b4d6ecb97" translate="yes" xml:space="preserve">
          <source>Now when the user presses the &lt;strong&gt;Set Name&lt;/strong&gt; button the clock continues to update while the dialog is visible.</source>
          <target state="translated">Ahora, cuando el usuario presiona el bot&amp;oacute;n &lt;strong&gt;Establecer nombre,&lt;/strong&gt; el reloj contin&amp;uacute;a actualiz&amp;aacute;ndose mientras el di&amp;aacute;logo est&amp;aacute; visible.</target>
        </trans-unit>
        <trans-unit id="c1c4edbd07c221b59e680f6880827ab56a3c246a" translate="yes" xml:space="preserve">
          <source>Now, because there is no catch-all handler, if you typed &lt;code&gt;console.lag&lt;/code&gt; (causes an error you don't expect), you will see:</source>
          <target state="translated">Ahora, debido a que no hay un controlador general, si escribiste &lt;code&gt;console.lag&lt;/code&gt; (causa un error que no esperas), ver&amp;aacute;s:</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="d1d56bab874d88dafd718a2b7e212040a9f0e45f" translate="yes" xml:space="preserve">
          <source>Of course you could use hacks like monkey patching or domains but these break down when something can't be monkey patched or new apis are introduced.</source>
          <target state="translated">Por supuesto que puedes usar hacks como parches de mono o dominios pero estos se rompen cuando algo no puede ser parcheado por un mono o se introducen nuevos apis.</target>
        </trans-unit>
        <trans-unit id="f9466283542f875b75d8d6a69434fd428fb07f65" translate="yes" xml:space="preserve">
          <source>Often browser APIs are nonstandard and automatic promisification will fail for them. If you're running into an API that you can't promisify with &lt;a href=&quot;api/promisify&quot;&gt;&lt;code&gt;promisify&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/promisifyall&quot;&gt;&lt;code&gt;promisifyAll&lt;/code&gt;&lt;/a&gt; - please consult the &lt;a href=&quot;#working-with-any-other-apis&quot;&gt;working with other APIs section&lt;/a&gt;</source>
          <target state="translated">A menudo, las API del navegador no son est&amp;aacute;ndar y la promisificaci&amp;oacute;n autom&amp;aacute;tica fallar&amp;aacute; para ellos. Si se encuentra con una API que no puede prometer con &lt;a href=&quot;api/promisify&quot;&gt; &lt;code&gt;promisify&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;api/promisifyall&quot;&gt; &lt;code&gt;promisifyAll&lt;/code&gt; &lt;/a&gt; , consulte la &lt;a href=&quot;#working-with-any-other-apis&quot;&gt;secci&amp;oacute;n de trabajo con otras API&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09c49c4361b267a50eb7359cfbbb3c119709f70d" translate="yes" xml:space="preserve">
          <source>Often it is known in certain code paths that a promise is guaranteed to be fulfilled at that point - it would then be extremely inconvenient to use &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt; to get at the promise's value as the callback is always called asynchronously.</source>
          <target state="translated">A menudo se sabe en ciertas rutas de c&amp;oacute;digo que se garantiza que se cumple una promesa en ese punto; entonces ser&amp;iacute;a extremadamente inconveniente usar &lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt; para obtener el valor de la promesa, ya que la devoluci&amp;oacute;n de llamada siempre se llama de forma asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="ba70c55cb182e14f7aec5abbfd219d10161351d3" translate="yes" xml:space="preserve">
          <source>Often it is known in certain code paths that a promise is guaranteed to be fulfilled at that point - it would then be extremely inconvenient to use &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then&lt;/code&gt;&lt;/a&gt; to get at the promise's value as the callback is always called asynchronously.</source>
          <target state="translated">A menudo se sabe en ciertas rutas de c&amp;oacute;digo que se garantiza que se cumple una promesa en ese punto; entonces ser&amp;iacute;a extremadamente inconveniente usar &lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then&lt;/code&gt; &lt;/a&gt; para obtener el valor de la promesa, ya que la devoluci&amp;oacute;n de llamada siempre se llama de forma asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="fb455bed4997b8d29dbd05a23ac828990139aad3" translate="yes" xml:space="preserve">
          <source>Old Promise Cancellation</source>
          <target state="translated">Cancelación de la vieja promesa</target>
        </trans-unit>
        <trans-unit id="c2882dbf534ae9b61f7574e530dc35a635e26a00" translate="yes" xml:space="preserve">
          <source>On client side, long stack traces currently only work in recent Firefoxes, Chrome and Internet Explorer 10+.</source>
          <target state="translated">Del lado del cliente,los rastros de pila larga actualmente sólo funcionan en los recientes Firefox,Chrome e Internet Explorer 10+.</target>
        </trans-unit>
        <trans-unit id="4e5a14a36dfaaeaed4f8ef85cfc8efef0579501d" translate="yes" xml:space="preserve">
          <source>One could solve this by either reading the file first or connecting first, and only proceeding if the first step succeeds. However, this would lose a lot of the benefits of using asynchronity and we might almost as well go back to using simple synchronous code.</source>
          <target state="translated">Uno podría resolver esto leyendo el archivo primero o conectando primero,y sólo procediendo si el primer paso tiene éxito.Sin embargo,esto perdería muchos de los beneficios del uso de la asincronía y podríamos casi volver a usar un simple código síncrono.</target>
        </trans-unit>
        <trans-unit id="6d2c6e796751446bf03d009641c4f94308285962" translate="yes" xml:space="preserve">
          <source>One possible cause is using &lt;code&gt;.indexOf&lt;/code&gt; which returns &lt;code&gt;-1&lt;/code&gt; when it doesn't find the value being searched for.</source>
          <target state="translated">Una posible causa es usar &lt;code&gt;.indexOf&lt;/code&gt; que devuelve &lt;code&gt;-1&lt;/code&gt; cuando no encuentra el valor que se busca.</target>
        </trans-unit>
        <trans-unit id="3bebf09d62dbf5ff3d0ee7b594d24983d9fecce2" translate="yes" xml:space="preserve">
          <source>OperationalError</source>
          <target state="translated">OperationalError</target>
        </trans-unit>
        <trans-unit id="5b01979a9cdca6e73817895c6a9c23e60230c14d" translate="yes" xml:space="preserve">
          <source>OperationalError()</source>
          <target state="translated">OperationalError()</target>
        </trans-unit>
        <trans-unit id="104370c5891b8b4ba98b88fdedf6b3dd37566a91" translate="yes" xml:space="preserve">
          <source>Option: filter</source>
          <target state="translated">Opción:filtro</target>
        </trans-unit>
        <trans-unit id="fd4d82f7dc12888a6113e02d99a1cd1ae6480faa" translate="yes" xml:space="preserve">
          <source>Option: multiArgs</source>
          <target state="translated">Opción:multiArgs</target>
        </trans-unit>
        <trans-unit id="c7fb7b92da5e81c452b72cf73b9e7e606a4be8c6" translate="yes" xml:space="preserve">
          <source>Option: promisifier</source>
          <target state="translated">Opción:promisorio</target>
        </trans-unit>
        <trans-unit id="739bd13df9b75cbacc926456c2659db41a7a2e16" translate="yes" xml:space="preserve">
          <source>Option: spread</source>
          <target state="translated">Opción:extenderse</target>
        </trans-unit>
        <trans-unit id="c86f01917e960f8cf0838c6de23ce3408a649b20" translate="yes" xml:space="preserve">
          <source>Option: suffix</source>
          <target state="translated">Opción:sufijo</target>
        </trans-unit>
        <trans-unit id="ad34d2a8ce003a253f94ae6e4eb935a9468f0f43" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom filter through the options object:</source>
          <target state="translated">Opcionalmente,puede definir un filtro personalizado a través del objeto de opciones:</target>
        </trans-unit>
        <trans-unit id="8110acd1b3d0f8ca4e9e279edf4604f42dc6b48b" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom promisifier, so you could promisifyAll e.g. the chrome APIs used in Chrome extensions.</source>
          <target state="translated">Opcionalmente,puedes definir un promisorio personalizado,de modo que puedas prometer todo,por ejemplo,las API de Chrome utilizadas en las extensiones de Chrome.</target>
        </trans-unit>
        <trans-unit id="889a0e5ec1b3411c0cd35c6e73319943162df789" translate="yes" xml:space="preserve">
          <source>Optionally, you can define a custom suffix through the options object:</source>
          <target state="translated">Opcionalmente,puede definir un sufijo personalizado a través del objeto de opciones:</target>
        </trans-unit>
        <trans-unit id="d850b7adaa397dfa33c1141f5bb572b4b4cee8d2" translate="yes" xml:space="preserve">
          <source>Or to use &lt;a href=&quot;api/promise.coroutine.addyieldhandler&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler`&lt;/code&gt;&lt;/a&gt; to teach &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt; to accept these sort of values.</source>
          <target state="translated">O usar &lt;a href=&quot;api/promise.coroutine.addyieldhandler&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler`&lt;/code&gt; &lt;/a&gt; para ense&amp;ntilde;arle a &lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt; a aceptar este tipo de valores.</target>
        </trans-unit>
        <trans-unit id="24ea190190a1068b342fd38d88b87afd5b7878ff" translate="yes" xml:space="preserve">
          <source>Or you could take advantage of the fact that if we reach password validation, then the user promise must be fulfilled:</source>
          <target state="translated">O podría aprovechar el hecho de que si llegamos a la validación de la contraseña,entonces la promesa del usuario debe ser cumplida:</target>
        </trans-unit>
        <trans-unit id="0b17d6ff961144643224165079cbd11a9c6bc25a" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;PromptDialog&lt;/code&gt; class is responsible for inheriting from &lt;code&gt;Dialog&lt;/code&gt; and setting up the required DOM scaffolding and eventually call &lt;code&gt;this._okCallback&lt;/code&gt; or &lt;code&gt;this._cancelCallback&lt;/code&gt; as appropriate.</source>
          <target state="translated">Nuestra clase &lt;code&gt;PromptDialog&lt;/code&gt; es responsable de heredar de &lt;code&gt;Dialog&lt;/code&gt; y configurar el andamiaje DOM requerido y eventualmente llamar &lt;code&gt;this._okCallback&lt;/code&gt; o &lt;code&gt;this._cancelCallback&lt;/code&gt; seg&amp;uacute;n corresponda.</target>
        </trans-unit>
        <trans-unit id="57cb5629649d7407a80d8544726571004c96c657" translate="yes" xml:space="preserve">
          <source>PascalCase the suffix</source>
          <target state="translated">PascalCase el sufijo</target>
        </trans-unit>
        <trans-unit id="feee47953c269413e18b8e3f8b2d28f42be54e4a" translate="yes" xml:space="preserve">
          <source>Pass a handler that will be called regardless of this promise's fate. Returns a new promise chained from this promise. There are special semantics for &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; in that the final value cannot be modified from the handler.</source>
          <target state="translated">Pase un controlador que se llamar&amp;aacute; independientemente del destino de esta promesa. Devuelve una nueva promesa encadenada de esta promesa. Hay una sem&amp;aacute;ntica especial para &lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt; en que el valor final no se puede modificar desde el controlador.</target>
        </trans-unit>
        <trans-unit id="9b4b02b67bed0ffe4b0b1b17a183e58f6d178ecc" translate="yes" xml:space="preserve">
          <source>Pass it a constructor that inherits from &lt;code&gt;Error&lt;/code&gt;:</source>
          <target state="translated">P&amp;aacute;salo un constructor que hereda de &lt;code&gt;Error&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ef62afb0d13c7501004b9f7402ac0fe34f1df36d" translate="yes" xml:space="preserve">
          <source>Passing no value or a non-function will have the effect of removing any kind of handling for possibly unhandled rejections.</source>
          <target state="translated">No pasar ningún valor o una no función tendrá el efecto de eliminar cualquier tipo de manejo para los rechazos posiblemente no manejados.</target>
        </trans-unit>
        <trans-unit id="14a1550a1e49d7c4df7b61809151dec155b9464f" translate="yes" xml:space="preserve">
          <source>Performance improvements when long stack traces are enabled</source>
          <target state="translated">El rendimiento mejora cuando se habilitan los rastros de pila larga</target>
        </trans-unit>
        <trans-unit id="f6d83e264c56100a2c68d859c185e245cdf12d6c" translate="yes" xml:space="preserve">
          <source>Perhaps the greatest thing about promises is that it unifies all error handling into one mechanism where errors propagate automatically and have to be explicitly ignored.</source>
          <target state="translated">Tal vez lo más importante de las promesas es que unifica todo el manejo de los errores en un mecanismo en el que los errores se propagan automáticamente y tienen que ser explícitamente ignorados.</target>
        </trans-unit>
        <trans-unit id="13bc9fc907ba93237d886bb7661f405dca851032" translate="yes" xml:space="preserve">
          <source>Playing with the first example with and without limits, and seeing how it affects the duration when reading 20 files:</source>
          <target state="translated">Jugando con el primer ejemplo con y sin límites,y viendo cómo afecta a la duración al leer 20 archivos:</target>
        </trans-unit>
        <trans-unit id="5e982889494e481131cdc4a0b26924bfa22d7d53" translate="yes" xml:space="preserve">
          <source>Please consider reading about &lt;a href=&quot;api/new-promise&quot;&gt;&lt;code&gt;new Promise&lt;/code&gt;&lt;/a&gt; and also consider checking out automatic &lt;a href=&quot;api/promisification&quot;&gt;&lt;code&gt;promisification&lt;/code&gt;&lt;/a&gt; as well as &lt;a href=&quot;api/promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Por favor, considere la lectura sobre &lt;a href=&quot;api/new-promise&quot;&gt; &lt;code&gt;new Promise&lt;/code&gt; &lt;/a&gt; y tambi&amp;eacute;n considerar el registro de salida autom&amp;aacute;tica &lt;a href=&quot;api/promisification&quot;&gt; &lt;code&gt;promisification&lt;/code&gt; &lt;/a&gt; , as&amp;iacute; como &lt;a href=&quot;api/promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b51c4c13d41d7852eb369e20c236af48cef84cc" translate="yes" xml:space="preserve">
          <source>Please consider reading more about &lt;a href=&quot;api/synchronous-inspection&quot;&gt;&lt;code&gt;synchronous inspection&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Por favor considere leer m&amp;aacute;s sobre &lt;a href=&quot;api/synchronous-inspection&quot;&gt; &lt;code&gt;synchronous inspection&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e14f1308fe5c8dea2b2ef541f7aee826d27d5e0" translate="yes" xml:space="preserve">
          <source>Please consider reading the API docs for &lt;a href=&quot;api/some&quot;&gt;&lt;code&gt;.some&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Considere leer los documentos de API para &lt;a href=&quot;api/some&quot;&gt; &lt;code&gt;.some&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5ef6b96fc3e88fc35fff339fde30327dde1a698" translate="yes" xml:space="preserve">
          <source>Please refer to the relevant section in the documentation about &lt;a href=&quot;api/generators&quot;&gt;&lt;code&gt;Generators&lt;/code&gt;&lt;/a&gt; in order to get usage instructions:</source>
          <target state="translated">Consulte la secci&amp;oacute;n correspondiente en la documentaci&amp;oacute;n sobre &lt;a href=&quot;api/generators&quot;&gt; &lt;code&gt;Generators&lt;/code&gt; &lt;/a&gt; para obtener instrucciones de uso:</target>
        </trans-unit>
        <trans-unit id="5ad1bb14fb0bdc68c8977349fd048e917d0e042c" translate="yes" xml:space="preserve">
          <source>Please see the API docs of &lt;a href=&quot;api/catch&quot;&gt;&lt;code&gt;.catch()&lt;/code&gt;&lt;/a&gt; on how to use predicate catches.</source>
          <target state="translated">Consulte los documentos de API de &lt;a href=&quot;api/catch&quot;&gt; &lt;code&gt;.catch()&lt;/code&gt; &lt;/a&gt; sobre c&amp;oacute;mo usar capturas de predicados.</target>
        </trans-unit>
        <trans-unit id="7c7ed98d6ff8cb1bb3beee177d5536fda218b9d6" translate="yes" xml:space="preserve">
          <source>Possibly unhandled rejection handler will always get a stack trace, even if the rejection or thrown error was not an error</source>
          <target state="translated">El manipulador de rechazo posiblemente no manipulado siempre obtendrá un rastro de la pila,incluso si el rechazo o el error arrojado no fue un error</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="642cccd7308199d6f0935637f8e1d6bddc7a7f5d" translate="yes" xml:space="preserve">
          <source>Predicate functions that only check properties have a handy shorthand. In place of a predicate function, you can pass an object, and its properties will be checked against the error object for a match:</source>
          <target state="translated">Las funciones de predicción que sólo comprueban las propiedades tienen una taquigrafía práctica.En lugar de una función predicada,puede pasar un objeto,y sus propiedades serán comprobadas contra el objeto de error para una coincidencia:</target>
        </trans-unit>
        <trans-unit id="ef29f5e7937f710796c69d5f2e8ef62b93259503" translate="yes" xml:space="preserve">
          <source>Predicates should allow for very fine grained control over caught errors: pattern matching, error-type sets with set operations and many other techniques can be implemented on top of them.</source>
          <target state="translated">Los pronósticos deben permitir un control de grano muy fino sobre los errores detectados:se puede aplicar sobre ellos la comparación de patrones,conjuntos de tipos de error con operaciones establecidas y muchas otras técnicas.</target>
        </trans-unit>
        <trans-unit id="966e683ff73ac6a6ff53e83d6497f2f1ad6da22d" translate="yes" xml:space="preserve">
          <source>Preserve bound-with-promise promises across the entire chain (&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/702&quot;&gt;&lt;code&gt;#702&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Preserve las promesas vinculadas con las promesas en toda la cadena ( &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/702&quot;&gt; &lt;code&gt;#702&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b1d7cb674f49e0b746c342035d00a2302db4c737" translate="yes" xml:space="preserve">
          <source>Progress bar</source>
          <target state="translated">Barra de progreso</target>
        </trans-unit>
        <trans-unit id="51674123623b6ab6e8ea7ca7250debfd7286bf63" translate="yes" xml:space="preserve">
          <source>Progress the underlying promise with &lt;code&gt;value&lt;/code&gt; as the progression value.</source>
          <target state="translated">Progrese la promesa subyacente con &lt;code&gt;value&lt;/code&gt; como valor de progresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="685e262241d88a216ab9353d6e8f0939b5803641" translate="yes" xml:space="preserve">
          <source>Progression</source>
          <target state="translated">Progression</target>
        </trans-unit>
        <trans-unit id="25eee37f31e0eba9807d8e531ecf239e4d0cd542" translate="yes" xml:space="preserve">
          <source>Progression has been removed as there are composability and chaining issues with APIs that use promise progression handlers. Implementing the common use case of progress bars can be accomplished using a pattern similar to &lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx&quot;&gt;IProgress&lt;/a&gt; in C#.</source>
          <target state="translated">Se ha eliminado la progresi&amp;oacute;n, ya que existen problemas de encadenabilidad y compilabilidad con las API que utilizan controladores de progresi&amp;oacute;n prometedores. La implementaci&amp;oacute;n del caso de uso com&amp;uacute;n de las barras de progreso se puede lograr usando un patr&amp;oacute;n similar a &lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx&quot;&gt;IProgress&lt;/a&gt; en C #.</target>
        </trans-unit>
        <trans-unit id="3248b463906e068e9fcc220b46e1a5d372a78fb1" translate="yes" xml:space="preserve">
          <source>Progression migration</source>
          <target state="translated">Migración progresiva</target>
        </trans-unit>
        <trans-unit id="be45959fa7407eeadb36fe64732e21bc44a21868" translate="yes" xml:space="preserve">
          <source>Promise config returns reference to Bluebird library</source>
          <target state="translated">La configuración de Promise devuelve la referencia a la biblioteca de Bluebird</target>
        </trans-unit>
        <trans-unit id="fb6113ea309f0d5b9bec49fc1796cd040f492643" translate="yes" xml:space="preserve">
          <source>Promise exception handling mirrors native exception handling in JavaScript. A synchronous function &lt;code&gt;throw&lt;/code&gt;ing is similar to a promise rejecting. Here is an example to illustrate it:</source>
          <target state="translated">El manejo de excepciones prometedoras refleja el manejo de excepciones nativo en JavaScript. Una funci&amp;oacute;n de &lt;code&gt;throw&lt;/code&gt; sincr&amp;oacute;nico es similar a una promesa de rechazo. Aqu&amp;iacute; hay un ejemplo para ilustrarlo:</target>
        </trans-unit>
        <trans-unit id="8782a387409c7a9a87576a85d07c1e64505c1544" translate="yes" xml:space="preserve">
          <source>Promise monitoring</source>
          <target state="translated">La vigilancia de la promesa</target>
        </trans-unit>
        <trans-unit id="4dbc67ef437634d86ab184513509ef1b7aec9846" translate="yes" xml:space="preserve">
          <source>Promise nuggets</source>
          <target state="translated">Nuggets de promesa</target>
        </trans-unit>
        <trans-unit id="cd4139a3b1a43d871cf4ddb3e7a6d5193448c48c" translate="yes" xml:space="preserve">
          <source>Promise progression has been completely removed.</source>
          <target state="translated">La progresión de la promesa ha sido completamente eliminada.</target>
        </trans-unit>
        <trans-unit id="7726aabf1843e710a9f37fd6b562d6f56faa7e88" translate="yes" xml:space="preserve">
          <source>Promise resolution</source>
          <target state="translated">Resolución de la promesa</target>
        </trans-unit>
        <trans-unit id="65f81fcc4877a1e4dd84dd9b0c2863d1631025a9" translate="yes" xml:space="preserve">
          <source>Promise returning functions &lt;em&gt;should never throw&lt;/em&gt;, they should always successfully return a promise which is rejected in the case of an error. Throwing from a promise returning function will force you to use both a &lt;code&gt;} catch {&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; a &lt;code&gt;.catch&lt;/code&gt;. People using promisified APIs do not expect promises to throw. If you're not sure how async APIs work in JS - please &lt;a href=&quot;http://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;see this answer&lt;/a&gt; first.</source>
          <target state="translated">Las funciones de devoluci&amp;oacute;n de promesas &lt;em&gt;nunca deben arrojarse&lt;/em&gt; , siempre deben devolver con &amp;eacute;xito una promesa que se rechaza en caso de error. Lanzar desde una funci&amp;oacute;n de devoluci&amp;oacute;n de promesa lo obligar&amp;aacute; a usar tanto un &lt;code&gt;} catch {&lt;/code&gt; &lt;em&gt;como&lt;/em&gt; un &lt;code&gt;.catch&lt;/code&gt; . Las personas que usan API prometidas no esperan promesas. Si no est&amp;aacute; seguro de c&amp;oacute;mo funcionan las API as&amp;iacute;ncronas en JS, &lt;a href=&quot;http://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;consulte&lt;/a&gt; primero esta respuesta .</target>
        </trans-unit>
        <trans-unit id="32c88e7c01a53d5b288b9de6a6aab20cb547871d" translate="yes" xml:space="preserve">
          <source>Promise.all</source>
          <target state="translated">Promise.all</target>
        </trans-unit>
        <trans-unit id="a6755a6ad2728b869d475dc11ace6f3bf5ea4871" translate="yes" xml:space="preserve">
          <source>Promise.all()</source>
          <target state="translated">Promise.all()</target>
        </trans-unit>
        <trans-unit id="8a9f46eacb22a3bbe6409bdb49b4254651eff678" translate="yes" xml:space="preserve">
          <source>Promise.any</source>
          <target state="translated">Promise.any</target>
        </trans-unit>
        <trans-unit id="59a3e9eecb28443ad28e7c96175567acc96c62f3" translate="yes" xml:space="preserve">
          <source>Promise.any()</source>
          <target state="translated">Promise.any()</target>
        </trans-unit>
        <trans-unit id="380ddbb670a463da41bcb2f09102155dde8e708e" translate="yes" xml:space="preserve">
          <source>Promise.bind</source>
          <target state="translated">Promise.bind</target>
        </trans-unit>
        <trans-unit id="c504dbf7b03cd885ada0adc0180bde1c542f6ff6" translate="yes" xml:space="preserve">
          <source>Promise.bind()</source>
          <target state="translated">Promise.bind()</target>
        </trans-unit>
        <trans-unit id="94cffff23a1082b260d53b460f0199319830c332" translate="yes" xml:space="preserve">
          <source>Promise.config</source>
          <target state="translated">Promise.config</target>
        </trans-unit>
        <trans-unit id="14cca1b3fd91fce3c7d78898b9b8ab87641cd45f" translate="yes" xml:space="preserve">
          <source>Promise.config()</source>
          <target state="translated">Promise.config()</target>
        </trans-unit>
        <trans-unit id="0281c083d21b56d693df7c85bdc8760d5a153cb3" translate="yes" xml:space="preserve">
          <source>Promise.coroutine</source>
          <target state="translated">Promise.coroutine</target>
        </trans-unit>
        <trans-unit id="417c8a52e78b52649cc8c0d1a4a5c72e470fba46" translate="yes" xml:space="preserve">
          <source>Promise.coroutine()</source>
          <target state="translated">Promise.coroutine()</target>
        </trans-unit>
        <trans-unit id="1c7ffab7487989ed4fab5bf27ffc68d6a9e83f84" translate="yes" xml:space="preserve">
          <source>Promise.coroutine.addYieldHandler</source>
          <target state="translated">Promise.coroutine.addYieldHandler</target>
        </trans-unit>
        <trans-unit id="b32e1c4e626c99ffd6f0e20eaa5f3f6e5768bfd5" translate="yes" xml:space="preserve">
          <source>Promise.coroutine.addYieldHandler()</source>
          <target state="translated">Promise.coroutine.addYieldHandler()</target>
        </trans-unit>
        <trans-unit id="0eaf3c7722c589dfef45cece747a91a4f63eb1c4" translate="yes" xml:space="preserve">
          <source>Promise.delay</source>
          <target state="translated">Promise.delay</target>
        </trans-unit>
        <trans-unit id="b0fcfeaf123206f651b32c45d020a06c0161b597" translate="yes" xml:space="preserve">
          <source>Promise.delay()</source>
          <target state="translated">Promise.delay()</target>
        </trans-unit>
        <trans-unit id="58c05c22c80b95286ff97a890b8a711ca2bc4455" translate="yes" xml:space="preserve">
          <source>Promise.each</source>
          <target state="translated">Promise.each</target>
        </trans-unit>
        <trans-unit id="a620ec9f632f36f8a08e631069c08191868f6916" translate="yes" xml:space="preserve">
          <source>Promise.each()</source>
          <target state="translated">Promise.each()</target>
        </trans-unit>
        <trans-unit id="36ed6ee5c85807e4301bf69d782f38ceb4470326" translate="yes" xml:space="preserve">
          <source>Promise.filter</source>
          <target state="translated">Promise.filter</target>
        </trans-unit>
        <trans-unit id="86054f183176a3f69e770d2c34d2bdeae915a41e" translate="yes" xml:space="preserve">
          <source>Promise.filter()</source>
          <target state="translated">Promise.filter()</target>
        </trans-unit>
        <trans-unit id="98d41166fbaafb718942a7d54eb7a52ea584c71b" translate="yes" xml:space="preserve">
          <source>Promise.fromCallback</source>
          <target state="translated">Promise.fromCallback</target>
        </trans-unit>
        <trans-unit id="3f0b67925c3695da1eb2886d38a30665c003a3b1" translate="yes" xml:space="preserve">
          <source>Promise.fromCallback()</source>
          <target state="translated">Promise.fromCallback()</target>
        </trans-unit>
        <trans-unit id="fd3f3e356627367a0a1deb529a31724afae6adf2" translate="yes" xml:space="preserve">
          <source>Promise.getNewLibraryCopy</source>
          <target state="translated">Promise.getNewLibraryCopy</target>
        </trans-unit>
        <trans-unit id="89fb5dda745c6bafe6968a6f413760af47aceae1" translate="yes" xml:space="preserve">
          <source>Promise.getNewLibraryCopy()</source>
          <target state="translated">Promise.getNewLibraryCopy()</target>
        </trans-unit>
        <trans-unit id="40fdb4632aedb0a1797f0c8a54579a1fde171242" translate="yes" xml:space="preserve">
          <source>Promise.join</source>
          <target state="translated">Promise.join</target>
        </trans-unit>
        <trans-unit id="23d8f43c5ac526250cf76c302ad4119a7b1ab47b" translate="yes" xml:space="preserve">
          <source>Promise.join()</source>
          <target state="translated">Promise.join()</target>
        </trans-unit>
        <trans-unit id="7978c060e1559749beb237c1e2cd848a0c8c4d0d" translate="yes" xml:space="preserve">
          <source>Promise.map</source>
          <target state="translated">Promise.map</target>
        </trans-unit>
        <trans-unit id="ca13a4d72f15f0ca07d5d50979466ec8d5754e56" translate="yes" xml:space="preserve">
          <source>Promise.map()</source>
          <target state="translated">Promise.map()</target>
        </trans-unit>
        <trans-unit id="4228fbfb6f0c4ca7c03f7f3fe02a32213a675bb6" translate="yes" xml:space="preserve">
          <source>Promise.mapSeries</source>
          <target state="translated">Promise.mapSeries</target>
        </trans-unit>
        <trans-unit id="e726d78ebf8fa9e8d4dd4170765a788187160409" translate="yes" xml:space="preserve">
          <source>Promise.mapSeries()</source>
          <target state="translated">Promise.mapSeries()</target>
        </trans-unit>
        <trans-unit id="02c686952be30df3ceda356456842c51ca54d6b6" translate="yes" xml:space="preserve">
          <source>Promise.method</source>
          <target state="translated">Promise.method</target>
        </trans-unit>
        <trans-unit id="745df198c177406843ab6f0aef1a0ee5dfc83def" translate="yes" xml:space="preserve">
          <source>Promise.method()</source>
          <target state="translated">Promise.method()</target>
        </trans-unit>
        <trans-unit id="84f80dd435e5e59f09d00da45ff238df86a37a40" translate="yes" xml:space="preserve">
          <source>Promise.noConflict</source>
          <target state="translated">Promise.noConflict</target>
        </trans-unit>
        <trans-unit id="7531a2c2c6b7c98ad21e08d5e3ae1c19a0b22683" translate="yes" xml:space="preserve">
          <source>Promise.noConflict()</source>
          <target state="translated">Promise.noConflict()</target>
        </trans-unit>
        <trans-unit id="71c980a14f65b0a2704a085acb674ac28a814685" translate="yes" xml:space="preserve">
          <source>Promise.onPossiblyUnhandledRejection</source>
          <target state="translated">Promise.onPossiblyUnhandledRejection</target>
        </trans-unit>
        <trans-unit id="c371d88740f13aaaca5694582d4b3f1c2be33ab4" translate="yes" xml:space="preserve">
          <source>Promise.onPossiblyUnhandledRejection()</source>
          <target state="translated">Promise.onPossiblyUnhandledRejection()</target>
        </trans-unit>
        <trans-unit id="829674402143cb4c85191f62c464c46f218abca2" translate="yes" xml:space="preserve">
          <source>Promise.onUnhandledRejectionHandled</source>
          <target state="translated">Promise.onUnhandledRejectionHandled</target>
        </trans-unit>
        <trans-unit id="9c2cbfa68db14a1011a8bf225d1d930825635838" translate="yes" xml:space="preserve">
          <source>Promise.onUnhandledRejectionHandled()</source>
          <target state="translated">Promise.onUnhandledRejectionHandled()</target>
        </trans-unit>
        <trans-unit id="1bd4c78395725232fde1b79374d6efc9908e559c" translate="yes" xml:space="preserve">
          <source>Promise.promisify</source>
          <target state="translated">Promise.promisify</target>
        </trans-unit>
        <trans-unit id="1713f0d05877ab5fe29b2ac17f3c75196afacdff" translate="yes" xml:space="preserve">
          <source>Promise.promisify()</source>
          <target state="translated">Promise.promisify()</target>
        </trans-unit>
        <trans-unit id="97bebc26a4bce522904a06ed52ef00804ef373fc" translate="yes" xml:space="preserve">
          <source>Promise.promisifyAll</source>
          <target state="translated">Promise.promisifyAll</target>
        </trans-unit>
        <trans-unit id="582205a63795dfa2ded431e29909f2b0510003b9" translate="yes" xml:space="preserve">
          <source>Promise.promisifyAll()</source>
          <target state="translated">Promise.promisifyAll()</target>
        </trans-unit>
        <trans-unit id="27847ed541d9e1eeb76f5dbeb0044fcdbf775d18" translate="yes" xml:space="preserve">
          <source>Promise.props</source>
          <target state="translated">Promise.props</target>
        </trans-unit>
        <trans-unit id="4f38df349b880a0f534b640b3a8136437dece180" translate="yes" xml:space="preserve">
          <source>Promise.props now takes a &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/f41edac61b7c421608ff439bb5a09b7cffeadcf9/test/mocha/props.js#L197-L217&quot;&gt;thenable-for-collection&lt;/a&gt;</source>
          <target state="translated">Promise.props ahora toma un &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/f41edac61b7c421608ff439bb5a09b7cffeadcf9/test/mocha/props.js#L197-L217&quot;&gt;thenable-for-collection&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9db0fa212e5a187e62cb941c0f3eb586f29ed38d" translate="yes" xml:space="preserve">
          <source>Promise.props()</source>
          <target state="translated">Promise.props()</target>
        </trans-unit>
        <trans-unit id="6196396df0252ad4dc6749ba58e4f523ddc5109d" translate="yes" xml:space="preserve">
          <source>Promise.race</source>
          <target state="translated">Promise.race</target>
        </trans-unit>
        <trans-unit id="c805ba00efdcb8c7baa42fe61c954261ddd4c775" translate="yes" xml:space="preserve">
          <source>Promise.race()</source>
          <target state="translated">Promise.race()</target>
        </trans-unit>
        <trans-unit id="09422a77b11ac9569156f52e83edb0002c26642c" translate="yes" xml:space="preserve">
          <source>Promise.reduce</source>
          <target state="translated">Promise.reduce</target>
        </trans-unit>
        <trans-unit id="3036bc3d125176ce64d7f9e3b21c3e0d47ea6b85" translate="yes" xml:space="preserve">
          <source>Promise.reduce()</source>
          <target state="translated">Promise.reduce()</target>
        </trans-unit>
        <trans-unit id="783910d23dd1b1558a9b16d71c0ed4b397115fd3" translate="yes" xml:space="preserve">
          <source>Promise.reject</source>
          <target state="translated">Promise.reject</target>
        </trans-unit>
        <trans-unit id="8a2f2af4e6e3d7ca0c77296866bcfff0749f0dd9" translate="yes" xml:space="preserve">
          <source>Promise.reject()</source>
          <target state="translated">Promise.reject()</target>
        </trans-unit>
        <trans-unit id="0a3c75bb1d9e15c9996579992a0721a69da28c55" translate="yes" xml:space="preserve">
          <source>Promise.resolve</source>
          <target state="translated">Promise.resolve</target>
        </trans-unit>
        <trans-unit id="3cf132f388e7330298717bcc33a49e9f948aa7e5" translate="yes" xml:space="preserve">
          <source>Promise.resolve and PromiseResolver.resolve follow thenables too.</source>
          <target state="translated">Promise.resolve y PromiseResolver.resolve siguen también las mismas pautas.</target>
        </trans-unit>
        <trans-unit id="47b038849d964f2910c38df87756eeab2c33c845" translate="yes" xml:space="preserve">
          <source>Promise.resolve()</source>
          <target state="translated">Promise.resolve()</target>
        </trans-unit>
        <trans-unit id="2bd5fccacac7e4b32307e5e90275cc00e52adab2" translate="yes" xml:space="preserve">
          <source>Promise.setScheduler</source>
          <target state="translated">Promise.setScheduler</target>
        </trans-unit>
        <trans-unit id="4f357c9ea9b4ced021695eb3da83abef0f53a5bc" translate="yes" xml:space="preserve">
          <source>Promise.setScheduler()</source>
          <target state="translated">Promise.setScheduler()</target>
        </trans-unit>
        <trans-unit id="b2b14953357fd6fd7061ee19d3a46165592f8187" translate="yes" xml:space="preserve">
          <source>Promise.some</source>
          <target state="translated">Promise.some</target>
        </trans-unit>
        <trans-unit id="a7f83b619aac204250fe4b4b48cffc16048afd2a" translate="yes" xml:space="preserve">
          <source>Promise.some()</source>
          <target state="translated">Promise.some()</target>
        </trans-unit>
        <trans-unit id="bcaec27b9cbb2228f24361eaa259b8fadc6e76b0" translate="yes" xml:space="preserve">
          <source>Promise.try</source>
          <target state="translated">Promise.try</target>
        </trans-unit>
        <trans-unit id="285c74e7f15b5592587b905c39313a8c4c3631cd" translate="yes" xml:space="preserve">
          <source>Promise.try()</source>
          <target state="translated">Promise.try()</target>
        </trans-unit>
        <trans-unit id="54ae20ee3d30d8a4d9a8c3f51ddc74ab08078bce" translate="yes" xml:space="preserve">
          <source>Promise.using</source>
          <target state="translated">Promise.using</target>
        </trans-unit>
        <trans-unit id="d12fa97fde3870925fdf7d6a0ac552e0c8c9b94a" translate="yes" xml:space="preserve">
          <source>Promise.using()</source>
          <target state="translated">Promise.using()</target>
        </trans-unit>
        <trans-unit id="1a5d11d2f1ddb5249c87ef7bd69381bb0b693272" translate="yes" xml:space="preserve">
          <source>PromiseInspection</source>
          <target state="translated">PromiseInspection</target>
        </trans-unit>
        <trans-unit id="868dfb6858e3ed48b9b873232bb97b0244d9d0bf" translate="yes" xml:space="preserve">
          <source>Promises are a concurrency primitive with a proven track record and language integration in most modern programming languages. They have been extensively studied since the 80s and will make your life much easier.</source>
          <target state="translated">Las promesas son una primitiva concurrencia con un historial probado e integración de lenguaje en la mayoría de los lenguajes de programación modernos.Han sido ampliamente estudiadas desde los años 80 y harán tu vida mucho más fácil.</target>
        </trans-unit>
        <trans-unit id="4979e5d38a5edf382533cb2038c51eb19a4dee6f" translate="yes" xml:space="preserve">
          <source>Promises are now not cancellable by default. This is backwards incompatible change - see &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#cancellable---promise&quot;&gt;&lt;code&gt;.cancellable()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Las promesas ahora no se pueden cancelar por defecto. Este es un cambio incompatible hacia atr&amp;aacute;s: ver &lt;a href=&quot;https://github.com/petkaantonov/bluebird/blob/master/API.md#cancellable---promise&quot;&gt; &lt;code&gt;.cancellable()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed5dd788dfd2194a43ab6fd8c2d1b84eb1ecc96e" translate="yes" xml:space="preserve">
          <source>Promises can be rejected with falsy values (or no value at all, equal to rejecting with &lt;code&gt;undefined&lt;/code&gt;), however &lt;code&gt;.asCallback&lt;/code&gt; will call the callback with an &lt;code&gt;Error&lt;/code&gt; object if the promise's rejection reason is a falsy value. You can retrieve the original falsy value from the error's &lt;code&gt;.cause&lt;/code&gt; property.</source>
          <target state="translated">Las promesas pueden ser rechazadas con los valores Falsy (o ning&amp;uacute;n valor, equivalente a rechazar con &lt;code&gt;undefined&lt;/code&gt; ), sin embargo &lt;code&gt;.asCallback&lt;/code&gt; llamar&amp;aacute; a la devoluci&amp;oacute;n de llamada con un &lt;code&gt;Error&lt;/code&gt; objeto si el motivo de rechazo de la promesa es un valor Falsy. Puede recuperar el valor falso original de la propiedad &lt;code&gt;.cause&lt;/code&gt; del error .</target>
        </trans-unit>
        <trans-unit id="51f657ce6a52627dea6e94af335b6ca122d8163b" translate="yes" xml:space="preserve">
          <source>Promises can have a steep learning curve and it doesn't help that promise standards go out of their way to make it even harder. Bluebird works around the limitations by providing warnings where the standards disallow throwing errors when incorrect usage is detected. See &lt;a href=&quot;warning-explanations&quot;&gt;Warning Explanations&lt;/a&gt; for the possible warnings that bluebird covers.</source>
          <target state="translated">Las promesas pueden tener una curva de aprendizaje empinada y no ayuda que los est&amp;aacute;ndares de las promesas se salgan de su camino para hacerlo a&amp;uacute;n m&amp;aacute;s dif&amp;iacute;cil. Bluebird evita las limitaciones al proporcionar advertencias donde los est&amp;aacute;ndares no permiten errores de lanzamiento cuando se detecta un uso incorrecto. Consulte las &lt;a href=&quot;warning-explanations&quot;&gt;explicaciones de advertencia&lt;/a&gt; para ver las posibles advertencias que cubre bluebird.</target>
        </trans-unit>
        <trans-unit id="3be96f5495c2d83069fb9e4fe84ca585a4ab5539" translate="yes" xml:space="preserve">
          <source>Promises do not aim to solve such live updating problems directly. One option would be to use an intermediate promise - for example a &lt;code&gt;.loaded&lt;/code&gt; property on the model that fulfills with nothing.</source>
          <target state="translated">Las promesas no apuntan a resolver directamente tales problemas de actualizaci&amp;oacute;n en vivo. Una opci&amp;oacute;n ser&amp;iacute;a utilizar una promesa intermedia, por ejemplo, una propiedad &lt;code&gt;.loaded&lt;/code&gt; en el modelo que no cumple nada.</target>
        </trans-unit>
        <trans-unit id="63104f36ddfde5f398242d3c9a325847a623a94b" translate="yes" xml:space="preserve">
          <source>Promises have state, they start as pending and can settle to:</source>
          <target state="translated">Las promesas tienen un estado,empiezan como pendientes y pueden resolverse:</target>
        </trans-unit>
        <trans-unit id="dc07d53901ac77bfe4d99f439fd922d98f514777" translate="yes" xml:space="preserve">
          <source>Promises now clean up all references (to handlers, child promises etc) as soon as possible.</source>
          <target state="translated">Las promesas ahora limpian todas las referencias (a los manipuladores,promesas de niños,etc.)tan pronto como sea posible.</target>
        </trans-unit>
        <trans-unit id="4f7e995a45e8a7aa84e5616f32bd9b6d2f616aeb" translate="yes" xml:space="preserve">
          <source>Promises now delete references to handlers attached to them as soon as possible</source>
          <target state="translated">Las promesas ahora eliminan las referencias a los manipuladores adjuntos a ellas tan pronto como sea posible</target>
        </trans-unit>
        <trans-unit id="85f84a547296b83c2cd9be954bf35fa432933967" translate="yes" xml:space="preserve">
          <source>Promises perform a role similar to &lt;code&gt;IO&lt;/code&gt; in that they allow for easy chaining of asynchronous non-blocking operations. &lt;code&gt;Promise.coroutine&lt;/code&gt; can be seen as similar to &lt;code&gt;do&lt;/code&gt; notation although in practice it's not an accurate comparison.</source>
          <target state="translated">Las promesas desempe&amp;ntilde;an un papel similar al de &lt;code&gt;IO&lt;/code&gt; ,ya que permiten encadenar f&amp;aacute;cilmente las operaciones asincr&amp;oacute;nicas sin bloqueo. &lt;code&gt;Promise.coroutine&lt;/code&gt; puede ser visto como similar a &lt;code&gt;do&lt;/code&gt; la notaci&amp;oacute;n aunque en la pr&amp;aacute;ctica no es una comparaci&amp;oacute;n exacta.</target>
        </trans-unit>
        <trans-unit id="3e8ddebed649b44e7a85d5ae2af303397fa7ea81" translate="yes" xml:space="preserve">
          <source>Promises provide a lot of really cool and powerful guarantees like throw safety which are hard to provide when manually converting APIs to use promises. Thus, whenever it is possible to use the &lt;code&gt;Promise.promisify&lt;/code&gt; and &lt;code&gt;Promise.promisifyAll&lt;/code&gt; methods - we recommend you use them. Not only are they the safest form of conversion - they also use techniques of dynamic recompilation to introduce very little overhead.</source>
          <target state="translated">Las promesas brindan muchas garant&amp;iacute;as realmente geniales y potentes, como la seguridad de lanzamiento, que son dif&amp;iacute;ciles de proporcionar al convertir manualmente las API para usar promesas. Por lo tanto, siempre que sea posible usar los m&amp;eacute;todos &lt;code&gt;Promise.promisify&lt;/code&gt; y &lt;code&gt;Promise.promisifyAll&lt;/code&gt; , le recomendamos que los use. No solo son la forma m&amp;aacute;s segura de conversi&amp;oacute;n, sino que tambi&amp;eacute;n usan t&amp;eacute;cnicas de recompilaci&amp;oacute;n din&amp;aacute;mica para introducir muy poca sobrecarga.</target>
        </trans-unit>
        <trans-unit id="45fe5ca98fd7d2bd4d25dbf8138ba708e64fdca4" translate="yes" xml:space="preserve">
          <source>Promises returned by the &lt;code&gt;mapper&lt;/code&gt; function are awaited for and the returned promise doesn't fulfill until all mapped promises have fulfilled as well. If any promise in the array is rejected, or any promise returned by the &lt;code&gt;mapper&lt;/code&gt; function is rejected, the returned promise is rejected as well.</source>
          <target state="translated">Se esperan las promesas devueltas por la funci&amp;oacute;n de &lt;code&gt;mapper&lt;/code&gt; y la promesa devuelta no se cumple hasta que todas las promesas asignadas tambi&amp;eacute;n se hayan cumplido. Si se rechaza cualquier promesa en la matriz, o se rechaza cualquier promesa devuelta por la funci&amp;oacute;n de &lt;code&gt;mapper&lt;/code&gt; , la promesa devuelta tambi&amp;eacute;n se rechaza.</target>
        </trans-unit>
        <trans-unit id="7e30cdf817cbb4a8901ddafd58155a4d7d146650" translate="yes" xml:space="preserve">
          <source>Promises:</source>
          <target state="translated">Promises:</target>
        </trans-unit>
        <trans-unit id="7bdd89f28407b699d8b7e554f8c4f6ce47ea6c46" translate="yes" xml:space="preserve">
          <source>Promisification</source>
          <target state="translated">Promisification</target>
        </trans-unit>
        <trans-unit id="590f705f9b259c4f0eb3b51eea47cea46ae9c547" translate="yes" xml:space="preserve">
          <source>Promisification API changes</source>
          <target state="translated">Cambios en el API de la promisificación</target>
        </trans-unit>
        <trans-unit id="1a75c237f8187352ba7d075c4badc17c24ae0667" translate="yes" xml:space="preserve">
          <source>Promisification means converting an existing promise-unaware API to a promise-returning API.</source>
          <target state="translated">La promisificación significa convertir una API existente de promesa desconocida en una API de promesa que devuelve.</target>
        </trans-unit>
        <trans-unit id="f53b14543d28697f9e7972521e017a85547d2532" translate="yes" xml:space="preserve">
          <source>Promisification now consider all functions on the object and its prototype chain</source>
          <target state="translated">La promisificación ahora considera todas las funciones en el objeto y su cadena prototipo</target>
        </trans-unit>
        <trans-unit id="0968c7924c5fa044c0bc32de590809b8b7a0237f" translate="yes" xml:space="preserve">
          <source>Promisification on steroids</source>
          <target state="translated">Promisificación de los esteroides</target>
        </trans-unit>
        <trans-unit id="f0fa280902593381c17c8ba3cc647f71fd36f85f" translate="yes" xml:space="preserve">
          <source>Promisified methods from promisifyAll no longer call the original method when it is overriden</source>
          <target state="translated">Métodos prometidos de la promisión Todos ya no llaman al método original cuando es anulado</target>
        </trans-unit>
        <trans-unit id="852dd44380a8f2d2fa9332abfb43753326f8154b" translate="yes" xml:space="preserve">
          <source>Promisifier APIs.</source>
          <target state="translated">APIs de promotores.</target>
        </trans-unit>
        <trans-unit id="b7ec2af376bac24219fefb48cbd2c962d80ace5d" translate="yes" xml:space="preserve">
          <source>Promisifies the entire object by going through the object's properties and creating an async equivalent of each function on the object and its prototype chain. The promisified method name will be the original method name suffixed with &lt;code&gt;suffix&lt;/code&gt; (default is &lt;code&gt;&quot;Async&quot;&lt;/code&gt;). Any class properties of the object (which is the case for the main export of many modules) are also promisified, both static and instance methods. Class property is a property with a function value that has a non-empty &lt;code&gt;.prototype&lt;/code&gt; object. Returns the input object.</source>
          <target state="translated">Promete todo el objeto pasando por las propiedades del objeto y creando un equivalente as&amp;iacute;ncrono de cada funci&amp;oacute;n en el objeto y su cadena de prototipo. El nombre del m&amp;eacute;todo prometido ser&amp;aacute; el nombre del m&amp;eacute;todo original con &lt;code&gt;suffix&lt;/code&gt; (por defecto es &lt;code&gt;&quot;Async&quot;&lt;/code&gt; ). Tambi&amp;eacute;n se promete cualquier propiedad de clase del objeto (que es el caso de la exportaci&amp;oacute;n principal de muchos m&amp;oacute;dulos), tanto m&amp;eacute;todos est&amp;aacute;ticos como de instancia. La propiedad de clase es una propiedad con un valor de funci&amp;oacute;n que tiene un objeto &lt;code&gt;.prototype&lt;/code&gt; no vac&amp;iacute;o . Devuelve el objeto de entrada.</target>
        </trans-unit>
        <trans-unit id="7adb5806d2a6c639cdca0db8fdac9403bca0bc03" translate="yes" xml:space="preserve">
          <source>Promisifying multiple classes in one go</source>
          <target state="translated">Prometiendo múltiples clases de una sola vez</target>
        </trans-unit>
        <trans-unit id="c938fd9d6e36daebdbc0cf487cfd4869c4aa7f93" translate="yes" xml:space="preserve">
          <source>Proper version check supporting VSCode(&lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1576&quot;&gt;&lt;code&gt;#1576&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">Verificaci&amp;oacute;n de la versi&amp;oacute;n adecuada que admite VSCode ( &lt;a href=&quot;https://github.com/petkaantonov/bluebird/issues/1576&quot;&gt; &lt;code&gt;#1576&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="4177920eedb2d8d91fca3384f4b40aec4d20dcd2" translate="yes" xml:space="preserve">
          <source>Q and bluebird share a lot of common methods that nevertheless have different names:</source>
          <target state="translated">Q y el pájaro azul comparten muchos métodos comunes que,sin embargo,tienen nombres diferentes:</target>
        </trans-unit>
        <trans-unit id="e9f05aa2c47c6bff64cd5f9cf0a523af4429924d" translate="yes" xml:space="preserve">
          <source>Rate Limiting</source>
          <target state="translated">Limitación de la tasa</target>
        </trans-unit>
        <trans-unit id="161ffbbe54e77d4760152fa5b4074a0a6142966a" translate="yes" xml:space="preserve">
          <source>Read given files sequentially while summing their contents as an integer. Each file contains just the text &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">Lea los archivos dados secuencialmente mientras suma su contenido como un n&amp;uacute;mero entero. Cada archivo contiene solo el texto &lt;code&gt;10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26bb4a571dec15958b5bf88436f13b472b9923db" translate="yes" xml:space="preserve">
          <source>Real example 2:</source>
          <target state="translated">Ejemplo real 2:</target>
        </trans-unit>
        <trans-unit id="cf7056b7cac2c0b2ad06995c1808b40114dc8624" translate="yes" xml:space="preserve">
          <source>Real example:</source>
          <target state="translated">Un ejemplo real:</target>
        </trans-unit>
        <trans-unit id="ede0567a2a6e0fddab65269f6559f8f6dd06aeb3" translate="yes" xml:space="preserve">
          <source>Rebinding can also be abused to do something gratuitous like this:</source>
          <target state="translated">También se puede abusar de la rebeldía para hacer algo gratuito como esto:</target>
        </trans-unit>
        <trans-unit id="bf87a9a8812fbf363e857266207b8e2473838eca" translate="yes" xml:space="preserve">
          <source>Reduce minified full browser build file size by not including unused code generation functionality.</source>
          <target state="translated">Reducir el tamaño de los archivos de construcción del navegador completo y minificado al no incluir la funcionalidad de generación de código no utilizada.</target>
        </trans-unit>
        <trans-unit id="aef1e9eebf3f426cee92bf8ff691ff6719cedbd1" translate="yes" xml:space="preserve">
          <source>Register a node-style callback on this promise. When this promise is either fulfilled or rejected, the node callback will be called back with the node.js convention where error reason is the first argument and success value is the second argument. The error argument will be &lt;code&gt;null&lt;/code&gt; in case of success.</source>
          <target state="translated">Registre una devoluci&amp;oacute;n de llamada de estilo de nodo en esta promesa. Cuando esta promesa se cumple o se rechaza, la devoluci&amp;oacute;n de llamada del nodo se volver&amp;aacute; a llamar con la convenci&amp;oacute;n node.js donde la raz&amp;oacute;n del error es el primer argumento y el valor de &amp;eacute;xito es el segundo argumento. El argumento del error ser&amp;aacute; &lt;code&gt;null&lt;/code&gt; en caso de &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="e8d6efc26ea6904bda20ba7769db8ea12c079f56" translate="yes" xml:space="preserve">
          <source>Reject the underlying promise with &lt;code&gt;reason&lt;/code&gt; as the rejection reason.</source>
          <target state="translated">Rechace la promesa subyacente con la &lt;code&gt;reason&lt;/code&gt; como la raz&amp;oacute;n del rechazo.</target>
        </trans-unit>
        <trans-unit id="3368ac8416e6d7cbc9d06211f6a676de253db2de" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;Promise.reject&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Promise.reject&lt;/code&gt; procedentes de Promise.reject</target>
        </trans-unit>
        <trans-unit id="8b0dba4404c73e60c9ff9e9453523c35331ea038" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;PromiseResolver&lt;/code&gt; where &lt;code&gt;.reject()&lt;/code&gt; method is called explicitly</source>
          <target state="translated">&lt;code&gt;PromiseResolver&lt;/code&gt; originan en PromiseResolver donde se llama expl&amp;iacute;citamente al m&amp;eacute;todo &lt;code&gt;.reject()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41142268db768fb66fa944cf61f77fd9b9826e36" translate="yes" xml:space="preserve">
          <source>Rejections originating from &lt;code&gt;new Promise&lt;/code&gt; constructor where the &lt;code&gt;reject&lt;/code&gt; callback is called explicitly</source>
          <target state="translated">Rechazos que se originan en el &lt;code&gt;new Promise&lt;/code&gt; constructor de Promise donde la devoluci&amp;oacute;n de llamada de &lt;code&gt;reject&lt;/code&gt; se llama expl&amp;iacute;citamente</target>
        </trans-unit>
        <trans-unit id="4fe2d523f67748538641074127a1db6157d74f6a" translate="yes" xml:space="preserve">
          <source>Rejections originating from promisified callbacks which use the &lt;code&gt;errback&lt;/code&gt; argument</source>
          <target state="translated">Rechazos originados por devoluciones de llamada prometidas que usan el argumento &lt;code&gt;errback&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8eec88d2942215a1433216bd7c1c773ddcf67d09" translate="yes" xml:space="preserve">
          <source>Rejections originating from thenables using the &lt;code&gt;reject&lt;/code&gt; callback</source>
          <target state="translated">Rechazos que se originan de los elementos no utilizables utilizando la devoluci&amp;oacute;n de llamada de &lt;code&gt;reject&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="198141ba7b56bcf3bec5a18ddd355c8adf68088b" translate="yes" xml:space="preserve">
          <source>Release control of the &lt;code&gt;Promise&lt;/code&gt; namespace to whatever it was before this library was loaded. Returns a reference to the library namespace so you can attach it to something else.</source>
          <target state="translated">Libere el control del espacio de nombres &lt;code&gt;Promise&lt;/code&gt; a lo que sea antes de cargar esta biblioteca. Devuelve una referencia al espacio de nombres de la biblioteca para que pueda adjuntarlo a otra cosa.</target>
        </trans-unit>
        <trans-unit id="0181ee2fe3f8479b72a162b35eb3977b69562275" translate="yes" xml:space="preserve">
          <source>Remove dependency of es5-shim and es5-sham when using ES3.</source>
          <target state="translated">Eliminar la dependencia de es5-shim y es5-sham al usar ES3.</target>
        </trans-unit>
        <trans-unit id="e444431ea8965e36418e87f29f232d6f066fbe6e" translate="yes" xml:space="preserve">
          <source>Remove kew from benchmarks due to bugs in the library breaking the benchmark</source>
          <target state="translated">Quitar el kew de los puntos de referencia debido a los errores en la biblioteca que rompen el punto de referencia</target>
        </trans-unit>
        <trans-unit id="1a4dd4da1213db0bc986ba8e811f9173d4dfd37c" translate="yes" xml:space="preserve">
          <source>Remove memoization of thenables</source>
          <target state="translated">Eliminar la memorización de los entoncesables</target>
        </trans-unit>
        <trans-unit id="851f4336d464dd91890330239ecdcbcd3eede50c" translate="yes" xml:space="preserve">
          <source>Remove uses of dynamic evaluation (&lt;code&gt;new Function&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt; etc) when strictly not necessary. Use feature detection to use static evaluation to avoid errors when dynamic evaluation is prohibited.</source>
          <target state="translated">Elimine los usos de la evaluaci&amp;oacute;n din&amp;aacute;mica ( &lt;code&gt;new Function&lt;/code&gt; , &lt;code&gt;eval&lt;/code&gt; uaci&amp;oacute;n , etc.) cuando no sea estrictamente necesario. Utilice la detecci&amp;oacute;n de caracter&amp;iacute;sticas para usar la evaluaci&amp;oacute;n est&amp;aacute;tica para evitar errores cuando la evaluaci&amp;oacute;n din&amp;aacute;mica est&amp;eacute; prohibida.</target>
        </trans-unit>
        <trans-unit id="963bc143de16fd9c36ff8020e48785b4de1b5fa2" translate="yes" xml:space="preserve">
          <source>Removed the &lt;code&gt;.inspect()&lt;/code&gt; method</source>
          <target state="translated">Se elimin&amp;oacute; el m&amp;eacute;todo &lt;code&gt;.inspect()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73c105dee9adb30dced75f9d53b912f789492799" translate="yes" xml:space="preserve">
          <source>Rename PromiseResolver#asCallback to PromiseResolver#callback</source>
          <target state="translated">Cambiar el nombre de PromiseResolver a PromiseResolver por el de Callback.</target>
        </trans-unit>
        <trans-unit id="a93b7a7d13386c2b9229d1b2d9f532763ef7e300" translate="yes" xml:space="preserve">
          <source>Report unhandled rejections even when long stack traces are disabled</source>
          <target state="translated">Informar de rechazos no manejados incluso cuando los rastros de pila larga están desactivados</target>
        </trans-unit>
        <trans-unit id="212187c4ba067f96c7eec7538c40788ae9024465" translate="yes" xml:space="preserve">
          <source>Represents an error is an explicit promise rejection as opposed to a thrown error. For example, if an error is errbacked by a callback API promisified through &lt;a href=&quot;promise.promisify&quot;&gt;&lt;code&gt;Promise.promisify&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; and is not a typed error, it will be converted to a &lt;code&gt;OperationalError&lt;/code&gt; which has the original error in the &lt;code&gt;.cause&lt;/code&gt; property.</source>
          <target state="translated">Representa un error es un rechazo expl&amp;iacute;cito de la promesa en lugar de un error arrojado. Por ejemplo, si un error es devuelto por una API de devoluci&amp;oacute;n de llamada prometida a trav&amp;eacute;s de &lt;a href=&quot;promise.promisify&quot;&gt; &lt;code&gt;Promise.promisify&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; y no es un error escrito, se convertir&amp;aacute; en un &lt;code&gt;OperationalError&lt;/code&gt; que tiene el error original en la propiedad &lt;code&gt;.cause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f957ddaaf86217c5ba862399d723b49b7e0b15cb" translate="yes" xml:space="preserve">
          <source>Requires a statement so cannot be used in an expression context</source>
          <target state="translated">Requiere una declaración,por lo que no puede utilizarse en un contexto de expresión</target>
        </trans-unit>
        <trans-unit id="9c076f55ca621ae470e8e6540a2f2547c25d4dbe" translate="yes" xml:space="preserve">
          <source>Resolve the underlying promise with &lt;code&gt;value&lt;/code&gt; as the resolution value. If &lt;code&gt;value&lt;/code&gt; is a thenable or a promise, the underlying promise will assume its state.</source>
          <target state="translated">Resuelva la promesa subyacente con &lt;code&gt;value&lt;/code&gt; como valor de resoluci&amp;oacute;n. Si el &lt;code&gt;value&lt;/code&gt; es una promesa o una promesa, la promesa subyacente asumir&amp;aacute; su estado.</target>
        </trans-unit>
        <trans-unit id="78389e9ab495397e98445c046d321313be7d1269" translate="yes" xml:space="preserve">
          <source>Resolves to the original array unmodified, this method is meant to be used for side effects. If the iterator function returns a promise or a thenable, then the result of the promise is awaited, before continuing with next iteration.</source>
          <target state="translated">Resuelve a la matriz original sin modificar,este método está destinado a ser utilizado para los efectos secundarios.Si la función del iterador devuelve una promesa o una posibilidad,entonces se espera el resultado de la promesa,antes de continuar con la siguiente iteración.</target>
        </trans-unit>
        <trans-unit id="ce09507134e744cff09a805076e969ccb76e51c1" translate="yes" xml:space="preserve">
          <source>Resolves to the original array unmodified. This method is meant to be used for side effects.</source>
          <target state="translated">Resuelve la matriz original sin modificar.Este método está destinado a ser utilizado para los efectos secundarios.</target>
        </trans-unit>
        <trans-unit id="9e392aa0bd224f1b62eea587068fd172df50f2e7" translate="yes" xml:space="preserve">
          <source>Resource management</source>
          <target state="translated">Gestión de recursos</target>
        </trans-unit>
        <trans-unit id="0d5055e26e1fb07ecf2ddfcb210895ed4ebe7ce8" translate="yes" xml:space="preserve">
          <source>Rethink already uses Bluebird promises internally and has promise returning APIs. Use those.</source>
          <target state="translated">Rethink ya usa las promesas de Bluebird internamente y ha prometido devolver las APIs.Usa esas.</target>
        </trans-unit>
        <trans-unit id="89ddb5cfb70d8bad46dda602a6ccbd88515a58d8" translate="yes" xml:space="preserve">
          <source>RethinkDB</source>
          <target state="translated">RethinkDB</target>
        </trans-unit>
        <trans-unit id="48ceb22a9c112e78b0de9c59218daa18a395591e" translate="yes" xml:space="preserve">
          <source>Returns a Disposer object which encapsulates both the resource as well as the method to clean it up. The user can pass this object to &lt;code&gt;Promise.using&lt;/code&gt; to get access to the resource when it becomes available, as well as to ensure it's automatically cleaned up.</source>
          <target state="translated">Devuelve un objeto Disposer que encapsula tanto el recurso como el m&amp;eacute;todo para limpiarlo. El usuario puede pasar este objeto a &lt;code&gt;Promise.using&lt;/code&gt; para obtener acceso al recurso cuando est&amp;eacute; disponible, as&amp;iacute; como para asegurarse de que se limpie autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="5f6f3eb0a331057a9ce7728d16275ef0f0403798" translate="yes" xml:space="preserve">
          <source>Returns a function that can use &lt;code&gt;yield&lt;/code&gt; to yield promises. Control is returned back to the generator when the yielded promise settles. This can lead to less verbose code when doing lots of sequential async calls with minimal processing in between. Requires node.js 0.12+, io.js 1.0+ or Google Chrome 40+.</source>
          <target state="translated">Devuelve una funci&amp;oacute;n que puede usar el &lt;code&gt;yield&lt;/code&gt; para cumplir las promesas. El control se devuelve al generador cuando la promesa cedida se asienta. Esto puede conducir a un c&amp;oacute;digo menos detallado cuando se realizan muchas llamadas as&amp;iacute;ncronas secuenciales con un procesamiento m&amp;iacute;nimo en el medio. Requiere node.js 0.12+, io.js 1.0+ o Google Chrome 40+.</target>
        </trans-unit>
        <trans-unit id="0f8e633d273655fa3f1e81f2818120962168742f" translate="yes" xml:space="preserve">
          <source>Returns a function that will wrap the given &lt;code&gt;nodeFunction&lt;/code&gt;. Instead of taking a callback, the returned function will return a promise whose fate is decided by the callback behavior of the given node function. The node function should conform to node.js convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument.</source>
          <target state="translated">Devuelve una funci&amp;oacute;n que envolver&amp;aacute; la funci&amp;oacute;n de &lt;code&gt;nodeFunction&lt;/code&gt; dada . En lugar de tomar una devoluci&amp;oacute;n de llamada, la funci&amp;oacute;n devuelta devolver&amp;aacute; una promesa cuyo destino se decide por el comportamiento de devoluci&amp;oacute;n de llamada de la funci&amp;oacute;n de nodo dada. La funci&amp;oacute;n de nodo debe cumplir con la convenci&amp;oacute;n de node.js de aceptar una devoluci&amp;oacute;n de llamada como &amp;uacute;ltimo argumento y llamar a esa devoluci&amp;oacute;n de llamada con error como primer argumento y valor de &amp;eacute;xito en el segundo argumento.</target>
        </trans-unit>
        <trans-unit id="77302444e8cc66fc3523da337688a121188e8a8c" translate="yes" xml:space="preserve">
          <source>Returns a new function that wraps the given function &lt;code&gt;fn&lt;/code&gt;. The new function will always return a promise that is fulfilled with the original functions return values or rejected with thrown exceptions from the original function.</source>
          <target state="translated">Devuelve una nueva funci&amp;oacute;n que envuelve la funci&amp;oacute;n dada &lt;code&gt;fn&lt;/code&gt; . La nueva funci&amp;oacute;n siempre devolver&amp;aacute; una promesa que se cumple con los valores de retorno de las funciones originales o se rechaza con excepciones lanzadas de la funci&amp;oacute;n original.</target>
        </trans-unit>
        <trans-unit id="d0084f22c144f601402343afe0d33d4fb7f3e903" translate="yes" xml:space="preserve">
          <source>Returns a new independent copy of the Bluebird library.</source>
          <target state="translated">Devuelve una nueva copia independiente de la biblioteca de Bluebird.</target>
        </trans-unit>
        <trans-unit id="1b966690c369fe4ac468c8b47b2a688522f4806f" translate="yes" xml:space="preserve">
          <source>Returns a promise for an array that contains the values returned by the &lt;code&gt;iterator&lt;/code&gt; function in their respective positions. The iterator won't be called for an item until its previous item, and the promise returned by the iterator for that item are fulfilled. This results in a &lt;code&gt;mapSeries&lt;/code&gt; kind of utility but it can also be used simply as a side effect iterator similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array#forEach&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Devuelve una promesa para una matriz que contiene los valores devueltos por la funci&amp;oacute;n &lt;code&gt;iterator&lt;/code&gt; en sus respectivas posiciones. El iterador no ser&amp;aacute; llamado para un art&amp;iacute;culo hasta su art&amp;iacute;culo anterior, y la promesa devuelta por el iterador para ese art&amp;iacute;culo se cumple. Esto da como resultado una &lt;code&gt;mapSeries&lt;/code&gt; tipo mapSeries , pero tambi&amp;eacute;n se puede usar simplemente como un iterador de efectos secundarios similar a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array#forEach&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa83662ab7e1494742b674953702f77f5f38fa1" translate="yes" xml:space="preserve">
          <source>Returns a promise that is resolved by a node style callback function. This is the most fitting way to do on the fly promisification when libraries don't expose classes for automatic promisification by undefined.</source>
          <target state="translated">Devuelve una promesa que se resuelve con una función de devolución de llamada estilo nodo.Esta es la forma más adecuada de hacer la promisión sobre la marcha cuando las bibliotecas no exponen clases para la promisión automática por indefinido.</target>
        </trans-unit>
        <trans-unit id="4da867e8cf20d6ea986a5fd922cf7a1fb8f17c8a" translate="yes" xml:space="preserve">
          <source>Returns a promise that will be fulfilled with this promise's fulfillment value or rejection reason. However, if this promise is not fulfilled or rejected within &lt;code&gt;ms&lt;/code&gt; milliseconds, the returned promise is rejected with a &lt;a href=&quot;timeouterror&quot;&gt;&lt;code&gt;TimeoutError&lt;/code&gt;&lt;/a&gt; or the &lt;code&gt;error&lt;/code&gt; as the reason.</source>
          <target state="translated">Devuelve una promesa que se cumplir&amp;aacute; con el valor de cumplimiento de esta promesa o el motivo de rechazo. Sin embargo, si esta promesa no se cumple o rechaza dentro de &lt;code&gt;ms&lt;/code&gt; milisegundos, la promesa devuelta se rechaza con un &lt;a href=&quot;timeouterror&quot;&gt; &lt;code&gt;TimeoutError&lt;/code&gt; &lt;/a&gt; o el &lt;code&gt;error&lt;/code&gt; como la raz&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dd6aed551657efa53d35002ee36b6a3e0c3755d8" translate="yes" xml:space="preserve">
          <source>Returns a promise that will be resolved with &lt;code&gt;value&lt;/code&gt; (or &lt;code&gt;undefined&lt;/code&gt;) after given &lt;code&gt;ms&lt;/code&gt; milliseconds. If &lt;code&gt;value&lt;/code&gt; is a promise, the delay will start counting down when it is fulfilled and the returned promise will be fulfilled with the fulfillment value of the &lt;code&gt;value&lt;/code&gt; promise. If &lt;code&gt;value&lt;/code&gt; is a rejected promise, the resulting promise will be rejected immediately.</source>
          <target state="translated">Devuelve una promesa que se resolver&amp;aacute; con &lt;code&gt;value&lt;/code&gt; (o &lt;code&gt;undefined&lt;/code&gt; ) despu&amp;eacute;s de &lt;code&gt;ms&lt;/code&gt; milisegundos. Si el &lt;code&gt;value&lt;/code&gt; es una promesa, la demora comenzar&amp;aacute; una cuenta regresiva cuando se cumpla y la promesa devuelta se cumplir&amp;aacute; con el valor de cumplimiento de la promesa de &lt;code&gt;value&lt;/code&gt; . Si el &lt;code&gt;value&lt;/code&gt; es una promesa rechazada, la promesa resultante ser&amp;aacute; rechazada de inmediato.</target>
        </trans-unit>
        <trans-unit id="0baaeaec06f70621397f1ef99fcbfb8ddf084acc" translate="yes" xml:space="preserve">
          <source>Returns back this promise instead of creating a new one. If the &lt;code&gt;callback&lt;/code&gt; argument is not a function, this method does not do anything.</source>
          <target state="translated">Devuelve esta promesa en lugar de crear una nueva. Si el argumento de &lt;code&gt;callback&lt;/code&gt; no es una funci&amp;oacute;n, este m&amp;eacute;todo no hace nada.</target>
        </trans-unit>
        <trans-unit id="f7778ce7c8366fce862636b34420e6d9618d48dd" translate="yes" xml:space="preserve">
          <source>Revert monitoring feature due to crash in browser</source>
          <target state="translated">Revertir la función de vigilancia debido a la caída del navegador</target>
        </trans-unit>
        <trans-unit id="48334a9d7741c7c5b6ebf7eef29195609c38e705" translate="yes" xml:space="preserve">
          <source>Rollback non-working multiple fresh copies feature</source>
          <target state="translated">La función de copias múltiples y frescas de Rollback que no funciona...</target>
        </trans-unit>
        <trans-unit id="af2379a3b3b95738bc09586b8c9af459a812b070" translate="yes" xml:space="preserve">
          <source>Run example on JSBin</source>
          <target state="translated">Ejecutar el ejemplo en JSBin</target>
        </trans-unit>
        <trans-unit id="080508f70cca7834ce2ef4eef4f37dd98ffff2b4" translate="yes" xml:space="preserve">
          <source>Running the example:</source>
          <target state="translated">Ejecutando el ejemplo:</target>
        </trans-unit>
        <trans-unit id="e2fa217fe73b363a41e739397cee0e3ca1933591" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.all&quot;&gt;&lt;code&gt;Promise.all(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Igual que &lt;a href=&quot;promise.all&quot;&gt; &lt;code&gt;Promise.all(this)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b23caad0148511b77a2cf241f932d7c6709a7d3" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.any&quot;&gt;&lt;code&gt;Promise.any(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Igual que &lt;a href=&quot;promise.any&quot;&gt; &lt;code&gt;Promise.any(this)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="580ea88db97d01930313a97fceee680b30d45b7d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.filter&quot;&gt;&lt;code&gt;Promise.filter(this, filterer, options)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Igual que &lt;a href=&quot;promise.filter&quot;&gt; &lt;code&gt;Promise.filter(this, filterer, options)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="975ef8a2ddc0a473b966c6a5cf58d6b15ce60290" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.map&quot;&gt;&lt;code&gt;Promise.map(this, mapper, options)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Igual que &lt;a href=&quot;promise.map&quot;&gt; &lt;code&gt;Promise.map(this, mapper, options)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6801edeea7902bcdcddad94e4e019a39b6cf35a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries(this, iterator)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Igual que &lt;a href=&quot;promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries(this, iterator)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8c55e09fe61d7950e9b369ac035513826c1d2a6" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.props&quot;&gt;&lt;code&gt;Promise.props(this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Igual que &lt;a href=&quot;promise.props&quot;&gt; &lt;code&gt;Promise.props(this)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a380c08b4944e2caae2cd146735f961151b5e6e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.reduce&quot;&gt;&lt;code&gt;Promise.reduce(this, reducer, initialValue)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Igual que &lt;a href=&quot;promise.reduce&quot;&gt; &lt;code&gt;Promise.reduce(this, reducer, initialValue)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a356dad7c25106bdfd17533e6d57d965a40a5a84" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;promise.some&quot;&gt;&lt;code&gt;Promise.some(this, count)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Igual que &lt;a href=&quot;promise.some&quot;&gt; &lt;code&gt;Promise.some(this, count)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6cc344c16a1e8b60323a0d888ae481c9928a8ab" translate="yes" xml:space="preserve">
          <source>Same as calling &lt;a href=&quot;promise.bind&quot;&gt;&lt;code&gt;Promise.bind(thisArg, thisPromise)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Lo mismo que llamar a &lt;a href=&quot;promise.bind&quot;&gt; &lt;code&gt;Promise.bind(thisArg, thisPromise)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e458385af15b3281d6aad96024285a33aab42f7e" translate="yes" xml:space="preserve">
          <source>Same as calling &lt;a href=&quot;promise.delay&quot;&gt;&lt;code&gt;Promise.delay(ms, this)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Igual que llamar a &lt;a href=&quot;promise.delay&quot;&gt; &lt;code&gt;Promise.delay(ms, this)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2c078b3023463c3ffc03ea245f314b93b9997db" translate="yes" xml:space="preserve">
          <source>Same limitations regarding to the binding time of &lt;code&gt;reason&lt;/code&gt; to apply as with &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Las mismas limitaciones con respecto al tiempo vinculante de la &lt;code&gt;reason&lt;/code&gt; para aplicar como con &lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5f6c90a1ad0cebcb9beb15aafa1cb6735ec4a6f" translate="yes" xml:space="preserve">
          <source>Same limitations regarding to the binding time of &lt;code&gt;value&lt;/code&gt; to apply as with &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Las mismas limitaciones con respecto al tiempo vinculante de &lt;code&gt;value&lt;/code&gt; para aplicar que con &lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b7e70bcf209a5323526033a9cbf768a3ae70c2c" translate="yes" xml:space="preserve">
          <source>Scala</source>
          <target state="translated">Scala</target>
        </trans-unit>
        <trans-unit id="4c8d353832617594b0903e9beaf0a3bc9414fd0a" translate="yes" xml:space="preserve">
          <source>Scheduler should be a function that asynchronously schedules the calling of the passed in function:</source>
          <target state="translated">El programador debe ser una función que programe asincrónicamente la llamada de la función pasada:</target>
        </trans-unit>
        <trans-unit id="b6e22d4f13d0bc08ae5171b4f3faa591b3854aba" translate="yes" xml:space="preserve">
          <source>Scoped prototypes</source>
          <target state="translated">Prototipos de alcance</target>
        </trans-unit>
        <trans-unit id="1e4c2c805f8ac17da444424c8f8bf077911b3260" translate="yes" xml:space="preserve">
          <source>Second example is creating a function that does nothing but manually wrap a callback API and doing a poor job at that:</source>
          <target state="translated">El segundo ejemplo es crear una función que no hace más que envolver manualmente una API de devolución de llamada y hacer un mal trabajo en eso:</target>
        </trans-unit>
        <trans-unit id="c651da6b87ea51d587627a0d63283b28e42fd9e4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#map-option-concurrency&quot;&gt;Map Option: concurrency&lt;/a&gt;</source>
          <target state="translated">Ver &lt;a href=&quot;#map-option-concurrency&quot;&gt;Opci&amp;oacute;n de Mapa: concurrencia&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fc2fab79463362dbab8dbab63714a6f37b5961f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#promisification&quot;&gt;promisification&lt;/a&gt; for more examples.</source>
          <target state="translated">Ver &lt;a href=&quot;#promisification&quot;&gt;promisificaci&amp;oacute;n&lt;/a&gt; para m&amp;aacute;s ejemplos.</target>
        </trans-unit>
        <trans-unit id="23a68335a77ae0704a80f59d32facaab6ffbdba9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/cancellation&quot;&gt;&lt;code&gt;Cancellation&lt;/code&gt;&lt;/a&gt; for how to use cancellation.</source>
          <target state="translated">Vea &lt;a href=&quot;api/cancellation&quot;&gt; &lt;code&gt;Cancellation&lt;/code&gt; &lt;/a&gt; para saber c&amp;oacute;mo usar la cancelaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5f52e149e8a0803d7f7b841c33681f919e936364" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/environment-variables&quot;&gt;&lt;code&gt;Environment Variables&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ver &lt;a href=&quot;api/environment-variables&quot;&gt; &lt;code&gt;Environment Variables&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab38b0ca0dbd1886ea0aa3b5d41ba2fd2e703bb5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/error-management-configuration#global-rejection-events&quot;&gt;global rejection events&lt;/a&gt; to learn more about the hooks.</source>
          <target state="translated">Vea &lt;a href=&quot;api/error-management-configuration#global-rejection-events&quot;&gt;los eventos de rechazo global&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre los ganchos.</target>
        </trans-unit>
        <trans-unit id="06395aee9e31cf27b400d0aac841e6752959ba6e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api/progression-migration&quot;&gt;Progression Migration&lt;/a&gt; for migration assistance and examples of how to convert APIs that use progression to ones that do not.</source>
          <target state="translated">Consulte &lt;a href=&quot;api/progression-migration&quot;&gt;Migraci&amp;oacute;n de progresi&amp;oacute;n&lt;/a&gt; para obtener ayuda con la migraci&amp;oacute;n y ejemplos de c&amp;oacute;mo convertir API que usan progresi&amp;oacute;n a otras que no.</target>
        </trans-unit>
        <trans-unit id="68ba78b1d14da78646ebff542d287d69dbc5a960" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/a/17891099/227176&quot;&gt;this StackOverflow answer&lt;/a&gt; for a more detailed and feature complete way to make custom errors.</source>
          <target state="translated">Consulte &lt;a href=&quot;http://stackoverflow.com/a/17891099/227176&quot;&gt;esta respuesta de StackOverflow&lt;/a&gt; para obtener una forma m&amp;aacute;s detallada y completa de cometer errores personalizados.</target>
        </trans-unit>
        <trans-unit id="06706fc1eca556ceadf36cdc2fed09eb5719e880" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala&quot;&gt;this question on StackOverflow&lt;/a&gt; for more differences.</source>
          <target state="translated">Vea &lt;a href=&quot;http://stackoverflow.com/questions/22724883/js-deferred-promise-future-compared-to-functional-languages-like-scala&quot;&gt;esta pregunta en StackOverflow&lt;/a&gt; para m&amp;aacute;s diferencias.</target>
        </trans-unit>
        <trans-unit id="87f924e288cbca74d9deadff4feb3964dc20a0cb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://stackoverflow.com/questions/26136389/how-can-i-realize-pattern-promise-deffered&quot;&gt;this question on StackOverflow&lt;/a&gt; for more differences.</source>
          <target state="translated">Vea &lt;a href=&quot;http://stackoverflow.com/questions/26136389/how-can-i-realize-pattern-promise-deffered&quot;&gt;esta pregunta en StackOverflow&lt;/a&gt; para m&amp;aacute;s diferencias.</target>
        </trans-unit>
        <trans-unit id="6b47ded2bd3e84b6a1d18b1f7005536f6c95a4c4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to enable long stack traces in your environment.</source>
          <target state="translated">Consulte la &lt;a href=&quot;install&quot;&gt;instalaci&amp;oacute;n&lt;/a&gt; sobre c&amp;oacute;mo habilitar rastreos largos de pila en su entorno.</target>
        </trans-unit>
        <trans-unit id="40938884818bf7e771e25611b0ecc72ecf13d826" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to enable warnings in your environment.</source>
          <target state="translated">Consulte la &lt;a href=&quot;install&quot;&gt;instalaci&amp;oacute;n&lt;/a&gt; sobre c&amp;oacute;mo habilitar las advertencias en su entorno.</target>
        </trans-unit>
        <trans-unit id="fd18968e9220ec2edbcb69219a62b308e07af8ca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;new-in-bluebird-3&quot;&gt;New in 3.0&lt;/a&gt;.</source>
          <target state="translated">Ver &lt;a href=&quot;new-in-bluebird-3&quot;&gt;nuevo en 3.0&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a128fef004cd14934d7a35ae580447b292348acd" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ver tambi&amp;eacute;n &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c964d6768cfba0357dc178ad5c1c5b834096887" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Ver tambi&amp;eacute;n &lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec633a7c6034c365e8ffcaf57fd91b71d7eba69d" translate="yes" xml:space="preserve">
          <source>See if this &lt;code&gt;promise&lt;/code&gt; has been cancelled.</source>
          <target state="translated">Vea si esta &lt;code&gt;promise&lt;/code&gt; ha sido cancelada.</target>
        </trans-unit>
        <trans-unit id="e2ba106a736de3c98da11dcab4e39f4c475860bf" translate="yes" xml:space="preserve">
          <source>See if this &lt;code&gt;promise&lt;/code&gt; is pending (not fulfilled or rejected or cancelled).</source>
          <target state="translated">Vea si esta &lt;code&gt;promise&lt;/code&gt; est&amp;aacute; pendiente (no cumplida, rechazada o cancelada).</target>
        </trans-unit>
        <trans-unit id="43f5e31f9196af8cf21954e2abe72267402aeb61" translate="yes" xml:space="preserve">
          <source>See if this promise has been fulfilled.</source>
          <target state="translated">Ver si esta promesa se ha cumplido.</target>
        </trans-unit>
        <trans-unit id="a4923f987cce26c1b5f0647eecfad58c0130790b" translate="yes" xml:space="preserve">
          <source>See if this promise has been rejected.</source>
          <target state="translated">Mira si esta promesa ha sido rechazada.</target>
        </trans-unit>
        <trans-unit id="00853e3a835e9b91810aba99eb34ee3eaa60c4cf" translate="yes" xml:space="preserve">
          <source>See the API on &lt;a href=&quot;api/synchronous-inspection&quot;&gt;&lt;code&gt;synchronous inspection&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">Consulte la API sobre &lt;a href=&quot;api/synchronous-inspection&quot;&gt; &lt;code&gt;synchronous inspection&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b6d3dd68401ad34ac91e21bd296d96dcc691d3a3" translate="yes" xml:space="preserve">
          <source>See the API page about &lt;a href=&quot;api/promise.longstacktraces&quot;&gt;&lt;code&gt;Promise.longStackTraces&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Vea la p&amp;aacute;gina API sobre &lt;a href=&quot;api/promise.longstacktraces&quot;&gt; &lt;code&gt;Promise.longStackTraces&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32248b4544c4dacee860f46416e5a89b6310bc5c" translate="yes" xml:space="preserve">
          <source>Sequelize</source>
          <target state="translated">Sequelize</target>
        </trans-unit>
        <trans-unit id="0353c268d6003a0b1d6e372faa2ae4914cf1ab42" translate="yes" xml:space="preserve">
          <source>Sequelize already uses Bluebird promises internally and has promise returning APIs. Use those.</source>
          <target state="translated">Sequelize ya usa las promesas de Bluebird internamente y ha prometido devolver las APIs.Usa esas.</target>
        </trans-unit>
        <trans-unit id="0477fce5eb6ea953b269e6b50843ad48931e59dd" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;multiArgs&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; means the resulting promise will always fulfill with an array of the callback's success value(s). This is needed because promises only support a single success value while some callback API's have multiple success value. The default is to ignore all but the first success value of a callback function.</source>
          <target state="translated">Establecer &lt;code&gt;multiArgs&lt;/code&gt; en &lt;code&gt;true&lt;/code&gt; significa que la promesa resultante siempre se cumplir&amp;aacute; con una serie de valores de &amp;eacute;xito de devoluci&amp;oacute;n de llamada. Esto es necesario porque las promesas solo admiten un &amp;uacute;nico valor de &amp;eacute;xito, mientras que algunas API de devoluci&amp;oacute;n de llamada tienen un valor de &amp;eacute;xito m&amp;uacute;ltiple. El valor predeterminado es ignorar todos menos el primer valor de &amp;eacute;xito de una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada.</target>
        </trans-unit>
        <trans-unit id="9d87c38ef9cdbe40b70787a797d9e70b16e2a6cd" translate="yes" xml:space="preserve">
          <source>Setting a custom scheduler could be necessary when you need a faster way to schedule functions than bluebird does by default. It also makes bluebird possible to use in platforms where normal timing constructs like &lt;code&gt;setTimeout&lt;/code&gt; and &lt;code&gt;process.nextTick&lt;/code&gt; are not available (like Nashhorn).</source>
          <target state="translated">Podr&amp;iacute;a ser necesario configurar un programador personalizado cuando necesite una forma m&amp;aacute;s r&amp;aacute;pida de programar funciones que Bluebird de manera predeterminada. Tambi&amp;eacute;n hace posible el uso de bluebird en plataformas donde las construcciones de temporizaci&amp;oacute;n normales como &lt;code&gt;setTimeout&lt;/code&gt; y &lt;code&gt;process.nextTick&lt;/code&gt; no est&amp;aacute;n disponibles (como Nashhorn).</target>
        </trans-unit>
        <trans-unit id="3932ebbf539f8a931c6f13cf255530da552644ed" translate="yes" xml:space="preserve">
          <source>Setting the environment variable &lt;code&gt;NODE_ENV&lt;/code&gt; to &lt;code&gt;&quot;development&quot;&lt;/code&gt; also automatically enables long stack traces.</source>
          <target state="translated">Establecer la variable de entorno &lt;code&gt;NODE_ENV&lt;/code&gt; en &lt;code&gt;&quot;development&quot;&lt;/code&gt; tambi&amp;eacute;n habilita autom&amp;aacute;ticamente los seguimientos largos de la pila.</target>
        </trans-unit>
        <trans-unit id="4742ee0d05bf00094d42512b9006ce355572faaf" translate="yes" xml:space="preserve">
          <source>Several examples of databases follow.</source>
          <target state="translated">A continuación se presentan varios ejemplos de bases de datos.</target>
        </trans-unit>
        <trans-unit id="6e704260c9c34a30c1e1c6e9cc96dcbaba23b9e4" translate="yes" xml:space="preserve">
          <source>Several popular Android libraries use promises - for example the Parse Java API returns &lt;code&gt;Task&lt;/code&gt;s which are similar to JavaScript promises.</source>
          <target state="translated">Varias bibliotecas populares de Android usan promesas, por ejemplo, la API Parse Java devuelve &lt;code&gt;Task&lt;/code&gt; que son similares a las promesas de JavaScript.</target>
        </trans-unit>
        <trans-unit id="79948cec8617f2b258642406e788e89df84d104b" translate="yes" xml:space="preserve">
          <source>Shorthand for &lt;code&gt;.then(null, null, handler);&lt;/code&gt;. Attach a progress handler that will be called if this promise is progressed. Returns a new promise chained from this promise.</source>
          <target state="translated">Taquigraf&amp;iacute;a para &lt;code&gt;.then(null, null, handler);&lt;/code&gt; . Adjunte un controlador de progreso que se llamar&amp;aacute; si se progresa esta promesa. Devuelve una nueva promesa encadenada de esta promesa.</target>
        </trans-unit>
        <trans-unit id="d2d63e7d6731c58944766cb081aef40963e6cb50" translate="yes" xml:space="preserve">
          <source>Showing a live list of rejected promises</source>
          <target state="translated">Mostrando una lista en vivo de las promesas rechazadas</target>
        </trans-unit>
        <trans-unit id="8bbe005c943c12fa6ff0d2f8cafd5ad98bc70211" translate="yes" xml:space="preserve">
          <source>Signals that an operation has been aborted or cancelled. The default reason used by &lt;a href=&quot;cancel&quot;&gt;&lt;code&gt;.cancel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Se&amp;ntilde;ala que una operaci&amp;oacute;n ha sido cancelada o cancelada. El motivo predeterminado utilizado por &lt;a href=&quot;cancel&quot;&gt; &lt;code&gt;.cancel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="299f23dc5dcc08c7bfee7c8ae781aacf85c196cb" translate="yes" xml:space="preserve">
          <source>Signals that an operation has timed out. Used as a custom cancellation reason in &lt;a href=&quot;timeout&quot;&gt;&lt;code&gt;.timeout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Se&amp;ntilde;ales de que una operaci&amp;oacute;n ha excedido el tiempo de espera. Se utiliza como un motivo de cancelaci&amp;oacute;n personalizado en &lt;a href=&quot;timeout&quot;&gt; &lt;code&gt;.timeout&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46bf40da88360ad7bbfcf32d9dd42056cd2f6ff3" translate="yes" xml:space="preserve">
          <source>Significantly improve parallel promise performance and memory usage (+50% faster, -50% less memory)</source>
          <target state="translated">Mejorar significativamente el rendimiento de la promesa paralela y el uso de la memoria (+50% más rápido,-50% menos memoria)</target>
        </trans-unit>
        <trans-unit id="d63c65ce4045c196a80e2036ef184d1e29767129" translate="yes" xml:space="preserve">
          <source>Significantly improve performance of foreign bluebird thenables</source>
          <target state="translated">Mejorar significativamente el rendimiento de las aves azules extranjeras entoncesables</target>
        </trans-unit>
        <trans-unit id="730519283954b4569cc72648083ced3012f2475e" translate="yes" xml:space="preserve">
          <source>Similarly, with promises:</source>
          <target state="translated">De la misma manera,con promesas:</target>
        </trans-unit>
        <trans-unit id="e16c84188a248cb435f2ade69bfef7f54bb36e8f" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;api/promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; takes promises, it must also take jQuery deferreds, so the above can be shortened to:</source>
          <target state="translated">Dado que &lt;a href=&quot;api/promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; toma promesas, tambi&amp;eacute;n debe tomar diferidos jQuery, por lo que lo anterior se puede acortar a:</target>
        </trans-unit>
        <trans-unit id="71d62301257a57ffc03da0d5c42ed2549e221316" translate="yes" xml:space="preserve">
          <source>Since all objects support having properties you might still wonder why exactly does it have to be an error object and not just any object. In addition to supporting properties, an equally important feature necessary for values that are automatically propagated is the stack trace property (&lt;code&gt;.stack&lt;/code&gt;). A stack trace allows you easily find where an error originated from as it gives the code's call stack - along with line numbers for reference in code files.</source>
          <target state="translated">Dado que todos los objetos admiten tener propiedades, a&amp;uacute;n podr&amp;iacute;a preguntarse por qu&amp;eacute; tiene que ser exactamente un objeto de error y no un objeto cualquiera. Adem&amp;aacute;s de las propiedades de soporte, una caracter&amp;iacute;stica igualmente importante necesaria para los valores que se propagan autom&amp;aacute;ticamente es la propiedad de seguimiento de la pila ( &lt;code&gt;.stack&lt;/code&gt; ). Un seguimiento de la pila le permite encontrar f&amp;aacute;cilmente d&amp;oacute;nde se origin&amp;oacute; un error, ya que proporciona la pila de llamadas del c&amp;oacute;digo, junto con los n&amp;uacute;meros de l&amp;iacute;nea para referencia en los archivos de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="92d019d6c6f872eca710a5e9fe46091f1e234c2c" translate="yes" xml:space="preserve">
          <source>Since in bluebird &lt;a href=&quot;api/promisification&quot;&gt;&lt;code&gt;promisification&lt;/code&gt;&lt;/a&gt; is made trivial, you can get long stack traces all the time:</source>
          <target state="translated">Dado que en bluebird la &lt;a href=&quot;api/promisification&quot;&gt; &lt;code&gt;promisification&lt;/code&gt; &lt;/a&gt; se hace trivial, puede obtener trazas largas de la pila todo el tiempo:</target>
        </trans-unit>
        <trans-unit id="fd8d850f23fc1a81c14cb9cdd8a5e00431fefc26" translate="yes" xml:space="preserve">
          <source>Since the array passed to waterfall is static (always the same 3 functions) a plain old promise chain is used:</source>
          <target state="translated">Como el conjunto pasado a la cascada es estático (siempre las mismas 3 funciones)se utiliza una simple cadena de promesas:</target>
        </trans-unit>
        <trans-unit id="ead75c8725f0a9530a5abc673013177ab974cfdf" translate="yes" xml:space="preserve">
          <source>Small performance improvements for all collection methods</source>
          <target state="translated">Pequeñas mejoras de rendimiento para todos los métodos de recolección</target>
        </trans-unit>
        <trans-unit id="dc101ed1f69471502ee81d7871e2413721d60887" translate="yes" xml:space="preserve">
          <source>So how then could we represent a progress bar like dialog? Well the answer is to manage the progress through callbacks outside the promise API. Bluebird has since &lt;a href=&quot;deprecated-apis#progression&quot;&gt;deprecated the progression feature&lt;/a&gt; and offers an alternative which I hope to illustrate here.</source>
          <target state="translated">Entonces, &amp;iquest;c&amp;oacute;mo podr&amp;iacute;amos representar una barra de progreso como el di&amp;aacute;logo? Bueno, la respuesta es administrar el progreso a trav&amp;eacute;s de devoluciones de llamada fuera de la API de promesa. Desde entonces, Bluebird ha &lt;a href=&quot;deprecated-apis#progression&quot;&gt;desaprobado la funci&amp;oacute;n de progresi&amp;oacute;n&lt;/a&gt; y ofrece una alternativa que espero ilustrar aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="e1ae1ffa70bbe4990a8964de54d99ecd7b5fd6b5" translate="yes" xml:space="preserve">
          <source>So please write the same when using promises too:</source>
          <target state="translated">Así que por favor escriba lo mismo cuando use promesas también:</target>
        </trans-unit>
        <trans-unit id="e0e6caa4611dfebbc5e6e21fabaf9c486084de89" translate="yes" xml:space="preserve">
          <source>Some examples of the above practice applied to some popular libraries:</source>
          <target state="translated">Algunos ejemplos de la práctica anterior se aplicaron a algunas bibliotecas populares:</target>
        </trans-unit>
        <trans-unit id="328f2682f2d41aa9dcab87997132944918cfc2f4" translate="yes" xml:space="preserve">
          <source>Some nodebacks expect more than 1 success value but there is no mapping for this in the promise world. You may specify the option &lt;code&gt;spread&lt;/code&gt; to call the nodeback with multiple values when the fulfillment value is an array:</source>
          <target state="translated">Algunos nodos de retorno esperan m&amp;aacute;s de 1 valor de &amp;eacute;xito, pero no existe una asignaci&amp;oacute;n para esto en el mundo prometedor. Puede especificar la opci&amp;oacute;n &lt;code&gt;spread&lt;/code&gt; para llamar al nodoback con m&amp;uacute;ltiples valores cuando el valor de cumplimiento es una matriz:</target>
        </trans-unit>
        <trans-unit id="d38c75cc8957e65c44573a2e27f3885375d06448" translate="yes" xml:space="preserve">
          <source>Something missing from the above example is proper error handling. When it comes to promises it is a best practise to always &lt;em&gt;reject a promise with an Error&lt;/em&gt; and not with plain data such as an object, string, number, or null/undefined. The reasoning for this is promises are best used as a way to regain some of the syntax you have with the standard &lt;code&gt;try {} catch() {}&lt;/code&gt; blocks with asynchronous code.</source>
          <target state="translated">Algo que falta en el ejemplo anterior es el manejo adecuado de errores. Cuando se trata de promesas, es una buena pr&amp;aacute;ctica &lt;em&gt;rechazar&lt;/em&gt; siempre &lt;em&gt;una promesa con un Error&lt;/em&gt; y no con datos simples como un objeto, cadena, n&amp;uacute;mero o nulo / indefinido. El razonamiento para esto es que las promesas se utilizan mejor como una forma de recuperar parte de la sintaxis que tiene con los bloques &lt;code&gt;try {} catch() {}&lt;/code&gt; est&amp;aacute;ndar con c&amp;oacute;digo as&amp;iacute;ncrono.</target>
        </trans-unit>
        <trans-unit id="f5366b89baa9bf31993646740e57cd8f67859925" translate="yes" xml:space="preserve">
          <source>Sometimes we want to find out when a single one time event has finished. For example - a stream is done. For this we can use &lt;a href=&quot;api/new-promise&quot;&gt;&lt;code&gt;new Promise&lt;/code&gt;&lt;/a&gt;. Note that this option should be considered only if &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;automatic conversion&lt;/a&gt; isn't possible.</source>
          <target state="translated">A veces queremos saber cu&amp;aacute;ndo ha finalizado un evento &amp;uacute;nico. Por ejemplo, se realiza una transmisi&amp;oacute;n. Para esto podemos usar la &lt;a href=&quot;api/new-promise&quot;&gt; &lt;code&gt;new Promise&lt;/code&gt; &lt;/a&gt; . Tenga en cuenta que esta opci&amp;oacute;n solo debe considerarse si &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;la conversi&amp;oacute;n autom&amp;aacute;tica&lt;/a&gt; no es posible.</target>
        </trans-unit>
        <trans-unit id="c0b9d85f33b2e758641f19550f5a9be3023ea242" translate="yes" xml:space="preserve">
          <source>Sometimes you have to work with APIs that are inconsistent and do not follow a common convention.</source>
          <target state="translated">A veces hay que trabajar con API que son inconsistentes y no siguen una convención común.</target>
        </trans-unit>
        <trans-unit id="47f7595fc4eaf9c4327785c6f28cc0a3cb93f37a" translate="yes" xml:space="preserve">
          <source>Sparse array holes are not skipped by collection methods but treated as existing elements with &lt;code&gt;undefined&lt;/code&gt; value</source>
          <target state="translated">Los agujeros de matriz dispersos no se omiten mediante m&amp;eacute;todos de recopilaci&amp;oacute;n, sino que se tratan como elementos existentes con &lt;code&gt;undefined&lt;/code&gt; valor indefinido</target>
        </trans-unit>
        <trans-unit id="334f0f329646de4898c801e89bc81110c62b9723" translate="yes" xml:space="preserve">
          <source>Start the chain of promises with &lt;code&gt;Promise.try&lt;/code&gt;. Any synchronous exceptions will be turned into rejections on the returned promise.</source>
          <target state="translated">Comience la cadena de promesas con &lt;code&gt;Promise.try&lt;/code&gt; . Cualquier excepci&amp;oacute;n sincr&amp;oacute;nica se convertir&amp;aacute; en rechazo de la promesa devuelta.</target>
        </trans-unit>
        <trans-unit id="7544908a62ca43e11724d7886c37028c419b528e" translate="yes" xml:space="preserve">
          <source>Starting from 2.7.0 all bluebird instances also fire rejection events globally so that applications can register one universal hook for them.</source>
          <target state="translated">A partir de la 2.7.0 todas las instancias de bluebird también disparan eventos de rechazo a nivel mundial para que las aplicaciones puedan registrar un gancho universal para ellos.</target>
        </trans-unit>
        <trans-unit id="3603ca6749bcc3136f65ac99d1a525e581f1708b" translate="yes" xml:space="preserve">
          <source>Stream libraries tend to serve a different purpose than promise libraries. Unlike promise libraries streams can represent multiple values.</source>
          <target state="translated">Las bibliotecas de corrientes tienden a servir un propósito diferente al de las bibliotecas de promesas.A diferencia de las bibliotecas de promesas,los flujos pueden representar múltiples valores.</target>
        </trans-unit>
        <trans-unit id="9a8475ec2272fa6b1c6b05f2bd678210b89009cf" translate="yes" xml:space="preserve">
          <source>Such a constructor can be minimally created like so:</source>
          <target state="translated">Tal constructor puede ser creado mínimamente como tal:</target>
        </trans-unit>
        <trans-unit id="d58681e9c8fb0c509a2cfc71f3a1d6ba692e9b25" translate="yes" xml:space="preserve">
          <source>Such policies could include:</source>
          <target state="translated">Esas políticas podrían incluir</target>
        </trans-unit>
        <trans-unit id="8f1919f0096a6b3087e18c842a5097f047b54d80" translate="yes" xml:space="preserve">
          <source>Such wrappers should be rare, if they're common for the reason that the promise library cannot generically promisify them, you should file an issue.</source>
          <target state="translated">Tales envoltorios deben ser raros,si son comunes por la razón de que la biblioteca de la promesa no puede prometerlos genéricamente,debe presentar una solicitud.</target>
        </trans-unit>
        <trans-unit id="0158596539b88e3d14cfe51fe82aba75fca71681" translate="yes" xml:space="preserve">
          <source>Summary of breaking changes</source>
          <target state="translated">Resumen de los cambios de ruptura</target>
        </trans-unit>
        <trans-unit id="c1e51f0164b5bdc44f9880dc21c2988e1430f473" translate="yes" xml:space="preserve">
          <source>Support primitives in catch filters</source>
          <target state="translated">Apoyar a los primitivos en los filtros de captura</target>
        </trans-unit>
        <trans-unit id="34c6c2ddc426343eed559ce47d4c777df69eba0c" translate="yes" xml:space="preserve">
          <source>Supported platforms</source>
          <target state="translated">Plataformas soportadas</target>
        </trans-unit>
        <trans-unit id="f02259e275f481a7fdda40736a24df99f0cd3a67" translate="yes" xml:space="preserve">
          <source>Surfacing unhandled errors</source>
          <target state="translated">La superficie de los errores no manejados...</target>
        </trans-unit>
        <trans-unit id="a3f9e4820c3b2f7bbea724b622595d004feda9b4" translate="yes" xml:space="preserve">
          <source>Swallowing all errors (challenge your debugging skills)</source>
          <target state="translated">Tragarse todos los errores (desafiar sus habilidades de depuración)</target>
        </trans-unit>
        <trans-unit id="9d4e83066087dd1079c656c148313dafa0d0a48a" translate="yes" xml:space="preserve">
          <source>Synchronous inspection</source>
          <target state="translated">Inspección sincrónica</target>
        </trans-unit>
        <trans-unit id="560cd166df807614aa93c9f2544b674451945594" translate="yes" xml:space="preserve">
          <source>Synchronous inspection allows you to retrieve the fulfillment value of an already fulfilled promise or the rejection reason of an already rejected promise synchronously.</source>
          <target state="translated">La inspección sincrónica permite recuperar el valor de cumplimiento de una promesa ya cumplida o el motivo de rechazo de una promesa ya rechazada de forma sincrónica.</target>
        </trans-unit>
        <trans-unit id="3f22a0a957f0468c0084e1e9ae07dd450cc45ad2" translate="yes" xml:space="preserve">
          <source>That is, you can return either a promise &lt;em&gt;or a plain value&lt;/em&gt; from a &lt;code&gt;then&lt;/code&gt; without wrapping it.</source>
          <target state="translated">Es decir, puede devolver una promesa &lt;em&gt;o un valor simple&lt;/em&gt; desde &lt;code&gt;then&lt;/code&gt; sin envolverlo.</target>
        </trans-unit>
        <trans-unit id="34bb1fab188a923aeae77d6108a07ce0c4ce134b" translate="yes" xml:space="preserve">
          <source>That means &lt;code&gt;value&lt;/code&gt; is bound at the time of calling &lt;a href=&quot;return&quot;&gt;&lt;code&gt;.return&lt;/code&gt;&lt;/a&gt; so this will not work as expected:</source>
          <target state="translated">Eso significa que el &lt;code&gt;value&lt;/code&gt; est&amp;aacute; vinculado al momento de llamar a &lt;a href=&quot;return&quot;&gt; &lt;code&gt;.return&lt;/code&gt; ,&lt;/a&gt; por lo que esto no funcionar&amp;aacute; como se esperaba:</target>
        </trans-unit>
        <trans-unit id="6e5c6863d3d57d6db5e4a2e948905db8b10466ee" translate="yes" xml:space="preserve">
          <source>That means when you have a problem there probably isn't an existing function tailored exactly to that problem but instead you can just combine the existing utilities to arrive at a solution. The upside of this is that you don't need to come up with all these different functions to solve problems that are not that different from each other. The most important thing to do when migrating from async to bluebird is this profound shift in philosophy.</source>
          <target state="translated">Eso significa que cuando tienes un problema probablemente no hay una función existente adaptada exactamente a ese problema,sino que puedes combinar las utilidades existentes para llegar a una solución.El lado positivo de esto es que no es necesario crear todas estas diferentes funciones para resolver problemas que no son tan diferentes entre sí.Lo más importante que hay que hacer cuando se migra de la asincronía a la bluebird es este profundo cambio en la filosofía.</target>
        </trans-unit>
        <trans-unit id="c31fbbf769a579d258b6c345c7359a66afd6aa22" translate="yes" xml:space="preserve">
          <source>That said, if you have code written using jQuery deferred methods, such as &lt;code&gt;.then&lt;/code&gt;, &lt;code&gt;.done&lt;/code&gt; and so on, you cannot drop-in replace the jQuery deferred with a bluebird promise in that code. Despite having the same names, jQuery deferred methods have different semantics than bluebird promise methods. These differences are due to the completely different goals of the implementations. Bluebird is &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;an internal DSL&lt;/a&gt; for the domain of asynchronous control flow while jQuery deferreds are a callback aggregator utility (&quot;glorified event emitters&quot;).</source>
          <target state="translated">Dicho esto, si tiene c&amp;oacute;digo escrito usando m&amp;eacute;todos jQuery diferidos, tales como &lt;code&gt;.then&lt;/code&gt; , &lt;code&gt;.done&lt;/code&gt; y as&amp;iacute; sucesivamente, no se puede caer en sustituir el jQuery diferido con la promesa p&amp;aacute;jaro azul en ese c&amp;oacute;digo. A pesar de tener los mismos nombres, los m&amp;eacute;todos diferidos de jQuery tienen una sem&amp;aacute;ntica diferente a los m&amp;eacute;todos de promesa de bluebird. Estas diferencias se deben a los objetivos completamente diferentes de las implementaciones. Bluebird es &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;un DSL interno&lt;/a&gt; para el dominio del flujo de control as&amp;iacute;ncrono, mientras que los diferidos jQuery son una utilidad de agregaci&amp;oacute;n de devoluci&amp;oacute;n de llamada (&quot;emisores de eventos glorificados&quot;).</target>
        </trans-unit>
        <trans-unit id="9576ae41ed6c2fc691cc3233977df2602674a9e5" translate="yes" xml:space="preserve">
          <source>The &quot;a promise was created in a handler but not returned from it&quot; warning now adds the bluebird API method used to create the non-returned promise at the top of the warning stack</source>
          <target state="translated">La advertencia &quot;se creó una promesa en un manipulador pero no se devolvió&quot; añade ahora el método de la API de Bluebird utilizado para crear la promesa no devuelta en la parte superior de la pila de advertencias</target>
        </trans-unit>
        <trans-unit id="2387bf8a5eec038b8dc1d6a136dd30eb885c69f6" translate="yes" xml:space="preserve">
          <source>The &quot;a promise was created in a handler but not returned from it&quot; warning now highlights the file, line and column where the return statement is missing.</source>
          <target state="translated">La advertencia &quot;se creó una promesa en un manejador pero no se devolvió desde él&quot; ahora destaca el archivo,la línea y la columna donde falta la declaración de devolución.</target>
        </trans-unit>
        <trans-unit id="9172632794382321ca96b52eb375dcf229573bb4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reflect&quot;&gt;&lt;code&gt;.reflect&lt;/code&gt;&lt;/a&gt; method returns a promise that is always successful when this promise is settled. Its fulfillment value is an object that implements the &lt;a href=&quot;promiseinspection&quot;&gt;&lt;code&gt;PromiseInspection&lt;/code&gt;&lt;/a&gt; interface and reflects the resolution of this promise.</source>
          <target state="translated">El m&amp;eacute;todo &lt;a href=&quot;reflect&quot;&gt; &lt;code&gt;.reflect&lt;/code&gt; &lt;/a&gt; devuelve una promesa que siempre es exitosa cuando esta promesa se resuelve. Su valor de cumplimiento es un objeto que implementa la interfaz &lt;a href=&quot;promiseinspection&quot;&gt; &lt;code&gt;PromiseInspection&lt;/code&gt; &lt;/a&gt; y refleja la resoluci&amp;oacute;n de esta promesa.</target>
        </trans-unit>
        <trans-unit id="dcc5097b492ec34ac1dac37541df7fa6d5523657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.props&lt;/code&gt; method expects to receive an object.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;.props&lt;/code&gt; espera recibir un objeto.</target>
        </trans-unit>
        <trans-unit id="b0eb698af924dfb32cf54d281b02888c506ead09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then(success, fail)&lt;/code&gt; anti-pattern</source>
          <target state="translated">El &lt;code&gt;.then(success, fail)&lt;/code&gt; anti-patr&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="0fcdb3492bd1cc7aa9ff1b548b88ce52afafa5d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.then&lt;/code&gt; signature is mostly about interop, there is &lt;em&gt;almost&lt;/em&gt; never a reason to use &lt;code&gt;.then(success, fail)&lt;/code&gt; in application code. It is even awkward to express it in the sync parallel:</source>
          <target state="translated">La firma &lt;code&gt;.then&lt;/code&gt; se trata principalmente de interoperabilidad, &lt;em&gt;casi&lt;/em&gt; nunca hay una raz&amp;oacute;n para usar &lt;code&gt;.then(success, fail)&lt;/code&gt; en el c&amp;oacute;digo de la aplicaci&amp;oacute;n. Es incluso inc&amp;oacute;modo expresarlo en el paralelo de sincronizaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e944db85ee16051290ad72f2026b7a41fb2a4813" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map&lt;/code&gt; operation is expecting an array here (or a promise on one) and instead gets the number &lt;code&gt;5&lt;/code&gt;.</source>
          <target state="translated">La operaci&amp;oacute;n de &lt;code&gt;map&lt;/code&gt; a espera una matriz aqu&amp;iacute; (o una promesa en una) y en su lugar obtiene el n&amp;uacute;mero &lt;code&gt;5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f752091c174b33d9da17500cd7d1d3ae7eb2bd9" translate="yes" xml:space="preserve">
          <source>The Explicit Construction Anti-Pattern</source>
          <target state="translated">La construcción explícita anti-patrón</target>
        </trans-unit>
        <trans-unit id="7ae99b6910e577d7be696210c2dbfc212e81ffa5" translate="yes" xml:space="preserve">
          <source>The JavaScript is the same as the &lt;code&gt;PromptDialog&lt;/code&gt; only we will add a &lt;code&gt;setProgress()&lt;/code&gt; method:</source>
          <target state="translated">El JavaScript es el mismo que el &lt;code&gt;PromptDialog&lt;/code&gt; , solo agregaremos un m&amp;eacute;todo &lt;code&gt;setProgress()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="987db8ad0cd3c6e2880ebfda0417324d809a8643" translate="yes" xml:space="preserve">
          <source>The above calls the function &lt;code&gt;processImage()&lt;/code&gt;&lt;em&gt;immediately&lt;/em&gt; and passes the result to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; (which is most likely &lt;code&gt;undefined&lt;/code&gt; - the default return value when a function doesn't return anything).</source>
          <target state="translated">Lo anterior llama a la funci&amp;oacute;n &lt;code&gt;processImage()&lt;/code&gt; &lt;em&gt;inmediatamente&lt;/em&gt; y pasa el resultado a &lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; (que probablemente &lt;code&gt;undefined&lt;/code&gt; est&amp;eacute; definido : el valor de retorno predeterminado cuando una funci&amp;oacute;n no devuelve nada).</target>
        </trans-unit>
        <trans-unit id="1c5b45d618d205b79bdd2339e1eb511e0597ceee" translate="yes" xml:space="preserve">
          <source>The above can also be written as (with a caveat, see below)</source>
          <target state="translated">Lo anterior también puede escribirse como (con una advertencia,véase más abajo)</target>
        </trans-unit>
        <trans-unit id="b9d96d94c20e29d7be811aad09d5f2fc69d847ac" translate="yes" xml:space="preserve">
          <source>The above does a &lt;code&gt;console.log&lt;/code&gt; of &lt;code&gt;my-element&lt;/code&gt;. Doing it this way is necessary because neither of the methods (&lt;code&gt;getElementById&lt;/code&gt;, &lt;code&gt;console.log&lt;/code&gt;) can be called as stand-alone methods.</source>
          <target state="translated">Lo anterior hace un &lt;code&gt;console.log&lt;/code&gt; de &lt;code&gt;my-element&lt;/code&gt; . Hacerlo de esta manera es necesario porque ninguno de los m&amp;eacute;todos ( &lt;code&gt;getElementById&lt;/code&gt; , &lt;code&gt;console.log&lt;/code&gt; ) puede llamarse como m&amp;eacute;todos independientes.</target>
        </trans-unit>
        <trans-unit id="4ff51746636ecc3655cfcaa3b14edb8e79b82038" translate="yes" xml:space="preserve">
          <source>The above ensures &lt;code&gt;getConnection&lt;/code&gt; fulfills the contract of a promise-returning function of never throwing a synchronous exception. Also see &lt;a href=&quot;promise.try&quot;&gt;&lt;code&gt;Promise.try&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;promise.method&quot;&gt;&lt;code&gt;Promise.method&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Lo anterior asegura que &lt;code&gt;getConnection&lt;/code&gt; cumpla el contrato de una funci&amp;oacute;n de promesa de no lanzar nunca una excepci&amp;oacute;n s&amp;iacute;ncrona. Ver tambi&amp;eacute;n &lt;a href=&quot;promise.try&quot;&gt; &lt;code&gt;Promise.try&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;promise.method&quot;&gt; &lt;code&gt;Promise.method&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec563887821c925f0b9a15bbaeb4d94ba4967bb9" translate="yes" xml:space="preserve">
          <source>The above function can then make everyone happy.</source>
          <target state="translated">La función anterior puede entonces hacer feliz a todo el mundo.</target>
        </trans-unit>
        <trans-unit id="cb5a0fcd51c35945773869b7451e685e33fe2b5b" translate="yes" xml:space="preserve">
          <source>The above has a direct translation:</source>
          <target state="translated">Lo anterior tiene una traducción directa:</target>
        </trans-unit>
        <trans-unit id="be3a5d7ac08554519f84fa1292d020a1294faf0a" translate="yes" xml:space="preserve">
          <source>The above without &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; could be achieved with:</source>
          <target state="translated">Lo anterior sin &lt;a href=&quot;bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; &lt;/a&gt; podr&amp;iacute;a lograrse con:</target>
        </trans-unit>
        <trans-unit id="a6770726e6458fe58ea6b5f4fd62bd9042424df5" translate="yes" xml:space="preserve">
          <source>The actual subscription API depends on the environment.</source>
          <target state="translated">La API de suscripción real depende del entorno.</target>
        </trans-unit>
        <trans-unit id="f16cc25950a83115317503e4adef79079d08a456" translate="yes" xml:space="preserve">
          <source>The advantage of using &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; over &lt;code&gt;.catch(function(){})&lt;/code&gt; is that it doesn't increment the branch count of the promise. Branch counts matter when using cancellation because a promise will only be cancelled if all of its branches want to cancel it.</source>
          <target state="translated">La ventaja de usar &lt;code&gt;.suppressUnhandledRejections()&lt;/code&gt; sobre &lt;code&gt;.catch(function(){})&lt;/code&gt; es que no incrementa el conteo de ramas de la promesa. El recuento de sucursales es importante cuando se utiliza la cancelaci&amp;oacute;n porque una promesa solo se cancelar&amp;aacute; si todas sus sucursales desean cancelarla.</target>
        </trans-unit>
        <trans-unit id="9c56f54fb10413e626d1f27ae289fc09dbb6d933" translate="yes" xml:space="preserve">
          <source>The advantages of the new cancellation compared to the old cancellation are:</source>
          <target state="translated">Las ventajas de la nueva cancelación en comparación con la vieja cancelación son:</target>
        </trans-unit>
        <trans-unit id="f38af64a279ce9559ab9430fe352d1985725b5b6" translate="yes" xml:space="preserve">
          <source>The cancellation feature is &lt;strong&gt;by default turned off&lt;/strong&gt;, you can enable it using &lt;a href=&quot;promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La funci&amp;oacute;n de cancelaci&amp;oacute;n est&amp;aacute; &lt;strong&gt;desactivada por defecto&lt;/strong&gt; , puede habilitarla usando &lt;a href=&quot;promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6200a8a72cc85fe3cd189630a2f941b849b20c71" translate="yes" xml:space="preserve">
          <source>The concurrency limit applies to Promises returned by the mapper function and it basically limits the number of Promises created. For example, if &lt;code&gt;concurrency&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; and the mapper callback has been called enough so that there are three returned Promises currently pending, no further callbacks are called until one of the pending Promises resolves. So the mapper function will be called three times and it will be called again only after at least one of the Promises resolves.</source>
          <target state="translated">El l&amp;iacute;mite de concurrencia se aplica a las Promesas devueltas por la funci&amp;oacute;n de mapeador y b&amp;aacute;sicamente limita el n&amp;uacute;mero de Promesas creadas. Por ejemplo, si la &lt;code&gt;concurrency&lt;/code&gt; es &lt;code&gt;3&lt;/code&gt; y la devoluci&amp;oacute;n de llamada del asignador se ha llamado lo suficiente como para que haya tres promesas devueltas actualmente pendientes, no se invocan m&amp;aacute;s devoluciones de llamada hasta que se resuelva una de las promesas pendientes. Por lo tanto, la funci&amp;oacute;n del asignador se llamar&amp;aacute; tres veces y se volver&amp;aacute; a llamar solo despu&amp;eacute;s de que se resuelva al menos una de las Promesas.</target>
        </trans-unit>
        <trans-unit id="a9dfc798d7155c42f102e1690ecdc5d11f1eed13" translate="yes" xml:space="preserve">
          <source>The current element of the iteration is a &lt;em&gt;pending&lt;/em&gt; promise, that promise will be awaited before running the iterator.</source>
          <target state="translated">El elemento actual de la iteraci&amp;oacute;n es una promesa &lt;em&gt;pendiente&lt;/em&gt; , esa promesa se esperar&amp;aacute; antes de ejecutar el iterador.</target>
        </trans-unit>
        <trans-unit id="e4676232a799b417212732864ed73ce3337f094d" translate="yes" xml:space="preserve">
          <source>The current element of the iteration is a &lt;em&gt;pending&lt;/em&gt; promise, that promise will be awaited before running the mapper.</source>
          <target state="translated">El elemento actual de la iteraci&amp;oacute;n es una promesa &lt;em&gt;pendiente&lt;/em&gt; , esa promesa se esperar&amp;aacute; antes de ejecutar el mapeador.</target>
        </trans-unit>
        <trans-unit id="7901af52e1d3bb0c5159bcb56902f980986ef864" translate="yes" xml:space="preserve">
          <source>The current element of the iteration is a &lt;em&gt;rejected&lt;/em&gt; promise, the iteration will stop and be rejected as well (with the same reason).</source>
          <target state="translated">El elemento actual de la iteraci&amp;oacute;n es una promesa &lt;em&gt;rechazada&lt;/em&gt; , la iteraci&amp;oacute;n se detendr&amp;aacute; y tambi&amp;eacute;n ser&amp;aacute; rechazada (por la misma raz&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="31ab830fa32b91594137493c8717fb7b7a2afbf7" translate="yes" xml:space="preserve">
          <source>The default approach of bluebird is to immediately log the stack trace when there is an unhandled rejection. This is similar to how uncaught exceptions cause the stack trace to be logged so that you have something to work with when something is not working as expected.</source>
          <target state="translated">El enfoque por defecto de Bluebird es registrar inmediatamente el rastro de la pila cuando hay un rechazo sin manejar.Esto es similar a la forma en que las excepciones no manipuladas hacen que el rastro de la pila se registre para tener algo con lo que trabajar cuando algo no funciona como se espera.</target>
        </trans-unit>
        <trans-unit id="79301b912f99cabfc6b1d506271ff79825a49941" translate="yes" xml:space="preserve">
          <source>The default filter function will ignore properties that start with a leading underscore, properties that are not valid JavaScript identifiers and constructor functions (function which have enumerable properties in their &lt;code&gt;.prototype&lt;/code&gt;).</source>
          <target state="translated">La funci&amp;oacute;n de filtro predeterminada ignorar&amp;aacute; las propiedades que comienzan con un gui&amp;oacute;n bajo, las propiedades que no son identificadores de JavaScript v&amp;aacute;lidos y las funciones de constructor (funci&amp;oacute;n que tiene propiedades enumerables en su &lt;code&gt;.prototype&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb7c7d829660ad1b607e4ff44a0e6cb994eacdf1" translate="yes" xml:space="preserve">
          <source>The dialog interface might look like this:</source>
          <target state="translated">La interfaz de diálogo podría verse así:</target>
        </trans-unit>
        <trans-unit id="2ec7326b7197ff7aa9ec6904e534048cbee04708" translate="yes" xml:space="preserve">
          <source>The difference between a &lt;code&gt;Task&lt;/code&gt; and a promise are that a task might not be started and might require a &lt;code&gt;.Start&lt;/code&gt; call where a promise always represents an already started operation.</source>
          <target state="translated">La diferencia entre una &lt;code&gt;Task&lt;/code&gt; y una promesa es que una tarea podr&amp;iacute;a no iniciarse y requerir una llamada &lt;code&gt;.Start&lt;/code&gt; donde una promesa siempre representa una operaci&amp;oacute;n ya iniciada.</target>
        </trans-unit>
        <trans-unit id="801933290ac764cce3fee90e0b881f138a330a0e" translate="yes" xml:space="preserve">
          <source>The entire prototype chain of the object is promisified on the object. Only enumerable are considered. If the object already has a promisified version of the method, it will be skipped. The target methods are assumed to conform to node.js callback convention of accepting a callback as last argument and calling that callback with error as the first argument and success value on the second argument. If the node method calls its callback with multiple success values, the fulfillment value will be an array of them.</source>
          <target state="translated">Toda la cadena del prototipo del objeto se promete en el objeto.Sólo se consideran las enumeraciones.Si el objeto ya tiene una versión prometida del método,se salteará.Se supone que los métodos de destino se ajustan a la convención de devolución de llamadas del node.js de aceptar una devolución de llamadas como último argumento y llamarla con error como primer argumento y valor de éxito en el segundo argumento.Si el método del nodo llama a su devolución con múltiples valores de éxito,el valor de cumplimiento será un array de ellos.</target>
        </trans-unit>
        <trans-unit id="d6be4df893a1137d6b3ab84348ff99be431c883e" translate="yes" xml:space="preserve">
          <source>The explicit construction anti-pattern</source>
          <target state="translated">La construcción explícita anti-patrón</target>
        </trans-unit>
        <trans-unit id="40e45891046aa649e068bb199da2efeaca661dda" translate="yes" xml:space="preserve">
          <source>The following lifecycle events are available:</source>
          <target state="translated">Los siguientes eventos del ciclo de vida están disponibles:</target>
        </trans-unit>
        <trans-unit id="b55e86c0fc753c356970890234eaa0b0ce6daee6" translate="yes" xml:space="preserve">
          <source>The function being called expects a Promise, but is given something different. There are two main reasons why this may occur.</source>
          <target state="translated">La función que se llama espera una promesa,pero se le da algo diferente.Hay dos razones principales por las que esto puede ocurrir.</target>
        </trans-unit>
        <trans-unit id="0fa7caae49fcd453bbf69746e24b32d9fbb6ba35" translate="yes" xml:space="preserve">
          <source>The generic promisification is likely to be faster because it can use internals directly but also handles edge cases like &lt;code&gt;libraryFunction&lt;/code&gt; throwing synchronously or using multiple success values.</source>
          <target state="translated">Es probable que la promisificaci&amp;oacute;n gen&amp;eacute;rica sea m&amp;aacute;s r&amp;aacute;pida porque puede usar elementos internos directamente, pero tambi&amp;eacute;n maneja casos &lt;code&gt;libraryFunction&lt;/code&gt; como libraryFunction lanzando sincr&amp;oacute;nicamente o usando m&amp;uacute;ltiples valores de &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="7b2748080c6d9715db0ad2710e45478c0f7c5d34" translate="yes" xml:space="preserve">
          <source>The global events are:</source>
          <target state="translated">Los acontecimientos mundiales son:</target>
        </trans-unit>
        <trans-unit id="ac6f6a9e8f68d43e290c78abcefdf4dfcc31bc80" translate="yes" xml:space="preserve">
          <source>The handler functions are now closures, thus less efficient and not reusable</source>
          <target state="translated">Las funciones del manipulador son ahora cierres,por lo que son menos eficientes y no son reutilizables</target>
        </trans-unit>
        <trans-unit id="578ba1114aa6fcded1f091d1702ddf63eaf4722c" translate="yes" xml:space="preserve">
          <source>The implementations for this benchmark are found in &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/doxbee-sequential&quot;&gt;&lt;code&gt;benchmark/doxbee-sequential&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="translated">Las implementaciones para este punto de referencia se encuentran en el directorio &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/doxbee-sequential&quot;&gt; &lt;code&gt;benchmark/doxbee-sequential&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2beec3e3018a687405477c67e8972c8a6a40dae3" translate="yes" xml:space="preserve">
          <source>The implementations for this benchmark are found in &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/madeup-parallel&quot;&gt;&lt;code&gt;benchmark/madeup-parallel&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="translated">Las implementaciones para este punto de referencia se encuentran en el directorio &lt;a href=&quot;https://github.com/petkaantonov/bluebird/tree/master/benchmark/madeup-parallel&quot;&gt; &lt;code&gt;benchmark/madeup-parallel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ab9ea41bf2d998f0ea876fa3d95827572dbbe3d" translate="yes" xml:space="preserve">
          <source>The iterator returns a promise or a thenable, it is awaited before continuing to the next iteration.</source>
          <target state="translated">El iterador devuelve una promesa o una posibilidad,se espera antes de continuar con la siguiente iteración.</target>
        </trans-unit>
        <trans-unit id="9448500cacb1ff64a30efd5b0e2bea57a588d796" translate="yes" xml:space="preserve">
          <source>The mapper function for a given item is called as soon as possible, that is, when the promise for that item's index in the input array is fulfilled. This doesn't mean that the result array has items in random order, it means that &lt;code&gt;.map&lt;/code&gt; can be used for concurrency coordination unlike &lt;code&gt;.all&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n de mapeador para un elemento dado se llama lo antes posible, es decir, cuando se cumple la promesa del &amp;iacute;ndice de ese elemento en la matriz de entrada. Esto no significa que la matriz de resultados tenga elementos en orden aleatorio, significa que &lt;code&gt;.map&lt;/code&gt; se puede usar para la coordinaci&amp;oacute;n de concurrencia a diferencia de &lt;code&gt;.all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="575b00766f4d58c35e179c44f5a23cda579eb7ad" translate="yes" xml:space="preserve">
          <source>The mapper returns a promise or a thenable, it is awaited before continuing to the next iteration.</source>
          <target state="translated">El mapeador devuelve una promesa o una posibilidad,se espera antes de continuar con la siguiente iteración.</target>
        </trans-unit>
        <trans-unit id="6416948697e16aeabbf92ec68782960804a2782d" translate="yes" xml:space="preserve">
          <source>The methods of a &lt;code&gt;PromiseResolver&lt;/code&gt; have no effect if the fate of the underlying promise is already decided (follow, reject, fulfill).</source>
          <target state="translated">Los m&amp;eacute;todos de un &lt;code&gt;PromiseResolver&lt;/code&gt; no tienen efecto si el destino de la promesa subyacente ya est&amp;aacute; decidido (seguir, rechazar, cumplir).</target>
        </trans-unit>
        <trans-unit id="666da53e9ba5fafe397413f91312c555ed1b2845" translate="yes" xml:space="preserve">
          <source>The mortals that can handle it may now release Zalgo by &lt;code&gt;require(&quot;bluebird/zalgo&quot;);&lt;/code&gt;</source>
          <target state="translated">Los mortales que pueden manejarlo ahora pueden liberar Zalgo por &lt;code&gt;require(&quot;bluebird/zalgo&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="788c3f097a42e7ff06bdab38fdaf7df400494dfe" translate="yes" xml:space="preserve">
          <source>The new cancellation has &quot;don't care&quot; semantics while the old cancellation had abort semantics. Cancelling a promise simply means that its handler callbacks will not be called.</source>
          <target state="translated">La nueva cancelación tiene una semántica de &quot;no me importa&quot; mientras que la vieja cancelación tenía una semántica de abortar.Cancelar una promesa simplemente significa que no se llamará a su responsable.</target>
        </trans-unit>
        <trans-unit id="9a98aedc50b84c7ebb0badc2de651f3ecf8937b9" translate="yes" xml:space="preserve">
          <source>The object predicate passed to &lt;code&gt;.catch&lt;/code&gt; in the above code (&lt;code&gt;{code: 'ENOENT'}&lt;/code&gt;) is shorthand for a predicate function &lt;code&gt;function predicate(e) { return isObject(e) &amp;amp;&amp;amp; e.code == 'ENOENT' }&lt;/code&gt;, I.E. loose equality is used.</source>
          <target state="translated">El predicado de objeto pasado a &lt;code&gt;.catch&lt;/code&gt; en el c&amp;oacute;digo anterior ( &lt;code&gt;{code: 'ENOENT'}&lt;/code&gt; ) es la abreviatura de una &lt;code&gt;function predicate(e) { return isObject(e) &amp;amp;&amp;amp; e.code == 'ENOENT' }&lt;/code&gt; , IE suelto se usa la igualdad.</target>
        </trans-unit>
        <trans-unit id="25c421b7ad33c6aa4c4ac1a5b06c22ec76d37875" translate="yes" xml:space="preserve">
          <source>The old progression API was meant to be used for tracking the progress of promise resolution. In retrospect, it did not work or compose very well. We understand that problem better now and the use case could be better solved without it.</source>
          <target state="translated">El antiguo API de progresión estaba destinado a ser utilizado para el seguimiento del progreso de la resolución de promesas.En retrospectiva,no funcionaba ni componía muy bien.Ahora entendemos mejor ese problema y el caso de uso podría resolverse mejor sin él.</target>
        </trans-unit>
        <trans-unit id="090f1f6fbdfbd7a3e0db64396e47bb24d64eb73a" translate="yes" xml:space="preserve">
          <source>The order &lt;code&gt;map&lt;/code&gt; calls the mapper function on the array elements is not specified, there is no guarantee on the order in which it'll execute the &lt;code&gt;map&lt;/code&gt;er on the elements. For order guarantee in sequential execution - see &lt;a href=&quot;promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El fin &lt;code&gt;map&lt;/code&gt; a llama a la funci&amp;oacute;n asignador de los elementos de la matriz no se especifica, no hay ninguna garant&amp;iacute;a sobre el orden en el que se va a ejecutar el &lt;code&gt;map&lt;/code&gt; a er en los elementos. Para la garant&amp;iacute;a del pedido en ejecuci&amp;oacute;n secuencial, consulte &lt;a href=&quot;promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22323bb03a1bb54a462c5535aaf1a55e597ca564" translate="yes" xml:space="preserve">
          <source>The problem with the above is that &lt;code&gt;getConnection&lt;/code&gt; itself might throw for some reason and if it does we'll get a synchronous rejection. An asynchronous operation should always be asynchronous to prevent double guarding and race conditions so it's best to always put the sync parts inside the promise constructor as such:</source>
          <target state="translated">El problema con lo anterior es que &lt;code&gt;getConnection&lt;/code&gt; podr&amp;iacute;a arrojarse por alguna raz&amp;oacute;n y si lo hace, obtendremos un rechazo sincr&amp;oacute;nico. Una operaci&amp;oacute;n asincr&amp;oacute;nica siempre debe ser asincr&amp;oacute;nica para evitar la doble protecci&amp;oacute;n y las condiciones de carrera, por lo que es mejor colocar siempre las partes de sincronizaci&amp;oacute;n dentro del constructor de la promesa como tal:</target>
        </trans-unit>
        <trans-unit id="5b81307bb00a714d49523b7e191e0b6160f8ce58" translate="yes" xml:space="preserve">
          <source>The promisifier gets a reference to the original method and should return a function which returns a promise.</source>
          <target state="translated">El promotor obtiene una referencia al método original y debe devolver una función que devuelva una promesa.</target>
        </trans-unit>
        <trans-unit id="1a87fc5ef703ad3003e186be301223055a0f1187" translate="yes" xml:space="preserve">
          <source>The resolver function is passed a callback that expects to be called back according to error-first node conventions.</source>
          <target state="translated">A la función de resolución se le pasa una llamada de retorno que espera ser llamada de acuerdo con las convenciones de los nodos de error primero.</target>
        </trans-unit>
        <trans-unit id="db5aac58e5c09043c491849101f61a81a5b4d12d" translate="yes" xml:space="preserve">
          <source>The resolver is called synchronously (the following is for documentation purposes and not idiomatic code):</source>
          <target state="translated">La resolución se llama sincrónicamente (lo siguiente es para fines de documentación y no un código idiomático):</target>
        </trans-unit>
        <trans-unit id="fa4bfc9835f1db3d068610dc3f23387d9b6dbcae" translate="yes" xml:space="preserve">
          <source>The same can also be written more concisely with &lt;code&gt;Function.prototype.bind&lt;/code&gt;:</source>
          <target state="translated">Lo mismo tambi&amp;eacute;n se puede escribir de manera m&amp;aacute;s concisa con &lt;code&gt;Function.prototype.bind&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e4d032a40184c01ff45a4fcd6a47f5f6ed12cc2d" translate="yes" xml:space="preserve">
          <source>The same thing can be done with less code using jQuery's &lt;a href=&quot;https://api.jquery.com/on/#event-names&quot;&gt;event namespacing&lt;/a&gt;.</source>
          <target state="translated">Lo mismo se puede hacer con menos c&amp;oacute;digo utilizando el &lt;a href=&quot;https://api.jquery.com/on/#event-names&quot;&gt;espacio de nombres de eventos&lt;/a&gt; de jQuery .</target>
        </trans-unit>
        <trans-unit id="3c2a20abb7e468fc73f206d7f17b3365726ea73c" translate="yes" xml:space="preserve">
          <source>The second argument passed to a disposer is the result promise of the using block, which you can inspect synchronously.</source>
          <target state="translated">El segundo argumento que se le pasa a un triturador es la promesa de resultado del bloque de uso,que se puede inspeccionar de forma sincronizada.</target>
        </trans-unit>
        <trans-unit id="7e1062ee61728ebe80f9bce80f90c97c30f5a642" translate="yes" xml:space="preserve">
          <source>The situation can be fixed with &lt;code&gt;.finally&lt;/code&gt;:</source>
          <target state="translated">La situaci&amp;oacute;n se puede solucionar con &lt;code&gt;.finally&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d8cfd5d14e8e321897ce3ab8e2b61c1f01768a60" translate="yes" xml:space="preserve">
          <source>The solution is to either convert it to a promise by calling &lt;code&gt;Promise.resolve&lt;/code&gt; on it or &lt;code&gt;Promise.promisify&lt;/code&gt; if it's a callback:</source>
          <target state="translated">La soluci&amp;oacute;n es convertirlo en una promesa llamando a &lt;code&gt;Promise.resolve&lt;/code&gt; o &lt;code&gt;Promise.promisify&lt;/code&gt; si es una devoluci&amp;oacute;n de llamada:</target>
        </trans-unit>
        <trans-unit id="a959d4cee575b4382df36392cd8df64e24184dbc" translate="yes" xml:space="preserve">
          <source>The stack trace for &lt;a href=&quot;warning-explanations#warning-a-promise-was-created-in-a-handler-but-none-were-returned-from-it&quot;&gt;forgotten return warnings&lt;/a&gt; is more useful now.</source>
          <target state="translated">El seguimiento de la pila de &lt;a href=&quot;warning-explanations#warning-a-promise-was-created-in-a-handler-but-none-were-returned-from-it&quot;&gt;advertencias de devoluci&amp;oacute;n olvidadas&lt;/a&gt; es m&amp;aacute;s &amp;uacute;til ahora.</target>
        </trans-unit>
        <trans-unit id="b7cfeae4442044317b39c717825ad07af88a84b2" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;Promises/A+ &lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; is still supported by Bluebird and support for it will continue indefinitely . However, the variant accepting a third &lt;code&gt;progressHandler&lt;/code&gt; argument is no longer supported.</source>
          <target state="translated">El est&amp;aacute;ndar &lt;a href=&quot;http://promises-aplus.github.io/promises-spec/&quot;&gt;Promises / A + &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; todav&amp;iacute;a es compatible con Bluebird y el soporte continuar&amp;aacute; indefinidamente. Sin embargo, la variante que acepta un tercer argumento &lt;code&gt;progressHandler&lt;/code&gt; ya no es compatible.</target>
        </trans-unit>
        <trans-unit id="0578afb0e805324fd3d6ef6661225daacb79ec32" translate="yes" xml:space="preserve">
          <source>The suffix must be a valid JavaScript identifier using ASCII letters</source>
          <target state="translated">El sufijo debe ser un identificador JavaScript válido usando letras ASCII</target>
        </trans-unit>
        <trans-unit id="51e5ddd442738d3ba0fcf36bd1580ce1e7b6558a" translate="yes" xml:space="preserve">
          <source>The usage pattern is similar to the PostgreSQL example above. You can also use a disposer pattern (but not an actual .disposer). See the PostgreSQL example above for instructions.</source>
          <target state="translated">El patrón de uso es similar al ejemplo de PostgreSQL anterior.También puede usar un patrón de eliminación (pero no un .disposer real).Consulte el ejemplo de PostgreSQL anterior para obtener instrucciones.</target>
        </trans-unit>
        <trans-unit id="28bb7fa145553052b5508efe6d9bb705def39d86" translate="yes" xml:space="preserve">
          <source>The usual way to use promises in node is to &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; some API and start exclusively calling promise returning versions of the APIs methods. E.g.</source>
          <target state="translated">La forma habitual de usar promesas en el nodo es &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; algunas API y comenzar a llamar exclusivamente a las versiones prometedoras de los m&amp;eacute;todos de API. P.ej</target>
        </trans-unit>
        <trans-unit id="9d0826c3236c309fa1a8bb247d52444104239f26" translate="yes" xml:space="preserve">
          <source>The usual way to use promises in node is to &lt;a href=&quot;promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; some API and start exclusively calling promise returning versions of the APIs methods. E.g.</source>
          <target state="translated">La forma habitual de usar promesas en el nodo es &lt;a href=&quot;promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; algunas API y comenzar a llamar exclusivamente a las versiones prometedoras de los m&amp;eacute;todos de API. P.ej</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="fdf91bb0325fcdd18970709eb26b34f64a3672d1" translate="yes" xml:space="preserve">
          <source>There are many third party promise libraries available for JavaScript and even the standard library contains a promise implementation in newer versions of browsers and node/io.js. This page will explore why one might use bluebird promises over other third party or the standard library implementations. For reasons to use promises in general, see the &lt;a href=&quot;why-promises&quot;&gt;Why Promises?&lt;/a&gt; article.</source>
          <target state="translated">Hay muchas bibliotecas de promesas de terceros disponibles para JavaScript e incluso la biblioteca est&amp;aacute;ndar contiene una implementaci&amp;oacute;n de promesas en versiones m&amp;aacute;s recientes de navegadores y node / io.js. Esta p&amp;aacute;gina explorar&amp;aacute; por qu&amp;eacute; se pueden usar promesas bluebird sobre otras implementaciones de bibliotecas est&amp;aacute;ndar o de terceros. Para conocer las razones para usar promesas en general, consulte &lt;a href=&quot;why-promises&quot;&gt;&amp;iquest;Por qu&amp;eacute; promesas? &lt;/a&gt;art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="12dfbb41929f3ee02dc34311b3347fac9dec5515" translate="yes" xml:space="preserve">
          <source>There are many third party promise libraries available for JavaScript and even the standard library contains a promise implementation in newer versions of browsers and node/io.js. This page will explore why one might use bluebird promises over other third party or the standard library implementations. For reasons why to use promises in general, see the &lt;a href=&quot;why-promises&quot;&gt;Why Promises?&lt;/a&gt; article.</source>
          <target state="translated">Hay muchas bibliotecas prometedoras de terceros disponibles para JavaScript e incluso la biblioteca est&amp;aacute;ndar contiene una implementaci&amp;oacute;n prometedora en versiones m&amp;aacute;s recientes de navegadores y node / io.js. Esta p&amp;aacute;gina explorar&amp;aacute; por qu&amp;eacute; uno podr&amp;iacute;a usar las promesas de bluebird sobre terceros o las implementaciones est&amp;aacute;ndar de la biblioteca. Para conocer las razones por las cuales se usan las promesas en general, consulte &lt;a href=&quot;why-promises&quot;&gt;&amp;iquest;Por qu&amp;eacute; las promesas? &lt;/a&gt;art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="0016f6e7c65d90d1ef2d07a4adbd7695a74d6216" translate="yes" xml:space="preserve">
          <source>There are many ways to use bluebird in browsers:</source>
          <target state="translated">Hay muchas maneras de usar el pájaro azul en los navegadores:</target>
        </trans-unit>
        <trans-unit id="acfa8f7a74926d5b3e71d319fe2e3737e67b4a45" translate="yes" xml:space="preserve">
          <source>There are still a few problems with the earlier code example. It feels like it is doing too much. A &lt;em&gt;squint&lt;/em&gt; test reveals behavior for showing the dialog, set the dialog's message, attach two DOM events, construct a promise, event delegation, hide the dialog, and finally detach DOM events. That is a lot for one little function. A refactoring can help.</source>
          <target state="translated">Todav&amp;iacute;a hay algunos problemas con el ejemplo de c&amp;oacute;digo anterior. Parece que est&amp;aacute; haciendo demasiado. Una prueba de &lt;em&gt;estrabismo&lt;/em&gt; revela el comportamiento para mostrar el di&amp;aacute;logo, establecer el mensaje del di&amp;aacute;logo, adjuntar dos eventos DOM, construir una promesa, delegaci&amp;oacute;n de eventos, ocultar el di&amp;aacute;logo y finalmente separar los eventos DOM. Eso es mucho para una peque&amp;ntilde;a funci&amp;oacute;n. Una refactorizaci&amp;oacute;n puede ayudar.</target>
        </trans-unit>
        <trans-unit id="c2d9fdb7b10a480524179ca553be134c2cab93bd" translate="yes" xml:space="preserve">
          <source>There are two primary methods of converting callback based APIs into promise based ones. You can either manually map the API calls to promise returning functions or you can let the bluebird do it for you. We &lt;strong&gt;strongly&lt;/strong&gt; recommend the latter.</source>
          <target state="translated">Hay dos m&amp;eacute;todos principales para convertir las API basadas en devoluci&amp;oacute;n de llamada en las basadas en promesas. Puede asignar manualmente las llamadas a la API para prometer funciones de retorno o puede dejar que el bluebird lo haga por usted. Nosotros &lt;strong&gt;fuertemente&lt;/strong&gt; recomendamos este &amp;uacute;ltimo.</target>
        </trans-unit>
        <trans-unit id="f594978f8f4cce365338daa917338cba030de34d" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;http://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;this more general StackOverflow question&lt;/a&gt; about conversion of callback APIs to promises. If you find anything missing in this guide however, please do open an issue or pull request.</source>
          <target state="translated">Tambi&amp;eacute;n existe &lt;a href=&quot;http://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;esta pregunta m&amp;aacute;s general de StackOverflow&lt;/a&gt; sobre la conversi&amp;oacute;n de API de devoluci&amp;oacute;n de llamada a promesas. Sin embargo, si encuentra algo que falta en esta gu&amp;iacute;a, abra un problema o una solicitud de extracci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="82ffbfbc41fe53312b41cce044330748666500e8" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://www.promisejs.org/generators/&quot;&gt;excellent article&lt;/a&gt; on promisejs.org detailing how to combine promises with generators to achieve much cleaner code. Instead of the &lt;code&gt;async&lt;/code&gt; function the article proposes, you can use &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hay un &lt;a href=&quot;https://www.promisejs.org/generators/&quot;&gt;excelente art&amp;iacute;culo&lt;/a&gt; en promisejs.org que detalla c&amp;oacute;mo combinar promesas con generadores para lograr un c&amp;oacute;digo mucho m&amp;aacute;s limpio. En lugar de la funci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; propone el art&amp;iacute;culo, puede usar &lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccd6b50860623f70756069f499d23f01b6d13e5c" translate="yes" xml:space="preserve">
          <source>There is no effect on performance if the user doesn't actually pass a node-style callback function.</source>
          <target state="translated">No hay ningún efecto en el rendimiento si el usuario no pasa realmente una función de devolución de llamada de estilo nodal.</target>
        </trans-unit>
        <trans-unit id="a899a39eea077d35fbd555f33e92cdecfa97e0f3" translate="yes" xml:space="preserve">
          <source>There is no need to convert timeouts/delays to a bluebird API, bluebird already ships with the &lt;a href=&quot;api/promise.delay&quot;&gt;&lt;code&gt;Promise.delay&lt;/code&gt;&lt;/a&gt; function for this use case. Please consult the &lt;a href=&quot;api/timers&quot;&gt;&lt;code&gt;timers&lt;/code&gt;&lt;/a&gt; section of the docs on usage and examples.</source>
          <target state="translated">No hay necesidad de convertir tiempos de espera / retrasos a una API de bluebird, bluebird ya viene con la funci&amp;oacute;n &lt;a href=&quot;api/promise.delay&quot;&gt; &lt;code&gt;Promise.delay&lt;/code&gt; &lt;/a&gt; para este caso de uso. Consulte la secci&amp;oacute;n de &lt;a href=&quot;api/timers&quot;&gt; &lt;code&gt;timers&lt;/code&gt; &lt;/a&gt; de los documentos sobre el uso y los ejemplos.</target>
        </trans-unit>
        <trans-unit id="816256e371a68e0a4e42cc5d7e31e59e968b1550" translate="yes" xml:space="preserve">
          <source>This APIs are what most core modules in Node/io use and bluebird comes with a fast and efficient way to convert them to promise based APIs through the &lt;code&gt;Promise.promisify&lt;/code&gt; and &lt;code&gt;Promise.promisifyAll&lt;/code&gt; function calls.</source>
          <target state="translated">Estas API son las que utilizan la mayor&amp;iacute;a de los m&amp;oacute;dulos centrales en Node / io y bluebird viene con una forma r&amp;aacute;pida y eficiente de convertirlas en API basadas en promesas a trav&amp;eacute;s de las llamadas a funciones &lt;code&gt;Promise.promisify&lt;/code&gt; y &lt;code&gt;Promise.promisifyAll&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d88bc0890f9955d9aafd69e5e422f7404df8670" translate="yes" xml:space="preserve">
          <source>This abstraction can be expanded on in other ways. For example a notification dialog:</source>
          <target state="translated">Esta abstracción puede ser ampliada de otras maneras.Por ejemplo,un diálogo de notificación:</target>
        </trans-unit>
        <trans-unit id="4ef92d2a854bbe01523868d53a897ee9b600001a" translate="yes" xml:space="preserve">
          <source>This also happens when implementing live-updating models with a &lt;code&gt;.then&lt;/code&gt; method that indicates when the model is &quot;ready&quot;. A promise is a process, it starts and it ends.</source>
          <target state="translated">Esto tambi&amp;eacute;n sucede al implementar modelos de actualizaci&amp;oacute;n en vivo con un m&amp;eacute;todo &lt;code&gt;.then&lt;/code&gt; que indica cu&amp;aacute;ndo el modelo est&amp;aacute; &quot;listo&quot;. Una promesa es un proceso, comienza y termina.</target>
        </trans-unit>
        <trans-unit id="1d9ddcdc77c9d4a96e7a508b17988600ecaa73fc" translate="yes" xml:space="preserve">
          <source>This also means that disposers should not contain code that does anything other than resource disposal. For example, you cannot write code inside a disposer to commit or rollback a transaction, because there is no mechanism for the disposer to signal a failure of the commit or rollback action without crashing the process.</source>
          <target state="translated">Esto también significa que los trituradores de desechos no deben contener un código que haga otra cosa que no sea la eliminación de recursos.Por ejemplo,no se puede escribir código dentro de un triturador de desechos para confirmar o anular una transacción,porque no hay ningún mecanismo para que el triturador de desechos señale un fallo en la acción de confirmar o anular sin interrumpir el proceso.</target>
        </trans-unit>
        <trans-unit id="66b2c8b4731b0f7ba7e6bf98e67448082824c523" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/api/promise.each.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">Este art&amp;iacute;culo est&amp;aacute; parcial o completamente sin terminar. Puede crear &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/api/promise.each.md&quot;&gt;solicitudes de extracci&amp;oacute;n&lt;/a&gt; para ayudar a completar este art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="9b70a0a7654e551108da4764c9f005aab32644aa" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/async-dialogs.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">Este art&amp;iacute;culo est&amp;aacute; parcial o completamente sin terminar. Puede crear &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/async-dialogs.md&quot;&gt;solicitudes de extracci&amp;oacute;n&lt;/a&gt; para ayudar a completar este art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="e1c525d7a299f5e8e85d4de9a717c3aacb38e9c7" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/beginners-guide.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">Este art&amp;iacute;culo est&amp;aacute; parcial o completamente sin terminar. Puede crear &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/beginners-guide.md&quot;&gt;solicitudes de extracci&amp;oacute;n&lt;/a&gt; para ayudar a completar este art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="c52f9c032871178393d4fecda1b976e39b1a06b1" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/deprecated-apis.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">Este art&amp;iacute;culo est&amp;aacute; parcial o completamente sin terminar. Puede crear &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/deprecated-apis.md&quot;&gt;solicitudes de extracci&amp;oacute;n&lt;/a&gt; para ayudar a completar este art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="b6f8fae1cd767c72257bf951d6fae38ca4750167" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/features.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">Este art&amp;iacute;culo est&amp;aacute; parcial o completamente sin terminar. Puede crear &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/features.md&quot;&gt;solicitudes de extracci&amp;oacute;n&lt;/a&gt; para ayudar a completar este art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="0b80a141eb9286b1bcd67d018003d3e43d4ca6b1" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/getting-started.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">Este art&amp;iacute;culo est&amp;aacute; parcial o completamente sin terminar. Puede crear &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/getting-started.md&quot;&gt;solicitudes de extracci&amp;oacute;n&lt;/a&gt; para ayudar a completar este art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="c9d9ce5a1a1cedf3cd3c1bf2b642c4920ce3d476" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/warning-explanations.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">Este art&amp;iacute;culo est&amp;aacute; parcial o completamente sin terminar. Puede crear &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/warning-explanations.md&quot;&gt;solicitudes de extracci&amp;oacute;n&lt;/a&gt; para ayudar a completar este art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="01153e43a1c1cb6db13e7e38cfc4a7ca277baf87" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/what-about-generators.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">Este art&amp;iacute;culo est&amp;aacute; parcial o completamente sin terminar. Puede crear &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/what-about-generators.md&quot;&gt;solicitudes de extracci&amp;oacute;n&lt;/a&gt; para ayudar a completar este art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="3b2b6fdf4dc9492f2c92f1362815d504f5b44c1e" translate="yes" xml:space="preserve">
          <source>This article is partially or completely unfinished. You are welcome to create &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/why-performance.md&quot;&gt;pull requests&lt;/a&gt; to help completing this article.</source>
          <target state="translated">Este art&amp;iacute;culo est&amp;aacute; parcial o completamente sin terminar. Puede crear &lt;a href=&quot;https://github.com/petkaantonov/bluebird/edit/master/docs/docs/why-performance.md&quot;&gt;solicitudes de extracci&amp;oacute;n&lt;/a&gt; para ayudar a completar este art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="7a69f82bc8c73af862fe6ee2765641d403ac8822" translate="yes" xml:space="preserve">
          <source>This can be used to create APIs that both accept node-style callbacks and return promises:</source>
          <target state="translated">Esto puede ser usado para crear APIs que acepten tanto llamadas de devolución de nodos como promesas de devolución:</target>
        </trans-unit>
        <trans-unit id="2af698572346d77b6e2820e63d397c65adf61bf3" translate="yes" xml:space="preserve">
          <source>This can be useful if a function returns a promise (say into a chain) but can optionally return a static value. Say, for a lazy-loaded value. Example:</source>
          <target state="translated">Esto puede ser útil si una función devuelve una promesa (digamos en una cadena)pero puede opcionalmente devolver un valor estático.Digamos,para un valor de carga perezosa.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="01154032238ce0a62f38ce2edfeea44425f1609e" translate="yes" xml:space="preserve">
          <source>This can happen when you are calling &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; on a function and invoking it instead of passing it.</source>
          <target state="translated">Esto puede suceder cuando llama a &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; en una funci&amp;oacute;n y la invoca en lugar de pasarla.</target>
        </trans-unit>
        <trans-unit id="b7e20e128e0a8a57b67f7c7c358d05477f3c5d61" translate="yes" xml:space="preserve">
          <source>This can happen when you tried to do something like:</source>
          <target state="translated">Esto puede suceder cuando tratas de hacer algo como:</target>
        </trans-unit>
        <trans-unit id="caac030e0f988203bfd2f85f66f13be073b83988" translate="yes" xml:space="preserve">
          <source>This doesn't add much much using &lt;code&gt;window.prompt&lt;/code&gt;; however, one advantage is the API that promises provide. In the case where we call &lt;code&gt;promptPromise(&amp;hellip;)&lt;/code&gt; we can easily react to the result of the dialog without having to worry about how it is implemented. In our example we've implemented the &lt;code&gt;window.prompt&lt;/code&gt; but our call to &lt;code&gt;promptPromise()&lt;/code&gt; doesn't care. This makes a change to an &lt;em&gt;asynchronous&lt;/em&gt; dialog a little more future proof.</source>
          <target state="translated">Esto no agrega mucho usando &lt;code&gt;window.prompt&lt;/code&gt; ; Sin embargo, una ventaja es la API que las promesas proporcionan. En el caso de que llamemos a &lt;code&gt;promptPromise(&amp;hellip;)&lt;/code&gt; , podemos reaccionar f&amp;aacute;cilmente al resultado del di&amp;aacute;logo sin tener que preocuparnos de c&amp;oacute;mo se implementa. En nuestro ejemplo, hemos implementado &lt;code&gt;window.prompt&lt;/code&gt; , pero nuestra llamada a &lt;code&gt;promptPromise()&lt;/code&gt; no importa. Esto hace que un cambio a un di&amp;aacute;logo &lt;em&gt;asincr&amp;oacute;nico sea&lt;/em&gt; un poco m&amp;aacute;s a prueba de futuro.</target>
        </trans-unit>
        <trans-unit id="71b6120513a7366580cee8aba7b9480ac2cf93a2" translate="yes" xml:space="preserve">
          <source>This error indicates you have tried to call &lt;a href=&quot;api/promise.promisifyall&quot;&gt;&lt;code&gt;Promise.promisifyAll&lt;/code&gt;&lt;/a&gt; on an object that already has a property with the &lt;code&gt;Async&lt;/code&gt; suffix:</source>
          <target state="translated">Este error indica que ha intentado llamar a &lt;a href=&quot;api/promise.promisifyall&quot;&gt; &lt;code&gt;Promise.promisifyAll&lt;/code&gt; &lt;/a&gt; en un objeto que ya tiene una propiedad con el sufijo &lt;code&gt;Async&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a572d9a56addbf0b78e49d060a13678d16002f76" translate="yes" xml:space="preserve">
          <source>This example doesn't work as intended because the &lt;code&gt;then&lt;/code&gt; handler actually swallows the exception and returns &lt;code&gt;undefined&lt;/code&gt; for any further chainers.</source>
          <target state="translated">Este ejemplo no funciona como se pretende porque el &lt;code&gt;then&lt;/code&gt; manejador realidad traga la excepci&amp;oacute;n y regresa &lt;code&gt;undefined&lt;/code&gt; para cualquier chainers adicionales.</target>
        </trans-unit>
        <trans-unit id="7c54ec4bcf6b3320c0e8ec781b0cb320bbd68320" translate="yes" xml:space="preserve">
          <source>This example pings 4 nameservers, and logs the fastest 2 on console:</source>
          <target state="translated">Este ejemplo hace un ping a 4 servidores de nombre,y registra los 2 más rápidos en la consola:</target>
        </trans-unit>
        <trans-unit id="2b07ce3ee1a174adcf4f487506a3c9e336575eaf" translate="yes" xml:space="preserve">
          <source>This feature enables subscription to promise lifecycle events via standard global events mechanisms in browsers and Node.js.</source>
          <target state="translated">Esta característica permite que la suscripción prometa eventos del ciclo de vida a través de mecanismos estándar de eventos globales en los navegadores y Node.js.</target>
        </trans-unit>
        <trans-unit id="876ee350821244d6855a5b5648beee14fb439673" translate="yes" xml:space="preserve">
          <source>This feature has to be explicitly enabled by calling &lt;a href=&quot;api/promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;monitoring: true&lt;/code&gt;.</source>
          <target state="translated">Esta caracter&amp;iacute;stica tiene que habilitarse expl&amp;iacute;citamente llamando a &lt;a href=&quot;api/promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt; con la &lt;code&gt;monitoring: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca7179462cda9a709541b309d7c01bbb585212a4" translate="yes" xml:space="preserve">
          <source>This file contains documentation for APIs that are no longer supported by Bluebird. These APIs still work in Bluebird but will be removed at a future version of the library.</source>
          <target state="translated">Este archivo contiene documentación para las API que ya no son compatibles con Bluebird.Estas APIs siguen funcionando en Bluebird pero serán eliminadas en una futura versión de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="4e1d1e209b1192c78f57f02dae0b2d4bf136ca53" translate="yes" xml:space="preserve">
          <source>This happens when a non object value or a promise that resolves with something that is not an object is being passed instead.</source>
          <target state="translated">Esto sucede cuando un valor no objeto o una promesa que se resuelve con algo que no es un objeto se pasa en su lugar.</target>
        </trans-unit>
        <trans-unit id="fb3b4bfaeb441a21b0068d6c2bb1331473c59ffc" translate="yes" xml:space="preserve">
          <source>This happens when you call &lt;code&gt;.some&lt;/code&gt; passing it a negative value or a non-integer.</source>
          <target state="translated">Esto sucede cuando llama a &lt;code&gt;.some&lt;/code&gt; pasando un valor negativo o no entero.</target>
        </trans-unit>
        <trans-unit id="361cf2ec170969184f8f35c3d2c58d91c88e0978" translate="yes" xml:space="preserve">
          <source>This inherits from &lt;code&gt;Dialog&lt;/code&gt; and stores references to the required DOM elements that this dialog uses. It then attaches the require DOM events (&lt;code&gt;attachDomEvents()&lt;/code&gt;) which eventually call the callbacks. Then it implements the &lt;code&gt;show()&lt;/code&gt; and &lt;code&gt;hide()&lt;/code&gt; methods. Its usage is more flexible and verbose:</source>
          <target state="translated">Esto hereda del cuadro de &lt;code&gt;Dialog&lt;/code&gt; y almacena referencias a los elementos DOM necesarios que utiliza este cuadro de di&amp;aacute;logo. Luego adjunta los eventos DOM requeridos ( &lt;code&gt;attachDomEvents()&lt;/code&gt; ) que eventualmente llaman las devoluciones de llamada. Luego implementa los m&amp;eacute;todos &lt;code&gt;show()&lt;/code&gt; y &lt;code&gt;hide()&lt;/code&gt; . Su uso es m&amp;aacute;s flexible y detallado:</target>
        </trans-unit>
        <trans-unit id="1c40c501429304b951f3e9a1e618216d7da3fae9" translate="yes" xml:space="preserve">
          <source>This interface is implemented by &lt;code&gt;Promise&lt;/code&gt; instances as well as the &lt;code&gt;PromiseInspection&lt;/code&gt; result given by &lt;a href=&quot;reflect&quot;&gt;&lt;code&gt;.reflect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta interfaz es implementada por instancias de &lt;code&gt;Promise&lt;/code&gt; , as&amp;iacute; como el resultado de &lt;code&gt;PromiseInspection&lt;/code&gt; dado por &lt;a href=&quot;reflect&quot;&gt; &lt;code&gt;.reflect()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1625642eae18357d2f9d1a1405e4d5fa15c5195c" translate="yes" xml:space="preserve">
          <source>This is Gorki Kosev's benchmark used in the article &lt;a href=&quot;http://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html&quot;&gt;Analysis of generators and other async patterns in node&lt;/a&gt;. The benchmark emulates a situation where N=10000 requests are being made concurrently to execute some mixed async/sync action with fast I/O response times.</source>
          <target state="translated">Este es el punto de referencia de Gorki Kosev utilizado en el art&amp;iacute;culo &lt;a href=&quot;http://spion.github.io/posts/analysis-generators-and-other-async-patterns-node.html&quot;&gt;An&amp;aacute;lisis de generadores y otros patrones as&amp;iacute;ncronos en el nodo&lt;/a&gt; . El punto de referencia emula una situaci&amp;oacute;n en la que se realizan N = 10000 solicitudes simult&amp;aacute;neamente para ejecutar una acci&amp;oacute;n mixta de sincronizaci&amp;oacute;n / sincronizaci&amp;oacute;n con tiempos de respuesta de E / S r&amp;aacute;pidos.</target>
        </trans-unit>
        <trans-unit id="c49dfefe9b869fa007a2d85f8deb59c16587b42f" translate="yes" xml:space="preserve">
          <source>This is a catch-all exception handler, shortcut for calling &lt;a href=&quot;then&quot;&gt;&lt;code&gt;.then(null, handler)&lt;/code&gt;&lt;/a&gt; on this promise. Any exception happening in a &lt;code&gt;.then&lt;/code&gt;-chain will propagate to nearest &lt;code&gt;.catch&lt;/code&gt; handler.</source>
          <target state="translated">Este es un controlador de excepci&amp;oacute;n general, acceso directo para llamar a &lt;a href=&quot;then&quot;&gt; &lt;code&gt;.then(null, handler)&lt;/code&gt; &lt;/a&gt; en esta promesa. Cualquier excepci&amp;oacute;n que ocurra en un &lt;code&gt;.then&lt;/code&gt; -chain se propagar&amp;aacute; al controlador &lt;code&gt;.catch&lt;/code&gt; m&amp;aacute;s cercano .</target>
        </trans-unit>
        <trans-unit id="41cc0d7fb9773615b0a72dbe0951bb7f568b688b" translate="yes" xml:space="preserve">
          <source>This is a convenience method for doing:</source>
          <target state="translated">Este es un método conveniente para hacer:</target>
        </trans-unit>
        <trans-unit id="ab45ed2cecaf14b1bbcc736ecc5d3c6da77d3562" translate="yes" xml:space="preserve">
          <source>This is a throughput benchmark.</source>
          <target state="translated">Este es un punto de referencia de rendimiento.</target>
        </trans-unit>
        <trans-unit id="0bb50cb46856cf19733b9b720a91a5dbcedf8961" translate="yes" xml:space="preserve">
          <source>This is an extension to &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; to work more like catch-clauses in languages like Java or C#. Instead of manually checking &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt;, you may specify a number of error constructors which are eligible for this catch handler. The catch handler that is first met that has eligible constructors specified, is the one that will be called.</source>
          <target state="translated">Esta es una extensi&amp;oacute;n de &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt; para funcionar m&amp;aacute;s como cl&amp;aacute;usulas catch en lenguajes como Java o C #. En lugar de verificar manualmente &lt;code&gt;instanceof&lt;/code&gt; o &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt; , puede especificar una serie de constructores de errores que son elegibles para este controlador de captura. El controlador de captura que se cumple por primera vez que tiene especificados constructores elegibles, es el que se llamar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="4e6f1e1654fff47bb7489453d9f0b688afc82574" translate="yes" xml:space="preserve">
          <source>This is an extension to &lt;a href=&quot;tapcatch&quot;&gt;&lt;code&gt;.tapCatch&lt;/code&gt;&lt;/a&gt; to filter exceptions similarly to languages like Java or C#. Instead of manually checking &lt;code&gt;instanceof&lt;/code&gt; or &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt;, you may specify a number of error constructors which are eligible for this tapCatch handler. The tapCatch handler that is first met that has eligible constructors specified, is the one that will be called.</source>
          <target state="translated">Esta es una extensi&amp;oacute;n de &lt;a href=&quot;tapcatch&quot;&gt; &lt;code&gt;.tapCatch&lt;/code&gt; &lt;/a&gt; para filtrar excepciones de manera similar a lenguajes como Java o C #. En lugar de verificar manualmente &lt;code&gt;instanceof&lt;/code&gt; o &lt;code&gt;.name === &quot;SomeError&quot;&lt;/code&gt; , puede especificar una serie de constructores de errores que son elegibles para este controlador tapCatch. El controlador tapCatch que se cumple por primera vez que tiene especificados los constructores elegibles, es el que se llamar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="de9b1d19482e049c5d2755c5328d90634cf4cf49" translate="yes" xml:space="preserve">
          <source>This is because Bluebird adds the &lt;code&gt;Async&lt;/code&gt; suffix to distinguish the original method from the promisified one, so &lt;code&gt;fooAsync&lt;/code&gt; would have been overridden. In order to avoid this - either rename &lt;code&gt;fooAsync&lt;/code&gt; before promisifying the API, or call &lt;a href=&quot;api/promise.promisify&quot;&gt;&lt;code&gt;Promise.promisify&lt;/code&gt;&lt;/a&gt; manually on select properties.</source>
          <target state="translated">Esto se debe a que Bluebird agrega el sufijo &lt;code&gt;Async&lt;/code&gt; para distinguir el m&amp;eacute;todo original del prometido, por lo que &lt;code&gt;fooAsync&lt;/code&gt; se habr&amp;iacute;a anulado. Para evitar esto, cambie el nombre de &lt;code&gt;fooAsync&lt;/code&gt; antes de promisificar la API o llame a &lt;a href=&quot;api/promise.promisify&quot;&gt; &lt;code&gt;Promise.promisify&lt;/code&gt; &lt;/a&gt; manualmente en las propiedades seleccionadas.</target>
        </trans-unit>
        <trans-unit id="fb04140a6d6f4216a6dfa405bfd92da440efbba0" translate="yes" xml:space="preserve">
          <source>This is exactly like the synchronous code:</source>
          <target state="translated">Esto es exactamente como el código sincrónico:</target>
        </trans-unit>
        <trans-unit id="bfb76de6040fe50d520474f7810629da738b7706" translate="yes" xml:space="preserve">
          <source>This is far more readable when done with promises:</source>
          <target state="translated">Esto es mucho más legible cuando se hace con promesas:</target>
        </trans-unit>
        <trans-unit id="618293c3c21f06bb90993a614c9db3abe676ad93" translate="yes" xml:space="preserve">
          <source>This is reinventing the square wheel because any callback API wrapping can and should be done immediately using the promise library's promisification methods:</source>
          <target state="translated">Esto es reinventar la rueda cuadrada porque cualquier envoltura de la API de devolución de llamada puede y debe hacerse inmediatamente usando los métodos de promisión de la biblioteca de promesas:</target>
        </trans-unit>
        <trans-unit id="278f2f5f91e65aca9cba986cd298d5b80d084994" translate="yes" xml:space="preserve">
          <source>This is relevant to browser environments with no module loader.</source>
          <target state="translated">Esto es relevante para los entornos de los navegadores sin cargador de módulos.</target>
        </trans-unit>
        <trans-unit id="72dacc01b0328b9bb5e5b49e4a3b2f09a68d5835" translate="yes" xml:space="preserve">
          <source>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. It's also sometimes called the promise constructor anti-pattern. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel. This pattern is also called the deferred anti-pattern.</source>
          <target state="translated">Este es el antipatrón más común.Es fácil caer en esto cuando no entiendes realmente las promesas y piensas en ellas como emisores de eventos glorificados o utilidad de devolución de llamada.A veces también se le llama el constructor de promesas anti-patrón.Recapitulemos:las promesas se refieren a hacer que el código asíncrono retenga la mayoría de las propiedades perdidas del código síncrono como la indentación plana y un canal de excepción.Este patrón también se llama el anti-patrón diferido.</target>
        </trans-unit>
        <trans-unit id="83310ff097e8beff42467f80b6885cac44a4a774" translate="yes" xml:space="preserve">
          <source>This is the point&amp;mdash;to have something that works like &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; in synchronous code.</source>
          <target state="translated">Este es el punto: tener algo que funcione como &lt;code&gt;return&lt;/code&gt; y &lt;code&gt;throw&lt;/code&gt; c&amp;oacute;digo s&amp;iacute;ncrono.</target>
        </trans-unit>
        <trans-unit id="158db758d5ef9e5d2ebee4458ff60d03b8698f8f" translate="yes" xml:space="preserve">
          <source>This is to enable better stack trace support and to have more consistent and logical code.</source>
          <target state="translated">Esto es para permitir un mejor soporte de rastreo de la pila y para tener un código más consistente y lógico.</target>
        </trans-unit>
        <trans-unit id="eb2cd71a05d06d1a123d046c307b240be60c02ec" translate="yes" xml:space="preserve">
          <source>This made-up scenario runs 25 shimmed queries in parallel per each request (N=10000) with fast I/O response times.</source>
          <target state="translated">Este escenario inventado ejecuta 25 consultas shimmed en paralelo por cada solicitud (N=10000)con rápidos tiempos de respuesta de E/S.</target>
        </trans-unit>
        <trans-unit id="1cc8fcf272c1fddb57ef8ff18a07070dc64c720d" translate="yes" xml:space="preserve">
          <source>This means you can insert &lt;code&gt;.tap()&lt;/code&gt; into a &lt;code&gt;.then()&lt;/code&gt; chain without affecting what is passed through the chain. (See example below).</source>
          <target state="translated">Esto significa que puede insertar &lt;code&gt;.tap()&lt;/code&gt; en una cadena &lt;code&gt;.then()&lt;/code&gt; sin afectar lo que pasa a trav&amp;eacute;s de la cadena. (Ver ejemplo a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="3c0de91929a03e3312c7e239b95e998f29ef038e" translate="yes" xml:space="preserve">
          <source>This method also supports predicate-based filters. If you pass a predicate function instead of an error constructor, the predicate will receive the error as an argument. The return result of the predicate will be used determine whether the error handler should be called.</source>
          <target state="translated">Este método también es compatible con los filtros basados en predicados.Si se pasa una función de predicado en lugar de un constructor de errores,el predicado recibirá el error como argumento.El resultado de retorno del predicado se usará para determinar si se debe llamar al manejador de errores.</target>
        </trans-unit>
        <trans-unit id="b9befc4f3f3a5debf1bc48e96cdc0758b3d6448b" translate="yes" xml:space="preserve">
          <source>This method is compatible with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; from native promises.</source>
          <target state="translated">Este m&amp;eacute;todo es compatible con &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; de las promesas nativas.</target>
        </trans-unit>
        <trans-unit id="a0481512ec7eb9822880d2eb57c4e1770159cdaa" translate="yes" xml:space="preserve">
          <source>This method is convenient when a function can sometimes return synchronously or throw synchronously.</source>
          <target state="translated">Este método es conveniente cuando una función puede a veces regresar de forma sincronizada o lanzar de forma sincronizada.</target>
        </trans-unit>
        <trans-unit id="05db19a6c7c0e842cae324b6edc66273dd337537" translate="yes" xml:space="preserve">
          <source>This method is deprecated. Use &lt;a href=&quot;promise.config&quot;&gt;Promise.config&lt;/a&gt; instead.</source>
          <target state="translated">Este m&amp;eacute;todo est&amp;aacute; en desuso. Use &lt;a href=&quot;promise.config&quot;&gt;Promise.config&lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="f63178b611e277d3437aa6cb79a370492a0a4d4d" translate="yes" xml:space="preserve">
          <source>This method is only implemented because it's in the ES6 standard. If you want to race promises to fulfillment the &lt;a href=&quot;any&quot;&gt;&lt;code&gt;.any&lt;/code&gt;&lt;/a&gt; method is more appropriate as it doesn't qualify a rejected promise as the winner. It also has less surprises: &lt;code&gt;.race&lt;/code&gt; must become infinitely pending if an empty array is passed but passing an empty array to &lt;a href=&quot;any&quot;&gt;&lt;code&gt;.any&lt;/code&gt;&lt;/a&gt; is more usefully a &lt;code&gt;RangeError&lt;/code&gt;</source>
          <target state="translated">Este m&amp;eacute;todo solo se implementa porque est&amp;aacute; en el est&amp;aacute;ndar ES6. Si desea competir con las promesas de cumplimiento, &lt;a href=&quot;any&quot;&gt; &lt;code&gt;.any&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo es m&amp;aacute;s apropiado, ya que no califica una promesa rechazada como el ganador. Tambi&amp;eacute;n tiene menos sorpresas: &lt;code&gt;.race&lt;/code&gt; debe quedar infinitamente pendiente si se pasa una matriz vac&amp;iacute;a, pero pasar una matriz vac&amp;iacute;a a &lt;a href=&quot;any&quot;&gt; &lt;code&gt;.any&lt;/code&gt; &lt;/a&gt; es m&amp;aacute;s &amp;uacute;til un &lt;code&gt;RangeError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17f763d4342a3b00b5440e744954545f7480822a" translate="yes" xml:space="preserve">
          <source>This method is useful for when you want to wait for more than one promise to complete.</source>
          <target state="translated">Este método es útil para cuando se quiere esperar a que se complete más de una promesa.</target>
        </trans-unit>
        <trans-unit id="e13b547a51d6973b8e8ea8229673f31834f1a93d" translate="yes" xml:space="preserve">
          <source>This method should be used before you use any of the methods which would otherwise alter the global &lt;code&gt;Bluebird&lt;/code&gt; object - to avoid polluting global state.</source>
          <target state="translated">Este m&amp;eacute;todo debe usarse antes de usar cualquiera de los m&amp;eacute;todos que de otro modo alterar&amp;iacute;an el objeto global &lt;code&gt;Bluebird&lt;/code&gt; , para evitar contaminar el estado global.</target>
        </trans-unit>
        <trans-unit id="bb88a06a14951217dbf7da64e1c214d581435513" translate="yes" xml:space="preserve">
          <source>This page describes parallels of using promises in other languages. Promises as a pattern are very common in other languages and knowing what they map to in other languages might help you with grasping them conceptually</source>
          <target state="translated">Esta página describe los paralelismos del uso de promesas en otros idiomas.Las promesas como patrón son muy comunes en otros idiomas y saber a qué corresponden en otros idiomas puede ayudarte a comprenderlas conceptualmente.</target>
        </trans-unit>
        <trans-unit id="f8caafd4bd28c25bbaa9e7e7281f27609e085879" translate="yes" xml:space="preserve">
          <source>This page explains how to interface your code with existing callback APIs and libraries you're using. We'll see that making bluebird work with callback APIs is not only easy - it's also fast.</source>
          <target state="translated">Esta página explica cómo interconectar tu código con las API de devolución de llamada existentes y las bibliotecas que estás usando.Veremos que hacer que Bluebird funcione con las API de devolución de llamada no sólo es fácil,sino también rápido.</target>
        </trans-unit>
        <trans-unit id="31362f3d4d915353baa5045a042087f3f740de15" translate="yes" xml:space="preserve">
          <source>This page is a reference for migrating to bluebird from other flow control or promise libraries. See &lt;a href=&quot;install&quot;&gt;installation&lt;/a&gt; on how to use bluebird in your environment.</source>
          <target state="translated">Esta p&amp;aacute;gina es una referencia para migrar a bluebird desde otras bibliotecas de control de flujo o prometedoras. Consulte la &lt;a href=&quot;install&quot;&gt;instalaci&amp;oacute;n&lt;/a&gt; sobre c&amp;oacute;mo usar bluebird en su entorno.</target>
        </trans-unit>
        <trans-unit id="7a9a982268e14e003930e216d5e26566cf85c426" translate="yes" xml:space="preserve">
          <source>This page will contain common promise anti-patterns that are exercised in the wild.</source>
          <target state="translated">Esta página contendrá promesas comunes anti-patrones que se ejercen en la naturaleza.</target>
        </trans-unit>
        <trans-unit id="aa9be090a3976e3bdcf5c7d5ffe1e9f09746eddc" translate="yes" xml:space="preserve">
          <source>This section lists the most common async module replacements.</source>
          <target state="translated">En esta sección se enumeran los reemplazos más comunes del módulo de sincronización.</target>
        </trans-unit>
        <trans-unit id="bbbc8fd10030426b3463e06d9b5b51c19c29316d" translate="yes" xml:space="preserve">
          <source>This section only applies to node.js or io.js.</source>
          <target state="translated">Esta sección sólo se aplica a node.js o io.js.</target>
        </trans-unit>
        <trans-unit id="dde97755fad5f67be03bd6d1c4049a9360dedd37" translate="yes" xml:space="preserve">
          <source>This superfluous wrapping is also dangerous, any kind of errors and rejections are swallowed and not propagated to the caller of this function.</source>
          <target state="translated">Esta envoltura superflua también es peligrosa,cualquier tipo de errores y rechazos son ingeridos y no se propagan al llamador de esta función.</target>
        </trans-unit>
        <trans-unit id="12297c68c5f136df52d6d18d4a5ba1ec592d81f8" translate="yes" xml:space="preserve">
          <source>This usually happens when you have a promise that resolves or rejects with itself.</source>
          <target state="translated">Esto suele suceder cuando se tiene una promesa que se resuelve o rechaza por sí misma.</target>
        </trans-unit>
        <trans-unit id="22c09fd50a68a2d3dd2ca54a203b3e20039f8ff5" translate="yes" xml:space="preserve">
          <source>This usually means that you simply forgot a &lt;code&gt;return&lt;/code&gt; statement somewhere, which will cause a runaway promise that is not connected to any promise chain.</source>
          <target state="translated">Esto generalmente significa que simplemente olvid&amp;oacute; una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; alg&amp;uacute;n lugar, lo que provocar&amp;aacute; una promesa desbocada que no est&amp;aacute; conectada a ninguna cadena de promesa.</target>
        </trans-unit>
        <trans-unit id="641aada61fdf6b191fac4681998d3181bd3d099f" translate="yes" xml:space="preserve">
          <source>This will ensure that &lt;code&gt;connection.close()&lt;/code&gt; will be called once the promise returned from the &lt;code&gt;Promise.using&lt;/code&gt; closure is resolved or if an exception was thrown in the closure body.</source>
          <target state="translated">Esto garantizar&amp;aacute; que se llame a &lt;code&gt;connection.close()&lt;/code&gt; una vez que se resuelva la promesa devuelta desde el cierre de &lt;code&gt;Promise.using&lt;/code&gt; o si se lanz&amp;oacute; una excepci&amp;oacute;n en el cuerpo del cierre.</target>
        </trans-unit>
        <trans-unit id="d1caca18b80550e74fc714f5129356a12216a1b3" translate="yes" xml:space="preserve">
          <source>This works because the array acts as a &quot;module&quot; where the indices are the &quot;module&quot;'s properties for classes.</source>
          <target state="translated">Esto funciona porque la matriz actúa como un &quot;módulo&quot; donde los índices son las propiedades del &quot;módulo&quot; para las clases.</target>
        </trans-unit>
        <trans-unit id="642f5108aa274866c1da99279aa0b6d98b1fdf21" translate="yes" xml:space="preserve">
          <source>Through the use of &lt;a href=&quot;api/each&quot;&gt;&lt;code&gt;.each&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;api/map&quot;&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/a&gt; doing things just at the right concurrency level becomes a breeze.</source>
          <target state="translated">Mediante el uso de &lt;a href=&quot;api/each&quot;&gt; &lt;code&gt;.each&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;api/map&quot;&gt; &lt;code&gt;.map&lt;/code&gt; ,&lt;/a&gt; hacer las cosas en el nivel de concurrencia correcto se convierte en una brisa.</target>
        </trans-unit>
        <trans-unit id="22a4ad2c60d9b1a4a4ab47810c732e12faec00b0" translate="yes" xml:space="preserve">
          <source>TimeoutError</source>
          <target state="translated">TimeoutError</target>
        </trans-unit>
        <trans-unit id="ae5a9ed10e48f39a8b693714bce92b1291ca1c8b" translate="yes" xml:space="preserve">
          <source>TimeoutError()</source>
          <target state="translated">TimeoutError()</target>
        </trans-unit>
        <trans-unit id="841cd03a97cd854590864d79ae48ee749c5e902e" translate="yes" xml:space="preserve">
          <source>Timers</source>
          <target state="translated">Timers</target>
        </trans-unit>
        <trans-unit id="23658960168be8cdbfbe275f17c4c761b8a8f3e9" translate="yes" xml:space="preserve">
          <source>To do this we will have two &lt;code&gt;catch()&lt;/code&gt; functions one for &lt;code&gt;UserCanceledError&lt;/code&gt; and one for any other &lt;code&gt;Error&lt;/code&gt;. We can make a custom error like so:</source>
          <target state="translated">Para hacer esto, tendremos dos funciones &lt;code&gt;catch()&lt;/code&gt; , una para &lt;code&gt;UserCanceledError&lt;/code&gt; y otra para cualquier otro &lt;code&gt;Error&lt;/code&gt; . Podemos hacer un error personalizado as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="b1a3ce42d2f42f9c24273b4cda598b33af25fce3" translate="yes" xml:space="preserve">
          <source>To drive home the synchronous nature of the &lt;code&gt;window.prompt&lt;/code&gt; notice that the time stops ticking when the prompt dialog is displayed. Let's fix that by making our own prompt. Since our dialog is just DOM manipulation the page won't be blocked while waiting for user input.</source>
          <target state="translated">Para conducir a casa, la naturaleza s&amp;iacute;ncrona de la &lt;code&gt;window.prompt&lt;/code&gt; Aviso r&amp;aacute;pido que el tiempo deja de marcar cuando se muestra el cuadro de di&amp;aacute;logo de solicitud. Arreglemos eso haciendo nuestro propio aviso. Dado que nuestro di&amp;aacute;logo es solo manipulaci&amp;oacute;n DOM, la p&amp;aacute;gina no se bloquear&amp;aacute; mientras se espera la entrada del usuario.</target>
        </trans-unit>
        <trans-unit id="a7035efe5121276c8995557c4e8d8404d5096469" translate="yes" xml:space="preserve">
          <source>To enable long stack traces and warnings in node development:</source>
          <target state="translated">Para permitir largos rastros y advertencias en el desarrollo de los nodos:</target>
        </trans-unit>
        <trans-unit id="0e38679fea7f9ddcf16ac2341ac48ffb3d6a13cd" translate="yes" xml:space="preserve">
          <source>To enable long stack traces and warnings in node production:</source>
          <target state="translated">Para permitir largos rastros de pila y advertencias en la producción de nodos:</target>
        </trans-unit>
        <trans-unit id="302b55ad14f02d86e137c0363366e824866304b7" translate="yes" xml:space="preserve">
          <source>To enable them in all instances of bluebird in node.js, use the environment variable &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt;:</source>
          <target state="translated">Para habilitarlos en todas las instancias de bluebird en node.js, use la variable de entorno &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6a347bd13a256b214fb6fa7d0dff43a0c457c811" translate="yes" xml:space="preserve">
          <source>To fix it, simply pass the function reference to &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; as is:</source>
          <target state="translated">Para solucionarlo, simplemente pase la referencia de funci&amp;oacute;n a &lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; como est&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="1ab4b669048933cdcafeed010c60563bc2fd72dd" translate="yes" xml:space="preserve">
          <source>To fix it, you need to &lt;code&gt;return&lt;/code&gt; the promise:</source>
          <target state="translated">Para solucionarlo, debe &lt;code&gt;return&lt;/code&gt; la promesa:</target>
        </trans-unit>
        <trans-unit id="67cb18d088b9f1e447cdd241d432d091a17f83ef" translate="yes" xml:space="preserve">
          <source>To fix, simply remember to add &lt;code&gt;return&lt;/code&gt; in front of your promise-complying function:</source>
          <target state="translated">Para solucionarlo, simplemente recuerde agregar &lt;code&gt;return&lt;/code&gt; frente a su funci&amp;oacute;n de cumplimiento de promesa:</target>
        </trans-unit>
        <trans-unit id="9dfea82804728489558d139da2f0b772571e485c" translate="yes" xml:space="preserve">
          <source>To make sure a function that returns a promise is following the implicit but critically important contract of promises, you can start a function with &lt;code&gt;new Promise&lt;/code&gt; if you cannot start a chain immediately:</source>
          <target state="translated">Para asegurarse de que una funci&amp;oacute;n que devuelve una promesa sigue el contrato de promesas impl&amp;iacute;cito pero de importancia cr&amp;iacute;tica, puede iniciar una funci&amp;oacute;n con una &lt;code&gt;new Promise&lt;/code&gt; si no puede iniciar una cadena de inmediato:</target>
        </trans-unit>
        <trans-unit id="4f45ac1d08d953780ed4fe1af6ee2f1aafa55655" translate="yes" xml:space="preserve">
          <source>Together with &lt;code&gt;onPossiblyUnhandledRejection&lt;/code&gt; these hooks can be used to implement a debugger that will show a list of unhandled promise rejections updated in real time as promises become handled.</source>
          <target state="translated">Junto con &lt;code&gt;onPossiblyUnhandledRejection&lt;/code&gt; , estos enganches se pueden usar para implementar un depurador que mostrar&amp;aacute; una lista de rechazos de promesas no manejadas actualizadas en tiempo real a medida que se cumplan las promesas.</target>
        </trans-unit>
        <trans-unit id="cffb3821e2781468cd3c381c1dd88d7da75f44e5" translate="yes" xml:space="preserve">
          <source>Typically &lt;em&gt;promises&lt;/em&gt; are used in conjunction with asynchronous tasks such as a network request or a &lt;code&gt;setTimeout&lt;/code&gt;; a lesser explored use is dealing with user input. Since a program has to wait for a user to continue some actions it makes sense to consider it an asynchronous event.</source>
          <target state="translated">Normalmente, las &lt;em&gt;promesas&lt;/em&gt; se usan junto con tareas asincr&amp;oacute;nicas como una solicitud de red o un &lt;code&gt;setTimeout&lt;/code&gt; ; Un uso menos explorado se refiere a la entrada del usuario. Dado que un programa tiene que esperar a que un usuario contin&amp;uacute;e con algunas acciones, tiene sentido considerarlo un evento asincr&amp;oacute;nico.</target>
        </trans-unit>
        <trans-unit id="95e39893849d27ccdda4985a773f9d1a23141d52" translate="yes" xml:space="preserve">
          <source>Unhandled errors are not silently swallowed by default but reported along with helpful stack traces where applicable. All of this is of course configurable.</source>
          <target state="translated">Los errores no manejados no se tragan silenciosamente por defecto,sino que se notifican junto con rastros útiles de la pila cuando corresponde.Todo esto es,por supuesto,configurable.</target>
        </trans-unit>
        <trans-unit id="3a34c30705919f5365483a84e6ffe973cf51a891" translate="yes" xml:space="preserve">
          <source>Unhandled rejections are tracked per promise, not per error. So if you create multiple branches from a single ancestor and that ancestor gets rejected, each branch with no error handler with the end will cause a possibly unhandled rejection handler invocation</source>
          <target state="translated">Los rechazos no manejados son rastreados por promesa,no por error.Así que si creas múltiples ramas de un solo ancestro y ese ancestro es rechazado,cada rama sin un manejador de errores con el final causará una posible invocación de manejador de rechazo no manejado</target>
        </trans-unit>
        <trans-unit id="4c350ad9142ecaab016e03c764abcb7074c45e90" translate="yes" xml:space="preserve">
          <source>Unless an AMD loader is installed, the script tag installation exposes the library in the &lt;code&gt;Promise&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; namespaces. If you want to restore the &lt;code&gt;Promise&lt;/code&gt; namespace, use &lt;code&gt;var Bluebird = Promise.noConflict()&lt;/code&gt;.</source>
          <target state="translated">A menos que se instale un cargador AMD, la instalaci&amp;oacute;n de la etiqueta del script expone la biblioteca en los espacios de nombres &lt;code&gt;Promise&lt;/code&gt; y &lt;code&gt;P&lt;/code&gt; .Si desea restaurar el espacio de nombres de &lt;code&gt;Promise&lt;/code&gt; , use &lt;code&gt;var Bluebird = Promise.noConflict()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44e42a41d2a20532fa9a5c2908e1e8626e2a7e8e" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;finally&quot;&gt;&lt;code&gt;.finally&lt;/code&gt;&lt;/a&gt; this is not called for rejections.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;finally&quot;&gt; &lt;code&gt;.finally&lt;/code&gt; &lt;/a&gt; esto no se requiere para rechazos.</target>
        </trans-unit>
        <trans-unit id="8371d8f357f54bfda7d7c8677986ada6f8fa2ae9" translate="yes" xml:space="preserve">
          <source>Unminified source file meant to be used in development. Warnings and long stack traces are enabled which are taxing on performance.</source>
          <target state="translated">Un archivo de fuente no minificado destinado a ser utilizado en el desarrollo.Se habilitan advertencias y largos rastros de pila,que son un obstáculo para el rendimiento.</target>
        </trans-unit>
        <trans-unit id="c6395a030ac1269e7ce9bae273ab910b5d2f5034" translate="yes" xml:space="preserve">
          <source>Update acorn dependency</source>
          <target state="translated">Actualizar la dependencia de las bellotas</target>
        </trans-unit>
        <trans-unit id="42a8536e189c405379021d94a1e8532ff836496d" translate="yes" xml:space="preserve">
          <source>Updated logo</source>
          <target state="translated">Logotipo actualizado</target>
        </trans-unit>
        <trans-unit id="08b6f1fdb58d25854a37bb391362fd81dc049478" translate="yes" xml:space="preserve">
          <source>Usage examples include:</source>
          <target state="translated">Los ejemplos de uso incluyen:</target>
        </trans-unit>
        <trans-unit id="eb4421a3da2485be27f4aababc58c8de5da2c8d7" translate="yes" xml:space="preserve">
          <source>Use setImmediate if available</source>
          <target state="translated">Utilice el setInmediato si está disponible</target>
        </trans-unit>
        <trans-unit id="289a45d725e898c1ca06ab7fa01837771482ed99" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#parallel&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">Usando &lt;a href=&quot;api/promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; para implementar el ejemplo desde la &lt;a href=&quot;https://github.com/caolan/async#parallel&quot;&gt;p&amp;aacute;gina de inicio as&amp;iacute;ncrona&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d609f610f666b772e57874290c0b6739f1e46b91" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.each&quot;&gt;&lt;code&gt;Promise.each&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">Usando &lt;a href=&quot;api/promise.each&quot;&gt; &lt;code&gt;Promise.each&lt;/code&gt; &lt;/a&gt; para implementar el ejemplo desde la &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;p&amp;aacute;gina de inicio as&amp;iacute;ncrona&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7b37cc52da759eea0a61e35010724d1f98be048a" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.map&quot;&gt;&lt;code&gt;Promise.map&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">Usando &lt;a href=&quot;api/promise.map&quot;&gt; &lt;code&gt;Promise.map&lt;/code&gt; &lt;/a&gt; para implementar el ejemplo desde la &lt;a href=&quot;https://github.com/caolan/async#maparr-iterator-callback&quot;&gt;p&amp;aacute;gina de inicio as&amp;iacute;ncrona&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="87872433fa3fca67fb5bcea17254b8b45dc74c5d" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;api/promise.mapseries&quot;&gt;&lt;code&gt;Promise.mapSeries&lt;/code&gt;&lt;/a&gt; to implement the example from &lt;a href=&quot;https://github.com/caolan/async#seriestasks-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">Usando &lt;a href=&quot;api/promise.mapseries&quot;&gt; &lt;code&gt;Promise.mapSeries&lt;/code&gt; &lt;/a&gt; para implementar el ejemplo desde la &lt;a href=&quot;https://github.com/caolan/async#seriestasks-callback&quot;&gt;p&amp;aacute;gina de inicio as&amp;iacute;ncrona&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5a34d8c3d20da73e7fdd61d0a9cd7e9a530150eb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.reflect()&lt;/code&gt; to implement &lt;code&gt;settleAll&lt;/code&gt; (wait until all promises in an array are either rejected or fulfilled) functionality</source>
          <target state="translated">Usando &lt;code&gt;.reflect()&lt;/code&gt; para implementar la funcionalidad &lt;code&gt;settleAll&lt;/code&gt; (espere hasta que todas las promesas en una matriz sean rechazadas o cumplidas)</target>
        </trans-unit>
        <trans-unit id="a030f13931277422b23a2b7aa92804eba9dbfca1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.reflect()&lt;/code&gt; to implement &lt;code&gt;settleProps&lt;/code&gt; (like settleAll for an object's properties) functionality</source>
          <target state="translated">Usando &lt;code&gt;.reflect()&lt;/code&gt; para implementar la funcionalidad &lt;code&gt;settleProps&lt;/code&gt; (como para resolver las propiedades de un objeto)</target>
        </trans-unit>
        <trans-unit id="510bd1d1748aa6be73d0b3f164f968144ae8f326" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;defaultPromisifier&lt;/code&gt; parameter to add enhancements on top of normal node promisification:</source>
          <target state="translated">Usando el par&amp;aacute;metro &lt;code&gt;defaultPromisifier&lt;/code&gt; para agregar mejoras adem&amp;aacute;s de la promisificaci&amp;oacute;n de nodo normal:</target>
        </trans-unit>
        <trans-unit id="a7f32ad8c97706d5425fc98083d499e4e2b0f38a" translate="yes" xml:space="preserve">
          <source>Using CoffeeScript's &lt;code&gt;class&lt;/code&gt; for the same:</source>
          <target state="translated">Usando la &lt;code&gt;class&lt;/code&gt; CoffeeScript para lo mismo:</target>
        </trans-unit>
        <trans-unit id="39b2fb1fa487e5be55b2254cc478460136f04a5f" translate="yes" xml:space="preserve">
          <source>Using DOM3 &lt;code&gt;addEventListener&lt;/code&gt; APIs (support starting from IE9+):</source>
          <target state="translated">Uso de las API &lt;code&gt;addEventListener&lt;/code&gt; de DOM3 (soporte a partir de IE9 +):</target>
        </trans-unit>
        <trans-unit id="0031ac8ff26e8b6b8c4fa9f5d7c7a8c5ff06fc8d" translate="yes" xml:space="preserve">
          <source>Using ECMAScript6 generators feature to implement C# 5.0 &lt;code&gt;async/await&lt;/code&gt; like syntax.</source>
          <target state="translated">Uso de la funci&amp;oacute;n de generadores ECMAScript6 para implementar la sintaxis &lt;code&gt;async/await&lt;/code&gt; C # 5.0 .</target>
        </trans-unit>
        <trans-unit id="acac6fbc07a16dd7002db7cd3b214125856ce811" translate="yes" xml:space="preserve">
          <source>Using an abstraction like this the &lt;code&gt;promisePrompt&lt;/code&gt; no longer needs to know anything about the DOM and concentrates on just providing a promise. This will also make things easier to create a promised version of a progress bar or confirmation dialog or any other type of UI that we want to have a value for. All we will need to do is write a class for that dialog type with the same interface and just pass that class into our promise making method.</source>
          <target state="translated">Usando una abstracci&amp;oacute;n como esta, el &lt;code&gt;promisePrompt&lt;/code&gt; ya no necesita saber nada sobre el DOM y se concentra en solo proporcionar una promesa. Esto tambi&amp;eacute;n facilitar&amp;aacute; las cosas para crear una versi&amp;oacute;n prometida de una barra de progreso o di&amp;aacute;logo de confirmaci&amp;oacute;n o cualquier otro tipo de IU para el que queremos tener un valor. Todo lo que necesitaremos hacer es escribir una clase para ese tipo de di&amp;aacute;logo con la misma interfaz y simplemente pasar esa clase a nuestro m&amp;eacute;todo de promesa.</target>
        </trans-unit>
        <trans-unit id="92e2993e6dea235a7dcb1db5bb36202c8485dbc9" translate="yes" xml:space="preserve">
          <source>Using it:</source>
          <target state="translated">Usándolo:</target>
        </trans-unit>
        <trans-unit id="d829b44477e34c8358b0978984bdca898183bed9" translate="yes" xml:space="preserve">
          <source>Using jQuery after:</source>
          <target state="translated">Usando jQuery después:</target>
        </trans-unit>
        <trans-unit id="c991e6de4c7c9ecea657f843e9921caf549f2112" translate="yes" xml:space="preserve">
          <source>Using jQuery before:</source>
          <target state="translated">Usando jQuery antes:</target>
        </trans-unit>
        <trans-unit id="ee10eda3c3f21aee43203ae597d2c13cd07e6eea" translate="yes" xml:space="preserve">
          <source>Using legacy APIs (support starting from IE6+):</source>
          <target state="translated">Usando APIs heredadas (soporte a partir de IE6+):</target>
        </trans-unit>
        <trans-unit id="51f995a28f75764b72a6c79dc89d54dd724921f6" translate="yes" xml:space="preserve">
          <source>Using manual resolver:</source>
          <target state="translated">Usando la resolución manual:</target>
        </trans-unit>
        <trans-unit id="d99578b7705756deffc2aa58f6ae34fb2dbdb0c2" translate="yes" xml:space="preserve">
          <source>Using multiple resources:</source>
          <target state="translated">Usando múltiples recursos:</target>
        </trans-unit>
        <trans-unit id="a3f65738b0a1c42c2a41e0b59a0029999f986703" translate="yes" xml:space="preserve">
          <source>Using no hooks and using &lt;a href=&quot;api/done&quot;&gt;&lt;code&gt;.done&lt;/code&gt;&lt;/a&gt; to manually to mark end points where rejections will not be handled</source>
          <target state="translated">Sin usar ganchos y usando &lt;a href=&quot;api/done&quot;&gt; &lt;code&gt;.done&lt;/code&gt; &lt;/a&gt; para marcar manualmente los puntos finales donde no se manejar&amp;aacute;n los rechazos</target>
        </trans-unit>
        <trans-unit id="678ad3a7449dc9211f664a6a26c9f4eeb83dd91e" translate="yes" xml:space="preserve">
          <source>Using no hooks and using &lt;a href=&quot;done&quot;&gt;&lt;code&gt;.done&lt;/code&gt;&lt;/a&gt; to manually to mark end points where rejections will not be handled</source>
          <target state="translated">Sin usar ganchos y usando &lt;a href=&quot;done&quot;&gt; &lt;code&gt;.done&lt;/code&gt; &lt;/a&gt; para marcar manualmente los puntos finales donde no se manejar&amp;aacute;n los rechazos</target>
        </trans-unit>
        <trans-unit id="7de8d54140fb8771440fc81fb18f3d53f9f6bb4f" translate="yes" xml:space="preserve">
          <source>Using recursion to implement the example from &lt;a href=&quot;https://github.com/caolan/async#whilsttest-fn-callback&quot;&gt;async homepage&lt;/a&gt;:</source>
          <target state="translated">Usando la recursi&amp;oacute;n para implementar el ejemplo desde la &lt;a href=&quot;https://github.com/caolan/async#whilsttest-fn-callback&quot;&gt;p&amp;aacute;gina de inicio as&amp;iacute;ncrona&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="40c7e148244964ef32867f708db116db37aa2e23" translate="yes" xml:space="preserve">
          <source>Using the same function &lt;code&gt;Promise.method&lt;/code&gt;, there is no need to manually wrap direct return or throw values into a promise:</source>
          <target state="translated">Usando la misma funci&amp;oacute;n &lt;code&gt;Promise.method&lt;/code&gt; , no hay necesidad de ajustar manualmente el retorno directo o arrojar valores en una promesa:</target>
        </trans-unit>
        <trans-unit id="fdf3b6cb551f8ba0a6b556e915881b1d2f0aa867" translate="yes" xml:space="preserve">
          <source>Using the value &lt;code&gt;0&lt;/code&gt; will explicitly disable a feature despite debug environment otherwise activating it:</source>
          <target state="translated">El uso del valor &lt;code&gt;0&lt;/code&gt; deshabilitar&amp;aacute; expl&amp;iacute;citamente una funci&amp;oacute;n a pesar del entorno de depuraci&amp;oacute;n, de lo contrario se activar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="6642c87a17774c8b004c1431ca83c93a48edf11b" translate="yes" xml:space="preserve">
          <source>Using webpack for development/debugging:</source>
          <target state="translated">Usando el webpack para el desarrollo/depuración:</target>
        </trans-unit>
        <trans-unit id="a94a8b8570fef0a3371781d1978a7c51f05ee4ff" translate="yes" xml:space="preserve">
          <source>Using webpack for production/performance:</source>
          <target state="translated">Usando el webpack para la producción/prestación:</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="02024b434dc6bfc227f2288a4656819d24c77710" translate="yes" xml:space="preserve">
          <source>Warn when &lt;a href=&quot;api/then&quot;&gt;&lt;code&gt;.then()&lt;/code&gt;&lt;/a&gt; is passed non-functions</source>
          <target state="translated">Avisar cuando &lt;a href=&quot;api/then&quot;&gt; &lt;code&gt;.then()&lt;/code&gt; &lt;/a&gt; se pasa sin funciones</target>
        </trans-unit>
        <trans-unit id="76bc85fbac802c9c28a4f34074f76273aa28dba3" translate="yes" xml:space="preserve">
          <source>Warning Explanations</source>
          <target state="translated">Explicaciones de advertencia</target>
        </trans-unit>
        <trans-unit id="e326d603e8ef33a0ace61e8bd45d1476027c27c7" translate="yes" xml:space="preserve">
          <source>Warning: .then() only accepts functions</source>
          <target state="translated">Advertencia:.then()sólo acepta funciones</target>
        </trans-unit>
        <trans-unit id="2f253a4ff30df6ead65cd95ca2db9916033eb9d8" translate="yes" xml:space="preserve">
          <source>Warning: a promise was created in a handler but was not returned from it</source>
          <target state="translated">Advertencia:una promesa fue creada en un manipulador pero no fue devuelta por él</target>
        </trans-unit>
        <trans-unit id="5f19b7cfb75065744f09c3f3dbd1dd8602fb5742" translate="yes" xml:space="preserve">
          <source>Warning: a promise was rejected with a non-error</source>
          <target state="translated">Advertencia:una promesa fue rechazada con un no-error</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="f9b093958e9b93291eee426980c6f76c2af8380b" translate="yes" xml:space="preserve">
          <source>Warnings about created promises that are not returned are no longer given if the handler promise has not been chained. This should reduce the amount of false positives with this warning.</source>
          <target state="translated">Las advertencias sobre las promesas creadas que no se devuelven ya no se dan si la promesa del manipulador no ha sido encadenada.Esto debería reducir la cantidad de falsos positivos con esta advertencia.</target>
        </trans-unit>
        <trans-unit id="987519cc8247ea08d785b3bed0d0edba12ab4768" translate="yes" xml:space="preserve">
          <source>Warnings have been added to report usages which are very likely to be programmer errors. See &lt;a href=&quot;api/promise.config&quot;&gt;&lt;code&gt;Promise.config&lt;/code&gt;&lt;/a&gt; for how to enable warnings. See &lt;a href=&quot;warning-explanations&quot;&gt;Warning Explanations&lt;/a&gt; for list of the warnings and their explanations.</source>
          <target state="translated">Se han agregado advertencias para informar sobre usos que probablemente sean errores de programador. Consulte &lt;a href=&quot;api/promise.config&quot;&gt; &lt;code&gt;Promise.config&lt;/code&gt; &lt;/a&gt; para saber c&amp;oacute;mo habilitar las advertencias. Consulte &lt;a href=&quot;warning-explanations&quot;&gt;Explicaciones de advertencia&lt;/a&gt; para obtener una lista de las advertencias y sus explicaciones.</target>
        </trans-unit>
        <trans-unit id="2346b64bd2ceb68b2dd0fe9b356367b311b6a6a1" translate="yes" xml:space="preserve">
          <source>We can do better, retaining concurrency and not leaking resources, by using:</source>
          <target state="translated">Podemos hacerlo mejor,reteniendo la concurrencia y no filtrando recursos,usando:</target>
        </trans-unit>
        <trans-unit id="d449d2a1898fdf6171ab397563a248fe80459a1d" translate="yes" xml:space="preserve">
          <source>We can use the promise constructor to convert it to a promise returning function:</source>
          <target state="translated">Podemos usar el constructor de promesas para convertirlo en una función de devolución de promesas:</target>
        </trans-unit>
        <trans-unit id="0998ac30de0c1580642c82716276399b1c613149" translate="yes" xml:space="preserve">
          <source>We will want to keep the same API so our change will be only to the &lt;code&gt;promisePrompt&lt;/code&gt;. It will find the dialog DOM elements, attach events to the elements, show the dialog box, return a promise that is resolved based on the attached events, and finally detaches the events and cleans up after itself (hiding the dialog box for another use later).</source>
          <target state="translated">Queremos mantener la misma API, por lo que nuestro cambio ser&amp;aacute; solo para la &lt;code&gt;promisePrompt&lt;/code&gt; . Encontrar&amp;aacute; los elementos DOM del di&amp;aacute;logo, adjuntar&amp;aacute; eventos a los elementos, mostrar&amp;aacute; el cuadro de di&amp;aacute;logo, devolver&amp;aacute; una promesa que se resuelve en funci&amp;oacute;n de los eventos adjuntos, y finalmente separar&amp;aacute; los eventos y se limpiar&amp;aacute; por s&amp;iacute; mismo (ocultando el cuadro de di&amp;aacute;logo para otro uso m&amp;aacute;s adelante). )</target>
        </trans-unit>
        <trans-unit id="86974e9cfd94347a9d8035a721441882b61e40c8" translate="yes" xml:space="preserve">
          <source>We'll cover several subjects. If you want to get the tl;dr what you need is likely the &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;Working with callback APIs using the Node convention&lt;/a&gt; section.</source>
          <target state="translated">Cubriremos varios temas. Si desea obtener el tl; dr, lo que necesita probablemente sea &lt;a href=&quot;#working-with-callback-apis-using-the-node-convention&quot;&gt;Trabajar con API de devoluci&amp;oacute;n de llamada utilizando la&lt;/a&gt; secci&amp;oacute;n de convenciones de nodo .</target>
        </trans-unit>
        <trans-unit id="41b24863fa5a051446f6f2ae3860594cb7d071eb" translate="yes" xml:space="preserve">
          <source>Well simply, when you have to.</source>
          <target state="translated">Bueno,simplemente,cuando tienes que hacerlo.</target>
        </trans-unit>
        <trans-unit id="f8c4fdd7823278887156d018b49c43e024631c27" translate="yes" xml:space="preserve">
          <source>What About Generators?</source>
          <target state="translated">¿Qué pasa con los generadores?</target>
        </trans-unit>
        <trans-unit id="30a484e5211183ba2cee4378c92b44d3105eeaf7" translate="yes" xml:space="preserve">
          <source>What about promises that have multiple consumers?</source>
          <target state="translated">¿Qué pasa con las promesas que tienen múltiples consumidores?</target>
        </trans-unit>
        <trans-unit id="6b7c4ebe4c5f3bfe7fb62f4c2a84779817b88487" translate="yes" xml:space="preserve">
          <source>What actually happens is that &lt;code&gt;result&lt;/code&gt; keeps track of how many consumers it has, in this case 2, and only if all the consumers signal cancel will the request be aborted. However, as far as &lt;code&gt;firstConsumer&lt;/code&gt; can tell, the promise was successfully cancelled and its handlers will not be called.</source>
          <target state="translated">Lo que realmente sucede es que ese &lt;code&gt;result&lt;/code&gt; ado lleva un registro de cu&amp;aacute;ntos consumidores tiene, en este caso 2, y solo si todos los consumidores se&amp;ntilde;alan que se cancelar&amp;aacute;, se cancelar&amp;aacute; la solicitud. Sin embargo, por lo que &lt;code&gt;firstConsumer&lt;/code&gt; puede decir, la promesa se cancel&amp;oacute; con &amp;eacute;xito y no se llamar&amp;aacute; a sus controladores.</target>
        </trans-unit>
        <trans-unit id="07c519ceae2b771a7ddeac59daf39ed209a19525" translate="yes" xml:space="preserve">
          <source>What is the the point of promises</source>
          <target state="translated">¿Cuál es el sentido de las promesas</target>
        </trans-unit>
        <trans-unit id="56aab8af41c28bb5f9c760d67856cb60689f1c68" translate="yes" xml:space="preserve">
          <source>What's new in 2.0</source>
          <target state="translated">¿Qué hay de nuevo en 2.0?</target>
        </trans-unit>
        <trans-unit id="b2223542269901e7186ce7f97c69174f8009c3e4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;NODE_ENV&lt;/code&gt; environment variable is &lt;code&gt;&quot;development&quot;&lt;/code&gt; setting &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; environment variable to &lt;code&gt;0&lt;/code&gt; can now be used to disable debug mode</source>
          <target state="translated">Cuando la variable de entorno &lt;code&gt;NODE_ENV&lt;/code&gt; es &lt;code&gt;&quot;development&quot;&lt;/code&gt; configuraci&amp;oacute;n de la variable de entorno &lt;code&gt;BLUEBIRD_DEBUG&lt;/code&gt; a &lt;code&gt;0&lt;/code&gt; ahora se puede usar para desactivar el modo de depuraci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="268de3a5addf552f9cb9505acf541fb1a6c7d1c4" translate="yes" xml:space="preserve">
          <source>When called, the coroutine function will start an instance of the generator and returns a promise for its final value.</source>
          <target state="translated">Cuando se llama,la función corrotina iniciará una instancia del generador y devuelve una promesa de su valor final.</target>
        </trans-unit>
        <trans-unit id="abcda78ef2264e69cff0163a190c8f4b357591ac" translate="yes" xml:space="preserve">
          <source>When chaining &lt;code&gt;.spread&lt;/code&gt;, returning an array of promises also works:</source>
          <target state="translated">Al encadenar &lt;code&gt;.spread&lt;/code&gt; , devolver una serie de promesas tambi&amp;eacute;n funciona:</target>
        </trans-unit>
        <trans-unit id="b6c0e36e057ee58c2317285366278f58808242b8" translate="yes" xml:space="preserve">
          <source>When debugging or performing a one-time operation on a variable before passing it to a function, a return variable is forgotten.</source>
          <target state="translated">Cuando se depura o se realiza una operación única en una variable antes de pasarla a una función,se olvida una variable de retorno.</target>
        </trans-unit>
        <trans-unit id="64d8621b03578f1c94ccc629a4cc7c4de3a568ed" translate="yes" xml:space="preserve">
          <source>When there are asynchronous tasks that have the ability to notify progress as they complete it can be tempting to want that in the promise that represents that task. Unfortunately this is a bit of an anti-pattern. That is because the point of promises is to represent a value as if it was natural (like it is in normal synchronous code) and not to be over glorified callback management.</source>
          <target state="translated">Cuando hay tareas asincrónicas que tienen la capacidad de notificar el progreso a medida que se completan puede ser tentador querer eso en la promesa que representa esa tarea.Desafortunadamente esto es un poco anti-patrón.Esto se debe a que el punto de las promesas es representar un valor como si fuera natural (como lo es en el código síncrono normal)y no estar sobre glorificado en la gestión de devolución de llamadas.</target>
        </trans-unit>
        <trans-unit id="b3f5f46aab39a3a9a507394c2c440bab65f0ea48" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;longStackTraces&lt;/code&gt; the first line in your code after requiring Bluebird should be:</source>
          <target state="translated">Cuando use &lt;code&gt;longStackTraces&lt;/code&gt; , la primera l&amp;iacute;nea en su c&amp;oacute;digo despu&amp;eacute;s de requerir Bluebird debe ser:</target>
        </trans-unit>
        <trans-unit id="b9be79b81b6d65c3ed9b6fe0e6688b7fd74367ea" translate="yes" xml:space="preserve">
          <source>When using script tags the global variables &lt;code&gt;Promise&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; (alias for &lt;code&gt;Promise&lt;/code&gt;) become available. Bluebird runs on a wide variety of browsers including older versions. We'd like to thank BrowserStack for giving us a free account which helps us test that.</source>
          <target state="translated">Cuando se utilizan etiquetas de script, las variables globales &lt;code&gt;Promise&lt;/code&gt; y &lt;code&gt;P&lt;/code&gt; (alias para &lt;code&gt;Promise&lt;/code&gt; ) est&amp;aacute;n disponibles. Bluebird se ejecuta en una amplia variedad de navegadores, incluidas las versiones anteriores. Nos gustar&amp;iacute;a agradecer a BrowserStack por darnos una cuenta gratuita que nos ayuda a probar eso.</target>
        </trans-unit>
        <trans-unit id="4a2fe4cb42752a52e254b8a6bf3ceb42b7e1ac55" translate="yes" xml:space="preserve">
          <source>When using the first signature, you may specify a custom error message with the &lt;code&gt;message&lt;/code&gt; parameter.</source>
          <target state="translated">Al usar la primera firma, puede especificar un mensaje de error personalizado con el par&amp;aacute;metro del &lt;code&gt;message&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25f41737292fcc0beb27bde5ba12d4c02e4d5a28" translate="yes" xml:space="preserve">
          <source>When we construct our &lt;code&gt;ProgressDialog&lt;/code&gt; we use the &lt;code&gt;waitForUser()&lt;/code&gt; method to capture the user interaction promise and then use &lt;code&gt;delayedPromise()&lt;/code&gt; to capture the fake network promise and finally &lt;code&gt;Promise.reace()&lt;/code&gt; to manage the two simultaneously and end with a single promise as usual.</source>
          <target state="translated">Cuando construimos nuestro &lt;code&gt;ProgressDialog&lt;/code&gt; usamos el m&amp;eacute;todo &lt;code&gt;waitForUser()&lt;/code&gt; para capturar la promesa de interacci&amp;oacute;n del usuario y luego usamos &lt;code&gt;delayedPromise()&lt;/code&gt; para capturar la promesa de red falsa y finalmente &lt;code&gt;Promise.reace()&lt;/code&gt; para administrar los dos simult&amp;aacute;neamente y terminar con una sola promesa como de costumbre .</target>
        </trans-unit>
        <trans-unit id="294f81c22475eef4fbaab8c79a52c780d37a7f28" translate="yes" xml:space="preserve">
          <source>When working with promises the philosophy is basically a complete opposite than when using &lt;code&gt;async&lt;/code&gt;. Async provides a huge bag of uncomposable helper functions that work at a very low level of abstraction. When using promises you can get the utility otherwise provided by uncountable amount of inflexible helper functions by just combining and composing a few existing functions and concepts.</source>
          <target state="translated">Cuando se trabaja con promesas, la filosof&amp;iacute;a es b&amp;aacute;sicamente un opuesto completo que cuando se usa &lt;code&gt;async&lt;/code&gt; . Async proporciona una enorme bolsa de funciones auxiliares invencibles que funcionan a un nivel muy bajo de abstracci&amp;oacute;n. Al usar promesas, puede obtener la utilidad que de otro modo se proporciona mediante una cantidad incontable de funciones auxiliares inflexibles simplemente combinando y componiendo algunas funciones y conceptos existentes.</target>
        </trans-unit>
        <trans-unit id="aa0d63ddeca860f4dd0ee04e6e6dfb59036ec440" translate="yes" xml:space="preserve">
          <source>Where blocking on a Future in scala is discouraged, in JavaScript it's downright impossible.</source>
          <target state="translated">Donde se desaconseja el bloqueo de un Futuro en la scala,en JavaScript es totalmente imposible.</target>
        </trans-unit>
        <trans-unit id="a04b5cdd0c9e7373883bf0306180ab9eff2c21cc" translate="yes" xml:space="preserve">
          <source>Which is needed in case error handlers are attached asynchronously to the promise later, which would otherwise result in premature unhandled rejection reporting.</source>
          <target state="translated">Lo cual es necesario en caso de que los manejadores de errores se adjunten asincrónicamente a la promesa más tarde,lo que de otro modo daría lugar a un informe de rechazo prematuro y no manejado.</target>
        </trans-unit>
        <trans-unit id="eee12cfe2d4a58cb2a6fc803d3775440ef97f722" translate="yes" xml:space="preserve">
          <source>Which would allow you to use:</source>
          <target state="translated">Lo que te permitiría usar:</target>
        </trans-unit>
        <trans-unit id="35d4fe62a5e87bc7beed2b0eec9121835e2b2243" translate="yes" xml:space="preserve">
          <source>Which would let you do:</source>
          <target state="translated">Lo que te permitiría hacer:</target>
        </trans-unit>
        <trans-unit id="048203462f9f2ccf893052bbc1b4ea9379b53188" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;cancel().&lt;/code&gt; is synchronous - &lt;code&gt;onCancel()&lt;/code&gt; is called asynchronously (in the next turn) just like &lt;code&gt;then&lt;/code&gt; handlers.</source>
          <target state="translated">Mientras &lt;code&gt;cancel().&lt;/code&gt; es sincr&amp;oacute;nica - &lt;code&gt;onCancel()&lt;/code&gt; se llama de forma asincr&amp;oacute;nica (en el siguiente turno) al igual que &lt;code&gt;then&lt;/code&gt; manipuladores.</target>
        </trans-unit>
        <trans-unit id="50051d4da0ca7d94943f9fa9969394e5949e12c1" translate="yes" xml:space="preserve">
          <source>While with long stack traces disabled, you would get:</source>
          <target state="translated">Mientras que con los rastros de la pila larga desactivados,obtendrías:</target>
        </trans-unit>
        <trans-unit id="a448f3eb7ee54eee8b460fbecc359153bf18d65f" translate="yes" xml:space="preserve">
          <source>Why I am switching to promises</source>
          <target state="translated">Por qué estoy cambiando a las promesas</target>
        </trans-unit>
        <trans-unit id="1472dbb2e195b22057a90d66f7a65b38461e79ba" translate="yes" xml:space="preserve">
          <source>Why Performance?</source>
          <target state="translated">¿Por qué la actuación?</target>
        </trans-unit>
        <trans-unit id="103997b340ba267b74ce431e1b85c8fb216b7d7d" translate="yes" xml:space="preserve">
          <source>Why Promises?</source>
          <target state="translated">¿Por qué promesas?</target>
        </trans-unit>
        <trans-unit id="7eed14a899fe9a4d5bf8f80b6404d95efa7b1db8" translate="yes" xml:space="preserve">
          <source>Why bluebird?</source>
          <target state="translated">¿Por qué el pájaro azul?</target>
        </trans-unit>
        <trans-unit id="0f975858c19a385aa9526530dd08a5074375be2f" translate="yes" xml:space="preserve">
          <source>With the use of abstract classes can the similarities between &lt;code&gt;PromptDialog&lt;/code&gt; and &lt;code&gt;NotifyDialog&lt;/code&gt; be abstracted? Make a sub class of &lt;code&gt;Dialog&lt;/code&gt; that abstracts the common DOM code (&lt;code&gt;DOMDialog&lt;/code&gt;). Then refactor the &lt;code&gt;PromptDialog&lt;/code&gt; and &lt;code&gt;NotifyDialog&lt;/code&gt; to inherate from &lt;code&gt;DOMDialog&lt;/code&gt; but references the correct DOM selectors.</source>
          <target state="translated">Con el uso de clases abstractas, &amp;iquest;se pueden abstraer las similitudes entre &lt;code&gt;PromptDialog&lt;/code&gt; y &lt;code&gt;NotifyDialog&lt;/code&gt; ? Haga una subclase de &lt;code&gt;Dialog&lt;/code&gt; que &lt;code&gt;DOMDialog&lt;/code&gt; c&amp;oacute;digo DOM com&amp;uacute;n ( DOMDialog ). A continuaci&amp;oacute;n, refactorice &lt;code&gt;PromptDialog&lt;/code&gt; y &lt;code&gt;NotifyDialog&lt;/code&gt; para que se inhale de &lt;code&gt;DOMDialog&lt;/code&gt; pero haga referencia a los selectores DOM correctos.</target>
        </trans-unit>
        <trans-unit id="b389c6872f328b7947b20ae5c017fe2c10bb9526" translate="yes" xml:space="preserve">
          <source>Without arrow functions that provide lexical &lt;code&gt;this&lt;/code&gt;, the correspondence between async and sync code breaks down when writing object-oriented code. &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind&lt;/code&gt;&lt;/a&gt; alleviates this.</source>
          <target state="translated">Sin las funciones de flecha que proporcionan &lt;code&gt;this&lt;/code&gt; l&amp;eacute;xico , la correspondencia entre el c&amp;oacute;digo as&amp;iacute;ncrono y el de sincronizaci&amp;oacute;n se descompone al escribir c&amp;oacute;digo orientado a objetos. &lt;a href=&quot;bind&quot;&gt; &lt;code&gt;.bind&lt;/code&gt; &lt;/a&gt; alivia esto.</target>
        </trans-unit>
        <trans-unit id="673b91ef144006953b2d0d3e1f31a66ba0a792bd" translate="yes" xml:space="preserve">
          <source>Working with Callbacks</source>
          <target state="translated">Trabajando con las devoluciones de llamada</target>
        </trans-unit>
        <trans-unit id="4814f16d83ce4c03a7697dffe837dd35ff625c3c" translate="yes" xml:space="preserve">
          <source>Working with any other APIs</source>
          <target state="translated">Trabajando con cualquier otro API</target>
        </trans-unit>
        <trans-unit id="d5431ac75df408d5c9ffc310217a12d8d9dcbf00" translate="yes" xml:space="preserve">
          <source>Working with browser APIs</source>
          <target state="translated">Trabajar con las API de los navegadores</target>
        </trans-unit>
        <trans-unit id="e3c2aac0738162450c1ba5ec6b637d0caf73d2e1" translate="yes" xml:space="preserve">
          <source>Working with callback APIs using the Node convention</source>
          <target state="translated">Trabajando con APIs de devolución de llamadas usando la convención de Nodos</target>
        </trans-unit>
        <trans-unit id="37dd709d1ccc2e12457cf6c183d0dbd315ee98c2" translate="yes" xml:space="preserve">
          <source>Working with databases</source>
          <target state="translated">Trabajar con bases de datos</target>
        </trans-unit>
        <trans-unit id="f06f929d4baa5a3ecf78b00957e3722d031a73c3" translate="yes" xml:space="preserve">
          <source>Working with delays</source>
          <target state="translated">Trabajando con retrasos</target>
        </trans-unit>
        <trans-unit id="5122dff991374514454140bce7e200af64069d8d" translate="yes" xml:space="preserve">
          <source>Working with delays/setTimeout</source>
          <target state="translated">Trabajando con retrasos/setTimeout</target>
        </trans-unit>
        <trans-unit id="a1c7659f3ee1ffff84437f6bd7a29c13e55a9375" translate="yes" xml:space="preserve">
          <source>Working with one time events</source>
          <target state="translated">Trabajando con eventos de una sola vez</target>
        </trans-unit>
        <trans-unit id="37316c9a58ae41ce75652d0e2a54b3a2feb756f2" translate="yes" xml:space="preserve">
          <source>Working with one time events.</source>
          <target state="translated">Trabajando con eventos de una sola vez.</target>
        </trans-unit>
        <trans-unit id="8b04f9b661548e262a9e539e7d756bac07782fea" translate="yes" xml:space="preserve">
          <source>Write a function that takes a &lt;code&gt;Dialog&lt;/code&gt; instance and a default value. Have it return a promise that resolves to the default value if the user clicks cancel.</source>
          <target state="translated">Escriba una funci&amp;oacute;n que tome una instancia de &lt;code&gt;Dialog&lt;/code&gt; y un valor predeterminado. Haga que devuelva una promesa que resuelva el valor predeterminado si el usuario hace clic en cancelar.</target>
        </trans-unit>
        <trans-unit id="0cf07d9d6990a0b3a8a806a431339f0ecf271176" translate="yes" xml:space="preserve">
          <source>Yield handlers are called when you yield something that is not supported by default. The first yield handler to return a promise or a thenable will be used. If no yield handler returns a promise or a thenable then an error is raised.</source>
          <target state="translated">Los manejadores de rendimiento se llaman cuando se rinde algo que no está soportado por defecto.El primer gestor de rendimiento que devuelva una promesa o una posibilidad se utilizará.Si ningún gestor de rendimiento devuelve una promesa o una posibilidad,entonces se produce un error.</target>
        </trans-unit>
        <trans-unit id="cb668cd94f8eca0b469371342b38d09219dbd2d0" translate="yes" xml:space="preserve">
          <source>Yielding an array from a coroutine is not supported by default. You can use &lt;a href=&quot;api/coroutine.addyieldhandler&quot;&gt;&lt;code&gt;coroutine.addYieldHandler()&lt;/code&gt;&lt;/a&gt; to configure the old behavior (or any behavior you want).</source>
          <target state="translated">El rendimiento de una matriz desde una rutina no es compatible de forma predeterminada. Puede usar &lt;a href=&quot;api/coroutine.addyieldhandler&quot;&gt; &lt;code&gt;coroutine.addYieldHandler()&lt;/code&gt; &lt;/a&gt; para configurar el comportamiento anterior (o cualquier comportamiento que desee).</target>
        </trans-unit>
        <trans-unit id="b43584c4df9052974185d0f13b0565b92e014095" translate="yes" xml:space="preserve">
          <source>You are able to yield non-promise values by adding your own yield handler using &lt;a href=&quot;promise.coroutine.addyieldhandler&quot;&gt;&lt;code&gt;Promise.coroutine.addYieldHandler&lt;/code&gt;&lt;/a&gt; or calling &lt;code&gt;Promise.coroutine()&lt;/code&gt; with a yield handler function as &lt;code&gt;options.yieldHandler&lt;/code&gt;.</source>
          <target state="translated">Puede generar valores no prometidos agregando su propio controlador de rendimiento utilizando &lt;a href=&quot;promise.coroutine.addyieldhandler&quot;&gt; &lt;code&gt;Promise.coroutine.addYieldHandler&lt;/code&gt; &lt;/a&gt; o llamando a &lt;code&gt;Promise.coroutine()&lt;/code&gt; con una funci&amp;oacute;n de controlador de rendimiento como &lt;code&gt;options.yieldHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e127999f42b63c2eddd476b0efc6c0cd617fe5c2" translate="yes" xml:space="preserve">
          <source>You are getting this error because you are enabling long stack traces after a promise has already been created.</source>
          <target state="translated">Este error se debe a que está habilitando largos rastros de pila después de que una promesa ya ha sido creada.</target>
        </trans-unit>
        <trans-unit id="bf62350a61d792a4742ad486033ffd83aaf0f56d" translate="yes" xml:space="preserve">
          <source>You are getting this error because you have tried to &lt;code&gt;yield&lt;/code&gt; something in a coroutine without a yield handler, for example:</source>
          <target state="translated">Recibe este error porque ha intentado &lt;code&gt;yield&lt;/code&gt; algo en una rutina sin un controlador de rendimiento, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="66ca93bb6eb46f59e659c6e2ebfd242ff1f0e6ac" translate="yes" xml:space="preserve">
          <source>You are getting this error when trying to use &lt;a href=&quot;api/promise.coroutine&quot;&gt;&lt;code&gt;Promise.coroutine&lt;/code&gt;&lt;/a&gt; and not passing it a generator function as a parameter. For example:</source>
          <target state="translated">&lt;a href=&quot;api/promise.coroutine&quot;&gt; &lt;code&gt;Promise.coroutine&lt;/code&gt; &lt;/a&gt; este error cuando intenta utilizar Promise.coroutine y no le pasa una funci&amp;oacute;n de generador como par&amp;aacute;metro. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="91785a774efe083e20f0a926f490793891f37e71" translate="yes" xml:space="preserve">
          <source>You can also pass the resources in an array in the first argument. In this case the handler function will only be called with one argument that is the array containing the resolved resources in respective positions in the array. Example:</source>
          <target state="translated">También puedes pasar los recursos en una matriz en el primer argumento.En este caso,la función de manejo sólo se llamará con un argumento que es la matriz que contiene los recursos resueltos en las respectivas posiciones de la matriz.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="e1e28c9edbfac1286ca67380518a1038c18f9339" translate="yes" xml:space="preserve">
          <source>You can also refactor some looping patterns to a more natural form that would &lt;a href=&quot;https://github.com/promises-aplus/promises-spec/issues/179&quot;&gt;leak memory when using native promises&lt;/a&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n puede refactorizar algunos patrones de bucle a una forma m&amp;aacute;s natural que podr&amp;iacute;a &lt;a href=&quot;https://github.com/promises-aplus/promises-spec/issues/179&quot;&gt;perder memoria al usar promesas nativas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="437864fc7461809f33ab9ef10e2c5d258352b129" translate="yes" xml:space="preserve">
          <source>You can also use it as a hook:</source>
          <target state="translated">También puedes usarlo como un gancho:</target>
        </trans-unit>
        <trans-unit id="5c5b397ce7d92f145be04aede9a7905dd3a775cc" translate="yes" xml:space="preserve">
          <source>You can also use promises to improve code that was written with callbacks:</source>
          <target state="translated">También puedes usar las promesas para mejorar el código que se escribió con las devoluciones de llamada:</target>
        </trans-unit>
        <trans-unit id="283713c3baaf7fbedb1d299415d2545b4024ca50" translate="yes" xml:space="preserve">
          <source>You can change bluebird behavior globally with various environment variables. These global variables affect all instances of bluebird that are running in your environment, rather than just the one you have &lt;code&gt;require&lt;/code&gt;d in your application. The effect an environment variable has depends on the bluebird version.</source>
          <target state="translated">Puede cambiar el comportamiento de bluebird globalmente con varias variables de entorno. Estas variables globales afectan a todas las instancias de bluebird que se ejecutan en su entorno, en lugar de solo la que ha &lt;code&gt;require&lt;/code&gt; en su aplicaci&amp;oacute;n. El efecto que tiene una variable de entorno depende de la versi&amp;oacute;n de bluebird.</target>
        </trans-unit>
        <trans-unit id="06b2e22d4bf3505ebf9bddb84ee0510239a546e0" translate="yes" xml:space="preserve">
          <source>You can configure the warning for checking forgotten return statements with &lt;code&gt;wForgottenReturn&lt;/code&gt;:</source>
          <target state="translated">Puede configurar la advertencia para verificar las declaraciones de devoluci&amp;oacute;n olvidadas con &lt;code&gt;wForgottenReturn&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f5a9baad84a48a76541ea70044c4acc58a16ccf2" translate="yes" xml:space="preserve">
          <source>You can correct this by doing:</source>
          <target state="translated">Puedes corregir esto haciendo:</target>
        </trans-unit>
        <trans-unit id="81293703b0f372c4f1dd8c1c5f5f64e0b6876c85" translate="yes" xml:space="preserve">
          <source>You can get a reference to &lt;a href=&quot;aggregateerror&quot;&gt;&lt;code&gt;AggregateError&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Promise.AggregateError&lt;/code&gt;.</source>
          <target state="translated">Puede obtener una referencia a &lt;a href=&quot;aggregateerror&quot;&gt; &lt;code&gt;AggregateError&lt;/code&gt; &lt;/a&gt; de &lt;code&gt;Promise.AggregateError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fa9ba97c4236ec4af4790e170f1a3227c61dec4" translate="yes" xml:space="preserve">
          <source>You can get this error for several reasons:</source>
          <target state="translated">Puedes obtener este error por varias razones:</target>
        </trans-unit>
        <trans-unit id="ef442967cec8981710fc742773b5611ef039af93" translate="yes" xml:space="preserve">
          <source>You can get this error when you're trying to call &lt;code&gt;.value&lt;/code&gt; or &lt;code&gt;.error&lt;/code&gt; when inspecting a promise where the promise has not been fulfilled or rejected yet.</source>
          <target state="translated">Puede obtener este error cuando intenta llamar a &lt;code&gt;.value&lt;/code&gt; o &lt;code&gt;.error&lt;/code&gt; al inspeccionar una promesa donde la promesa a&amp;uacute;n no se ha cumplido o rechazado.</target>
        </trans-unit>
        <trans-unit id="6f5a4a44a59a1f96bff1bedb0c04a482fd574dd1" translate="yes" xml:space="preserve">
          <source>You can promisify multiple classes in one go by constructing an array out of the classes and passing it to &lt;code&gt;promisifyAll&lt;/code&gt;:</source>
          <target state="translated">Puede promover m&amp;uacute;ltiples clases de una vez construyendo una matriz de las clases y pas&amp;aacute;ndola a &lt;code&gt;promisifyAll&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a9fb5d736e0ab6fce975e6a9b34a4fef475d7bc7" translate="yes" xml:space="preserve">
          <source>You got this error because you used &lt;code&gt;new Promise()&lt;/code&gt; or &lt;code&gt;new Promise(something)&lt;/code&gt; without passing a function as the parameter.</source>
          <target state="translated">Recibi&amp;oacute; este error porque us&amp;oacute; &lt;code&gt;new Promise()&lt;/code&gt; o &lt;code&gt;new Promise(something)&lt;/code&gt; sin pasar una funci&amp;oacute;n como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="a4d97ed3b9b528f072b3b9ef916af019f8c658c3" translate="yes" xml:space="preserve">
          <source>You got this this error because you've used &lt;code&gt;Promise.promisify&lt;/code&gt; on an object, for example:</source>
          <target state="translated">&lt;code&gt;Promise.promisify&lt;/code&gt; este error porque ha utilizado Promise.promisify en un objeto, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="9ca3543e4c8b58e9db66720a46ab1377349e2f9b" translate="yes" xml:space="preserve">
          <source>You may also add multiple filters for a catch handler:</source>
          <target state="translated">También puede añadir varios filtros para un manipulador de capturas:</target>
        </trans-unit>
        <trans-unit id="83847d072bb765ac14ac4e083fdf4b485ddcd196" translate="yes" xml:space="preserve">
          <source>You may also use the custom suffix option to choose another suffix that doesn't result in conflicts.</source>
          <target state="translated">También puede utilizar la opción de sufijo personalizado para elegir otro sufijo que no provoque conflictos.</target>
        </trans-unit>
        <trans-unit id="6624c3c603bb59caba6a82386be7841487cbe7f2" translate="yes" xml:space="preserve">
          <source>You may now return promises and thenables from the filterer function used in &lt;code&gt;Promise.filter&lt;/code&gt; and &lt;code&gt;Promise.prototype.filter&lt;/code&gt;.</source>
          <target state="translated">Ahora puede devolver promesas y cumplibles de la funci&amp;oacute;n de &lt;code&gt;Promise.filter&lt;/code&gt; utilizada en Promise.filter y &lt;code&gt;Promise.prototype.filter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05e60416b3790827596a6ef7f2cab94aae07bff3" translate="yes" xml:space="preserve">
          <source>You may optionally prepend one predicate function or ErrorClass to pattern match the error (the generic &lt;a href=&quot;catch&quot;&gt;&lt;code&gt;.catch&lt;/code&gt;&lt;/a&gt; methods accepts multiple)</source>
          <target state="translated">Opcionalmente, puede anteponer una funci&amp;oacute;n de predicado o ErrorClass para que el patr&amp;oacute;n coincida con el error (los m&amp;eacute;todos gen&amp;eacute;ricos &lt;a href=&quot;catch&quot;&gt; &lt;code&gt;.catch&lt;/code&gt; &lt;/a&gt; aceptan m&amp;uacute;ltiples)</target>
        </trans-unit>
        <trans-unit id="4dea303545fcf8fcdea34efebeca4ef1c0a6fbdc" translate="yes" xml:space="preserve">
          <source>You may optionally specify a concurrency limit:</source>
          <target state="translated">Opcionalmente,puede especificar un límite de concurrencia:</target>
        </trans-unit>
        <trans-unit id="1f96ba6d073dbbb822c6dc38156f5d2c778c3e34" translate="yes" xml:space="preserve">
          <source>You may register an optional cancellation hook at a root promise by using the &lt;code&gt;onCancel&lt;/code&gt; argument that is passed to the executor function when cancellation is enabled:</source>
          <target state="translated">Puede registrar un enlace de cancelaci&amp;oacute;n opcional en una promesa de ra&amp;iacute;z utilizando el argumento &lt;code&gt;onCancel&lt;/code&gt; que se pasa a la funci&amp;oacute;n ejecutora cuando la cancelaci&amp;oacute;n est&amp;aacute; habilitada:</target>
        </trans-unit>
        <trans-unit id="da7c4c4ceabe5cd66746addf080121cd0177cb25" translate="yes" xml:space="preserve">
          <source>You may use &lt;a href=&quot;api/promise.setscheduler&quot;&gt;&lt;code&gt;Promise.setScheduler&lt;/code&gt;&lt;/a&gt; to pass a custom scheduler that your environment supports. For example in DukTape:</source>
          <target state="translated">Puede usar &lt;a href=&quot;api/promise.setscheduler&quot;&gt; &lt;code&gt;Promise.setScheduler&lt;/code&gt; &lt;/a&gt; para pasar un programador personalizado que admita su entorno. Por ejemplo en DukTape:</target>
        </trans-unit>
        <trans-unit id="72d529e0be153c472000cf98a0b7d4552852d11f" translate="yes" xml:space="preserve">
          <source>You may use browserify on the main export</source>
          <target state="translated">Puede utilizar el navegador en la exportación principal</target>
        </trans-unit>
        <trans-unit id="5178ce348175a2d6a2e16b69f6aa6c59ef943a40" translate="yes" xml:space="preserve">
          <source>You may use the &lt;a href=&quot;http://bower.io&quot;&gt;bower&lt;/a&gt; package.</source>
          <target state="translated">Puede usar el paquete de &lt;a href=&quot;http://bower.io&quot;&gt;bower&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79662f72fb448baebdf8a6c7d0131a375dff4095" translate="yes" xml:space="preserve">
          <source>You might have to use a deferred object when wrapping a callback API that doesn't follow the standard convention. Like &lt;code&gt;setTimeout&lt;/code&gt;:</source>
          <target state="translated">Es posible que deba usar un objeto diferido al ajustar una API de devoluci&amp;oacute;n de llamada que no siga la convenci&amp;oacute;n est&amp;aacute;ndar. Como &lt;code&gt;setTimeout&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c2ac050d03d9c2bd58543cfcee398d79f07ec7bc" translate="yes" xml:space="preserve">
          <source>You might notice that the promise approach looks very similar to using synchronous I/O:</source>
          <target state="translated">Notarán que el enfoque de la promesa es muy similar al uso de E/S síncrona:</target>
        </trans-unit>
        <trans-unit id="a07914b7b08162442f33327417b0ff4a50f4409e" translate="yes" xml:space="preserve">
          <source>You passed a non-function where a function was expected.</source>
          <target state="translated">Pasaste una no-función donde se esperaba una función.</target>
        </trans-unit>
        <trans-unit id="cc81677e43359861a52ce63568e3d792c6bcee22" translate="yes" xml:space="preserve">
          <source>You should check if this promise is &lt;a href=&quot;isfulfilled&quot;&gt;&lt;code&gt;.isFulfilled()&lt;/code&gt;&lt;/a&gt; in code paths where it's not guaranteed that this promise is fulfilled.</source>
          <target state="translated">Debe verificar si esta promesa es &lt;a href=&quot;isfulfilled&quot;&gt; &lt;code&gt;.isFulfilled()&lt;/code&gt; &lt;/a&gt; en rutas de c&amp;oacute;digo donde no se garantiza que esta promesa se cumpla.</target>
        </trans-unit>
        <trans-unit id="88143ae7a4624ccb7145716c9f902897a88d096d" translate="yes" xml:space="preserve">
          <source>You should check if this promise is &lt;a href=&quot;isrejected&quot;&gt;&lt;code&gt;.isRejected()&lt;/code&gt;&lt;/a&gt; in code paths where it's guaranteed that this promise is rejected.</source>
          <target state="translated">Debe verificar si esta promesa es &lt;a href=&quot;isrejected&quot;&gt; &lt;code&gt;.isRejected()&lt;/code&gt; &lt;/a&gt; en las rutas de c&amp;oacute;digo donde se garantiza que esta promesa se rechaza.</target>
        </trans-unit>
        <trans-unit id="a5bc1b292604f8a755bedb0d6bdc5baa78c79e97" translate="yes" xml:space="preserve">
          <source>You should enabled long stack traces if you want better debugging experience. For example:</source>
          <target state="translated">Deberías habilitar los rastros de pila larga si quieres una mejor experiencia de depuración.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="9389a4bd5323ad51b671d2380af345d329495a0f" translate="yes" xml:space="preserve">
          <source>You should heed this warning because rejecting a promise with a non-error makes debugging extremely hard and costly. Additionally, if you reject with simple primitives such as &lt;code&gt;undefined&lt;/code&gt; (commonly caused by simply calling &lt;code&gt;reject()&lt;/code&gt;) you cannot handle errors at all because it's impossible to tell from &lt;code&gt;undefined&lt;/code&gt; what exactly went wrong. All you can tell the user is that &quot;something went wrong&quot; and lose them forever.</source>
          <target state="translated">Deber&amp;iacute;a prestar atenci&amp;oacute;n a esta advertencia porque rechazar una promesa sin error hace que la depuraci&amp;oacute;n sea extremadamente dif&amp;iacute;cil y costosa. Adem&amp;aacute;s, si rechaza con primitivas simples como &lt;code&gt;undefined&lt;/code&gt; (com&amp;uacute;nmente causado por simplemente llamar a &lt;code&gt;reject()&lt;/code&gt; ) no puede manejar los errores en absoluto porque es imposible saber desde &lt;code&gt;undefined&lt;/code&gt; qu&amp;eacute; sali&amp;oacute; mal exactamente. Todo lo que puede decirle al usuario es que &quot;algo sali&amp;oacute; mal&quot; y los pierde para siempre.</target>
        </trans-unit>
        <trans-unit id="ee7d769e258faced0824e928a0c2037e1a245676" translate="yes" xml:space="preserve">
          <source>You should use promises to turn this:</source>
          <target state="translated">Deberías usar promesas para convertir esto:</target>
        </trans-unit>
        <trans-unit id="3801444ae548127f53972d4de9db926d35147429" translate="yes" xml:space="preserve">
          <source>Your library can then use &lt;code&gt;var Promise = require(&quot;bluebird-extended&quot;);&lt;/code&gt; and do whatever it wants with it. Then if the application or other library uses their own bluebird promises they will all play well together because of Promises/A+ thenable assimilation magic.</source>
          <target state="translated">Su biblioteca puede usar &lt;code&gt;var Promise = require(&quot;bluebird-extended&quot;);&lt;/code&gt; y haz lo que quiera con &amp;eacute;l. Luego, si la aplicaci&amp;oacute;n u otra biblioteca usa sus propias promesas de bluebird, todos jugar&amp;aacute;n bien juntos debido a la magia de asimilaci&amp;oacute;n que promete Promises / A +.</target>
        </trans-unit>
        <trans-unit id="2ea5d7794d32ab52b93c85c9e6c21b1aea324d24" translate="yes" xml:space="preserve">
          <source>because &lt;code&gt;data&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; at the time &lt;code&gt;.return&lt;/code&gt; is called.</source>
          <target state="translated">porque los &lt;code&gt;data&lt;/code&gt; &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute;n definidos en el momento en que se llama &lt;code&gt;.return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c304689dc11138fde5d03ea645ecb41953e1334" translate="yes" xml:space="preserve">
          <source>bugfix</source>
          <target state="translated">bugfix</target>
        </trans-unit>
        <trans-unit id="321ef65dd8e0fe725eb1aefadf1bd87479757769" translate="yes" xml:space="preserve">
          <source>composes with other bluebird features, like &lt;a href=&quot;promise.all&quot;&gt;&lt;code&gt;Promise.all&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">se compone con otras caracter&amp;iacute;sticas de bluebird, como &lt;a href=&quot;promise.all&quot;&gt; &lt;code&gt;Promise.all&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b7615dce52c4c05ce4e1d374e9c61a13717ac7c" translate="yes" xml:space="preserve">
          <source>feature</source>
          <target state="translated">feature</target>
        </trans-unit>
        <trans-unit id="03e02ad7e48448605c30956ca4071a16aaf4bf8b" translate="yes" xml:space="preserve">
          <source>in the case where &lt;code&gt;value&lt;/code&gt; doesn't change its value because its binding time is different than when using a closure.</source>
          <target state="translated">en el caso donde el &lt;code&gt;value&lt;/code&gt; no cambia su valor porque su tiempo de enlace es diferente que cuando se usa un cierre.</target>
        </trans-unit>
        <trans-unit id="fdb19623519a22b9149620557f13925f7b42fd29" translate="yes" xml:space="preserve">
          <source>new Promise</source>
          <target state="translated">nueva Promesa</target>
        </trans-unit>
        <trans-unit id="afbedb8dbf47bdab5c49c2b9d92015b7b3581a43" translate="yes" xml:space="preserve">
          <source>new Promise()</source>
          <target state="translated">nueva Promesa()</target>
        </trans-unit>
        <trans-unit id="558916e0aef77e0a7a2bbe15ca31648114109299" translate="yes" xml:space="preserve">
          <source>no setup code required to make cancellation work</source>
          <target state="translated">no se requiere un código de configuración para hacer que la cancelación funcione</target>
        </trans-unit>
        <trans-unit id="4397a4d17f5c537ce4e705bcaf7b0efdd50c51d6" translate="yes" xml:space="preserve">
          <source>reasonable semantics for multiple consumer cancellation</source>
          <target state="translated">semántica razonable para la cancelación de consumidores múltiples</target>
        </trans-unit>
        <trans-unit id="748bc7560ff57854e11d5ab937864f0ff100bb12" translate="yes" xml:space="preserve">
          <source>resolving it with itself tells it &quot;it is done when it is done&quot;</source>
          <target state="translated">resolverlo con sí mismo le dice &quot;está hecho cuando está hecho&quot;</target>
        </trans-unit>
        <trans-unit id="9379d4b4f4ef9775cb3c71402acd9e3e7970ea7f" translate="yes" xml:space="preserve">
          <source>throw TypeError when thenable resolves with itself</source>
          <target state="translated">lanzar el TypeError cuando el thenable se resuelve con él mismo</target>
        </trans-unit>
        <trans-unit id="44176cf9434e38d37133324ac3fb90ae6fc35afd" translate="yes" xml:space="preserve">
          <source>~~Promise.longStackTraces~~</source>
          <target state="translated">~~Promise.longStackTraces~~</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
