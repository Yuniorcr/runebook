<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="481df4f9db6b7c39f75ab8b5d8402946a05557b9" translate="yes" xml:space="preserve">
          <source>An output range that discards the data it receives.</source>
          <target state="translated">Un rango de salida que descarta los datos que recibe.</target>
        </trans-unit>
        <trans-unit id="01b526186c983c89501e19ff25742faa0abd686c" translate="yes" xml:space="preserve">
          <source>An output range to write the contents to.</source>
          <target state="translated">Un rango de salida para escribir el contenido.</target>
        </trans-unit>
        <trans-unit id="6ec96a76a1b7b768707aea157270f72d702aae35" translate="yes" xml:space="preserve">
          <source>An uninitialized &lt;code&gt;Variant&lt;/code&gt; is used in any way except assignment and &lt;code&gt;hasValue&lt;/code&gt;;</source>
          <target state="translated">Una &lt;code&gt;Variant&lt;/code&gt; no inicializada se utiliza de cualquier forma, excepto la asignaci&amp;oacute;n y &lt;code&gt;hasValue&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="017d1765237968f656e289b4e56677bea3baad1b" translate="yes" xml:space="preserve">
          <source>An uninitialized value, generated from void initializers.</source>
          <target state="translated">Un valor no inicializado,generado a partir de inicializadores de vacío.</target>
        </trans-unit>
        <trans-unit id="6d865e1b843ed22f5ad95224465f066dd3bf97cd" translate="yes" xml:space="preserve">
          <source>An unqualified postblit will get called even if the struct is instantiated as &lt;code&gt;immutable&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;, but the compiler issues an error if the struct is instantiated as &lt;code&gt;shared&lt;/code&gt;:</source>
          <target state="translated">Se llamar&amp;aacute; a un postblit no calificado incluso si la estructura se instancia como &lt;code&gt;immutable&lt;/code&gt; o &lt;code&gt;const&lt;/code&gt; ante , pero el compilador emite un error si la estructura se instancia como &lt;code&gt;shared&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="02377b58a34c4a8ec19952d46cd99f893c878ed8" translate="yes" xml:space="preserve">
          <source>An unrecognized command-line argument is passed, and &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; was not present.</source>
          <target state="translated">Se pasa un argumento de l&amp;iacute;nea de comandos no reconocido y &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; no estaba presente.</target>
        </trans-unit>
        <trans-unit id="355743baaf25b39e6a1bf6c9a0897a53f7ca51a0" translate="yes" xml:space="preserve">
          <source>An unrecognized option such as &quot;--baz&quot; will be found untouched in &lt;code&gt;args&lt;/code&gt; after &lt;code&gt;getopt&lt;/code&gt; returns.</source>
          <target state="translated">Una opci&amp;oacute;n no reconocida como &quot;--baz&quot; se encontrar&amp;aacute; intacta en &lt;code&gt;args&lt;/code&gt; despu&amp;eacute;s de que regresa &lt;code&gt;getopt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b75455d22427a9d7061b91a6aa632f59812aa7cb" translate="yes" xml:space="preserve">
          <source>Analogously to class templates, struct, union and interfaces can be transformed into templates by supplying a template parameter list.</source>
          <target state="translated">Análogamente a las plantillas de clase,la estructura,la unión y las interfaces pueden transformarse en plantillas suministrando una lista de parámetros de plantillas.</target>
        </trans-unit>
        <trans-unit id="381d6919b76a155cc3d0bed8744ee2e82e29874b" translate="yes" xml:space="preserve">
          <source>Analogously, &lt;code&gt;typeof(super)&lt;/code&gt; will generate the type of what &lt;code&gt;super&lt;/code&gt; would be in a non-static member function.</source>
          <target state="translated">An&amp;aacute;logamente, &lt;code&gt;typeof(super)&lt;/code&gt; generar&amp;aacute; el tipo de lo que ser&amp;iacute;a &lt;code&gt;super&lt;/code&gt; en una funci&amp;oacute;n miembro no est&amp;aacute;tica.</target>
        </trans-unit>
        <trans-unit id="e760dd880de0f515f576dc77edef82d0231e14ae" translate="yes" xml:space="preserve">
          <source>Ancient Greek Musical Notation</source>
          <target state="translated">Notación musical del griego antiguo</target>
        </trans-unit>
        <trans-unit id="aac24095b26055100b3e137537a2c7e0ad932e04" translate="yes" xml:space="preserve">
          <source>Ancient Greek Numbers</source>
          <target state="translated">Números de la antigua Grecia</target>
        </trans-unit>
        <trans-unit id="3550f110a8c69b086b7eac12c46c400773c345dc" translate="yes" xml:space="preserve">
          <source>Ancient Symbols</source>
          <target state="translated">Símbolos antiguos</target>
        </trans-unit>
        <trans-unit id="29bd442643bea5b50cf62a67104dd1d1aa8f0d1e" translate="yes" xml:space="preserve">
          <source>And Expressions</source>
          <target state="translated">Y las expresiones</target>
        </trans-unit>
        <trans-unit id="955032d49b799cc6cb579cffbe0f243b5d0f3d5f" translate="yes" xml:space="preserve">
          <source>And all the summary sections will now be green.</source>
          <target state="translated">Y todas las secciones de resumen serán ahora de color verde.</target>
        </trans-unit>
        <trans-unit id="e67c2d4e000dc2740dc758b29287dd9038d89a6b" translate="yes" xml:space="preserve">
          <source>And an example of D code providing a callback to C code:</source>
          <target state="translated">Y un ejemplo de código D que proporciona una llamada al código C:</target>
        </trans-unit>
        <trans-unit id="028627a78221787a21142d8d33379cef0d471467" translate="yes" xml:space="preserve">
          <source>AndAnd Expressions</source>
          <target state="translated">y expresiones</target>
        </trans-unit>
        <trans-unit id="d132739724126beb0a58639e9a6156fdf0949d66" translate="yes" xml:space="preserve">
          <source>AndAndExpression</source>
          <target state="translated">AndAndExpression</target>
        </trans-unit>
        <trans-unit id="b25772e958c7000fd371337d6359418dab3becfa" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu</source>
          <target state="translated">Andrei Alexandrescu</target>
        </trans-unit>
        <trans-unit id="8086e1eeb4770ea0dab8abf60035423c0a58a5b4" translate="yes" xml:space="preserve">
          <source>Andrei Alexandrescu's article &lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt; &lt;i&gt;On Iteration&lt;/i&gt;&lt;/a&gt; for conceptual aspect of ranges and the motivation</source>
          <target state="translated">Art&amp;iacute;culo de Andrei Alexandrescu &lt;a href=&quot;http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;amp;rll=1&quot;&gt;&lt;i&gt;sobre iteraci&amp;oacute;n&lt;/i&gt;&lt;/a&gt; para el aspecto conceptual de los rangos y la motivaci&amp;oacute;n. &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="translated">Android</target>
        </trans-unit>
        <trans-unit id="b803b58141bc58845f04cfa8646ac85f1f1a979d" translate="yes" xml:space="preserve">
          <source>Anonymous Enums</source>
          <target state="translated">Enumeraciones anónimas</target>
        </trans-unit>
        <trans-unit id="7ccd2afbc983959f9583ca7f31cb4e5cf46494d9" translate="yes" xml:space="preserve">
          <source>Anonymous Functions and Anonymous Delegates</source>
          <target state="translated">Funciones anónimas y delegados anónimos</target>
        </trans-unit>
        <trans-unit id="98a2443b6da1909f7a102e64a4964e0f390eb397" translate="yes" xml:space="preserve">
          <source>Anonymous Nested Classes</source>
          <target state="translated">Clases Anónimas Anidadas</target>
        </trans-unit>
        <trans-unit id="46249cc944aedcf50eaf15b7e810784027798c68" translate="yes" xml:space="preserve">
          <source>Anonymous delegates can behave like arbitrary statement literals. For example, here an arbitrary statement is executed by a loop:</source>
          <target state="translated">Los delegados anónimos pueden comportarse como literales de declaración arbitraria.Por ejemplo,aquí una declaración arbitraria es ejecutada por un bucle:</target>
        </trans-unit>
        <trans-unit id="e1acf88a52df3795f2b20ed6511eee7ceb7ec305" translate="yes" xml:space="preserve">
          <source>Another caveat of using sub-matcher is that skip is not available preciesly because sub-matcher doesn't detect all lengths.</source>
          <target state="translated">Otra salvedad del uso del subcaptador es que el salto no está disponible con precisión porque el subcaptador no detecta todas las longitudes.</target>
        </trans-unit>
        <trans-unit id="9a60f4e1a9ef014cfadbb26ea290e8c3eb775ed4" translate="yes" xml:space="preserve">
          <source>Another event handling module</source>
          <target state="translated">Otro módulo de manejo de eventos</target>
        </trans-unit>
        <trans-unit id="bae2455d3699406c3641a5d660465c6bf6758fc6" translate="yes" xml:space="preserve">
          <source>Another example of formatting a &lt;code&gt;struct&lt;/code&gt; with a defined &lt;code&gt;toString&lt;/code&gt;, this time using the &lt;code&gt;scope delegate&lt;/code&gt; method.  This method is now discouraged for non-virtual functions. If possible, please use the output range method instead.</source>
          <target state="translated">Otro ejemplo de formateo de una &lt;code&gt;struct&lt;/code&gt; con un &lt;code&gt;toString&lt;/code&gt; definido , esta vez usando el m&amp;eacute;todo de &lt;code&gt;scope delegate&lt;/code&gt; . Este m&amp;eacute;todo ahora se desaconseja para funciones no virtuales. Si es posible, utilice el m&amp;eacute;todo de rango de salida en su lugar.</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="85e6f644dc8e5726c5821532bf00eff211afd4d4" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; or non-basic &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; (i.e. any type that does not encode as a fixed one or two character sequence) that has been emitted to the mangled symbol before will not be emitted again, but is referenced by a special sequence encoding the relative position of the original occurrence in the mangled symbol name.</source>
          <target state="translated">Cualquier &lt;a href=&quot;#LName&quot;&gt;&lt;i&gt;LName&lt;/i&gt;&lt;/a&gt; o no b&amp;aacute;sico &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Tipo&lt;/i&gt;&lt;/a&gt; (es decir, cualquier tipo que no hace codificar como una o dos secuencia de caracteres fijo) que ha sido emitida al s&amp;iacute;mbolo mangled antes no ser&amp;aacute; emitida de nuevo, pero se hace referencia por una secuencia especial que codifica la posici&amp;oacute;n relativa de la aparici&amp;oacute;n original en el nombre del s&amp;iacute;mbolo destrozado.</target>
        </trans-unit>
        <trans-unit id="a4ebed2ed3fe69fdf17bf0f9ea8120a1a0f126ed" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;pure&lt;/code&gt; function that is not strongly pure cannot be assumed to be memoizable, and calls to it may not be elided even if it returns &lt;code&gt;void&lt;/code&gt; (save for compiler optimizations that prove the function has no effect). Function calls may still be elided, or results be memoized, by means of traditional inlining and optimization techniques available for all functions.</source>
          <target state="translated">No se puede suponer que cualquier funci&amp;oacute;n &lt;code&gt;pure&lt;/code&gt; que no sea fuertemente pura sea memorable, y es posible que las llamadas no se eluden incluso si devuelve &lt;code&gt;void&lt;/code&gt; (salvo para las optimizaciones del compilador que prueban que la funci&amp;oacute;n no tiene efecto). Las llamadas a funciones a&amp;uacute;n se pueden omitir, o los resultados se pueden memorizar, por medio de t&amp;eacute;cnicas tradicionales de optimizaci&amp;oacute;n y en l&amp;iacute;nea disponibles para todas las funciones.</target>
        </trans-unit>
        <trans-unit id="eb9050538a91f8603d45e66e05f6aeeb1d29c1a1" translate="yes" xml:space="preserve">
          <source>Any CSV input</source>
          <target state="translated">Cualquier entrada de CSV</target>
        </trans-unit>
        <trans-unit id="3dd20dd36e01004b82e2eb3d1b7678c47e9521c9" translate="yes" xml:space="preserve">
          <source>Any IPv4 host address.</source>
          <target state="translated">Cualquier dirección de host IPv4.</target>
        </trans-unit>
        <trans-unit id="8aed77784e6588d748089e680321e31de462e28c" translate="yes" xml:space="preserve">
          <source>Any IPv4 port number.</source>
          <target state="translated">Cualquier número de puerto IPv4.</target>
        </trans-unit>
        <trans-unit id="bb484c1e8a46997e29e20927039aa9b377327c02" translate="yes" xml:space="preserve">
          <source>Any IPv6 host address.</source>
          <target state="translated">Cualquier dirección de host IPv6.</target>
        </trans-unit>
        <trans-unit id="94c6cca2615cd31987c71c42944c48bb96956b95" translate="yes" xml:space="preserve">
          <source>Any IPv6 port number.</source>
          <target state="translated">Cualquier número de puerto IPv6.</target>
        </trans-unit>
        <trans-unit id="1e80ff69d9bdfebf77e41c7bd69caee37e4adb6e" translate="yes" xml:space="preserve">
          <source>Any Object types will be serialized in a key-sorted order.</source>
          <target state="translated">Cualquier tipo de objeto será serializado en un orden clave.</target>
        </trans-unit>
        <trans-unit id="6f7c1cd84505fa215ea84971d24628315cd3387b" translate="yes" xml:space="preserve">
          <source>Any Statement that fails semantic() or has a component that is an ErrorExp or a TypeError should return an ErrorStatement from semantic().</source>
          <target state="translated">Cualquier declaración que falle semantic()o que tenga un componente que sea un ErrorExp o un TypeError debería devolver una ErrorStatement de semantic().</target>
        </trans-unit>
        <trans-unit id="baa16ecc9203783f7d302f47d6c7e99ca53b7882" translate="yes" xml:space="preserve">
          <source>Any ambiguities in the grammar between</source>
          <target state="translated">Cualquier ambigüedad en la gramática entre</target>
        </trans-unit>
        <trans-unit id="77ecebcd0dc38ae59d287e9d6832a173b570a0a2" translate="yes" xml:space="preserve">
          <source>Any atom</source>
          <target state="translated">Cualquier átomo</target>
        </trans-unit>
        <trans-unit id="638621cad02fb4ef96d35005061aa41c6d8d2099" translate="yes" xml:space="preserve">
          <source>Any casting of a class reference to a derived class reference is done with a runtime check to make sure it really is a downcast. &lt;code&gt;null&lt;/code&gt; is the result if it isn't.</source>
          <target state="translated">Cualquier conversi&amp;oacute;n de una referencia de clase a una referencia de clase derivada se realiza con una verificaci&amp;oacute;n de tiempo de ejecuci&amp;oacute;n para asegurarse de que realmente sea un downcast. &lt;code&gt;null&lt;/code&gt; es el resultado si no lo es.</target>
        </trans-unit>
        <trans-unit id="7916c4b8de53330f21dcd29a0e59721012e5dd75" translate="yes" xml:space="preserve">
          <source>Any class invariants for base classes are applied before the class invariant for the derived class.</source>
          <target state="translated">Cualquier invariante de clase para las clases básicas se aplica antes de la invariante de clase para la clase derivada.</target>
        </trans-unit>
        <trans-unit id="f7e950396436ad2a46ce9aad7dec469f189171b3" translate="yes" xml:space="preserve">
          <source>Any data referenced by the const declaration cannot be changed from the const declaration, but it might be changed by other references to the same data.</source>
          <target state="translated">Los datos a los que se hace referencia en la declaración const no pueden modificarse a partir de la declaración const,pero pueden modificarse mediante otras referencias a los mismos datos.</target>
        </trans-unit>
        <trans-unit id="ea9ba6b957e1ee541543e4ed84469edf4ec75cad" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined thread.</source>
          <target state="translated">Cualquier excepción no manejada por el hilo unido.</target>
        </trans-unit>
        <trans-unit id="df41046890795b4eaa63b398c58e4d9d99374a20" translate="yes" xml:space="preserve">
          <source>Any exception not handled by the joined threads.</source>
          <target state="translated">Cualquier excepción no manejada por los hilos unidos.</target>
        </trans-unit>
        <trans-unit id="010d3e9dcdbd22cd7fd006df77170e4cb60a5618" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this fiber if rethrow = false, null otherwise.</source>
          <target state="translated">Cualquier excepción que no sea manejada por esta fibra si relanzamiento=falso,nulo de otra manera.</target>
        </trans-unit>
        <trans-unit id="b6ba130c34ce4b05804f636f1f2f916c5937c009" translate="yes" xml:space="preserve">
          <source>Any exception not handled by this thread if rethrow = false, null otherwise.</source>
          <target state="translated">Cualquier excepción no manejada por este hilo si relanzamiento=falso,nulo de otra manera.</target>
        </trans-unit>
        <trans-unit id="3547b50f09fd44e299559c0d0f1b8fb00ea84d79" translate="yes" xml:space="preserve">
          <source>Any expression that resolves to either a tuple of strings or an empty tuple is accepted. When the expression resolves to an empty tuple, it is equivalent to &lt;code&gt;extern (C++)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f674a6378976f81a229e3e40bb92d9695e3314fe" translate="yes" xml:space="preserve">
          <source>Any functions that execute in CTFE must also be executable at run time. The compile time evaluation of a function does the equivalent of running the function at run time. This means that the semantics of a function cannot depend on compile time values of the function. For example:</source>
          <target state="translated">Cualquier función que se ejecute en la CTFE también debe ser ejecutable en tiempo de ejecución.La evaluación del tiempo de compilación de una función hace el equivalente de ejecutar la función en tiempo de ejecución.Esto significa que la semántica de una función no puede depender de los valores de tiempo de compilación de la función.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a57e0db645362adce30e4484501c92ffe3bbf8b7" translate="yes" xml:space="preserve">
          <source>Any insertion, removal, or lookups in an associative array</source>
          <target state="translated">Cualquier inserción,extracción o búsqueda en un conjunto asociativo</target>
        </trans-unit>
        <trans-unit id="0e84b6b0c57f34d7c618d447a7ab2c9f8792eac9" translate="yes" xml:space="preserve">
          <source>Any interface that derives from a C++ interface is also a C++ interface. A C++ interface differs from a D interface in that:</source>
          <target state="translated">Cualquier interfaz que derive de una interfaz C++es también una interfaz C++.Una interfaz C++se diferencia de una interfaz D en que:</target>
        </trans-unit>
        <trans-unit id="440031e52a8a0c7f5013522c41d2f3dc66691e39" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, along with releasing any intervening synchronization mutexes.</source>
          <target state="translated">Se ejecutan las cláusulas finales que intervienen,junto con la liberación de los mutex de sincronización que intervienen.</target>
        </trans-unit>
        <trans-unit id="752a908277ccaeb8ca9908aea34bc98614160ea6" translate="yes" xml:space="preserve">
          <source>Any intervening finally clauses are executed, and any intervening synchronization objects are released.</source>
          <target state="translated">Se ejecutan las cláusulas finales que intervienen y se liberan los objetos de sincronización que intervienen.</target>
        </trans-unit>
        <trans-unit id="3c58819fbd73a8c9fe0c340f0db018003ce09975" translate="yes" xml:space="preserve">
          <source>Any invariants for fields are applied before the struct invariant.</source>
          <target state="translated">Cualquier invariante para los campos se aplica antes de la invariante estructural.</target>
        </trans-unit>
        <trans-unit id="f9fe95fc6eae39aaf25f84d103f3acf7d7a384fd" translate="yes" xml:space="preserve">
          <source>Any license information for copyrighted code.</source>
          <target state="translated">Cualquier información de licencia para el código de derechos de autor.</target>
        </trans-unit>
        <trans-unit id="67b9adde439b5f8364926599d4a45d83875f65d8" translate="yes" xml:space="preserve">
          <source>Any numerical type that supports the modulo operator &lt;code&gt;%&lt;/code&gt;. If bit-shifting &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; are also supported, Stein's algorithm will be used; otherwise, Euclid's algorithm is used as a fallback.</source>
          <target state="translated">Cualquier tipo num&amp;eacute;rico que admita el operador de m&amp;oacute;dulo &lt;code&gt;%&lt;/code&gt; . Si los cambios de bit &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; y &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; tambi&amp;eacute;n son compatibles, se utilizar&amp;aacute; el algoritmo de Stein; de lo contrario, el algoritmo de Euclides se usa como reserva.</target>
        </trans-unit>
        <trans-unit id="81c3013df61cbea6a4c917b70878d87da30767d9" translate="yes" xml:space="preserve">
          <source>Any pointer may be cast to &lt;code&gt;void*&lt;/code&gt; and from &lt;code&gt;void*&lt;/code&gt; back to its original type. Casting between pointer and non-pointer types is prohibited.</source>
          <target state="translated">Cualquier puntero se puede convertir a &lt;code&gt;void*&lt;/code&gt; y de &lt;code&gt;void*&lt;/code&gt; a su tipo original. Se proh&amp;iacute;be la conversi&amp;oacute;n entre tipos de puntero y sin puntero.</target>
        </trans-unit>
        <trans-unit id="c5cc05a90008a92dc38ec7d27e928baccc65c4ac" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;NegInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;NegInfInterval&lt;/code&gt; is to create an infinite range which starts at negative infinity and goes to a fixed end point. Iterate over it in reverse.</source>
          <target state="translated">Cualquier rango que itera sobre un &lt;code&gt;NegInfInterval&lt;/code&gt; es infinito. Por lo tanto, el prop&amp;oacute;sito principal de usar &lt;code&gt;NegInfInterval&lt;/code&gt; es crear un rango infinito que comience en el infinito negativo y vaya a un punto final fijo. Iterar sobre &amp;eacute;l a la inversa.</target>
        </trans-unit>
        <trans-unit id="fea46f39188f37b7400472b6a7256e566f0dadfc" translate="yes" xml:space="preserve">
          <source>Any ranges which iterate over a &lt;code&gt;PosInfInterval&lt;/code&gt; are infinite. So, the main purpose of using &lt;code&gt;PosInfInterval&lt;/code&gt; is to create an infinite range which starts at a fixed point in time and goes to positive infinity.</source>
          <target state="translated">Cualquier rango que itera sobre un &lt;code&gt;PosInfInterval&lt;/code&gt; es infinito. Por lo tanto, el prop&amp;oacute;sito principal de usar &lt;code&gt;PosInfInterval&lt;/code&gt; es crear un rango infinito que comience en un punto fijo en el tiempo y llegue al infinito positivo.</target>
        </trans-unit>
        <trans-unit id="f9d9d3b6ac3e9e29441a9345be2bae022fb55442" translate="yes" xml:space="preserve">
          <source>Any sequence of character class elements implicitly forms a union.</source>
          <target state="translated">Cualquier secuencia de elementos de clase de carácter forma implícitamente una unión.</target>
        </trans-unit>
        <trans-unit id="f33c41254cc91d5ef5db3832237d967b66a6b7df" translate="yes" xml:space="preserve">
          <source>Any statement can be labeled, including empty statements, and so can serve as the target of a goto statement. Labeled statements can also serve as the target of a break or continue statement.</source>
          <target state="translated">Cualquier declaración puede ser etiquetada,incluyendo las declaraciones vacías,y así puede servir como objetivo de una declaración de goto.Las declaraciones etiquetadas también pueden servir como objetivo de una declaración de &quot;break&quot; o &quot;continue&quot;.</target>
        </trans-unit>
        <trans-unit id="77bf850fc03647bf14bd010a86cea6f71dcbb566" translate="yes" xml:space="preserve">
          <source>Any type which implicitly converts to &lt;code&gt;dchar&lt;/code&gt;. In the case where it's a built-in type, or an enum of a built-in type, &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; is returned, whereas if it's a user-defined type, &lt;code&gt;dchar&lt;/code&gt; is returned.</source>
          <target state="translated">Cualquier tipo que impl&amp;iacute;citamente se convierta a &lt;code&gt;dchar&lt;/code&gt; . En el caso de que sea un tipo incorporado, o una enumeraci&amp;oacute;n de un tipo &lt;code&gt;Unqual!(OriginalType!C)&lt;/code&gt; , se devuelve Unqual! (OriginalType! C) , mientras que si es un tipo definido por el usuario, se devuelve &lt;code&gt;dchar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83413c5ae04e9398c07c45877def24fe2d3e627f" translate="yes" xml:space="preserve">
          <source>Any usage examples</source>
          <target state="translated">Cualquier ejemplo de uso</target>
        </trans-unit>
        <trans-unit id="5b0bf7c14ffa6d93dd97c17d04c8db163f500b7e" translate="yes" xml:space="preserve">
          <source>Append 'this' to the specific module members[]</source>
          <target state="translated">Añada &quot;esto&quot; a los miembros específicos del módulo[]</target>
        </trans-unit>
        <trans-unit id="e6389badcbed51133ce737118947b50567eac4a2" translate="yes" xml:space="preserve">
          <source>Append &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;&lt;code&gt;ch&lt;/code&gt; to this grapheme.</source>
          <target state="translated">A&amp;ntilde;ade el &lt;a href=&quot;#Character&quot;&gt;car&amp;aacute;cter &lt;/a&gt; &lt;code&gt;ch&lt;/code&gt; a este grafema.</target>
        </trans-unit>
        <trans-unit id="9423c656632feb94c95542550bc5776ab847c04f" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;e2&lt;/code&gt; to chain of exceptions that starts with &lt;code&gt;e1&lt;/code&gt;.</source>
          <target state="translated">Agregue &lt;code&gt;e2&lt;/code&gt; a la cadena de excepciones que comienza con &lt;code&gt;e1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3d06094350a95ba5b433011fb835e7124c4ec5e" translate="yes" xml:space="preserve">
          <source>Append a CData item to the interior of this element</source>
          <target state="translated">Añade un elemento CData al interior de este elemento</target>
        </trans-unit>
        <trans-unit id="984824e040f0720fce2fc4f6a13d57fc728e8caa" translate="yes" xml:space="preserve">
          <source>Append a comment to the interior of this element</source>
          <target state="translated">Añade un comentario al interior de este elemento</target>
        </trans-unit>
        <trans-unit id="db03388cd72ade8520d2e378966e698614e72a5e" translate="yes" xml:space="preserve">
          <source>Append a complete element to the interior of this element</source>
          <target state="translated">Agregar un elemento completo al interior de este elemento</target>
        </trans-unit>
        <trans-unit id="ef21e116b7bca07b0b591badb0bc081fdcfe67e5" translate="yes" xml:space="preserve">
          <source>Append a processing instruction to the interior of this element</source>
          <target state="translated">Añada una instrucción de procesamiento al interior de este elemento...</target>
        </trans-unit>
        <trans-unit id="496596976c04bde5f7e7a5a8202d7b8abe85e980" translate="yes" xml:space="preserve">
          <source>Append a text item to the interior of this element</source>
          <target state="translated">Añade un elemento de texto al interior de este elemento</target>
        </trans-unit>
        <trans-unit id="f6dd93a31eb85b0a74d513a784054a244ba3c76c" translate="yes" xml:space="preserve">
          <source>Append all &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; from the input range &lt;code&gt;inp&lt;/code&gt; to this Grapheme.</source>
          <target state="translated">Agregue todos los &lt;a href=&quot;#Character&quot;&gt;caracteres&lt;/a&gt; del rango de entrada &lt;code&gt;inp&lt;/code&gt; a este Grafema.</target>
        </trans-unit>
        <trans-unit id="34b47904d2988c2185d4a53f77f7d8e792a3291d" translate="yes" xml:space="preserve">
          <source>Append array &lt;code&gt;y&lt;/code&gt; to array &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Agregue la matriz &lt;code&gt;y&lt;/code&gt; a la matriz &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad6cd5314f128c12adc628c28aef59e004d422e0" translate="yes" xml:space="preserve">
          <source>Append data represented by ptr[0..size]</source>
          <target state="translated">Añada los datos representados por ptr[0..size]</target>
        </trans-unit>
        <trans-unit id="35f4f092745cbd38143bff7f25d5d2804e9a0623" translate="yes" xml:space="preserve">
          <source>Append data to the internal buffer.</source>
          <target state="translated">Añade datos al buffer interno.</target>
        </trans-unit>
        <trans-unit id="6cfc826c67159c690715f887f4b34b4df17e6673" translate="yes" xml:space="preserve">
          <source>Append dchar to char[]</source>
          <target state="translated">Añadir dchar a char[]</target>
        </trans-unit>
        <trans-unit id="b6ff7bb65433411731c9ec32fd03f8c8b7ab8dbf" translate="yes" xml:space="preserve">
          <source>Append dchar to wchar[]</source>
          <target state="translated">Añadir dchar a wchar[]</target>
        </trans-unit>
        <trans-unit id="f099c58d9143b4e0a6f01a50957762bf07adaa8f" translate="yes" xml:space="preserve">
          <source>Append dt to data.</source>
          <target state="translated">Añada el dt a los datos.</target>
        </trans-unit>
        <trans-unit id="73602dd98d646af114882b411baed4caf29ed4aa" translate="yes" xml:space="preserve">
          <source>Append dtb to data.</source>
          <target state="translated">Añada el dtb a los datos.</target>
        </trans-unit>
        <trans-unit id="05676aa51ec52e96deb89d7ae3b7bad0e2920095" translate="yes" xml:space="preserve">
          <source>Append instead of overwrite on upload!</source>
          <target state="translated">¡Añada en lugar de sobreescribir en la subida!</target>
        </trans-unit>
        <trans-unit id="725e2673bb64dd768f5e35adc33733f051daff12" translate="yes" xml:space="preserve">
          <source>Append integer item to list.</source>
          <target state="translated">Añada un elemento entero a la lista.</target>
        </trans-unit>
        <trans-unit id="8e98d78b75b667bfa9432c073969f89aad62837e" translate="yes" xml:space="preserve">
          <source>Append nbytes of 0 to the internal buffer.</source>
          <target state="translated">Añade nbytes de 0 al buffer interno.</target>
        </trans-unit>
        <trans-unit id="6100e49b257665109b21fcb575027c3b1d83fee9" translate="yes" xml:space="preserve">
          <source>Append output of C's printf() to internal buffer.</source>
          <target state="translated">Añade la salida de la impresión de C a la memoria interna.</target>
        </trans-unit>
        <trans-unit id="6f1cd15bde5d09d444835959bdf7cf1009a819c1" translate="yes" xml:space="preserve">
          <source>Append output of C's vprintf() to internal buffer.</source>
          <target state="translated">Añade la salida de C's vprintf()al buffer interno.</target>
        </trans-unit>
        <trans-unit id="26196f1c60516e313842646d760dfe092b0b8783" translate="yes" xml:space="preserve">
          <source>Append ptr to *plist.</source>
          <target state="translated">Añade el ptr a la *plista.</target>
        </trans-unit>
        <trans-unit id="379fc789872b087a61658c08353344a2820471c2" translate="yes" xml:space="preserve">
          <source>Append s to list of object files to generate later.</source>
          <target state="translated">Añade s a la lista de archivos de objetos que se generarán más tarde.</target>
        </trans-unit>
        <trans-unit id="7c74420521a423ce5daf955e234405a229d6cc0f" translate="yes" xml:space="preserve">
          <source>Append the remaining segments of &lt;code&gt;path&lt;/code&gt; to the string and return.</source>
          <target state="translated">Agregue los segmentos restantes de &lt;code&gt;path&lt;/code&gt; a la cadena y regrese.</target>
        </trans-unit>
        <trans-unit id="9e7e4b12820cee8e262b36441f586183f6d04cab" translate="yes" xml:space="preserve">
          <source>Append y[] to array x[]</source>
          <target state="translated">Añade y[]a la matriz x[]</target>
        </trans-unit>
        <trans-unit id="0ef306358b052f7e64b8bcc3cd14249cef33ca02" translate="yes" xml:space="preserve">
          <source>Appender!(E[]) &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A : E[], E)(auto ref A array);</source>
          <target state="translated">Appender! (E []) &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt; (A: E [], E) (auto ref A array);</target>
        </trans-unit>
        <trans-unit id="4e11e6991b83788f5357a19dc342f52d09507315" translate="yes" xml:space="preserve">
          <source>Appender!A &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt;(A)()</source>
          <target state="translated">Appender! A &lt;strong id=&quot;appender&quot;&gt;appender&lt;/strong&gt; (A) ()</target>
        </trans-unit>
        <trans-unit id="b06a35dce8dc5935a09578e40179d4dbbd0cee5e" translate="yes" xml:space="preserve">
          <source>Appending does not always create a copy, see &lt;a href=&quot;#resize&quot;&gt; setting dynamic array length&lt;/a&gt; for details.</source>
          <target state="translated">Agregar no siempre crea una copia; consulte la &lt;a href=&quot;#resize&quot;&gt;configuraci&amp;oacute;n de la longitud de la matriz din&amp;aacute;mica&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d23d95cfc1028cebc43e6d6bc87290142bad8a2a" translate="yes" xml:space="preserve">
          <source>Appending to and direct manipulation of grapheme's &lt;a href=&quot;#Character&quot;&gt;characters&lt;/a&gt; may render it no longer valid. Certain applications may chose to use Grapheme as a &quot;small string&quot; of any &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt; and ignore this property entirely.</source>
          <target state="translated">Agregar y manipular directamente a los &lt;a href=&quot;#Character&quot;&gt;personajes&lt;/a&gt; del grafema puede hacer que deje de ser v&amp;aacute;lido. Ciertas aplicaciones pueden optar por usar Grapheme como una &quot;peque&amp;ntilde;a cadena&quot; de cualquier punto de &lt;a href=&quot;#Code%20point&quot;&gt;c&amp;oacute;digo&lt;/a&gt; e ignorar esta propiedad por completo.</target>
        </trans-unit>
        <trans-unit id="27687e63c8f2765f7f45c656d25a88a2f70872d2" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;buffer&lt;/code&gt; to file &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Agrega &lt;code&gt;buffer&lt;/code&gt; al &lt;code&gt;name&lt;/code&gt; archivo .</target>
        </trans-unit>
        <trans-unit id="d7f62b12268c12952ecff14c3290b88618812066" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;item&lt;/code&gt; to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; types if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="translated">Agrega un &lt;code&gt;item&lt;/code&gt; a la matriz administrada. Realiza la codificaci&amp;oacute;n para &lt;code&gt;char&lt;/code&gt; tipos si &lt;code&gt;A&lt;/code&gt; es una forma diferente mecanografiado &lt;code&gt;char&lt;/code&gt; matriz.</target>
        </trans-unit>
        <trans-unit id="3fa391a5e33fe2002fc2b72cecadf723ca6b30fe" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;rhs&lt;/code&gt; to the managed array.</source>
          <target state="translated">Agrega &lt;code&gt;rhs&lt;/code&gt; a la matriz administrada.</target>
        </trans-unit>
        <trans-unit id="7623fabcaede88b964c04becc831d4ac3e3b23ce" translate="yes" xml:space="preserve">
          <source>Appends &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; may be a single element or an input range type.</source>
          <target state="translated">Anexa &lt;code&gt;x&lt;/code&gt; a &lt;code&gt;c&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; puede ser un solo elemento o un tipo de rango de entrada.</target>
        </trans-unit>
        <trans-unit id="18bc8e8710e112a386b8301eb1ea86dca70c5d37" translate="yes" xml:space="preserve">
          <source>Appends a string to a linked list. If no list exists, it will be created first. Returns the new list, after appending.</source>
          <target state="translated">Añade una cadena a una lista de enlaces.Si no existe ninguna lista,se creará primero.Devuelve la nueva lista,después de añadirla.</target>
        </trans-unit>
        <trans-unit id="81cdccb19773651976963e90237f5de77beaf9e6" translate="yes" xml:space="preserve">
          <source>Appends an entire range to the managed array. Performs encoding for &lt;code&gt;char&lt;/code&gt; elements if &lt;code&gt;A&lt;/code&gt; is a differently typed &lt;code&gt;char&lt;/code&gt; array.</source>
          <target state="translated">Agrega un rango completo a la matriz administrada. Realiza la codificaci&amp;oacute;n para &lt;code&gt;char&lt;/code&gt; elementos si &lt;code&gt;A&lt;/code&gt; es una forma diferente mecanografiado &lt;code&gt;char&lt;/code&gt; matriz.</target>
        </trans-unit>
        <trans-unit id="e1a17d68e5eb26669b8a6fd759bf09e863160e46" translate="yes" xml:space="preserve">
          <source>Appends the contents of the argument &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">Agrega los contenidos del argumento &lt;code&gt;rhs&lt;/code&gt; a &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20cd868cd32de230764914be80101e71a8f019d2" translate="yes" xml:space="preserve">
          <source>Appends to the managed array.</source>
          <target state="translated">Se añade a la matriz administrada.</target>
        </trans-unit>
        <trans-unit id="762f62942181d4b2666650e69bb8c92655c35501" translate="yes" xml:space="preserve">
          <source>AppleTalk</source>
          <target state="translated">AppleTalk</target>
        </trans-unit>
        <trans-unit id="82cac29a8ad5cbbc38d1a1fb84f536367b07a15f" translate="yes" xml:space="preserve">
          <source>Application Binary Interface</source>
          <target state="translated">Interfaz binaria de la aplicación</target>
        </trans-unit>
        <trans-unit id="8c42705eec7c415a6997bd8c9d3dc65da77e4f55" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache.</source>
          <target state="translated">Caché de página definido por la aplicación.</target>
        </trans-unit>
        <trans-unit id="a1097391b6d8c24e778f4782f5e62fadaf414d9d" translate="yes" xml:space="preserve">
          <source>Applies a delegate or function to the given &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; depending on the held type, ensuring that all types are handled by the visiting functions.</source>
          <target state="translated">Aplica un delegado o funci&amp;oacute;n al &lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; o&lt;/a&gt; dado dependiendo del tipo retenido, asegurando que todos los tipos sean manejados por las funciones de visita.</target>
        </trans-unit>
        <trans-unit id="2e64c5b4326d836829a0ebf41a9e13a5e62411c7" translate="yes" xml:space="preserve">
          <source>Apply MODxxxx bits to existing type.</source>
          <target state="translated">Aplicar los bits MODxxxx al tipo existente.</target>
        </trans-unit>
        <trans-unit id="ee985a3510121398e40860de4ace149b4869d63d" translate="yes" xml:space="preserve">
          <source>Apply STCxxxx bits to existing type. Use *before* semantic analysis is run.</source>
          <target state="translated">Aplicar los bits STCxxxx al tipo existente.Usar *antes*de que se ejecute el análisis semántico.</target>
        </trans-unit>
        <trans-unit id="a27c3d86d32e5ed828ae9b07fd5ad23ae9593843" translate="yes" xml:space="preserve">
          <source>Apply a function fp to each member of a list.</source>
          <target state="translated">Aplicar una función fp a cada miembro de una lista.</target>
        </trans-unit>
        <trans-unit id="5c98d8debd927a2a04375be8cb963231c736c4c5" translate="yes" xml:space="preserve">
          <source>Applying a qualifier to a type that already has that qualifier is legal but has no effect, e.g. given an unqualified type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;shared(const shared T)&lt;/code&gt; yields the type &lt;code&gt;const shared T&lt;/code&gt;.</source>
          <target state="translated">La aplicaci&amp;oacute;n de un calificador a un tipo que ya tiene ese calificativo es legal pero no tiene efecto, por ejemplo, dado un tipo sin reservas &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;shared(const shared T)&lt;/code&gt; se obtiene el tipo &lt;code&gt;const shared T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a15b638351f6a01ae8878d2186ac098d189b867" translate="yes" xml:space="preserve">
          <source>Applying the &lt;code&gt;immutable&lt;/code&gt; qualifier to any type (qualified or not) results in &lt;code&gt;immutable T&lt;/code&gt;. Applying any qualifier to &lt;code&gt;immutable T&lt;/code&gt; results in &lt;code&gt;immutable T&lt;/code&gt;. This makes &lt;code&gt;immutable&lt;/code&gt; a fixed point of qualifier combinations and makes types such as &lt;code&gt;const(immutable(shared T))&lt;/code&gt; impossible to create.</source>
          <target state="translated">La aplicaci&amp;oacute;n del calificador &lt;code&gt;immutable&lt;/code&gt; a cualquier tipo (calificado o no) da como resultado &lt;code&gt;immutable T&lt;/code&gt; . La aplicaci&amp;oacute;n de cualquier calificador a &lt;code&gt;immutable T&lt;/code&gt; da como resultado &lt;code&gt;immutable T&lt;/code&gt; . Esto hace que &lt;code&gt;immutable&lt;/code&gt; sea un punto fijo de las combinaciones de calificadores y hace que sea imposible crear tipos como &lt;code&gt;const(immutable(shared T))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="5e35d0b2742a654477e1cd63556f021113ce5b4c" translate="yes" xml:space="preserve">
          <source>Arabic Extended-A</source>
          <target state="translated">Árabe Extendido-A</target>
        </trans-unit>
        <trans-unit id="e2e75f0c9d3aecdda25899708775d147043e7830" translate="yes" xml:space="preserve">
          <source>Arabic Mathematical Alphabetic Symbols</source>
          <target state="translated">Símbolos alfabéticos matemáticos árabes</target>
        </trans-unit>
        <trans-unit id="1855677dcc7468bb9c8e6a1cd81ba79444a4ff7e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-A</source>
          <target state="translated">Formas de presentación en árabe-A</target>
        </trans-unit>
        <trans-unit id="81d80ec90565c460cb86314a7772144c7915e63e" translate="yes" xml:space="preserve">
          <source>Arabic Presentation Forms-B</source>
          <target state="translated">Formas de presentación en árabe-B</target>
        </trans-unit>
        <trans-unit id="f967001c1a34ccb5d4db68033cb95ea3afa4f067" translate="yes" xml:space="preserve">
          <source>Arabic Supplement</source>
          <target state="translated">Suplemento arábigo</target>
        </trans-unit>
        <trans-unit id="f984e10440745697cc3d65ba4c39e78b962f2e10" translate="yes" xml:space="preserve">
          <source>Arbitrary block of memory (&lt;code&gt;null&lt;/code&gt; is allowed; &lt;code&gt;owns(null)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">Bloque de memoria arbitrario ( se permite &lt;code&gt;null&lt;/code&gt; ; &lt;code&gt;owns(null)&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="35ae340d74ec660428a4617d592eb281817c9ae4" translate="yes" xml:space="preserve">
          <source>Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.</source>
          <target state="translated">Longitud y complejidad arbitrarias mirando hacia atrás,incluyendo el lookahead en el lookbehind y vise-versa.</target>
        </trans-unit>
        <trans-unit id="2b10f364535b59752b7187d9f87de14ac7b52ee5" translate="yes" xml:space="preserve">
          <source>Arbitrary-precision ('bignum') arithmetic.</source>
          <target state="translated">Aritmética de precisión arbitraria ('bignum').</target>
        </trans-unit>
        <trans-unit id="04a64131d2f2d9afe00e52e932f2410778390372" translate="yes" xml:space="preserve">
          <source>ArchiveMember &lt;code&gt;de&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fcbd049669bd8c4ed6c2c7a64ef6513f2e0d6d" translate="yes" xml:space="preserve">
          <source>Are AMD extensions to MMX supported?</source>
          <target state="translated">¿Son compatibles las extensiones de AMD para MMX?</target>
        </trans-unit>
        <trans-unit id="01e21616c01d0a2fca25a82b396c6f6e959a0c86" translate="yes" xml:space="preserve">
          <source>Are LAHF and SAHF supported in 64-bit mode?</source>
          <target state="translated">¿Son compatibles LAHF y SAHF en modo de 64 bits?</target>
        </trans-unit>
        <trans-unit id="3a1445e9d8e93be79bf26c9c6c4caa120500ae1a" translate="yes" xml:space="preserve">
          <source>Are any of the Objects an error?</source>
          <target state="translated">¿Alguno de los objetos es un error?</target>
        </trans-unit>
        <trans-unit id="4bf0024c4bc943f998126635e2b2826496ec8582" translate="yes" xml:space="preserve">
          <source>Args</source>
          <target state="translated">Args</target>
        </trans-unit>
        <trans-unit id="4293e4b957c97199f617f8492936758c0b738afa" translate="yes" xml:space="preserve">
          <source>Args &lt;code&gt;args&lt;/code&gt;</source>
          <target state="translated">Args &lt;code&gt;args&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f5be29a09e6e60319db52d529ad7515c16471a5" translate="yes" xml:space="preserve">
          <source>Argument Deduction</source>
          <target state="translated">Deducción del argumento</target>
        </trans-unit>
        <trans-unit id="54486629b7690ae513c392c789d163e099b5b87d" translate="yes" xml:space="preserve">
          <source>Argument Type</source>
          <target state="translated">Tipo de argumento</target>
        </trans-unit>
        <trans-unit id="29654984a9e906a0a06167995d3f42a8d08cf353" translate="yes" xml:space="preserve">
          <source>Argument to xInit() and xShutdown()</source>
          <target state="translated">Argumento para xInit()y xShutdown()</target>
        </trans-unit>
        <trans-unit id="daf86c8879ed0c69961403ceb76965c2482d6deb" translate="yes" xml:space="preserve">
          <source>ArgumentList</source>
          <target state="translated">ArgumentList</target>
        </trans-unit>
        <trans-unit id="8946712557cc8b1c3fb3e94fee0d0fce04b3802b" translate="yes" xml:space="preserve">
          <source>Arguments to pass to &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="translated">Argumentos para pasar al constructor de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfbc91d37e47f927568d7a30e3496cf96960cf08" translate="yes" xml:space="preserve">
          <source>Arguments to pass to the method.</source>
          <target state="translated">Argumentos para pasar al método.</target>
        </trans-unit>
        <trans-unit id="89180ef2e932b4599c798900639013ef3f341134" translate="yes" xml:space="preserve">
          <source>Arguments to the function.</source>
          <target state="translated">Argumentos para la función.</target>
        </trans-unit>
        <trans-unit id="cd64cf49b3ec9934a802f3e5622e652b8742e909" translate="yes" xml:space="preserve">
          <source>Arguments to variadic functions (such as &lt;code&gt;printf&lt;/code&gt;) are considered to be consumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9630a5d15efcdc7541a36a0160b3500004aba0a" translate="yes" xml:space="preserve">
          <source>Arithmetic between &lt;code&gt;VariantN&lt;/code&gt; objects and numeric values. All arithmetic operations return a &lt;code&gt;VariantN&lt;/code&gt; object typed depending on the types of both values involved. The conversion rules mimic D's built-in rules for arithmetic conversions.</source>
          <target state="translated">Aritm&amp;eacute;tica entre objetos &lt;code&gt;VariantN&lt;/code&gt; y valores num&amp;eacute;ricos. Todas las operaciones aritm&amp;eacute;ticas devuelven un objeto &lt;code&gt;VariantN&lt;/code&gt; escrito seg&amp;uacute;n los tipos de ambos valores involucrados. Las reglas de conversi&amp;oacute;n imitan las reglas integradas de D para las conversiones aritm&amp;eacute;ticas.</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="2c96bf3a668aac126792eaf02dadd14fa48e70d3" translate="yes" xml:space="preserve">
          <source>Array &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="translated">Array &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (string op, Stuff) (cosas de cosas)</target>
        </trans-unit>
        <trans-unit id="3660d1d1308b201f353bc8fa6130b29f9ba2d842" translate="yes" xml:space="preserve">
          <source>Array Bounds Checking</source>
          <target state="translated">Comprobación de los límites de la matriz</target>
        </trans-unit>
        <trans-unit id="1f1275d2846b1606eecf7847c7e27140c6dc6c89" translate="yes" xml:space="preserve">
          <source>Array Concatenation</source>
          <target state="translated">Concatenación de matrices</target>
        </trans-unit>
        <trans-unit id="5d1d05717fafa53ed33983c8c412c01fb3ca32f6" translate="yes" xml:space="preserve">
          <source>Array Copying</source>
          <target state="translated">Copia de la matriz</target>
        </trans-unit>
        <trans-unit id="0b0779db36c24b1c78ab44d3d32261e35d9bc05e" translate="yes" xml:space="preserve">
          <source>Array Declarations</source>
          <target state="translated">Declaraciones de la matriz</target>
        </trans-unit>
        <trans-unit id="83248d40160f2cce014335fe1581785cb6bcecaf" translate="yes" xml:space="preserve">
          <source>Array Index/Slice scope</source>
          <target state="translated">Índice de la matriz/alcance de los cortes</target>
        </trans-unit>
        <trans-unit id="4b91e23ca287553cadb09bb925d112bdb13a167e" translate="yes" xml:space="preserve">
          <source>Array Indexing and Slicing Operators Overloading</source>
          <target state="translated">Sobrecarga de los operadores de indexación y corte de matrices</target>
        </trans-unit>
        <trans-unit id="b3e061b1b0837d1a9960794f282dd75e750eb332" translate="yes" xml:space="preserve">
          <source>Array Initialization</source>
          <target state="translated">Inicialización de la matriz</target>
        </trans-unit>
        <trans-unit id="1c847e3a06bdc4135a7a456a0f00a984d2c67477" translate="yes" xml:space="preserve">
          <source>Array Length</source>
          <target state="translated">Longitud de la matriz</target>
        </trans-unit>
        <trans-unit id="f9f04b9d6c3b8a78da5ec9d06e0efef4332889f5" translate="yes" xml:space="preserve">
          <source>Array Literals</source>
          <target state="translated">Literales de Array</target>
        </trans-unit>
        <trans-unit id="7106a989ccb65a04eb4c26053be05ad2d2e071e2" translate="yes" xml:space="preserve">
          <source>Array Operations</source>
          <target state="translated">Operaciones de la matriz</target>
        </trans-unit>
        <trans-unit id="9d517d3c8494600360cbc4c90cee07bed4ba0d68" translate="yes" xml:space="preserve">
          <source>Array Properties</source>
          <target state="translated">Propiedades de la matriz</target>
        </trans-unit>
        <trans-unit id="9703b944aa367c5aa673c3d017ce64794e77b9b2" translate="yes" xml:space="preserve">
          <source>Array Setting</source>
          <target state="translated">Configuración de la matriz</target>
        </trans-unit>
        <trans-unit id="1aa037357a9b7f1c16ef42cc60976b8847ef657b" translate="yes" xml:space="preserve">
          <source>Array Usage</source>
          <target state="translated">Uso de la matriz</target>
        </trans-unit>
        <trans-unit id="c01b400578305839c9f204fb953e859a5125d529" translate="yes" xml:space="preserve">
          <source>Array and associative array operations. If a &lt;code&gt; VariantN&lt;/code&gt; contains an (associative) array, it can be indexed into. Otherwise, an exception is thrown.</source>
          <target state="translated">Matriz y operaciones de matriz asociativa. Si una &lt;code&gt; VariantN&lt;/code&gt; contiene una matriz (asociativa), se puede indexar en. De lo contrario, se lanza una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b84dfacc31a0969124c8d1abef734c629bb90a1e" translate="yes" xml:space="preserve">
          <source>Array appending</source>
          <target state="translated">Matriz de apéndices</target>
        </trans-unit>
        <trans-unit id="5d76be94dc9a7b58ca84dbb5c3adb93a7d01641c" translate="yes" xml:space="preserve">
          <source>Array bound checks.</source>
          <target state="translated">Controles de la matriz.</target>
        </trans-unit>
        <trans-unit id="85acbf2069ff740d2820da623cb0a7f96c951889" translate="yes" xml:space="preserve">
          <source>Array bounds checks are disabled (command line switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck=off&lt;/em&gt;&lt;/a&gt;)</source>
          <target state="translated">Las comprobaciones de l&amp;iacute;mites de matriz est&amp;aacute;n deshabilitadas (cambio de l&amp;iacute;nea de comando &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;em&gt;-boundscheck = off&lt;/em&gt;&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c9495b0030caddeaddd3d77aa9749a4ea64f6f7d" translate="yes" xml:space="preserve">
          <source>Array bounds checks are necessary to enforce memory safety, so these are enabled (by default) for &lt;code&gt;@safe&lt;/code&gt; code even in &lt;b&gt;-release&lt;/b&gt; mode.</source>
          <target state="translated">Las verificaciones de los l&amp;iacute;mites de la matriz son necesarias para reforzar la seguridad de la memoria, por lo que est&amp;aacute;n habilitadas (de forma predeterminada) para el c&amp;oacute;digo &lt;code&gt;@safe&lt;/code&gt; incluso en modo de &lt;b&gt;liberaci&amp;oacute;n&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cea52181688b642f5fdfd14c038de482c009d5f6" translate="yes" xml:space="preserve">
          <source>Array concatenation</source>
          <target state="translated">Concatenación de matrices</target>
        </trans-unit>
        <trans-unit id="57ff9464bbbd1fa1767e470a5012532b91719c42" translate="yes" xml:space="preserve">
          <source>Array container for internal usage.</source>
          <target state="translated">Contenedor de la matriz para uso interno.</target>
        </trans-unit>
        <trans-unit id="65a0b8da864827cd0478aba1fdf30610a77c4fd1" translate="yes" xml:space="preserve">
          <source>Array containing arrays that will be concatenated.</source>
          <target state="translated">Matrices que contienen matrices que se concatenarán.</target>
        </trans-unit>
        <trans-unit id="67d3696aeb8ef015e2952b35a392df743f65e443" translate="yes" xml:space="preserve">
          <source>Array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="translated">El literal de la matriz va a ser asignado en el montón de GC.Comprueba sus elementos para ver si alguno se escapa al ir al montón.</target>
        </trans-unit>
        <trans-unit id="014dbf281d4d372cf828b4f858f7eb383406da80" translate="yes" xml:space="preserve">
          <source>Array literals (except when used to initialize static data)</source>
          <target state="translated">Literales de la matriz (excepto cuando se usan para inicializar datos estáticos)</target>
        </trans-unit>
        <trans-unit id="f6a7d7c506c31a93cc6747b37be514d93fad8773" translate="yes" xml:space="preserve">
          <source>Array literals are a comma-separated list of &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;s between square brackets &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;. The</source>
          <target state="translated">Los literales de matriz son una lista separada por comas de &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; s entre corchetes &lt;code&gt;[&lt;/code&gt; y &lt;code&gt;]&lt;/code&gt; . los</target>
        </trans-unit>
        <trans-unit id="dae2c2b63d025ee4c0832bb31c33f2a5fbf34690" translate="yes" xml:space="preserve">
          <source>Array literals are allocated on the memory managed heap. Thus, they can be returned safely from functions:</source>
          <target state="translated">Los literales de la matriz se asignan en el montón de memoria administrada.Así,pueden ser devueltos de forma segura desde las funciones:</target>
        </trans-unit>
        <trans-unit id="e69b9d12c30731402c84433338297ab2257d2102" translate="yes" xml:space="preserve">
          <source>Array of VarDeclaration's for parameters</source>
          <target state="translated">Matriz de VarDeclaraciones para los parámetros</target>
        </trans-unit>
        <trans-unit id="5d9eb8f765adfc90b02ec28ca02924204c83af1e" translate="yes" xml:space="preserve">
          <source>Array of characters read.</source>
          <target state="translated">Matriz de caracteres leídos.</target>
        </trans-unit>
        <trans-unit id="1a234f4c4feb75a8aa7b93d09c3a8859c0ea7eb5" translate="yes" xml:space="preserve">
          <source>Array of pairs giving the offset and type information for each member in an aggregate.</source>
          <target state="translated">Matriz de pares que da la información de compensación y tipo para cada miembro en un agregado.</target>
        </trans-unit>
        <trans-unit id="3cc66155c78e1b4720002ac02361e391e42c1fdd" translate="yes" xml:space="preserve">
          <source>Array of the strings representing time units, starting with the smallest unit and going to the largest. It does not include &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt;.</source>
          <target state="translated">Matriz de las cadenas que representan unidades de tiempo, comenzando con la unidad m&amp;aacute;s peque&amp;ntilde;a y yendo a la m&amp;aacute;s grande. No incluye &lt;code&gt;&quot;nsecs&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c26e25fdec1370d18f0c93ee54cfd77f08bc7279" translate="yes" xml:space="preserve">
          <source>Array options.</source>
          <target state="translated">Opciones de arreglos.</target>
        </trans-unit>
        <trans-unit id="fecbe8e577ceb3d414c1005061daf3736c402d86" translate="yes" xml:space="preserve">
          <source>Array representing the entire archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268c73e26ed36171acb2987f7e489853cedee3f4" translate="yes" xml:space="preserve">
          <source>Array representing the entire contents of the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ee133059983d2093ca847eb799753d9f96eeef" translate="yes" xml:space="preserve">
          <source>Array slicing, and array bounds checking</source>
          <target state="translated">El corte de la matriz,y la comprobación de los límites de la matriz</target>
        </trans-unit>
        <trans-unit id="f187d73020c36a9ee259d3863cac2e2a8546f9fe" translate="yes" xml:space="preserve">
          <source>Array specialized for &lt;code&gt;bool&lt;/code&gt;. Packs together values efficiently by allocating one bit per element.</source>
          <target state="translated">Matriz especializada para &lt;code&gt;bool&lt;/code&gt; . Empaqueta valores de manera eficiente mediante la asignaci&amp;oacute;n de un bit por elemento.</target>
        </trans-unit>
        <trans-unit id="5058965ad79b9992b8f00aae6b40d9b43a8d0f10" translate="yes" xml:space="preserve">
          <source>Array syntax for json arrays.</source>
          <target state="translated">La sintaxis de los arreglos para los arreglos de Json.</target>
        </trans-unit>
        <trans-unit id="5973135baae02b17a741da0daeae795a22336d6f" translate="yes" xml:space="preserve">
          <source>Array to append the flags to, if any.</source>
          <target state="translated">Preparaos para añadir las banderas,si las hay.</target>
        </trans-unit>
        <trans-unit id="d290f86768d5ed39f7a46e3545ef125df15763f2" translate="yes" xml:space="preserve">
          <source>Array to which binaries (shared/static libs and object files) will be appended</source>
          <target state="translated">Matriz a la que se añadirán binarios (liberaciones compartidas/estáticas y archivos de objetos)</target>
        </trans-unit>
        <trans-unit id="c59fb5bcd382383b02c6f2e682a6e49d5169c774" translate="yes" xml:space="preserve">
          <source>Array type with deterministic control of memory. The memory allocated for the array is reclaimed as soon as possible; there is no reliance on the garbage collector. &lt;code&gt;Array&lt;/code&gt; uses &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt; and &lt;code&gt;free&lt;/code&gt; for managing its own memory.</source>
          <target state="translated">Tipo de matriz con control determinista de la memoria. La memoria asignada para la matriz se recupera lo antes posible; no se depende del recolector de basura. &lt;code&gt;Array&lt;/code&gt; usa &lt;code&gt;malloc&lt;/code&gt; , &lt;code&gt;realloc&lt;/code&gt; y &lt;code&gt;free&lt;/code&gt; para administrar su propia memoria.</target>
        </trans-unit>
        <trans-unit id="17f3d834c909f91543323d2da6d7e392df7fc04d" translate="yes" xml:space="preserve">
          <source>Array utilities.</source>
          <target state="translated">Arriba de las utilidades.</target>
        </trans-unit>
        <trans-unit id="d8d1c5f297e5b542d7b3b426ee67519393b84051" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;Address&lt;/code&gt; instance per socket address.</source>
          <target state="translated">Matriz con una instancia de &lt;code&gt;Address&lt;/code&gt; por direcci&amp;oacute;n de socket.</target>
        </trans-unit>
        <trans-unit id="7b02c75e5cfd1dbb8861cc9d33aefc7788debf27" translate="yes" xml:space="preserve">
          <source>Array with one &lt;code&gt;AddressInfo&lt;/code&gt; per socket address.</source>
          <target state="translated">Matriz con una &lt;code&gt;AddressInfo&lt;/code&gt; por direcci&amp;oacute;n de socket.</target>
        </trans-unit>
        <trans-unit id="ccb9694106595867500e36f178956e556d5f06d5" translate="yes" xml:space="preserve">
          <source>Array!T &lt;code&gt;array&lt;/code&gt;</source>
          <target state="translated">Array! T &lt;code&gt;array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59ed81f06d61cee7ac46ef81d4494047f843a918" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt;(string op, Stuff)(Stuff rhs)</source>
          <target state="translated">Array! Bool &lt;strong id=&quot;opBinary&quot;&gt;opBinary&lt;/strong&gt; (string op, Stuff) (Stuff rhs)</target>
        </trans-unit>
        <trans-unit id="f58b7e3beff7cb376f330022b72abdbf5e8d71a8" translate="yes" xml:space="preserve">
          <source>Array!bool &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt;(string op, Stuff)(Stuff stuff)</source>
          <target state="translated">Array! Bool &lt;strong id=&quot;opOpAssign&quot;&gt;opOpAssign&lt;/strong&gt; (string op, Stuff) (Stuff stuff)</target>
        </trans-unit>
        <trans-unit id="fb8a70fa9de0823f16fd95fb5d95b4122c80f726" translate="yes" xml:space="preserve">
          <source>ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</source>
          <target state="translated">ArrayInitializer &lt;code&gt;ai&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcde65a6ef36678480c533ad205a2b3653940979" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="translated">ArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49604b859f9dbf7987784da7c49e4b4f67d157a7" translate="yes" xml:space="preserve">
          <source>ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt;(UnionExp* pue, ref const Loc loc, Type type, Expression elem, size_t dim);</source>
          <target state="translated">ArrayLiteralExp &lt;strong id=&quot;createBlockDuplicatedArrayLiteral&quot;&gt;createBlockDuplicatedArrayLiteral&lt;/strong&gt; (UnionExp * pue, ref const Loc loc, Type type, Expression elem, size_t dim);</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="5ec121f807ed23a3ee478e2902d2a39d93f6938e" translate="yes" xml:space="preserve">
          <source>Arrays (dynamic and static)</source>
          <target state="translated">Matrices (dinámicas y estáticas)</target>
        </trans-unit>
        <trans-unit id="dad86d2f90fcf8d8a3cdfa4cf789d731af0dd940" translate="yes" xml:space="preserve">
          <source>Arrays and static arrays</source>
          <target state="translated">Matrices y matrices estáticas</target>
        </trans-unit>
        <trans-unit id="1f1d0899c823da5c8626a1dbb08800ddf6eec849" translate="yes" xml:space="preserve">
          <source>Arrays of any type can be implicitly converted to a void array; the compiler inserts the appropriate calculations so that the &lt;code&gt;.length&lt;/code&gt; of the resulting array's size is in bytes rather than number of elements. Void arrays cannot be converted back to the original type without using a cast, and it is an error to convert to an array type whose element size does not evenly divide the length of the void array.</source>
          <target state="translated">Las matrices de cualquier tipo pueden convertirse impl&amp;iacute;citamente en una matriz vac&amp;iacute;a; el compilador inserta los c&amp;aacute;lculos apropiados para que la &lt;code&gt;.length&lt;/code&gt; del tama&amp;ntilde;o de la matriz resultante sea en bytes en lugar de en n&amp;uacute;mero de elementos. Las matrices vac&amp;iacute;as no se pueden convertir de nuevo al tipo original sin usar una conversi&amp;oacute;n, y es un error convertirlas en un tipo de matriz cuyo tama&amp;ntilde;o de elemento no divida uniformemente la longitud de la matriz vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="d07335e1b59b41b81acffb9c1b5c94e2033e5ab4" translate="yes" xml:space="preserve">
          <source>Arrays read right to left as well:</source>
          <target state="translated">Las matrices se leen de derecha a izquierda también:</target>
        </trans-unit>
        <trans-unit id="0cf604cb001bdc6112fda3affb0c7674d1c4481b" translate="yes" xml:space="preserve">
          <source>Arrows</source>
          <target state="translated">Arrows</target>
        </trans-unit>
        <trans-unit id="ebe044f5962ca7b8d7aab096e7aee2bc2b61b686" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;static foreach&lt;/code&gt; is a code generation construct and not a loop, &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; cannot be used to change control flow within it. Instead of breaking or continuing a suitable enclosing statement, such an usage yields an error (this is to prevent misunderstandings).</source>
          <target state="translated">Como &lt;code&gt;static foreach&lt;/code&gt; es una construcci&amp;oacute;n de generaci&amp;oacute;n de c&amp;oacute;digo y no un bucle, &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; no se puede usar para cambiar el flujo de control dentro de &amp;eacute;l. En lugar de romper o continuar una declaraci&amp;oacute;n adjunta adecuada, tal uso produce un error (esto es para evitar malentendidos).</target>
        </trans-unit>
        <trans-unit id="8fe64c824a70f2fd7f91ffe1f685564777c5e63c" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;scope&lt;/code&gt; parameter must not escape, the compiler can potentially avoid heap-allocating a unique argument to a &lt;code&gt;scope&lt;/code&gt; parameter. Due to this, passing an array literal, delegate literal or a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt; to a scope parameter may be allowed in a &lt;code&gt;@nogc&lt;/code&gt; context, depending on the compiler implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d13756a62d354c00bff64fd46fa593358676140" translate="yes" xml:space="preserve">
          <source>As a concession to practicality, a pure function can also:</source>
          <target state="translated">Como una concesión a la practicidad,una función pura también puede:</target>
        </trans-unit>
        <trans-unit id="8bc155ad0d18590ebe40ebe2b93eb23941ceadd8" translate="yes" xml:space="preserve">
          <source>As a contract, an &lt;code&gt;assert&lt;/code&gt; represents a guarantee that the code</source>
          <target state="translated">Como contrato, una &lt;code&gt;assert&lt;/code&gt; representa una garant&amp;iacute;a de que el c&amp;oacute;digo</target>
        </trans-unit>
        <trans-unit id="bccab5f9b93fd641ceebcd69566613681ff777b0" translate="yes" xml:space="preserve">
          <source>As a debugging aid, the compiler may insert a runtime check to verify that the expression is indeed true. If it is false, an &lt;code&gt;AssertError&lt;/code&gt; is thrown. When compiling for release, this check is not generated. The special &lt;code&gt;assert(0)&lt;/code&gt; expression, however, is generated even in release mode. See the &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; documentation for more information.</source>
          <target state="translated">Como ayuda para la depuraci&amp;oacute;n, el compilador puede insertar una verificaci&amp;oacute;n de tiempo de ejecuci&amp;oacute;n para verificar que la expresi&amp;oacute;n es realmente verdadera. Si es falso, se lanza un &lt;code&gt;AssertError&lt;/code&gt; . Al compilar para el lanzamiento, esta verificaci&amp;oacute;n no se genera. La expresi&amp;oacute;n especial &lt;code&gt;assert(0)&lt;/code&gt; , sin embargo, se genera incluso en modo de liberaci&amp;oacute;n. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;expression#AssertExpression&quot;&gt;&lt;i&gt;AssertExpression&lt;/i&gt;&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="90a896ea477e7a62fdbd266c90ef3478e166538a" translate="yes" xml:space="preserve">
          <source>As a micro-optimization, to avoid the heap allocation associated with &lt;code&gt;task&lt;/code&gt; or with the creation of a closure.</source>
          <target state="translated">Como una microoptimizaci&amp;oacute;n, para evitar la asignaci&amp;oacute;n del mont&amp;oacute;n asociada con la &lt;code&gt;task&lt;/code&gt; o con la creaci&amp;oacute;n de un cierre.</target>
        </trans-unit>
        <trans-unit id="842753f613e1812047f79b9da908210026f9a41f" translate="yes" xml:space="preserve">
          <source>As above, but also provides &lt;code&gt;back&lt;/code&gt; and &lt;code&gt;popBack&lt;/code&gt;.</source>
          <target state="translated">Como arriba, pero tambi&amp;eacute;n proporciona &lt;code&gt;back&lt;/code&gt; y &lt;code&gt;popBack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a95b268782f9af6c10edd99d4e3bb5baafff0eb" translate="yes" xml:space="preserve">
          <source>As above, but may be reallocated later. Examples of types fitting this description are &lt;code&gt;int[]&lt;/code&gt;, &lt;code&gt;double[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt;, but not &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;, which contains an indirection.</source>
          <target state="translated">Como arriba, pero puede reasignarse m&amp;aacute;s tarde. Ejemplos de tipos que se ajustan a esta descripci&amp;oacute;n son &lt;code&gt;int[]&lt;/code&gt; , &lt;code&gt;double[]&lt;/code&gt; , &lt;code&gt;Tuple!(int, long)[]&lt;/code&gt; , pero no &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt; , que contiene una indirecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ada3120f9cc1043d7b4f9c611d3e84f82bcb254e" translate="yes" xml:space="preserve">
          <source>As above, but may embed indirections. Examples of types fitting this description are &lt;code&gt;int*[]&lt;/code&gt;, &lt;code&gt;Object[]&lt;/code&gt;, &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt;.</source>
          <target state="translated">Como arriba, pero puede incorporar indirecciones. Ejemplos de tipos que se ajustan a esta descripci&amp;oacute;n son &lt;code&gt;int*[]&lt;/code&gt; , &lt;code&gt;Object[]&lt;/code&gt; , &lt;code&gt;Tuple!(int, string)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1700838138f9af03c11ccaa20b548dd32d2a5c61" translate="yes" xml:space="preserve">
          <source>As above, but the memory allocated is aligned at &lt;code&gt;a&lt;/code&gt; bytes.</source>
          <target state="translated">Como arriba, pero la memoria asignada se alinea en &lt;code&gt;a&lt;/code&gt; bytes.</target>
        </trans-unit>
        <trans-unit id="9a7b2b5d58503b9d84dce03ccae75f857fd6475e" translate="yes" xml:space="preserve">
          <source>As above, but the type may be appended to in the future. Example: &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Como arriba, pero el tipo puede agregarse en el futuro. Ejemplo: &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67b44aad993023067b75a99b577d6a3bad9df809" translate="yes" xml:space="preserve">
          <source>As above, but the type may embed references. Example: &lt;code&gt;immutable(Object)[]&lt;/code&gt;.</source>
          <target state="translated">Como arriba, pero el tipo puede incluir referencias. Ejemplo: &lt;code&gt;immutable(Object)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0ab111de9460a5c459418af453cc0583e8938ad" translate="yes" xml:space="preserve">
          <source>As an exception to the above, curl_off_t shall be typedef'ed to a 32-bit wide signed integral data type if there is no 64-bit type.</source>
          <target state="translated">Como excepción a lo anterior,curl_off_t se tipificará como un tipo de datos integral con signo de 32 bits de ancho si no hay un tipo de 64 bits.</target>
        </trans-unit>
        <trans-unit id="00c376f2504564e95535f66220527b7aef723e32" translate="yes" xml:space="preserve">
          <source>As copying the range means copying all elements, it can be safely returned from functions. For the same reason, copying the returned range may be expensive for a large number of arguments.</source>
          <target state="translated">Como copiar el rango significa copiar todos los elementos,puede ser devuelto con seguridad de las funciones.Por la misma razón,copiar el rango devuelto puede ser costoso por un gran número de argumentos.</target>
        </trans-unit>
        <trans-unit id="86ffd7c99fd994cc802f084df86d92e7d718ebb0" translate="yes" xml:space="preserve">
          <source>As long as the target range elements support assignment from source range elements, different types of ranges are accepted:</source>
          <target state="translated">Siempre y cuando los elementos del rango objetivo apoyen la asignación de los elementos del rango fuente,se aceptan diferentes tipos de rangos:</target>
        </trans-unit>
        <trans-unit id="89f24648855e3c77be3def51419022b8377886d0" translate="yes" xml:space="preserve">
          <source>As of this time, &lt;code&gt;std.experimental.allocator&lt;/code&gt; is not integrated with D's built-in operators that allocate memory, such as &lt;code&gt;new&lt;/code&gt;, array literals, or array concatenation operators. That means &lt;code&gt;std.experimental.allocator&lt;/code&gt; is opt-in</source>
          <target state="translated">A partir de este momento, &lt;code&gt;std.experimental.allocator&lt;/code&gt; no est&amp;aacute; integrado con los operadores integrados de D que asignan memoria, como los &lt;code&gt;new&lt;/code&gt; , literales de matriz u operadores de concatenaci&amp;oacute;n de matriz. Eso significa que &lt;code&gt;std.experimental.allocator&lt;/code&gt; es opt-in</target>
        </trans-unit>
        <trans-unit id="7b1738337554a47ddb128a4a9aaf14cc6fec9d90" translate="yes" xml:space="preserve">
          <source>As some GC implementations (such as the current conservative one) don't support GC memory allocation during object finalization, this function can be used to guard against such programming errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102c86647896232382d7c6363a032a8965f35f84" translate="yes" xml:space="preserve">
          <source>As the above example shows, a different compile-time argument is passed to &lt;code&gt;opDollar&lt;/code&gt; depending on which argument it appears in. A &lt;code&gt;$&lt;/code&gt; appearing in the first argument gets translated to &lt;code&gt;opDollar!0&lt;/code&gt;, a &lt;code&gt;$&lt;/code&gt; appearing in the second argument gets translated to &lt;code&gt;opDollar!1&lt;/code&gt;, and so on. Thus, the appropriate value for &lt;code&gt;$&lt;/code&gt; can be returned to implement multidimensional arrays.</source>
          <target state="translated">Como muestra el ejemplo anterior, se pasa un argumento de tiempo de compilaci&amp;oacute;n diferente a &lt;code&gt;opDollar&lt;/code&gt; dependiendo del argumento en el que aparezca. &amp;iexcl;Un &lt;code&gt;$&lt;/code&gt; que aparece en el primer argumento se traduce a &lt;code&gt;opDollar!0&lt;/code&gt; , un &lt;code&gt;$&lt;/code&gt; que aparece en el segundo argumento se traduce a &lt;code&gt;opDollar!1&lt;/code&gt; , y as&amp;iacute; sucesivamente. Por lo tanto, el valor apropiado para &lt;code&gt;$&lt;/code&gt; se puede devolver para implementar matrices multidimensionales.</target>
        </trans-unit>
        <trans-unit id="6f1f55e4d756cae86481e151850fb4d8b6d4d597" translate="yes" xml:space="preserve">
          <source>As the interval goes to negative infinity, the range is always iterated over backwards, never forwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be earlier in time than the one passed to it. If it's either identical or later in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">A medida que el intervalo va al infinito negativo, el rango siempre se repite hacia atr&amp;aacute;s, nunca hacia adelante. &lt;code&gt;func&lt;/code&gt; debe generar un punto de tiempo en la direcci&amp;oacute;n correcta de iteraci&amp;oacute;n, o se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException . Por lo tanto, los puntos de tiempo que genera &lt;code&gt;func&lt;/code&gt; deben ser anteriores al tiempo que le pas&amp;oacute;. Si es id&amp;eacute;ntico o m&amp;aacute;s tarde en el tiempo, se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una std.datetime.date.DateTimeException .</target>
        </trans-unit>
        <trans-unit id="19397d297232fda90f291340ee30b5e3c1ea48c9" translate="yes" xml:space="preserve">
          <source>As the interval goes to positive infinity, the range is always iterated over forwards, never backwards. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, the time points that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">A medida que el intervalo llega al infinito positivo, el rango siempre se repite hacia adelante, nunca hacia atr&amp;aacute;s. &lt;code&gt;func&lt;/code&gt; debe generar un punto de tiempo en la direcci&amp;oacute;n correcta de iteraci&amp;oacute;n, o se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException . Por lo tanto, los puntos de tiempo que genera &lt;code&gt;func&lt;/code&gt; deben ser m&amp;aacute;s tarde que el que le pas&amp;oacute;. Si es id&amp;eacute;ntico o anterior en el tiempo, se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una std.datetime.date.DateTimeException .</target>
        </trans-unit>
        <trans-unit id="80d4a16f3b080b8168646190c746d43efc570fe1" translate="yes" xml:space="preserve">
          <source>As this module is used for diagnostic, it should handle failures as gracefully as possible. Having the runtime error out on printing the stack trace one is trying to debug would be quite a terrible UX. For this reason, this module works on a &quot;best effort&quot; basis and will sometimes print mangled symbols, or &quot;???&quot; when it cannot do anything more useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85319de6635b6d77d85a430a22ed2839720cedf1" translate="yes" xml:space="preserve">
          <source>As we generate code, collect information about what parts of NT exception handling we need.</source>
          <target state="translated">A medida que generamos el código,recogemos información sobre qué partes del manejo de excepciones de la NT necesitamos.</target>
        </trans-unit>
        <trans-unit id="51268903c8fb9b838b2eb55d7979a33593c37355" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#lists&quot;&gt;lists&lt;/a&gt;, note that the initial &lt;code&gt;*&lt;/code&gt; in the example above will be stripped because it is part of a documentation comment that is delimited with asterisks, so you need at least three subsequent asterisks.</source>
          <target state="translated">Al igual que con las &lt;a href=&quot;#lists&quot;&gt;listas&lt;/a&gt; , tenga en cuenta que el &lt;code&gt;*&lt;/code&gt; inicial en el ejemplo anterior se eliminar&amp;aacute; porque es parte de un comentario de documentaci&amp;oacute;n que est&amp;aacute; delimitado con asteriscos, por lo que necesita al menos tres asteriscos posteriores.</target>
        </trans-unit>
        <trans-unit id="ac7e95e21d2700c2e5e4f32e9e7f466df23faf33" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#replaceAll&quot;&gt;&lt;code&gt;replaceAll&lt;/code&gt;&lt;/a&gt; there are 2 overloads - one with a format string, the other one with a user defined functor.</source>
          <target state="translated">Al igual que &lt;a href=&quot;#replaceAll&quot;&gt; &lt;code&gt;replaceAll&lt;/code&gt; ,&lt;/a&gt; hay 2 sobrecargas: una con una cadena de formato y la otra con un functor definido por el usuario.</target>
        </trans-unit>
        <trans-unit id="4799d67b11d550709cf6847100b2162c1067dd7e" translate="yes" xml:space="preserve">
          <source>As with any global resource, setting &lt;code&gt;theAllocator&lt;/code&gt; and &lt;code&gt;processAllocator&lt;/code&gt; should not be done often and casually. In particular, allocating memory with one allocator and deallocating with another causes undefined behavior. Typically, these variables are set during application initialization phase and last through the application.  To avoid this, long-lived objects that need to perform allocations, reallocations, and deallocations relatively often may want to store a reference to the allocator object they use throughout their lifetime. Then, instead of using &lt;code&gt;theAllocator&lt;/code&gt; for internal allocation-related tasks, they'd use the internally held reference. For example, consider a user-defined hash table:</source>
          <target state="translated">Al igual que con cualquier recurso global, la configuraci&amp;oacute;n de &lt;code&gt;theAllocator&lt;/code&gt; y &lt;code&gt;processAllocator&lt;/code&gt; no se debe hacer de manera frecuente y casual. En particular, asignar memoria con un asignador y desasignar con otro causa un comportamiento indefinido. Por lo general, estas variables se establecen durante la fase de inicializaci&amp;oacute;n de la aplicaci&amp;oacute;n y duran hasta la aplicaci&amp;oacute;n. Para evitar esto, los objetos de larga duraci&amp;oacute;n que necesitan realizar asignaciones, reasignaciones y desasignaciones con relativa frecuencia pueden querer almacenar una referencia al objeto asignador que usan a lo largo de su vida &amp;uacute;til. Luego, en lugar de usar el &lt;code&gt;theAllocator&lt;/code&gt; para tareas relacionadas con la asignaci&amp;oacute;n interna, usar&amp;iacute;an la referencia interna. Por ejemplo, considere una tabla hash definida por el usuario:</target>
        </trans-unit>
        <trans-unit id="a187fce74f3c088795c6e5b47e1056e5126c0fae" translate="yes" xml:space="preserve">
          <source>Ask curl for its fd_set sets. The app can use these to select() or poll() on. We want curl_multi_perform() called as soon as one of them are ready.</source>
          <target state="translated">Pídele a Curl sus juegos de fd_set.La aplicación puede usarlos para seleccionar()o hacer una encuesta()sobre.Queremos que curl_multi_perform()sea llamado tan pronto como uno de ellos esté listo.</target>
        </trans-unit>
        <trans-unit id="407c3cb45f2c60add113bb40a5a457b3e7b28548" translate="yes" xml:space="preserve">
          <source>Ask the multi handle if there's any messages/informationals from the individual transfers. Messages include informationals such as error code from the transfer or just the fact that a transfer is completed. More details on these should be written down as well.</source>
          <target state="translated">Pregunte en el multi-manipulador si hay algún mensaje/información de las transferencias individuales.Los mensajes incluyen información como el código de error de la transferencia o simplemente el hecho de que la transferencia se ha completado.También se deben anotar más detalles sobre estos.</target>
        </trans-unit>
        <trans-unit id="00a0f49dff6a5c0c910755166ec70967a98d46e8" translate="yes" xml:space="preserve">
          <source>Asm Statement</source>
          <target state="translated">Declaración de Asm</target>
        </trans-unit>
        <trans-unit id="1afc7a2cc88dee030813b66323a3af633b890e22" translate="yes" xml:space="preserve">
          <source>Asm instruction</source>
          <target state="translated">Instrucción de Asm</target>
        </trans-unit>
        <trans-unit id="790208a1b6c1cdd2c13b57adc90b509e7d203c6c" translate="yes" xml:space="preserve">
          <source>Asm instructions are terminated by a ;, not by an end of line.</source>
          <target state="translated">Las instrucciones de Asm terminan con un ;,no con un final de línea.</target>
        </trans-unit>
        <trans-unit id="8a7e3825909e47cd662a1349cd9c1f9bb88f142c" translate="yes" xml:space="preserve">
          <source>Asm statement</source>
          <target state="translated">Declaración de Asm</target>
        </trans-unit>
        <trans-unit id="90e6cfa22a58ec4314abe99303529bc30df1cd45" translate="yes" xml:space="preserve">
          <source>AsmStatement</source>
          <target state="translated">AsmStatement</target>
        </trans-unit>
        <trans-unit id="7c9be4e0207ca69f4c35ec2cd41e7f07aef7a2ef" translate="yes" xml:space="preserve">
          <source>Assemble &lt;code&gt;values&lt;/code&gt; into a range that carries all its elements in-situ.</source>
          <target state="translated">Ensamble los &lt;code&gt;values&lt;/code&gt; en un rango que lleve todos sus elementos in situ.</target>
        </trans-unit>
        <trans-unit id="c617a006ef306c30de2e4c3a12d2334fbba7a9af" translate="yes" xml:space="preserve">
          <source>Assembler instructions can be labeled just like other statements. They can be the target of goto statements. For example:</source>
          <target state="translated">Las instrucciones de montaje pueden ser etiquetadas como otras declaraciones.Pueden ser el objetivo de las declaraciones de goto.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e421bc1f45d2b482fe2ff716000545e5646f7277" translate="yes" xml:space="preserve">
          <source>Assembler instructions must be located inside an &lt;code&gt;asm&lt;/code&gt; block. Like functions, &lt;code&gt;asm&lt;/code&gt; statements must be anotated with adequate function attributes to be compatible with the caller. Asm statements attributes must be explicitly defined, they are not infered.</source>
          <target state="translated">Las instrucciones del ensamblador deben ubicarse dentro de un bloque &lt;code&gt;asm&lt;/code&gt; . Al igual que las funciones, las declaraciones &lt;code&gt;asm&lt;/code&gt; se deben anotar con atributos de funci&amp;oacute;n adecuados para ser compatibles con el llamador. Los atributos de las declaraciones asm deben definirse expl&amp;iacute;citamente, no se infieren.</target>
        </trans-unit>
        <trans-unit id="714e45eb8c405fbdb34a796120ab67c6ae2d72b9" translate="yes" xml:space="preserve">
          <source>Assembling Your Own Allocator</source>
          <target state="translated">Ensamblando su propio asignador</target>
        </trans-unit>
        <trans-unit id="b52465945f6ab45ca943fa9fa1e9d738eca2cc3b" translate="yes" xml:space="preserve">
          <source>Assert Contract</source>
          <target state="translated">Afirmar el contrato</target>
        </trans-unit>
        <trans-unit id="881c910749065a58abd709f4221af38a82fabadc" translate="yes" xml:space="preserve">
          <source>Assert Expressions</source>
          <target state="translated">Expresiones de afirmación</target>
        </trans-unit>
        <trans-unit id="c7a5b9464524d049c6fe8ff66c5b2bdc7b543fff" translate="yes" xml:space="preserve">
          <source>Assert Failure</source>
          <target state="translated">Afirmar el fracaso</target>
        </trans-unit>
        <trans-unit id="d7d72241e6b5848e305187f74df13930409f541f" translate="yes" xml:space="preserve">
          <source>Assert checks.</source>
          <target state="translated">Afirmar los controles.</target>
        </trans-unit>
        <trans-unit id="843aa1baaf4b9511699ef763eb98fe79f5099f70" translate="yes" xml:space="preserve">
          <source>Assert failure functions in the GLIBC library.</source>
          <target state="translated">Afirmar las funciones de fallo en la biblioteca de la GLIBC.</target>
        </trans-unit>
        <trans-unit id="94e6ce29a6460dbe0c0daaaab648acdb3c2883d7" translate="yes" xml:space="preserve">
          <source>AssertExpression</source>
          <target state="translated">AssertExpression</target>
        </trans-unit>
        <trans-unit id="a422512dc44cc15063776e77a81a3f8e6eb0d6de" translate="yes" xml:space="preserve">
          <source>AssertExpressions</source>
          <target state="translated">AssertExpressions</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="2f19e0385b8f9d7c5a7eb86bb2c7ba5f0e720900" translate="yes" xml:space="preserve">
          <source>Asserts that the given condition is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Afirma que la condici&amp;oacute;n dada es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="120daecc558f73b157187685546d1c314c351c50" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression does</source>
          <target state="translated">Afirma que la expresión dada hace</target>
        </trans-unit>
        <trans-unit id="bba2525f9e139559b132642a96447978bab43209" translate="yes" xml:space="preserve">
          <source>Asserts that the given expression throws the given type of &lt;code&gt;Throwable&lt;/code&gt;. The &lt;code&gt;Throwable&lt;/code&gt; is caught and does not escape assertThrown. However, any other &lt;code&gt;Throwable&lt;/code&gt;s</source>
          <target state="translated">Afirma que la expresi&amp;oacute;n dada arroja el tipo dado de &lt;code&gt;Throwable&lt;/code&gt; . El &lt;code&gt;Throwable&lt;/code&gt; es atrapado y no escapa de afirmaci&amp;oacute;n. Sin embargo, cualquier otro s &lt;code&gt;Throwable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17e81c7a1f671e7e24608f38c1a74f6ff4e02c7b" translate="yes" xml:space="preserve">
          <source>Assign Expressions</source>
          <target state="translated">Asignar expresiones</target>
        </trans-unit>
        <trans-unit id="7f86ed464704ba1c6b681ec2726c5fbeefb20008" translate="yes" xml:space="preserve">
          <source>Assign a value to the current thread's instance. This function has the same caveats as its overload.</source>
          <target state="translated">Asigna un valor a la instancia del hilo actual.Esta función tiene las mismas advertencias que su sobrecarga.</target>
        </trans-unit>
        <trans-unit id="76d3ba357057c554bcbcf6a7822d736c1e09e3bc" translate="yes" xml:space="preserve">
          <source>AssignExpression</source>
          <target state="translated">AssignExpression</target>
        </trans-unit>
        <trans-unit id="365e967e191a82b0dfa667724d9ef332e0565a97" translate="yes" xml:space="preserve">
          <source>Assigned to each element of range</source>
          <target state="translated">Asignado a cada elemento del rango</target>
        </trans-unit>
        <trans-unit id="2490af57d4237289ce473c7f9d5d5a7e29bbba7a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Expressions</source>
          <target state="translated">Expresiones del Operador de Asignación</target>
        </trans-unit>
        <trans-unit id="eda4293e36885d0479c5dae22502b3085be9643a" translate="yes" xml:space="preserve">
          <source>Assignment Operator Overloading</source>
          <target state="translated">Sobrecarga del Operador de Asignación</target>
        </trans-unit>
        <trans-unit id="3bf524ec3b928fa7a8316d5c4f46f6427bafeb2e" translate="yes" xml:space="preserve">
          <source>Assignment from another &lt;code&gt;Tuple&lt;/code&gt;.</source>
          <target state="translated">Asignaci&amp;oacute;n de otra &lt;code&gt;Tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad22a9ad0d4f785e89bbd9df67b80efd310fb186" translate="yes" xml:space="preserve">
          <source>Assignment from another BigInt.</source>
          <target state="translated">Asignación de otro BigInt.</target>
        </trans-unit>
        <trans-unit id="c734c417d0433b21b0c33224a47f994821944ee9" translate="yes" xml:space="preserve">
          <source>Assignment from built-in integer types.</source>
          <target state="translated">Asignación de tipos enteros incorporados.</target>
        </trans-unit>
        <trans-unit id="a2c6b545c0015432c32a5f8afe451255b5b743ef" translate="yes" xml:space="preserve">
          <source>Assignment helper functions</source>
          <target state="translated">Funciones de ayuda a la asignación</target>
        </trans-unit>
        <trans-unit id="84aa2531d79787134c4a3ba8faa799337584a358" translate="yes" xml:space="preserve">
          <source>Assignment operator. Has the same constraints as the constructor.</source>
          <target state="translated">Operador de asignación.Tiene las mismas limitaciones que el constructor.</target>
        </trans-unit>
        <trans-unit id="aa098245c1ec6b3b4a9cec4ec49f68bc2b3dc905" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
          <target state="translated">Operadores de asignación</target>
        </trans-unit>
        <trans-unit id="99b05821addb139efb582d5733eb165057e45a88" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;super&lt;/code&gt; is not allowed.</source>
          <target state="translated">La asignaci&amp;oacute;n a &lt;code&gt;super&lt;/code&gt; no est&amp;aacute; permitida.</target>
        </trans-unit>
        <trans-unit id="d46d956c7065444efb33c5f5602fe16eab572e8a" translate="yes" xml:space="preserve">
          <source>Assignment to &lt;code&gt;this&lt;/code&gt; is not allowed.</source>
          <target state="translated">La asignaci&amp;oacute;n a &lt;code&gt;this&lt;/code&gt; no est&amp;aacute; permitida.</target>
        </trans-unit>
        <trans-unit id="ac9f4d1b12010a7c21b70ea99324f1a0dd8bcccd" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the first element of the container.</source>
          <target state="translated">Asigna &lt;code&gt;v&lt;/code&gt; al primer elemento del contenedor.</target>
        </trans-unit>
        <trans-unit id="922d6285649b37db600cf15c96dc723863c5afe5" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;v&lt;/code&gt; to the last element of the container.</source>
          <target state="translated">Asigna &lt;code&gt;v&lt;/code&gt; al &amp;uacute;ltimo elemento del contenedor.</target>
        </trans-unit>
        <trans-unit id="9af0d121c1f00202f8eb1627dd5494f59fbf6800" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to each element of input range &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">Asigna &lt;code&gt;value&lt;/code&gt; a cada elemento del rango de &lt;code&gt;range&lt;/code&gt; de entrada .</target>
        </trans-unit>
        <trans-unit id="e5f7c4ee9f81cf1e0b7f9cbc458913458f588507" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state.</source>
          <target state="translated">Asigna &lt;code&gt;value&lt;/code&gt; al estado retenido internamente.</target>
        </trans-unit>
        <trans-unit id="21c3bd56c75643c04bab89ad011aec98a36c3a16" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null.</source>
          <target state="translated">Asigna &lt;code&gt;value&lt;/code&gt; al estado retenido internamente. Si la asignaci&amp;oacute;n tiene &amp;eacute;xito, &lt;code&gt;this&lt;/code&gt; convierte en no nulo.</target>
        </trans-unit>
        <trans-unit id="8d0fc7c17a3a2b5f1514756ed138007924a3a66a" translate="yes" xml:space="preserve">
          <source>Assigns &lt;code&gt;value&lt;/code&gt; to the internally-held state. If the assignment succeeds, &lt;code&gt;this&lt;/code&gt; becomes non-null. No null checks are made. Note that the assignment may leave &lt;code&gt;this&lt;/code&gt; in the null state.</source>
          <target state="translated">Asigna &lt;code&gt;value&lt;/code&gt; al estado retenido internamente. Si la asignaci&amp;oacute;n tiene &amp;eacute;xito, &lt;code&gt;this&lt;/code&gt; convierte en no nulo. No se realizan controles nulos. Tenga en cuenta que la asignaci&amp;oacute;n puede dejar &lt;code&gt;this&lt;/code&gt; en estado nulo.</target>
        </trans-unit>
        <trans-unit id="5b359bc586830b69163a1e75c910372bb60f5dad" translate="yes" xml:space="preserve">
          <source>Assigns a &lt;code&gt;VariantN&lt;/code&gt; from a generic argument. Statically rejects disallowed types.</source>
          <target state="translated">Asigna una &lt;code&gt;VariantN&lt;/code&gt; de un argumento gen&amp;eacute;rico. Rechaza est&amp;aacute;ticamente los tipos no permitidos.</target>
        </trans-unit>
        <trans-unit id="44eb8314103f2fdd05abf9443854b7e8c14d4780" translate="yes" xml:space="preserve">
          <source>Assigns a file to another. The target of the assignment gets detached from whatever file it was attached to, and attaches itself to the new file.</source>
          <target state="translated">Asigna un archivo a otro.El objetivo de la asignación se desprende de cualquier archivo al que se haya adjuntado,y se adjunta al nuevo archivo.</target>
        </trans-unit>
        <trans-unit id="057b5aa3c0ad5c43ab19d19f8ce9f6db63dca13d" translate="yes" xml:space="preserve">
          <source>Assigns a logical thread to execute the supplied op.</source>
          <target state="translated">Asigna un hilo lógico para ejecutar la operación suministrada.</target>
        </trans-unit>
        <trans-unit id="5425da91b2931a4dd8cdec7b13e0afa9866f1762" translate="yes" xml:space="preserve">
          <source>Assigns the given &lt;code&gt;value&lt;/code&gt; to the environment variable with the given &lt;code&gt;name&lt;/code&gt;. If &lt;code&gt;value&lt;/code&gt; is null the variable is removed from environment.</source>
          <target state="translated">Asigna el &lt;code&gt;value&lt;/code&gt; dado a la variable de entorno con el &lt;code&gt;name&lt;/code&gt; dado . Si el &lt;code&gt;value&lt;/code&gt; es nulo, la variable se elimina del entorno.</target>
        </trans-unit>
        <trans-unit id="a6b3ed4789854a21da3d57b64bb5165df47849f8" translate="yes" xml:space="preserve">
          <source>Assigns to the &lt;code&gt;n&lt;/code&gt;th element in the composite range. Defined if all ranges offer random access.</source>
          <target state="translated">Asigna a la &lt;code&gt;n&lt;/code&gt; -&amp;eacute;simo elemento en el rango compuesta. Definido si todos los rangos ofrecen acceso aleatorio.</target>
        </trans-unit>
        <trans-unit id="a41d06f6960668b2b925acd3bf255f8df4491e62" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteral</source>
          <target state="translated">AssocArrayLiteral</target>
        </trans-unit>
        <trans-unit id="5a9bcf3e687e72baa7a855ea1562aeb0b0f6c922" translate="yes" xml:space="preserve">
          <source>AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</source>
          <target state="translated">AssocArrayLiteralExp &lt;code&gt;ae&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47c12f36c1b476d37e1b0680000a7ced07747bab" translate="yes" xml:space="preserve">
          <source>Associate a local address with this socket.</source>
          <target state="translated">Asocie una dirección local a este enchufe.</target>
        </trans-unit>
        <trans-unit id="6fdc76eca25e9805145ab4faa10fd711ec8e7f73" translate="yes" xml:space="preserve">
          <source>Associates name with tid in a process-local map. When the thread represented by tid terminates, any names associated with it will be automatically unregistered.</source>
          <target state="translated">Asocia el nombre con la marea en un mapa de proceso local.Cuando el hilo representado por tid termina,cualquier nombre asociado a él será automáticamente desregistrado.</target>
        </trans-unit>
        <trans-unit id="d00bb7dcc304b2d3b149b7f7680cc932d7d86d19" translate="yes" xml:space="preserve">
          <source>Associates name with tid.</source>
          <target state="translated">Asocia el nombre con Tid.</target>
        </trans-unit>
        <trans-unit id="33ed59cb9cc5ad4f51c71cb705b6c66305c4ea95" translate="yes" xml:space="preserve">
          <source>Associative Array Example: counting Tuples</source>
          <target state="translated">Ejemplo de matriz asociativa:contar tuplas</target>
        </trans-unit>
        <trans-unit id="66110798d937132b8b4c69b6c86f490e42147357" translate="yes" xml:space="preserve">
          <source>Associative Array Example: word count</source>
          <target state="translated">Ejemplo de matriz asociativa:recuento de palabras</target>
        </trans-unit>
        <trans-unit id="62a00c8d718bd407e11a04d361c97fd9304d9228" translate="yes" xml:space="preserve">
          <source>Associative Array Literals</source>
          <target state="translated">Literatura asociativa</target>
        </trans-unit>
        <trans-unit id="8cd02aabb1cb92301b44ecacb4a3476fbc048ed6" translate="yes" xml:space="preserve">
          <source>Associative Array Properties</source>
          <target state="translated">Propiedades de la matriz asociativa</target>
        </trans-unit>
        <trans-unit id="ac6bb05c1566d531b5e617bff01417f7eeacaa8d" translate="yes" xml:space="preserve">
          <source>Associative Arrays</source>
          <target state="translated">Arreglos asociativos</target>
        </trans-unit>
        <trans-unit id="eac66f094196ab59907d539af93b0f79d61ccbc4" translate="yes" xml:space="preserve">
          <source>Associative array indexed by the name of each member of the archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a88997c71f98db7849444ee105aa1b9e104461" translate="yes" xml:space="preserve">
          <source>Associative array literal is going to be allocated on the GC heap. Check its elements to see if any would escape by going on the heap.</source>
          <target state="translated">El literal de la matriz asociativa va a ser asignado en el montón de GC.Comprueba sus elementos para ver si alguno se escapa al ir al montón.</target>
        </trans-unit>
        <trans-unit id="2cdd3f26aaf9ed2ca50e34f9cba8cec0e214e787" translate="yes" xml:space="preserve">
          <source>Associative array literals</source>
          <target state="translated">Literales de la matriz asociativa</target>
        </trans-unit>
        <trans-unit id="aa59b9862478a41dd5f1d43314d8d4fd2f36cfac" translate="yes" xml:space="preserve">
          <source>Associative array literals are a comma-separated list of</source>
          <target state="translated">Los literales de la matriz asociativa son una lista separada por comas de</target>
        </trans-unit>
        <trans-unit id="f1464f4beecb9ccd1b6cd79f0d3fdebe26677ef6" translate="yes" xml:space="preserve">
          <source>Associative array of attributes</source>
          <target state="translated">Conjunto asociativo de atributos</target>
        </trans-unit>
        <trans-unit id="b87ce9bf0d9a5c06c6d7bc4fc73a4cd816351837" translate="yes" xml:space="preserve">
          <source>Associative array to string conversion. Each element is converted by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3256b0ab3483fa8604ecf1ce16a782f56f85d2" translate="yes" xml:space="preserve">
          <source>Associative array to string conversion. Each element is printed by calling &lt;code&gt;to!T&lt;/code&gt;.</source>
          <target state="translated">Conversi&amp;oacute;n asociativa de matriz a cadena. Cada elemento est&amp;aacute; impresa llamando &lt;code&gt;to!T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6eed25868a22de24520441116395f69e925a6704" translate="yes" xml:space="preserve">
          <source>Associative array with all archive members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0cf74a282aed4f93bc7369a99f5541139720753" translate="yes" xml:space="preserve">
          <source>Associative arrays</source>
          <target state="translated">Matrices asociativas</target>
        </trans-unit>
        <trans-unit id="b7b195035b64b57f923bdef12ca24604e56d713e" translate="yes" xml:space="preserve">
          <source>Associative arrays are declared by placing the</source>
          <target state="translated">Las matrices asociativas se declaran colocando el</target>
        </trans-unit>
        <trans-unit id="e2e6b379c645fab1d146e1f88662672372565c42" translate="yes" xml:space="preserve">
          <source>Associative arrays are formatted by using &lt;code&gt;':'&lt;/code&gt; and &lt;code&gt;&quot;, &quot;&lt;/code&gt; as separators, and enclosed by &lt;code&gt;'['&lt;/code&gt; and &lt;code&gt;']'&lt;/code&gt;.</source>
          <target state="translated">Las matrices asociativas se formatean con &lt;code&gt;':'&lt;/code&gt; y &lt;code&gt;&quot;, &quot;&lt;/code&gt; como separadores, y se delimitan con &lt;code&gt;'['&lt;/code&gt; y &lt;code&gt;']'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="578b6958d55efc32eb2164f95c40c985b159a3d3" translate="yes" xml:space="preserve">
          <source>Associative arrays are initialized to having 0 elements.</source>
          <target state="translated">Los conjuntos asociativos se inicializan para tener 0 elementos.</target>
        </trans-unit>
        <trans-unit id="1f9ac76e68b33aa5367eaec796765ac41035935d" translate="yes" xml:space="preserve">
          <source>Associative arrays are returned in EAX.</source>
          <target state="translated">Las matrices asociativas se devuelven en EAX.</target>
        </trans-unit>
        <trans-unit id="5ca5da5a3d3a14509f014f2f90e91f3a2f1bc8b9" translate="yes" xml:space="preserve">
          <source>Associative arrays consist of a pointer to an opaque, implementation defined type.</source>
          <target state="translated">Las matrices asociativas consisten en un puntero a un tipo opaco y definido de implementación.</target>
        </trans-unit>
        <trans-unit id="4b7aaeec3338d91fc185c073ff6aea7f4aaaf1d1" translate="yes" xml:space="preserve">
          <source>Associative arrays have an index that is not necessarily an integer, and can be sparsely populated. The index for an associative array is called the</source>
          <target state="translated">Los conjuntos asociativos tienen un índice que no es necesariamente un entero,y pueden estar poco poblados.El índice de un conjunto asociativo se llama</target>
        </trans-unit>
        <trans-unit id="24b2b993b7d8aa8b139deca02db3001c61ba8f93" translate="yes" xml:space="preserve">
          <source>Associative arrays have unique keys. If r contains duplicate keys, then the result will contain the value of the last pair for that key in r.</source>
          <target state="translated">Las matrices asociativas tienen claves únicas.Si r contiene claves duplicadas,el resultado contendrá el valor del último par para esa clave en r.</target>
        </trans-unit>
        <trans-unit id="7140c60dcf97eae1fd241925dc294e9b664ccf47" translate="yes" xml:space="preserve">
          <source>Associativity and Commutativity</source>
          <target state="translated">La asociatividad y la conmutabilidad</target>
        </trans-unit>
        <trans-unit id="d4afb493c09c81bc22adc7df22495a98eac06f94" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;a = &quot;blah&quot;&lt;/code&gt;. Then &lt;code&gt;skipOver(a, &quot;bi&quot;)&lt;/code&gt; leaves &lt;code&gt;a&lt;/code&gt; unchanged and returns &lt;code&gt;false&lt;/code&gt;, whereas &lt;code&gt;skipOver(a, &quot;bl&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to refer to &lt;code&gt;&quot;ah&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Suponga &lt;code&gt;a = &quot;blah&quot;&lt;/code&gt; . Entonces &lt;code&gt;skipOver(a, &quot;bi&quot;)&lt;/code&gt; deja &lt;code&gt;a&lt;/code&gt; sin cambios y devuelve &lt;code&gt;false&lt;/code&gt; , mientras que &lt;code&gt;skipOver(a, &quot;bl&quot;)&lt;/code&gt; avanza &lt;code&gt;a&lt;/code&gt; para referirse a &lt;code&gt;&quot;ah&quot;&lt;/code&gt; y devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c94a2c42cde8321b948dff42533f346ec9014aea" translate="yes" xml:space="preserve">
          <source>Assume that it is safe to append to this array. Appends made to this array after calling this function may append in place, even if the array was a slice of a larger array to begin with.</source>
          <target state="translated">Suponga que es seguro añadirlo a esta matriz.Los apéndices hechos a esta matriz después de llamar a esta función pueden ser añadidos en su lugar,incluso si la matriz era un trozo de una matriz más grande para empezar.</target>
        </trans-unit>
        <trans-unit id="3954f2a28b82752323144cbb88151e77e6d01da9" translate="yes" xml:space="preserve">
          <source>Assume the given array of integers &lt;code&gt;arr&lt;/code&gt; is a well-formed UTF string and return it typed as a UTF string.</source>
          <target state="translated">Suponga que la matriz dada de enteros &lt;code&gt;arr&lt;/code&gt; es una cadena UTF bien formada y devu&amp;eacute;lvala escrita como una cadena UTF.</target>
        </trans-unit>
        <trans-unit id="51fef9f691908f559d18676822c2b16e9811cadf" translate="yes" xml:space="preserve">
          <source>Assume, that the range is sorted without checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46abda9a40531b5c7ab25b4f982669308c54d50" translate="yes" xml:space="preserve">
          <source>Assumes &lt;code&gt;r&lt;/code&gt; is sorted by predicate &lt;code&gt;pred&lt;/code&gt; and returns the corresponding &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; having &lt;code&gt;r&lt;/code&gt; as support. To check for sorted-ness at cost &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;), use &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt;&lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e62b25f8e7aaa35a775d4bc9ee591164888166" translate="yes" xml:space="preserve">
          <source>Assumes &lt;code&gt;r&lt;/code&gt; is sorted by predicate &lt;code&gt;pred&lt;/code&gt; and returns the corresponding &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; having &lt;code&gt;r&lt;/code&gt; as support. To keep the checking costs low, the cost is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) in release mode (no checks for sorted-ness are performed). In debug mode, a few random elements of &lt;code&gt;r&lt;/code&gt; are checked for sorted-ness. The size of the sample is proportional &amp;Omicron;(&lt;code&gt;log(r.length)&lt;/code&gt;). That way, checking has no effect on the complexity of subsequent operations specific to sorted ranges (such as binary search). The probability of an arbitrary unsorted range failing the test is very high (however, an almost-sorted range is likely to pass it). To check for sorted-ness at cost &amp;Omicron;(&lt;code&gt;n&lt;/code&gt;), use &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt;&lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Asume que &lt;code&gt;r&lt;/code&gt; est&amp;aacute; ordenado por predicado &lt;code&gt;pred&lt;/code&gt; y devuelve el &lt;code&gt;SortedRange!(pred, R)&lt;/code&gt; correspondiente (pred, R) teniendo &lt;code&gt;r&lt;/code&gt; como soporte. Para mantener bajos los costos de verificaci&amp;oacute;n, el costo es &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) en el modo de liberaci&amp;oacute;n (no se realizan verificaciones de clasificaci&amp;oacute;n). En el modo de depuraci&amp;oacute;n, algunos elementos aleatorios de &lt;code&gt;r&lt;/code&gt; se verifican para su ordenaci&amp;oacute;n. El tama&amp;ntilde;o de la muestra es proporcional &amp;Omicron; ( &lt;code&gt;log(r.length)&lt;/code&gt; ). De esa manera, la verificaci&amp;oacute;n no tiene ning&amp;uacute;n efecto sobre la complejidad de las operaciones posteriores espec&amp;iacute;ficas de los rangos ordenados (como la b&amp;uacute;squeda binaria). La probabilidad de que un rango arbitrario no ordenado falle la prueba es muy alta (sin embargo, es probable que un rango casi ordenado lo supere). Para verificar la ordenaci&amp;oacute;n al costo &amp;Omicron; ( &lt;code&gt;n&lt;/code&gt; ), use &lt;a href=&quot;std_algorithm_sorting#isSorted&quot;&gt; &lt;code&gt;std.algorithm.sorting.isSorted&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f92de52d34809fb9f9b5a422d22d2bd3f403b63b" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;T&lt;/code&gt; is an unqualified type, the graph below illustrates how qualifiers combine (combinations with &lt;code&gt;immutable&lt;/code&gt; are omitted). For each node, applying the qualifier labeling the edge leads to the resulting type.</source>
          <target state="translated">Suponiendo que &lt;code&gt;T&lt;/code&gt; es un tipo no calificado, el siguiente gr&amp;aacute;fico ilustra c&amp;oacute;mo se combinan los calificadores ( se omiten las combinaciones con &lt;code&gt;immutable&lt;/code&gt; ). Para cada nodo, la aplicaci&amp;oacute;n del calificador que etiqueta el borde conduce al tipo resultante.</target>
        </trans-unit>
        <trans-unit id="317581a22ccf8624556bdb31509c5c5a51feef3f" translate="yes" xml:space="preserve">
          <source>Assuming that pages are laid out consequently in one array at &lt;code&gt;pages&lt;/code&gt;, the pseudo-code is:</source>
          <target state="translated">Suponiendo que las p&amp;aacute;ginas se presentan en consecuencia en una matriz en las &lt;code&gt;pages&lt;/code&gt; , el pseudoc&amp;oacute;digo es:</target>
        </trans-unit>
        <trans-unit id="7bfdbbc84ee0d35091e2296c00a0a25e1c9d7c15" translate="yes" xml:space="preserve">
          <source>Assuming the file was at /example/test.d, this will output:</source>
          <target state="translated">Asumiendo que el archivo estaba en /example/test.d,esto saldrá:</target>
        </trans-unit>
        <trans-unit id="4ade9724e5f6c8aea4d40d9c22982099c0a42498" translate="yes" xml:space="preserve">
          <source>Assuming the reverse meaning (i.e. &quot;ignoreTerminator&quot;) and inserting the wrong code compiles and runs with erroneous results.  After replacing the boolean parameter with an instantiation of &lt;code&gt;Flag&lt;/code&gt;, code calling &lt;code&gt;getLine&lt;/code&gt; can be easily read and understood even by people not fluent with the API:</source>
          <target state="translated">Suponiendo el significado inverso (es decir, &quot;ignoreTerminator&quot;) e insertando el c&amp;oacute;digo incorrecto, se compila y se ejecuta con resultados err&amp;oacute;neos. Despu&amp;eacute;s de reemplazar el par&amp;aacute;metro booleano con una instanciaci&amp;oacute;n de &lt;code&gt;Flag&lt;/code&gt; , el c&amp;oacute;digo que llama a &lt;code&gt;getLine&lt;/code&gt; puede ser le&amp;iacute;do y entendido f&amp;aacute;cilmente incluso por personas que no dominan la API:</target>
        </trans-unit>
        <trans-unit id="8b593995c88f61a609044a01e37e8e4ccc22e065" translate="yes" xml:space="preserve">
          <source>Assumptions</source>
          <target state="translated">Assumptions</target>
        </trans-unit>
        <trans-unit id="875a558108f6180c117cd2a9851fbd31bf1ad357" translate="yes" xml:space="preserve">
          <source>At Least Alias</source>
          <target state="translated">Al menos Alias</target>
        </trans-unit>
        <trans-unit id="319fc7f766d3014146f622cd42e082b9d29acc59" translate="yes" xml:space="preserve">
          <source>At any point in the program, for each memory object, there is exactly one live mutable pointer to it or all the live pointers to it are read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a5e7ce73794fbffd33597afe29e6656f7606b48" translate="yes" xml:space="preserve">
          <source>At least one return statement, throw statement, or assert(0) expression is required if the function specifies a return type that is not void, unless the function contains inline assembler code.</source>
          <target state="translated">Se requiere al menos una declaración de retorno,una declaración de lanzamiento o una expresión de afirmación(0)si la función especifica un tipo de retorno que no es nulo,a menos que la función contenga código ensamblador en línea.</target>
        </trans-unit>
        <trans-unit id="90d61c89ed43af9a321f3f7948cd37fb3078855e" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. &lt;code&gt;Zip&lt;/code&gt; offers the lowest range facilities of all components, e.g. it offers random access iff all ranges offer random access, and also offers mutation and swapping if all ranges offer it. Due to this, &lt;code&gt;Zip&lt;/code&gt; is extremely powerful because it allows manipulating several ranges in lockstep.</source>
          <target state="translated">Como m&amp;iacute;nimo, un rango de entrada. &lt;code&gt;Zip&lt;/code&gt; ofrece las instalaciones de rango m&amp;aacute;s bajo de todos los componentes, por ejemplo, ofrece acceso aleatorio si todos los rangos ofrecen acceso aleatorio, y tambi&amp;eacute;n ofrece mutaci&amp;oacute;n e intercambio si todos los rangos lo ofrecen. Debido a esto, &lt;code&gt;Zip&lt;/code&gt; es extremadamente poderoso porque permite manipular varios rangos de forma sincronizada.</target>
        </trans-unit>
        <trans-unit id="bf82744118a56dc50e99bed95e0674d739012373" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. All other range primitives are given in the resulting range if &lt;code&gt;range&lt;/code&gt; has them. The exceptions are the bidirectional primitives, which are propagated only if &lt;code&gt;range&lt;/code&gt; has length.</source>
          <target state="translated">Como m&amp;iacute;nimo, un rango de entrada. Todas las dem&amp;aacute;s primitivas de rango se dan en el rango resultante si el &lt;code&gt;range&lt;/code&gt; tiene. Las excepciones son las primitivas bidireccionales, que se propagan solo si el &lt;code&gt;range&lt;/code&gt; tiene longitud.</target>
        </trans-unit>
        <trans-unit id="e9641b92bdebc39e62f8119a95b586fda5bb953c" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. If the range offers random access and &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;take&lt;/code&gt; offers them as well.</source>
          <target state="translated">Como m&amp;iacute;nimo, un rango de entrada. Si el rango ofrece acceso aleatorio y &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;take&lt;/code&gt; les ofrece tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="b4f8bcff8fd004d35539b31be3e23eec00e83071" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. Range primitives such as bidirectionality and random access are given if the element type of &lt;code&gt;rr&lt;/code&gt; provides them.</source>
          <target state="translated">Como m&amp;iacute;nimo, un rango de entrada. Se proporcionan primitivas de rango como la bidireccionalidad y el acceso aleatorio si el tipo de elemento de &lt;code&gt;rr&lt;/code&gt; los proporciona.</target>
        </trans-unit>
        <trans-unit id="ab81f7243697f45d24e88eac476807c5bafc54c5" translate="yes" xml:space="preserve">
          <source>At minimum, an input range. The resulting range will adopt the range primitives of the underlying range as long as &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt;&lt;code&gt;std.range.primitives.hasLength&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Como m&amp;iacute;nimo, un rango de entrada. El rango resultante adoptar&amp;aacute; las primitivas de rango del rango subyacente siempre que &lt;a href=&quot;std_range_primitives#hasLength&quot;&gt; &lt;code&gt;std.range.primitives.hasLength&lt;/code&gt; &lt;/a&gt; sea &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13e0cdc536d3ebf98a18c0bc6152dede0a930dcf" translate="yes" xml:space="preserve">
          <source>At offset index into buffer, create nbytes of space by shifting upwards all data past index.</source>
          <target state="translated">En el índice de compensación en la memoria intermedia,crear nbytes de espacio desplazando hacia arriba todos los datos más allá del índice.</target>
        </trans-unit>
        <trans-unit id="1427d1990cebaf6b24e9781e5fa4c566cf53ece6" translate="yes" xml:space="preserve">
          <source>At present, C++ exceptions cannot be caught in or thrown from D, and D exceptions cannot be caught in or thrown from C++. Additionally, objects in C++ stack frames are not guaranteed to be destroyed when unwinding the stack due to a D exception, and vice versa.</source>
          <target state="translated">En la actualidad,las excepciones de C++no pueden ser capturadas o lanzadas desde D,y las excepciones de D no pueden ser capturadas o lanzadas desde C++.Además,no se garantiza que los objetos en los marcos de la pila de C++sean destruidos al desenrollar la pila debido a una excepción D,y viceversa.</target>
        </trans-unit>
        <trans-unit id="8d76f9b99e41b5780a5b8aa58882552e760fb6a3" translate="yes" xml:space="preserve">
          <source>Atomically adds &lt;code&gt;mod&lt;/code&gt; to the value referenced by &lt;code&gt;val&lt;/code&gt; and returns the value &lt;code&gt;val&lt;/code&gt; held previously. This operation is both lock-free and atomic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79117be4a561837c4e341dc958c03f4b3575dace" translate="yes" xml:space="preserve">
          <source>Atomically increment the current count by one. This will notify one waiter, if there are any in the queue.</source>
          <target state="translated">Incrementa atómicamente el conteo actual en uno.Esto notificará a un camarero,si hay alguno en la cola.</target>
        </trans-unit>
        <trans-unit id="0e72ffed036979247fd717525ebb223918c99bbc" translate="yes" xml:space="preserve">
          <source>Atomically subtracts &lt;code&gt;mod&lt;/code&gt; from the value referenced by &lt;code&gt;val&lt;/code&gt; and returns the value &lt;code&gt;val&lt;/code&gt; held previously. This operation is both lock-free and atomic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="translated">Intentar liberar la memoria del montón</target>
        </trans-unit>
        <trans-unit id="2d4188d946f5310d84944e1cbc16ca3404e12f5e" translate="yes" xml:space="preserve">
          <source>Attempt to write a readonly database</source>
          <target state="translated">Intenta escribir una base de datos de sólo lectura</target>
        </trans-unit>
        <trans-unit id="bad2e7923396bd94563de54c8743dd18ec710863" translate="yes" xml:space="preserve">
          <source>Attempting to read a non-existent file.</source>
          <target state="translated">Intentando leer un archivo inexistente.</target>
        </trans-unit>
        <trans-unit id="cfc72cd8439fa8fc0153768ece769b118903087b" translate="yes" xml:space="preserve">
          <source>Attempting to write to a read-only file.</source>
          <target state="translated">Intentando escribir en un archivo de sólo lectura.</target>
        </trans-unit>
        <trans-unit id="f3bc6684b273ddb5150c8f76dec58669641f537c" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a read lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the function blocks until either the lock can be obtained or the time elapsed exceeds timeout, returning true if the lock was acquired and false if the function timed out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619f7dc21d7be2451ba09a0a31590c696e32ea77" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a read lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the lock is not acquired and false is returned.</source>
          <target state="translated">Intenta adquirir una cerradura de lectura en el mutex adjunto.Si se puede obtener uno sin bloqueo,se adquiere el bloqueo y se devuelve el verdadero.Si no,el bloqueo no se adquiere y se devuelve falso.</target>
        </trans-unit>
        <trans-unit id="3953627ccf0b01ecfcf23b7ad87c26a8060eafac" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a write lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the function blocks until either the lock can be obtained or the time elapsed exceeds timeout, returning true if the lock was acquired and false if the function timed out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640457600821a8df2d538564c057e12d520f4905" translate="yes" xml:space="preserve">
          <source>Attempts to acquire a write lock on the enclosing mutex. If one can be obtained without blocking, the lock is acquired and true is returned. If not, the lock is not acquired and false is returned.</source>
          <target state="translated">Intenta adquirir una cerradura de escritura en el mutex adjunto.Si se puede obtener uno sin bloqueo,se adquiere el bloqueo y se devuelve el verdadero.Si no,el bloqueo no se adquiere y se devuelve falso.</target>
        </trans-unit>
        <trans-unit id="3b9757d22891fdb7b2db7ae0d5e59794d8111018" translate="yes" xml:space="preserve">
          <source>Attempts to cast Object o to class c. Returns o if successful, null if not.</source>
          <target state="translated">Intentos de lanzar el objeto o a la clase c.Vuelve o si tiene éxito,nulo si no.</target>
        </trans-unit>
        <trans-unit id="fb9f33e63583d791ce38087ee972da2a9a91218e" translate="yes" xml:space="preserve">
          <source>Attempts to lock the specified file segment. If both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are zero, the entire file is locked.</source>
          <target state="translated">Intenta bloquear el segmento de archivo especificado. Si tanto el &lt;code&gt;start&lt;/code&gt; como la &lt;code&gt;length&lt;/code&gt; son cero, todo el archivo est&amp;aacute; bloqueado.</target>
        </trans-unit>
        <trans-unit id="25ad0c35f575b740f4d561c41e13284745953ceb" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the host address as a human-readable string.</source>
          <target state="translated">Intenta recuperar la dirección del anfitrión como una cadena legible por los humanos.</target>
        </trans-unit>
        <trans-unit id="0ee6b4fbb8496cdc7d0620d9b9ed398b895a55e3" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the host name as a fully qualified domain name.</source>
          <target state="translated">Intenta recuperar el nombre del host como un nombre de dominio totalmente cualificado.</target>
        </trans-unit>
        <trans-unit id="2288a588beafb785ffe5d4183be649edf540fac4" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the numeric port number as a string.</source>
          <target state="translated">Intenta recuperar el número de puerto numérico como una cadena.</target>
        </trans-unit>
        <trans-unit id="f6c4cea55c8d840b0fc77f72a5e89fc5d0c7b734" translate="yes" xml:space="preserve">
          <source>Attempts to retrieve the service name as a string.</source>
          <target state="translated">Intenta recuperar el nombre del servicio como una cadena.</target>
        </trans-unit>
        <trans-unit id="06a30d499359e73aad911822ebc036ba5b33b771" translate="yes" xml:space="preserve">
          <source>Attempts to terminate the process associated with &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Intenta terminar el proceso asociado con &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e521b72cd060c4862399350be7113a0bf337401" translate="yes" xml:space="preserve">
          <source>Attention: Enabling precise scanning needs slightly more caution typing global memory. For example, if you pre-allocate memory in the DATA/TLS segment and later emplace an object instance with references to other allocations into this memory, you must not use basic integer types to reserve the space. Doing so will cause the garbage collector not to detect the references. Instead, use an array type that will scan this area conservatively. Using &lt;code&gt;void*&lt;/code&gt; is usually the best option as it also ensures proper alignment for pointers being scanned by the GC.</source>
          <target state="translated">Atenci&amp;oacute;n: habilitar el escaneo preciso requiere un poco m&amp;aacute;s de precauci&amp;oacute;n al escribir la memoria global. Por ejemplo, si preasigna memoria en el segmento DATA / TLS y luego coloca una instancia de objeto con referencias a otras asignaciones en esta memoria, no debe usar tipos enteros b&amp;aacute;sicos para reservar el espacio. Al hacerlo, el recolector de basura no detectar&amp;aacute; las referencias. En su lugar, utilice un tipo de matriz que escanear&amp;aacute; esta &amp;aacute;rea de forma conservadora. El uso de &lt;code&gt;void*&lt;/code&gt; suele ser la mejor opci&amp;oacute;n, ya que tambi&amp;eacute;n garantiza una alineaci&amp;oacute;n adecuada para los punteros escaneados por el GC.</target>
        </trans-unit>
        <trans-unit id="435469686dcf93332d214d0927042b6ab70eb76c" translate="yes" xml:space="preserve">
          <source>Attention: Enabling precise scanning needs slightly more caution with type declarations. For example, if you reserve a buffer as part of a struct and later emplace an object instance with references to other allocations into this memory, you must not use basic integer types to reserve the space. Doing so will cause the garbage collector not to detect the references. Instead, use an array type that will scan this area conservatively. Using &lt;code&gt;void*&lt;/code&gt; is usually the best option as it also ensures proper alignment for pointers being scanned by the GC.</source>
          <target state="translated">Atenci&amp;oacute;n: habilitar la exploraci&amp;oacute;n precisa requiere un poco m&amp;aacute;s de precauci&amp;oacute;n con las declaraciones de tipo. Por ejemplo, si reserva un b&amp;uacute;fer como parte de una estructura y luego coloca una instancia de objeto con referencias a otras asignaciones en esta memoria, no debe usar tipos enteros b&amp;aacute;sicos para reservar el espacio. Al hacerlo, el recolector de basura no detectar&amp;aacute; las referencias. En su lugar, utilice un tipo de matriz que escanear&amp;aacute; esta &amp;aacute;rea de forma conservadora. El uso de &lt;code&gt;void*&lt;/code&gt; suele ser la mejor opci&amp;oacute;n, ya que tambi&amp;eacute;n garantiza una alineaci&amp;oacute;n adecuada para los punteros escaneados por el GC.</target>
        </trans-unit>
        <trans-unit id="223e46f6b77744459f61cc252aea39f3bcaac056" translate="yes" xml:space="preserve">
          <source>Attribs</source>
          <target state="translated">Attribs</target>
        </trans-unit>
        <trans-unit id="563889efc6708465a0f8d7b13b7a64dc9449be63" translate="yes" xml:space="preserve">
          <source>Attribute inference is not done for other functions, even if the function body is present.</source>
          <target state="translated">La inferencia de atributos no se hace para otras funciones,incluso si el cuerpo de la función está presente.</target>
        </trans-unit>
        <trans-unit id="fde0c64566e4280899df7f71f529a9c5822593d2" translate="yes" xml:space="preserve">
          <source>Attributed Unittests</source>
          <target state="translated">Pruebas unitarias atribuidas</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="3566d57f396227b960696c7c5f730c9617ce2ae9" translate="yes" xml:space="preserve">
          <source>Attributes are a way to modify one or more declarations. The general forms are:</source>
          <target state="translated">Los atributos son una forma de modificar una o más declaraciones.Las formas generales son:</target>
        </trans-unit>
        <trans-unit id="caa5510657413031ecde7637769e34ce12f05928" translate="yes" xml:space="preserve">
          <source>Attributes as obtained by &lt;a href=&quot;std_file#getAttributes&quot;&gt;&lt;code&gt;std.file.getAttributes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;std_file#DirEntry.attributes&quot;&gt;&lt;code&gt;std.file.DirEntry.attributes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a118fa9a5b31a61d074da7d6149cfba22d1f3ad" translate="yes" xml:space="preserve">
          <source>Authentication method as specified in &lt;a href=&quot;#AuthMethod&quot;&gt;&lt;code&gt;AuthMethod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">M&amp;eacute;todo de autenticaci&amp;oacute;n como se especifica en &lt;a href=&quot;#AuthMethod&quot;&gt; &lt;code&gt;AuthMethod&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1033f15759fcb47c36fb8ab321053fc3f1eca814" translate="yes" xml:space="preserve">
          <source>Authentication method equal to &lt;a href=&quot;etc_c_curl#CurlAuth&quot;&gt;&lt;code&gt;etc.c.curl.CurlAuth&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">M&amp;eacute;todo de autenticaci&amp;oacute;n igual a &lt;a href=&quot;etc_c_curl#CurlAuth&quot;&gt; &lt;code&gt;etc.c.curl.CurlAuth&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="66d5524bc6e9a905bcd8ad67ae1eb457c570b564" translate="yes" xml:space="preserve">
          <source>Authorization denied</source>
          <target state="translated">Autorización denegada</target>
        </trans-unit>
        <trans-unit id="96526fc6efe098c9c6df94252412831b9ccb9466" translate="yes" xml:space="preserve">
          <source>Authors:</source>
          <target state="translated">Authors:</target>
        </trans-unit>
        <trans-unit id="ce0159a5518bc584a9e41b4b2690ef154fde135a" translate="yes" xml:space="preserve">
          <source>Auto Functions</source>
          <target state="translated">Funciones automáticas</target>
        </trans-unit>
        <trans-unit id="cac7a53f813ead2d8559f8bf1f813c3742d1564d" translate="yes" xml:space="preserve">
          <source>Auto Ref Functions</source>
          <target state="translated">Funciones de Refuerzo Automático</target>
        </trans-unit>
        <trans-unit id="5437bd3930e7f40ca7893e40f97b38d23c03f5fa" translate="yes" xml:space="preserve">
          <source>Auto functions have their return type inferred from any &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;ReturnStatement&lt;/i&gt;&lt;/a&gt;s in the function body.</source>
          <target state="translated">Las funciones autom&amp;aacute;ticas tienen su tipo de retorno inferido de cualquier &lt;a href=&quot;statement#ReturnStatement&quot;&gt;&lt;i&gt;declaraci&amp;oacute;n de retorno&lt;/i&gt;&lt;/a&gt; en el cuerpo de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cec7110add8230fd3e3cee4a6982476165507102" translate="yes" xml:space="preserve">
          <source>Auto ref function can have explicit return type.</source>
          <target state="translated">La función de referencia automática puede tener un tipo de retorno explícito.</target>
        </trans-unit>
        <trans-unit id="1c98218626b244980716cf56d4d67cef842f3ffa" translate="yes" xml:space="preserve">
          <source>Auto ref functions infer their return type just as &lt;a href=&quot;#auto-functions&quot;&gt;auto functions&lt;/a&gt; do. In addition, they become &lt;a href=&quot;#ref-functions&quot;&gt;ref functions&lt;/a&gt; if all return expressions are lvalues, and it would not be a reference to a local or a parameter.</source>
          <target state="translated">Las funciones de referencia autom&amp;aacute;tica infieren su tipo de retorno al igual que &lt;a href=&quot;#auto-functions&quot;&gt;las funciones autom&amp;aacute;ticas&lt;/a&gt; . Adem&amp;aacute;s, se convierten en &lt;a href=&quot;#ref-functions&quot;&gt;funciones de referencia&lt;/a&gt; si todas las expresiones de retorno son valores, y no ser&amp;iacute;a una referencia a un local o un par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="72dbdd4328b363da1dc721bef13390d325cb449b" translate="yes" xml:space="preserve">
          <source>Auto ref parameters can be combined with auto ref return attributes:</source>
          <target state="translated">Los parámetros de referencia automática pueden combinarse con los atributos de retorno de referencia automática:</target>
        </trans-unit>
        <trans-unit id="b60c388599c6393e9a67e964a642ad91629c903e" translate="yes" xml:space="preserve">
          <source>Auto start with constructor.</source>
          <target state="translated">Arranque automático con el constructor.</target>
        </trans-unit>
        <trans-unit id="efe7dcdfb00b164478f91903b1de63b3b45e9d2f" translate="yes" xml:space="preserve">
          <source>Auto-initialize the object</source>
          <target state="translated">Autoiniciar el objeto</target>
        </trans-unit>
        <trans-unit id="9d4560b6ff607cd4aecb5b5ff67e03b10904f66c" translate="yes" xml:space="preserve">
          <source>Autodecoding is enabled if this is set to true.</source>
          <target state="translated">La autodescodificación está habilitada si se establece como verdadera.</target>
        </trans-unit>
        <trans-unit id="360d06366226a26ec284df57dde94213ed2f94dc" translate="yes" xml:space="preserve">
          <source>Automatic input/output redirection using pipes</source>
          <target state="translated">Redireccionamiento automático de entrada/salida mediante tuberías</target>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="translated">Cargar automáticamente las extensiones enlazadas estáticamente</target>
        </trans-unit>
        <trans-unit id="d2178e65328973816c4ca61d0183a96480a9ed99" translate="yes" xml:space="preserve">
          <source>Available GC options are:</source>
          <target state="translated">Las opciones de GC disponibles son:</target>
        </trans-unit>
        <trans-unit id="e14fc18612f34181b225bea7665a50b7b0f96761" translate="yes" xml:space="preserve">
          <source>Available output formats:</source>
          <target state="translated">Formatos de salida disponibles:</target>
        </trans-unit>
        <trans-unit id="063d4770adfbdb2cd75f5fde3c562c12c1713762" translate="yes" xml:space="preserve">
          <source>Available parameters are: CURLFTPAUTH_DEFAULT - let libcurl decide CURLFTPAUTH_SSL - try &quot;AUTH SSL&quot; first, then TLS CURLFTPAUTH_TLS - try &quot;AUTH TLS&quot; first, then SSL</source>
          <target state="translated">Los parámetros disponibles son:CURLFTPAUTH_DEFAULT-deja que libcurl decida CURLFTPAUTH_SSL-intenta &quot;AUTH SSL&quot; primero,luego TLS CURLFTPAUTH_TLS-intenta &quot;AUTH TLS&quot; primero,luego SSL</target>
        </trans-unit>
        <trans-unit id="463bce54270761ca786235a57251bca24f1dbc8b" translate="yes" xml:space="preserve">
          <source>Available space in bytes</source>
          <target state="translated">Espacio disponible en bytes</target>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="2be47cf0ea6736915b049bc8ea265c97a2606e56" translate="yes" xml:space="preserve">
          <source>Avoid cyclical imports where practical. They can be a sign of poor decomposition of program structure into independent modules. Two modules that import each other can often be reorganized into three modules without cycles, where the third contains declarations needed by the other two.</source>
          <target state="translated">Evite las importaciones cíclicas cuando sea posible.Pueden ser un signo de una mala descomposición de la estructura del programa en módulos independientes.Dos módulos que se importan mutuamente pueden a menudo reorganizarse en tres módulos sin ciclos,donde el tercero contiene las declaraciones que necesitan los otros dos.</target>
        </trans-unit>
        <trans-unit id="4417a2a43deb22ade3de0092387bf58a8c4fe263" translate="yes" xml:space="preserve">
          <source>Avoid cyclical imports where practical. They can be an indication of poor decomposition of a program's structure into independent modules. Two modules that import each other can often be reorganized into three modules without cycles, where the third contains the declarations needed by the other two.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa042d5d9bad75e7a516100618f6fbb64a7728b7" translate="yes" xml:space="preserve">
          <source>Avoid dependence on byte order; i.e. whether the CPU is big-endian or little-endian.</source>
          <target state="translated">Evita la dependencia del orden de los bytes,es decir,si el CPU es big-endian o little-endian.</target>
        </trans-unit>
        <trans-unit id="87263cc0efbd41c932d10eec489a5a9fa53f4615" translate="yes" xml:space="preserve">
          <source>Avoid dependence on the size of a pointer or reference being the same size as a particular integral type.</source>
          <target state="translated">Evite la dependencia del tamaño de un puntero o de una referencia que sea del mismo tamaño que un tipo integral particular.</target>
        </trans-unit>
        <trans-unit id="a5f3c22b10cd44ac8e47f76e9ce3358fd5ea5dbb" translate="yes" xml:space="preserve">
          <source>Avoid depending on the order of side effects in a computation that may get reordered by the compiler. For example:</source>
          <target state="translated">Evite depender del orden de los efectos secundarios en un cómputo que puede ser reordenado por el compilador.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="07964cf6df89426658b50b243ee7036b1cf42153" translate="yes" xml:space="preserve">
          <source>Avoid having mutable public fields of classes with invariants, as then the invariant cannot verify the public interface.</source>
          <target state="translated">Evite tener campos públicos mutables de clases con invariantes,ya que entonces la invariante no puede verificar la interfaz pública.</target>
        </trans-unit>
        <trans-unit id="4d3d6af1490ba88616db8531edd7f4d34c56a495" translate="yes" xml:space="preserve">
          <source>Avoid having mutable public fields of structs with invariants, as then the invariant cannot verify the public interface.</source>
          <target state="translated">Evite tener campos públicos mutables de estructuras con invariantes,ya que entonces la invariante no puede verificar la interfaz pública.</target>
        </trans-unit>
        <trans-unit id="0209d0b0190d63b253227592d1649d56cf0d62a8" translate="yes" xml:space="preserve">
          <source>Avoid reliance on side effects in the invariant. as the invariant may or may not be executed.</source>
          <target state="translated">Evite depender de los efectos secundarios en el invariante,ya que el invariante puede o no ejecutarse.</target>
        </trans-unit>
        <trans-unit id="9a2c3569f4cdef214baa0f7dccd251b7796ef000" translate="yes" xml:space="preserve">
          <source>Avoid using empty structs as parameters or arguments to variadic functions.</source>
          <target state="translated">Evite utilizar estructuras vacías como parámetros o argumentos para las funciones variadas.</target>
        </trans-unit>
        <trans-unit id="aa27a565a88b1217ee8242e278c52dfa4dc27415" translate="yes" xml:space="preserve">
          <source>Avoid using empty structs when interfacing with C and C++ code.</source>
          <target state="translated">Evita usar estructuras vacías cuando interactúes con el código C y C++.</target>
        </trans-unit>
        <trans-unit id="fa97dd47910ed157d733ff928c6533de2cbdb883" translate="yes" xml:space="preserve">
          <source>A|B</source>
          <target state="translated">A|B</target>
        </trans-unit>
        <trans-unit id="ee75ef351995c342c1fa5ff34f0c8888a0c4023e" translate="yes" xml:space="preserve">
          <source>B &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">B &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ed32df2c72f22e8029196feaab8d830b375f94a9" translate="yes" xml:space="preserve">
          <source>B &lt;code&gt;begin&lt;/code&gt;</source>
          <target state="translated">B &lt;code&gt;begin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9228bacbd6367d63160ad16de9da2a5dc0a4c8ac" translate="yes" xml:space="preserve">
          <source>B &lt;strong id=&quot;select&quot;&gt;select&lt;/strong&gt;(bool cond : false, A, B)(lazy A a, B b);</source>
          <target state="translated">B &lt;strong id=&quot;select&quot;&gt;select&lt;/strong&gt; (bool cond: false, A, B) (perezoso A a, B b);</target>
        </trans-unit>
        <trans-unit id="38af9591e3fb4695fab9bf9aa8e4b04997260819" translate="yes" xml:space="preserve">
          <source>BE stands for BlockExit.</source>
          <target state="translated">BE significa BlockExit.</target>
        </trans-unit>
        <trans-unit id="f18291c5630b11c70838e02838757f776b664e5c" translate="yes" xml:space="preserve">
          <source>BE.xxxx</source>
          <target state="translated">BE.xxxx</target>
        </trans-unit>
        <trans-unit id="a8ac71a34c4bf8d47fcd34a3bb48e39638e1c9c2" translate="yes" xml:space="preserve">
          <source>BEL (alarm) character (U+0007).</source>
          <target state="translated">Carácter de BEL (alarma)(U+0007).</target>
        </trans-unit>
        <trans-unit id="c4c51eeb133480a8ab13e2aac716dc1c49511996" translate="yes" xml:space="preserve">
          <source>BODY</source>
          <target state="translated">BODY</target>
        </trans-unit>
        <trans-unit id="4248a9b200b0703a243217afa7ea61bb6e9a6078" translate="yes" xml:space="preserve">
          <source>BOM</source>
          <target state="translated">BOM</target>
        </trans-unit>
        <trans-unit id="9e5d541d33dd4e690757280921ed4737bc5066d7" translate="yes" xml:space="preserve">
          <source>BUILTIN &lt;strong id=&quot;builtin&quot;&gt;builtin&lt;/strong&gt;;</source>
          <target state="translated">CONSTRUIDO &lt;strong id=&quot;builtin&quot;&gt;incorporado&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="e08e1bc55cdffceca473579010d3eed8f80f3da4" translate="yes" xml:space="preserve">
          <source>BUILTIN &lt;strong id=&quot;isBuiltin&quot;&gt;isBuiltin&lt;/strong&gt;(FuncDeclaration fd);</source>
          <target state="translated">BUILTIN &lt;strong id=&quot;isBuiltin&quot;&gt;isBuiltin&lt;/strong&gt; (FuncDeclaration fd);</target>
        </trans-unit>
        <trans-unit id="2ba208c7a57215fe25a2dc8edeb1eed6d80c323c" translate="yes" xml:space="preserve">
          <source>Back references</source>
          <target state="translated">Referencias anteriores</target>
        </trans-unit>
        <trans-unit id="cc6aace08575981676ef15b08f05eb45989c65af" translate="yes" xml:space="preserve">
          <source>Back-end type seldom used directly by user code. Two commonly-used types using &lt;code&gt;VariantN&lt;/code&gt; are:</source>
          <target state="translated">El tipo de fondo rara vez se usa directamente por el c&amp;oacute;digo de usuario. Dos tipos de uso &lt;code&gt;VariantN&lt;/code&gt; usan VariantN son:</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="59c009b9aac36256a825b962a8506069b93a0cd0" translate="yes" xml:space="preserve">
          <source>Backspace (U+0008).</source>
          <target state="translated">Retroceso (U+0008).</target>
        </trans-unit>
        <trans-unit id="cc460f6a8460cfc0b7f80f1ff3a6c734e2b3ea57" translate="yes" xml:space="preserve">
          <source>Backward.</source>
          <target state="translated">Backward.</target>
        </trans-unit>
        <trans-unit id="be7e10d1c5dd2ad77f6d5a617372a7bf013cb7bf" translate="yes" xml:space="preserve">
          <source>Bad</source>
          <target state="translated">Bad</target>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="a4ba5616fd448eeba2a0c6f11c812abe221ea915" translate="yes" xml:space="preserve">
          <source>Bamum Supplement</source>
          <target state="translated">Suplemento de Bamum</target>
        </trans-unit>
        <trans-unit id="8e0abbaab6b20b6084d656b5fa956a7ead91c3cf" translate="yes" xml:space="preserve">
          <source>Bare URLs</source>
          <target state="translated">URLs desnudas</target>
        </trans-unit>
        <trans-unit id="f70b3222f4784cd8b2d7fa95c5e6ff653751d799" translate="yes" xml:space="preserve">
          <source>Bare URLs are sequences of characters that start with &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;, continue with one or more characters from the set of letters, digits and &lt;code&gt;-_?=%&amp;amp;/+#~.&lt;/code&gt;, and contain at least one period. URL recognition happens before all macro text substitution. The URL is wrapped in a &lt;code&gt;&amp;amp;dollar;(DDOC_LINK_AUTODETECT)&lt;/code&gt; macro and is otherwise left untouched.</source>
          <target state="translated">Las URL desnudas son secuencias de caracteres que comienzan con &lt;code&gt;http://&lt;/code&gt; o &lt;code&gt;https://&lt;/code&gt; , contin&amp;uacute;an con uno o m&amp;aacute;s caracteres del conjunto de letras, d&amp;iacute;gitos y &lt;code&gt;-_?=%&amp;amp;/+#~.&lt;/code&gt; y contener al menos un punto. El reconocimiento de URL ocurre antes de toda sustituci&amp;oacute;n de texto macro. La URL est&amp;aacute; envuelta en una macro &lt;code&gt;&amp;amp;dollar;(DDOC_LINK_AUTODETECT)&lt;/code&gt; y, de lo contrario, no se modifica .</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="fb6d805e2be11428f917d98dd4e9cac7ed971f88" translate="yes" xml:space="preserve">
          <source>Base Types</source>
          <target state="translated">Tipos de base</target>
        </trans-unit>
        <trans-unit id="cc110ca211bf143dd27dd71bfdb7b015a52cf91f" translate="yes" xml:space="preserve">
          <source>Base class construction is done by calling the base class constructor by the name &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">La construcci&amp;oacute;n de la clase base se realiza llamando al constructor de la clase base por el nombre &lt;code&gt;super&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da5e0d7ff0c3f501f663124890a539611d14d952" translate="yes" xml:space="preserve">
          <source>Base class for synchronization errors.</source>
          <target state="translated">Clase base para errores de sincronización.</target>
        </trans-unit>
        <trans-unit id="c38a7f6f1cb2f71a182073d464805a1edb6ea0e7" translate="yes" xml:space="preserve">
          <source>Base class for synchronization exceptions.</source>
          <target state="translated">Clase base para excepciones de sincronización.</target>
        </trans-unit>
        <trans-unit id="672c3fd9686f0e99c9f798afb18e998c05c3a884" translate="yes" xml:space="preserve">
          <source>Base class for thread errors to be used for function inside GC when allocations are unavailable.</source>
          <target state="translated">Clase base para errores de hilo que se utilizará para la función dentro de GC cuando las asignaciones no estén disponibles.</target>
        </trans-unit>
        <trans-unit id="db07e1efbf8851dc009b2f7a1cf1562018684f57" translate="yes" xml:space="preserve">
          <source>Base class for thread exceptions.</source>
          <target state="translated">Clase base para las excepciones de los hilos.</target>
        </trans-unit>
        <trans-unit id="b0f6bbd9a7204a011357ddbe15da4f159805a9c3" translate="yes" xml:space="preserve">
          <source>Base classes are a list of these.</source>
          <target state="translated">Las clases base son una lista de éstas.</target>
        </trans-unit>
        <trans-unit id="72c50689eae38c1c7d83b57fc2a2426479cefce2" translate="yes" xml:space="preserve">
          <source>Base exception thrown by &lt;code&gt;std.socket&lt;/code&gt;.</source>
          <target state="translated">Excepci&amp;oacute;n base lanzada por &lt;code&gt;std.socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05df8270dbce2a852d75025619c0b4d03bd1da5f" translate="yes" xml:space="preserve">
          <source>BaseClass* &lt;strong id=&quot;interfaceVirtual&quot;&gt;interfaceVirtual&lt;/strong&gt;;</source>
          <target state="translated">BaseClass * &lt;strong id=&quot;interfaceVirtual&quot;&gt;interfaceVirtual&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="22f60185c7bbe04f26adbe40ecfd3daf1c5e1e4a" translate="yes" xml:space="preserve">
          <source>Based on a design by Mikola Lysenko.</source>
          <target state="translated">Basado en un diseño de Mikola Lysenko.</target>
        </trans-unit>
        <trans-unit id="b9c44f636926230213ca4c58bc4bd5fa1a395472" translate="yes" xml:space="preserve">
          <source>Based on code written by Regan Heath</source>
          <target state="translated">Basado en el código escrito por Regan Heath</target>
        </trans-unit>
        <trans-unit id="8a178898d54dc17c11ed3e0694b1794aa76cee7f" translate="yes" xml:space="preserve">
          <source>Based on ideas in Table 3.1 from &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt; Modern C++ Design&lt;/a&gt;, Andrei Alexandrescu (Addison-Wesley Professional, 2001)</source>
          <target state="translated">Basado en las ideas de la tabla 3.1 de &lt;a href=&quot;http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768&quot;&gt;Modern C ++ Design&lt;/a&gt; , Andrei Alexandrescu (Addison-Wesley Professional, 2001)</target>
        </trans-unit>
        <trans-unit id="74c70ad4dc394c37a35d8a9a02d3bbf206c6a2c3" translate="yes" xml:space="preserve">
          <source>Baseok &lt;strong id=&quot;baseok&quot;&gt;baseok&lt;/strong&gt;;</source>
          <target state="translated">Baseok &lt;strong id=&quot;baseok&quot;&gt;baseok&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2958841f21ba5aab25e4b9de01c61072c4396f05" translate="yes" xml:space="preserve">
          <source>Basic (default)</source>
          <target state="translated">Básico (por defecto)</target>
        </trans-unit>
        <trans-unit id="0376175c25ef469be8d7167b7c3f076d8a83135c" translate="yes" xml:space="preserve">
          <source>Basic Data Types</source>
          <target state="translated">Tipos de datos básicos</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">Ejemplo básico</target>
        </trans-unit>
        <trans-unit id="e19913977bf78df5f5b70c758a83b5ae4241e38e" translate="yes" xml:space="preserve">
          <source>Basic Latin</source>
          <target state="translated">Latín básico</target>
        </trans-unit>
        <trans-unit id="0c51e02cc99b54172f7d7ba26283b9a2651139e1" translate="yes" xml:space="preserve">
          <source>Basic Logging</source>
          <target state="translated">Registro básico</target>
        </trans-unit>
        <trans-unit id="c1025054c73b30fcc4ab113e76ab64be203331d7" translate="yes" xml:space="preserve">
          <source>Basic SMTP protocol support.</source>
          <target state="translated">Soporte de protocolo SMTP básico.</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes" xml:space="preserve">
          <source>Basic Types</source>
          <target state="translated">Tipos básicos</target>
        </trans-unit>
        <trans-unit id="bf25bdb7baac4ca40f143b32bfd463f5aa35f794" translate="yes" xml:space="preserve">
          <source>Basic and dumm visitor which implements a visit method for each AST node implemented in AST. This visitor is the parent of strict, transitive and permissive visitors.</source>
          <target state="translated">Visitante básico y dumm que implementa un método de visita para cada nodo del AST implementado en el AST.Este visitante es el padre de los visitantes estrictos,transitivos y permisivos.</target>
        </trans-unit>
        <trans-unit id="da424bc11d72f3a523d822671599c05d2482dd43" translate="yes" xml:space="preserve">
          <source>Basic block control flow operators.</source>
          <target state="translated">Operadores de flujo de control de bloque básico.</target>
        </trans-unit>
        <trans-unit id="55069311e393b3bc10e5288945ff6aebf4b60dce" translate="yes" xml:space="preserve">
          <source>Basic blocks: Basic blocks are a linked list of all the basic blocks in a function. startblock heads the list.</source>
          <target state="translated">Bloques básicos:Los bloques básicos son una lista enlazada de todos los bloques básicos de una función.El bloque inicial encabeza la lista.</target>
        </trans-unit>
        <trans-unit id="b015bc27621ab2a6e58582de340627d2513e110c" translate="yes" xml:space="preserve">
          <source>Basic data types are leaf types. Derived data types build on leaf types. User defined types are aggregates of basic and derived types.</source>
          <target state="translated">Los tipos de datos básicos son los tipos de hojas.Los tipos de datos derivados se basan en los tipos de hojas.Los tipos definidos por el usuario son agregados de tipos básicos y derivados.</target>
        </trans-unit>
        <trans-unit id="c76e778b9531849f5fdc3371b8bf8a9576ca93cb" translate="yes" xml:space="preserve">
          <source>Basic splitting with characters and numbers.</source>
          <target state="translated">División básica con caracteres y números.</target>
        </trans-unit>
        <trans-unit id="22d64c70202f0fd0175e71294c1f0654ef85c43d" translate="yes" xml:space="preserve">
          <source>Basic support for lock-free concurrent programming.</source>
          <target state="translated">Soporte básico para la programación simultánea sin bloqueo.</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="f3a7ec26a786494d0ab6bd615e7d7023643666db" translate="yes" xml:space="preserve">
          <source>Be wary of CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal') attacks. &lt;a href=&quot;http://cwe.mitre.org/data/definitions/22.html&quot;&gt;http://cwe.mitre.org/data/definitions/22.html&lt;/a&gt; More info: &lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&quot;&gt;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&lt;/a&gt;</source>
          <target state="translated">Tenga cuidado con CWE-22: Limitaci&amp;oacute;n inadecuada de un nombre de ruta a un directorio restringido ('Recorrido de ruta'). &lt;a href=&quot;http://cwe.mitre.org/data/definitions/22.html&quot;&gt;http://cwe.mitre.org/data/definitions/22.html&lt;/a&gt; M&amp;aacute;s informaci&amp;oacute;n: &lt;a href=&quot;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources&quot;&gt;https://www.securecoding.cert.org/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating + de + fuentes + contaminadas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d9a6a84847309258cd9cad1f00b1d9b08270b36" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;MultiwayMerge&lt;/code&gt; does not allocate extra memory, it will leave &lt;code&gt;ror&lt;/code&gt; modified. Namely, &lt;code&gt;MultiwayMerge&lt;/code&gt; assumes ownership of &lt;code&gt;ror&lt;/code&gt; and discretionarily swaps and advances elements of it. If you want &lt;code&gt;ror&lt;/code&gt; to preserve its contents after the call, you may want to pass a duplicate to &lt;code&gt;MultiwayMerge&lt;/code&gt; (and perhaps cache the duplicate in between calls).</source>
          <target state="translated">Debido a que &lt;code&gt;MultiwayMerge&lt;/code&gt; no asigna memoria adicional, dejar&amp;aacute; &lt;code&gt;ror&lt;/code&gt; modificado. A saber, &lt;code&gt;MultiwayMerge&lt;/code&gt; asume la propiedad de &lt;code&gt;ror&lt;/code&gt; e intercambia discrecionalmente y avanza elementos del mismo. Si quieres &lt;code&gt;ror&lt;/code&gt; para preservar su contenido despu&amp;eacute;s de la llamada, es posible que desee pasar un duplicado a &lt;code&gt;MultiwayMerge&lt;/code&gt; (y tal vez en cach&amp;eacute; el duplicado de una llamada a otra).</target>
        </trans-unit>
        <trans-unit id="34edc8e4b66b211204a07db61a02d64017fc4c94" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;largestPartialIntersection&lt;/code&gt; does not allocate extra memory, it will leave &lt;code&gt;ror&lt;/code&gt; modified. Namely, &lt;code&gt;largestPartialIntersection&lt;/code&gt; assumes ownership of &lt;code&gt;ror&lt;/code&gt; and discretionarily swaps and advances elements of it. If you want &lt;code&gt;ror&lt;/code&gt; to preserve its contents after the call, you may want to pass a duplicate to &lt;code&gt;largestPartialIntersection&lt;/code&gt; (and perhaps cache the duplicate in between calls).</source>
          <target state="translated">Debido a que &lt;code&gt;largestPartialIntersection&lt;/code&gt; no asigna memoria adicional, dejar&amp;aacute; &lt;code&gt;ror&lt;/code&gt; modificado. Es decir, la &lt;code&gt;largestPartialIntersection&lt;/code&gt; parte de la intersecci&amp;oacute;n parcial asume la propiedad de &lt;code&gt;ror&lt;/code&gt; e intercambia discrecionalmente y avanza elementos de la misma. Si quieres &lt;code&gt;ror&lt;/code&gt; para preservar su contenido despu&amp;eacute;s de la llamada, es posible que desee pasar un duplicado a &lt;code&gt;largestPartialIntersection&lt;/code&gt; (y tal vez en cach&amp;eacute; el duplicado de una llamada a otra).</target>
        </trans-unit>
        <trans-unit id="f9b6407740dfbc3c5fa141971e324ac38d1b4cc4" translate="yes" xml:space="preserve">
          <source>Because errors are unusual, execution of error handling code is not performance critical.</source>
          <target state="translated">Debido a que los errores son inusuales,la ejecución del código de manejo de errores no es crítica para el rendimiento.</target>
        </trans-unit>
        <trans-unit id="1362358bff14273f0cd677a86a2f16a4032a69e1" translate="yes" xml:space="preserve">
          <source>Because immutable is transitive, data referred to by an immutable is also immutable:</source>
          <target state="translated">Debido a que lo inmutable es transitivo,los datos a los que se refiere un inmutable también son inmutables:</target>
        </trans-unit>
        <trans-unit id="37a897f3827c71e8379bebae37724c5759dd60a2" translate="yes" xml:space="preserve">
          <source>Because it doesn't return the value, this function is cheaper than &lt;code&gt;get&lt;/code&gt;. However, if you do need the value as well, you should just check the return of &lt;code&gt;get&lt;/code&gt; for &lt;code&gt;null&lt;/code&gt; instead of using this function first.</source>
          <target state="translated">Como no devuelve el valor, esta funci&amp;oacute;n es m&amp;aacute;s barata que &lt;code&gt;get&lt;/code&gt; . Sin embargo, si tambi&amp;eacute;n necesita el valor, debe verificar el retorno de &lt;code&gt;get&lt;/code&gt; para &lt;code&gt;null&lt;/code&gt; lugar de usar esta funci&amp;oacute;n primero.</target>
        </trans-unit>
        <trans-unit id="46a9674034fbe47581e972f1a85b13b8dd6bc584" translate="yes" xml:space="preserve">
          <source>Because modules are not part of C++, each function with C++ linkage in the global namespace must be globally unique within the program.</source>
          <target state="translated">Debido a que los módulos no son parte de C++,cada función con enlace C++en el espacio de nombres global debe ser globalmente única dentro del programa.</target>
        </trans-unit>
        <trans-unit id="1a175b9174f2111e9e8065ab0dee738f3bde0af2" translate="yes" xml:space="preserve">
          <source>Because static arrays are passed to functions by value, a larger array can consume a lot of stack space. Use dynamic arrays instead.</source>
          <target state="translated">Debido a que los conjuntos estáticos se pasan a las funciones por valor,un conjunto más grande puede consumir mucho espacio de pila.Utiliza los arreglos dinámicos en su lugar.</target>
        </trans-unit>
        <trans-unit id="f36468f4c3a8d99449e93cf621c400036ac04c35" translate="yes" xml:space="preserve">
          <source>Because the allocator does not reuse memory, any dangling references to deallocated memory will always result in deterministically crashing the process.</source>
          <target state="translated">Dado que el asignador no reutiliza la memoria,cualquier referencia que cuelgue a la memoria deslocalizada siempre hará que el proceso se interrumpa de forma determinante.</target>
        </trans-unit>
        <trans-unit id="d8c3a61715e6c076e516e2adb94c24e13d1a7e0e" translate="yes" xml:space="preserve">
          <source>Because the reduction is being performed in parallel, &lt;code&gt;functions&lt;/code&gt; must be associative. For notational simplicity, let # be an infix operator representing &lt;code&gt;functions&lt;/code&gt;. Then, (a # b) # c must equal a # (b # c). Floating point addition is not associative even though addition in exact arithmetic is. Summing floating point numbers using this function may give different results than summing serially. However, for many practical purposes floating point addition can be treated as associative.</source>
          <target state="translated">Debido a que la reducci&amp;oacute;n se realiza en paralelo, las &lt;code&gt;functions&lt;/code&gt; deben ser asociativas. Para simplificar la notaci&amp;oacute;n, dejemos que # sea un operador infijo que represente &lt;code&gt;functions&lt;/code&gt; . Entonces, (a # b) # c debe ser igual a # (b # c). La adici&amp;oacute;n de punto flotante no es asociativa, aunque la adici&amp;oacute;n en aritm&amp;eacute;tica exacta s&amp;iacute; lo es. Sumar n&amp;uacute;meros de coma flotante usando esta funci&amp;oacute;n puede dar resultados diferentes que sumar en serie. Sin embargo, para muchos prop&amp;oacute;sitos pr&amp;aacute;cticos, la adici&amp;oacute;n de coma flotante puede tratarse como asociativa.</target>
        </trans-unit>
        <trans-unit id="b6b9c971f1d02fbd8d1af3306f1013bb85ae0126" translate="yes" xml:space="preserve">
          <source>Because the validity of the day number depends on both on the year and month of which the day is occurring, take all three variables to validate the day.</source>
          <target state="translated">Debido a que la validez del número de día depende tanto del año como del mes en que se produce el día,tome las tres variables para validar el día.</target>
        </trans-unit>
        <trans-unit id="04beefc07e753c0350f57ce75d35ae3795bc6efa" translate="yes" xml:space="preserve">
          <source>Because there are no units larger than years, there is no difference between adding and rolling years.</source>
          <target state="translated">Debido a que no hay unidades más grandes que los años,no hay diferencia entre sumar y restar años.</target>
        </trans-unit>
        <trans-unit id="8b9fa636d60436156ac4d9755dc04095e1b03ef6" translate="yes" xml:space="preserve">
          <source>Before the function actually returns, any objects with scope storage duration are destroyed, any enclosing finally clauses are executed, any scope(exit) statements are executed, any scope(success) statements are executed, and any enclosing synchronization objects are released.</source>
          <target state="translated">Antes de que la función regrese realmente,se destruyen todos los objetos con duración de almacenamiento del alcance,se ejecutan todas las cláusulas de cierre,se ejecutan todas las declaraciones de salida del alcance,se ejecutan todas las declaraciones de éxito del alcance y se liberan todos los objetos de sincronización del alcance.</target>
        </trans-unit>
        <trans-unit id="29b56d3b3ce732a418c6733f4aa512d819b9b955" translate="yes" xml:space="preserve">
          <source>Begins a full collection. While the meaning of this may change based on the garbage collector implementation, typical behavior is to scan all stack segments for roots, mark accessible memory blocks as alive, and then to reclaim free space. This action may need to suspend all running threads for at least part of the collection process.</source>
          <target state="translated">Comienza una colección completa.Aunque el significado de esto puede cambiar según la implementación del recolector de basura,el comportamiento típico es escanear todos los segmentos de la pila en busca de raíces,marcar los bloques de memoria accesibles como vivos,y luego reclamar el espacio libre.Esta acción puede necesitar suspender todos los hilos en marcha durante al menos una parte del proceso de recolección.</target>
        </trans-unit>
        <trans-unit id="a9290b213da7c41d3b9d381305e1a85dfd638ddf" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;#visit&quot;&gt;&lt;code&gt;visit&lt;/code&gt;&lt;/a&gt; but doesn't enforce that all types are handled by the visiting functions.</source>
          <target state="translated">Se comporta como &lt;a href=&quot;#visit&quot;&gt; &lt;code&gt;visit&lt;/code&gt; a&lt;/a&gt; pero no exige que las funciones de visita manejen todos los tipos.</target>
        </trans-unit>
        <trans-unit id="8671963c6358c10c30f0a9f60f5760e545d91151" translate="yes" xml:space="preserve">
          <source>Behaves like the identity function when args is empty.</source>
          <target state="translated">Se comporta como la función de identidad cuando los arcos están vacíos.</target>
        </trans-unit>
        <trans-unit id="f909782a90d0d82b3e7b38e26ebe9e00bc13126f" translate="yes" xml:space="preserve">
          <source>Being 100% compatible with C++ means more or less adding a fully functional C++ compiler front end to D. Anecdotal evidence suggests that writing such is a minimum of a 10 man-year project, essentially making a D compiler with such capability unimplementable. Other languages looking to hook up to C++ face the same problem, and the solutions have been:</source>
          <target state="translated">Ser 100% compatible con C++significa más o menos añadir un compilador de C++completamente funcional a D.La evidencia anecdótica sugiere que escribirlo es como mínimo un proyecto de 10 años-hombre,haciendo esencialmente inimaginable un compilador D con tal capacidad.Otros lenguajes que buscan conectarse a C++se enfrentan al mismo problema,y las soluciones han sido:</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="d6bc78c2edfd9a1e4a494692d443253b772c6030" translate="yes" xml:space="preserve">
          <source>Below here follows defines for the CURLOPT_IPRESOLVE option. If a host name resolves addresses using more than one IP protocol version, this option might be handy to force libcurl to use a specific IP version.</source>
          <target state="translated">A continuación se definen para la opción CURLOPT_IPRESOLVE.Si un nombre de host resuelve las direcciones usando más de una versión del protocolo IP,esta opción puede ser útil para forzar a libcurl a usar una versión IP específica.</target>
        </trans-unit>
        <trans-unit id="8b8ee9a8f224bc381d10b9725300af6e8ad60b2f" translate="yes" xml:space="preserve">
          <source>Below is the table of names accepted by &lt;a href=&quot;#unicode.hangulSyllableType&quot;&gt;&lt;code&gt;unicode.hangulSyllableType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra la tabla de nombres aceptados por &lt;a href=&quot;#unicode.hangulSyllableType&quot;&gt; &lt;code&gt;unicode.hangulSyllableType&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f460beb4086eb83db26145c0c14bfc2836a2dd77" translate="yes" xml:space="preserve">
          <source>Below is the table with block names accepted by &lt;a href=&quot;#unicode.block&quot;&gt;&lt;code&gt;unicode.block&lt;/code&gt;&lt;/a&gt;. Note that the shorthand version &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt; requires &quot;In&quot; to be prepended to the names of blocks so as to disambiguate scripts and blocks.</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra la tabla con los nombres de bloque aceptados por &lt;a href=&quot;#unicode.block&quot;&gt; &lt;code&gt;unicode.block&lt;/code&gt; &lt;/a&gt; . Tenga en cuenta que la versi&amp;oacute;n abreviada &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; requiere que &quot;In&quot; se anteponga a los nombres de los bloques para desambiguar los scripts y los bloques.</target>
        </trans-unit>
        <trans-unit id="c16ded473b8d6a501e3afbf1d6b1aaa3bb67b9a5" translate="yes" xml:space="preserve">
          <source>Below is the table with script names accepted by &lt;a href=&quot;#unicode.script&quot;&gt;&lt;code&gt;unicode.script&lt;/code&gt;&lt;/a&gt; and by the shorthand version &lt;a href=&quot;#unicode&quot;&gt;&lt;code&gt;unicode&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra la tabla con los nombres de script aceptados por &lt;a href=&quot;#unicode.script&quot;&gt; &lt;code&gt;unicode.script&lt;/code&gt; &lt;/a&gt; y por la versi&amp;oacute;n abreviada &lt;a href=&quot;#unicode&quot;&gt; &lt;code&gt;unicode&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5cce75cef6b6f1b3c31bc07730b294f2256592a7" translate="yes" xml:space="preserve">
          <source>Benchmark with two functions comparing.</source>
          <target state="translated">Comparación de dos funciones.</target>
        </trans-unit>
        <trans-unit id="aa8cbccdf814344c472fdc83108ce95f463d76c2" translate="yes" xml:space="preserve">
          <source>Benchmarks code for speed assessment and comparison.</source>
          <target state="translated">Código de referencia para la evaluación y comparación de la velocidad.</target>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="39b464ae10a3403acc76206ce3373cf277ad5588" translate="yes" xml:space="preserve">
          <source>Beta function</source>
          <target state="translated">Función Beta</target>
        </trans-unit>
        <trans-unit id="6cf60f60aed600fb3f70f4f199ce23160c46df50" translate="yes" xml:space="preserve">
          <source>Better C</source>
          <target state="translated">Mejor C</target>
        </trans-unit>
        <trans-unit id="fa66737ffd71fbd94c99a79ae1d7c0f7a3f83f97" translate="yes" xml:space="preserve">
          <source>Bidi_Control</source>
          <target state="translated">Bidi_Control</target>
        </trans-unit>
        <trans-unit id="c1dd854953db9a48bc0d0ea0a3df0b423f22bafe" translate="yes" xml:space="preserve">
          <source>Bidirectional primitives. They are offered if &lt;code&gt; isBidirectionalRange!RangeOfRanges&lt;/code&gt;.</source>
          <target state="translated">Primitivas bidireccionales. Se ofrecen si &lt;code&gt; isBidirectionalRange!RangeOfRanges&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd2b2945fcece1d7de6dc41f877ba8c67c13689" translate="yes" xml:space="preserve">
          <source>Bidirectional range of elements</source>
          <target state="translated">Rango bidireccional de elementos</target>
        </trans-unit>
        <trans-unit id="019ef9f3f8b5262d462588c43fd756f3913eee2d" translate="yes" xml:space="preserve">
          <source>Bidirectional range primitives. Provided only if both &lt;code&gt;hasSlicing!Source&lt;/code&gt; and &lt;code&gt;hasLength!Source&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Gama primitiva bidireccional. Solo se proporciona si ambos &lt;code&gt;hasSlicing!Source&lt;/code&gt; y &lt;code&gt;hasLength!Source&lt;/code&gt; son &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71bfb07d0cb12b1ba4834790c7322d9de720c8a3" translate="yes" xml:space="preserve">
          <source>BidirectionalRange &lt;code&gt;range&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; bidireccional</target>
        </trans-unit>
        <trans-unit id="635846f5f8a3535fe06ebe7bdfb132d87f3a3a9b" translate="yes" xml:space="preserve">
          <source>Big endian byte order</source>
          <target state="translated">Gran orden de bytes endianos</target>
        </trans-unit>
        <trans-unit id="880ccaf424d3d59837e9afca21d218a82696d56c" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;base&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; BigInt</target>
        </trans-unit>
        <trans-unit id="15d8e19b48cf73cfcbd5673d000427a6c89fe0cf" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;dividend&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dividend&lt;/code&gt; BigInt</target>
        </trans-unit>
        <trans-unit id="6bf4e8892121a909f8719ff5ba16cf85f8324a8e" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;divisor&lt;/code&gt;</source>
          <target state="translated">Bigint &lt;code&gt;divisor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf9d72c5e7f7fec77eccf61954e6a190a6919e39" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;exponent&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exponent&lt;/code&gt; BigInt</target>
        </trans-unit>
        <trans-unit id="8d09af76576312e7fbdeb58e15f85ddf03bdfeca" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;modulus&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;modulus&lt;/code&gt; BigInt</target>
        </trans-unit>
        <trans-unit id="6719bddb8d0310ee6d49cac219e4be2a60dd859e" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;quotient&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;quotient&lt;/code&gt; BigInt</target>
        </trans-unit>
        <trans-unit id="6acf46d3f9c34c441344f4052f380185deff090a" translate="yes" xml:space="preserve">
          <source>BigInt &lt;code&gt;remainder&lt;/code&gt;</source>
          <target state="translated">BigInt &lt;code&gt;remainder&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc0d6128e74b8ffa38299adc002109eff669779d" translate="yes" xml:space="preserve">
          <source>BigInt implements value semantics using copy-on-write. This means that assignment is cheap, but operations such as x++ will cause heap allocation. (But note that for most bigint operations, heap allocation is inevitable anyway.)</source>
          <target state="translated">BigInt implementa la semántica de valores usando la copia en la escritura.Esto significa que la asignación es barata,pero las operaciones como x++causarán una asignación en montón.(Pero ten en cuenta que para la mayoría de las operaciones de bigint,la asignación de heap es inevitable de todos modos.)</target>
        </trans-unit>
        <trans-unit id="2ae987b3c8b155139b22a17dacfded40cd54d6e8" translate="yes" xml:space="preserve">
          <source>Binary Operator Overloading</source>
          <target state="translated">Sobrecarga del operador binario</target>
        </trans-unit>
        <trans-unit id="7ea3f10d7dc50a5d1d60c584be4ba66327be2344" translate="yes" xml:space="preserve">
          <source>Binary exponentiation</source>
          <target state="translated">La exponenciación binaria</target>
        </trans-unit>
        <trans-unit id="bc0e2dd063d01cb0a49d6952e1a447f5a0786666" translate="yes" xml:space="preserve">
          <source>Binary expressions except for &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt;, &lt;a href=&quot;#OrOrExpression&quot;&gt;&lt;i&gt;OrOrExpression&lt;/i&gt;&lt;/a&gt;, and &lt;a href=&quot;#AndAndExpression&quot;&gt;&lt;i&gt;AndAndExpression&lt;/i&gt;&lt;/a&gt; are evaluated in lexical order (left-to-right). Example:</source>
          <target state="translated">Las expresiones binarias, excepto &lt;a href=&quot;#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; , &lt;a href=&quot;#OrOrExpression&quot;&gt;&lt;i&gt;OrOrExpression&lt;/i&gt;&lt;/a&gt; y &lt;a href=&quot;#AndAndExpression&quot;&gt;&lt;i&gt;AndAndExpression,&lt;/i&gt;&lt;/a&gt; se eval&amp;uacute;an en orden l&amp;eacute;xico (de izquierda a derecha). Ejemplo:</target>
        </trans-unit>
        <trans-unit id="3f59323ff0289ed186c342bdb4f9ade9bee4b594" translate="yes" xml:space="preserve">
          <source>Binary files: Number of bytes to offset from origin.</source>
          <target state="translated">Archivos binarios:Número de bytes para compensar el origen.</target>
        </trans-unit>
        <trans-unit id="5ec3f5b7c67a25b307ee5761394fbc7f85f5c4ec" translate="yes" xml:space="preserve">
          <source>Binary files: Position used as reference for the offset, must be one of &lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt;, &lt;a href=&quot;core_stdc_stdio#SEEK_CUR&quot;&gt;SEEK_CUR&lt;/a&gt; or &lt;a href=&quot;core_stdc_stdio#SEEK_END&quot;&gt;SEEK_END&lt;/a&gt;.</source>
          <target state="translated">Archivos binarios: la posici&amp;oacute;n utilizada como referencia para el desplazamiento debe ser &lt;a href=&quot;core_stdc_stdio#SEEK_SET&quot;&gt;SEEK_SET&lt;/a&gt; , &lt;a href=&quot;core_stdc_stdio#SEEK_CUR&quot;&gt;SEEK_CUR&lt;/a&gt; o &lt;a href=&quot;core_stdc_stdio#SEEK_END&quot;&gt;SEEK_END&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="710001c86b903db5ac28284015f70ad29d702165" translate="yes" xml:space="preserve">
          <source>Binary integers are a sequence of binary digits preceded by a &amp;lsquo;0b&amp;rsquo; or &amp;lsquo;0B&amp;rsquo;.</source>
          <target state="translated">Los enteros binarios son una secuencia de d&amp;iacute;gitos binarios precedidos por un '0b' o '0B'.</target>
        </trans-unit>
        <trans-unit id="e30449766634fc47649993e043f53913e318f363" translate="yes" xml:space="preserve">
          <source>Binary operations: subtracting and intersecting flags</source>
          <target state="translated">Operaciones binarias:sustracción e intersección de banderas</target>
        </trans-unit>
        <trans-unit id="5bc41f55b9ac5ad602ac2a15812f4fa17e719258" translate="yes" xml:space="preserve">
          <source>Binary predicate for determining equivalence of two elements.</source>
          <target state="translated">Predicato binario para determinar la equivalencia de dos elementos.</target>
        </trans-unit>
        <trans-unit id="1b5c4d6f642263934709007da433b44cfafe3dfa" translate="yes" xml:space="preserve">
          <source>Binary predicate that reverses the order of arguments, e.g., given &lt;code&gt;pred(a, b)&lt;/code&gt;, returns &lt;code&gt;pred(b, a)&lt;/code&gt;.</source>
          <target state="translated">El predicado binario que invierte el orden de los argumentos, por ejemplo, dado &lt;code&gt;pred(a, b)&lt;/code&gt; , devuelve &lt;code&gt;pred(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3390f0873b37228eb9da1981c4edea13376f4ce4" translate="yes" xml:space="preserve">
          <source>Binary zero (NUL, U+0000).</source>
          <target state="translated">Cero binario (NUL,U+0000).</target>
        </trans-unit>
        <trans-unit id="f07c525c75d6754496cc9e553ac6cf1931c4d038" translate="yes" xml:space="preserve">
          <source>BinaryHeap!(Store, less) &lt;strong id=&quot;heapify&quot;&gt;heapify&lt;/strong&gt;(alias less = &quot;a &amp;lt; b&quot;, Store)(Store s, size_t initialSize = size_t.max);</source>
          <target state="translated">BinaryHeap! (Store, less) &lt;strong id=&quot;heapify&quot;&gt;heapify&lt;/strong&gt; (alias less = &quot;a &amp;lt;b&quot;, Store) (Store s, size_t initialSize = size_t.max);</target>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="translated">Valores vinculantes para las declaraciones preparadas</target>
        </trans-unit>
        <trans-unit id="29d9453c80dc53e32cc00f3280980ce7ea8a0687" translate="yes" xml:space="preserve">
          <source>Binding for ::operator delete(void* ptr)</source>
          <target state="translated">Vinculación para ::operador borrar(void*ptr)</target>
        </trans-unit>
        <trans-unit id="f7d97838adda037dd541956c0b38a3516ae36925" translate="yes" xml:space="preserve">
          <source>Binding for ::operator delete(void* ptr, const std::nothrow_t&amp;amp; tag)</source>
          <target state="translated">Enlace para :: operador eliminar (void * ptr, const std :: nothrow_t &amp;amp; tag)</target>
        </trans-unit>
        <trans-unit id="9e8bd6d0542a61db39dc7370f4ff9f5bdec532e6" translate="yes" xml:space="preserve">
          <source>Binding for ::operator new(std::size_t count)</source>
          <target state="translated">Vinculación para ::operador nuevo(std::tamaño_t cuenta)</target>
        </trans-unit>
        <trans-unit id="c9209fa1a437c94943e83fdcf912d410e070a043" translate="yes" xml:space="preserve">
          <source>Binding for ::operator new(std::size_t count, const std::nothrow_t&amp;amp;)</source>
          <target state="translated">Enlace para :: operator new (std :: size_t count, const std :: nothrow_t &amp;amp;)</target>
        </trans-unit>
        <trans-unit id="c595af9a225910870bb198153cb9e584ec6c2237" translate="yes" xml:space="preserve">
          <source>Binds the internal state to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Vincula el estado interno al &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e718a122aa87d12e98c5f3055711cc94d264e1c" translate="yes" xml:space="preserve">
          <source>Bionic C runtime</source>
          <target state="translated">Tiempo de ejecución del Biónico C</target>
        </trans-unit>
        <trans-unit id="cec8cf9a0b27bd714792dac06606e5c1b0178367" translate="yes" xml:space="preserve">
          <source>Bit constructs</source>
          <target state="translated">Las construcciones de bits</target>
        </trans-unit>
        <trans-unit id="70402e7ad10ad5f2124d70b6b5dfed369e14c974" translate="yes" xml:space="preserve">
          <source>Bit decoding of the TargetOS</source>
          <target state="translated">Decodificación de bits del TargetOS</target>
        </trans-unit>
        <trans-unit id="da97ac52d02a77703c633362dd74456458d249b2" translate="yes" xml:space="preserve">
          <source>Bit fields are supported with the &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;bitfields&lt;/a&gt; template.</source>
          <target state="translated">Los campos de bits son compatibles con la plantilla de campos de &lt;a href=&quot;https://dlang.org/phobos/std_bitmanip.html#bitfields&quot;&gt;bits&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11ee76002d783da853ef20847f30176e5d03ae44" translate="yes" xml:space="preserve">
          <source>Bit flipping</source>
          <target state="translated">Un poco de giro...</target>
        </trans-unit>
        <trans-unit id="8f76655665dcf73e363d56fc2df9877070986357" translate="yes" xml:space="preserve">
          <source>Bit wise expressions perform a bitwise operation on their operands. Their operands must be integral types. First, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are done. Then, the bitwise operation is done.</source>
          <target state="translated">Las expresiones sabias en bits realizan una operaci&amp;oacute;n bit a bit en sus operandos. Sus operandos deben ser tipos integrales. Primero, se realizan las &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;conversiones aritm&amp;eacute;ticas habituales&lt;/a&gt; . Luego, se realiza la operaci&amp;oacute;n bit a bit.</target>
        </trans-unit>
        <trans-unit id="0ab61da13a6c10abbc480c4a1c0747cb3baa6877" translate="yes" xml:space="preserve">
          <source>Bit-level manipulation facilities.</source>
          <target state="translated">Instalaciones de manipulación a nivel de bits.</target>
        </trans-unit>
        <trans-unit id="d9eff8dc4264242a1ae12f932821b47da28a5cc7" translate="yes" xml:space="preserve">
          <source>Bitwise Expressions</source>
          <target state="translated">Expresiones de bits</target>
        </trans-unit>
        <trans-unit id="df5079d347ee1e4244353fecfac2f5edf6b28c3c" translate="yes" xml:space="preserve">
          <source>Bitwise adapter over an integral type range. Consumes the range elements bit by bit, from the least significant bit to the most significant bit.</source>
          <target state="translated">Adaptador de bits sobre un rango de tipo integral.Consume los elementos de la gama poco a poco,desde el bit menos significativo hasta el bit más significativo.</target>
        </trans-unit>
        <trans-unit id="9b504c7d294e8d9e76232c80318479234720041d" translate="yes" xml:space="preserve">
          <source>Bitwise rotate &lt;code&gt;value&lt;/code&gt; left (&lt;code&gt;rol&lt;/code&gt;) or right (&lt;code&gt;ror&lt;/code&gt;) by &lt;code&gt;count&lt;/code&gt; bit positions.</source>
          <target state="translated">Gire a la izquierda el &lt;code&gt;value&lt;/code&gt; izquierda ( &lt;code&gt;rol&lt;/code&gt; ) o hacia la derecha ( &lt;code&gt;ror&lt;/code&gt; ) &lt;code&gt;count&lt;/code&gt; las posiciones de bits.</target>
        </trans-unit>
        <trans-unit id="8ac6960d99f504b227c089027d841f4e9c385375" translate="yes" xml:space="preserve">
          <source>Block Elements</source>
          <target state="translated">Elementos de bloqueo</target>
        </trans-unit>
        <trans-unit id="44f23b923d4c118ace9751471e8a32d3ddca275e" translate="yes" xml:space="preserve">
          <source>Block Statement</source>
          <target state="translated">Declaración de bloqueo</target>
        </trans-unit>
        <trans-unit id="7358e14919f4d134af66ef6ad913b5a7d1139ac8" translate="yes" xml:space="preserve">
          <source>Block comments can span multiple lines, but do not nest.</source>
          <target state="translated">Los comentarios de bloque pueden abarcar varias líneas,pero no se anidan.</target>
        </trans-unit>
        <trans-unit id="7fbe37dc50c1260fc0044f00cb0158d89f4c81af" translate="yes" xml:space="preserve">
          <source>Block of memory to serve as support for the allocator. Memory must be larger than two words and word-aligned.</source>
          <target state="translated">Bloque de memoria para servir de apoyo al asignador.La memoria debe ser más grande que dos palabras y estar alineada con las palabras.</target>
        </trans-unit>
        <trans-unit id="ae0016c0671df573a3221620d651641a4c8dfdcc" translate="yes" xml:space="preserve">
          <source>Block previously obtained by a call to &lt;code&gt;allocate&lt;/code&gt; against this allocator (&lt;code&gt;null&lt;/code&gt; is allowed).</source>
          <target state="translated">Bloque obtenido previamente por una llamada para &lt;code&gt;allocate&lt;/code&gt; contra este asignador ( se permite &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3ccb689779e89b6ac603e18c3e2082f3bf5ed78f" translate="yes" xml:space="preserve">
          <source>Block to deallocate.</source>
          <target state="translated">Bloqueo para repartir.</target>
        </trans-unit>
        <trans-unit id="8117bd427e84d25123d525df198441ce5a262ba4" translate="yes" xml:space="preserve">
          <source>BlockStatement</source>
          <target state="translated">BlockStatement</target>
        </trans-unit>
        <trans-unit id="1c575a00b6c6472431006e69a67cda683c681cb6" translate="yes" xml:space="preserve">
          <source>BookkeepingAllocator</source>
          <target state="translated">BookkeepingAllocator</target>
        </trans-unit>
        <trans-unit id="642b597338266fa6f0fcfa51d03f6363e4f3af1d" translate="yes" xml:space="preserve">
          <source>BookkeepingAllocator &lt;strong id=&quot;bkalloc&quot;&gt;bkalloc&lt;/strong&gt;;</source>
          <target state="translated">BookkeepingAllocator &lt;strong id=&quot;bkalloc&quot;&gt;bkalloc&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="807b1864fdb6805b8347ae2bc9a6c20e8e44cbff" translate="yes" xml:space="preserve">
          <source>Boolean Operations</source>
          <target state="translated">Operaciones Booleanas</target>
        </trans-unit>
        <trans-unit id="9a7bb38540335c853c8483b5f52966e014c86be1" translate="yes" xml:space="preserve">
          <source>Boolean flag set to true while the runtime is initialized.</source>
          <target state="translated">Bandera booleana puesta en true mientras se inicia el tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="919ba0f721b82028f799116e9733b52309e726b3" translate="yes" xml:space="preserve">
          <source>Boolean options</source>
          <target state="translated">Opciones booleanas</target>
        </trans-unit>
        <trans-unit id="d62f48763e9c33e113d6e562d9814ef6092b4bb1" translate="yes" xml:space="preserve">
          <source>Boolean values are converted to &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401d2f1688a777ae0bc5be157d0d7272e332e127" translate="yes" xml:space="preserve">
          <source>Boolean values are printed as &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">Los valores booleanos se imprimen como &lt;code&gt;&quot;true&quot;&lt;/code&gt; o &lt;code&gt;&quot;false&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="105c6c86d7dd1b24e773395f017e7ee3c51ac8ff" translate="yes" xml:space="preserve">
          <source>Boost License 1.0</source>
          <target state="translated">Licencia Boost 1.0</target>
        </trans-unit>
        <trans-unit id="e47a3386c7e74d205f749769164e9ef5c8040834" translate="yes" xml:space="preserve">
          <source>Boost Signals</source>
          <target state="translated">Señales de impulso</target>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="5ba82cb02c720f3652f57a038e834a4bcc4c4c2f" translate="yes" xml:space="preserve">
          <source>Bopomofo Extended</source>
          <target state="translated">Bopomofo Extendido</target>
        </trans-unit>
        <trans-unit id="50d58ef5d04eba875c690e66a2db13e6043d0608" translate="yes" xml:space="preserve">
          <source>Borrowed</source>
          <target state="translated">Borrowed</target>
        </trans-unit>
        <trans-unit id="a5cd3b3f934540f0788541fb598aaaad1cf890f6" translate="yes" xml:space="preserve">
          <source>Borrowers are considered Owners if they are initialized from other than a pointer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a58aa19fb67e0b5abe5d7641293ce8ffcd1a87d" translate="yes" xml:space="preserve">
          <source>Borrowers can be Owners</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60c93251f61201f166e2379b490f975956e31c4" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Algebraic&lt;/code&gt; and &lt;code&gt;Variant&lt;/code&gt; share &lt;code&gt; VariantN&lt;/code&gt;'s interface. (See their respective documentations below.)</source>
          <target state="translated">Tanto &lt;code&gt;Algebraic&lt;/code&gt; como &lt;code&gt;Variant&lt;/code&gt; comparten la interfaz de &lt;code&gt; VariantN&lt;/code&gt; . (Ver sus respectivas documentaciones a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="6535ded07930e3ddda0a1fe0ceda88dc9ce33dfa" translate="yes" xml:space="preserve">
          <source>Both backward and forward.</source>
          <target state="translated">Tanto hacia atrás como hacia adelante.</target>
        </trans-unit>
        <trans-unit id="b8f7ae57cc9f0d657e03c01e9e4d98ba216ba14c" translate="yes" xml:space="preserve">
          <source>Both immutable and const are</source>
          <target state="translated">Tanto la inmutabilidad como la constancia son</target>
        </trans-unit>
        <trans-unit id="e6a3f4fd036b065b2e797530c76e1c67c7c891ad" translate="yes" xml:space="preserve">
          <source>Both isThis() and isNested() should return true if function needs a dual-context pointer, otherwise if isThis() returns true, isNested() should return false.</source>
          <target state="translated">Tanto isThis()como isNested()deben devolver true si la función necesita un puntero de doble contexto,de lo contrario si isThis()devuelve true,isNested()debe devolver false.</target>
        </trans-unit>
        <trans-unit id="bf39d0ca68e0898427724a5e452ff23fb939fa46" translate="yes" xml:space="preserve">
          <source>Both rewrites are tried. If only one compiles, that one is taken. If they both resolve to the same function, the first rewrite is done. If they resolve to different functions, the best matching one is used. If they both match the same, but are different functions, an ambiguity error results.</source>
          <target state="translated">Ambas reescrituras están probadas.Si sólo una compila,esa se toma.Si ambos resuelven la misma función,se hace la primera reescritura.Si se resuelven a diferentes funciones,se utiliza la que mejor se ajusta.Si ambas coinciden en la misma,pero son funciones diferentes,se produce un error de ambigüedad.</target>
        </trans-unit>
        <trans-unit id="0cd32d8791a4b901dbb6cc0f81dd64df4c40048e" translate="yes" xml:space="preserve">
          <source>Both the test and the return expressions are lazily evaluated.</source>
          <target state="translated">Tanto la expresión de prueba como la de retorno son evaluadas perezosamente.</target>
        </trans-unit>
        <trans-unit id="171f0c459de342d1f54dbc2ce2646745cc4ebc56" translate="yes" xml:space="preserve">
          <source>Both variants are implemented as instantiations of the template &lt;a href=&quot;#Base64Impl&quot;&gt;&lt;code&gt;Base64Impl&lt;/code&gt;&lt;/a&gt;. Most users will not need to use this template directly; however, it can be used to create customized Base64 encodings, such as one that omits padding characters, or one that is safe to embed inside a regular expression.</source>
          <target state="translated">Ambas variantes se implementan como instancias de la plantilla &lt;a href=&quot;#Base64Impl&quot;&gt; &lt;code&gt;Base64Impl&lt;/code&gt; &lt;/a&gt; . La mayor&amp;iacute;a de los usuarios no necesitar&amp;aacute;n usar esta plantilla directamente; sin embargo, se puede usar para crear codificaciones Base64 personalizadas, como una que omita caracteres de relleno, o una que sea segura para incrustar dentro de una expresi&amp;oacute;n regular.</target>
        </trans-unit>
        <trans-unit id="00d1805af0d734eef9db29bbdcf7d82b5d3e7f04" translate="yes" xml:space="preserve">
          <source>Box Drawing</source>
          <target state="translated">Dibujo de la caja</target>
        </trans-unit>
        <trans-unit id="b8d28f7a363659e9c4b08c47130a0d8f80f5c106" translate="yes" xml:space="preserve">
          <source>BoyerMooreFinder!(binaryFun!pred, Range) &lt;strong id=&quot;boyerMooreFinder&quot;&gt;boyerMooreFinder&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range needle)</source>
          <target state="translated">BoyerMooreFinder! (BinaryFun! Pred, Range) &lt;strong id=&quot;boyerMooreFinder&quot;&gt;boyerMooreFinder&lt;/strong&gt; (alias pred = &quot;a == b&quot;, Range) (aguja de rango)</target>
        </trans-unit>
        <trans-unit id="2a76fd949603813a813972f30d7b0eeea91480d5" translate="yes" xml:space="preserve">
          <source>BoyerMooreFinder!(pred, InputRange) &lt;code&gt;needle&lt;/code&gt;</source>
          <target state="translated">BoyerMooreFinder! (Pred, InputRange) &lt;code&gt;needle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e5a99860d31900d36389daa3fa718de031554d4" translate="yes" xml:space="preserve">
          <source>Brahmi</source>
          <target state="translated">Brahmi</target>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="754a680c22eb1f9ecca61fac281a3f23b7fb9d29" translate="yes" xml:space="preserve">
          <source>Braille Patterns</source>
          <target state="translated">Patrones de Braille</target>
        </trans-unit>
        <trans-unit id="b2fcd02a50371b93a9e3654260745ee0af90cca2" translate="yes" xml:space="preserve">
          <source>Break Statement</source>
          <target state="translated">Declaración de ruptura</target>
        </trans-unit>
        <trans-unit id="76820814ec6d343b49333e574d3bb22a7fa8676a" translate="yes" xml:space="preserve">
          <source>Break and Continue out of Foreach</source>
          <target state="translated">Romper y continuar fuera de Foreach</target>
        </trans-unit>
        <trans-unit id="0a89343c3ed16b2574554e37596ef4b4facffb9f" translate="yes" xml:space="preserve">
          <source>Breaking from a parallel foreach loop via a break, labeled break, labeled continue, return or goto statement throws a &lt;code&gt;ParallelForeachError&lt;/code&gt;.  In the case of non-random access ranges, parallel foreach buffers lazily to an array of size &lt;code&gt;workUnitSize&lt;/code&gt; before executing the parallel portion of the loop. The exception is that, if a parallel foreach is executed over a range returned by &lt;code&gt;asyncBuf&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt;, the copying is elided and the buffers are simply swapped. In this case &lt;code&gt;workUnitSize&lt;/code&gt; is ignored and the work unit size is set to the buffer size of &lt;code&gt;range&lt;/code&gt;.  A memory barrier is guaranteed to be executed on exit from the loop, so that results produced by all threads are visible in the calling thread.  &lt;b&gt;Exception Handling&lt;/b&gt;:  When at least one exception is thrown from inside a parallel foreach loop, the submission of additional &lt;code&gt;Task&lt;/code&gt; objects is terminated as soon as possible, in a non-deterministic manner. All executing or enqueued work units are allowed to complete. Then, all exceptions that were thrown by any work unit are chained using &lt;code&gt;Throwable.next&lt;/code&gt; and rethrown. The order of the exception chaining is non-deterministic.</source>
          <target state="translated">Romper desde un bucle foreach paralelo a trav&amp;eacute;s de una pausa, rotura rotulada, etiquetada continuar, regresar o ir a la instrucci&amp;oacute;n arroja un &lt;code&gt;ParallelForeachError&lt;/code&gt; . En el caso de rangos de acceso no aleatorio, los foreach paralelos se almacenan perezosamente en una matriz de tama&amp;ntilde;o &lt;code&gt;workUnitSize&lt;/code&gt; antes de ejecutar la parte paralela del bucle. La excepci&amp;oacute;n es que, si se ejecuta un foreach paralelo en un rango devuelto por &lt;code&gt;asyncBuf&lt;/code&gt; o &lt;code&gt;map&lt;/code&gt; , la copia se elude y los buffers simplemente se intercambian. En este caso, se ignora &lt;code&gt;workUnitSize&lt;/code&gt; y el tama&amp;ntilde;o de la unidad de trabajo se establece en el tama&amp;ntilde;o de b&amp;uacute;fer del &lt;code&gt;range&lt;/code&gt; . Se garantiza que se ejecutar&amp;aacute; una barrera de memoria al salir del bucle, de modo que los resultados producidos por todos los hilos sean visibles en el hilo de llamada. &lt;b&gt;Manejo de excepciones&lt;/b&gt; : cuando se lanza al menos una excepci&amp;oacute;n desde el interior de un bucle foreach paralelo, el env&amp;iacute;o de objetos de &lt;code&gt;Task&lt;/code&gt; adicionales finaliza lo antes posible, de manera no determinista. Se permite completar todas las unidades de trabajo en ejecuci&amp;oacute;n o en cola. Entonces, todas las excepciones que fueron lanzados por cualquier unidad de trabajo est&amp;aacute;n encadenados utilizando &lt;code&gt;Throwable.next&lt;/code&gt; y relanza. El orden de la cadena de excepci&amp;oacute;n no es determinista.</target>
        </trans-unit>
        <trans-unit id="9d3201041918654fbf75089e070856aa79ebc523" translate="yes" xml:space="preserve">
          <source>Breaks x into an integral part and a fractional part, each of which has the same sign as x. The integral part is stored in i.</source>
          <target state="translated">Rompe la x en una parte integral y una parte fraccionaria,cada una de las cuales tiene el mismo signo que la x.La parte integral se almacena en la i.</target>
        </trans-unit>
        <trans-unit id="4324d0ed28641cb58b631967da3876548c2a70ef" translate="yes" xml:space="preserve">
          <source>Bring leaves to common type.</source>
          <target state="translated">Lleva las hojas al tipo común.</target>
        </trans-unit>
        <trans-unit id="399d0f0935a4fd7e2adf0462c69b1578bb0496b9" translate="yes" xml:space="preserve">
          <source>Buffer &lt;code&gt;buffer&lt;/code&gt;</source>
          <target state="translated">Buffer &lt;code&gt;buffer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="535393fe6f448d36dc112ebfa2c4ec8acdaebcaa" translate="yes" xml:space="preserve">
          <source>Buffer to receive error messages in, must be at least CURL_ERROR_SIZE bytes big. If this is not used, error messages go to stderr instead:</source>
          <target state="translated">El buffer para recibir los mensajes de error,debe ser al menos CURL_ERROR_SIZE bytes grande.Si esto no se usa,los mensajes de error van a stderr en su lugar:</target>
        </trans-unit>
        <trans-unit id="303f92df69f201e44e4c0ca1825e2e280d1f0c91" translate="yes" xml:space="preserve">
          <source>Buffer to structure as a free list. If &lt;code&gt;ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, the buffer is assumed to be allocated by &lt;code&gt;parent&lt;/code&gt; and will be freed in the destructor.</source>
          <target state="translated">Buffer para estructurar como una lista libre. Si &lt;code&gt;ParentAllocator&lt;/code&gt; no es &lt;code&gt;NullAllocator&lt;/code&gt; , se supone que el b&amp;uacute;fer es asignado por el &lt;code&gt;parent&lt;/code&gt; y se liberar&amp;aacute; en el destructor.</target>
        </trans-unit>
        <trans-unit id="c05d2a8029044c4c4e57f66bbd40a3eac5b198a2" translate="yes" xml:space="preserve">
          <source>Buffer to write the escaped path to</source>
          <target state="translated">Buffer para escribir el camino de escape a</target>
        </trans-unit>
        <trans-unit id="c083c9d2a3d468528bb5dd1cebdd4400312c43c2" translate="yes" xml:space="preserve">
          <source>Buffer used to store the resulting line data. buf is enlarged if necessary, then set to the slice exactly containing the line.</source>
          <target state="translated">Buffer utilizado para almacenar los datos de la línea resultante.buf se amplía si es necesario,luego se ajusta al trozo que contiene exactamente la línea.</target>
        </trans-unit>
        <trans-unit id="7ab4ac68db7c219824ba8029fe0a1e0d5e5c01c5" translate="yes" xml:space="preserve">
          <source>Buffer used to store the resulting line data. buf is resized as necessary.</source>
          <target state="translated">El buffer utilizado para almacenar los datos de la línea resultante.buf se redimensiona según sea necesario.</target>
        </trans-unit>
        <trans-unit id="271befc09ec922fba884ac992f346efbaa84c1c6" translate="yes" xml:space="preserve">
          <source>Bug</source>
          <target state="translated">Bug</target>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="80432fb4403119d7fa36b39cc0581f74363b7507" translate="yes" xml:space="preserve">
          <source>Bugs:</source>
          <target state="translated">Bugs:</target>
        </trans-unit>
        <trans-unit id="e543d61d1db526d2c201a9150a8eeb4f6a08a7bb" translate="yes" xml:space="preserve">
          <source>Bugzilla 2137</source>
          <target state="translated">Bugzilla 2137</target>
        </trans-unit>
        <trans-unit id="d957a3ddca24bb7ba3415ed5d23a475def657008" translate="yes" xml:space="preserve">
          <source>Bugzilla 592</source>
          <target state="translated">Bugzilla 592</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="e4ce8210e89bb0abea338092bae131b54bcd5ff1" translate="yes" xml:space="preserve">
          <source>Build __xopCmp for TypeInfo_Struct static bool __xopCmp(ref const S p, ref const S q) { return p.opCmp(q); }</source>
          <target state="translated">Construir __xopCmp para TypeInfo_Struct static bool __xopCmp(ref const S p,ref const S q){return p.opCmp(q);}</target>
        </trans-unit>
        <trans-unit id="f3d924ea22f0f293cf6f3ebfcd84f23fb87ecdc9" translate="yes" xml:space="preserve">
          <source>Build __xopEquals for TypeInfo_Struct static bool __xopEquals(ref const S p, ref const S q) { return p == q; }</source>
          <target state="translated">Build __xopEquals for TypeInfo_Struct static bool __xopEquals(ref const S p,ref const S q){return p ==q;}</target>
        </trans-unit>
        <trans-unit id="edd21187462263909c4e5bccda552a4211a055ce" translate="yes" xml:space="preserve">
          <source>Build _xtoHash for non-bitwise hashing static hash_t xtoHash(ref const S p) nothrow @trusted;</source>
          <target state="translated">Construye _xtoHash para hash estático no bitáctico hash_t xtoHash(ref const S p)nothrow @trusted;</target>
        </trans-unit>
        <trans-unit id="02755102e393b0ceee36f18acf3cd4f3a97f903b" translate="yes" xml:space="preserve">
          <source>Build a list out of the null-terminated argument list.</source>
          <target state="translated">Construye una lista a partir de la lista de argumentos nulos.</target>
        </trans-unit>
        <trans-unit id="8926cd9ddf0e4003036d0a204fc3589b6f556c48" translate="yes" xml:space="preserve">
          <source>Build a temporary variable to copy the value of e into.</source>
          <target state="translated">Construye una variable temporal para copiar el valor de e.</target>
        </trans-unit>
        <trans-unit id="7126b83ecb05ac49ee0d9a4bfd7fa2c9443a5db6" translate="yes" xml:space="preserve">
          <source>Build a temporary variable to extract e's evaluation, if e is not trivial.</source>
          <target state="translated">Construye una variable temporal para extraer la evaluación de e,si e no es trivial.</target>
        </trans-unit>
        <trans-unit id="5f0947173a3022e64a66ace8a16da7bd0953de0d" translate="yes" xml:space="preserve">
          <source>Build opAssign for a &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="translated">Construye opAssign para una &lt;code&gt;struct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd267126bb39bb406bc3a0c8c87a8165b825fa2e" translate="yes" xml:space="preserve">
          <source>Build opEquals for struct. const bool opEquals(const S s) { ... }</source>
          <target state="translated">Construir opEquals para struct.const bool opEquals(const S s){...}</target>
        </trans-unit>
        <trans-unit id="6dd999e7845d7581c295f9165da47448ffe76f29" translate="yes" xml:space="preserve">
          <source>Build scoped variables and reference-counted types.</source>
          <target state="translated">Construye variables de alcance y tipos de conteo de referencia.</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="e777aa2ee0a1277f1927115dd56047ae99acaf63" translate="yes" xml:space="preserve">
          <source>Building Blocks</source>
          <target state="translated">Bloques de construcción</target>
        </trans-unit>
        <trans-unit id="3f334616286956fcb816046552d7f9bf1acd6341" translate="yes" xml:space="preserve">
          <source>Building block functions, they translate to a single x87 instruction.</source>
          <target state="translated">Las funciones de los bloques de construcción,se traducen a una sola instrucción x87.</target>
        </trans-unit>
        <trans-unit id="5d7f3504504044d481b2cb93792c53ee903721c6" translate="yes" xml:space="preserve">
          <source>Building blocks</source>
          <target state="translated">Bloques de construcción</target>
        </trans-unit>
        <trans-unit id="39c609d88be88f825074ec54ab9e12948dadee89" translate="yes" xml:space="preserve">
          <source>Building contract support into the language makes for:</source>
          <target state="translated">Construir el apoyo del contrato en el lenguaje hace que:</target>
        </trans-unit>
        <trans-unit id="e5d9a44c338285ef0b2cf2cbe5abd6d13da4bd15" translate="yes" xml:space="preserve">
          <source>Builds a &lt;code&gt;Trie&lt;/code&gt; with typically optimal speed-size trade-off and wraps it into a delegate of the following type: &lt;code&gt;bool delegate(dchar ch)&lt;/code&gt;.</source>
          <target state="translated">Construye un &lt;code&gt;Trie&lt;/code&gt; con una compensaci&amp;oacute;n de tama&amp;ntilde;o de velocidad t&amp;iacute;picamente &amp;oacute;ptima y lo envuelve en un delegado del siguiente tipo: &lt;code&gt;bool delegate(dchar ch)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddd9b5faf4e195f0b71766badf13e8513590fa7" translate="yes" xml:space="preserve">
          <source>Builds an index of the top elements of a range.</source>
          <target state="translated">Construye un índice de los elementos superiores de una gama.</target>
        </trans-unit>
        <trans-unit id="8ac6cb76b75c220d2577581173ee0a6d992a81d1" translate="yes" xml:space="preserve">
          <source>Builds an object. Usually this is invoked indirectly by using the &lt;a href=&quot;#zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Construye un objeto. Por lo general, esto se invoca indirectamente mediante el uso de la funci&amp;oacute;n &lt;a href=&quot;#zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12e943a67bf614d76638933b655f13c408534085" translate="yes" xml:space="preserve">
          <source>Built-in mathematical intrinsics.</source>
          <target state="translated">Intrínsecos matemáticos incorporados.</target>
        </trans-unit>
        <trans-unit id="393ada6b17ede7fe1acbc7b82bec2f4e8c1c04b5" translate="yes" xml:space="preserve">
          <source>Built-in postfix unary expressions &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are evaluated as if lowered (rewritten) to lambda invocations as follows: &lt;code&gt;expr++&lt;/code&gt; becomes &lt;code&gt;(ref T x){auto t = x; ++x; return t;}(expr)&lt;/code&gt;, and &lt;code&gt;expr--&lt;/code&gt; becomes &lt;code&gt;(ref T x){auto t = x; --x; return t;}(expr)&lt;/code&gt;. Therefore, the result of postfix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; is an rvalue just before the side effect has been effected.</source>
          <target state="translated">Las expresiones unarias de postfix incorporadas &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; se eval&amp;uacute;an como si fueran invocadas (reescritas) a lambda de la siguiente manera: &lt;code&gt;expr++&lt;/code&gt; convierte &lt;code&gt;(ref T x){auto t = x; ++x; return t;}(expr)&lt;/code&gt; , y &lt;code&gt;expr--&lt;/code&gt; se convierte en &lt;code&gt;(ref T x){auto t = x; --x; return t;}(expr)&lt;/code&gt; . Por lo tanto, el resultado de postfix &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; es un valor justo antes de que se haya efectuado el efecto secundario.</target>
        </trans-unit>
        <trans-unit id="140a63c50a697c2475ba756ea1b637cf7b49226e" translate="yes" xml:space="preserve">
          <source>Built-in prefix unary expressions &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are evaluated as if lowered (rewritten) to assignments as follows: &lt;code&gt;++expr&lt;/code&gt; becomes &lt;code&gt;((expr) += 1)&lt;/code&gt;, and &lt;code&gt;--expr&lt;/code&gt; becomes &lt;code&gt;((expr) -= 1)&lt;/code&gt;. Therefore, the result of prefix &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; is the lvalue after the side effect has been effected.</source>
          <target state="translated">Las expresiones unarias del prefijo incorporado &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; se eval&amp;uacute;an como si fueran reducidas (reescritas) a las asignaciones de la siguiente manera: &lt;code&gt;++expr&lt;/code&gt; se convierte en &lt;code&gt;((expr) += 1)&lt;/code&gt; y &lt;code&gt;--expr&lt;/code&gt; se convierte en &lt;code&gt;((expr) -= 1)&lt;/code&gt; . Por lo tanto, el resultado del prefijo &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; es el valor despu&amp;eacute;s de que se haya efectuado el efecto secundario.</target>
        </trans-unit>
        <trans-unit id="f4ef630934a7f1267240a157c0264f348c4dadf3" translate="yes" xml:space="preserve">
          <source>Built-in threading (e.g. &lt;a href=&quot;https://dlang.org/phobos/core_thread.html&quot;&gt;&lt;code&gt;core.thread&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://dlang.org/phobos/core_thread.html&quot;&gt; &lt;code&gt;core.thread&lt;/code&gt; &lt;/a&gt; (p . Ej., Core.thread )</target>
        </trans-unit>
        <trans-unit id="738019c18e7d3c678f51b2d2bb9de596778335f1" translate="yes" xml:space="preserve">
          <source>Builtin SIMD intrinsics</source>
          <target state="translated">La construcción de la SIMD es intrínseca</target>
        </trans-unit>
        <trans-unit id="809be9a33e4a381b76b3f2392efbde90e7cac474" translate="yes" xml:space="preserve">
          <source>Builtin mathematical intrinsics</source>
          <target state="translated">Construido intrínsecamente matemático</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="aee13f098c3fbc98d67893709d2f60dddc7f25f1" translate="yes" xml:space="preserve">
          <source>But the precision of &lt;code&gt;StopWatch&lt;/code&gt; differs from system to system. It is impossible to for it to be the same from system to system since the precision of the system clock varies from system to system, and other system-dependent and situation-dependent stuff (such as the overhead of a context switch between threads) can also affect &lt;code&gt;StopWatch&lt;/code&gt;'s accuracy.</source>
          <target state="translated">Pero la precisi&amp;oacute;n de &lt;code&gt;StopWatch&lt;/code&gt; difiere de un sistema a otro. Es imposible que sea igual de un sistema a otro ya que la precisi&amp;oacute;n del reloj del sistema var&amp;iacute;a de un sistema a otro, y otras cosas dependientes del sistema y de la situaci&amp;oacute;n (como la sobrecarga de un cambio de contexto entre hilos) pueden tambi&amp;eacute;n afecta la precisi&amp;oacute;n de &lt;code&gt;StopWatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="768690cb6415ff721efd279bcb993c49ad663947" translate="yes" xml:space="preserve">
          <source>But, if one context is indirectly accessible from other context, it is allowed.</source>
          <target state="translated">Pero,si un contexto es accesible indirectamente desde otro contexto,está permitido.</target>
        </trans-unit>
        <trans-unit id="bbd7cb5dd010de18293afcbf1ef490f5cd753c28" translate="yes" xml:space="preserve">
          <source>By convention, package and module names are all lower case. This is because these names have a one-to-one correspondence with the operating system's directory and file names, and many file systems are not case sensitive. Using all lower case package and module names will avoid or minimize problems when moving projects between dissimilar file systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45921646718dbb6e00896e143e95be14de95c04" translate="yes" xml:space="preserve">
          <source>By convention, package and module names are all lower case. This is because those names can have a one-to-one correspondence with the operating system's directory and file names, and many file systems are not case sensitive. All lower case package and module names will minimize problems moving projects between dissimilar file systems.</source>
          <target state="translated">Por convención,los nombres de los paquetes y módulos están en minúsculas.Esto se debe a que esos nombres pueden tener una correspondencia unívoca con el directorio y los nombres de los archivos del sistema operativo,y muchos sistemas de archivos no distinguen entre mayúsculas y minúsculas.Todos los nombres de paquetes y módulos en minúsculas minimizarán los problemas para mover proyectos entre sistemas de archivos diferentes.</target>
        </trans-unit>
        <trans-unit id="2f986e628567a153d5373360f16e912e237bc63a" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;StoppingPolicy&lt;/code&gt; is set to &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, &lt;code&gt;StoppingPolicy&lt;/code&gt; se establece en &lt;code&gt;StoppingPolicy.shortest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8a76e2827ccb54962a847a022109fb17e84070" translate="yes" xml:space="preserve">
          <source>By default a request has it's &quot;User-Agent&quot; field set to &lt;a href=&quot;#%20defaultUserAgent&quot;&gt;&lt;code&gt; defaultUserAgent&lt;/code&gt;&lt;/a&gt; even if &lt;code&gt;setUserAgent&lt;/code&gt; was never called. Pass an empty string to suppress the &quot;User-Agent&quot; field altogether.</source>
          <target state="translated">Por defecto, una solicitud tiene su campo &quot;User-Agent&quot; establecido en &lt;a href=&quot;#%20defaultUserAgent&quot;&gt; &lt;code&gt; defaultUserAgent&lt;/code&gt; &lt;/a&gt; incluso si nunca se llam&amp;oacute; a &lt;code&gt;setUserAgent&lt;/code&gt; . Pase una cadena vac&amp;iacute;a para suprimir el campo &quot;User-Agent&quot; por completo.</target>
        </trans-unit>
        <trans-unit id="478b0d271a29c1d5ae05535cd04bb959cef13353" translate="yes" xml:space="preserve">
          <source>By default an &lt;code&gt;Error&lt;/code&gt; will be thrown.</source>
          <target state="translated">Por defecto se lanzar&amp;aacute; un &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6de89d666cfcbf1e2d91df4f90cb3d04defa9a2" translate="yes" xml:space="preserve">
          <source>By default four &lt;code&gt;Logger&lt;/code&gt; implementations are given. The &lt;code&gt;FileLogger&lt;/code&gt; logs data to files. It can also be used to log to &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; as these devices are files as well. A &lt;code&gt;Logger&lt;/code&gt; that logs to &lt;code&gt;stdout&lt;/code&gt; can therefore be created by &lt;code&gt;new FileLogger(stdout)&lt;/code&gt;. The &lt;code&gt;MultiLogger&lt;/code&gt; is basically an associative array of &lt;code&gt;string&lt;/code&gt;s to &lt;code&gt;Logger&lt;/code&gt;. It propagates log calls to its stored &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;ArrayLogger&lt;/code&gt; contains an array of &lt;code&gt;Logger&lt;/code&gt; and also propagates log calls to its stored &lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;NullLogger&lt;/code&gt; does not do anything. It will never log a message and will never throw on a log call with &lt;code&gt;LogLevel&lt;/code&gt;&lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">Por defecto se dan cuatro implementaciones de &lt;code&gt;Logger&lt;/code&gt; . El &lt;code&gt;FileLogger&lt;/code&gt; registra datos de archivos. Tambi&amp;eacute;n se puede usar para iniciar sesi&amp;oacute;n en &lt;code&gt;stdout&lt;/code&gt; y &lt;code&gt;stderr&lt;/code&gt; , ya que estos dispositivos tambi&amp;eacute;n son archivos. A &lt;code&gt;Logger&lt;/code&gt; que los registros a &lt;code&gt;stdout&lt;/code&gt; por lo tanto puede ser creado por &lt;code&gt;new FileLogger(stdout)&lt;/code&gt; . El &lt;code&gt;MultiLogger&lt;/code&gt; es b&amp;aacute;sicamente una matriz asociativa de &lt;code&gt;string&lt;/code&gt; s para &lt;code&gt;Logger&lt;/code&gt; . Se propaga llamadas de registro en su almacenado &lt;code&gt;Logger&lt;/code&gt; . El &lt;code&gt;ArrayLogger&lt;/code&gt; contiene una matriz de &lt;code&gt;Logger&lt;/code&gt; y tambi&amp;eacute;n propaga las llamadas de registro a su &lt;code&gt;Logger&lt;/code&gt; almacenado . los &lt;code&gt;NullLogger&lt;/code&gt; no hace nada. Nunca registrar&amp;aacute; un mensaje y nunca lanzar&amp;aacute; una llamada de registro con el &lt;code&gt;error&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ef4ca6979d9539ab9bd7cee842dec5c1148639b" translate="yes" xml:space="preserve">
          <source>By default it is conservatively assumed that allocated memory may be &lt;code&gt;cast&lt;/code&gt; to &lt;code&gt;shared&lt;/code&gt;, passed across threads, and deallocated in a different thread than the one that allocated it. If that's not the case, there are two options. First, &lt;code&gt;immutableShared&lt;/code&gt; means the memory is allocated for &lt;code&gt;immutable&lt;/code&gt; data and will be deallocated in the same thread it was allocated in. Second, &lt;code&gt;threadLocal&lt;/code&gt; means the memory is not to be shared across threads at all. The two flags cannot be simultaneously present.</source>
          <target state="translated">Por defecto, se supone de forma conservadora que la memoria asignada se puede &lt;code&gt;cast&lt;/code&gt; en &lt;code&gt;shared&lt;/code&gt; , pasar a trav&amp;eacute;s de subprocesos y desasignarse en un subproceso diferente al que lo asign&amp;oacute;. Si ese no es el caso, hay dos opciones. Primero, &lt;code&gt;immutableShared&lt;/code&gt; significa que la memoria se asigna para datos &lt;code&gt;immutable&lt;/code&gt; y se desasignar&amp;aacute; en el mismo subproceso en el que se asign&amp;oacute;. Segundo, &lt;code&gt;threadLocal&lt;/code&gt; significa que la memoria no se debe compartir entre subprocesos en absoluto. Las dos banderas no pueden estar presentes simult&amp;aacute;neamente.</target>
        </trans-unit>
        <trans-unit id="6f5b3a15a485cfab1e5a75e1fa6e376cde7fb92a" translate="yes" xml:space="preserve">
          <source>By default options are case-insensitive. You can change that behavior by passing &lt;code&gt;getopt&lt;/code&gt; the &lt;code&gt;caseSensitive&lt;/code&gt; directive like this:</source>
          <target state="translated">Por defecto, las opciones no distinguen entre may&amp;uacute;sculas y min&amp;uacute;sculas. Puede cambiar ese comportamiento pasando &lt;code&gt;getopt&lt;/code&gt; la directiva &lt;code&gt;caseSensitive&lt;/code&gt; de esta manera:</target>
        </trans-unit>
        <trans-unit id="dbec3e9c45747840b24455eb80ba1df0a750e9ae" translate="yes" xml:space="preserve">
          <source>By default the garbage collector uses all available CPU cores to mark the heap.</source>
          <target state="translated">Por defecto,el recolector de basura utiliza todos los núcleos de CPU disponibles para marcar el montón.</target>
        </trans-unit>
        <trans-unit id="b8fa023c2d92a0d81832e9bd89d175d5927659d9" translate="yes" xml:space="preserve">
          <source>By default, GC options can only be passed on the command line of the program to run, e.g.</source>
          <target state="translated">Por defecto,las opciones del GC sólo se pueden pasar en la línea de comandos del programa a ejecutar,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="8b24a9b44aee4758b90d689774f561a91ccfd9f7" translate="yes" xml:space="preserve">
          <source>By default, a string literal is typed as a dynamic array, but the element count is known at compile time. So all string literals can be implicitly converted to static array types.</source>
          <target state="translated">Por defecto,un literal de cadena se escribe como una matriz dinámica,pero el recuento de elementos se conoce en tiempo de compilación.Así que todos los literales de cadena pueden ser convertidos implícitamente en tipos de matriz estática.</target>
        </trans-unit>
        <trans-unit id="8bdaa68e3c22ff7ff0194a0456f12cfccad4e7b3" translate="yes" xml:space="preserve">
          <source>By default, an array literal is typed as a dynamic array, but the element count is known at compile time. So all array literals can be implicitly converted to static array types.</source>
          <target state="translated">Por defecto,una matriz literal se escribe como una matriz dinámica,pero el recuento de elementos se conoce en el momento de la compilación.Así que todos los literales de la matriz pueden ser convertidos implícitamente en tipos de matriz estática.</target>
        </trans-unit>
        <trans-unit id="22091b5b2cb326fb7704d38d801e2ea343fe0a4b" translate="yes" xml:space="preserve">
          <source>By default, imports are</source>
          <target state="translated">Por defecto,las importaciones son</target>
        </trans-unit>
        <trans-unit id="f143feea6dee31aa56bf9053dddf3e0e772b7f34" translate="yes" xml:space="preserve">
          <source>By default, non-immutable global declarations reside in thread local storage. When a global variable is marked with the &lt;code&gt;__gshared&lt;/code&gt; attribute, its value is shared across all threads.</source>
          <target state="translated">De forma predeterminada, las declaraciones globales no inmutables residen en el almacenamiento local de subprocesos. Cuando una variable global se marca con el atributo &lt;code&gt;__gshared&lt;/code&gt; , su valor se comparte en todos los subprocesos.</target>
        </trans-unit>
        <trans-unit id="aad3d8313e40930c344804ce8ccc20bf40a3e89a" translate="yes" xml:space="preserve">
          <source>By default, parameters take rvalue arguments. A ref parameter takes an lvalue argument, so changes to its value will operate on the caller's argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="079ae70c5ecf861c3729c19e224c7956b1bb4ed1" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;#execute&quot;&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#executeShell&quot;&gt;&lt;code&gt;executeShell&lt;/code&gt;&lt;/a&gt; functions will capture child processes' both stdout and stderr. This can be undesirable if the standard output is to be processed or otherwise used by the invoking program, as &lt;code&gt;execute&lt;/code&gt;'s result would then contain a mix of output and warning/error messages.</source>
          <target state="translated">Por defecto, las funciones &lt;a href=&quot;#execute&quot;&gt; &lt;code&gt;execute&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#executeShell&quot;&gt; &lt;code&gt;executeShell&lt;/code&gt; &lt;/a&gt; capturar&amp;aacute;n los procesos secundarios tanto stdout como stderr. Esto puede ser indeseable si el programa de invocaci&amp;oacute;n va a procesar o utilizar la salida est&amp;aacute;ndar, ya que el resultado de la &lt;code&gt;execute&lt;/code&gt; contendr&amp;iacute;a una mezcla de salida y mensajes de advertencia / error.</target>
        </trans-unit>
        <trans-unit id="5c5dc33ccdd6fb02e11d57deb9c037003d388703" translate="yes" xml:space="preserve">
          <source>By default, the above will print:</source>
          <target state="translated">Por defecto,lo anterior se imprimirá:</target>
        </trans-unit>
        <trans-unit id="2a431b7902a6f8a61040ea86e57ea9fd88c07b45" translate="yes" xml:space="preserve">
          <source>By default, the child process inherits the environment of the parent process, along with any additional variables specified in the &lt;code&gt;env&lt;/code&gt; parameter. If the same variable exists in both the parent's environment and in &lt;code&gt;env&lt;/code&gt;, the latter takes precedence.</source>
          <target state="translated">De manera predeterminada, el proceso secundario hereda el entorno del proceso primario, junto con cualquier variable adicional especificada en el par&amp;aacute;metro &lt;code&gt;env&lt;/code&gt; . Si existe la misma variable en el entorno tanto la de los padres y de &lt;code&gt;env&lt;/code&gt; , este &amp;uacute;ltimo tiene prioridad.</target>
        </trans-unit>
        <trans-unit id="00f97c90e4779d49bd0154dcbe3ccd270b7c1a5c" translate="yes" xml:space="preserve">
          <source>By default, the child process inherits the parent's environment, and any environment variables passed to &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; will be added to it. If this flag is set, the only variables in the child process' environment will be those given to spawnProcess.</source>
          <target state="translated">De manera predeterminada, el proceso secundario hereda el entorno del padre y se le agregar&amp;aacute;n las variables de entorno que se pasen a &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; . Si se establece este indicador, las &amp;uacute;nicas variables en el entorno del proceso hijo ser&amp;aacute;n las que se le dan a spawnProcess.</target>
        </trans-unit>
        <trans-unit id="164f65e6c4e1ffea6984f3be9b15c6fd4fcd5bd7" translate="yes" xml:space="preserve">
          <source>By default, the return type is time_t (which is normally an alias for int on 32-bit systems and long on 64-bit systems), but if a different size is required than either int or long can be passed as a template argument to get the desired size.</source>
          <target state="translated">Por defecto,el tipo de retorno es time_t (que normalmente es un alias para int en sistemas de 32 bits y long en sistemas de 64 bits),pero si se requiere un tamaño diferente al de int o long puede pasarse como argumento de plantilla para obtener el tamaño deseado.</target>
        </trans-unit>
        <trans-unit id="887970dcbfc9d8811c8813f736813ed286b7d258" translate="yes" xml:space="preserve">
          <source>By default, the rounding mode is roundToNearest and all hardware exceptions are disabled. For most applications, debugging is easier if the</source>
          <target state="translated">Por defecto,el modo de redondeo es roundToNearest y todas las excepciones de hardware están desactivadas.Para la mayoría de las aplicaciones,la depuración es más fácil si el</target>
        </trans-unit>
        <trans-unit id="6e33332413c374faf23d6382e0a46b9fcaf1aadb" translate="yes" xml:space="preserve">
          <source>By definition, empty ranges are matched fully and if &lt;code&gt;needles&lt;/code&gt; contains an empty range, &lt;code&gt;skipOver&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Por definici&amp;oacute;n, los rangos vac&amp;iacute;os coinciden completamente y si las &lt;code&gt;needles&lt;/code&gt; contienen un rango vac&amp;iacute;o, &lt;code&gt;skipOver&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10ce83358e38997bfd068876bacbbbb4077fd36b" translate="yes" xml:space="preserve">
          <source>By definition, if a pre contract fails, then the function received bad parameters. If a post contract fails, then there is a bug in the function. In either case, an &lt;code&gt;assert&lt;/code&gt; statement within the corresponding &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt; block will throw an &lt;code&gt;AssertError&lt;/code&gt;.</source>
          <target state="translated">Por definici&amp;oacute;n, si falla un precontrato, entonces la funci&amp;oacute;n recibi&amp;oacute; par&amp;aacute;metros incorrectos. Si falla un contrato posterior, entonces hay un error en la funci&amp;oacute;n. En cualquiera de los casos, una &lt;code&gt;assert&lt;/code&gt; de sentencia dentro de los correspondientes &lt;code&gt;in&lt;/code&gt; o &lt;code&gt;out&lt;/code&gt; del bloque arrojar&amp;aacute; una &lt;code&gt;AssertError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb96c2ff58da640b614e1d83a03d1ae961343b00" translate="yes" xml:space="preserve">
          <source>By fixing &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=3789&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=3789&lt;/a&gt; opEquals is changed to be never implicitly generated. Now, struct objects comparison s1 == s2 is translated to: s1.tupleof == s2.tupleof to calculate structural equality. See EqualExp.op_overload.</source>
          <target state="translated">Al corregir &lt;a href=&quot;https://issues.dlang.org/show_bug.cgi?id=3789&quot;&gt;https://issues.dlang.org/show_bug.cgi?id=3789&lt;/a&gt; opEquals se cambia para que nunca se genere impl&amp;iacute;citamente. Ahora, la comparaci&amp;oacute;n de objetos de estructura s1 == s2 se traduce a: s1.tupleof == s2.tupleof para calcular la igualdad estructural. Ver EqualExp.op_overload.</target>
        </trans-unit>
        <trans-unit id="aac8d772d9fb45f1ebe981cf3bff581d81f0a9a1" translate="yes" xml:space="preserve">
          <source>By using &lt;a href=&quot;std_utf#byUTF&quot;&gt;&lt;code&gt;std.utf.byUTF&lt;/code&gt;&lt;/a&gt; and its aliases, GC allocations via auto-decoding and thrown exceptions can be avoided, making &lt;code&gt;icmp&lt;/code&gt;&lt;code&gt;@safe @nogc nothrow pure&lt;/code&gt;.</source>
          <target state="translated">Mediante el uso de &lt;a href=&quot;std_utf#byUTF&quot;&gt; &lt;code&gt;std.utf.byUTF&lt;/code&gt; &lt;/a&gt; y sus alias, las asignaciones de GC a trav&amp;eacute;s de excepciones de auto-descodificaci&amp;oacute;n y lanzados pueden ser evitados, haciendo &lt;code&gt;icmp&lt;/code&gt; &lt;code&gt;@safe @nogc nothrow pure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc291c2891b81ab141f345fa0230adb20fd10cd9" translate="yes" xml:space="preserve">
          <source>Byte order endianness.</source>
          <target state="translated">Byte order endianness.</target>
        </trans-unit>
        <trans-unit id="1eb54b97f13d87edcd6a934d982b6f81fb1b387f" translate="yes" xml:space="preserve">
          <source>Byte order, least significant first</source>
          <target state="translated">El orden de los bytes,el menos significativo primero</target>
        </trans-unit>
        <trans-unit id="b59f4e1ab4662646945739f875a2dc8274ccd34b" translate="yes" xml:space="preserve">
          <source>Byte order, most significant first</source>
          <target state="translated">El orden de los bytes,el más significativo primero</target>
        </trans-unit>
        <trans-unit id="0c1f86b6eef786b75f48b5164472c5f379f29825" translate="yes" xml:space="preserve">
          <source>Byte value in hexadecimal, where</source>
          <target state="translated">Valor del byte en hexadecimal,donde</target>
        </trans-unit>
        <trans-unit id="f4e5cf625ea1bf16e64b237498429dc72e94863d" translate="yes" xml:space="preserve">
          <source>Byte value in octal.</source>
          <target state="translated">Valor de bytes en octal.</target>
        </trans-unit>
        <trans-unit id="a58fed109fdbc425c9e3e299c4f472aa1e81b9e2" translate="yes" xml:space="preserve">
          <source>Bytes (not items) to be allocated for the free list. Memory will be allocated during construction and deallocated in the destructor.</source>
          <target state="translated">Bytes (no artículos)que se asignarán para la lista gratuita.La memoria se asignará durante la construcción y se colocará en el destructor.</target>
        </trans-unit>
        <trans-unit id="b2e625cfca365b6f5ed6d88821a2c881a6679253" translate="yes" xml:space="preserve">
          <source>Bytes to allocate</source>
          <target state="translated">Bytes a asignar</target>
        </trans-unit>
        <trans-unit id="2eadc64c1cdbc5d6ca752a0b38f5f0a02d05c4b1" translate="yes" xml:space="preserve">
          <source>Bytes to allocate using &lt;code&gt;ParentAllocator&lt;/code&gt;. This constructor is only defined If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;parent.allocate(n)&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;, the region will be initialized as empty (correctly initialized but unable to allocate).</source>
          <target state="translated">Bytes para asignar usando &lt;code&gt;ParentAllocator&lt;/code&gt; . Este constructor solo se define si &lt;code&gt;ParentAllocator&lt;/code&gt; es diferente de &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; . Si &lt;code&gt;parent.allocate(n)&lt;/code&gt; devuelve &lt;code&gt;null&lt;/code&gt; , la regi&amp;oacute;n se inicializar&amp;aacute; como vac&amp;iacute;a (inicializada correctamente pero no se puede asignar).</target>
        </trans-unit>
        <trans-unit id="d3fc47eb5e867c1a90c1c6140022201511e39c13" translate="yes" xml:space="preserve">
          <source>Byzantine Musical Symbols</source>
          <target state="translated">Símbolos musicales bizantinos</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="91ab2886a8945715f467ad2616dd5309295ba114" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">C &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="922a6aa3cb89e34ea72fe9d27effc2df259df392" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;create&lt;/code&gt;</source>
          <target state="translated">C &lt;code&gt;create&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9652018eda95d6aa3dab8e093571b39cf52c2264" translate="yes" xml:space="preserve">
          <source>C ABI</source>
          <target state="translated">C ABI</target>
        </trans-unit>
        <trans-unit id="f824a58327e609cd9fdba23fe1a3c84c364898ea" translate="yes" xml:space="preserve">
          <source>C code can correspondingly call D functions, if the D functions use an attribute that is compatible with the C compiler, most likely the extern (C):</source>
          <target state="translated">El código C puede,en consecuencia,llamar a las funciones D,si las funciones D utilizan un atributo compatible con el compilador C,muy probablemente el externo (C):</target>
        </trans-unit>
        <trans-unit id="0ffb7f8837c1a11eeb25850dd4e1e4ef9b573509" translate="yes" xml:space="preserve">
          <source>C code explicitly manages memory with calls to &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#malloc&quot;&gt;malloc()&lt;/a&gt; and &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#free&quot;&gt;free()&lt;/a&gt;. D allocates memory using the D garbage collector, so no explicit frees are necessary.</source>
          <target state="translated">El c&amp;oacute;digo C gestiona expl&amp;iacute;citamente la memoria con llamadas a &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#malloc&quot;&gt;malloc ()&lt;/a&gt; y &lt;a href=&quot;http://www.digitalmars.com/rtl/stdlib.html#free&quot;&gt;free ()&lt;/a&gt; . D asigna memoria utilizando el recolector de basura D, por lo que no se necesitan liberaciones expl&amp;iacute;citas.</target>
        </trans-unit>
        <trans-unit id="d221b852c9ebec0058ed069c0351edaaeb33622d" translate="yes" xml:space="preserve">
          <source>C code often adjusts the alignment and packing of struct members with a command line switch or with various implementation specific #pragmas. D supports explicit alignment attributes that correspond to the C compiler's rules. Check what alignment the C code is using, and explicitly set it for the D struct declaration.</source>
          <target state="translated">El código C a menudo ajusta la alineación y el empaquetamiento de los miembros estructurales con un interruptor de línea de comando o con varios #pragmaas específicos de implementación.D soporta atributos de alineación explícitos que corresponden a las reglas del compilador C.Comprueba qué alineación está usando el código C,y configúralo explícitamente para la declaración de la estructura D.</target>
        </trans-unit>
        <trans-unit id="ad0081e0fe0dd4d8c8faa110d448e18b099251c6" translate="yes" xml:space="preserve">
          <source>C function calling conventions are specified by:</source>
          <target state="translated">Las convenciones de llamada de función C se especifican por:</target>
        </trans-unit>
        <trans-unit id="7bbdeb583f7af40df326e5ef45b5341310bfa3a8" translate="yes" xml:space="preserve">
          <source>C functions can be called directly from D. There is no need for wrapper functions, argument swizzling, and the C functions do not need to be put into a separate DLL.</source>
          <target state="translated">Las funciones C pueden ser llamadas directamente desde D.No hay necesidad de funciones de envoltura,argumento swizzling,y las funciones C no necesitan ser puestas en un DLL separado.</target>
        </trans-unit>
        <trans-unit id="391732c6d45f595037ed6d3acf61093990d2af4d" translate="yes" xml:space="preserve">
          <source>C functions cannot be overloaded with another C function with the same name.</source>
          <target state="translated">Las funciones C no pueden ser sobrecargadas con otra función C con el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="5f547f273af63b8119db89b56d4a8680c878d370" translate="yes" xml:space="preserve">
          <source>C globals can be accessed directly from D. C globals have the C naming convention, and so must be in an &lt;code&gt;extern (C)&lt;/code&gt; block. Use the &lt;code&gt;extern&lt;/code&gt; storage class to indicate that the global is allocated in the C code, not the D code. C globals default to being in global, not thread local, storage. To reference global storage from D, use the &lt;code&gt;__gshared&lt;/code&gt; storage class.</source>
          <target state="translated">Se puede acceder a los globales C directamente desde D. Los globales C tienen la convenci&amp;oacute;n de nomenclatura C, por lo que deben estar en un bloque &lt;code&gt;extern (C)&lt;/code&gt; . Use la clase de almacenamiento &lt;code&gt;extern&lt;/code&gt; o para indicar que el global est&amp;aacute; asignado en el c&amp;oacute;digo C, no en el c&amp;oacute;digo D. El valor global de C es el almacenamiento global, no el subproceso local. Para hacer referencia al almacenamiento global desde D, use la clase de almacenamiento &lt;code&gt;__gshared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="088f42af395914ff1b11b211001ff8dc3bfb47de" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.initialize, returns 1/0 instead of bool</source>
          <target state="translated">La interfaz C para Runtime.initialize,devuelve 1/0 en lugar de bool</target>
        </trans-unit>
        <trans-unit id="dc4b969769a12fb03185e79820cbdb1188eba5a6" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.loadLibrary</source>
          <target state="translated">Interfaz C para Runtime.loadLibrary</target>
        </trans-unit>
        <trans-unit id="1ba4ae2523a2983e2479e8220f1eed45cabbda41" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.terminate, returns 1/0 instead of bool</source>
          <target state="translated">La interfaz C para Runtime.terminate,devuelve 1/0 en lugar de bool</target>
        </trans-unit>
        <trans-unit id="8ebac48238568ab95c4c5ad69ed5cd780269c53c" translate="yes" xml:space="preserve">
          <source>C interface for Runtime.unloadLibrary, returns 1/0 instead of bool</source>
          <target state="translated">La interfaz C para Runtime.unloadLibrary,devuelve 1/0 en lugar de bool</target>
        </trans-unit>
        <trans-unit id="86cf735b5a9e30aaa5f0fee060cea7d39ebc4f60" translate="yes" xml:space="preserve">
          <source>C library routines. See callclib().</source>
          <target state="translated">Rutinas de la biblioteca C.Ver callclib().</target>
        </trans-unit>
        <trans-unit id="c1ff5ead3c46826c14b71159d580aef25ffbf060" translate="yes" xml:space="preserve">
          <source>C name mangling is done by adding a prefix on some platforms.</source>
          <target state="translated">La manipulación de nombres se hace añadiendo un prefijo en algunas plataformas.</target>
        </trans-unit>
        <trans-unit id="126f7b78af09df06aa9df51a74fef4005eae1de9" translate="yes" xml:space="preserve">
          <source>C style variadic function</source>
          <target state="translated">Función variádica de estilo C</target>
        </trans-unit>
        <trans-unit id="dd58d1bb166ddedbf2d0eda882e81a02524b0fbc" translate="yes" xml:space="preserve">
          <source>C#'s &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/b2s063f7.aspx&quot;&gt;embedded XML&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/b2s063f7.aspx&quot;&gt;XML incrustado de&lt;/a&gt; C #</target>
        </trans-unit>
        <trans-unit id="34cf1ff3bbe582bde426d598f3ad72cfcc2d599c" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;free&lt;/code&gt; does not have a safe interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd30234820540d843ae13b550abfa205649ae3c" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;malloc&lt;/code&gt; does have a safe interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0143508b7b64b86b3401c85034e750942cedf11" translate="yes" xml:space="preserve">
          <source>C's &lt;code&gt;strlen&lt;/code&gt; and &lt;code&gt;memcpy&lt;/code&gt; do not have safe interfaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0548c5e650e5d6686abc5b2a04b9371833fa90" translate="yes" xml:space="preserve">
          <source>C's printf() and Strings</source>
          <target state="translated">C's printf()y Cuerdas</target>
        </trans-unit>
        <trans-unit id="4f540b0aaef1641b1d80a5208b7c055e606bf72a" translate="yes" xml:space="preserve">
          <source>C++ Interfaces</source>
          <target state="translated">Interfaces C++</target>
        </trans-unit>
        <trans-unit id="f1642c1a4e4dce54c68aa20addb027e83adf0715" translate="yes" xml:space="preserve">
          <source>C++ Namespaces</source>
          <target state="translated">C++Namespaces</target>
        </trans-unit>
        <trans-unit id="c5cb41022921444e105840eeb5b0879ab0ff1d75" translate="yes" xml:space="preserve">
          <source>C++ Support</source>
          <target state="translated">Soporte C++</target>
        </trans-unit>
        <trans-unit id="f9f27585ae5da3fc2a761861b44ded6adf3015ec" translate="yes" xml:space="preserve">
          <source>C++ Templates</source>
          <target state="translated">Plantillas C++</target>
        </trans-unit>
        <trans-unit id="7e28b0c0a074b69119fdaf750d5061c6c3eed943" translate="yes" xml:space="preserve">
          <source>C++ allows a struct to inherit from a base struct. This is done in D using &lt;code&gt;alias this&lt;/code&gt;:</source>
          <target state="translated">C ++ permite que una estructura herede de una estructura base. Esto se hace en D usando el &lt;code&gt;alias this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="270c92d90f5419eb56fc78a11ccc1e3fb6e75988" translate="yes" xml:space="preserve">
          <source>C++ and D follow different rules for function overloading. D source code, even when calling &lt;code&gt;extern (C++)&lt;/code&gt; functions, will still follow D overloading rules.</source>
          <target state="translated">C ++ y D siguen diferentes reglas para la sobrecarga de funciones. El c&amp;oacute;digo fuente D, incluso cuando se llama a funciones &lt;code&gt;extern (C++)&lt;/code&gt; , seguir&amp;aacute; las reglas de sobrecarga de D.</target>
        </trans-unit>
        <trans-unit id="803c33c0bd9c5c8e423f248219c12fcafd72a234" translate="yes" xml:space="preserve">
          <source>C++ can open the same namespace in the same file and multiple files. In D, this can be done as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9777d8f776f92bf25e9cab083b49833d4a402d3" translate="yes" xml:space="preserve">
          <source>C++ class</source>
          <target state="translated">Clase C++</target>
        </trans-unit>
        <trans-unit id="bc6ef19080a44be47740e7c8ef1fb2da8b514001" translate="yes" xml:space="preserve">
          <source>C++ classes can be declared in D by using the &lt;code&gt;extern (C++)&lt;/code&gt; attribute on &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;interface&lt;/code&gt; declarations. &lt;code&gt;extern (C++)&lt;/code&gt; interfaces have the same restrictions as D interfaces, which means that Multiple Inheritance is supported to the extent that only one base class can have member fields.</source>
          <target state="translated">Las clases de C ++ se pueden declarar en D utilizando el atributo &lt;code&gt;extern (C++)&lt;/code&gt; en &lt;code&gt;class&lt;/code&gt; declaraciones de clase , &lt;code&gt;struct&lt;/code&gt; e &lt;code&gt;interface&lt;/code&gt; . &lt;code&gt;extern (C++)&lt;/code&gt; interfaces externas (C ++) tienen las mismas restricciones que las interfaces D, lo que significa que se admite la herencia m&amp;uacute;ltiple en la medida en que solo una clase base puede tener campos miembro.</target>
        </trans-unit>
        <trans-unit id="2696fbb29a2404060229a5c0ef4dcf0d930ebf5a" translate="yes" xml:space="preserve">
          <source>C++ code explicitly manages memory with calls to &lt;code&gt;::operator new()&lt;/code&gt; and &lt;code&gt;::operator delete()&lt;/code&gt;. D's &lt;code&gt;new&lt;/code&gt; operator allocates memory using the D garbage collector, so no explicit delete is necessary. D's &lt;code&gt;new&lt;/code&gt; operator is not compatible with C++'s &lt;code&gt;::operator new&lt;/code&gt; and &lt;code&gt;::operator delete&lt;/code&gt;. Attempting to allocate memory with D's &lt;code&gt;new&lt;/code&gt; and deallocate with C++ &lt;code&gt;::operator delete&lt;/code&gt; will result in miserable failure.</source>
          <target state="translated">El c&amp;oacute;digo C ++ administra expl&amp;iacute;citamente la memoria con llamadas a &lt;code&gt;::operator new()&lt;/code&gt; y &lt;code&gt;::operator delete()&lt;/code&gt; . El &lt;code&gt;new&lt;/code&gt; operador de D asigna memoria utilizando el recolector de basura D, por lo que no es necesario eliminarlo expl&amp;iacute;citamente. El &lt;code&gt;new&lt;/code&gt; operador de D no es compatible con C ++ ' &lt;code&gt;::operator new&lt;/code&gt; y &lt;code&gt;::operator delete&lt;/code&gt; . Intentar asignar memoria con D's &lt;code&gt;new&lt;/code&gt; y desasignar con C ++ &lt;code&gt;::operator delete&lt;/code&gt; dar&amp;aacute; como resultado una falla miserable.</target>
        </trans-unit>
        <trans-unit id="bc28c8a3178ea35aefa2bc7cad45f485c5c7f436" translate="yes" xml:space="preserve">
          <source>C++ constructors, copy constructors, move constructors and destructors cannot be called directly in D code, and D constructors, postblit operators and destructors cannot be directly exported to C++ code. Interoperation of types with these special operators is possible by either 1) disabling the operator in the client language and only using it in the host language, or 2) faithfully reimplementing the operator in the client language. With the latter approach, care needs to be taken to ensure observable semantics remain the same with both implementations, which can be difficult, or in some edge cases impossible, due to differences in how the operators work in the two languages. For example, in D all objects are movable and there is no move constructor.</source>
          <target state="translated">Los constructores C++,los constructores de copia,los constructores de movimiento y los destructores no pueden ser llamados directamente en código D,y los constructores D,los operadores postblit y los destructores no pueden ser exportados directamente a código C++.La interoperabilidad de tipos con estos operadores especiales es posible ya sea 1)desactivando el operador en el idioma del cliente y usándolo sólo en el idioma del cliente,o 2)reimplementando fielmente el operador en el idioma del cliente.Con este último enfoque,hay que tener cuidado de asegurar que la semántica observable siga siendo la misma con ambas implementaciones,lo que puede ser difícil,o en algunos casos imposible,debido a las diferencias en la forma de trabajar de los operadores en los dos idiomas.Por ejemplo,en D todos los objetos son móviles y no hay constructor de movimientos.</target>
        </trans-unit>
        <trans-unit id="7201ae364cc48822a82b73b893189a5dd94aef18" translate="yes" xml:space="preserve">
          <source>C++ function and type templates can be bound by using the &lt;code&gt;extern (C++)&lt;/code&gt; attribute on a function or type template declaration.</source>
          <target state="translated">Las plantillas de tipo y funci&amp;oacute;n de C ++ pueden vincularse mediante el uso del atributo &lt;code&gt;extern (C++)&lt;/code&gt; en una declaraci&amp;oacute;n de plantilla de tipo o funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b5593ddf6c58f1012fa7ffeb46813794152a771a" translate="yes" xml:space="preserve">
          <source>C++ global functions, including those in namespaces, can be declared and called in D, or defined in D and called in C++.</source>
          <target state="translated">Las funciones globales de C++,incluidas las de los espacios de nombres,pueden declararse y llamarse en D,o definirse en D y llamarse en C++.</target>
        </trans-unit>
        <trans-unit id="4e9e4356221d1ee2aa897fff7328f9ee52314134" translate="yes" xml:space="preserve">
          <source>C++ interfaces are interfaces declared with C++ linkage:</source>
          <target state="translated">Las interfaces C++son interfaces declaradas con vinculación C++:</target>
        </trans-unit>
        <trans-unit id="5099e4c841655b922a765e68cbf8aefc57d5356e" translate="yes" xml:space="preserve">
          <source>C++ namespace this symbol belongs to</source>
          <target state="translated">El espacio de nombres C++al que pertenece este símbolo</target>
        </trans-unit>
        <trans-unit id="c6f5200183cdf7ce197fbb3bc50824c16c47152a" translate="yes" xml:space="preserve">
          <source>C++ reference:</source>
          <target state="translated">Referencia C++:</target>
        </trans-unit>
        <trans-unit id="912b136567cd7cbd9fc8f323d5606bbe39d07750" translate="yes" xml:space="preserve">
          <source>C++ symbols that reside in namespaces can be accessed from D. A &lt;a href=&quot;attribute#namespace&quot;&gt;namespace&lt;/a&gt; can be added to the &lt;code&gt;extern (C++)&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;LinkageAttribute&lt;/a&gt;:</source>
          <target state="translated">Se puede acceder a los s&amp;iacute;mbolos de C ++ que residen en espacios de nombres desde D. Se puede agregar un &lt;a href=&quot;attribute#namespace&quot;&gt;espacio de nombres&lt;/a&gt; al &lt;a href=&quot;attribute#linkage&quot;&gt;atributo de enlace &lt;/a&gt; &lt;code&gt;extern (C++)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f98b3c489784aabeb7da68a1d1411495ec51290" translate="yes" xml:space="preserve">
          <source>C++'s make_shared</source>
          <target state="translated">C++'s make_shared</target>
        </trans-unit>
        <trans-unit id="588f44e70bf472a1f45f7efcfa562168c8457c0a" translate="yes" xml:space="preserve">
          <source>C-style Variadic Functions</source>
          <target state="translated">Funciones variadas de estilo C</target>
        </trans-unit>
        <trans-unit id="d5ccb24bc3ad9fc7c10cfe2824e9cb190ac91f9d" translate="yes" xml:space="preserve">
          <source>C-style array, function pointer and pointer to array declarations are deprecated:</source>
          <target state="translated">La matriz de estilo C,el puntero de función y las declaraciones de puntero a matriz están obsoletas:</target>
        </trans-unit>
        <trans-unit id="f0848a8145c311481df53130b777fe467332d312" translate="yes" xml:space="preserve">
          <source>C-style octal integer notation was deemed too easy to mix up with decimal notation; it is only fully supported in string literals. D still supports octal integer literals interpreted at compile time through the &lt;a href=&quot;https://dlang.org/phobos/std_conv.html#octal&quot;&gt;&lt;code&gt;std.conv.octal&lt;/code&gt;&lt;/a&gt; template, as in &lt;code&gt;octal!167&lt;/code&gt;.</source>
          <target state="translated">La notaci&amp;oacute;n de entero octal de estilo C se consider&amp;oacute; demasiado f&amp;aacute;cil de mezclar con la notaci&amp;oacute;n decimal; solo es totalmente compatible con literales de cadena. D todav&amp;iacute;a admite literales enteros octales interpretados en tiempo de compilaci&amp;oacute;n a trav&amp;eacute;s de la plantilla &lt;a href=&quot;https://dlang.org/phobos/std_conv.html#octal&quot;&gt; &lt;code&gt;std.conv.octal&lt;/code&gt; &lt;/a&gt; , como en &lt;code&gt;octal!167&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9adf55a50113afd886edb1cbfcea7b8ecf56ed5e" translate="yes" xml:space="preserve">
          <source>C-style semantics on pointer arithmetic are strictly enforced. Pointer arithmetic is permitted only on pointers which point to static or dynamic array elements. Such pointers must point to an element of the array, or to the first element past the array. Pointer arithmetic is completely forbidden on pointers which are null, or which point to a non-array.</source>
          <target state="translated">La semántica del estilo C en la aritmética de los punteros se aplica estrictamente.La aritmética de punteros sólo se permite en punteros que apuntan a elementos de conjuntos estáticos o dinámicos.Tales punteros deben apuntar a un elemento de la matriz,o al primer elemento más allá de la matriz.La aritmética de puntero está completamente prohibida en punteros que son nulos,o que apuntan a una matriz que no es la matriz.</target>
        </trans-unit>
        <trans-unit id="52aea3b6618c4eb66aee74f7ff3b04621de74570" translate="yes" xml:space="preserve">
          <source>C-style variadic functions</source>
          <target state="translated">Funciones variadas de estilo C</target>
        </trans-unit>
        <trans-unit id="77ba44bb9e589c769fa658f005333eee147a4900" translate="yes" xml:space="preserve">
          <source>C-style variadic functions cannot be marked as &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">Las funciones variadas de estilo C no se pueden marcar como &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ddb858f8a20b16ac93e15adcc78e42ffbd8db66" translate="yes" xml:space="preserve">
          <source>C-style variadic functions match the C calling convention for variadic functions, and is most useful for calling C library functions like &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">Las funciones variadas de estilo C coinciden con la convenci&amp;oacute;n de llamada C para funciones variadas, y es m&amp;aacute;s &amp;uacute;til para llamar a funciones de biblioteca C como &lt;code&gt;printf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8818f4ee4a0e406f4fe10b1e03aebaf4d71f3819" translate="yes" xml:space="preserve">
          <source>C1 &lt;code&gt;next&lt;/code&gt;</source>
          <target state="translated">C1 &lt;code&gt;next&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30212c965112a877f52f60d83e8ff113ef1b3f96" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;path&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;path&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9089e6f07372bce6e832f5f650cb3e7c0c621e3b" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4aa0499528f63537a98f340c34d4972647df60e5" translate="yes" xml:space="preserve">
          <source>C1[] &lt;code&gt;suffix&lt;/code&gt;</source>
          <target state="translated">C1 [] &lt;code&gt;suffix&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c459d7b347295856b421ffb8792a1964353bfe70" translate="yes" xml:space="preserve">
          <source>C1[] &lt;strong id=&quot;tr&quot;&gt;tr&lt;/strong&gt;(C1, C2, C3, C4 = immutable(char))(C1[] str, const(C2)[] from, const(C3)[] to, const(C4)[] modifiers = null);</source>
          <target state="translated">C1 [] &lt;strong id=&quot;tr&quot;&gt;tr&lt;/strong&gt; (C1, C2, C3, C4 = inmutable (char)) (C1 [] str, const (C2) [] from, const (C3) [] to, const (C4) [] modificadores = nulo) ;</target>
        </trans-unit>
        <trans-unit id="a0d01d3baedb5ae97bde5874c2012010c575e84c" translate="yes" xml:space="preserve">
          <source>C2 &lt;code&gt;empty&lt;/code&gt;</source>
          <target state="translated">C2 &lt;code&gt;empty&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8e1804fe922cd90750831c2c298d54a222ba628" translate="yes" xml:space="preserve">
          <source>C2[] &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">C2 [] &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b7d328ba78816f38f975bb5147f4c05534a9bc5" translate="yes" xml:space="preserve">
          <source>CAPI3REF</source>
          <target state="translated">CAPI3REF</target>
        </trans-unit>
        <trans-unit id="bd963590f78aa017d53387443be555aa971b1144" translate="yes" xml:space="preserve">
          <source>CData &lt;code&gt;item&lt;/code&gt;</source>
          <target state="translated">CData &lt;code&gt;item&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afdd392374481b4db6ac2ce43fdc87d5888fe7e3" translate="yes" xml:space="preserve">
          <source>CDataException if the segment body is illegal (contains &quot;]]&amp;gt;&quot;)</source>
          <target state="translated">CDataException si el cuerpo del segmento es ilegal (contiene &quot;]]&amp;gt;&quot;)</target>
        </trans-unit>
        <trans-unit id="3061e575e355c19788f22cb3d62aa0cd47f40e40" translate="yes" xml:space="preserve">
          <source>CData[] &lt;strong id=&quot;cdatas&quot;&gt;cdatas&lt;/strong&gt;;</source>
          <target state="translated">CData [] &lt;strong id=&quot;cdatas&quot;&gt;cdatas&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="92b00c2e72a02d322e30292a494b0f77de93d540" translate="yes" xml:space="preserve">
          <source>CJK Compatibility</source>
          <target state="translated">Compatibilidad con CJK</target>
        </trans-unit>
        <trans-unit id="24dc7006e4bfb5dae3e8ea7f01d766f357b0514b" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Forms</source>
          <target state="translated">Formularios de compatibilidad CJK</target>
        </trans-unit>
        <trans-unit id="28610435f9d6e37ccd13448891ef635456bc6798" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Ideographs</source>
          <target state="translated">Idearios de compatibilidad de CJK</target>
        </trans-unit>
        <trans-unit id="3a3044d64bf35123af4c2034c39688d2f85c3b7d" translate="yes" xml:space="preserve">
          <source>CJK Compatibility Ideographs Supplement</source>
          <target state="translated">Suplemento de Ideografías de Compatibilidad CJK</target>
        </trans-unit>
        <trans-unit id="56398f3cc299fcadc8172ed7743fcc8d6604a2b2" translate="yes" xml:space="preserve">
          <source>CJK Radicals Supplement</source>
          <target state="translated">CJK Radicals Supplement</target>
        </trans-unit>
        <trans-unit id="c80daba1e9c50935dee4c69ef20e42e31a63bfcb" translate="yes" xml:space="preserve">
          <source>CJK Strokes</source>
          <target state="translated">CJK Apoplejías</target>
        </trans-unit>
        <trans-unit id="41d774013768fc4cae9cda6ce11ff4062ab10d65" translate="yes" xml:space="preserve">
          <source>CJK Symbols and Punctuation</source>
          <target state="translated">Símbolos y puntuación de CJK</target>
        </trans-unit>
        <trans-unit id="a8e25b3246b6d0e0fa06fb72ba766979769141a7" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs</source>
          <target state="translated">Idearios unificados de CJK</target>
        </trans-unit>
        <trans-unit id="6370cdf4d714b545f5b7bf4ee34e57e56e359487" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension A</source>
          <target state="translated">CJK Unified Ideographs Extensión A</target>
        </trans-unit>
        <trans-unit id="a1724e7543e72f713653f623821483898403f1d0" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension B</source>
          <target state="translated">CJK Unified Ideographs Extensión B</target>
        </trans-unit>
        <trans-unit id="71e4356045ae7c85afc88a13e5be97e037f502d4" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension C</source>
          <target state="translated">CJK Unified Ideographs Extensión C</target>
        </trans-unit>
        <trans-unit id="de4f53e7b0971e7c4fd9b6b5639b6d9d3d564380" translate="yes" xml:space="preserve">
          <source>CJK Unified Ideographs Extension D</source>
          <target state="translated">CJK Unified Ideographs Extensión D</target>
        </trans-unit>
        <trans-unit id="df31bd94e79946dcd6e346825f4e84b5f0358f50" translate="yes" xml:space="preserve">
          <source>CLI flag without leading &lt;code&gt;-&lt;/code&gt;, e.g. &lt;code&gt;color&lt;/code&gt;</source>
          <target state="translated">Bandera CLI sin conducir &lt;code&gt;-&lt;/code&gt; , por ejemplo, &lt;code&gt;color&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d78b798fee78a64b81d6899e06efc15c1dccde51" translate="yes" xml:space="preserve">
          <source>COM Interfaces</source>
          <target state="translated">Interfaces COM</target>
        </trans-unit>
        <trans-unit id="154721c66d149bb61466c03b8ff3861e25ef38c7" translate="yes" xml:space="preserve">
          <source>COM classes and C++ classes</source>
          <target state="translated">Las clases COM y C++</target>
        </trans-unit>
        <trans-unit id="ae337737f416d275254734defda66541f870f22e" translate="yes" xml:space="preserve">
          <source>COMPILER INTERFACE /////////////////////</source>
          <target state="translated">INTERFAZ DEL COMPILADOR //////////////////////////</target>
        </trans-unit>
        <trans-unit id="e352fc138c5e488dc34254c3ee2e99e3e9aaf288" translate="yes" xml:space="preserve">
          <source>COPYRIGHT</source>
          <target state="translated">COPYRIGHT</target>
        </trans-unit>
        <trans-unit id="0af12e3ea89b844b314d17c7e3f7bac655ebd0c7" translate="yes" xml:space="preserve">
          <source>CPPNamespaceDeclaration &lt;strong id=&quot;cppnamespace&quot;&gt;cppnamespace&lt;/strong&gt;;</source>
          <target state="translated">CPPNamespaceDeclaration &lt;strong id=&quot;cppnamespace&quot;&gt;cppnamespace&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="95fe9c2b68a6150c2538241de478d073b3c01eb6" translate="yes" xml:space="preserve">
          <source>CPU architectures supported -mcpu=id</source>
          <target state="translated">Arquitecturas de CPU soportadas -mcpu=id</target>
        </trans-unit>
        <trans-unit id="73c7fc0f09e167cc17d6e2ae64cdb2bc100ca9d7" translate="yes" xml:space="preserve">
          <source>CPUs often support specialized vector types and vector operations (a.k.a.</source>
          <target state="translated">Las CPU suelen apoyar tipos de vectores especializados y operaciones de vectores (también conocidas como &quot;vectores&quot;).</target>
        </trans-unit>
        <trans-unit id="bf887172139520e2ce3c00abdb93ee2e9fd86211" translate="yes" xml:space="preserve">
          <source>CRC32 of data</source>
          <target state="translated">CRC32 de datos</target>
        </trans-unit>
        <trans-unit id="992514a6a8b2e73f449a04615c81ce6686d74551" translate="yes" xml:space="preserve">
          <source>CRC32 value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764a2bd592ab90f526cba7f18836f8fb323c69e5" translate="yes" xml:space="preserve">
          <source>CRC64-ECMA of data</source>
          <target state="translated">CRC64-ECMA de datos</target>
        </trans-unit>
        <trans-unit id="de219addfefcc2e27f49a3ca6fa5a51d3de19ec6" translate="yes" xml:space="preserve">
          <source>CRC64-ISO of data</source>
          <target state="translated">CRC64-ISO de datos</target>
        </trans-unit>
        <trans-unit id="91d96d88652e57b949051060aed04c0c7a55db68" translate="yes" xml:space="preserve">
          <source>CRCs are usually printed with the MSB first. When using &lt;a href=&quot;std_digest#toHexString&quot;&gt;&lt;code&gt;std.digest.toHexString&lt;/code&gt;&lt;/a&gt; the result will be in an unexpected order. Use &lt;a href=&quot;std_digest#toHexString&quot;&gt;&lt;code&gt;std.digest.toHexString&lt;/code&gt;&lt;/a&gt;'s optional order parameter to specify decreasing order for the correct result. The &lt;a href=&quot;#crcHexString&quot;&gt;&lt;code&gt;crcHexString&lt;/code&gt;&lt;/a&gt; alias can also be used for this purpose.</source>
          <target state="translated">Los CRC generalmente se imprimen con el MSB primero. Al usar &lt;a href=&quot;std_digest#toHexString&quot;&gt; &lt;code&gt;std.digest.toHexString&lt;/code&gt; ,&lt;/a&gt; el resultado estar&amp;aacute; en un orden inesperado. Utilice el par&amp;aacute;metro de orden opcional de &lt;a href=&quot;std_digest#toHexString&quot;&gt; &lt;code&gt;std.digest.toHexString&lt;/code&gt; &lt;/a&gt; para especificar un orden decreciente para el resultado correcto. El alias &lt;a href=&quot;#crcHexString&quot;&gt; &lt;code&gt;crcHexString&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n se puede utilizar para este prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="20226dce447690b9ec8699b49af5230d49691790" translate="yes" xml:space="preserve">
          <source>CRL file</source>
          <target state="translated">Archivo CRL</target>
        </trans-unit>
        <trans-unit id="9d1c93dd97d25f4c239981585e218bded30a91de" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a402cf31f9cf0e6b5b8a55752e348488f03f726b" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9864028d4f462263a4ffef0bfb1252c98316a14b" translate="yes" xml:space="preserve">
          <source>CSX &lt;code&gt;csx&lt;/code&gt;</source>
          <target state="translated">CSX &lt;code&gt;csx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d8934fa932e57010a67e3ca78ffd8b25af059e9" translate="yes" xml:space="preserve">
          <source>CSX &lt;strong id=&quot;callSuper&quot;&gt;callSuper&lt;/strong&gt;;</source>
          <target state="translated">CSX &lt;strong id=&quot;callSuper&quot;&gt;callSuper&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6cb8e5d0c4fc4c6db7f22e70f099ed917c02dc9a" translate="yes" xml:space="preserve">
          <source>CSX &lt;strong id=&quot;csx&quot;&gt;csx&lt;/strong&gt;;</source>
          <target state="translated">CSX &lt;strong id=&quot;csx&quot;&gt;csx&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="ef70b18a1d95d31d7157c61d4106f2015fb5f903" translate="yes" xml:space="preserve">
          <source>CTFE</source>
          <target state="translated">CTFE</target>
        </trans-unit>
        <trans-unit id="f226c00a4d670c28c9ce96128a908ed75e3c4fc6" translate="yes" xml:space="preserve">
          <source>CTFE Sanity Checks</source>
          <target state="translated">Controles de sanidad de la CTFE</target>
        </trans-unit>
        <trans-unit id="bcdc8bcedfff54c513bf8524b5ea04b31a01d40f" translate="yes" xml:space="preserve">
          <source>CTFE is not supported.</source>
          <target state="translated">No se admite la ECP.</target>
        </trans-unit>
        <trans-unit id="2e8b7f100028e56862c1d736efc547af30992b6b" translate="yes" xml:space="preserve">
          <source>CTFE is subject to the following restrictions:</source>
          <target state="translated">La ETC está sujeta a las siguientes restricciones:</target>
        </trans-unit>
        <trans-unit id="5cbcfb039635320e7ff7d8feb659fe88d90d6d53" translate="yes" xml:space="preserve">
          <source>CTFE-able expression, resolving to &lt;code&gt;TupleExp&lt;/code&gt; or &lt;code&gt;StringExp&lt;/code&gt;</source>
          <target state="translated">Expresi&amp;oacute;n &lt;code&gt;TupleExp&lt;/code&gt; con CTFE , resolviendo a TupleExp o &lt;code&gt;StringExp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da921efe49d919390e46ee7013dc94409e0427b9" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;curl_easy_duphandle&lt;/strong&gt;(CURL* curl);</source>
          <target state="translated">CURL * &lt;strong id=&quot;curl_easy_duphandle&quot;&gt;curl_easy_duphandle&lt;/strong&gt; (CURL * curl);</target>
        </trans-unit>
        <trans-unit id="f3df3af8e49ed4cabb82ec3eb374069c299119bb" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;curl_easy_init&quot;&gt;curl_easy_init&lt;/strong&gt;();</source>
          <target state="translated">CURL * &lt;strong id=&quot;curl_easy_init&quot;&gt;curl_easy_init&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="6751502e2bc0440a5e6927ebe6c763c9fb33f615" translate="yes" xml:space="preserve">
          <source>CURL* &lt;strong id=&quot;easy_handle&quot;&gt;easy_handle&lt;/strong&gt;;</source>
          <target state="translated">CURL * &lt;strong id=&quot;easy_handle&quot;&gt;easy_handle&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="828fa48577f41dee0175a07d2bcd99aa7917b639" translate="yes" xml:space="preserve">
          <source>CURLE_OUT_OF_MEMORY may sometimes indicate a conversion error instead of a memory allocation error if CURL_DOES_CONVERSIONS is defined</source>
          <target state="translated">CURL_OUT_OF_MEMORY puede a veces indicar un error de conversión en lugar de un error de asignación de memoria si CURL_DOES_CONVERSIONS está definido</target>
        </trans-unit>
        <trans-unit id="2ab51649023b66c808197a6d0ba638e7d65bf9da" translate="yes" xml:space="preserve">
          <source>CURLFORMcode &lt;strong id=&quot;curl_formadd&quot;&gt;curl_formadd&lt;/strong&gt;(curl_httppost** httppost, curl_httppost** last_post, ...);</source>
          <target state="translated">CURLFORMcode &lt;strong id=&quot;curl_formadd&quot;&gt;curl_formadd&lt;/strong&gt; (curl_httppost ** httppost, curl_httppost ** last_post, ...);</target>
        </trans-unit>
        <trans-unit id="ee42c010a41bbc2d374ffe159f6514f8ff046b0e" translate="yes" xml:space="preserve">
          <source>CURLINFO_RESPONSE_CODE is the new name for the option previously known as CURLINFO_HTTP_CODE</source>
          <target state="translated">CURLINFO_RESPONSE_CODE es el nuevo nombre de la opción anteriormente conocida como CURLINFO_HTTP_CODE</target>
        </trans-unit>
        <trans-unit id="32ad7575f66b5734a63076c0cb3d75f3884da653" translate="yes" xml:space="preserve">
          <source>CURLM error code.</source>
          <target state="translated">Código de error CURLM.</target>
        </trans-unit>
        <trans-unit id="99dd99b527ed789fcfbdfc456b2eb941ef204be1" translate="yes" xml:space="preserve">
          <source>CURLM* &lt;strong id=&quot;curl_multi_init&quot;&gt;curl_multi_init&lt;/strong&gt;();</source>
          <target state="translated">CURLM * &lt;strong id=&quot;curl_multi_init&quot;&gt;curl_multi_init&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="3b90f598cb268ee4dc09f1ac996362f90296018c" translate="yes" xml:space="preserve">
          <source>CURLMSG &lt;strong id=&quot;msg&quot;&gt;msg&lt;/strong&gt;;</source>
          <target state="translated">CURLMSG &lt;strong id=&quot;msg&quot;&gt;msg&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="1999612ad18366624e0d0b2cd56012c1afc025b3" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_add_handle&quot;&gt;curl_multi_add_handle&lt;/strong&gt;(CURLM* multi_handle, CURL* curl_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_add_handle&quot;&gt;curl_multi_add_handle&lt;/strong&gt; (CURLM * multi_handle, CURL * curl_handle);</target>
        </trans-unit>
        <trans-unit id="22a1019ea56e4dab3fcad53491bac13d0d8af5fb" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_assign&quot;&gt;curl_multi_assign&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t sockfd, void* sockp);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_assign&quot;&gt;curl_multi_assign&lt;/strong&gt; (CURLM * multi_handle, curl_socket_t sockfd, void * sockp);</target>
        </trans-unit>
        <trans-unit id="25a2804bd3b7261884e99b1fc524c94a8f152120" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_cleanup&quot;&gt;curl_multi_cleanup&lt;/strong&gt;(CURLM* multi_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_cleanup&quot;&gt;curl_multi_cleanup&lt;/strong&gt; (CURLM * multi_handle);</target>
        </trans-unit>
        <trans-unit id="0d7d7eae82011af95f4a6e15b19e86d79b7d077b" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_fdset&quot;&gt;curl_multi_fdset&lt;/strong&gt;(CURLM* multi_handle, fd_set* read_fd_set, fd_set* write_fd_set, fd_set* exc_fd_set, int* max_fd);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_fdset&quot;&gt;curl_multi_fdset&lt;/strong&gt; (CURLM * multi_handle, fd_set * read_fd_set, fd_set * write_fd_set, fd_set * exc_fd_set, int * max_fd);</target>
        </trans-unit>
        <trans-unit id="811b3bdcf0c9e88ad95fd7b9e1e9194bc510f1d4" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_perform&quot;&gt;curl_multi_perform&lt;/strong&gt;(CURLM* multi_handle, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_perform&quot;&gt;curl_multi_perform&lt;/strong&gt; (CURLM * multi_handle, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="cdc21e6a79fac27e25ab2401a2231a5159d42fa2" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_remove_handle&quot;&gt;curl_multi_remove_handle&lt;/strong&gt;(CURLM* multi_handle, CURL* curl_handle);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_remove_handle&quot;&gt;curl_multi_remove_handle&lt;/strong&gt; (CURLM * multi_handle, CURL * curl_handle);</target>
        </trans-unit>
        <trans-unit id="b77796e4441642019f5f0ee725e2d2ccbaf79203" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_setopt&quot;&gt;curl_multi_setopt&lt;/strong&gt;(CURLM* multi_handle, CURLMoption option, ...);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_setopt&quot;&gt;curl_multi_setopt&lt;/strong&gt; (CURLM * multi_handle, opci&amp;oacute;n CURLMoption, ...);</target>
        </trans-unit>
        <trans-unit id="a09fadf338e9129df789fdea317e027aaed23a5b" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket&quot;&gt;curl_multi_socket&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t s, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket&quot;&gt;curl_multi_socket&lt;/strong&gt; (CURLM * multi_handle, curl_socket_t s, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="ff40633804853059e167a117757dc66453ca66ad" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket_action&quot;&gt;curl_multi_socket_action&lt;/strong&gt;(CURLM* multi_handle, curl_socket_t s, int ev_bitmask, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket_action&quot;&gt;curl_multi_socket_action&lt;/strong&gt; (CURLM * multi_handle, curl_socket_t s, int ev_bitmask, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="2466194fef4d1ee2ade6e8ccdeda99a667524258" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_socket_all&quot;&gt;curl_multi_socket_all&lt;/strong&gt;(CURLM* multi_handle, int* running_handles);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_socket_all&quot;&gt;curl_multi_socket_all&lt;/strong&gt; (CURLM * multi_handle, int * running_handles);</target>
        </trans-unit>
        <trans-unit id="11ebb04cdf64624f9d24ec68ab137e1aca46350a" translate="yes" xml:space="preserve">
          <source>CURLMcode &lt;strong id=&quot;curl_multi_timeout&quot;&gt;curl_multi_timeout&lt;/strong&gt;(CURLM* multi_handle, c_long* milliseconds);</source>
          <target state="translated">CURLMcode &lt;strong id=&quot;curl_multi_timeout&quot;&gt;curl_multi_timeout&lt;/strong&gt; (CURLM * multi_handle, c_long * milisegundos);</target>
        </trans-unit>
        <trans-unit id="78c7684a9c1f8b1ac34050129574ece72e711bdd" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code.</source>
          <target state="translated">Tipo de código CURLM,código de error múltiple general.</target>
        </trans-unit>
        <trans-unit id="4dc759c2b4e3bdbdc1edda0576bc41603b22a66f" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code.  tmp decl</source>
          <target state="translated">Tipo de código CURLM,código de error múltiple general.tmp decl</target>
        </trans-unit>
        <trans-unit id="8b52c35c36f45f74e7316bea0caa3ca7b9817c93" translate="yes" xml:space="preserve">
          <source>CURLMcode type, general multi error code. &lt;em&gt;NOTE&lt;/em&gt; that this only returns errors etc regarding the whole multi stack. There might still have occurred problems on invidual transfers even when this returns OK.</source>
          <target state="translated">Tipo de c&amp;oacute;digo CURLM, c&amp;oacute;digo general de error m&amp;uacute;ltiple. &lt;em&gt;TEN EN CUENTA&lt;/em&gt; que esto solo devuelve errores, etc. con respecto a toda la pila m&amp;uacute;ltiple. Es posible que a&amp;uacute;n se hayan producido problemas en las transferencias inviduales, incluso cuando esto devuelve OK.</target>
        </trans-unit>
        <trans-unit id="24871c0c35a14246d94f5b601f5067185618ba89" translate="yes" xml:space="preserve">
          <source>CURLMsg* &lt;strong id=&quot;curl_multi_info_read&quot;&gt;curl_multi_info_read&lt;/strong&gt;(CURLM* multi_handle, int* msgs_in_queue);</source>
          <target state="translated">CURLMsg * &lt;strong id=&quot;curl_multi_info_read&quot;&gt;curl_multi_info_read&lt;/strong&gt; (CURLM * multi_handle, int * msgs_in_queue);</target>
        </trans-unit>
        <trans-unit id="af2fa369dcf8fd4fae6663dacfb6660f7d91238e" translate="yes" xml:space="preserve">
          <source>CURLPROTO_ defines are for the CURLOPT_*PROTOCOLS options</source>
          <target state="translated">Las definiciones de CURLPROTO_son para las opciones de CURLOPT_*PROTOCOLS</target>
        </trans-unit>
        <trans-unit id="d2e3b588ca39c50e2dd064cfebdc4915a19704fb" translate="yes" xml:space="preserve">
          <source>CURLSH* &lt;strong id=&quot;curl_share_init&quot;&gt;curl_share_init&lt;/strong&gt;();</source>
          <target state="translated">CURLSH * &lt;strong id=&quot;curl_share_init&quot;&gt;curl_share_init&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="0cd2315c9c925b9d61d4c461b411526f237b821b" translate="yes" xml:space="preserve">
          <source>CURLSHcode &lt;strong id=&quot;curl_share_cleanup&quot;&gt;curl_share_cleanup&lt;/strong&gt;(CURLSH*);</source>
          <target state="translated">CURLSHcode &lt;strong id=&quot;curl_share_cleanup&quot;&gt;curl_share_cleanup&lt;/strong&gt; (CURLSH *);</target>
        </trans-unit>
        <trans-unit id="c12fc1ef3ac28f47fb0a0bb249fb914036edd5d6" translate="yes" xml:space="preserve">
          <source>CURLSHcode &lt;strong id=&quot;curl_share_setopt&quot;&gt;curl_share_setopt&lt;/strong&gt;(CURLSH*, CURLSHoption option, ...);</source>
          <target state="translated">CURLSHcode &lt;strong id=&quot;curl_share_setopt&quot;&gt;curl_share_setopt&lt;/strong&gt; (CURLSH *, opci&amp;oacute;n CURLSHoption, ...);</target>
        </trans-unit>
        <trans-unit id="80c9a3afaa37cabae0ead42d1ea2a983b4448ab3" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_ILLEGAL_ARRAY if an illegal option is used in an array</source>
          <target state="translated">CURL_FORMADD_ILLEGAL_ARRAY si se usa una opción ilegal en una matriz</target>
        </trans-unit>
        <trans-unit id="237caace3d00237f9fad71d5fdcb4b423276a5aa" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_INCOMPLETE if the some FormInfo is not complete (or error)</source>
          <target state="translated">CURL_FORMADD_INCOMPLETE si el algún FormInfo no está completo (o error)</target>
        </trans-unit>
        <trans-unit id="16321db303d4490b9645491e5cfe20deb293518b" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if a curl_httppost struct cannot be allocated</source>
          <target state="translated">CURL_FORMADD_MEMORY si una estructura curl_httppost no puede ser asignada</target>
        </trans-unit>
        <trans-unit id="468f4fa1bb410d0fd70e03f6a5dce8bd45ccdbe3" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if some allocation for string copying failed.</source>
          <target state="translated">CURL_FORMADD_MEMORY si alguna asignación para la copia de cadenas fallaba.</target>
        </trans-unit>
        <trans-unit id="244588782f153f2f49d14b88a76a4b1567aa1f97" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if the FormInfo allocation fails</source>
          <target state="translated">CURL_FORMADD_MEMORY si la asignación de FormInfo falla</target>
        </trans-unit>
        <trans-unit id="21b7579474f488d4369aa40ec4d89dc3bb5304c5" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_MEMORY if the allocation of a FormInfo struct failed</source>
          <target state="translated">CURL_FORMADD_MEMORY si la asignación de una estructura FormInfo fallaba</target>
        </trans-unit>
        <trans-unit id="f486f564c902d8b166b922ce6666a103809fa080" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_NULL if a null pointer was given for a char</source>
          <target state="translated">CURL_FORMADD_NULL si un puntero nulo fue dado para un char</target>
        </trans-unit>
        <trans-unit id="03c087c14e47ce05c5a730cee27884e0f0271510" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_OK on success</source>
          <target state="translated">CURL_FORMADD_OK sobre el éxito</target>
        </trans-unit>
        <trans-unit id="657acce1995ce0c4c4cc9704302fc40b3180ce0c" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_OPTION_TWICE if one option is given twice for one Form</source>
          <target state="translated">CURL_FORMADD_OPTION_TWICE si se da una opción dos veces para un formulario</target>
        </trans-unit>
        <trans-unit id="fb231ca0da85a5247735b55bae68726897d51402" translate="yes" xml:space="preserve">
          <source>CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used</source>
          <target state="translated">CURL_FORMADD_UNKNOWN_OPTION si se utilizó una opción desconocida</target>
        </trans-unit>
        <trans-unit id="c1c36583a3bee413dd4d6eabaaf03906540af6c8" translate="yes" xml:space="preserve">
          <source>CURL_LOCK_DATA_SHARE is used internally to say that the locking is just made to change the internal state of the share itself.</source>
          <target state="translated">CURL_LOCK_DATA_SHARE se usa internamente para decir que el bloqueo se hace sólo para cambiar el estado interno de la propia acción.</target>
        </trans-unit>
        <trans-unit id="08d333ae982f2ab5fd05c92959c9f03604998f78" translate="yes" xml:space="preserve">
          <source>CURL_VERSION</source>
          <target state="translated">CURL_VERSION</target>
        </trans-unit>
        <trans-unit id="311de4a4e55e22b4fb916aea606488f2810807f6" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;curl_easy_getinfo&lt;/strong&gt;(CURL* curl, CURLINFO info, ...);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_getinfo&quot;&gt;curl_easy_getinfo&lt;/strong&gt; (CURL * curl, informaci&amp;oacute;n CURLINFO, ...);</target>
        </trans-unit>
        <trans-unit id="732ee216b7a86b2068f3e21e26d039d5ff87d0a6" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_pause&quot;&gt;curl_easy_pause&lt;/strong&gt;(CURL* handle, int bitmask);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_pause&quot;&gt;curl_easy_pause&lt;/strong&gt; (CURL * handle, int bitmask);</target>
        </trans-unit>
        <trans-unit id="743291b335af5fe8701249accd883cdee309abc2" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_perform&quot;&gt;curl_easy_perform&lt;/strong&gt;(CURL* curl);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_perform&quot;&gt;curl_easy_perform&lt;/strong&gt; (CURL * curl);</target>
        </trans-unit>
        <trans-unit id="5ef9ed35887a97572c7e153166cf3c37d4499135" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_recv&quot;&gt;curl_easy_recv&lt;/strong&gt;(CURL* curl, void* buffer, size_t buflen, size_t* n);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_recv&quot;&gt;curl_easy_recv&lt;/strong&gt; (CURL * curl, void * buffer, size_t buflen, size_t * n);</target>
        </trans-unit>
        <trans-unit id="03f5e5216a441a870631a8ebbf1324f0d53aad46" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_send&quot;&gt;curl_easy_send&lt;/strong&gt;(CURL* curl, void* buffer, size_t buflen, size_t* n);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_send&quot;&gt;curl_easy_send&lt;/strong&gt; (CURL * curl, void * buffer, size_t buflen, size_t * n);</target>
        </trans-unit>
        <trans-unit id="c2267b7c0b6dd8f394f4e53f9877924630091aa4" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_easy_setopt&quot;&gt;curl_easy_setopt&lt;/strong&gt;(CURL* curl, CURLoption option, ...);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_easy_setopt&quot;&gt;curl_easy_setopt&lt;/strong&gt; (CURL * curl, opci&amp;oacute;n CURLoption, ...);</target>
        </trans-unit>
        <trans-unit id="856a997055fde5b0daa6466669272d7c21200826" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_global_init&quot;&gt;curl_global_init&lt;/strong&gt;(c_long flags);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_global_init&quot;&gt;curl_global_init&lt;/strong&gt; (banderas de c_long);</target>
        </trans-unit>
        <trans-unit id="ad44c3dd1dc580f2f09873c3d8bc4b0f2c99e680" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;curl_global_init_mem&quot;&gt;curl_global_init_mem&lt;/strong&gt;(c_long flags, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c);</source>
          <target state="translated">CURLcode &lt;strong id=&quot;curl_global_init_mem&quot;&gt;curl_global_init_mem&lt;/strong&gt; (c_long flags, curl_malloc_callback m, curl_free_callback f, curl_realloc_callback r, curl_strdup_callback s, curl_calloc_callback c);</target>
        </trans-unit>
        <trans-unit id="47d9bbe805f8580c705596e7003de4a50cbc2583" translate="yes" xml:space="preserve">
          <source>CURLcode &lt;strong id=&quot;result&quot;&gt;result&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;result&quot;&gt;Resultado de&lt;/strong&gt; CURLcode ;</target>
        </trans-unit>
        <trans-unit id="304f1ec0769d4c548febbdf47625f266fdcfab5b" translate="yes" xml:space="preserve">
          <source>CURLformoption &lt;strong id=&quot;option&quot;&gt;option&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong id=&quot;option&quot;&gt;Opci&amp;oacute;n&lt;/strong&gt; CURLformoption ;</target>
        </trans-unit>
        <trans-unit id="a4c24fe1a70e51826ba9ae7c30e20cd7e2a29828" translate="yes" xml:space="preserve">
          <source>CURLversion &lt;strong id=&quot;age&quot;&gt;age&lt;/strong&gt;;</source>
          <target state="translated">CURLversi&amp;oacute;n &lt;strong id=&quot;age&quot;&gt;edad&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b4a140e494ddd4ae40e04aab42088b88b1becbfe" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;buf&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;buf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="afe63bc0735098979cb97ac441f55ea9bf41ba0b" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;ext&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;ext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bacd88197768daee4b3de506c5c3a95e5a62751a" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; C []</target>
        </trans-unit>
        <trans-unit id="f06ae80fea6ce71846e64d1060826cd17e855a35" translate="yes" xml:space="preserve">
          <source>C[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">C [] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7150792a1546098dee35fe7a98fdfc975256a790" translate="yes" xml:space="preserve">
          <source>Cache size and behaviour</source>
          <target state="translated">Tamaño de la caché y comportamiento</target>
        </trans-unit>
        <trans-unit id="f800f99aa3df3800502bbb36ab972cc0eb0d5c0b" translate="yes" xml:space="preserve">
          <source>CacheInfo[5] &lt;strong id=&quot;datacache&quot;&gt;datacache&lt;/strong&gt;;</source>
          <target state="translated">CacheInfo [5] &lt;strong id=&quot;datacache&quot;&gt;datacache&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="6bcc4b116e2d06311b0fc9927d035dbff820590a" translate="yes" xml:space="preserve">
          <source>Calculate and return</source>
          <target state="translated">Calcule y devuelva</target>
        </trans-unit>
        <trans-unit id="3d6ed85fb2e3f634e358f0719e27875d435ea774" translate="yes" xml:space="preserve">
          <source>Calculate built-in properties which just the type is necessary.</source>
          <target state="translated">Calcular las propiedades incorporadas que sólo el tipo es necesario.</target>
        </trans-unit>
        <trans-unit id="a4aa52fc673bba9caf0d9f71c29d0ae6f9877456" translate="yes" xml:space="preserve">
          <source>Calculate field[i].overlapped and overlapUnsafe, and check that all of explicit field initializers have unique memory space on instance.</source>
          <target state="translated">Calcule el campo[i].superpuesto y solapadoInseguro,y compruebe que todos los inicializadores de campo explícitos tienen un espacio de memoria único en la instancia.</target>
        </trans-unit>
        <trans-unit id="5c68d55b4c8ec705956e2d8e0515e64b113840ed" translate="yes" xml:space="preserve">
          <source>Calculate the base-10 logarithm of x.</source>
          <target state="translated">Calcula el logaritmo base-10 de x.</target>
        </trans-unit>
        <trans-unit id="aa77a0a0c44f9dd6e1b336ed64c758b221d1485c" translate="yes" xml:space="preserve">
          <source>Calculate the length of the UTF sequence ending one code unit before &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Calcule la longitud de la secuencia UTF que termina una unidad de c&amp;oacute;digo antes del &lt;code&gt;index&lt;/code&gt; en &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14c2e14715fa06b8f138716be37c507138d963e7" translate="yes" xml:space="preserve">
          <source>Calculate the length of the UTF sequence starting at &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Calcule la longitud de la secuencia UTF comenzando en el &lt;code&gt;index&lt;/code&gt; en &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e12b3a821d4bde6f6cb14b1be6565da8f2b8ddac" translate="yes" xml:space="preserve">
          <source>Calculate the natural logarithm of x.</source>
          <target state="translated">Calcula el logaritmo natural de x.</target>
        </trans-unit>
        <trans-unit id="3f112af5d27881f2633fc0efa7c8c3ce5a0a8242" translate="yes" xml:space="preserve">
          <source>Calculate the natural logarithm of x. The branch cut is along the negative axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30b6367e2a4061ed4b790ec3600b0de931f9e1f" translate="yes" xml:space="preserve">
          <source>Calculate the next largest floating point value after x.</source>
          <target state="translated">Calcule el siguiente valor de punto flotante más grande después de x.</target>
        </trans-unit>
        <trans-unit id="b9c742d632c337bd8cbf69961edcf3221964c540" translate="yes" xml:space="preserve">
          <source>Calculate the next smallest floating point value before x.</source>
          <target state="translated">Calcula el siguiente valor de punto flotante más pequeño antes de x.</target>
        </trans-unit>
        <trans-unit id="018fa0870c360e2cac7a8c4bc28e389efc5f1613" translate="yes" xml:space="preserve">
          <source>Calculate the remainder x REM y, following IEC 60559.</source>
          <target state="translated">Calcule el resto x REM y,siguiendo la norma IEC 60559.</target>
        </trans-unit>
        <trans-unit id="3fba25e1430b0ae9ada9b4efe1168d1151f49b29" translate="yes" xml:space="preserve">
          <source>Calculates 2&lt;sup&gt;x&lt;/sup&gt;.</source>
          <target state="translated">Calcula 2 &lt;sup&gt;x&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="63c1fbfad55eb2f0634d2925033191320d7fe148" translate="yes" xml:space="preserve">
          <source>Calculates e&lt;sup&gt;x&lt;/sup&gt;.</source>
          <target state="translated">Calcula e &lt;sup&gt;x&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="552f818572293e7e3df3d8078e1d8502861c8778" translate="yes" xml:space="preserve">
          <source>Calculates the absolute value of a number</source>
          <target state="translated">Calcula el valor absoluto de un número</target>
        </trans-unit>
        <trans-unit id="4ec6328d585b956e719618a807b023dcff090ac5" translate="yes" xml:space="preserve">
          <source>Calculates the absolute value of a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be2a6f70202c3264162991c74bed6c4baae9236" translate="yes" xml:space="preserve">
          <source>Calculates the arc cosine of x, returning a value ranging from 0 to &amp;pi;.</source>
          <target state="translated">Calcula el arco coseno de x, devolviendo un valor que var&amp;iacute;a de 0 a &amp;pi;.</target>
        </trans-unit>
        <trans-unit id="d946a27b03ca4cac969d0047946f4fc66affc0fa" translate="yes" xml:space="preserve">
          <source>Calculates the arc sine of x, returning a value ranging from -&amp;pi;/2 to &amp;pi;/2.</source>
          <target state="translated">Calcula el arco seno de x, devolviendo un valor que var&amp;iacute;a de -&amp;pi; / 2 a &amp;pi; / 2.</target>
        </trans-unit>
        <trans-unit id="d9e1b5526d250f5e8ab8ddc83903cc95d1cc029a" translate="yes" xml:space="preserve">
          <source>Calculates the arc tangent of x, returning a value ranging from -&amp;pi;/2 to &amp;pi;/2.</source>
          <target state="translated">Calcula el arco tangente de x, devolviendo un valor que var&amp;iacute;a de -&amp;pi; / 2 a &amp;pi; / 2.</target>
        </trans-unit>
        <trans-unit id="3783817bf938b83309854c6205d56ee4a302e644" translate="yes" xml:space="preserve">
          <source>Calculates the arc tangent of y / x, returning a value ranging from -&amp;pi; to &amp;pi;.</source>
          <target state="translated">Calcula la arco tangente de y / x, devolviendo un valor que var&amp;iacute;a de -&amp;pi; a &amp;pi;.</target>
        </trans-unit>
        <trans-unit id="e1c3e20fd2cd7d94fdcf1efca206597755351a82" translate="yes" xml:space="preserve">
          <source>Calculates the base-2 logarithm of x: log&lt;sub&gt;2&lt;/sub&gt;x</source>
          <target state="translated">Calcula el logaritmo de base-2 de x: log &lt;sub&gt;2&lt;/sub&gt; x</target>
        </trans-unit>
        <trans-unit id="ba562ff7e573b706f15ed8cff069704fa53ed5ac" translate="yes" xml:space="preserve">
          <source>Calculates the cube root of x.</source>
          <target state="translated">Calcula la raíz cúbica de x.</target>
        </trans-unit>
        <trans-unit id="c6b3ccb038ca0414c5d73b25ada62fdde6188a5c" translate="yes" xml:space="preserve">
          <source>Calculates the hash value of &lt;code&gt;arg&lt;/code&gt; with an optional &lt;code&gt;seed&lt;/code&gt; initial value. The result might not be equal to &lt;code&gt;typeid(T).getHash(&amp;amp;arg)&lt;/code&gt;.</source>
          <target state="translated">Calcula el valor hash del &lt;code&gt;arg&lt;/code&gt; con un opcional &lt;code&gt;seed&lt;/code&gt; valor inicial. El resultado podr&amp;iacute;a no ser igual a &lt;code&gt;typeid(T).getHash(&amp;amp;arg)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6077e40f1d7c6b4630a9eabd54e9cc9ad6cdbbd5" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic cosine of x.</source>
          <target state="translated">Calcula el coseno hiperbólico de x.</target>
        </trans-unit>
        <trans-unit id="c3be2955cec737e95210a83c0153e5a7b26737f0" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic sine of x.</source>
          <target state="translated">Calcula el seno hiperbólico de x.</target>
        </trans-unit>
        <trans-unit id="836a3048b7c344efad04edc701d9a39358e4ddc2" translate="yes" xml:space="preserve">
          <source>Calculates the hyperbolic tangent of x.</source>
          <target state="translated">Calcula la tangente hiperbólica de x.</target>
        </trans-unit>
        <trans-unit id="26863b4aef8c0a694cd2e723d6778f9f04e7eb52" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic cosine of x.</source>
          <target state="translated">Calcula el coseno hiperbólico inverso de x.</target>
        </trans-unit>
        <trans-unit id="c627e3b3df39ce6438ba816e8a109c0ffed6f76d" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic sine of x.</source>
          <target state="translated">Calcula el seno hiperbólico inverso de x.</target>
        </trans-unit>
        <trans-unit id="8af98eaa49794884fefd803885cf1f1893246ddf" translate="yes" xml:space="preserve">
          <source>Calculates the inverse hyperbolic tangent of x, returning a value from ranging from -1 to 1.</source>
          <target state="translated">Calcula la tangente hiperbólica inversa de x,devolviendo un valor de entre -1 y 1.</target>
        </trans-unit>
        <trans-unit id="5c5618c4bbf47d472509dd6366443a216865a98d" translate="yes" xml:space="preserve">
          <source>Calculates the length needed to store the encoded string corresponding to an input of the given length.</source>
          <target state="translated">Calcula la longitud necesaria para almacenar la cadena codificada correspondiente a una entrada de la longitud dada.</target>
        </trans-unit>
        <trans-unit id="027e373dfea678dcf40ffef9e131551d07153fd8" translate="yes" xml:space="preserve">
          <source>Calculates the length of the hypotenuse of a right-angled triangle with sides of length x and y. The hypotenuse is the value of the square root of the sums of the squares of x and y:</source>
          <target state="translated">Calcula la longitud de la hipotenusa de un triángulo en ángulo recto con lados de longitud x y y.La hipotenusa es el valor de la raíz cuadrada de las sumas de los cuadrados de x y y:</target>
        </trans-unit>
        <trans-unit id="49efa739aec865cfda8564b9080c48989d5e33a7" translate="yes" xml:space="preserve">
          <source>Calculates the natural logarithm of 1 + x.</source>
          <target state="translated">Calcula el logaritmo natural de 1+x.</target>
        </trans-unit>
        <trans-unit id="2c06de5b0b0a99a9dfc2d0912c58bdadc98082d6" translate="yes" xml:space="preserve">
          <source>Calculates the next representable value after x in the direction of y.</source>
          <target state="translated">Calcula el siguiente valor representable después de x en la dirección de y.</target>
        </trans-unit>
        <trans-unit id="3754c2ce035cf1b13a7cd37e615749fb652610b4" translate="yes" xml:space="preserve">
          <source>Calculates the number of set bits in an integer using the X86 SSE4 POPCNT instruction. POPCNT is not available on all X86 CPUs.</source>
          <target state="translated">Calcula el número de bits de un entero usando la instrucción X86 SSE4 POPCNT.POPCNT no está disponible en todas las CPUs X86.</target>
        </trans-unit>
        <trans-unit id="06d72e9a8ced5d5423191cc63ca6b46b4610af0d" translate="yes" xml:space="preserve">
          <source>Calculates the number of set bits in an integer.</source>
          <target state="translated">Calcula el número de bits fijos en un número entero.</target>
        </trans-unit>
        <trans-unit id="9a6eed62af9d1a47c1ab6bc79899d39e32a6483a" translate="yes" xml:space="preserve">
          <source>Calculates the remainder from the calculation x/y.</source>
          <target state="translated">Calcula el resto a partir del cálculo x/y.</target>
        </trans-unit>
        <trans-unit id="fe24886c3219456f2196eb244fb852afd4fb56a9" translate="yes" xml:space="preserve">
          <source>Calculates the value of the natural logarithm base (e) raised to the power of x, minus 1.</source>
          <target state="translated">Calcula el valor de la base del logaritmo natural (e)elevado a la potencia de x,menos 1.</target>
        </trans-unit>
        <trans-unit id="af2f291e997ca41e56ba422f46bf86ff11ebb79d" translate="yes" xml:space="preserve">
          <source>Calculates x&lt;sup&gt;n&lt;/sup&gt;. The branch cut is on the negative axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f6cce6873a9a6bb919b268ff433dd1e133a874" translate="yes" xml:space="preserve">
          <source>Calculates x&lt;sup&gt;y&lt;/sup&gt;.</source>
          <target state="translated">Calcula x &lt;sup&gt;y&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="801ce4a0b5aa9b661ade0819332605cc7b1ae809" translate="yes" xml:space="preserve">
          <source>Call each of the connected slots, passing the argument(s) i to them. Nested call will be ignored.</source>
          <target state="translated">Llama a cada una de las ranuras conectadas,pasándoles los argumentos i.La llamada anidada será ignorada.</target>
        </trans-unit>
        <trans-unit id="5f9f4deb84100f6aec181820d5a751140cd068c1" translate="yes" xml:space="preserve">
          <source>Call this after printing out fatal error messages to clean up and exit the compiler.</source>
          <target state="translated">Llámalo después de imprimir mensajes de error fatales para limpiar y salir del compilador.</target>
        </trans-unit>
        <trans-unit id="f75e5681020d520d2c6f752e809e81b0c81a85b8" translate="yes" xml:space="preserve">
          <source>CallExp &lt;code&gt;ce&lt;/code&gt;</source>
          <target state="translated">CallExp &lt;code&gt;ce&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf7b36d93b4e5475d0f1769a4ea2f0934f697c5" translate="yes" xml:space="preserve">
          <source>Callback for each received StatusLine.</source>
          <target state="translated">Devolución de llamada para cada StatusLine recibido.</target>
        </trans-unit>
        <trans-unit id="f3869aa6b3628e9280e1301a0819ce5b27364caa" translate="yes" xml:space="preserve">
          <source>Callback function for opening socket (instead of socket(2)). Optionally, callback is able change the address or refuse to connect returning CURL_SOCKET_BAD. The callback should have type curl_opensocket_callback</source>
          <target state="translated">Función de retrollamada para la apertura del enchufe (en lugar del enchufe(2)).Opcionalmente,la llamada de retorno es capaz de cambiar la dirección o rechazar la conexión regresando CURL_SOCKET_BAD.La llamada de retorno debe tener el tipo curl_opensocket_callback</target>
        </trans-unit>
        <trans-unit id="fa6c180b210d6c195ea47a0f5808f2e991c787e3" translate="yes" xml:space="preserve">
          <source>Callback function for seeking in the input stream</source>
          <target state="translated">Función de retrollamada para buscar en el flujo de entrada</target>
        </trans-unit>
        <trans-unit id="d4829fe836ac65e604efec860420d6bb34e163e7" translate="yes" xml:space="preserve">
          <source>Callback implementation user data</source>
          <target state="translated">Datos de usuario de la implementación de la devolución de llamada</target>
        </trans-unit>
        <trans-unit id="7958bba34f83b3f0d9bec51f1aa784c3099f4330" translate="yes" xml:space="preserve">
          <source>Callback options.</source>
          <target state="translated">Opciones de devolución de llamada.</target>
        </trans-unit>
        <trans-unit id="2c70d267e735763e25416c3729426a88c83fd93c" translate="yes" xml:space="preserve">
          <source>Callback parameters</source>
          <target state="translated">Parámetros de retrollamada</target>
        </trans-unit>
        <trans-unit id="83da71c0b0c98f854fd142c883ddfbc56d402d5a" translate="yes" xml:space="preserve">
          <source>Callback returns</source>
          <target state="translated">Devoluciones de llamadas</target>
        </trans-unit>
        <trans-unit id="5277f74ec6b2c07897ae08c4150298f4a47bfee7" translate="yes" xml:space="preserve">
          <source>Callback routine requested an abort</source>
          <target state="translated">La rutina de devolución de llamada solicitó un aborto</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="9d7a88bd45dd2018e4f369390635318ba64e842f" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad &lt;code&gt;opOpAssign&lt;/code&gt; call (one that loses precision or attempts to convert a negative value to an unsigned type).</source>
          <target state="translated">Se &lt;code&gt;opOpAssign&lt;/code&gt; autom&amp;aacute;ticamente cuando hay una llamada opOpAssign incorrecta (una que pierde precisi&amp;oacute;n o intenta convertir un valor negativo a un tipo sin signo).</target>
        </trans-unit>
        <trans-unit id="7102900b536c87cd1ddcccfc7367f11bb9536bf4" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad cast (one that loses precision or attempts to convert a negative value to an unsigned type). The source type is &lt;code&gt;Src&lt;/code&gt; and the destination type is &lt;code&gt;Dst&lt;/code&gt;.</source>
          <target state="translated">Se invoca autom&amp;aacute;ticamente cuando se emite un error (uno que pierde precisi&amp;oacute;n o intenta convertir un valor negativo en un tipo sin signo). El tipo de origen es &lt;code&gt;Src&lt;/code&gt; y el tipo de destino es &lt;code&gt;Dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09ced3e78029e52a33dba4c3dc622cbf4db610e5" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bad cast from &lt;code&gt;src&lt;/code&gt; to type &lt;code&gt;Dst&lt;/code&gt; (one that loses precision or attempts to convert a negative value to an unsigned type).</source>
          <target state="translated">Se invoca autom&amp;aacute;ticamente cuando se emite un error desde &lt;code&gt;src&lt;/code&gt; para escribir &lt;code&gt;Dst&lt;/code&gt; (uno que pierde precisi&amp;oacute;n o intenta convertir un valor negativo en un tipo sin signo).</target>
        </trans-unit>
        <trans-unit id="1b890f532573803598c95ff0855037312602e65a" translate="yes" xml:space="preserve">
          <source>Called automatically upon a bounds error.</source>
          <target state="translated">Llamado automáticamente por un error de límites.</target>
        </trans-unit>
        <trans-unit id="cec93f38cfc349e778449343568f595e85578df6" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. In case of a erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), this hook issues &lt;code&gt;assert(0)&lt;/code&gt; which terminates the application.</source>
          <target state="translated">Llamado autom&amp;aacute;ticamente sobre una comparaci&amp;oacute;n para la igualdad. En caso de una comparaci&amp;oacute;n err&amp;oacute;nea (una que har&amp;iacute;a que un valor negativo con signo pareciera igual a un valor positivo sin signo), este enlace emite &lt;code&gt;assert(0)&lt;/code&gt; que finaliza la aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0d9a0c46bb6698d633be1a9f6fd1250d9925d992" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. In case of an Erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), writes a warning message to &lt;code&gt;stderr&lt;/code&gt; as a side effect.</source>
          <target state="translated">Llamado autom&amp;aacute;ticamente sobre una comparaci&amp;oacute;n para la igualdad. En caso de una comparaci&amp;oacute;n err&amp;oacute;nea (una que har&amp;iacute;a que un valor negativo con signo pareciera igual a un valor positivo sin signo), escribe un mensaje de advertencia en &lt;code&gt;stderr&lt;/code&gt; como efecto secundario.</target>
        </trans-unit>
        <trans-unit id="c5f36c313c02bf2d55947333ca1b1ce5b5e726cd" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for equality. Throws upon an erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value).</source>
          <target state="translated">Llamado automáticamente a una comparación para la igualdad.Se lanza sobre una comparación errónea (una que haría que un valor negativo firmado pareciera igual a un valor positivo no firmado).</target>
        </trans-unit>
        <trans-unit id="482787b051181ec9851e392f48ceca8d8cc29f3f" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then a warning message is printed to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">Llamado autom&amp;aacute;ticamente al hacer una comparaci&amp;oacute;n para ordenar usando uno de los operadores &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;gt;=&lt;/code&gt; . En caso de que la comparaci&amp;oacute;n sea err&amp;oacute;nea (es decir, har&amp;iacute;a que un valor negativo con signo pareciera mayor o igual que un valor positivo sin signo), se imprime un mensaje de advertencia en &lt;code&gt;stderr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f347895ce62ab753804db2ed8acefc457ef89fc4" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then application is terminated with &lt;code&gt;assert(0)&lt;/code&gt;. Otherwise, the three-state result is returned (positive if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">Llamado autom&amp;aacute;ticamente al hacer una comparaci&amp;oacute;n para ordenar usando uno de los operadores &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;gt;=&lt;/code&gt; . En caso de que la comparaci&amp;oacute;n sea err&amp;oacute;nea (es decir, har&amp;iacute;a que un valor negativo con signo pareciera mayor o igual que un valor positivo sin signo), la aplicaci&amp;oacute;n se termina con &lt;code&gt;assert(0)&lt;/code&gt; . De lo contrario, se devuelve el resultado de tres estados (positivo si &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; , negativo si &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; en caso contrario).</target>
        </trans-unit>
        <trans-unit id="fd9dee545de2de37ec8d225d3452d9b9db4a4de3" translate="yes" xml:space="preserve">
          <source>Called automatically upon a comparison for ordering using one of the operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), throws a &lt;code&gt;Throw.CheckFailure&lt;/code&gt; exception. Otherwise, the three-state result is returned (positive if &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;, negative if &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; otherwise).</source>
          <target state="translated">Llamado autom&amp;aacute;ticamente al hacer una comparaci&amp;oacute;n para ordenar usando uno de los operadores &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;gt;=&lt;/code&gt; . En caso de que la comparaci&amp;oacute;n sea err&amp;oacute;nea (es decir, har&amp;iacute;a que un valor negativo con signo parezca mayor o igual que un valor positivo sin signo), &lt;code&gt;Throw.CheckFailure&lt;/code&gt; una excepci&amp;oacute;n Throw.CheckFailure . De lo contrario, se devuelve el resultado de tres estados (positivo si &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; , negativo si &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; en caso contrario).</target>
        </trans-unit>
        <trans-unit id="288a3bb051cf2f7e5a316c4d4e70d5118f188801" translate="yes" xml:space="preserve">
          <source>Called automatically upon an overflow during a unary or binary operation.</source>
          <target state="translated">Llamado automáticamente en caso de desbordamiento durante una operación unaria o binaria.</target>
        </trans-unit>
        <trans-unit id="18ffd2396df8d946aeaff03367807e9289b502e5" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;accept&lt;/code&gt; when a new &lt;code&gt;Socket&lt;/code&gt; must be created for a new connection. To use a derived class, override this method and return an instance of your class. The returned &lt;code&gt;Socket&lt;/code&gt;'s handle must not be set; &lt;code&gt;Socket&lt;/code&gt; has a protected constructor &lt;code&gt;this()&lt;/code&gt; to use in this situation.</source>
          <target state="translated">Llamado por &lt;code&gt;accept&lt;/code&gt; cuando se debe crear un nuevo &lt;code&gt;Socket&lt;/code&gt; para una nueva conexi&amp;oacute;n. Para usar una clase derivada, anule este m&amp;eacute;todo y devuelva una instancia de su clase. El identificador de &lt;code&gt;Socket&lt;/code&gt; devuelto no debe establecerse; &lt;code&gt;Socket&lt;/code&gt; tiene un constructor protegido &lt;code&gt;this()&lt;/code&gt; para usar en esta situaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b54f1e19b12e53615e8a653c409ba5ab2951a872" translate="yes" xml:space="preserve">
          <source>Called by D code to throw an exception via</source>
          <target state="translated">Llamado por el código D para lanzar una excepción a través de</target>
        </trans-unit>
        <trans-unit id="1ca7f5a39bbf37ff1a678bd1aa4c79aba11959d4" translate="yes" xml:space="preserve">
          <source>Called by SQLite to clean up pUser</source>
          <target state="translated">Llamado por SQLite para limpiar el pUser</target>
        </trans-unit>
        <trans-unit id="9743db8f1711c6b311db6267994885195b8a6347" translate="yes" xml:space="preserve">
          <source>Called by libcurl whenever the library detects a change in the maximum number of milliseconds the app is allowed to wait before curl_multi_socket() or curl_multi_perform() must be called (to allow libcurl's timed events to take place).</source>
          <target state="translated">Llamado por libcurl siempre que la biblioteca detecta un cambio en el número máximo de milisegundos que la aplicación puede esperar antes de que curl_multi_socket()o curl_multi_perform()deba ser llamado (para permitir que los eventos temporales de libcurl tengan lugar).</target>
        </trans-unit>
        <trans-unit id="3edd2c76a126518315d7a71140c73140e3fc8324" translate="yes" xml:space="preserve">
          <source>Called during runtime initialization to initialize a GC instance of given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Llamado durante la inicializaci&amp;oacute;n del tiempo de ejecuci&amp;oacute;n para inicializar una instancia de GC de un &lt;code&gt;name&lt;/code&gt; dado .</target>
        </trans-unit>
        <trans-unit id="6980b4453fbc6893945f9512aa33baa854c12d55" translate="yes" xml:space="preserve">
          <source>Called from back end.</source>
          <target state="translated">Llamó desde la parte de atrás.</target>
        </trans-unit>
        <trans-unit id="f90881b5eb5e600ad18d60ab2849afead809fc76" translate="yes" xml:space="preserve">
          <source>Called once per thread; returns array of thread local storage ranges</source>
          <target state="translated">Llamado una vez por hilo;devuelve un conjunto de rangos de almacenamiento local de hilos</target>
        </trans-unit>
        <trans-unit id="7a912bc6a899a5bd4ea502581245c2ef16bd2966" translate="yes" xml:space="preserve">
          <source>Called when fibers switch contexts.</source>
          <target state="translated">Llamado cuando las fibras cambian de contexto.</target>
        </trans-unit>
        <trans-unit id="c0acd999c318ee36079d9ad700960738ccee34ac" translate="yes" xml:space="preserve">
          <source>Called when setting a version identifier, e.g. &lt;code&gt;-version=identifier&lt;/code&gt; parameter to the compiler or &lt;code&gt;version = Foo&lt;/code&gt; in user code.</source>
          <target state="translated">Se llama cuando se establece un identificador de versi&amp;oacute;n, por ejemplo, &lt;code&gt;-version=identifier&lt;/code&gt; par&amp;aacute;metro identificador para el compilador o &lt;code&gt;version = Foo&lt;/code&gt; en el c&amp;oacute;digo de usuario.</target>
        </trans-unit>
        <trans-unit id="495dea06203f25ae26116f2f5772a696918832bd" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#reset&quot;&gt;&lt;code&gt;reset&lt;/code&gt;&lt;/a&gt; will reset this to &lt;code&gt;Duration.zero&lt;/code&gt;.</source>
          <target state="translated">Llamar a &lt;a href=&quot;#reset&quot;&gt; &lt;code&gt;reset&lt;/code&gt; &lt;/a&gt; restablecer&amp;aacute; esto a &lt;code&gt;Duration.zero&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f23a63a5505f1213693ee8224d96b5310cf3183b" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#kill&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt; with the resulting &lt;code&gt;Pid&lt;/code&gt; is invalid.</source>
          <target state="translated">Llamar a &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#kill&quot;&gt; &lt;code&gt;kill&lt;/code&gt; &lt;/a&gt; con el &lt;code&gt;Pid&lt;/code&gt; resultante no es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="796201301481a494676b87bd22f58df79f6f3bdb" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;printf()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69ccd3a1a7e462d569968184a6624c2a8f6e037" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;reopen&lt;/code&gt; with a &lt;code&gt;null&lt;/code&gt;&lt;code&gt;name&lt;/code&gt; is not implemented in all C runtimes.</source>
          <target state="translated">Llamar a &lt;code&gt;reopen&lt;/code&gt; con un &lt;code&gt;name&lt;/code&gt; &lt;code&gt;null&lt;/code&gt; no se implementa en todos los tiempos de ejecuci&amp;oacute;n de C.</target>
        </trans-unit>
        <trans-unit id="8a670c32e5ff77bac0fbdbb4ed6c86d3156f5f82" translate="yes" xml:space="preserve">
          <source>Calling C Functions</source>
          <target state="translated">Llamando a las funciones C</target>
        </trans-unit>
        <trans-unit id="2a58b71a9eba354c8a2762dcf96889501c4c8b2f" translate="yes" xml:space="preserve">
          <source>Calling C++ Global Functions from D</source>
          <target state="translated">Llamando a C++Funciones Globales desde D</target>
        </trans-unit>
        <trans-unit id="0af92a8a9a70b3aa97a6e09d334eff695960b293" translate="yes" xml:space="preserve">
          <source>Calling CTFE-able functions or using manifest constants is also possible.</source>
          <target state="translated">También es posible llamar a las funciones aptas para CTFE o utilizar constantes manifiestas.</target>
        </trans-unit>
        <trans-unit id="ab9616e4fb5ac458c376db23b38a3a4f41bdffa3" translate="yes" xml:space="preserve">
          <source>Calling Global D Functions From C++</source>
          <target state="translated">Llamando a las funciones globales D desde C++</target>
        </trans-unit>
        <trans-unit id="011de1cd8c5a8313b4819150b58f7b77ffe1686b" translate="yes" xml:space="preserve">
          <source>Calling an Instance Method</source>
          <target state="translated">Llamando a un método de instancia</target>
        </trans-unit>
        <trans-unit id="882cd8e97a7e6dec1b20f7ffc308265e42981f07" translate="yes" xml:space="preserve">
          <source>Calling an Objective-C instance method uses the same syntax as calling regular D methods:</source>
          <target state="translated">Llamar a un método de instancia Objetivo-C utiliza la misma sintaxis que llamar a los métodos regulares D:</target>
        </trans-unit>
        <trans-unit id="2837bac68cbbca90ef92df0ecb7045b8bad05e30" translate="yes" xml:space="preserve">
          <source>Calling any system functions.</source>
          <target state="translated">Llamando a cualquier función del sistema.</target>
        </trans-unit>
        <trans-unit id="99afec36350160ba55067caa792fb170d47da7f2" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the @nogc-ness, i.e. if we're in a @nogc function we can only call other @nogc functions. Returns true if error occurs.</source>
          <target state="translated">Llamar función f.Comprobar la @nogc-ness,es decir,si estamos en una función @nogc sólo podemos llamar a otras funciones @nogc.Devuelve verdadero si se produce un error.</target>
        </trans-unit>
        <trans-unit id="889558fe1d6b373ebfb4108727201ca1efea7bd9" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the purity, i.e. if we're in a pure function we can only call other pure functions. Returns true if error occurs.</source>
          <target state="translated">Llamar función f.Comprobar la pureza,es decir,si estamos en una función pura sólo podemos llamar a otras funciones puras.Devuelve verdadero si se produce un error.</target>
        </trans-unit>
        <trans-unit id="9d07dff2f17d03cbf0372862de2a911c37b1df31" translate="yes" xml:space="preserve">
          <source>Calling function f. Check the safety, i.e. if we're in a @safe function we can only call @safe or @trusted functions. Returns true if error occurs.</source>
          <target state="translated">Llamar función f.Comprobar la seguridad,es decir,si estamos en una función @segura sólo podemos llamar a las funciones @segura o @confianza.Devuelve verdadero si se produce un error.</target>
        </trans-unit>
        <trans-unit id="49f72934b9748e8925ba7a574cd2caf074e942d5" translate="yes" xml:space="preserve">
          <source>Calling printf()</source>
          <target state="translated">Llamando a printf()</target>
        </trans-unit>
        <trans-unit id="06859dbd6f7a9d0b1a468c855675188601e16f52" translate="yes" xml:space="preserve">
          <source>Calling this function sets a flag indicating that this struct is no longer worker-local, and attempting to use the &lt;code&gt;get&lt;/code&gt; method again will result in an assertion failure if assertions are enabled.</source>
          <target state="translated">Al llamar a esta funci&amp;oacute;n se establece un indicador que indica que esta estructura ya no es local para el trabajador, e intentar usar el m&amp;eacute;todo &lt;code&gt;get&lt;/code&gt; nuevamente dar&amp;aacute; como resultado un error de aserci&amp;oacute;n si las aserciones est&amp;aacute;n habilitadas.</target>
        </trans-unit>
        <trans-unit id="c5e417ef005e02e78fdb802550dfe5fd2fa097a5" translate="yes" xml:space="preserve">
          <source>Calling this function with &lt;code&gt;blocking = true&lt;/code&gt; from a worker thread that is a member of the same &lt;code&gt;TaskPool&lt;/code&gt; that &lt;code&gt;finish&lt;/code&gt; is being called on will result in a deadlock.</source>
          <target state="translated">Llamar a esta funci&amp;oacute;n con &lt;code&gt;blocking = true&lt;/code&gt; de un subproceso de trabajo que es un miembro de la misma &lt;code&gt;TaskPool&lt;/code&gt; que &lt;code&gt;finish&lt;/code&gt; est&amp;aacute; llamado dar&amp;aacute; lugar a un punto muerto.</target>
        </trans-unit>
        <trans-unit id="a483b09288907bf0c6892b8a0c3a3688580a1534" translate="yes" xml:space="preserve">
          <source>Calling this function, and then using references to data located after the given array results in undefined behavior.</source>
          <target state="translated">Llamar a esta función,y luego usar referencias a datos localizados después del arreglo dado resulta en un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="0a48762ee3e2f7b163567b2b8c2bdc321fb3d29c" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fflush.html&quot;&gt;fflush&lt;/a&gt; for the file handle.</source>
          <target state="translated">Llamadas &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fflush.html&quot;&gt;fflush&lt;/a&gt; para el identificador de archivo.</target>
        </trans-unit>
        <trans-unit id="5fa582845b2a8965acb06e6a0955d839742fab8a" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fread.html&quot;&gt;fread&lt;/a&gt; for the file handle. The number of items to read and the size of each item is inferred from the size and type of the input array, respectively.</source>
          <target state="translated">Llama a &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fread.html&quot;&gt;fread&lt;/a&gt; para el identificador de archivo. El n&amp;uacute;mero de elementos a leer y el tama&amp;ntilde;o de cada elemento se infiere del tama&amp;ntilde;o y tipo de la matriz de entrada, respectivamente.</target>
        </trans-unit>
        <trans-unit id="4204f336078b400c2ca8218f3dc707eed9fc8eef" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fseek.html&quot;&gt;fseek&lt;/a&gt; for the file handle to move its position indicator.</source>
          <target state="translated">Llama a &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fseek.html&quot;&gt;fseek&lt;/a&gt; para que el identificador de archivo mueva su indicador de posici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b841aa017960fa21330d3bce71d1341f08261fc1" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ftell.html&quot;&gt;ftell&lt;/a&gt; for the managed file handle.</source>
          <target state="translated">Llama a &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ftell.html&quot;&gt;ftell&lt;/a&gt; para el identificador de archivo administrado.</target>
        </trans-unit>
        <trans-unit id="19416b73e0b0cfe1706209f1904f9557babb3844" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fwrite.html&quot;&gt;fwrite&lt;/a&gt; for the file handle. The number of items to write and the size of each item is inferred from the size and type of the input array, respectively. An error is thrown if the buffer could not be written in its entirety.</source>
          <target state="translated">Llama a &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fwrite.html&quot;&gt;fwrite&lt;/a&gt; para el identificador de archivo. El n&amp;uacute;mero de elementos a escribir y el tama&amp;ntilde;o de cada elemento se infiere del tama&amp;ntilde;o y tipo de la matriz de entrada, respectivamente. Se genera un error si el b&amp;uacute;fer no se pudo escribir en su totalidad.</target>
        </trans-unit>
        <trans-unit id="b50971f4c5e8a0e45c73e7c7c90d36d61fddcb7f" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/rewind.html&quot;&gt;rewind&lt;/a&gt; for the file handle.</source>
          <target state="translated">Las llamadas &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/rewind.html&quot;&gt;rebobinan&lt;/a&gt; para el identificador de archivo.</target>
        </trans-unit>
        <trans-unit id="6954ffddc60a249c70b2b20272f1b59673a22e6b" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html&quot;&gt;setvbuf&lt;/a&gt; for the file handle.</source>
          <target state="translated">Llama a &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html&quot;&gt;setvbuf&lt;/a&gt; para el identificador de archivo.</target>
        </trans-unit>
        <trans-unit id="660af3415b8af8c796363c6a336c94f83d470574" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;StorageClassDeclaration.newScope&lt;/code&gt; (as it must be called or copied in any function overriding &lt;code&gt;newScope&lt;/code&gt;), then set the &lt;code&gt;Scope&lt;/code&gt;'s depdecl.</source>
          <target state="translated">Las llamadas &lt;code&gt;StorageClassDeclaration.newScope&lt;/code&gt; (como debe ser llamado o copiarse en cualquier funci&amp;oacute;n primordial &lt;code&gt;newScope&lt;/code&gt; ), a continuaci&amp;oacute;n, establecer el &lt;code&gt;Scope&lt;/code&gt; 's depdecl.</target>
        </trans-unit>
        <trans-unit id="ea66981f1c839cec218fd677425515ff882faad6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;free(b.ptr)&lt;/code&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">Llamadas &lt;code&gt;free(b.ptr)&lt;/code&gt; en Posix y &lt;a href=&quot;http://msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_free(b.ptr)&lt;/code&gt; &lt;/a&gt; en Windows.</target>
        </trans-unit>
        <trans-unit id="e076da4834d8b045458f6ec7dd1c5d3b78bd298c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;impl.deallocateAll()&lt;/code&gt; and returns the result if defined, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Llama a &lt;code&gt;impl.deallocateAll()&lt;/code&gt; y devuelve el resultado si est&amp;aacute; definido; de lo contrario, devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b0309269b86732c6de69ae225028495fc3e76bc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;move(a, b)&lt;/code&gt; for each element &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; and the corresponding element &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;tgt&lt;/code&gt;, in increasing order, stopping when either range has been exhausted.</source>
          <target state="translated">Las llamadas se &lt;code&gt;move(a, b)&lt;/code&gt; para cada elemento &lt;code&gt;a&lt;/code&gt; en &lt;code&gt;src&lt;/code&gt; y el elemento correspondiente &lt;code&gt;b&lt;/code&gt; en &lt;code&gt;tgt&lt;/code&gt; , en orden creciente, deteni&amp;eacute;ndose cuando cualquiera de los rangos se ha agotado.</target>
        </trans-unit>
        <trans-unit id="b3aff67db2952371a04e1469cf552b2bafe5ed21" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;move(a, b)&lt;/code&gt; for each element &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; and the corresponding element &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;tgt&lt;/code&gt;, in increasing order.</source>
          <target state="translated">Las llamadas se &lt;code&gt;move(a, b)&lt;/code&gt; para cada elemento &lt;code&gt;a&lt;/code&gt; en &lt;code&gt;src&lt;/code&gt; y el elemento correspondiente &lt;code&gt;b&lt;/code&gt; en &lt;code&gt;tgt&lt;/code&gt; , en orden creciente.</target>
        </trans-unit>
        <trans-unit id="9326ff35ce625813cb6e134a6874955a7343c986" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;popBack&lt;/code&gt; for all controlled ranges.</source>
          <target state="translated">Llama a &lt;code&gt;popBack&lt;/code&gt; para todos los rangos controlados.</target>
        </trans-unit>
        <trans-unit id="1cb6a5ebd9c3d585d565184c781a892ebfa3d0e5" translate="yes" xml:space="preserve">
          <source>Calls dg(Dsymbol *sym) for each Dsymbol.</source>
          <target state="translated">Llama a dg(Símbolo *simple)para cada Símbolo.</target>
        </trans-unit>
        <trans-unit id="f0ea91146057c0154bb8b4caec2606cab70e289d" translate="yes" xml:space="preserve">
          <source>Calls dg(Dsymbol *sym) for each Dsymbol. If dg returns !=0, stops and returns that value else returns 0.</source>
          <target state="translated">Llama a dg(Símbolo *simple)para cada Símbolo.Si dg devuelve !=0,se detiene y devuelve ese valor,si no,devuelve 0.</target>
        </trans-unit>
        <trans-unit id="20447109fe962cd134aaca38e701f9a14ee5ab9e" translate="yes" xml:space="preserve">
          <source>Calls the destructor &lt;code&gt;~this()&lt;/code&gt; for the object referred to by &lt;code&gt;x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; is a class or interface reference) or for the object pointed to by &lt;code&gt;x&lt;/code&gt; (if &lt;code&gt;x&lt;/code&gt; is a pointer to a &lt;code&gt;struct&lt;/code&gt;). Arrays of structs call the destructor, if defined, for each element in the array. If no destructor is defined, this step has no effect.</source>
          <target state="translated">Llama al destructor &lt;code&gt;~this()&lt;/code&gt; para el objeto al que hace referencia &lt;code&gt;x&lt;/code&gt; (si &lt;code&gt;x&lt;/code&gt; es una referencia de clase o interfaz) o para el objeto al que apunta &lt;code&gt;x&lt;/code&gt; (si &lt;code&gt;x&lt;/code&gt; es un puntero a una &lt;code&gt;struct&lt;/code&gt; ). Las matrices de estructuras llaman al destructor, si est&amp;aacute; definido, para cada elemento de la matriz. Si no se define un destructor, este paso no tiene efecto.</target>
        </trans-unit>
        <trans-unit id="d91be267ab03b3c9611f9cbcd4786308f2144fc6" translate="yes" xml:space="preserve">
          <source>Calls to functions with &lt;code&gt;extern(D)&lt;/code&gt;&lt;a href=&quot;attribute#linkage&quot;&gt;linkage&lt;/a&gt; (which is the default linkage) are evaluated in the following order: first, if necessary, the address of the function to call is evaluated (e.g. in the case of a computed function pointer or delegate). Then, arguments are evaluated left to right. Finally, transfer is passed to the function. Example:</source>
          <target state="translated">Las llamadas a funciones con &lt;a href=&quot;attribute#linkage&quot;&gt;enlace &lt;/a&gt; &lt;code&gt;extern(D)&lt;/code&gt; (que es el enlace predeterminado) se eval&amp;uacute;an en el siguiente orden: primero, si es necesario, se eval&amp;uacute;a la direcci&amp;oacute;n de la funci&amp;oacute;n a llamar (por ejemplo, en el caso de un puntero o delegado de funci&amp;oacute;n calculado) . Luego, los argumentos se eval&amp;uacute;an de izquierda a derecha. Finalmente, la transferencia se pasa a la funci&amp;oacute;n. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="0645e6f6a8a53952c04e63653f8086d201146bb8" translate="yes" xml:space="preserve">
          <source>Calls to the free standing log functions are not directly forwarded to the global &lt;code&gt;Logger&lt;/code&gt;&lt;code&gt;sharedLog&lt;/code&gt;. Actually, a thread local &lt;code&gt;Logger&lt;/code&gt; of type &lt;code&gt;StdForwardLogger&lt;/code&gt; processes the log call and then, by default, forwards the created &lt;code&gt;Logger.LogEntry&lt;/code&gt; to the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;. The thread local &lt;code&gt;Logger&lt;/code&gt; is accessible by the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; property. This property allows to assign user defined &lt;code&gt;Logger&lt;/code&gt;. The default &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt; is &lt;code&gt;LogLevel.all&lt;/code&gt; and it will therefore forward all messages to the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;. The &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; can be used to filter log calls before they reach the &lt;code&gt;sharedLog&lt;/code&gt;&lt;code&gt;Logger&lt;/code&gt;.</source>
          <target state="translated">Las llamadas a las funciones de registro independientes no se reenv&amp;iacute;an directamente al &lt;code&gt;Logger&lt;/code&gt; global &lt;code&gt;sharedLog&lt;/code&gt; . En realidad, una secuencia de procesamiento local &lt;code&gt;Logger&lt;/code&gt; de tipo &lt;code&gt;StdForwardLogger&lt;/code&gt; procesa el registro de llamadas y, a continuaci&amp;oacute;n, de forma predeterminada, reenv&amp;iacute;a el creado &lt;code&gt;Logger.LogEntry&lt;/code&gt; a la &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; . La secuencia de procesamiento local &lt;code&gt;Logger&lt;/code&gt; es accesible por el &lt;code&gt;stdThreadLocalLog&lt;/code&gt; propiedad. Esta propiedad permite asignar un &lt;code&gt;Logger&lt;/code&gt; definido por el usuario . El valor por defecto &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;stdThreadLocalLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; es &lt;code&gt;LogLevel.all&lt;/code&gt; y por lo tanto va a reenviar todos los mensajes a la &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; . El &lt;code&gt;LogLevel&lt;/code&gt; de &lt;code&gt;stdThreadLocalLog&lt;/code&gt; se puede usar para filtrar las llamadas de registro antes de que lleguen al &lt;code&gt;sharedLog&lt;/code&gt; &lt;code&gt;Logger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb904d86116e0af2b9834a7896df4545d587c42c" translate="yes" xml:space="preserve">
          <source>Can also assign class values</source>
          <target state="translated">También puede asignar valores de clase</target>
        </trans-unit>
        <trans-unit id="0e9fa73b910a6a2eb1eaa95a1ab5ac09bd2a00f0" translate="yes" xml:space="preserve">
          <source>Can be called from either the driver or a &lt;code&gt;debug = Ident;&lt;/code&gt; statement. Unlike version identifier, there isn't any reserved debug identifier so no validation takes place.</source>
          <target state="translated">Se puede llamar desde el controlador o desde un &lt;code&gt;debug = Ident;&lt;/code&gt; declaraci&amp;oacute;n. A diferencia del identificador de versi&amp;oacute;n, no hay ning&amp;uacute;n identificador de depuraci&amp;oacute;n reservado, por lo que no se realiza ninguna validaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="38f77fd06cc4025566434eff583d8ad55911f526" translate="yes" xml:space="preserve">
          <source>Can be overridden to support other addresses.</source>
          <target state="translated">Puede ser anulado para apoyar otras direcciones.</target>
        </trans-unit>
        <trans-unit id="b93c4ede92c61cd906a3c26c9c976c09eb1f2fc5" translate="yes" xml:space="preserve">
          <source>Can start enumeration from a negative position:</source>
          <target state="translated">Puede comenzar la enumeración desde una posición negativa:</target>
        </trans-unit>
        <trans-unit id="9a5600ddf1629b08398131936e3e9652bd1d2e46" translate="yes" xml:space="preserve">
          <source>Can variable be read and written by CTFE?</source>
          <target state="translated">¿Puede la variable ser leída y escrita por la CTFE?</target>
        </trans-unit>
        <trans-unit id="3b92458a5ee7b262130f2150d91ab4bffe0cab98" translate="yes" xml:space="preserve">
          <source>Can't run semantic on s now, try again later.</source>
          <target state="translated">No puedo ejecutar la semántica ahora,inténtalo de nuevo más tarde.</target>
        </trans-unit>
        <trans-unit id="65065adca48747308c795b0ca8e2fa3439ca68c0" translate="yes" xml:space="preserve">
          <source>Canadian_Aboriginal</source>
          <target state="translated">Canadian_Aboriginal</target>
        </trans-unit>
        <trans-unit id="77dfd2135f4db726c47299bb55be26f7f4525a46" translate="yes" xml:space="preserve">
          <source>Cancel</source>
          <target state="translated">Cancel</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">Cancelar la carga de la extensión automática</target>
        </trans-unit>
        <trans-unit id="33b8203d640b9445058eff13b7f608ffa2a1d260" translate="yes" xml:space="preserve">
          <source>Cannot access &lt;code&gt;__gshared&lt;/code&gt; variables.</source>
          <target state="translated">No se puede acceder a &lt;code&gt;__gshared&lt;/code&gt; variables __gshared .</target>
        </trans-unit>
        <trans-unit id="23679ec318316b42991fb0add8c6df84610db970" translate="yes" xml:space="preserve">
          <source>Cannot access unions that have pointers or references overlapping with other types.</source>
          <target state="translated">No se puede acceder a las uniones que tienen punteros o referencias que se superponen con otros tipos.</target>
        </trans-unit>
        <trans-unit id="486e3c068e9f84acb903fe338c21a7a8da40f7e4" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;void&lt;/code&gt; initializers for class or interface references.</source>
          <target state="translated">No se pueden usar inicializadores &lt;code&gt;void&lt;/code&gt; para referencias de clase o interfaz.</target>
        </trans-unit>
        <trans-unit id="71a9611e8c1a236df296e1967a0f6238ddd70798" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;void&lt;/code&gt; initializers for pointers.</source>
          <target state="translated">No se pueden usar inicializadores &lt;code&gt;void&lt;/code&gt; para punteros.</target>
        </trans-unit>
        <trans-unit id="774c0fbc4f368f6c2081f7a0dddc8b68729cb7f6" translate="yes" xml:space="preserve">
          <source>Canonical decomposition. The result is canonically equivalent sequence.</source>
          <target state="translated">Descomposición canónica.El resultado es una secuencia canónicamente equivalente.</target>
        </trans-unit>
        <trans-unit id="aae48ee7b1f403f38486b8bf47778fda77282b5f" translate="yes" xml:space="preserve">
          <source>Canonical name, when &lt;code&gt;AddressInfoFlags.CANONNAME&lt;/code&gt; is used.</source>
          <target state="translated">Nombre can&amp;oacute;nico, cuando se usa &lt;code&gt;AddressInfoFlags.CANONNAME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca2d0802f87ef08825202a1ca29c54992dad17b0" translate="yes" xml:space="preserve">
          <source>Capabilities of the CPU the program is running on.</source>
          <target state="translated">Las capacidades de la CPU en la que se está ejecutando el programa.</target>
        </trans-unit>
        <trans-unit id="7e1973f266a216415dc191028046ea7f74365eb7" translate="yes" xml:space="preserve">
          <source>Capacity desired. This constructor is defined only if &lt;code&gt; ParentAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;.</source>
          <target state="translated">Capacidad deseada. Este constructor se define solo si &lt;code&gt; ParentAllocator&lt;/code&gt; no es &lt;code&gt;NullAllocator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70603ccef126aa6da95612288168a613c4bc83f0" translate="yes" xml:space="preserve">
          <source>Capitalize a the first character of a ASCII string.</source>
          <target state="translated">Capitalizar el primer carácter de una cadena ASCII.</target>
        </trans-unit>
        <trans-unit id="7bac59f23d8a421d02552a2b75009a6de4d133eb" translate="yes" xml:space="preserve">
          <source>Capitalize an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; or string, meaning convert the first character to upper case and subsequent characters to lower case.</source>
          <target state="translated">Ponga en may&amp;uacute;scula un &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;rango&lt;/a&gt; o cadena de entrada , lo que significa convertir el primer car&amp;aacute;cter a may&amp;uacute;sculas y los siguientes a min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="d87b28abafacc3e31f8a5ef814dc1a89c95adc81" translate="yes" xml:space="preserve">
          <source>Capitalize the first character of &lt;code&gt;s&lt;/code&gt; and convert the rest of &lt;code&gt;s&lt;/code&gt; to lowercase.</source>
          <target state="translated">Poner en may&amp;uacute;scula el primer car&amp;aacute;cter de &lt;code&gt;s&lt;/code&gt; y convertir el resto de &lt;code&gt;s&lt;/code&gt; en min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="63beb67c34339e7c0d71b7c05343dfc0c5c06706" translate="yes" xml:space="preserve">
          <source>Captures a range state.</source>
          <target state="translated">Captura un estado de rango.</target>
        </trans-unit>
        <trans-unit id="6e0d5cedfdd10366517f607a93eeeef9b4785a51" translate="yes" xml:space="preserve">
          <source>Carian</source>
          <target state="translated">Carian</target>
        </trans-unit>
        <trans-unit id="df10067f5a8780a3c7f1ce6b060b8d78df100b22" translate="yes" xml:space="preserve">
          <source>Carriage return</source>
          <target state="translated">Retorno del transporte...</target>
        </trans-unit>
        <trans-unit id="b94582323a02af8750c89d9914ff8a094fbada5b" translate="yes" xml:space="preserve">
          <source>Carriage return (U+000D).</source>
          <target state="translated">Retorno del transporte (U+000D).</target>
        </trans-unit>
        <trans-unit id="9254c4bba00f5ff69304a7921d3118fcbac7e6b8" translate="yes" xml:space="preserve">
          <source>Case</source>
          <target state="translated">Case</target>
        </trans-unit>
        <trans-unit id="af7c0d9ee5c8a6c4478105142a141d1bad096c35" translate="yes" xml:space="preserve">
          <source>Case expressions must all evaluate to distinct values. Const or immutable variables must all have different names. If they share a value, the first case statement with that value gets control. There must be exactly one default statement.</source>
          <target state="translated">Las expresiones de los casos deben ser evaluadas con valores distintos.Las variables constantes o inmutables deben tener todas nombres diferentes.Si comparten un valor,la primera expresión de caso con ese valor obtiene el control.Debe haber exactamente una declaración por defecto.</target>
        </trans-unit>
        <trans-unit id="be29d0c965453b901d4ad20bdc8e2ddd09f27c5c" translate="yes" xml:space="preserve">
          <source>Case insensitive matching.</source>
          <target state="translated">Coincidencia insensible a las mayúsculas y minúsculas.</target>
        </trans-unit>
        <trans-unit id="b632747e3a93dfa45ef0653a66ab6ac246268230" translate="yes" xml:space="preserve">
          <source>Case statements and default statements associated with the switch can be nested within block statements; they do not have to be in the outermost block. For example, this is allowed:</source>
          <target state="translated">Las declaraciones de caso y las declaraciones por defecto asociadas al interruptor pueden anidarse dentro de las declaraciones de bloque;no es necesario que estén en el bloque más exterior.Por ejemplo,esto está permitido:</target>
        </trans-unit>
        <trans-unit id="4830655a69813534d85f86f1ac7683b83fc06b02" translate="yes" xml:space="preserve">
          <source>Case-insensitive find of a string</source>
          <target state="translated">El hallazgo de una cuerda sin tener en cuenta las mayúsculas y minúsculas</target>
        </trans-unit>
        <trans-unit id="22a0daee669e27ee86078432c6d32a4c0da14fe0" translate="yes" xml:space="preserve">
          <source>Case-insensitive string comparison (&lt;a href=&quot;#sicmp&quot;&gt;&lt;code&gt;sicmp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#icmp&quot;&gt;&lt;code&gt;icmp&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Comparaci&amp;oacute;n de cadenas de may&amp;uacute;sculas y min&amp;uacute;sculas ( &lt;a href=&quot;#sicmp&quot;&gt; &lt;code&gt;sicmp&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#icmp&quot;&gt; &lt;code&gt;icmp&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc02e22f8ccf2c7182decb6993c9ab41402098ce" translate="yes" xml:space="preserve">
          <source>Case-sensitivity of the comparison.</source>
          <target state="translated">La sensibilidad al caso de la comparación.</target>
        </trans-unit>
        <trans-unit id="8647c28bed14fb487e34d3da55fb4ace9c3a88fa" translate="yes" xml:space="preserve">
          <source>CaseRangeStatement</source>
          <target state="translated">CaseRangeStatement</target>
        </trans-unit>
        <trans-unit id="f31bf93714d4f8de709a473ac493e8917fd94741" translate="yes" xml:space="preserve">
          <source>CaseSensitive &lt;code&gt;cs&lt;/code&gt;</source>
          <target state="translated">CaseSensitive &lt;code&gt;cs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82cbdef9815d26de04f79b63bed3258b574ec1e5" translate="yes" xml:space="preserve">
          <source>CaseStatements* &lt;strong id=&quot;cases&quot;&gt;cases&lt;/strong&gt;;</source>
          <target state="translated">CaseStatements * &lt;strong id=&quot;cases&quot;&gt;casos&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="93e81c6075ed3230ff50ed8c47578708810401aa" translate="yes" xml:space="preserve">
          <source>Case_Ignorable</source>
          <target state="translated">Case_Ignorable</target>
        </trans-unit>
        <trans-unit id="744f1d9b60891d9266196d1c3e78b1d6da592b82" translate="yes" xml:space="preserve">
          <source>Cased</source>
          <target state="translated">Cased</target>
        </trans-unit>
        <trans-unit id="f3d4dffe4c9ebac969ee4f02157e5740619b3299" translate="yes" xml:space="preserve">
          <source>Casing</source>
          <target state="translated">Casing</target>
        </trans-unit>
        <trans-unit id="fdce1732b6c6c14b93a5e9a8f896d5e70598b645" translate="yes" xml:space="preserve">
          <source>Cast Expressions</source>
          <target state="translated">Expresiones del reparto</target>
        </trans-unit>
        <trans-unit id="1be1f5579be197b60f4cbccf065fa7be7bb581e6" translate="yes" xml:space="preserve">
          <source>Cast Operator Overloading</source>
          <target state="translated">Sobrecarga del operador de reparto</target>
        </trans-unit>
        <trans-unit id="5a95ed2864a76fc66062c5a7f51b3cb5c4d55c8a" translate="yes" xml:space="preserve">
          <source>Cast Operators</source>
          <target state="translated">Operadores de reparto</target>
        </trans-unit>
        <trans-unit id="ca826936bee948f2eb775d1f8e1ae92d516c0afe" translate="yes" xml:space="preserve">
          <source>Cast is not necessary if the type of the variable is inferred. See the example below.</source>
          <target state="translated">El reparto no es necesario si se infiere el tipo de la variable.Véase el ejemplo a continuación.</target>
        </trans-unit>
        <trans-unit id="25e55b52ee2f3dc95810f24ff7dd2b0e1de46b08" translate="yes" xml:space="preserve">
          <source>CastExpression</source>
          <target state="translated">CastExpression</target>
        </trans-unit>
        <trans-unit id="f137db9c32541b4a024e2e40ec97ea3e4571d7c9" translate="yes" xml:space="preserve">
          <source>Casting a class object to an interface consists of adding the offset of the interface's corresponding vptr to the address of the base of the object. Casting an interface ptr back to the class type it came from involves getting the correct offset to subtract from it from the object.Interface entry at vtbl[0]. Adjustor thunks are created and pointers to them stored in the method entries in the vtbl[] in order to set the this pointer to the start of the object instance corresponding to the implementing method.</source>
          <target state="translated">El envío de un objeto de clase a una interfaz consiste en añadir el desplazamiento del vptr correspondiente de la interfaz a la dirección de la base del objeto.Echar un ptrtr de interfaz al tipo de clase del que procede implica obtener el offset correcto para restarle al objeto.entrada de la interfaz en vtbl[0].Se crean thunks de ajuste y punteros a ellos almacenados en las entradas del método en el vtbl[]con el fin de establecer este puntero al inicio de la instancia del objeto correspondiente al método de implementación.</target>
        </trans-unit>
        <trans-unit id="2be16817be1151d2bfd103342ffb9b83c9bc8eec" translate="yes" xml:space="preserve">
          <source>Casting a dynamic array to another dynamic array is done only if the array lengths multiplied by the element sizes match. The cast is done as a type paint, with the array length adjusted to match any change in element size. If there's not a match, a runtime error is generated.</source>
          <target state="translated">La fusión de un conjunto dinámico con otro conjunto dinámico sólo se realiza si las longitudes de los conjuntos multiplicadas por los tamaños de los elementos coinciden.El molde se hace como una pintura tipo,con la longitud del arreglo ajustada para que coincida con cualquier cambio en el tamaño del elemento.Si no hay coincidencia,se genera un error de ejecución.</target>
        </trans-unit>
        <trans-unit id="16edfc7539440dbdc02f7a14941c4d5ef8ef9a5e" translate="yes" xml:space="preserve">
          <source>Casting a floating point literal from one type to another changes its type, but internally it is retained at full precision for the purposes of constant folding.</source>
          <target state="translated">El vertido de una punta flotante literalmente de un tipo a otro cambia su tipo,pero internamente se mantiene con total precisión a efectos de un plegado constante.</target>
        </trans-unit>
        <trans-unit id="11324dd9fa7b8d9c53df605d6416fafef2a68188" translate="yes" xml:space="preserve">
          <source>Casting a floating point value to an integral type is the equivalent of converting to an integer using truncation.</source>
          <target state="translated">Echar un valor en coma flotante a un tipo de integral es el equivalente a convertirlo en un entero utilizando el truncamiento.</target>
        </trans-unit>
        <trans-unit id="f259cd40444c3107ae944acf4631f694eae6b61d" translate="yes" xml:space="preserve">
          <source>Casting a pointer type to and from a class type is done as a type paint (i.e. a reinterpret cast).</source>
          <target state="translated">El lanzamiento de un tipo de puntero hacia y desde un tipo de clase se hace como una pintura de tipo (es decir,un molde de reinterpretación).</target>
        </trans-unit>
        <trans-unit id="67471401dacb96c319b67d90467f1e1ec414ef57" translate="yes" xml:space="preserve">
          <source>Casting a value</source>
          <target state="translated">Emitiendo un valor</target>
        </trans-unit>
        <trans-unit id="c6340b2b57764ca857638ab68adda2ab272e357c" translate="yes" xml:space="preserve">
          <source>Casting an expression to &lt;code&gt;void&lt;/code&gt; type is allowed to mark that the result is unused. On &lt;a href=&quot;statement#ExpressionStatement&quot;&gt;&lt;i&gt;ExpressionStatement&lt;/i&gt;&lt;/a&gt;, it could be used properly to avoid &quot;has no effect&quot; error.</source>
          <target state="translated">La conversi&amp;oacute;n de una expresi&amp;oacute;n a tipo &lt;code&gt;void&lt;/code&gt; puede marcar que el resultado no se utiliza. En &lt;a href=&quot;statement#ExpressionStatement&quot;&gt;&lt;i&gt;ExpressionStatement&lt;/i&gt;&lt;/a&gt; , podr&amp;iacute;a usarse correctamente para evitar el error &quot;no tiene efecto&quot;.</target>
        </trans-unit>
        <trans-unit id="01335a9c442d0255ed0b8bd54d5bf5a26e8b8dab" translate="yes" xml:space="preserve">
          <source>Casting operator to integral, &lt;code&gt;bool&lt;/code&gt;, or floating point type. If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpCast&lt;/code&gt;, the call immediately returns &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt;. Otherwise, casting to &lt;code&gt;bool&lt;/code&gt; yields &lt;code&gt; get != 0&lt;/code&gt; and casting to another integral that can represent all values of &lt;code&gt;T&lt;/code&gt; returns &lt;code&gt;get&lt;/code&gt; promoted to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Operador de fundici&amp;oacute;n a tipo integral, &lt;code&gt;bool&lt;/code&gt; o de coma flotante. Si &lt;code&gt;Hook&lt;/code&gt; define &lt;code&gt;hookOpCast&lt;/code&gt; , la llamada devuelve inmediatamente &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; . De lo contrario, la fundici&amp;oacute;n a &lt;code&gt;bool&lt;/code&gt; rendimientos &lt;code&gt; get != 0&lt;/code&gt; y emitan a otro integrante que puede representar todos los valores de &lt;code&gt;T&lt;/code&gt; vuelve &lt;code&gt;get&lt;/code&gt; promovidos a &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="563db6d9dd42954287b5cda42119295bd4e28aa4" translate="yes" xml:space="preserve">
          <source>Casting pointers to non-pointers and vice versa is allowed.</source>
          <target state="translated">Se permite lanzar punteros a los no punteros y viceversa.</target>
        </trans-unit>
        <trans-unit id="e8c8325b9ae374bf1edc7d50c4d5a016a9981e5a" translate="yes" xml:space="preserve">
          <source>Casting to a &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; replaces the qualifiers to the type of the &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">La &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;conversi&amp;oacute;n&lt;/i&gt;&lt;/a&gt; a &lt;i&gt;CastQual&lt;/i&gt; reemplaza los calificadores al tipo de &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d98bf7b9cde5141dc8af74c8c9759ef593ae47b" translate="yes" xml:space="preserve">
          <source>Casting to/from &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; may break type system guarantees. Use with care.</source>
          <target state="translated">Lanzar hacia / desde &lt;code&gt;const&lt;/code&gt; ante o &lt;code&gt;immutable&lt;/code&gt; puede romper las garant&amp;iacute;as del sistema de tipos. Usar con cuidado.</target>
        </trans-unit>
        <trans-unit id="b02f79fb40c6ba2556a5ea0081aed386869f0012" translate="yes" xml:space="preserve">
          <source>Casting with no &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/a&gt; or &lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;CastQual&lt;/i&gt;&lt;/a&gt; removes any top level &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;immutable&lt;/code&gt;, &lt;code&gt;shared&lt;/code&gt; or &lt;code&gt;inout&lt;/code&gt; type modifiers from the type of the &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#CastQual&quot;&gt;&lt;i&gt;Transmitir&lt;/i&gt;&lt;/a&gt; sin &lt;a href=&quot;#Type&quot;&gt;&lt;i&gt;tipo&lt;/i&gt;&lt;/a&gt; o &lt;i&gt;CastQual&lt;/i&gt; elimina los modificadores de tipo &lt;code&gt;const&lt;/code&gt; antes , &lt;code&gt;immutable&lt;/code&gt; , &lt;code&gt;shared&lt;/code&gt; o &lt;code&gt;inout&lt;/code&gt; de nivel superior del tipo de &lt;a href=&quot;#UnaryExpression&quot;&gt;&lt;i&gt;UnaryExpression&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5591322bc1301d82b541b6b5ad169c351dc74a45" translate="yes" xml:space="preserve">
          <source>Casts a mutable array to an immutable array in an idiomatic manner. Technically, &lt;code&gt;assumeUnique&lt;/code&gt; just inserts a cast, but its name documents assumptions on the part of the caller. &lt;code&gt;assumeUnique(arr)&lt;/code&gt; should only be called when there are no more active mutable aliases to elements of &lt;code&gt; arr&lt;/code&gt;. To strengthen this assumption, &lt;code&gt;assumeUnique(arr)&lt;/code&gt; also clears &lt;code&gt;arr&lt;/code&gt; before returning. Essentially &lt;code&gt; assumeUnique(arr)&lt;/code&gt; indicates commitment from the caller that there is no more mutable access to any of &lt;code&gt;arr&lt;/code&gt;'s elements (transitively), and that all future accesses will be done through the immutable array returned by &lt;code&gt;assumeUnique&lt;/code&gt;.</source>
          <target state="translated">Convierte una matriz mutable en una matriz inmutable de manera idiom&amp;aacute;tica. T&amp;eacute;cnicamente, &lt;code&gt;assumeUnique&lt;/code&gt; solo inserta un reparto, pero su nombre documenta suposiciones por parte de la persona que llama. &lt;code&gt;assumeUnique(arr)&lt;/code&gt; solo debe llamarse cuando no hay m&amp;aacute;s alias mutables activos para elementos de &lt;code&gt; arr&lt;/code&gt; . Para fortalecer esta suposici&amp;oacute;n, &lt;code&gt;assumeUnique(arr)&lt;/code&gt; tambi&amp;eacute;n borra &lt;code&gt;arr&lt;/code&gt; antes de regresar. Esencialmente, &lt;code&gt; assumeUnique(arr)&lt;/code&gt; indica el compromiso del llamador de que no hay m&amp;aacute;s acceso mutable a ninguno de los elementos de &lt;code&gt;arr&lt;/code&gt; (transitivamente), y que todos los accesos futuros se realizar&amp;aacute;n a trav&amp;eacute;s de la matriz inmutable devuelta por &lt;code&gt;assumeUnique&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96fd17cf1de8b408679f9b1db49477fb8f0c66b6" translate="yes" xml:space="preserve">
          <source>Casts that break the type system.</source>
          <target state="translated">Lanzamientos que rompen el sistema de tipos.</target>
        </trans-unit>
        <trans-unit id="bc260f3af1fc6e8bf46c5b8f8a854fbc6153096b" translate="yes" xml:space="preserve">
          <source>Cat Expressions</source>
          <target state="translated">Expresiones del gato</target>
        </trans-unit>
        <trans-unit id="a953a29fa47d85867e2fab2716c48cee491dd470" translate="yes" xml:space="preserve">
          <source>CatExpression</source>
          <target state="translated">CatExpression</target>
        </trans-unit>
        <trans-unit id="a7c51e67b60b0927212f25eb1aaefb172b8a7153" translate="yes" xml:space="preserve">
          <source>Catch</source>
          <target state="translated">Catch</target>
        </trans-unit>
        <trans-unit id="d3ce6d6c33d89c5cd835012c244acc4d8b858a0e" translate="yes" xml:space="preserve">
          <source>CatchParameter</source>
          <target state="translated">CatchParameter</target>
        </trans-unit>
        <trans-unit id="5e59a1d3b6be9c8f0e29f469cc4ebfb54cc7e205" translate="yes" xml:space="preserve">
          <source>Catches</source>
          <target state="translated">Catches</target>
        </trans-unit>
        <trans-unit id="f1645524550ec6b1dbf604c910de525c1199c393" translate="yes" xml:space="preserve">
          <source>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned and &lt;code&gt;result&lt;/code&gt; is set to the result of the expression.</source>
          <target state="translated">Captura y devuelve la excepci&amp;oacute;n lanzada desde la expresi&amp;oacute;n dada. Si no se produce ninguna excepci&amp;oacute;n, se devuelve un valor nulo y el &lt;code&gt;result&lt;/code&gt; ado se establece como el resultado de la expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="040c55a2a9c3c731e36a7abc0e21f539bc1f80a5" translate="yes" xml:space="preserve">
          <source>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned. &lt;code&gt;E&lt;/code&gt; can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Captura y devuelve la excepci&amp;oacute;n lanzada desde la expresi&amp;oacute;n dada. Si no se produce ninguna excepci&amp;oacute;n, se devuelve nulo. &lt;code&gt;E&lt;/code&gt; puede ser &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d90ffac3b749155c40310e22300174e6246501c0" translate="yes" xml:space="preserve">
          <source>Catches the exception thrown from the given expression and returns the msg property of that exception. If no exception is thrown, then null is returned. &lt;code&gt;E&lt;/code&gt; can be &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Captura la excepci&amp;oacute;n lanzada desde la expresi&amp;oacute;n dada y devuelve la propiedad msg de esa excepci&amp;oacute;n. Si no se produce ninguna excepci&amp;oacute;n, se devuelve nulo. &lt;code&gt;E&lt;/code&gt; puede ser &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73a0dfe4cefda0d8bb54b75566ce6c7751cb0769" translate="yes" xml:space="preserve">
          <source>Catching C++ Class Objects</source>
          <target state="translated">Captura de objetos de clase C++</target>
        </trans-unit>
        <trans-unit id="df7467bf765f309d90be05cf8631fc4bacfe7590" translate="yes" xml:space="preserve">
          <source>Categories of types</source>
          <target state="translated">Categorías de tipos</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="729cda91611ce285ba0ef14cc4efdd486065b7fa" translate="yes" xml:space="preserve">
          <source>Causes the assembler to emit NOP instructions to align the next assembler instruction on an</source>
          <target state="translated">Hace que el ensamblador emita instrucciones NOP para alinear la siguiente instrucción de ensamblador en un</target>
        </trans-unit>
        <trans-unit id="147c8bbdbf1f140f88bd53dffd29cf82c9997a05" translate="yes" xml:space="preserve">
          <source>Causes the assembler to emit NOP instructions to align the next assembler instruction on an even boundary.</source>
          <target state="translated">Hace que el ensamblador emita instrucciones NOP para alinear la siguiente instrucción de ensamblador en un límite uniforme.</target>
        </trans-unit>
        <trans-unit id="70c5dda624176ab62b854d62901ed2b2ed8a9f72" translate="yes" xml:space="preserve">
          <source>Causes the compiler to not generate the function prolog and epilog sequences. This means such is the responsibility of inline assembly programmer, and is normally used when the entire function is to be written in assembler.</source>
          <target state="translated">Hace que el compilador no genere las secuencias de prólogo y epílogo de la función.Esto significa que tal es la responsabilidad del programador en ensamblador en línea,y se usa normalmente cuando toda la función debe ser escrita en ensamblador.</target>
        </trans-unit>
        <trans-unit id="1fd6a880ee16bb33003559b204f8a2cff5a9e90c" translate="yes" xml:space="preserve">
          <source>Cc</source>
          <target state="translated">Cc</target>
        </trans-unit>
        <trans-unit id="51f00921e108b6ca8be5e3997778036a6ec831aa" translate="yes" xml:space="preserve">
          <source>Cells in the delimiter row contain hyphens (&lt;code&gt;-&lt;/code&gt;) and optional colons (&lt;code&gt;:&lt;/code&gt;). A &lt;code&gt;:&lt;/code&gt; to the left of the hyphens creates a left-aligned column, a &lt;code&gt;:&lt;/code&gt; to the right of the hyphens creates a right-aligned column (like the example above), and &lt;code&gt;:&lt;/code&gt;'s on both sides of the hyphens create a center-aligned column.</source>
          <target state="translated">Las c&amp;eacute;lulas en la fila delimitador contienen guiones ( &lt;code&gt;-&lt;/code&gt; ) y los dos puntos opcionales ( &lt;code&gt;:&lt;/code&gt; ). A &lt;code&gt;:&lt;/code&gt; a la izquierda de los guiones crea una columna alineada a la izquierda, a &lt;code&gt;:&lt;/code&gt; a la derecha de los guiones crea una columna alineada a la derecha (como en el ejemplo anterior), y &lt;code&gt;:&lt;/code&gt; a ambos lados de los guiones crea un centro columna alineada</target>
        </trans-unit>
        <trans-unit id="20b2af77551ab62ecafee8361a6775168a8911be" translate="yes" xml:space="preserve">
          <source>Centaur Isiah = VIA Nano (family 6, model F) is an out-of-order core.</source>
          <target state="translated">Centauro Isiah=VIA Nano (familia 6,modelo F)es un núcleo fuera de servicio.</target>
        </trans-unit>
        <trans-unit id="8408f82534bfffd0ab07188fc9d719f71130e4e0" translate="yes" xml:space="preserve">
          <source>Center &lt;code&gt;s&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;s&lt;/code&gt; doesn't fill.</source>
          <target state="translated">Centrar &lt;code&gt;s&lt;/code&gt; en un &lt;code&gt;width&lt;/code&gt; campo de caracteres de ancho. &lt;code&gt;fillChar&lt;/code&gt; es el personaje que se usar&amp;aacute; para llenar el espacio en el campo que &lt;code&gt;s&lt;/code&gt; no llena.</target>
        </trans-unit>
        <trans-unit id="4e74b6056afd83cbdf235c0e1e1aa022d7643f34" translate="yes" xml:space="preserve">
          <source>Center justify &lt;code&gt;r&lt;/code&gt; in a field &lt;code&gt;width&lt;/code&gt; characters wide. &lt;code&gt;fillChar&lt;/code&gt; is the character that will be used to fill up the space in the field that &lt;code&gt;r&lt;/code&gt; doesn't fill.</source>
          <target state="translated">El centro justifica &lt;code&gt;r&lt;/code&gt; en un &lt;code&gt;width&lt;/code&gt; campo con caracteres anchos. &lt;code&gt;fillChar&lt;/code&gt; es el personaje que se usar&amp;aacute; para llenar el espacio en el campo que &lt;code&gt;r&lt;/code&gt; no llena.</target>
        </trans-unit>
        <trans-unit id="fb14d77020e4dbef1a189a81fe3dbc04509cb2d1" translate="yes" xml:space="preserve">
          <source>Certain alphabets like German and Greek have no 1:1 upper-lower mapping. Use overload of toUpper which takes full string instead.</source>
          <target state="translated">Ciertos alfabetos como el alemán y el griego no tienen una relación de 1:1 entre los mapas superiores e inferiores.Usar la sobrecarga de toUpper que toma la cadena completa en su lugar.</target>
        </trans-unit>
        <trans-unit id="64a2e3e9bc5b4cd297d23de932339bb6c474455f" translate="yes" xml:space="preserve">
          <source>Cf</source>
          <target state="translated">Cf</target>
        </trans-unit>
        <trans-unit id="70b3ae21ee59942a0d41812e09cc5d908774f36f" translate="yes" xml:space="preserve">
          <source>Chain multiple calls to ifThrown, each capturing errors from the entire preceding expression.</source>
          <target state="translated">Encadena múltiples llamadas a ifThrown,cada una capturando errores de toda la expresión precedente.</target>
        </trans-unit>
        <trans-unit id="6a803e5d1d5407c176b6adb93c4ec23f4ef3c32f" translate="yes" xml:space="preserve">
          <source>Chakma</source>
          <target state="translated">Chakma</target>
        </trans-unit>
        <trans-unit id="5e052ac9c7fd6c9d46817ea48b907dbb7047ae81" translate="yes" xml:space="preserve">
          <source>Cham</source>
          <target state="translated">Cham</target>
        </trans-unit>
        <trans-unit id="c94dac697486986e71af2c37242755c0937be074" translate="yes" xml:space="preserve">
          <source>Change directory to &lt;code&gt;pathname&lt;/code&gt;. Equivalent to &lt;code&gt;cd&lt;/code&gt; on Windows and POSIX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458b3d4cc82936041a171ad6f7ca77493ddeb2bd" translate="yes" xml:space="preserve">
          <source>Change directory to &lt;code&gt;pathname&lt;/code&gt;. Equivalent to &lt;code&gt;cd&lt;/code&gt; on Windows and Posix.</source>
          <target state="translated">Cambie el directorio a &lt;code&gt;pathname&lt;/code&gt; de ruta . Equivalente a &lt;code&gt;cd&lt;/code&gt; en Windows y Posix.</target>
        </trans-unit>
        <trans-unit id="6f314cb3c24c1c8ee48dc8abfd534cc520363d6c" translate="yes" xml:space="preserve">
          <source>Change match (fnmatch-like) callback for wildcard matching</source>
          <target state="translated">Cambiar la llamada de coincidencia (fnmatch-like)por la coincidencia de comodín</target>
        </trans-unit>
        <trans-unit id="e8304f2bae085deed1b3c8125f9fa43407a675db" translate="yes" xml:space="preserve">
          <source>Change the IEEE754 floating-point rounding mode and the floating-point hardware exceptions.</source>
          <target state="translated">Cambie el modo de redondeo de punto flotante del IEEE754 y las excepciones de hardware de punto flotante.</target>
        </trans-unit>
        <trans-unit id="9f333c0a78429177429051909d1f599b48a73b54" translate="yes" xml:space="preserve">
          <source>Change the floating-point hardware rounding mode</source>
          <target state="translated">Cambiar el modo de redondeo del hardware de punto flotante</target>
        </trans-unit>
        <trans-unit id="3d9d32d43390d1a2629123edfc32deb49f461b6a" translate="yes" xml:space="preserve">
          <source>Change the key on an open database. If the current database is not encrypted, this routine will encrypt it. If pNew == 0 or nNew == 0, the database is decrypted.</source>
          <target state="translated">Cambiar la clave en una base de datos abierta.Si la base de datos actual no está encriptada,esta rutina la encriptará.Si pNew ==0 o nNew ==0,la base de datos se desencripta.</target>
        </trans-unit>
        <trans-unit id="5ba310a0f8acd1b8bbbdaa00b70d0bff2f5990f6" translate="yes" xml:space="preserve">
          <source>Change this function so the caller doesn't have to be aware of this issue. Either return by value and expect the caller to always check the base ptr as an indication of whether the struct is valid, or set the BlkInfo as a side-effect and return a bool to indicate success.</source>
          <target state="translated">Cambie esta función para que la persona que llama no tenga que estar al tanto de este asunto.O bien devuelve por valor y espera que el llamante siempre compruebe el ptr de la base como una indicación de si la estructura es válida,o establece la BlkInfo como un efecto secundario y devuelve un bool para indicar el éxito.</target>
        </trans-unit>
        <trans-unit id="e7d3b1db7f0a311580f3e633ae63903d1a427f37" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; arguments are not propagated to the call site, only to &lt;code&gt;args&lt;/code&gt; in this struct.</source>
          <target state="translated">Los cambios en &lt;code&gt;out&lt;/code&gt; argumentos de &lt;code&gt;ref&lt;/code&gt; y out no se propagan al sitio de la llamada, solo a los &lt;code&gt;args&lt;/code&gt; en esta estructura.</target>
        </trans-unit>
        <trans-unit id="8c06a1392ead6cea3258d7b832ab861bbcb2d0e3" translate="yes" xml:space="preserve">
          <source>Changing the rounding mode in the middle of a function can interfere with optimizations of floating point expressions, as the optimizer assumes that the rounding mode does not change. It is best to change the rounding mode only at the beginning of the function, and keep it until the function returns. It is also best to add the line:</source>
          <target state="translated">Cambiar el modo de redondeo en medio de una función puede interferir con la optimización de las expresiones en coma flotante,ya que el optimizador asume que el modo de redondeo no cambia.Lo mejor es cambiar el modo de redondeo sólo al principio de la función,y mantenerlo hasta que la función vuelva.También es mejor añadir la línea:</target>
        </trans-unit>
        <trans-unit id="0f9ba953e35135a3f8ec268817cc92f2557202a9" translate="yes" xml:space="preserve">
          <source>Char</source>
          <target state="translated">Char</target>
        </trans-unit>
        <trans-unit id="c6b74142b3b389f15ac5cd805f70960cc3a1abf0" translate="yes" xml:space="preserve">
          <source>Char[] &lt;code&gt;fmt&lt;/code&gt;</source>
          <target state="translated">Char [] &lt;code&gt;fmt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d66a912fb521a267fef61e2619d881aa8e9c5935" translate="yes" xml:space="preserve">
          <source>Char[] &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">Char [] &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="516088a32b97fe8b60ae41af7a9da5ea8c8b89b1" translate="yes" xml:space="preserve">
          <source>Character Entities</source>
          <target state="translated">Entidades de carácter</target>
        </trans-unit>
        <trans-unit id="669b19e596ff87d2ed122a5266e7aff0c3d614e2" translate="yes" xml:space="preserve">
          <source>Character Literals</source>
          <target state="translated">Literatura de personajes</target>
        </trans-unit>
        <trans-unit id="2760308a0f6d1684065a6510212e96dc91848ae1" translate="yes" xml:space="preserve">
          <source>Character Set</source>
          <target state="translated">Conjunto de personajes</target>
        </trans-unit>
        <trans-unit id="bf238be65bb5e7ebb05fdca2c63f71cc0a076a1a" translate="yes" xml:space="preserve">
          <source>Character classes</source>
          <target state="translated">Las clases de carácter</target>
        </trans-unit>
        <trans-unit id="ad3c933b2dd70972eec55e516f2ae9ffae669d0e" translate="yes" xml:space="preserve">
          <source>Character classification by category and common properties: &lt;a href=&quot;#isAlpha&quot;&gt;&lt;code&gt;isAlpha&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#isWhite&quot;&gt;&lt;code&gt;isWhite&lt;/code&gt;&lt;/a&gt; and others.</source>
          <target state="translated">Clasificaci&amp;oacute;n de caracteres por categor&amp;iacute;a y propiedades comunes: &lt;a href=&quot;#isAlpha&quot;&gt; &lt;code&gt;isAlpha&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#isWhite&quot;&gt; &lt;code&gt;isWhite&lt;/code&gt; &lt;/a&gt; y otros.</target>
        </trans-unit>
        <trans-unit id="1ef00f56499c816e60a9c87369bcd2210570f41d" translate="yes" xml:space="preserve">
          <source>Character input ranges</source>
          <target state="translated">Rangos de entrada de caracteres</target>
        </trans-unit>
        <trans-unit id="133c67a5c003572ca8daaddcc62800905a7a14d7" translate="yes" xml:space="preserve">
          <source>Character literals are a single character or escape sequence enclosed by single quotes.</source>
          <target state="translated">Los literales de los caracteres son un solo carácter o secuencia de escape encerrado por citas sencillas.</target>
        </trans-unit>
        <trans-unit id="aa8ec24f3290e6543c77a63504c45b69a0237e5a" translate="yes" xml:space="preserve">
          <source>Character literals are single characters and resolve to one of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;. If the literal is a &lt;code&gt;\u&lt;/code&gt; escape sequence, it resolves to type &lt;code&gt;wchar&lt;/code&gt;. If the literal is a &lt;code&gt;\U&lt;/code&gt; escape sequence, it resolves to type &lt;code&gt;dchar&lt;/code&gt;. Otherwise, it resolves to the type with the smallest size it will fit into.</source>
          <target state="translated">Los literales de caracteres son caracteres individuales y se resuelven en uno de tipo &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar&lt;/code&gt; o &lt;code&gt;dchar&lt;/code&gt; . Si el literal es un &lt;code&gt;\u&lt;/code&gt; secuencia de escape, se resuelve para escribir &lt;code&gt;wchar&lt;/code&gt; . Si el literal es una secuencia de escape &lt;code&gt;\U&lt;/code&gt; , se resuelve escribir &lt;code&gt;dchar&lt;/code&gt; . De lo contrario, se resuelve en el tipo con el tama&amp;ntilde;o m&amp;aacute;s peque&amp;ntilde;o que se ajuste.</target>
        </trans-unit>
        <trans-unit id="3748669139d2553c2dce70085bc8d87e3b65bf04" translate="yes" xml:space="preserve">
          <source>Character to insert between digits.</source>
          <target state="translated">Carácter a insertar entre los dígitos.</target>
        </trans-unit>
        <trans-unit id="b03707df5e411692fe21adde8672bde4c3d712ec" translate="yes" xml:space="preserve">
          <source>Character traits classes specify character properties and provide specific semantics for certain operations on characters and sequences of characters.</source>
          <target state="translated">Las clases de rasgos de carácter especifican las propiedades de los caracteres y proporcionan una semántica específica para ciertas operaciones en los caracteres y secuencias de caracteres.</target>
        </trans-unit>
        <trans-unit id="7d08e774321e793244bcf20b89151a8c5636ee9d" translate="yes" xml:space="preserve">
          <source>Character type for each line, defaulting to &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Tipo de caracteres para cada l&amp;iacute;nea, por defecto en &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ea2c19a4eb8af5f3f4d555aac37a5f0f405718" translate="yes" xml:space="preserve">
          <source>Character type for each line, defaulting to &lt;code&gt;immutable char&lt;/code&gt;.</source>
          <target state="translated">Tipo de caracteres para cada l&amp;iacute;nea, por defecto en caracteres &lt;code&gt;immutable char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fe23e4b9b84f174b905f70c10737ea338eb6786" translate="yes" xml:space="preserve">
          <source>Characters and Entities</source>
          <target state="translated">Personajes y entidades</target>
        </trans-unit>
        <trans-unit id="407259c6fa72a57c5df67c0a931d6eaafa218825" translate="yes" xml:space="preserve">
          <source>Characters and Escape Macros</source>
          <target state="translated">Personajes y macros de escape</target>
        </trans-unit>
        <trans-unit id="e688823a84fa6f43670fb82f99c26f690e6bccb5" translate="yes" xml:space="preserve">
          <source>Cheat Sheet</source>
          <target state="translated">Hoja de Trampas</target>
        </trans-unit>
        <trans-unit id="98fea9560fa564556454626729a76607af1a8cca" translate="yes" xml:space="preserve">
          <source>Check access to d for expression e.d Returns true if the declaration is not accessible.</source>
          <target state="translated">Compruebe el acceso a d para la expresión e.d Devuelve verdadero si la declaración no es accesible.</target>
        </trans-unit>
        <trans-unit id="992d8a3514d4f8fb1a7565ecd89e7c7459b088b7" translate="yes" xml:space="preserve">
          <source>Check access to package/module &lt;code&gt;p&lt;/code&gt; from scope &lt;code&gt;sc&lt;/code&gt;.</source>
          <target state="translated">Verifique el acceso al paquete / m&amp;oacute;dulo &lt;code&gt;p&lt;/code&gt; desde el alcance &lt;code&gt;sc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eda17044e9450b32ce8d657d8c476e2e931877a8" translate="yes" xml:space="preserve">
          <source>Check an entire XML document for well-formedness</source>
          <target state="translated">Revisar un documento XML completo para ver si está bien formado</target>
        </trans-unit>
        <trans-unit id="d970e5fd0eca0560f8d7376c859148711be4729a" translate="yes" xml:space="preserve">
          <source>Check for special enum names.</source>
          <target state="translated">Busca nombres de lista especiales.</target>
        </trans-unit>
        <trans-unit id="2d3f64068fd53c1e2cf2c76775f8f8fabfefbbfd" translate="yes" xml:space="preserve">
          <source>Check for unsafe access in @safe code: 1. read overlapped pointers 2. write misaligned pointers 3. write overlapped storage classes Print error if unsafe.</source>
          <target state="translated">Comprueba si hay un acceso inseguro en el código @seguro:1.leer los punteros superpuestos 2.escribir los punteros desalineados 3.escribir las clases de almacenamiento superpuestas Error de impresión si no es seguro.</target>
        </trans-unit>
        <trans-unit id="7c0bee715813745db32b38bbccf3a069246cf610" translate="yes" xml:space="preserve">
          <source>Check given aggregate actually has an identity opAssign or not.</source>
          <target state="translated">El cheque dado agregado tiene realmente una identidad opAssign o no.</target>
        </trans-unit>
        <trans-unit id="3858f175449bae14406b7154904a8462b908a3ad" translate="yes" xml:space="preserve">
          <source>Check if &lt;code&gt;this&lt;/code&gt; is in the null state.</source>
          <target state="translated">Compruebe si &lt;code&gt;this&lt;/code&gt; est&amp;aacute; en el estado nulo.</target>
        </trans-unit>
        <trans-unit id="076573205d4206fc69ab2dc4fcc4e09a0f119e4b" translate="yes" xml:space="preserve">
          <source>Check if a symbol is visible from a given scope without taking into account the most visible overload.</source>
          <target state="translated">Comprueba si un símbolo es visible desde un ámbito determinado sin tener en cuenta la sobrecarga más visible.</target>
        </trans-unit>
        <trans-unit id="62479c6f09569fa4521b5d1a5251de698f6fa595" translate="yes" xml:space="preserve">
          <source>Check if an &lt;code&gt;alias this&lt;/code&gt; is deprecated</source>
          <target state="translated">Comprueba si un &lt;code&gt;alias this&lt;/code&gt; est&amp;aacute; en desuso</target>
        </trans-unit>
        <trans-unit id="2bab44045df4b9981599697a77f678e9b3ebdf8e" translate="yes" xml:space="preserve">
          <source>Check if any elements exist in the container. Returns &lt;code&gt;false&lt;/code&gt; if at least one element exists.</source>
          <target state="translated">Compruebe si existen elementos en el contenedor. Devuelve &lt;code&gt;false&lt;/code&gt; si existe al menos un elemento.</target>
        </trans-unit>
        <trans-unit id="0eee93ccff6c0e0b4aa6087370d984e43f3308e9" translate="yes" xml:space="preserve">
          <source>Check if the file the &lt;code&gt;path&lt;/code&gt; points to exists</source>
          <target state="translated">Compruebe si el archivo al &lt;code&gt;path&lt;/code&gt; apunta la ruta existe</target>
        </trans-unit>
        <trans-unit id="7ac10cbe580bb712b906c15722c15b6e0026c3e6" translate="yes" xml:space="preserve">
          <source>Check if the function &lt;code&gt;F&lt;/code&gt; is calleable in a &lt;code&gt;nothrow&lt;/code&gt; scope.</source>
          <target state="translated">Verifique si la funci&amp;oacute;n &lt;code&gt;F&lt;/code&gt; se puede llamar en un alcance &lt;code&gt;nothrow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64f568a0788eaf3c104e4f61c0874d4d74f59f4e" translate="yes" xml:space="preserve">
          <source>Check if the last template parameter is a tuple one, and returns it if so, else returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Compruebe si el &amp;uacute;ltimo par&amp;aacute;metro de plantilla es de tupla y lo devuelve si es as&amp;iacute;, de lo contrario, devuelve &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="188659108f60184522d74ac9e6ab3f12baec9896" translate="yes" xml:space="preserve">
          <source>Check if the type &lt;code&gt;T&lt;/code&gt;'s postblit is called in nothrow, if it exist</source>
          <target state="translated">Compruebe si el postblit de tipo &lt;code&gt;T&lt;/code&gt; se llama en nothrow, si existe</target>
        </trans-unit>
        <trans-unit id="af7a4c6a5c2ba8859b2cd5a292e2e803c480f264" translate="yes" xml:space="preserve">
          <source>Check parameters and return type of D main() function. Issue error messages.</source>
          <target state="translated">Compruebe los parámetros y devuelva el tipo de función D main().Emitir mensajes de error.</target>
        </trans-unit>
        <trans-unit id="44068e2d631fa41db726b0ad86a2506b1696fdd4" translate="yes" xml:space="preserve">
          <source>Check struct constructor of the form &lt;code&gt;s.this(args)&lt;/code&gt;, by checking each &lt;code&gt;return&lt;/code&gt; parameter to see if it gets assigned to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Verifique el constructor de estructura de la forma &lt;code&gt;s.this(args)&lt;/code&gt; , verificando cada par&amp;aacute;metro de &lt;code&gt;return&lt;/code&gt; para ver si se asigna a &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9ca07e85195a45175df8f93c70295e0d597f076" translate="yes" xml:space="preserve">
          <source>Check that an email address conforms to RFCs 5321, 5322 and others.</source>
          <target state="translated">Compruebe que una dirección de correo electrónico se ajusta a las RFC 5321,5322 y otras.</target>
        </trans-unit>
        <trans-unit id="96a4caea4b58f9a696a9fa2d9139cbc448939376" translate="yes" xml:space="preserve">
          <source>Check that the expression has a valid type. If not, generates an error &quot;... has no type&quot;.</source>
          <target state="translated">Comprueba que la expresión tiene un tipo válido.Si no,genera un error &quot;...no tiene tipo&quot;.</target>
        </trans-unit>
        <trans-unit id="72c3f1230ce767eb6fa0da10917246e5895c0d26" translate="yes" xml:space="preserve">
          <source>Check that the expression has a valid value. If not, generates an error &quot;... has no value&quot;.</source>
          <target state="translated">Comprueba que la expresión tiene un valor válido.Si no,genera un error &quot;...no tiene valor&quot;.</target>
        </trans-unit>
        <trans-unit id="dcdeb8730ffac94e46f7144e685915d89bb60d12" translate="yes" xml:space="preserve">
          <source>Check that the function contains any closure. If it's @nogc, report suitable errors. This is mostly consistent with FuncDeclaration::needsClosure().</source>
          <target state="translated">Compruebe que la función contiene algún cierre.Si es @nogc,informe de los errores adecuados.Esto es mayormente consistente con FuncDeclaration::needsClosure().</target>
        </trans-unit>
        <trans-unit id="a439ace69e6b39c914e8a0f30a7839c881b0b42e" translate="yes" xml:space="preserve">
          <source>Check that the postblit is callable if t is an array of structs. Returns true if error happens.</source>
          <target state="translated">Comprueba que el postblit es llamable si es un conjunto de estructuras.Devuelve verdadero si ocurre un error.</target>
        </trans-unit>
        <trans-unit id="a636a07f4f3d9c05ce29614c151925a9aeb57b2d" translate="yes" xml:space="preserve">
          <source>Check that there are no uses of arrays without [].</source>
          <target state="translated">Compruebe que no hay usos de los arreglos sin [].</target>
        </trans-unit>
        <trans-unit id="0af7c63ae853953456799e62f8dd988319b13c2e" translate="yes" xml:space="preserve">
          <source>Check that this function type is properly resolved. If not, report &quot;forward reference error&quot; and return true.</source>
          <target state="translated">Compruebe que este tipo de función se resuelve correctamente.Si no es así,informe de &quot;error de referencia de avance&quot; y devuelva &quot;verdadero&quot;.</target>
        </trans-unit>
        <trans-unit id="dc26a5cb1e94e18dd7bae9c48ba4424f2687029b" translate="yes" xml:space="preserve">
          <source>Check to see if constraint is satisfied.</source>
          <target state="translated">Comprueba si se satisface la restricción.</target>
        </trans-unit>
        <trans-unit id="2e9e70f18c437515a642e7710d6acf41c2b8a612" translate="yes" xml:space="preserve">
          <source>Check to see if declaration can be modified in this context (sc). Issue error if not.</source>
          <target state="translated">Compruebe si la declaración puede modificarse en este contexto (sc).Si no es así,dé un error.</target>
        </trans-unit>
        <trans-unit id="51115eb7becb93e1ed9565c740be9cbe2b13d39d" translate="yes" xml:space="preserve">
          <source>Check to see if this variable is actually in an enclosing function rather than the current one. Returns true if error occurs.</source>
          <target state="translated">Comprueba si esta variable está realmente en una función de encierro en lugar de la actual.Devuelve verdadero si se produce un error.</target>
        </trans-unit>
        <trans-unit id="c9e9e80b6fb0bcd2c2078fcf4d43cd2c78a6fad0" translate="yes" xml:space="preserve">
          <source>Check to see the aggregate type is nested and its context pointer is accessible from the current scope. Returns true if error occurs.</source>
          <target state="translated">Compruebe que el tipo de agregado está anidado y que su puntero de contexto es accesible desde el ámbito actual.Devuelve verdadero si se produce un error.</target>
        </trans-unit>
        <trans-unit id="4f9c3759a0e90a57282f3d4825c0a253d6bfa729" translate="yes" xml:space="preserve">
          <source>Check type to see if it is based on a deprecated symbol.</source>
          <target state="translated">Revise el tipo de letra para ver si se basa en un símbolo obsoleto.</target>
        </trans-unit>
        <trans-unit id="3bebff7bd9c6f992a862c3947845278a778590d5" translate="yes" xml:space="preserve">
          <source>Check whether a number is an integer power of two.</source>
          <target state="translated">Comprueba si un número es una potencia entera de dos.</target>
        </trans-unit>
        <trans-unit id="68ee613e321cfb260a31b167d7e8362d6611b9ba" translate="yes" xml:space="preserve">
          <source>Check whether a thread was created by &lt;code&gt;createLowLevelThread&lt;/code&gt;.</source>
          <target state="translated">Compruebe si un hilo fue creado por &lt;code&gt;createLowLevelThread&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81773160380ee69dcc483492366b6c611e0a1eed" translate="yes" xml:space="preserve">
          <source>Check whether symbols &lt;code&gt;s&lt;/code&gt; is visible in &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">Compruebe si los s&amp;iacute;mbolos &lt;code&gt;s&lt;/code&gt; son visibles en el &lt;code&gt;mod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16a4ea9c15d653616cd1ab89eeb1d07e1733ed47" translate="yes" xml:space="preserve">
          <source>Check whether the expression allows RMW operations, error with rmw operator diagnostic if not. ex is the RHS expression, or NULL if ++/-- is used (for diagnostics) Returns true if error occurs.</source>
          <target state="translated">Comprueba si la expresión permite operaciones RMW,error con el diagnóstico del operador rmw si no.ex es la expresión RHS,o NULL si se usa ++/--(para el diagnóstico)Devuelve verdadero si se produce el error.</target>
        </trans-unit>
        <trans-unit id="c3f04bc3752d2690dd0208e77754d66e24067224" translate="yes" xml:space="preserve">
          <source>Check whether the given Unicode code point is valid.</source>
          <target state="translated">Comprueba si el punto de código Unicode dado es válido.</target>
        </trans-unit>
        <trans-unit id="967bb865d76cb5dec46effc4ddf3db69dd7bd8b3" translate="yes" xml:space="preserve">
          <source>Check whether the tuple &lt;code&gt;T&lt;/code&gt; is a type tuple. A type tuple only contains types.</source>
          <target state="translated">Compruebe si la tupla &lt;code&gt;T&lt;/code&gt; es una tupla de tipo. Una tupla de tipo solo contiene tipos.</target>
        </trans-unit>
        <trans-unit id="f2b123f344913046043c7f94d2d9417280390123" translate="yes" xml:space="preserve">
          <source>Check whether the tuple T is an expression tuple. An expression tuple only contains expressions.</source>
          <target state="translated">Comprueba si la tupla T es una tupla de expresión.Una tupla de expresión sólo contiene expresiones.</target>
        </trans-unit>
        <trans-unit id="5374967cf17045f818df69f4c4da8c46fb272364" translate="yes" xml:space="preserve">
          <source>Check whether the type t representation relies on one or more the template parameters.</source>
          <target state="translated">Compruebe si la representación del tipo t se basa en uno o más de los parámetros de la plantilla.</target>
        </trans-unit>
        <trans-unit id="a81260a4f45c118b1ea3d76244c3549c2710e64e" translate="yes" xml:space="preserve">
          <source>CheckDns &lt;code&gt;checkDNS&lt;/code&gt;</source>
          <target state="translated">CheckDns &lt;code&gt;checkDNS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5ad7d1dc4c316626ec88560f3cf3f5028c21c54" translate="yes" xml:space="preserve">
          <source>CheckException &lt;strong id=&quot;err&quot;&gt;err&lt;/strong&gt;;</source>
          <target state="translated">CheckException &lt;strong id=&quot;err&quot;&gt;err&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="102c409f892dccfa7ef03ae04285bb95f236e32f" translate="yes" xml:space="preserve">
          <source>CheckException if the document is not well formed  CheckException's toString() method will yield the complete hierarchy of parse failure (the XML equivalent of a stack trace), giving the line and column number of every failure at every level.</source>
          <target state="translated">CheckException si el documento no está bien formado El método toString()de CheckException producirá la jerarquía completa del fallo de análisis (el equivalente XML de una traza de pila),dando el número de línea y columna de cada fallo en cada nivel.</target>
        </trans-unit>
        <trans-unit id="bada63007fff0aeaf5219e5a4263f3c5062820f1" translate="yes" xml:space="preserve">
          <source>Checked integral type wraps an integral &lt;code&gt;T&lt;/code&gt; and customizes its behavior with the help of a &lt;code&gt;Hook&lt;/code&gt; type. The type wrapped must be one of the predefined integrals (unqualified), or another instance of &lt;code&gt;Checked&lt;/code&gt;.</source>
          <target state="translated">El tipo integral marcado envuelve una &lt;code&gt;T&lt;/code&gt; integral y personaliza su comportamiento con la ayuda de un tipo &lt;code&gt;Hook&lt;/code&gt; . El tipo empaquetado debe ser una de las integrales predefinidas (no calificadas) u otra instancia de &lt;code&gt;Checked&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
