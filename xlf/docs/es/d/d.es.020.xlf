<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="560e8754d1a43d2889127379ce8941035430acdf" translate="yes" xml:space="preserve">
          <source>Identity Assignment Overload</source>
          <target state="translated">Sobrecarga en la asignación de identidades</target>
        </trans-unit>
        <trans-unit id="feaad94f17d0151c7ee9d808da8437d06bd6ced9" translate="yes" xml:space="preserve">
          <source>Identity Expressions</source>
          <target state="translated">Expresiones de identidad</target>
        </trans-unit>
        <trans-unit id="3541f48427fcdd81e30c7c16278c379163644459" translate="yes" xml:space="preserve">
          <source>Ideographic</source>
          <target state="translated">Ideographic</target>
        </trans-unit>
        <trans-unit id="5b6b53689a3fc635c459675544040944bd74d306" translate="yes" xml:space="preserve">
          <source>Ideographic Description Characters</source>
          <target state="translated">Descripción Ideográfica Personajes</target>
        </trans-unit>
        <trans-unit id="250ad5161fad3e8519e80733a4a75b5049da3f8e" translate="yes" xml:space="preserve">
          <source>Idiomatic Use of &lt;code&gt;std.experimental.allocator&lt;/code&gt;</source>
          <target state="translated">Uso idiom&amp;aacute;tico de &lt;code&gt;std.experimental.allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="828467146cd8af7a4600851262e42a7b8fdfff46" translate="yes" xml:space="preserve">
          <source>If !is null, elements[] can be sparse and basis is used for the &quot;default&quot; element value. In other words, non-null elements[i] overrides this 'basis' value.</source>
          <target state="translated">Si !es nulo,los elementos[]pueden ser escasos y se utiliza la base para el valor &quot;por defecto&quot; del elemento.En otras palabras,los elementos no nulos[i]anulan este valor &quot;base&quot;.</target>
        </trans-unit>
        <trans-unit id="9ddd459237f2459c44b509144a91e81da646bb40" translate="yes" xml:space="preserve">
          <source>If 'e' is a tree of commas, returns the rightmost expression by stripping off it from the tree. The remained part of the tree is returned via e0. Otherwise 'e' is directly returned and e0 is set to NULL.</source>
          <target state="translated">Si &quot;e&quot; es un árbol de comas,devuelve la expresión más correcta quitándola del árbol.La parte que queda del árbol es devuelta a través de la &quot;e0&quot;.Si no,&quot;e&quot; es devuelta directamente y &quot;e0&quot; es puesta en NULL.</target>
        </trans-unit>
        <trans-unit id="1b4dc8c105f5a3f750e979db674fe11913e62d44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="translated">Si &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt; &lt;code&gt;std.range.primitives.ElementType&lt;/code&gt; &lt;/a&gt; ! R es un tipo de punto flotante y &lt;code&gt;R&lt;/code&gt; es un &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;rango de acceso aleatorio&lt;/a&gt; con longitud y corte, entonces &lt;code&gt;sum&lt;/code&gt; usa el algoritmo de &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;suma por pares&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c45083751ac69c2e8e598d9798f65c4de37c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!!value&lt;/code&gt; is true, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; is thrown. &lt;code&gt;WindowsException&lt;/code&gt; assumes that the last operation set &lt;code&gt;GetLastError()&lt;/code&gt; appropriately.</source>
          <target state="translated">Si &lt;code&gt;!!value&lt;/code&gt; es verdadero, se devuelve el &lt;code&gt;value&lt;/code&gt; . De lo contrario, se &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; . &lt;code&gt;WindowsException&lt;/code&gt; supone que la &amp;uacute;ltima operaci&amp;oacute;n estableci&amp;oacute; &lt;code&gt;GetLastError()&lt;/code&gt; adecuada.</target>
        </trans-unit>
        <trans-unit id="8df9d33ad5bc28652f3433433542fda31081bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!isInfinite!Source&lt;/code&gt; and &lt;code&gt;source.walkLength&lt;/code&gt; is not evenly divisible by &lt;code&gt;chunkSize&lt;/code&gt;, the back element of this range will contain fewer than &lt;code&gt;chunkSize&lt;/code&gt; elements.</source>
          <target state="translated">Si &lt;code&gt;!isInfinite!Source&lt;/code&gt; y &lt;code&gt;source.walkLength&lt;/code&gt; no es divisible por &lt;code&gt;chunkSize&lt;/code&gt; , el elemento posterior de este rango contendr&amp;aacute; menos elementos que &lt;code&gt;chunkSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da45e2d8d90136b7f84f13e1858fb6ece371b4b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new E(msg, file, line)&lt;/code&gt; is thrown. Or if &lt;code&gt;E&lt;/code&gt; doesn't take a message and can be constructed with &lt;code&gt;new E(file, line)&lt;/code&gt;, then &lt;code&gt;new E(file, line)&lt;/code&gt; will be thrown.</source>
          <target state="translated">Si &lt;code&gt;!value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , se devuelve el &lt;code&gt;value&lt;/code&gt; . De lo contrario, se lanza una &lt;code&gt;new E(msg, file, line)&lt;/code&gt; . O si &lt;code&gt;E&lt;/code&gt; no toma un mensaje y puede construirse con una &lt;code&gt;new E(file, line)&lt;/code&gt; , se generar&amp;aacute; una &lt;code&gt;new E(file, line)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e70bac81fdcc8ee63f8a6ffecb44cdbcf2f794c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no state, the resulting object is allocated in static shared storage.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; no tiene estado, el objeto resultante se asigna en almacenamiento compartido est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="7b2c6010fe0ff7fc814ba13aa84690947c8cb83d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is copyable, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; tiene estado y es copiable, el resultado &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; el asignador &lt;code&gt;A a&lt;/code&gt; suministrado dentro. El resultado en s&amp;iacute; mismo se asigna en su propio asignador est&amp;aacute;ticamente tipado.</target>
        </trans-unit>
        <trans-unit id="e90491f805af73197e670ba7dcdbdea4f3f9187b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is not copyable, the result will move the passed-in argument into the result. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; tiene estado y no es copiable, el resultado mover&amp;aacute; el argumento pasado al resultado. El resultado en s&amp;iacute; mismo se asigna en su propio asignador est&amp;aacute;ticamente tipado.</target>
        </trans-unit>
        <trans-unit id="8e3921430ef3c9cb639e4397d8b838ecfe391c50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; tiene estado, el resultado &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; el asignador suministrado &lt;code&gt;A a&lt;/code&gt; dentro. El resultado en s&amp;iacute; mismo se asigna en su propio asignador est&amp;aacute;ticamente tipado.</target>
        </trans-unit>
        <trans-unit id="85c9db39cbb0a223dde8b65577a816ac4ae74ca1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Allocator&lt;/code&gt; implements &lt;code&gt;owns&lt;/code&gt;, forwards to it. Otherwise, returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Allocator&lt;/code&gt; implementa &lt;code&gt;owns&lt;/code&gt; , reenv&amp;iacute;a a &amp;eacute;l. De lo contrario, devuelve &lt;code&gt;Ternary.unknown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="602c75c69645dadebf41e326ef28dced33652078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;bkalloc&lt;/code&gt; is defined and accessible.</source>
          <target state="translated">Si &lt;code&gt;BookkeepingAllocator&lt;/code&gt; no es &lt;code&gt;NullAllocator&lt;/code&gt; , &lt;code&gt;bkalloc&lt;/code&gt; est&amp;aacute; definido y accesible.</target>
        </trans-unit>
        <trans-unit id="e61003ea748193c575ad061853d1dd56eb5e4c1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="translated">Si &lt;code&gt;ElementType!R&lt;/code&gt; es un tipo de punto flotante y &lt;code&gt;R&lt;/code&gt; es un rango de entrada finito (pero no un rango de acceso aleatorio con segmentaci&amp;oacute;n), entonces &lt;code&gt;sum&lt;/code&gt; usa el algoritmo de &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;suma Kahan&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e00af2edb93d47ac443e7418f444a801ea32bd2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;max&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">Si &lt;code&gt;FreeList&lt;/code&gt; se ha instanciado con &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; , entonces la propiedad &lt;code&gt;max&lt;/code&gt; se puede escribir. Establecerlo debe preceder a cualquier asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="619bff2f62db09894cc368f16063c71698b3e91a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;min&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">Si &lt;code&gt;FreeList&lt;/code&gt; se ha instanciado con &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; , entonces la propiedad &lt;code&gt;min&lt;/code&gt; se puede escribir. Establecerlo debe preceder a cualquier asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="614802dd9535195f4c34d795221ff4407109b94d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpOpAssign&lt;/code&gt;, &lt;code&gt;opOpAssign&lt;/code&gt; forwards to &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt;, where &lt;code&gt;payload&lt;/code&gt; is a reference to the internally held data so the hook can change it.</source>
          <target state="translated">Si &lt;code&gt;Hook&lt;/code&gt; define &lt;code&gt;hookOpOpAssign&lt;/code&gt; , &lt;code&gt;opOpAssign&lt;/code&gt; reenv&amp;iacute;a a &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; , donde la &lt;code&gt;payload&lt;/code&gt; es una referencia a los datos internos para que el gancho pueda cambiarla.</target>
        </trans-unit>
        <trans-unit id="6213f7b3e2cf0b3c2b2e856da1c03c2c3603a41e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opBinary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; in case an overflow occurs.</source>
          <target state="translated">Si &lt;code&gt;Hook&lt;/code&gt; no define &lt;code&gt;hookOpBinary&lt;/code&gt; pero define &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opBinary&lt;/code&gt; reenv&amp;iacute;a a &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; en caso de que ocurra un desbordamiento.</target>
        </trans-unit>
        <trans-unit id="48a7fb4afe12c2822acfff866c271812d59b89d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpUnary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opUnary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; in case an overflow occurs. For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, the payload is assigned from the result of the call to &lt;code&gt;onOverflow&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Hook&lt;/code&gt; no define &lt;code&gt;hookOpUnary&lt;/code&gt; pero define &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opUnary&lt;/code&gt; reenv&amp;iacute;a a &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; en caso de que ocurra un desbordamiento. Para &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; , la carga &amp;uacute;til se asigna del resultado de la llamada a &lt;code&gt;onOverflow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10cd8aa857d486ec2d02cef4465f8ceb45e4e90d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; holds state, &lt;code&gt;parent&lt;/code&gt; is a public member of type &lt;code&gt;KRRegion&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an &lt;code&gt;alias&lt;/code&gt; for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ParentAllocator&lt;/code&gt; posee el estado, &lt;code&gt;parent&lt;/code&gt; es un miembro p&amp;uacute;blico de tipo &lt;code&gt;KRRegion&lt;/code&gt; . De lo contrario, &lt;code&gt;parent&lt;/code&gt; es un &lt;code&gt;alias&lt;/code&gt; para &lt;code&gt;ParentAllocator.instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bbccd514894e82c4ce13569d09888036cf3359f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, only the constructor taking &lt;code&gt;data&lt;/code&gt; is defined and the user is responsible for freeing &lt;code&gt;data&lt;/code&gt; if desired.</source>
          <target state="translated">Si &lt;code&gt;ParentAllocator&lt;/code&gt; es &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , s&amp;oacute;lo el constructor toma &lt;code&gt;data&lt;/code&gt; se define y el usuario es responsable de liberar &lt;code&gt;data&lt;/code&gt; si se desea.</target>
        </trans-unit>
        <trans-unit id="d42312f5e4b477adba48781c375b173d6250fd1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Region&lt;/code&gt; deallocates the chunk of memory during destruction.</source>
          <target state="translated">Si &lt;code&gt;ParentAllocator&lt;/code&gt; es diferente de &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Region&lt;/code&gt; desasigna la porci&amp;oacute;n de memoria durante la destrucci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9a65e34991edf1fabbde944025e9467eaa28acfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is stateful, &lt;code&gt;parent&lt;/code&gt; is a property giving access to an &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an alias for &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ParentAllocator&lt;/code&gt; tiene estado, &lt;code&gt;parent&lt;/code&gt; es una propiedad que da acceso a un &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt; . De lo contrario, &lt;code&gt;parent&lt;/code&gt; es un alias para &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d333c4fd79ece4dce7180ff004a1dd304cfda4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;, the alignment is that of the parent. Otherwise, the alignment is the same as the &lt;code&gt;Prefix&lt;/code&gt;'s alignment.</source>
          <target state="translated">Si &lt;code&gt;Prefix&lt;/code&gt; es &lt;code&gt;void&lt;/code&gt; , la alineaci&amp;oacute;n es la del padre. De lo contrario, la alineaci&amp;oacute;n es la misma que la del &lt;code&gt;Prefix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ef958a14b28e8a87e35d39d726513cf1a24e3ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is not &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;Allocator&lt;/code&gt; must guarantee an alignment at least as large as &lt;code&gt;Prefix.alignof&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Prefix&lt;/code&gt; no es &lt;code&gt;void&lt;/code&gt; , &lt;code&gt;Allocator&lt;/code&gt; debe garantizar una alineaci&amp;oacute;n al menos tan grande como &lt;code&gt;Prefix.alignof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bde56d414db390f6de687beeb6a7de19e32b07b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; defines a destructor, the generated code for &lt;code&gt;opAssign&lt;/code&gt; is:</source>
          <target state="translated">Si &lt;code&gt;S&lt;/code&gt; define un destructor, el c&amp;oacute;digo generado para &lt;code&gt;opAssign&lt;/code&gt; es:</target>
        </trans-unit>
        <trans-unit id="8fa12abad24500172f1e1f4de478a1e097e94f32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; does not have a postblit or a destructor, but contains at least one field that defines an &lt;code&gt;opAssign&lt;/code&gt; function (which is not disabled), then the body will make member-wise assignments:</source>
          <target state="translated">Si &lt;code&gt;S&lt;/code&gt; no tiene un postblit o un destructor, pero contiene al menos un campo que define una funci&amp;oacute;n &lt;code&gt;opAssign&lt;/code&gt; (que no est&amp;aacute; deshabilitada), entonces el cuerpo realizar&amp;aacute; asignaciones para miembros:</target>
        </trans-unit>
        <trans-unit id="135d5e0bd9ac5cff9f359e01e49ee96d18ba1175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; has a disabled destructor or at least one field that has a disabled &lt;code&gt;opAssign&lt;/code&gt;, &lt;code&gt;S.opAssign&lt;/code&gt; is going to be generated, but marked with &lt;code&gt;@disable&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;S&lt;/code&gt; tiene un destructor deshabilitado o al menos un campo que tiene un &lt;code&gt;opAssign&lt;/code&gt; deshabilitado , se &lt;code&gt;S.opAssign&lt;/code&gt; , pero se marcar&amp;aacute; con &lt;code&gt;@disable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d3671bcdce32a3ae79160f07ed6d9617aa8c77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; has structural conformance with the &lt;code&gt;interface&lt;/code&gt;&lt;code&gt;Targets&lt;/code&gt;, wrap creates an internal wrapper class which inherits &lt;code&gt;Targets&lt;/code&gt; and wraps the &lt;code&gt;src&lt;/code&gt; object, then returns it.</source>
          <target state="translated">Si &lt;code&gt;Source&lt;/code&gt; tiene conformidad estructural con los &lt;code&gt;Targets&lt;/code&gt; la &lt;code&gt;interface&lt;/code&gt; , wrap crea una clase de contenedor interno que hereda los &lt;code&gt;Targets&lt;/code&gt; y ajusta el objeto &lt;code&gt;src&lt;/code&gt; , luego lo devuelve.</target>
        </trans-unit>
        <trans-unit id="a6a1c6b133b0871dee66034a379d92385c6acfa0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting chunks will be input ranges consuming the same input: iterating over &lt;code&gt;front&lt;/code&gt; will shrink the chunk such that subsequent invocations of &lt;code&gt;front&lt;/code&gt; will no longer return the full chunk, and calling &lt;code&gt;popFront&lt;/code&gt; on the outer range will invalidate any lingering references to previous values of &lt;code&gt;front&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Source&lt;/code&gt; es un rango directo, el rango resultante ser&amp;aacute; tambi&amp;eacute;n rangos directos. De lo contrario, los fragmentos resultantes ser&amp;aacute;n rangos de entrada que consuman la misma entrada: iterar sobre el &lt;code&gt;front&lt;/code&gt; reducir&amp;aacute; el fragmento de manera que las invocaciones posteriores del &lt;code&gt;front&lt;/code&gt; ya no devolver&amp;aacute;n el fragmento completo, y llamar a &lt;code&gt;popFront&lt;/code&gt; en el rango externo invalidar&amp;aacute; cualquier referencia persistente a valores anteriores de &lt;code&gt;front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68e4c36f3a209b42eda6036b89cfd912aefdf8d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;StopWatch.init&lt;/code&gt; is used, then the constructed StopWatch isn't running (and can't be, since no constructor ran).</source>
          <target state="translated">Si se utiliza &lt;code&gt;StopWatch.init&lt;/code&gt; , entonces el StopWatch construido no se est&amp;aacute; ejecutando (y no se puede ejecutar, ya que no se ejecut&amp;oacute; ning&amp;uacute;n constructor).</target>
        </trans-unit>
        <trans-unit id="8fa16aaee056c365a9ba1b96bbf4c7ab3e0c7909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; is a range, the &lt;code&gt;BinaryHeap&lt;/code&gt; cannot grow beyond the size of that range. If &lt;code&gt;Store&lt;/code&gt; is a container that supports &lt;code&gt;insertBack&lt;/code&gt;, the &lt;code&gt;BinaryHeap&lt;/code&gt; may grow by adding elements to the container.</source>
          <target state="translated">Si &lt;code&gt;Store&lt;/code&gt; es un rango, &lt;code&gt;BinaryHeap&lt;/code&gt; no puede crecer m&amp;aacute;s all&amp;aacute; del tama&amp;ntilde;o de ese rango. Si &lt;code&gt;Store&lt;/code&gt; es un contenedor que admite &lt;code&gt;insertBack&lt;/code&gt; , &lt;code&gt;BinaryHeap&lt;/code&gt; puede crecer agregando elementos al contenedor.</target>
        </trans-unit>
        <trans-unit id="dbe0360bc543f33ed0b90fcff8d9687e9b9ea633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, returns a reference to the created &lt;code&gt;T&lt;/code&gt; object. Otherwise, returns a &lt;code&gt;T*&lt;/code&gt; pointing to the created object. In all cases, returns &lt;code&gt;null&lt;/code&gt; if allocation failed.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de clase, devuelve una referencia al objeto &lt;code&gt;T&lt;/code&gt; creado . De lo contrario, devuelve una &lt;code&gt;T*&lt;/code&gt; apuntando al objeto creado. En todos los casos, devuelve &lt;code&gt;null&lt;/code&gt; si la asignaci&amp;oacute;n falla.</target>
        </trans-unit>
        <trans-unit id="85b009305a8588231d9cf9c49742c5425d7c6707" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a nested struct, the context pointer in &lt;code&gt;T.init&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una estructura anidada, el puntero de contexto en &lt;code&gt;T.init&lt;/code&gt; es &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86a83fbe1dd6e8e6329df1be326be31fbac7542c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct which has &lt;code&gt;@disable this();&lt;/code&gt;, &lt;code&gt;T.init&lt;/code&gt; might return a logically incorrect object.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una estructura que tiene &lt;code&gt;@disable this();&lt;/code&gt; , &lt;code&gt;T.init&lt;/code&gt; podr&amp;iacute;a devolver un objeto l&amp;oacute;gicamente incorrecto.</target>
        </trans-unit>
        <trans-unit id="28ecbbbd57ec70df9468c10b69230725191bde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct with a destructor or postblit defined, source is reset to its &lt;code&gt;.init&lt;/code&gt; value after it is moved into target, otherwise it is left unchanged.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una estructura con un destructor o postblit definido, la fuente se restablece a su valor &lt;code&gt;.init&lt;/code&gt; despu&amp;eacute;s de que se mueve al destino, de lo contrario se deja sin cambios.</target>
        </trans-unit>
        <trans-unit id="be0ddbf38059d4859dc637f9816765cfecd51bd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a value type, then &lt;code&gt;Unique!T&lt;/code&gt; will be implemented as a reference to a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de valor, entonces &lt;code&gt;Unique!T&lt;/code&gt; ser&amp;aacute; implementado como una referencia a una &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad884b639da3b067a89fc2f9254b6e884145e3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una clase interna cuyo campo &lt;code&gt;outer&lt;/code&gt; se puede utilizar para acceder a una instancia de la clase que lo encierra, entonces &lt;code&gt;Args&lt;/code&gt; no debe estar vac&amp;iacute;o, y el primer miembro debe ser un inicializador v&amp;aacute;lido para ese campo &lt;code&gt;outer&lt;/code&gt; . La inicializaci&amp;oacute;n correcta de este campo es esencial para acceder a los miembros de la clase externa dentro de &lt;code&gt;T&lt;/code&gt; m&amp;eacute;todos T.</target>
        </trans-unit>
        <trans-unit id="5e5dca16a0b08e551a0873d6f42ddf6d816c0620" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s constructor throws, deallocates the allocated memory and propagates the exception.</source>
          <target state="translated">Si el constructor de &lt;code&gt;T&lt;/code&gt; arroja, desasigna la memoria asignada y propaga la excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f9ccf6d42185874390122acb61e0fffade4a1d7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpCmp&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">Si &lt;code&gt;U&lt;/code&gt; tambi&amp;eacute;n es una instancia de &lt;code&gt;Checked&lt;/code&gt; , ambos ganchos (lado izquierdo y derecho) son introspectivos para el m&amp;eacute;todo &lt;code&gt;hookOpCmp&lt;/code&gt; . Si ambos lo definen, se da prioridad al lado izquierdo.</target>
        </trans-unit>
        <trans-unit id="f714d4a1a2b46c6585bd14b3632f61dc774fe527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpEquals&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">Si &lt;code&gt;U&lt;/code&gt; tambi&amp;eacute;n es una instancia de &lt;code&gt;Checked&lt;/code&gt; , ambos ganchos (lado izquierdo y derecho) son introspectivos para el m&amp;eacute;todo &lt;code&gt;hookOpEquals&lt;/code&gt; . Si ambos lo definen, se da prioridad al lado izquierdo.</target>
        </trans-unit>
        <trans-unit id="6530603e838c2a2e64b1bcfb9217be83aec2dafc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.checkDns&lt;/code&gt; then a DNS check for MX records will be made</source>
          <target state="translated">Si la &lt;code&gt;Yes.checkDns&lt;/code&gt; es Yes.checkDns, se realizar&amp;aacute; una comprobaci&amp;oacute;n de DNS para los registros MX</target>
        </trans-unit>
        <trans-unit id="a1992ec3ad4038c0370a2f08b90896545a010903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Si es &lt;code&gt;Yes.pipeOnPop&lt;/code&gt; , simplemente iterar el rango sin llamar al &lt;code&gt;front&lt;/code&gt; es suficiente para tener elementos de espejo en &lt;code&gt;tee&lt;/code&gt; para &lt;code&gt;outputRange&lt;/code&gt; (o, respectivamente, &lt;code&gt;fun&lt;/code&gt; ). Si &lt;code&gt;No.pipeOnPop&lt;/code&gt; , solo los elementos para los que se llama al &lt;code&gt;front&lt;/code&gt; tambi&amp;eacute;n se enviar&amp;aacute;n a &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b44ae6759ea792f0bca17c48004575c328a9fdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt;, then &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and leaves &lt;code&gt;a&lt;/code&gt; unchanged, whereas &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;&quot;de&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt; , &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; y deja &lt;code&gt;a&lt;/code&gt; sin cambios, mientras que &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; avanza &lt;code&gt;a&lt;/code&gt; a &lt;code&gt;&quot;de&quot;&lt;/code&gt; y devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22d1d40c86b33d24346ec7f18b6caa5014b1c725" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt;, &lt;code&gt;bringToFront(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; and &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; y &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt; , &lt;code&gt;bringToFront(a, b)&lt;/code&gt; las hojas &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; y &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161672661d076244bfa4e1cb23db5cb7cee3f0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;reverse(a)&lt;/code&gt; changes it to &lt;code&gt;[3, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; , &lt;code&gt;reverse(a)&lt;/code&gt; cambia a &lt;code&gt;[3, 2, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c20592a36a578c54537352b677f5ac5e2a4bd22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt;, then &lt;code&gt;initializeAll(a)&lt;/code&gt; leaves &lt;code&gt;a = [double.init, double.init]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt; , &lt;code&gt;initializeAll(a)&lt;/code&gt; deja &lt;code&gt;a = [double.init, double.init]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f19fe74876068eb9761e0ed018d3efe050a2dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; and &lt;code&gt;b = [40, 6, 15]&lt;/code&gt;, then &lt;code&gt;completeSort(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; and &lt;code&gt;b = [20, 30, 40]&lt;/code&gt;. The range &lt;code&gt;a&lt;/code&gt; must be sorted prior to the call, and as a result the combination &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; is sorted.</source>
          <target state="translated">Si &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; y &lt;code&gt;b = [40, 6, 15]&lt;/code&gt; , a continuaci&amp;oacute;n, &lt;code&gt;completeSort(a, b)&lt;/code&gt; las hojas &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; y &lt;code&gt;b = [20, 30, 40]&lt;/code&gt; . El rango &lt;code&gt;a&lt;/code&gt; debe ordenarse antes de la llamada y, como resultado, la combinaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; se ordena.</target>
        </trans-unit>
        <trans-unit id="8653b5c90f101e5bb8cf18c8696bdaa4b97980b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt;, then &lt;code&gt;partialSort(a, 3)&lt;/code&gt; leaves &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt;. The other elements of &lt;code&gt;a&lt;/code&gt; are left in an unspecified order.</source>
          <target state="translated">Si &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt; , &lt;code&gt;partialSort(a, 3)&lt;/code&gt; deja &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt; . Los otros elementos de &lt;code&gt;a&lt;/code&gt; se dejan en un orden no especificado.</target>
        </trans-unit>
        <trans-unit id="761844ca385c58407529b15b7f0264a9fdc0b35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allowDuplicates&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then inserting the same element more than once continues to add more elements. If it is &lt;code&gt;false&lt;/code&gt;, duplicate elements are ignored on insertion. If duplicates are allowed, then new elements are inserted after all existing duplicate elements.</source>
          <target state="translated">Si &lt;code&gt;allowDuplicates&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , entonces insertar el mismo elemento m&amp;aacute;s de una vez contin&amp;uacute;a agregando m&amp;aacute;s elementos. Si es &lt;code&gt;false&lt;/code&gt; , los elementos duplicados se ignoran en la inserci&amp;oacute;n. Si se permiten duplicados, se insertan nuevos elementos despu&amp;eacute;s de todos los elementos duplicados existentes.</target>
        </trans-unit>
        <trans-unit id="42df331db67fcac4570e8d97255c06bf51fcef31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;arr.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">Si &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt; , no hace nada y devuelve &lt;code&gt;false&lt;/code&gt; . De lo contrario, destruye los &amp;uacute;ltimos elementos &lt;code&gt;arr.length - delta&lt;/code&gt; en la matriz y luego reasigna el b&amp;uacute;fer de la matriz. Si la reasignaci&amp;oacute;n falla, llena la matriz con datos inicializados por defecto.</target>
        </trans-unit>
        <trans-unit id="73774d72a77acb4ae5cc4817197c7e3cc39e3e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;array.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">Si &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt; , no hace nada y devuelve &lt;code&gt;false&lt;/code&gt; . De lo contrario, destruye los &amp;uacute;ltimos elementos &lt;code&gt;array.length - delta&lt;/code&gt; en la matriz y luego reasigna el b&amp;uacute;fer de la matriz. Si la reasignaci&amp;oacute;n falla, llena la matriz con datos inicializados por defecto.</target>
        </trans-unit>
        <trans-unit id="7b4fa4088c1f332dc1cc2c07bd6dcf7ba46787dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b is null&lt;/code&gt;, does nothing and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, deallocates memory previously allocated with this allocator and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise. An implementation that would not support deallocation (i.e. would always return &lt;code&gt;false&lt;/code&gt; should not define this primitive at all.)</source>
          <target state="translated">Si &lt;code&gt;b is null&lt;/code&gt; , no hace nada y devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, desasigna la memoria previamente asignada con este asignador y devuelve &lt;code&gt;true&lt;/code&gt; si tiene &amp;eacute;xito, de lo contrario , &lt;code&gt;false&lt;/code&gt; . Una implementaci&amp;oacute;n que no admitir&amp;iacute;a la desasignaci&amp;oacute;n (es decir, siempre devolver&amp;iacute;a &lt;code&gt;false&lt;/code&gt; no deber&amp;iacute;a definir esta primitiva en absoluto).</target>
        </trans-unit>
        <trans-unit id="8bae244a830c8d1176da79e2579d3599e88c12f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ba&lt;/code&gt; is zero (the default) the attributes of the existing memory will be used for an allocation. If &lt;code&gt;ba&lt;/code&gt; is not zero and no new memory is allocated, the bits in ba will replace those of the current memory block.</source>
          <target state="translated">Si &lt;code&gt;ba&lt;/code&gt; es cero (el valor predeterminado), los atributos de la memoria existente se utilizar&amp;aacute;n para una asignaci&amp;oacute;n. Si &lt;code&gt;ba&lt;/code&gt; no es cero y no se asigna memoria nueva, los bits en ba reemplazar&amp;aacute;n a los del bloque de memoria actual.</target>
        </trans-unit>
        <trans-unit id="221a7c0321e1759235e9e5a40274abe6cabee406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block.length&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then inserts the block at the front of the free list. For all others, forwards to &lt;code&gt; parent.deallocate&lt;/code&gt; if &lt;code&gt;Parent.deallocate&lt;/code&gt; is defined.</source>
          <target state="translated">Si &lt;code&gt;block.length&lt;/code&gt; est&amp;aacute; dentro de &lt;code&gt;[min, max]&lt;/code&gt; o si la lista libre no est&amp;aacute; marcada ( &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; ), entonces inserta el bloque al principio de la lista libre. Para todos los dem&amp;aacute;s, reenv&amp;iacute;a a &lt;code&gt; parent.deallocate&lt;/code&gt; si se define &lt;code&gt;Parent.deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e4b98282d9ecdaaa0277f0ab4f62ad8d1b53af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;BitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">Si &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;BitmappedBlock&lt;/code&gt; ofrece una propiedad de lectura / escritura &lt;code&gt;blockSize&lt;/code&gt; . Debe establecerse antes de cualquier uso del asignador. De lo contrario (es decir, &lt;code&gt;theBlockSize&lt;/code&gt; es una constante leg&amp;iacute;tima), &lt;code&gt;blockSize&lt;/code&gt; es un alias para &lt;code&gt;theBlockSize&lt;/code&gt; . Ya sea constante o variable, tambi&amp;eacute;n debe ser un m&amp;uacute;ltiplo de &lt;code&gt;alignment&lt;/code&gt; . Esta restricci&amp;oacute;n se &lt;code&gt;assert&lt;/code&gt; est&amp;aacute;tica y din&amp;aacute;micamente.</target>
        </trans-unit>
        <trans-unit id="f93a5a60f8514085265f3aa9ca6972ee5e3faff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">Si &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; ofrece una propiedad de lectura / escritura &lt;code&gt;blockSize&lt;/code&gt; . Debe establecerse antes de cualquier uso del asignador. De lo contrario (es decir, &lt;code&gt;theBlockSize&lt;/code&gt; es una constante leg&amp;iacute;tima), &lt;code&gt;blockSize&lt;/code&gt; es un alias para &lt;code&gt;theBlockSize&lt;/code&gt; . Ya sea constante o variable, tambi&amp;eacute;n debe ser un m&amp;uacute;ltiplo de &lt;code&gt;alignment&lt;/code&gt; . Esta restricci&amp;oacute;n se &lt;code&gt;assert&lt;/code&gt; est&amp;aacute;tica y din&amp;aacute;micamente.</target>
        </trans-unit>
        <trans-unit id="8e23237ade60446568cde90bc631b8dba6e68c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode lowercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its uppercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es un &lt;a href=&quot;#Character&quot;&gt;car&amp;aacute;cter&lt;/a&gt; min&amp;uacute;sculo Unicode , se devuelve su equivalente en may&amp;uacute;scula. De lo contrario, se devuelve &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4c4b1af0ac218e5d7d40db7db18515091e62fd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode uppercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its lowercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es un &lt;a href=&quot;#Character&quot;&gt;car&amp;aacute;cter en&lt;/a&gt; may&amp;uacute;scula Unicode , se devuelve su equivalente en min&amp;uacute;scula. De lo contrario, se devuelve &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9744833e493e9a4deaf2d113274c40f2b544663e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir == Direction.fwd&lt;/code&gt;, then a range iterates forward in time, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then it iterates backwards in time. So, if &lt;code&gt;dir == Direction.fwd&lt;/code&gt; then &lt;code&gt;front == interval.begin&lt;/code&gt;, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt; then &lt;code&gt;front == interval.end&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, to iterate forward in time, the time point that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in.</source>
          <target state="translated">Si &lt;code&gt;dir == Direction.fwd&lt;/code&gt; , entonces un rango itera hacia adelante en el tiempo, mientras que si &lt;code&gt;dir == Direction.bwd&lt;/code&gt; , itera hacia atr&amp;aacute;s en el tiempo. Entonces, si &lt;code&gt;dir == Direction.fwd&lt;/code&gt; entonces &lt;code&gt;front == interval.begin&lt;/code&gt; , mientras que si &lt;code&gt;dir == Direction.bwd&lt;/code&gt; entonces &lt;code&gt;front == interval.end&lt;/code&gt; . &lt;code&gt;func&lt;/code&gt; debe generar un punto de tiempo en la direcci&amp;oacute;n correcta de iteraci&amp;oacute;n, o se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException . Entonces, para iterar hacia adelante en el tiempo, el punto de tiempo que genera &lt;code&gt;func&lt;/code&gt; debe ser m&amp;aacute;s tarde que el que le pas&amp;oacute;. Si es id&amp;eacute;ntico o anterior, entonces una &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;ser&amp;aacute; arrojado Para iterar hacia atr&amp;aacute;s, el punto de tiempo generado debe ser anterior al punto de tiempo que se pas&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="a610ee5ef0581a49f22c22f37935b0d33a042c3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filler&lt;/code&gt; is empty.</source>
          <target state="translated">Si el &lt;code&gt;filler&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="59e6f081398b1db2fd694d5b94d19e81b02d48a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, a new single parameter function  If &lt;code&gt;fun&lt;/code&gt; is not a &lt;code&gt;string&lt;/code&gt;, an alias to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;fun&lt;/code&gt; es una &lt;code&gt;string&lt;/code&gt; , una nueva funci&amp;oacute;n de par&amp;aacute;metro &amp;uacute;nico. Si &lt;code&gt;fun&lt;/code&gt; no es una &lt;code&gt;string&lt;/code&gt; , un alias de la &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="109bcbee3e25a658c4c9396a1465014de8c69b2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is not a string, &lt;code&gt;binaryFun&lt;/code&gt; aliases itself away to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Si la &lt;code&gt;fun&lt;/code&gt; no es una cadena, &lt;code&gt;binaryFun&lt;/code&gt; se aleja de la &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feeb8b9cc07251142d08e56cda48b8463e68f011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hasLength!Range&lt;/code&gt;, simply returns &lt;code&gt;range.length&lt;/code&gt; without checking &lt;code&gt;upTo&lt;/code&gt; (when specified).</source>
          <target state="translated">Si &lt;code&gt;hasLength!Range&lt;/code&gt; , simplemente devuelve &lt;code&gt;range.length&lt;/code&gt; sin marcar &lt;code&gt;upTo&lt;/code&gt; (cuando se especifica).</target>
        </trans-unit>
        <trans-unit id="46b7e88c254c5bba652608bb5aa781949149f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;haystack&lt;/code&gt; is a random-access range, all three components of the tuple have the same type as &lt;code&gt;haystack&lt;/code&gt;. Otherwise, &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the type of &lt;code&gt;result[0]&lt;/code&gt; and &lt;code&gt;result[1]&lt;/code&gt; is the same as &lt;a href=&quot;std_range#takeExactly&quot;&gt;&lt;code&gt;std.range.takeExactly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;haystack&lt;/code&gt; es un rango de acceso aleatorio, los tres componentes de la tupla tienen el mismo tipo que &lt;code&gt;haystack&lt;/code&gt; . De lo contrario, &lt;code&gt;haystack&lt;/code&gt; debe ser un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango directo&lt;/a&gt; y el tipo de &lt;code&gt;result[0]&lt;/code&gt; y &lt;code&gt;result[1]&lt;/code&gt; es el mismo que &lt;a href=&quot;std_range#takeExactly&quot;&gt; &lt;code&gt;std.range.takeExactly&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3993b4b628968f5e6dd7d41599d550f5e0f99ef4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.alignedAllocate&lt;/code&gt; exists, calls it and returns the result. Otherwise, always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Si existe &lt;code&gt;impl.alignedAllocate&lt;/code&gt; , lo llama y devuelve el resultado. De lo contrario, siempre devuelve &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02ba66810cd0cea189e643c4eeba55ce0d4de3e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.deallocate&lt;/code&gt; is not defined, returns &lt;code&gt;false&lt;/code&gt;. Otherwise it forwards the call.</source>
          <target state="translated">Si &lt;code&gt;impl.deallocate&lt;/code&gt; no est&amp;aacute; definido, devuelve &lt;code&gt;false&lt;/code&gt; . De lo contrario, reenv&amp;iacute;a la llamada.</target>
        </trans-unit>
        <trans-unit id="48d32ce690c5f4ef93e7705c87fc34b78de3c611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, &lt;code&gt;needle&lt;/code&gt; can be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; too. In this case &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; is evaluated on each evaluation.</source>
          <target state="translated">Si la &lt;code&gt;input&lt;/code&gt; es un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango de avance&lt;/a&gt; , la &lt;code&gt;needle&lt;/code&gt; puede ser un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango de avance&lt;/a&gt; . En este caso, se &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; en cada evaluaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="26612f521f443b434c0c471a4bb077313e418fc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;less&lt;/code&gt; is the less-than operator, which is the default option, then &lt;code&gt;BinaryHeap&lt;/code&gt; defines a so-called max-heap that optimizes extraction of the</source>
          <target state="translated">Si &lt;code&gt;less&lt;/code&gt; es el operador menor que, que es la opci&amp;oacute;n predeterminada, entonces &lt;code&gt;BinaryHeap&lt;/code&gt; define un llamado max-heap que optimiza la extracci&amp;oacute;n de</target>
        </trans-unit>
        <trans-unit id="bfc0979cbe401db983c65651eae478d6291e89b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; y el operador no se desborda, la funci&amp;oacute;n devuelve el mismo resultado que el operador incorporado. En todos los dem&amp;aacute;s casos, devuelve &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc27af0c815a7e79af80d07be90722649a52810" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, returns &lt;code&gt;double.init&lt;/code&gt;. Otherwise, has the same semantics as the default comparison.</source>
          <target state="translated">Si &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; , devuelve &lt;code&gt;double.init&lt;/code&gt; . De lo contrario, tiene la misma sem&amp;aacute;ntica que la comparaci&amp;oacute;n predeterminada.</target>
        </trans-unit>
        <trans-unit id="d151dfc3083b5628c51cfe2464aced84ec2e31e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; reference the same instance, then nothing is done.</source>
          <target state="translated">Si &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; hacen referencia a la misma instancia, entonces no se hace nada.</target>
        </trans-unit>
        <trans-unit id="1e390340bdf19475ede0638df9c1955fea065de9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, &lt;code&gt;dchar[]&lt;/code&gt;, the line's content will be reused (overwritten) across reads.</source>
          <target state="translated">Si la &lt;code&gt;line&lt;/code&gt; tiene el tipo &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; , &lt;code&gt;dchar[]&lt;/code&gt; , el contenido de la l&amp;iacute;nea se reutilizar&amp;aacute; (se sobrescribir&amp;aacute;) en las lecturas.</target>
        </trans-unit>
        <trans-unit id="98f495eca2d1ec291e5bd0a688459f5f1c82028b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;immutable(ubyte)[]&lt;/code&gt;, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</source>
          <target state="translated">Si la &lt;code&gt;line&lt;/code&gt; tiene un tipo &lt;code&gt;immutable(ubyte)[]&lt;/code&gt; , el comportamiento es similar al caso (1), excepto que no se intenta ninguna comprobaci&amp;oacute;n de UTF en la entrada.</target>
        </trans-unit>
        <trans-unit id="1a835fb44628e74f7f9ff451e8b58c089bf38a93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;wstring&lt;/code&gt;, or &lt;code&gt;dstring&lt;/code&gt;, a new string of the respective type is allocated every read.</source>
          <target state="translated">Si la &lt;code&gt;line&lt;/code&gt; tiene tipo &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;wstring&lt;/code&gt; o &lt;code&gt;dstring&lt;/code&gt; , se asigna una nueva cadena del tipo respectivo en cada lectura.</target>
        </trans-unit>
        <trans-unit id="18e388959a9abaf079dbbac18945110b36067b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;ubyte[]&lt;/code&gt;, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</source>
          <target state="translated">Si la &lt;code&gt;line&lt;/code&gt; tiene el tipo &lt;code&gt;ubyte[]&lt;/code&gt; , el comportamiento es similar al del caso (2), excepto que no se intenta la comprobaci&amp;oacute;n de UTF en la entrada.</target>
        </trans-unit>
        <trans-unit id="c61c7e699d18c7312070fee75c860133527ced6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;main()&lt;/code&gt; or the thread returns normally, (does not throw an exception), the static destructor is added to the list of functions to be called on thread termination.</source>
          <target state="translated">Si &lt;code&gt;main()&lt;/code&gt; o el subproceso regresa normalmente (no produce una excepci&amp;oacute;n), el destructor est&amp;aacute;tico se agrega a la lista de funciones que se invocar&amp;aacute;n en la terminaci&amp;oacute;n del subproceso.</target>
        </trans-unit>
        <trans-unit id="c93fc296f2b731310f3189f9c017eaec2be70e3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxSize == unbounded&lt;/code&gt;, returns &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt;. Otherwise, returns &lt;code&gt;max&lt;/code&gt; for sizes in the interval &lt;code&gt;[min, max]&lt;/code&gt;, and &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; otherwise.</source>
          <target state="translated">Si &lt;code&gt;maxSize == unbounded&lt;/code&gt; , devuelve &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;max&lt;/code&gt; para tama&amp;ntilde;os en el intervalo &lt;code&gt;[min, max]&lt;/code&gt; y &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="27889a42945896ba8e96a2b9190859d044697880" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt;, the algorithm has no effect and returns &lt;code&gt;r[0 .. r.length]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt; , el algoritmo no tiene efecto y devuelve &lt;code&gt;r[0 .. r.length]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c001d68799c0a0c1fe4332536339591e3128dd5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is eligible for freelisting, returns &lt;code&gt;max&lt;/code&gt;. Otherwise, returns &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; es elegible para la lista libre, devuelve &lt;code&gt;max&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fec7ab17fff539f84df945449516192c8415a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is not defined, an infinite random access range with slicing.  If &lt;code&gt;n&lt;/code&gt; is defined, a random access range with slicing.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; no est&amp;aacute; definido, un rango de acceso aleatorio infinito con segmentaci&amp;oacute;n. Si se define &lt;code&gt;n&lt;/code&gt; , un rango de acceso aleatorio con segmentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7f2409b5e5208bcbd4bd9ae5b46439868d522731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opCall&lt;/code&gt; is overridden for the struct, and the struct is initialized with a value that is of a different type, then the &lt;code&gt;opCall&lt;/code&gt; operator is called:</source>
          <target state="translated">Si &lt;code&gt;opCall&lt;/code&gt; se anula para la estructura, y la estructura se inicializa con un valor que es de un tipo diferente, entonces se &lt;code&gt;opCall&lt;/code&gt; operador opCall :</target>
        </trans-unit>
        <trans-unit id="0a8768e44be6ce84df4d8ac63955bf151c1ba410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opIndex&lt;/code&gt; is declared with only one argument, the compile-time argument to &lt;code&gt;opDollar&lt;/code&gt; may be omitted. In this case, it is illegal to use &lt;code&gt;$&lt;/code&gt; inside an array indexing expression with more than one argument.</source>
          <target state="translated">Si &lt;code&gt;opIndex&lt;/code&gt; se declara con un solo argumento, puede omitirse el argumento en tiempo de compilaci&amp;oacute;n de &lt;code&gt;opDollar&lt;/code&gt; . En este caso, es ilegal usar &lt;code&gt;$&lt;/code&gt; dentro de una expresi&amp;oacute;n de indexaci&amp;oacute;n de matriz con m&amp;aacute;s de un argumento.</target>
        </trans-unit>
        <trans-unit id="1c029e2e84868e89d9aba168477cd4b281e4a698" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a pointer somewhere inside a block allocated with this allocator, &lt;code&gt;result&lt;/code&gt; holds a pointer to the beginning of the allocated block and returns &lt;code&gt;Ternary.yes&lt;/code&gt;. Otherwise, &lt;code&gt;result&lt;/code&gt; holds &lt;code&gt;null&lt;/code&gt; and returns &lt;code&gt;Ternary.no&lt;/code&gt;. If the pointer points immediately after an allocated block, the result is implementation defined.</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es un puntero en alg&amp;uacute;n lugar dentro de un bloque asignado con este asignador, el &lt;code&gt;result&lt;/code&gt; ado mantiene un puntero al principio del bloque asignado y devuelve &lt;code&gt;Ternary.yes&lt;/code&gt; . De lo contrario, el &lt;code&gt;result&lt;/code&gt; ado se mantiene &lt;code&gt;null&lt;/code&gt; y devuelve &lt;code&gt;Ternary.no&lt;/code&gt; . Si el puntero apunta inmediatamente despu&amp;eacute;s de un bloque asignado, el resultado es la implementaci&amp;oacute;n definida.</target>
        </trans-unit>
        <trans-unit id="e2eb2629d5b4956bd1542eca4775455139c95a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a relative directory, return it unaltered.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; es un directorio relativo, devu&amp;eacute;lvalo sin modificaciones.</target>
        </trans-unit>
        <trans-unit id="702fecc6b0bc34adfafc2cb51d268f4825e76aef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already absolute, return it.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; ya es absoluta, devu&amp;eacute;lvala.</target>
        </trans-unit>
        <trans-unit id="051c5165fdb7f4181c26346b52a8a370bb269c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is empty, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; est&amp;aacute; vac&amp;iacute;a, devuelva &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de70cd968c35f871aa7f988334ddd5070ebe64cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is on the form &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; is applied to</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; est&amp;aacute; en el formulario &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (ruta UNC), &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt; se aplica a</target>
        </trans-unit>
        <trans-unit id="5ccfc704dde80078077c0681938c9dc1e45235e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\.\&lt;/code&gt; (Win32 device namespace) this function returns &lt;code&gt;false&lt;/code&gt;; such paths are beyond the scope of this module.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; comienza con &lt;code&gt;\\.\&lt;/code&gt; (Espacio de nombres del dispositivo Win32), esta funci&amp;oacute;n devuelve &lt;code&gt;false&lt;/code&gt; ; tales caminos est&amp;aacute;n m&amp;aacute;s all&amp;aacute; del alcance de este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="891daee93beed99df04fb47b76bddba5d0aeec90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\?\&lt;/code&gt; (long UNC path), the only requirement for the rest of the string is that it does not contain the null character.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; comienza con &lt;code&gt;\\?\&lt;/code&gt; (Ruta UNC larga), el &amp;uacute;nico requisito para el resto de la cadena es que no contenga el car&amp;aacute;cter nulo.</target>
        </trans-unit>
        <trans-unit id="cf0839c8941b9553277dcc1246fadae5b4af51e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;postData&lt;/code&gt; is non-null the method will be set to &lt;code&gt;post&lt;/code&gt; for HTTP requests.</source>
          <target state="translated">Si &lt;code&gt;postData&lt;/code&gt; no es nulo, el m&amp;eacute;todo se configurar&amp;aacute; para &lt;code&gt;post&lt;/code&gt; las solicitudes HTTP.</target>
        </trans-unit>
        <trans-unit id="b45cfaf55131d31d198ea2c44bd484f7f79174d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pretty&lt;/code&gt; is false no whitespaces are generated. If &lt;code&gt;pretty&lt;/code&gt; is true serialized string is formatted to be human-readable. Set the &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt;&lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;options&lt;/code&gt; to encode NaN/Infinity as strings.</source>
          <target state="translated">Si &lt;code&gt;pretty&lt;/code&gt; es falso, no se generan espacios en blanco. Si &lt;code&gt;pretty&lt;/code&gt; es cierto, la cadena serializada est&amp;aacute; formateada para que sea legible por humanos. Establezca el indicador &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt; &lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt; &lt;/a&gt; en las &lt;code&gt;options&lt;/code&gt; para codificar NaN / Infinity como cadenas.</target>
        </trans-unit>
        <trans-unit id="4fe6d0c26964bd6dde3a76798f875b6541f56e6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; is attempted. If that fails, an attempt is made to move the allocation from &lt;code&gt;fallback&lt;/code&gt; to &lt;code&gt;primary&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;primary&lt;/code&gt; no posee &lt;code&gt;b&lt;/code&gt; , entonces se intenta &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; . Si eso falla, se hace un intento para mover la asignaci&amp;oacute;n de &lt;code&gt;fallback&lt;/code&gt; a &lt;code&gt;primary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45d84a0c7a2f66706678e328dd9e74e78023bd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;printf&lt;/code&gt;-style logging is needed add a &lt;b&gt;f&lt;/b&gt; to the logging call, such as &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; or &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt;. The additional &lt;b&gt;f&lt;/b&gt; appended to the function name enables &lt;code&gt;printf&lt;/code&gt;-style logging for all combinations of explicit &lt;code&gt;LogLevel&lt;/code&gt; and conditional logging functions and methods.</source>
          <target state="translated">Si se necesita el registro de estilo &lt;code&gt;printf&lt;/code&gt; , agregue una &lt;b&gt;f&lt;/b&gt; a la llamada de registro, como &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; o &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt; . La &lt;b&gt;f&lt;/b&gt; adicional agregada al nombre de la funci&amp;oacute;n permite el registro de estilo &lt;code&gt;printf&lt;/code&gt; para todas las combinaciones de &lt;code&gt;LogLevel&lt;/code&gt; expl&amp;iacute;cito y funciones y m&amp;eacute;todos de registro condicional.</target>
        </trans-unit>
        <trans-unit id="c809d18303614396b533b1264943fb0bf373af22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; contains equivalent elements, multiple permutations of &lt;code&gt;r&lt;/code&gt; satisfy these constraints. In such cases, &lt;code&gt;pivotPartition&lt;/code&gt; attempts to distribute equivalent elements fairly to the left and right of &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;k&lt;/code&gt; stays close to &lt;code&gt;r.length / 2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; contiene elementos equivalentes, las permutaciones m&amp;uacute;ltiples de &lt;code&gt;r&lt;/code&gt; satisfacen estas restricciones. En tales casos, &lt;code&gt;pivotPartition&lt;/code&gt; intenta distribuir elementos equivalentes equitativamente a la izquierda y a la derecha de &lt;code&gt;k&lt;/code&gt; de modo que &lt;code&gt;k&lt;/code&gt; permanezca cerca de &lt;code&gt;r.length / 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23935d946a100a97c3e455c30306a633f7b98438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; has a length, then this is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, it's &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; tiene una longitud, entonces esto es &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ). De lo contrario, es &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f163286db8bb098fc5cc4073249e55f06a301b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a string with Unicode characters in it, &lt;code&gt;padLeft&lt;/code&gt; follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call &lt;a href=&quot;std_uni#byGrapheme&quot;&gt;&lt;code&gt;std.uni.byGrapheme&lt;/code&gt;&lt;/a&gt; before calling this function.</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; es una cadena con caracteres Unicode, &lt;code&gt;padLeft&lt;/code&gt; sigue las reglas de D sobre la longitud de las cadenas, que no es el n&amp;uacute;mero de caracteres o grafemas, sino el n&amp;uacute;mero de unidades de codificaci&amp;oacute;n. Si desea tratar cada grafema como una sola unidad de codificaci&amp;oacute;n, llame a &lt;a href=&quot;std_uni#byGrapheme&quot;&gt; &lt;code&gt;std.uni.byGrapheme&lt;/code&gt; &lt;/a&gt; antes de llamar a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6a927ae2914fb825262976485c0cc9304c3da3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then &lt;code&gt;r&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;r&lt;/code&gt; is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If &lt;code&gt;r&lt;/code&gt; is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions),</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; no es una cadena autodescodificable (es decir, una cadena estrecha o un tipo definido por el usuario que implique conversiones a un tipo de cadena), entonces se devuelve &lt;code&gt;r&lt;/code&gt; . De lo contrario, &lt;code&gt;r&lt;/code&gt; se convierte a su tipo de cadena correspondiente (si a&amp;uacute;n no es una cadena) y se envuelve en un rango de acceso aleatorio donde el tipo de codificaci&amp;oacute;n del elemento de la cadena (su unidad de c&amp;oacute;digo) es el tipo de elemento del rango, y ese rango devuelto El rango tiene rebanado. Si &lt;code&gt;r&lt;/code&gt; es lo suficientemente peculiar como para ser una estructura o clase que es un rango de entrada de caracteres por s&amp;iacute; solo (es decir, tiene la API de rango de entrada como funciones miembro),</target>
        </trans-unit>
        <trans-unit id="df6a47c8f433360081103c7b545791ca9cd35f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; does not have length, and &lt;code&gt;popFront&lt;/code&gt; is called when &lt;code&gt;front.index == Enumerator.max&lt;/code&gt;, the index will overflow and continue from &lt;code&gt;Enumerator.min&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;range&lt;/code&gt; no tiene longitud, y &lt;code&gt;popFront&lt;/code&gt; se llama cuando &lt;code&gt;front.index == Enumerator.max&lt;/code&gt; , el &amp;iacute;ndice se desbordar&amp;aacute; y continuar desde &lt;code&gt;Enumerator.min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e2389187db9ad1c90dc2cdb963a735557c21c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; has length, then it is an error to pass a value for &lt;code&gt;start&lt;/code&gt; so that &lt;code&gt;start + range.length&lt;/code&gt; is bigger than &lt;code&gt;Enumerator.max&lt;/code&gt;, thus it is ensured that overflow cannot happen.</source>
          <target state="translated">Si el &lt;code&gt;range&lt;/code&gt; tiene longitud, entonces es un error pasar un valor de &lt;code&gt;start&lt;/code&gt; para que &lt;code&gt;start + range.length&lt;/code&gt; sea ​​mayor que &lt;code&gt;Enumerator.max&lt;/code&gt; , por lo que se garantiza que no se produzca un desbordamiento.</target>
        </trans-unit>
        <trans-unit id="111a596bfe5993b016245842df9ecb465a3674d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; y el operador no se desborda, la funci&amp;oacute;n devuelve el mismo resultado que el operador incorporado. En todos los dem&amp;aacute;s casos, devuelve &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5536ec979292168bf217723d15877e765427904" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt;. Otherwise, returns &lt;code&gt;cast(Lhs) rhs&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;rhs&lt;/code&gt; es &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt; , devuelve &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;cast(Lhs) rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ede40fbc0f7d83884db066a6386fc8a519d5ed8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == 0&lt;/code&gt;, the call may return any empty slice (including &lt;code&gt;null&lt;/code&gt;). Otherwise, the call allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns the allocated block, or &lt;code&gt;null&lt;/code&gt; if the request could not be satisfied.</source>
          <target state="translated">Si &lt;code&gt;s == 0&lt;/code&gt; , la llamada puede devolver cualquier segmento vac&amp;iacute;o (incluido &lt;code&gt;null&lt;/code&gt; ). De lo contrario, la llamada asigna &lt;code&gt;s&lt;/code&gt; bytes de memoria y devuelve el bloque asignado, o &lt;code&gt;null&lt;/code&gt; si no se puede satisfacer la solicitud.</target>
        </trans-unit>
        <trans-unit id="9eadce3ccc140e91f7b505d0328ee8cc176eeac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt;, then elements are moved from the end of the range into the slots to be filled. In this case, the absolute minimum of moves is performed.</source>
          <target state="translated">Si &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt; , los elementos se mueven desde el final del rango a las ranuras a rellenar. En este caso, se realiza el m&amp;iacute;nimo absoluto de movimientos.</target>
        </trans-unit>
        <trans-unit id="8bbc6063db8df4c25b1d7ab2586ea771801923fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a function template, i.e. the only member of a template and that member is a function, return that template.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es una plantilla de funci&amp;oacute;n, es decir, el &amp;uacute;nico miembro de una plantilla y ese miembro es una funci&amp;oacute;n, devuelva esa plantilla.</target>
        </trans-unit>
        <trans-unit id="ac063e0ae979bd086a87ed636e906eb9690bf4e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; ends with &lt;code&gt;delimiter&lt;/code&gt;, then &lt;code&gt;str&lt;/code&gt; is returned without &lt;code&gt;delimiter&lt;/code&gt; on its end. If it &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">Si &lt;code&gt;str&lt;/code&gt; termina con &lt;code&gt;delimiter&lt;/code&gt; , entonces &lt;code&gt;str&lt;/code&gt; se devuelve sin &lt;code&gt;delimiter&lt;/code&gt; en su extremo. Si lo hace &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a851969ac104167dbde2b6f580e63232a655ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; starts with &lt;code&gt;delimiter&lt;/code&gt;, then the part of &lt;code&gt;str&lt;/code&gt; following &lt;code&gt;delimiter&lt;/code&gt; is returned. If &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">Si &lt;code&gt;str&lt;/code&gt; comienza con &lt;code&gt;delimiter&lt;/code&gt; , se devuelve la parte de &lt;code&gt;str&lt;/code&gt; que sigue al &lt;code&gt;delimiter&lt;/code&gt; . Si &lt;code&gt;str&lt;/code&gt; hace</target>
        </trans-unit>
        <trans-unit id="4978f696ceefb2aa4374b5f4ce674343dc8b0fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sz&lt;/code&gt; is zero, the memory referenced by p will be deallocated as if by a call to &lt;code&gt;free&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, new memory will be allocated via &lt;code&gt;malloc&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is pointing to memory not allocated from the GC or to the interior of an allocated memory block, no operation is performed and null is returned.</source>
          <target state="translated">Si &lt;code&gt;sz&lt;/code&gt; es cero, la memoria a la que hace referencia p se desasignar&amp;aacute; como si fuera una llamada a &lt;code&gt;free&lt;/code&gt; . Si &lt;code&gt;p&lt;/code&gt; es &lt;code&gt;null&lt;/code&gt; , se asignar&amp;aacute; nueva memoria a trav&amp;eacute;s de &lt;code&gt;malloc&lt;/code&gt; . Si &lt;code&gt;p&lt;/code&gt; apunta a una memoria no asignada desde el GC o al interior de un bloque de memoria asignado, no se realiza ninguna operaci&amp;oacute;n y se devuelve un valor nulo.</target>
        </trans-unit>
        <trans-unit id="b756c4e80a3354d029916e71e883d1d288090aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ticksPerSec&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then then &lt;code&gt;TickDuration&lt;/code&gt; failed to get the value of &lt;code&gt;ticksPerSec&lt;/code&gt; on the current system, and &lt;code&gt;TickDuration&lt;/code&gt; is not going to work. That would be highly abnormal though.</source>
          <target state="translated">Si &lt;code&gt;ticksPerSec&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; , entonces &lt;code&gt;TickDuration&lt;/code&gt; no pudo obtener el valor de &lt;code&gt;ticksPerSec&lt;/code&gt; en el sistema actual, y &lt;code&gt;TickDuration&lt;/code&gt; no funcionar&amp;aacute;. Sin embargo, eso ser&amp;iacute;a muy anormal.</target>
        </trans-unit>
        <trans-unit id="0a174cf4ab1d67c6c049d75173bd4c15d10ca6f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeval.tv_sec&lt;/code&gt; is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used for &lt;code&gt;tv_sec&lt;/code&gt;. (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under).</source>
          <target state="translated">Si &lt;code&gt;timeval.tv_sec&lt;/code&gt; es int, y el resultado no puede caber en un int, entonces el valor m&amp;aacute;s cercano que puede mantenerse en 32 bits se usar&amp;aacute; para &lt;code&gt;tv_sec&lt;/code&gt; . (entonces &lt;code&gt;int.max&lt;/code&gt; si se supera e &lt;code&gt;int.min&lt;/code&gt; si se reduce ).</target>
        </trans-unit>
        <trans-unit id="b737bf16441ab6f2f4b4d91936f54afa2de4c527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two objects that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">Si &lt;code&gt;toHash&lt;/code&gt; debe ser siempre el mismo valor cuando &lt;code&gt;opEquals&lt;/code&gt; devuelve verdadero. En otras palabras, dos objetos que se consideran iguales siempre deben tener el mismo valor hash. De lo contrario, se producir&amp;aacute; un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="46b829bd712225872ea6d9fe14e82ebf07db56c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two structs that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">Si &lt;code&gt;toHash&lt;/code&gt; debe ser siempre el mismo valor cuando &lt;code&gt;opEquals&lt;/code&gt; devuelve verdadero. En otras palabras, dos estructuras que se consideran iguales siempre deben tener el mismo valor hash. De lo contrario, se producir&amp;aacute; un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="bdd34bf58210d81d6b36b3924a3e5089f87b29e6" translate="yes" xml:space="preserve">
          <source>If B to A conversion is convariant that requires offseet adjusting, all return statements should be adjusted to return expressions typed A.</source>
          <target state="translated">Si la conversión de B a A es convariante y requiere un ajuste de offset,todas las declaraciones de retorno deben ajustarse a las expresiones de retorno de tipo A.</target>
        </trans-unit>
        <trans-unit id="5f616405142623769cdbbf978f769d6bf8291c51" translate="yes" xml:space="preserve">
          <source>If JSON value is null, then operator initializes it with object and then sets &lt;code&gt;value&lt;/code&gt; for it.</source>
          <target state="translated">Si el valor JSON es nulo, el operador lo inicializa con un objeto y luego establece el &lt;code&gt;value&lt;/code&gt; para &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="b3d334f3b16094aef354285c2c419452a7b589ea" translate="yes" xml:space="preserve">
          <source>If Source is a &lt;code&gt;struct&lt;/code&gt; then wrapping/unwrapping will create a copy; it is not possible to affect the original &lt;code&gt;struct&lt;/code&gt; through the wrapper.</source>
          <target state="translated">Si Source es una &lt;code&gt;struct&lt;/code&gt; entonces envolver / desenvolver crear&amp;aacute; una copia; No es posible afectar la &lt;code&gt;struct&lt;/code&gt; original a trav&amp;eacute;s del contenedor.</target>
        </trans-unit>
        <trans-unit id="2e8ce4614eba95d281d33d622683800da451bb90" translate="yes" xml:space="preserve">
          <source>If Statement</source>
          <target state="translated">Si la declaración</target>
        </trans-unit>
        <trans-unit id="dd4a3f3a81119e68ec01207d19a926cbd1e5f669" translate="yes" xml:space="preserve">
          <source>If Targets has only one entry and Source is a class which explicitly implements it, wrap simply returns src upcasted to &lt;code&gt;Targets[0]&lt;/code&gt;.</source>
          <target state="translated">Si Targets tiene solo una entrada y Source es una clase que la implementa expl&amp;iacute;citamente, wrap simplemente devuelve src a &lt;code&gt;Targets[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">Si un</target>
        </trans-unit>
        <trans-unit id="38354ffb09e774c4e1e6d7b1ae1d349a56902b44" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; is supplied, the fields are initialized by the &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">Si se proporciona un &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; , la sintaxis de &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; inicializa los &lt;i&gt;campos&lt;/i&gt; .</target>
        </trans-unit>
        <trans-unit id="82eb1a8a8a78d51182899822b5022de27e60420b" translate="yes" xml:space="preserve">
          <source>If a and b are both class objects, then the expression is rewritten as:</source>
          <target state="translated">Si a y b son ambos objetos de clase,entonces la expresión se reescribe como:</target>
        </trans-unit>
        <trans-unit id="5e7e375e1c7dad6e65f441c0e60a25b131f8701e" translate="yes" xml:space="preserve">
          <source>If a cast to a floating-point type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get == cast(T) U(get)&lt;/code&gt;. If that is not &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">Si se solicita una &lt;code&gt;onBadCast&lt;/code&gt; a un tipo de punto flotante y &lt;code&gt;Hook&lt;/code&gt; define onBadCast , la conversi&amp;oacute;n se verifica garantizando &lt;code&gt;get == cast(T) U(get)&lt;/code&gt; . Si eso no es &lt;code&gt;true&lt;/code&gt; , se &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="214d150104c62cbd9a8df607ea8c5c4b3837548b" translate="yes" xml:space="preserve">
          <source>If a cast to an integral type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;cast(U) get&lt;/code&gt; are the same arithmetic number. (Note that &lt;code&gt;int(-1)&lt;/code&gt; and &lt;code&gt;uint(1)&lt;/code&gt; are different values arithmetically although they have the same bitwise representation and compare equal by language rules.) If the numbers are not arithmetically equal, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">Si se solicita una &lt;code&gt;onBadCast&lt;/code&gt; a un tipo integral y &lt;code&gt;Hook&lt;/code&gt; define onBadCast , la conversi&amp;oacute;n se verifica asegurando que &lt;code&gt;get&lt;/code&gt; y &lt;code&gt;cast(U) get&lt;/code&gt; sean el mismo n&amp;uacute;mero aritm&amp;eacute;tico. (Tenga en cuenta que &lt;code&gt;int(-1)&lt;/code&gt; y &lt;code&gt;uint(1)&lt;/code&gt; son diferentes valores aritm&amp;eacute;ticamente a pesar de que tienen la misma representaci&amp;oacute;n a nivel de bits y comparan iguales por las reglas del lenguaje.) Si los n&amp;uacute;meros no son aritm&amp;eacute;ticamente iguales, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; se devuelve .</target>
        </trans-unit>
        <trans-unit id="f50b34e635f5b3d69730e335c13e613f658b1407" translate="yes" xml:space="preserve">
          <source>If a choice's return type is void, the choice must throw an exception, unless all the choices are void. In that case, castSwitch itself will return void.</source>
          <target state="translated">Si el tipo de devolución de una elección es nulo,la elección debe lanzar una excepción,a menos que todas las elecciones sean nulas.En ese caso,el propio CastSwitch devolverá el vacío.</target>
        </trans-unit>
        <trans-unit id="fb6d0d046ebbfc4f31bb86cf82620af737d82d69" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:</source>
          <target state="translated">Si el código de un constructor contiene una llamada de constructor delegado,todas las posibles trayectorias de ejecución a través del constructor deben hacer exactamente una llamada de constructor delegado:</target>
        </trans-unit>
        <trans-unit id="74c7db79dd1c4bbec318c1afec835bd55146cddb" translate="yes" xml:space="preserve">
          <source>If a copy constructor is defined, implicit calls to it will be inserted in the following situations:</source>
          <target state="translated">Si se define un constructor de copias,se insertarán llamadas implícitas a él en las siguientes situaciones:</target>
        </trans-unit>
        <trans-unit id="3a4c5302b387be4ef4923c3da45ea70ef8244969" translate="yes" xml:space="preserve">
          <source>If a declaration is followed by a documented unittest, the code in the unittest will be inserted in the &lt;b&gt;example&lt;/b&gt; section of the declaration:</source>
          <target state="translated">Si una declaraci&amp;oacute;n es seguida por una prueba unitaria documentada, el c&amp;oacute;digo en la prueba unitaria se insertar&amp;aacute; en la secci&amp;oacute;n de &lt;b&gt;ejemplo&lt;/b&gt; de la declaraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="994d2a230df4885735f193cf875a7c34425353d8" translate="yes" xml:space="preserve">
          <source>If a declaration starts with a</source>
          <target state="translated">Si una declaración comienza con un</target>
        </trans-unit>
        <trans-unit id="5abfec0c9b70a28afdd54a250553e480e8e7f188" translate="yes" xml:space="preserve">
          <source>If a delegate is passed, the safety and purity of this function are inferred from &lt;code&gt;Dg&lt;/code&gt;'s safety and purity.</source>
          <target state="translated">Si se aprueba un delegado, la seguridad y pureza de esta funci&amp;oacute;n se infieren de la seguridad y pureza de &lt;code&gt;Dg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea319443f8c57e701d411ba01a8cc3309299df11" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument to &lt;code&gt;receive&lt;/code&gt;, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">Si se incluye un delegado que acepta un &lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt; como &amp;uacute;ltimo argumento para &lt;code&gt;receive&lt;/code&gt; , coincidir&amp;aacute; con cualquier mensaje que no haya coincidido con un delegado anterior. Si se env&amp;iacute;a m&amp;aacute;s de un argumento, la &lt;code&gt;Variant&lt;/code&gt; e contendr&amp;aacute; un &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; de todos los valores enviados.</target>
        </trans-unit>
        <trans-unit id="6772ca1fa3a50c56b1e2254d50cd48e0b56364df" translate="yes" xml:space="preserve">
          <source>If a delegating constructor is not called, a call to the base class's default constructor is issued.</source>
          <target state="translated">Si no se llama a un constructor delegado,se llama al constructor por defecto de la clase base.</target>
        </trans-unit>
        <trans-unit id="881137e036e5d861dacc5e49c7e5ec6d46042221" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with diferrent &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">Si una clase derivada anula una funci&amp;oacute;n miembro de clase base con diferentes atributos de &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;funci&amp;oacute;n&lt;/i&gt;&lt;/a&gt; , el compilador compensar&amp;aacute; autom&amp;aacute;ticamente los atributos faltantes.</target>
        </trans-unit>
        <trans-unit id="b01bf1413dae9a84ffd106c13e7efc616299cc07" translate="yes" xml:space="preserve">
          <source>If a documentation comment for a declaration consists only of the identifier &lt;code&gt;ditto&lt;/code&gt; then the documentation comment for the previous declaration at the same declaration scope is applied to this declaration as well.</source>
          <target state="translated">Si un comentario de documentaci&amp;oacute;n para una declaraci&amp;oacute;n consta solo del identificador &lt;code&gt;ditto&lt;/code&gt; entonces el comentario de documentaci&amp;oacute;n para la declaraci&amp;oacute;n anterior en el mismo alcance de declaraci&amp;oacute;n tambi&amp;eacute;n se aplica a esta declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3415ea6dfee5691668c1c8232a3e5910eb9c73a0" translate="yes" xml:space="preserve">
          <source>If a field's type has disabled default construction, then it must be initialized in the constructor.</source>
          <target state="translated">Si el tipo de un campo ha desactivado la construcción por defecto,entonces debe ser inicializado en el constructor.</target>
        </trans-unit>
        <trans-unit id="d8f6fa7fc0afa2680299befa1345222924cf9276" translate="yes" xml:space="preserve">
          <source>If a floating literal has a &lt;b&gt;.&lt;/b&gt; and a type suffix, at least one digit must be in-between:</source>
          <target state="translated">Si un literal flotante tiene un &lt;b&gt;. &lt;/b&gt;y un sufijo de tipo, al menos un d&amp;iacute;gito debe estar en el medio:</target>
        </trans-unit>
        <trans-unit id="3a19adb71ebefd9a28ba0c9b27281e67156dc538" translate="yes" xml:space="preserve">
          <source>If a floating literal is followed by &lt;b&gt;i&lt;/b&gt;, then it is an</source>
          <target state="translated">Si un literal flotante es seguido por &lt;b&gt;i&lt;/b&gt; , entonces es un</target>
        </trans-unit>
        <trans-unit id="8d8575d274fd6277028e0c2b41501d26b560a2c4" translate="yes" xml:space="preserve">
          <source>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes.</source>
          <target state="translated">Si una función intenta probarse a sí misma en cuanto a esos atributos,entonces se infiere que la función no tiene esos atributos.</target>
        </trans-unit>
        <trans-unit id="a4a6cb5bd72ee43c0b82dda81af5fd129c286fde" translate="yes" xml:space="preserve">
          <source>If a function call passes no explicit argument, i.e. it would syntactically use &lt;code&gt;()&lt;/code&gt;, then these parentheses may be omitted, similar to a getter invocation of a &lt;a href=&quot;#property-functions&quot;&gt;property function&lt;/a&gt;.</source>
          <target state="translated">Si una llamada a funci&amp;oacute;n no pasa ning&amp;uacute;n argumento expl&amp;iacute;cito, es decir, usar&amp;iacute;a sint&amp;aacute;cticamente &lt;code&gt;()&lt;/code&gt; , entonces estos par&amp;eacute;ntesis pueden omitirse, de forma similar a una invocaci&amp;oacute;n getter de una &lt;a href=&quot;#property-functions&quot;&gt;funci&amp;oacute;n de propiedad&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7b8dc0678edabe73fefcc44809c2cbac6174ce" translate="yes" xml:space="preserve">
          <source>If a function in a derived class overrides a function from its super class, then only one of the &lt;code&gt;in&lt;/code&gt; contracts of the function and its base functions must be satisfied. Overriding functions then becomes a process of</source>
          <target state="translated">Si una funci&amp;oacute;n en una clase derivada anula una funci&amp;oacute;n de su super clase, entonces s&amp;oacute;lo uno de los &lt;code&gt;in&lt;/code&gt; los contratos de la funci&amp;oacute;n y sus funciones base debe ser satisfecho. Anular funciones se convierte en un proceso de</target>
        </trans-unit>
        <trans-unit id="833166b5c67f31578b3c0dc74c8f4637740cb9ae" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parantheses are required if the returned value is to be called.</source>
          <target state="translated">Si una función devuelve un delegado o un puntero de función,se requieren los paréntesis si se va a llamar al valor devuelto.</target>
        </trans-unit>
        <trans-unit id="a1d31581f409e137dd612d786dd84ed15f076e6f" translate="yes" xml:space="preserve">
          <source>If a function with an untyped parameter is specified, this function is called when the variant contains a type that does not match any other function. This can be used to apply the same function across multiple possible types. Exactly one generic function is allowed.</source>
          <target state="translated">Si se especifica una función con un parámetro no escrito,se llama esta función cuando la variante contiene un tipo que no coincide con ninguna otra función.Esto puede utilizarse para aplicar la misma función a varios tipos posibles.Se permite exactamente una función genérica.</target>
        </trans-unit>
        <trans-unit id="a87b66dd6db50119dfebfdc41112382fe6b81c05" translate="yes" xml:space="preserve">
          <source>If a function without parameters is specified, this function is called when &lt;code&gt;variant&lt;/code&gt; doesn't hold a value. Exactly one parameter-less function is allowed.</source>
          <target state="translated">Si se especifica una funci&amp;oacute;n sin par&amp;aacute;metros, se llama a esta funci&amp;oacute;n cuando la &lt;code&gt;variant&lt;/code&gt; e no tiene un valor. Se permite exactamente una funci&amp;oacute;n sin par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="834aeb00a2af9d1c11ab80f05c9f251ecfe858eb" translate="yes" xml:space="preserve">
          <source>If a legacy boolean returning custom handler is used, &lt;code&gt;false&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.fail&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.pass&lt;/code&gt;. This was the original behavior of the unit testing system.</source>
          <target state="translated">Si se utiliza un controlador personalizado booleano de retorno heredado, &lt;code&gt;false&lt;/code&gt; mapas falsos a &lt;code&gt;UnitTestResult.fail&lt;/code&gt; y &lt;code&gt;true&lt;/code&gt; mapas verdaderos a &lt;code&gt;UnitTestResult.pass&lt;/code&gt; . Este fue el comportamiento original del sistema de prueba de la unidad.</target>
        </trans-unit>
        <trans-unit id="82b2fe9ee0ea82740e7dc777c9a1e9340bcda42d" translate="yes" xml:space="preserve">
          <source>If a library routine cannot handle the Typedef type, you can use the &lt;code&gt;TypedefType&lt;/code&gt; template to extract the type which the Typedef wraps.</source>
          <target state="translated">Si una rutina de biblioteca no puede manejar el tipo Typedef, puede usar la plantilla &lt;code&gt;TypedefType&lt;/code&gt; para extraer el tipo que envuelve Typedef.</target>
        </trans-unit>
        <trans-unit id="4aba4b8ca7c725b8d06f470a62c86a1bda5b271f" translate="yes" xml:space="preserve">
          <source>If a mixin has an</source>
          <target state="translated">Si una mezcla tiene un</target>
        </trans-unit>
        <trans-unit id="016a5428498ce2567043077b67b52a004f09c60b" translate="yes" xml:space="preserve">
          <source>If a module C imports modules A and B, any modifications to B will not silently change code in C that is dependent on A.</source>
          <target state="translated">Si un módulo C importa los módulos A y B,las modificaciones de B no cambiarán silenciosamente el código de C que depende de A.</target>
        </trans-unit>
        <trans-unit id="f84ff68027db236d1e6d7027fe7c21486026d4f8" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Si una clase anidada tiene el atributo &lt;code&gt;static&lt;/code&gt; , entonces no puede acceder a las variables del alcance que son locales a la pila o necesita &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56c79f57d1a50238baec29c9e84fb38c7b1202da" translate="yes" xml:space="preserve">
          <source>If a option is required, not passing it will result in an error</source>
          <target state="translated">Si se requiere una opción,no pasarla resultará en un error</target>
        </trans-unit>
        <trans-unit id="149e6d9194089a56d26c5e902cbd9179de1d63bd" translate="yes" xml:space="preserve">
          <source>If a parameter-less function is specified it is called when either &lt;code&gt;variant&lt;/code&gt; doesn't hold a value or holds a type which isn't handled by the visiting functions.</source>
          <target state="translated">Si se especifica una funci&amp;oacute;n sin par&amp;aacute;metros, se llama cuando cualquiera de las &lt;code&gt;variant&lt;/code&gt; es no tiene un valor o tiene un tipo que las funciones de visita no manejan.</target>
        </trans-unit>
        <trans-unit id="7beb51fb64caa2734e6c937b4e1f891bde552887" translate="yes" xml:space="preserve">
          <source>If a pointer contains a</source>
          <target state="translated">Si un puntero contiene un</target>
        </trans-unit>
        <trans-unit id="54a6b6d625a26fd15e5bed961a528f1a4d8c8d83" translate="yes" xml:space="preserve">
          <source>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter.</source>
          <target state="translated">Si una función de propiedad no tiene parámetros,funciona como un getter.Si tiene exactamente un parámetro,funciona como un &quot;setter&quot;.</target>
        </trans-unit>
        <trans-unit id="bd63b3bb30889f251334a86eb473db6c340d3649" translate="yes" xml:space="preserve">
          <source>If a protocol name is omitted, any protocol will be matched.</source>
          <target state="translated">Si se omite un nombre de protocolo,cualquier protocolo será igualado.</target>
        </trans-unit>
        <trans-unit id="bc8ed891e7a0d7d840793ac113f827ba325b777c" translate="yes" xml:space="preserve">
          <source>If a range returned by &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;asyncBuf&lt;/code&gt; is used as an input to &lt;code&gt;map&lt;/code&gt;, then as an optimization the copying from the output buffer of the first range to the input buffer of the second range is elided, even though the ranges returned by &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;asyncBuf&lt;/code&gt; are non-random access ranges. This means that the &lt;code&gt;bufSize&lt;/code&gt; parameter passed to the current call to &lt;code&gt;map&lt;/code&gt; will be ignored and the size of the buffer will be the buffer size of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">Si un rango devuelto por &lt;code&gt;map&lt;/code&gt; o &lt;code&gt;asyncBuf&lt;/code&gt; se usa como entrada para &lt;code&gt;map&lt;/code&gt; ear , entonces, como optimizaci&amp;oacute;n, se copia la copia del buffer de salida del primer rango al buffer de entrada del segundo rango, aunque los rangos devueltos por &lt;code&gt;map&lt;/code&gt; y &lt;code&gt;asyncBuf&lt;/code&gt; son rangos de acceso no aleatorio. Esto significa que el par&amp;aacute;metro &lt;code&gt;bufSize&lt;/code&gt; pasado a la llamada actual al &lt;code&gt;map&lt;/code&gt; a se ignorar&amp;aacute; y el tama&amp;ntilde;o del b&amp;uacute;fer ser&amp;aacute; el tama&amp;ntilde;o del b&amp;uacute;fer de &lt;code&gt;source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a76bf15d9ef796c131b625f04b8d1b48403d73" translate="yes" xml:space="preserve">
          <source>If a slice operator appears as the left-hand side of an assignment expression, and the type of the right-hand side is the same as the element type of the left-hand side, then the array contents of the left-hand side are set to the right-hand side.</source>
          <target state="translated">Si un operador de rebanada aparece como el lado izquierdo de una expresión de asignación,y el tipo del lado derecho es el mismo que el tipo de elemento del lado izquierdo,entonces el contenido de la matriz del lado izquierdo se establece en el lado derecho.</target>
        </trans-unit>
        <trans-unit id="290e0c5d88ccb110cac619050e0670bb23f215bd" translate="yes" xml:space="preserve">
          <source>If a strongly pure function throws an exception or an error, the assumptions related to memoization and references do not carry to the thrown exception.</source>
          <target state="translated">Si una función fuertemente pura arroja una excepción o un error,los supuestos relacionados con la memorización y las referencias no llevan a la excepción arrojada.</target>
        </trans-unit>
        <trans-unit id="b3a5f4c5b0a3ecfb344535d097fbd6472ec3aaaf" translate="yes" xml:space="preserve">
          <source>If a subexpression of an expression throws an exception, all temporaries created up to the evaluation of that subexpression will be destroyed per the rules above. No destructor calls will be issued for temporaries not yet constructed.</source>
          <target state="translated">Si una subexpresión de una expresión arroja una excepción,todos los temporales creados hasta la evaluación de esa subexpresión serán destruidos según las reglas anteriores.No se emitirán llamadas destructoras para los temporales aún no construidos.</target>
        </trans-unit>
        <trans-unit id="c750c9691a6ca511a5908ab0fae040fe6ae197ae" translate="yes" xml:space="preserve">
          <source>If a template argument matches a specialized template parameter, the argument is mangled with prefix &lt;b&gt;H&lt;/b&gt;.</source>
          <target state="translated">Si un argumento de plantilla coincide con un par&amp;aacute;metro de plantilla especializada, el argumento se ha mezclado con el prefijo &lt;b&gt;H&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="537fb8313b9340d6a7720624890b667ceaf5eabd" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier and if the type or the parameters type of these members include at least all the template parameters then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">Si una plantilla contiene miembros cuyo nombre es el mismo que el identificador de la plantilla y si el tipo o el tipo de parámetros de estos miembros incluyen al menos todos los parámetros de la plantilla,se supone que se hace referencia a estos miembros en una instanciación de la plantilla:</target>
        </trans-unit>
        <trans-unit id="6e940bc97403a68b4bd6fcc2185065a84be4a8ef" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template:</source>
          <target state="translated">Si una plantilla declara exactamente un miembro,y ese miembro es una clase con el mismo nombre que la plantilla:</target>
        </trans-unit>
        <trans-unit id="7228f16c50b7195b2939cb5fdb81b9ec5f38dc52" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a function with the same name as the template, it is a function template declaration. Alternatively, a function template declaration is a function declaration with a &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; immediately preceding the &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Si una plantilla declara exactamente un miembro, y ese miembro es una funci&amp;oacute;n con el mismo nombre que la plantilla, es una declaraci&amp;oacute;n de plantilla de funci&amp;oacute;n. Alternativamente, una declaraci&amp;oacute;n de plantilla de funci&amp;oacute;n es una declaraci&amp;oacute;n de funci&amp;oacute;n con una &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; inmediatamente anterior a los &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Par&amp;aacute;metros&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f02f572072804182d7734d7a928006f6d805f14" translate="yes" xml:space="preserve">
          <source>If a template has a &lt;a href=&quot;#aliasparameters&quot;&gt;template alias parameter&lt;/a&gt;, and is instantiated with a local symbol, the instantiated function will implicitly become nested in order to access runtime data of the given local symbol.</source>
          <target state="translated">Si una plantilla tiene un &lt;a href=&quot;#aliasparameters&quot;&gt;par&amp;aacute;metro de alias de plantilla&lt;/a&gt; y se instancia con un s&amp;iacute;mbolo local, la funci&amp;oacute;n instanciada se anidar&amp;aacute; impl&amp;iacute;citamente para acceder a los datos de tiempo de ejecuci&amp;oacute;n del s&amp;iacute;mbolo local dado.</target>
        </trans-unit>
        <trans-unit id="996438a9f4c88ad530df79801ff8b03c0e475abe" translate="yes" xml:space="preserve">
          <source>If a template is declared in aggregate or function local scope, the instantiated functions will implicitly capture the context of the enclosing scope.</source>
          <target state="translated">Si se declara una plantilla en el ámbito local agregado o de funciones,las funciones instanciadas captarán implícitamente el contexto del ámbito adjunto.</target>
        </trans-unit>
        <trans-unit id="449794f5173b1c91e0c8a9e969999efee1d1266f" translate="yes" xml:space="preserve">
          <source>If a variable has a scope destructor call, return call for it. Otherwise, return NULL.</source>
          <target state="translated">Si una variable tiene una llamada de destructor de alcance,devuelva la llamada.De lo contrario,devuelva NULL.</target>
        </trans-unit>
        <trans-unit id="e7d0ce5000213342db830246324bf60d4a0dcc21" translate="yes" xml:space="preserve">
          <source>If after all the type arguments are examined, there are any type parameters left with no type assigned, they are assigned types corresponding to the template argument in the same position in the</source>
          <target state="translated">Si después de examinar todos los argumentos de tipo,quedan parámetros de tipo sin tipo asignado,se les asignan tipos correspondientes al argumento de plantilla en la misma posición en el</target>
        </trans-unit>
        <trans-unit id="8425958e6e0e9a1c94e548c8eed6685e1c97af18" translate="yes" xml:space="preserve">
          <source>If aliased to the same object or both null =&amp;gt; equal</source>
          <target state="translated">Si tiene alias para el mismo objeto o ambos nulo =&amp;gt; igual</target>
        </trans-unit>
        <trans-unit id="201815c4325a8fddf0539c89b74ba96e4169f933" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">Si un &lt;code&gt;auto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa6bbb7d06b0bd7ec69b77758d95900b4054089" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;enum&lt;/code&gt; is used as type, the random variate is drawn with equal probability from any of the possible values of the enum &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Si un &lt;code&gt;enum&lt;/code&gt; se utiliza como tipo, el valor aleatorio se dibuja con la misma probabilidad de cualquiera de los posibles valores de la enumeraci&amp;oacute;n &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="168c9f0755c4bd4e21cdb3d96a893ad7470eff57" translate="yes" xml:space="preserve">
          <source>If an aggregate declaration defines an &lt;code&gt;opCmp&lt;/code&gt; or &lt;code&gt;opEquals&lt;/code&gt; method, it will take precedence to that of the aliased this member. Note that, unlike an &lt;code&gt;opCmp&lt;/code&gt; method, an &lt;code&gt;opEquals&lt;/code&gt; method is implicitly defined for a &lt;code&gt;struct&lt;/code&gt; declaration if a user defined one isn't provided; this means that if the aliased this member &lt;code&gt;opEquals&lt;/code&gt; is preferred it should be explicitly defined:</source>
          <target state="translated">Si una declaraci&amp;oacute;n agregada define un m&amp;eacute;todo &lt;code&gt;opCmp&lt;/code&gt; u &lt;code&gt;opEquals&lt;/code&gt; , tendr&amp;aacute; prioridad sobre el del miembro con alias. Tenga en cuenta que, a diferencia de un m&amp;eacute;todo &lt;code&gt;opCmp&lt;/code&gt; , un m&amp;eacute;todo &lt;code&gt;opEquals&lt;/code&gt; se define impl&amp;iacute;citamente para una declaraci&amp;oacute;n de &lt;code&gt;struct&lt;/code&gt; si no se proporciona uno definido por el usuario; Esto significa que si se prefiere el alias este miembro &lt;code&gt;opEquals&lt;/code&gt; , debe definirse expl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="2cf56dfdcc6eee095fd25bd060be3e831d6148d4" translate="yes" xml:space="preserve">
          <source>If an append must reallocate a slice with no possibility of extension, then &lt;code&gt;0&lt;/code&gt; is returned. This happens when the slice references a static array, or if another slice references elements past the end of the current slice.</source>
          <target state="translated">Si un anexo debe reasignar un segmento sin posibilidad de extensi&amp;oacute;n, se devuelve &lt;code&gt;0&lt;/code&gt; . Esto sucede cuando el segmento hace referencia a una matriz est&amp;aacute;tica, o si otro segmento hace referencia a elementos m&amp;aacute;s all&amp;aacute; del final del segmento actual.</target>
        </trans-unit>
        <trans-unit id="fbeff861e7616c530bb5c083257a7ef08f727eef" translate="yes" xml:space="preserve">
          <source>If an application needs to do its own processing of whichever arguments &lt;code&gt;getopt&lt;/code&gt; did not understand, it can pass the &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; directive to &lt;code&gt;getopt&lt;/code&gt;:</source>
          <target state="translated">Si una aplicaci&amp;oacute;n necesita hacer su propio procesamiento de cualquier argumento que &lt;code&gt;getopt&lt;/code&gt; no haya entendido, puede pasar la directiva &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; a &lt;code&gt;getopt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eaf53aac4b71af8424769f45a7b82ff0df7d317c" translate="yes" xml:space="preserve">
          <source>If an enum has as a base type one of the types in the left column, it is converted to the type in the right column.</source>
          <target state="translated">Si un enum tiene como tipo base uno de los tipos de la columna izquierda,se convierte en el tipo de la columna derecha.</target>
        </trans-unit>
        <trans-unit id="3c064315a80e4366fd87dbfa8b9a5125e74f88b6" translate="yes" xml:space="preserve">
          <source>If an error occurs during the compilation of your program, the use of overloads and overrides needs to be reexamined in the relevant classes.</source>
          <target state="translated">Si se produce un error durante la compilación de su programa,el uso de sobrecargas y anulaciones debe ser reexaminado en las clases pertinentes.</target>
        </trans-unit>
        <trans-unit id="a2623dd123c39f9f457825f03bd99064fa3431f1" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the</source>
          <target state="translated">Si se plantea una excepción en el</target>
        </trans-unit>
        <trans-unit id="180043ac16b1a016937b09456574733627d6647e" translate="yes" xml:space="preserve">
          <source>If an exception is thrown but it has an empty message, then &lt;code&gt;emptyExceptionMsg&lt;/code&gt; is returned.</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n pero tiene un mensaje vac&amp;iacute;o, se &lt;code&gt;emptyExceptionMsg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb4162f43906e6c9a7e64e7ecdf711ae4fd96612" translate="yes" xml:space="preserve">
          <source>If an identical type to &lt;code&gt;type&lt;/code&gt; is in &lt;code&gt;type.stringtable&lt;/code&gt;, return the latter one. Otherwise, add it to &lt;code&gt;type.stringtable&lt;/code&gt;. Some types don't get merged and are returned as-is.</source>
          <target state="translated">Si un tipo id&amp;eacute;ntico para &lt;code&gt;type&lt;/code&gt; est&amp;aacute; en &lt;code&gt;type.stringtable&lt;/code&gt; , devuelva el &amp;uacute;ltimo. De lo contrario, agr&amp;eacute;guelo a &lt;code&gt;type.stringtable&lt;/code&gt; . Algunos tipos no se fusionan y se devuelven tal cual.</target>
        </trans-unit>
        <trans-unit id="2efd485ddee09f5b6939ce6531c2909633020004" translate="yes" xml:space="preserve">
          <source>If an identity assignment overload is required and does not exist, an identity assignment overload function of the type &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; will be automatically generated.</source>
          <target state="translated">Si se requiere una sobrecarga de asignaci&amp;oacute;n de identidad y no existe, se generar&amp;aacute; autom&amp;aacute;ticamente una funci&amp;oacute;n de sobrecarga de asignaci&amp;oacute;n de identidad del tipo &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5e3f00360d5b8852208ee3415dc3a1a01f6dc8" translate="yes" xml:space="preserve">
          <source>If an implicit conversion is disallowed by the table, an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; may be converted if:</source>
          <target state="translated">Si la tabla no permite una conversi&amp;oacute;n impl&amp;iacute;cita, se puede convertir una &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expresi&amp;oacute;n&lt;/i&gt;&lt;/a&gt; si:</target>
        </trans-unit>
        <trans-unit id="9520036db9c2c3cb7627c2cb880cb288fe8ee7ee" translate="yes" xml:space="preserve">
          <source>If an index expression can be rewritten using &lt;code&gt;opIndexAssign&lt;/code&gt; or &lt;code&gt;opIndexOpAssign&lt;/code&gt;, those are preferred over &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">Si una expresi&amp;oacute;n de &amp;iacute;ndice puede reescribirse usando &lt;code&gt;opIndexAssign&lt;/code&gt; u &lt;code&gt;opIndexOpAssign&lt;/code&gt; , se prefieren a &lt;code&gt;opIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d0247eb6c576e08ded3f7c08dff25cd606da70" translate="yes" xml:space="preserve">
          <source>If an interface has &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; storage class, then all members of the interface are &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt;. This storage class is not inherited.</source>
          <target state="translated">Si una interfaz tiene una clase de almacenamiento &lt;code&gt;const&lt;/code&gt; ante o &lt;code&gt;immutable&lt;/code&gt; , entonces todos los miembros de la interfaz son &lt;code&gt;const&lt;/code&gt; antes o &lt;code&gt;immutable&lt;/code&gt; . Esta clase de almacenamiento no se hereda.</target>
        </trans-unit>
        <trans-unit id="7e7381c9bb35e9f77c152ce0763035229030f128" translate="yes" xml:space="preserve">
          <source>If an option is bound to a numeric type, a number is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Si una opción está vinculada a un tipo numérico,se espera que un número sea la siguiente opción,o justo dentro de la opción separada con un signo &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="e1388310610be9143f93d5757e5dd370de55e952" translate="yes" xml:space="preserve">
          <source>If an option is bound to a string, a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Si una opción está ligada a una cadena,se espera una cadena como la siguiente opción,o justo dentro de la opción separada con un signo &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="cd9d52ae8827e5578c6e463b4801745d426f4b79" translate="yes" xml:space="preserve">
          <source>If an option is bound to an array, a new element is appended to the array each time the option occurs:</source>
          <target state="translated">Si una opción está vinculada a una matriz,se añade un nuevo elemento a la matriz cada vez que se produce la opción:</target>
        </trans-unit>
        <trans-unit id="d7c493c513172131987de31a463653700c8dc123" translate="yes" xml:space="preserve">
          <source>If an option is bound to an associative array, a string of the form &quot;name=value&quot; is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Si una opción está unida a una matriz asociativa,se espera una cadena de la forma &quot;nombre=valor&quot; como la siguiente opción,o justo dentro de la opción separada con un signo &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="b6f632caf5c4044e09e5739104d63549a3fc0c34" translate="yes" xml:space="preserve">
          <source>If an option is bound to an enum, an enum symbol as a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Si una opción está vinculada a un enum,se espera un símbolo enum como cadena como la siguiente opción,o justo dentro de la opción separada con un signo &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="7c32990bfc4d36bb0abf0d415d84bd3e023f0845" translate="yes" xml:space="preserve">
          <source>If an option name has a &quot;+&quot; suffix and is bound to a numeric type, then the option's value tracks the number of times the option occurred on the command line:</source>
          <target state="translated">Si el nombre de una opción tiene un sufijo &quot;+&quot; y está ligado a un tipo numérico,entonces el valor de la opción sigue el número de veces que la opción se produjo en la línea de comandos:</target>
        </trans-unit>
        <trans-unit id="3bc9e305061e747e54d09f33e1d219d952240a58" translate="yes" xml:space="preserve">
          <source>If an option string is followed by another string, this string serves as a description for this option. The &lt;code&gt;getopt&lt;/code&gt; function returns a struct of type &lt;code&gt;GetoptResult&lt;/code&gt;. This return value contains information about all passed options as well a &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; flag indicating whether information about these options was requested. The &lt;code&gt;getopt&lt;/code&gt; function always adds an option for &lt;code&gt;--help|-h&lt;/code&gt; to set the flag if the option is seen on the command line.</source>
          <target state="translated">Si una cadena de opciones es seguida por otra cadena, esta cadena sirve como una descripci&amp;oacute;n para esta opci&amp;oacute;n. La funci&amp;oacute;n &lt;code&gt;getopt&lt;/code&gt; devuelve una estructura de tipo &lt;code&gt;GetoptResult&lt;/code&gt; . Este valor de retorno contiene informaci&amp;oacute;n sobre todas las opciones pasadas, as&amp;iacute; como un &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; que indica si se solicit&amp;oacute; informaci&amp;oacute;n sobre estas opciones. La funci&amp;oacute;n &lt;code&gt;getopt&lt;/code&gt; siempre agrega una opci&amp;oacute;n para &lt;code&gt;--help|-h&lt;/code&gt; para establecer el indicador si la opci&amp;oacute;n se ve en la l&amp;iacute;nea de comando.</target>
        </trans-unit>
        <trans-unit id="cecb4b7cfecf63467f6f4623b6ecf01515e03ef4" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;TaskPool&lt;/code&gt; with non-daemon threads is active, either &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; must be called on it before the program can terminate.</source>
          <target state="translated">Si alg&amp;uacute;n &lt;code&gt;TaskPool&lt;/code&gt; con subprocesos que no son daemon est&amp;aacute; activo, debe &lt;code&gt;stop&lt;/code&gt; o &lt;code&gt;finish&lt;/code&gt; antes de que el programa pueda finalizar.</target>
        </trans-unit>
        <trans-unit id="a14ab7622e0f011a987d4940247d86d91424d5c2" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, the struct default construction is also disabled.</source>
          <target state="translated">Si algún campo tiene deshabilitada la construcción por defecto,la construcción por defecto de la estructura también está deshabilitada.</target>
        </trans-unit>
        <trans-unit id="11956d46948d1d13d7ee53327bbd180ff0d5d12d" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;lead&lt;/code&gt; and &lt;code&gt;vowel&lt;/code&gt; are not a valid hangul jamo of the respective &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; class returns dchar.init.</source>
          <target state="translated">Si alguno de los &lt;code&gt;lead&lt;/code&gt; y &lt;code&gt;vowel&lt;/code&gt; no son un hangul jamo v&amp;aacute;lido de la clase de &lt;a href=&quot;#Character&quot;&gt;personaje&lt;/a&gt; respectiva , devuelve dchar.init.</target>
        </trans-unit>
        <trans-unit id="643424aa2159c0dc971a85e93b28f54bc425b055" translate="yes" xml:space="preserve">
          <source>If any of the arguments in the &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; are a</source>
          <target state="translated">Si alguno de los argumentos en &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; es un</target>
        </trans-unit>
        <trans-unit id="3744bc315bbcad378bdb3ff87a3b9de7d402fea7" translate="yes" xml:space="preserve">
          <source>If any of the checks fail, a compile error will occur.</source>
          <target state="translated">Si alguna de las comprobaciones falla,se producirá un error de compilación.</target>
        </trans-unit>
        <trans-unit id="def10a047da7cb724c42b1f59da46ab76ef31dc6" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in the</source>
          <target state="translated">Si alguna de las claves o valores en el</target>
        </trans-unit>
        <trans-unit id="41bc7edc68b18e54f236d3ac39e824893010bd91" translate="yes" xml:space="preserve">
          <source>If applying the above rules does not result in exactly one type for each template parameter, then it is an error.</source>
          <target state="translated">Si la aplicación de las reglas anteriores no da como resultado exactamente un tipo para cada parámetro de la plantilla,entonces es un error.</target>
        </trans-unit>
        <trans-unit id="a7c844c173ee0a673d9ab2e503851d6c710a834c" translate="yes" xml:space="preserve">
          <source>If assertions are enabled and &lt;code&gt;toRange&lt;/code&gt; has been called, then this WorkerLocalStorage instance is no longer worker-local and an assertion failure will result when calling this method. This is not checked when assertions are disabled for performance reasons.</source>
          <target state="translated">Si las aserciones est&amp;aacute;n habilitadas y se ha llamado a &lt;code&gt;toRange&lt;/code&gt; , entonces esta instancia de WorkerLocalStorage ya no es un trabajador local y se producir&amp;aacute; un error de aserci&amp;oacute;n al llamar a este m&amp;eacute;todo. Esto no se verifica cuando las aserciones est&amp;aacute;n deshabilitadas por razones de rendimiento.</target>
        </trans-unit>
        <trans-unit id="df118ef438600490adb83de4d6beaa35bff251d8" translate="yes" xml:space="preserve">
          <source>If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all input ranges and picking the highest &lt;code&gt;tgt.length&lt;/code&gt;, weight-based ranking elements.</source>
          <target state="translated">Si al menos uno de los rangos es un conjunto m&amp;uacute;ltiple, se tienen en cuenta todas las ocurrencias de un elemento duplicado. El resultado es equivalente a fusionar todos los rangos de entrada y elegir los elementos de clasificaci&amp;oacute;n basados ​​en el peso de &lt;code&gt;tgt.length&lt;/code&gt; m&amp;aacute;s altos .</target>
        </trans-unit>
        <trans-unit id="4519d0d5950e5356f4f13b61a821ffce61eda0b3" translate="yes" xml:space="preserve">
          <source>If authentication or redirections are done then the status will be for the last response received.</source>
          <target state="translated">Si se hace una autenticación o redireccionamiento,el estado será el de la última respuesta recibida.</target>
        </trans-unit>
        <trans-unit id="0a0246e59acc96ca671df31d602e303fc5a3e9ab" translate="yes" xml:space="preserve">
          <source>If blocking argument is true, wait for all worker threads to terminate before returning. This option might be used in applications where task results are never consumed-- e.g. when &lt;code&gt;TaskPool&lt;/code&gt; is employed as a rudimentary scheduler for tasks which communicate by means other than return values.</source>
          <target state="translated">Si el argumento de bloqueo es verdadero, espere a que todos los subprocesos de trabajo finalicen antes de regresar. Esta opci&amp;oacute;n podr&amp;iacute;a usarse en aplicaciones donde los resultados de la tarea nunca se consumen, por ejemplo, cuando &lt;code&gt;TaskPool&lt;/code&gt; se emplea como un programador rudimentario para tareas que se comunican por medios distintos de los valores de retorno.</target>
        </trans-unit>
        <trans-unit id="7479ca1ded9e48be6a8e038bc9b2488efa665f70" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Primary&lt;/code&gt; and &lt;code&gt;Fallback&lt;/code&gt; are stateless, &lt;code&gt;FallbackAllocator&lt;/code&gt; defines a static instance called &lt;code&gt;instance&lt;/code&gt;.</source>
          <target state="translated">Si tanto &lt;code&gt;Primary&lt;/code&gt; como &lt;code&gt;Fallback&lt;/code&gt; no tienen estado, &lt;code&gt;FallbackAllocator&lt;/code&gt; define una instancia est&amp;aacute;tica llamada &lt;code&gt;instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec43df7b50b565bd7b1219f8c1f3ab8b182ffb2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are integers (may be constant-folded), the slice expression can be converted to a static array type &lt;code&gt;T[b - a]&lt;/code&gt;.</source>
          <target state="translated">Si tanto &lt;code&gt;a&lt;/code&gt; como &lt;code&gt;b&lt;/code&gt; son enteros (pueden estar plegados constantemente), la expresi&amp;oacute;n de corte se puede convertir a una matriz est&amp;aacute;tica tipo &lt;code&gt;T[b - a]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0deff799fed4758452aa1b15f9e2a5541bd46d3e" translate="yes" xml:space="preserve">
          <source>If both a template with a sequence parameter and a template without a sequence parameter exactly match a template instantiation, the template without a</source>
          <target state="translated">Si tanto una plantilla con un parámetro de secuencia como una plantilla sin un parámetro de secuencia coinciden exactamente con una instanciación de la plantilla,la plantilla sin un</target>
        </trans-unit>
        <trans-unit id="220f653add85effdd5e512619500f4b49743b534" translate="yes" xml:space="preserve">
          <source>If both allocators are &lt;code&gt;shared&lt;/code&gt;, the &lt;code&gt;Segregator&lt;/code&gt; will also offer &lt;code&gt;shared&lt;/code&gt; methods.</source>
          <target state="translated">Si ambos asignadores son &lt;code&gt;shared&lt;/code&gt; , el &lt;code&gt;Segregator&lt;/code&gt; tambi&amp;eacute;n ofrecer&amp;aacute; m&amp;eacute;todos &lt;code&gt;shared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69639385682c3a994448b82bd2bb7cf46189be9b" translate="yes" xml:space="preserve">
          <source>If both are signed or both are unsigned, the smaller type is converted to the larger.</source>
          <target state="translated">Si ambos están firmados o ambos no lo están,el tipo más pequeño se convierte en el más grande.</target>
        </trans-unit>
        <trans-unit id="05fb2e935ce549269270c5d42145fc9b4f07b7f4" translate="yes" xml:space="preserve">
          <source>If both are the same type, no more conversions are done.</source>
          <target state="translated">Si ambos son del mismo tipo,no se hacen más conversiones.</target>
        </trans-unit>
        <trans-unit id="05dd5c60a4e9b82d4adbecb6f4127f3d732ab860" translate="yes" xml:space="preserve">
          <source>If both arguments are ranges of L-values of the same type then &lt;code&gt;SetSymmetricDifference&lt;/code&gt; will also be a range of L-values of that type.</source>
          <target state="translated">Si ambos argumentos son rangos de valores L del mismo tipo, entonces &lt;code&gt;SetSymmetricDifference&lt;/code&gt; tambi&amp;eacute;n ser&amp;aacute; un rango de valores L de ese tipo.</target>
        </trans-unit>
        <trans-unit id="a1166af836d0ff22ec8996cf90c0ca104ddf9187" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. That is, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; and &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;.</source>
          <target state="translated">Si ambos operandos son de tipos integrales y se produce un desbordamiento o un subflujo en el c&amp;aacute;lculo, se producir&amp;aacute; un ajuste. Es decir, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; y &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88c921254e07ee3d3550bb0c4328e00c73dbba70" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;+&lt;/code&gt;, then it is illegal.</source>
          <target state="translated">Si ambos operandos son punteros y el operador es &lt;code&gt;+&lt;/code&gt; , entonces es ilegal.</target>
        </trans-unit>
        <trans-unit id="d175863c948db7d84910700658bc03bfa12bed2a" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;-&lt;/code&gt;, the pointers are subtracted and the result is divided by the size of the type pointed to by the operands. In this calculation the assumed size of &lt;code&gt;void&lt;/code&gt; is one byte. It is an error if the pointers point to different types. The type of the result is &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">Si ambos operandos son punteros, y el operador es &lt;code&gt;-&lt;/code&gt; , los punteros se restan y el resultado se divide por el tama&amp;ntilde;o del tipo se&amp;ntilde;alado por los operandos. En este c&amp;aacute;lculo, el tama&amp;ntilde;o supuesto de &lt;code&gt;void&lt;/code&gt; es un byte. Es un error si los punteros apuntan a diferentes tipos. El tipo del resultado es &lt;code&gt;ptrdiff_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1abf720abea123f60d5888992d6209534bf4e09" translate="yes" xml:space="preserve">
          <source>If both ranges are finite, then one must be (at least) a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the other an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">Si ambos rangos son finitos, uno debe ser (al menos) un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango directo&lt;/a&gt; y el otro un &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;rango de entrada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb5178f6f33c9b3fe021f6007cd182ded54b74f7" translate="yes" xml:space="preserve">
          <source>If both ranges are infinite, then both must be forward ranges.</source>
          <target state="translated">Si ambos rangos son infinitos,entonces ambos deben ser rangos hacia adelante.</target>
        </trans-unit>
        <trans-unit id="09621590d3975cfd09fe2c0811ba26754a5cdd9d" translate="yes" xml:space="preserve">
          <source>If both ranges are sets (without duplicated elements), the resulting range is going to be a set. If at least one of the ranges is a multiset, the number of occurences of an element &lt;code&gt;x&lt;/code&gt; in the resulting range is &lt;code&gt;abs(a-b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r2&lt;/code&gt;, and &lt;code&gt;abs&lt;/code&gt; is the absolute value.</source>
          <target state="translated">Si ambos rangos son conjuntos (sin elementos duplicados), el rango resultante ser&amp;aacute; un conjunto. Si al menos uno de los rangos es un conjunto m&amp;uacute;ltiple, el n&amp;uacute;mero de ocurrencias de un elemento &lt;code&gt;x&lt;/code&gt; en el rango resultante es &lt;code&gt;abs(a-b)&lt;/code&gt; donde &lt;code&gt;a&lt;/code&gt; es el n&amp;uacute;mero de ocurrencias de &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;r1&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; es el n&amp;uacute;mero de ocurrencias de &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;r2&lt;/code&gt; , y &lt;code&gt;abs&lt;/code&gt; es el valor absoluto.</target>
        </trans-unit>
        <trans-unit id="c3cd520fd113fc0ea9747b7e4b22c4c42d0b39c5" translate="yes" xml:space="preserve">
          <source>If both ranges have a length member, this function is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, this function is &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;).</source>
          <target state="translated">Si ambos rangos tienen un miembro de longitud, esta funci&amp;oacute;n es &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ). De lo contrario, esta funci&amp;oacute;n es &amp;Omicron; ( &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="077a8fbc08834027e3db2ad54352fdf64c6364ae" translate="yes" xml:space="preserve">
          <source>If both x and n are 0, the result is 1. If n is negative, an integer divide error will occur at runtime, regardless of the value of x.</source>
          <target state="translated">Si tanto x como n son 0,el resultado es 1.Si n es negativo,se producirá un error de división de números enteros en tiempo de ejecución,independientemente del valor de x.</target>
        </trans-unit>
        <trans-unit id="d8d58e2935a54be899c1932e2430b1d836d6854b" translate="yes" xml:space="preserve">
          <source>If break is followed by</source>
          <target state="translated">Si la ruptura es seguida por</target>
        </trans-unit>
        <trans-unit id="133ff22691958b87ce955cf38fc2654641e5c95a" translate="yes" xml:space="preserve">
          <source>If class invariant checking is turned on, the class invariant is called at the end of the constructor.</source>
          <target state="translated">Si se activa la comprobación de la invariante de clase,la invariante de clase se llama al final del constructor.</target>
        </trans-unit>
        <trans-unit id="2873dd219021490e067fcdc56ae6ce69a60f4696" translate="yes" xml:space="preserve">
          <source>If code detects an error like &quot;out of memory,&quot; then an Error is thrown with a message saying &quot;Out of memory&quot;. The function call stack is unwound, looking for a handler for the Error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finally blocks&lt;/a&gt; are executed as the stack is unwound. If an error handler is found, execution resumes there. If not, the default Error handler is run, which displays the message and terminates the program.</source>
          <target state="translated">Si el c&amp;oacute;digo detecta un error como &quot;sin memoria&quot;, se genera un error con un mensaje que dice &quot;sin memoria&quot;. La pila de llamadas de funci&amp;oacute;n se desenrolla, buscando un controlador para el error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finalmente, los bloques&lt;/a&gt; se ejecutan cuando la pila se desenrolla. Si se encuentra un controlador de errores, la ejecuci&amp;oacute;n se reanuda all&amp;iacute;. De lo contrario, se ejecuta el controlador de errores predeterminado, que muestra el mensaje y finaliza el programa.</target>
        </trans-unit>
        <trans-unit id="026a3ed1741bfc55e99518c871b70d4250291a91" translate="yes" xml:space="preserve">
          <source>If continue is followed by</source>
          <target state="translated">Si continuar es seguido por</target>
        </trans-unit>
        <trans-unit id="6422eca509193d7e5c40c75cbc0a1df0e38709f1" translate="yes" xml:space="preserve">
          <source>If defined and &lt;code&gt;hookOpCast&lt;/code&gt; is</source>
          <target state="translated">Si se define y &lt;code&gt;hookOpCast&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="5a7e95bb168b15f4a8bcb2b5cf99f8ea675a9dca" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; is used as the default initializer of the payload.</source>
          <target state="translated">Si se define, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; se utiliza como inicializador predeterminado de la carga &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="03019d524f44be31cdffd6208c1acffd47d8953d" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.max!T&lt;/code&gt; is used as the maximum value of the payload.</source>
          <target state="translated">Si se define, &lt;code&gt;Hook.max!T&lt;/code&gt; se usa como el valor m&amp;aacute;ximo de la carga &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="f5bf55bfa3966b60e1868595f8913387e32b50a0" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.min!T&lt;/code&gt; is used as the minimum value of the payload.</source>
          <target state="translated">Si se define, &lt;code&gt;Hook.min!T&lt;/code&gt; se utiliza como el valor m&amp;iacute;nimo de la carga &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="c860109476dd6e83e225430bc70cc535b0742b87" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (donde &lt;code&gt;op&lt;/code&gt; es el s&amp;iacute;mbolo del operador y &lt;code&gt;rhs&lt;/code&gt; es el operando del lado derecho) se reenv&amp;iacute;a incondicionalmente para los operadores binarios &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22acb3135b0d52c02522e9bda0aa4a9ab72a1f15" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;lhs&lt;/code&gt; is the left-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (donde &lt;code&gt;op&lt;/code&gt; es el s&amp;iacute;mbolo del operador y &lt;code&gt;lhs&lt;/code&gt; es el operando del lado izquierdo) se reenv&amp;iacute;a incondicionalmente para los operadores binarios &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f903c768577a0e387a7661822b3ab6e9ea3a27" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; is forwarded to unconditionally when the payload is to be cast to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; se reenv&amp;iacute;a a incondicionalmente cuando la carga &amp;uacute;til es ser echado al tipo &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d39d077b66c222df35757287877d0f5e2f125e3c" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for ordering against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; se reenv&amp;iacute;a incondicionalmente cuando se compara la carga &amp;uacute;til para ordenar contra valores &lt;code&gt;rhs&lt;/code&gt; de tipo integral, coma flotante o booleano.</target>
        </trans-unit>
        <trans-unit id="61710dc38aff3803efddd69b40c8a0d534e524ab" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for equality against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; se reenv&amp;iacute;a incondicionalmente cuando se compara la carga &amp;uacute;til para la igualdad con el valor &lt;code&gt;rhs&lt;/code&gt; de tipo integral, de punto flotante o booleano.</target>
        </trans-unit>
        <trans-unit id="78db295a6db30c78e28bbcb362075d3be4e0b84f" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (donde &lt;code&gt;op&lt;/code&gt; es el s&amp;iacute;mbolo del operador y &lt;code&gt;rhs&lt;/code&gt; es el operando del lado derecho) se reenv&amp;iacute;a incondicionalmente para operadores binarios &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; , y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c14604f1c472b8a4a8bbea3e846c210307c64e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol) is forwarded to for unary operators &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. In addition, for unary operators &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; is called, where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by &lt;code&gt;Checked&lt;/code&gt; so the hook can change it.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (donde &lt;code&gt;op&lt;/code&gt; es el s&amp;iacute;mbolo del operador) se reenv&amp;iacute;a a los operadores unarios &lt;code&gt;-&lt;/code&gt; y &lt;code&gt;~&lt;/code&gt; . Adem&amp;aacute;s, para operadores unarios &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; , se &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; , donde &lt;code&gt;payload&lt;/code&gt; es una referencia al valor envuelto por &lt;code&gt;Checked&lt;/code&gt; para que el hook pueda cambiarlo.</target>
        </trans-unit>
        <trans-unit id="2297e50d0b2beb4cdd48e76ba56a839dcb04ab78" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by Checked) is forwarded to when &lt;code&gt;toHash&lt;/code&gt; is called on a Checked type. Custom hashing can be implemented in a &lt;code&gt;Hook&lt;/code&gt;, otherwise the built-in hashing is used.</source>
          <target state="translated">Si est&amp;aacute; definido, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (donde la &lt;code&gt;payload&lt;/code&gt; es una referencia al valor envuelto por Checked) se reenv&amp;iacute;a cuando se llama a &lt;code&gt;toHash&lt;/code&gt; en un tipo Checked. El hash personalizado se puede implementar en un &lt;code&gt;Hook&lt;/code&gt; , de lo contrario se usa el hash incorporado.</target>
        </trans-unit>
        <trans-unit id="33310de24a417af9692c142b1ec271b4bb06c9e6" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is smaller than the smallest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si se define, se &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (donde &lt;code&gt;value&lt;/code&gt; es el valor asignado) cuando el resultado de operadores binarios &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; , y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; es menor que el valor m&amp;aacute;s peque&amp;ntilde;o representable por &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6931e0e7ba4cd85c003adc62fe48bb16dad0a7" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; is forwarded to for unary operators that overflow but only if &lt;code&gt;hookOpUnary&lt;/code&gt; is not defined. Unary &lt;code&gt;~&lt;/code&gt; does not overflow; unary &lt;code&gt;-&lt;/code&gt; overflows only when the most negative value of a signed type is negated, and the result of the hook call is returned. When the increment or decrement operators overflow, the payload is assigned the result of &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt;. When a binary operator overflows, the result of &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; is returned, but only if &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt;.</source>
          <target state="translated">Si se define, se &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; a los operadores unarios que se desbordan, pero solo si &lt;code&gt;hookOpUnary&lt;/code&gt; no est&amp;aacute; definido. Unary &lt;code&gt;~&lt;/code&gt; no se desborda; unario &lt;code&gt;-&lt;/code&gt; desborda solo cuando se niega el valor m&amp;aacute;s negativo de un tipo firmado y se devuelve el resultado de la llamada de enlace. Cuando los operadores de incremento o decremento se desbordan, la carga &amp;uacute;til se le asigna el resultado de &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; . Cuando un operador binario se desborda, se &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; el resultado de hook.onOverflow! Op (get, rhs) , pero solo si &lt;code&gt;Hook&lt;/code&gt; no define &lt;code&gt;hookOpBinary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="908a2f8c24579c24ba178c54fd857b4b41ae78ef" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is larger than the largest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si se define, se &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (donde &lt;code&gt;value&lt;/code&gt; es el valor asignado) cuando el resultado de operadores binarios &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; , y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; es mayor que el valor m&amp;aacute;s grande que puede representarse por &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d3755f1788c95f9d9709ea3791ec92f2804e77a" translate="yes" xml:space="preserve">
          <source>If e is a SliceExp, constant fold it.</source>
          <target state="translated">Si e es un SliceExp,doblarlo constantemente.</target>
        </trans-unit>
        <trans-unit id="4e157bdef2847bcd47c86d8616eb969d0de41200" translate="yes" xml:space="preserve">
          <source>If e1 is a property function (template), resolve it.</source>
          <target state="translated">Si e1 es una función de propiedad (plantilla),resuélvela.</target>
        </trans-unit>
        <trans-unit id="fe36cf6a431bba3d0f0866cfcc1c8bfbdb70659d" translate="yes" xml:space="preserve">
          <source>If either is null =&amp;gt; non-equal</source>
          <target state="translated">Si cualquiera es nulo =&amp;gt; no igual</target>
        </trans-unit>
        <trans-unit id="51547fe82011becc25f7663a54c1c79b37b3b626" translate="yes" xml:space="preserve">
          <source>If either operand is &lt;code&gt;real&lt;/code&gt;, the other operand is converted to &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">Si cualquiera de los operandos es &lt;code&gt;real&lt;/code&gt; , el otro operando se convierte en &lt;code&gt;real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c828619435ec0d80d0eb291888f4070be2665b9" translate="yes" xml:space="preserve">
          <source>If either operand is a floating point type, the other is implicitly converted to floating point and they are brought to a common type via the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">Si cualquiera de los operandos es un tipo de coma flotante, el otro se convierte impl&amp;iacute;citamente en coma flotante y se llevan a un tipo com&amp;uacute;n a trav&amp;eacute;s de las &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;conversiones aritm&amp;eacute;ticas habituales&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19204c26120415c2143a5e03cf2be7f558db1190" translate="yes" xml:space="preserve">
          <source>If either the second or third expressions are of type &lt;code&gt;void&lt;/code&gt;, then the resulting type is &lt;code&gt;void&lt;/code&gt;. Otherwise, the second and third expressions are implicitly converted to a common type which becomes the result type of the conditional expression.</source>
          <target state="translated">Si la segunda o la tercera expresi&amp;oacute;n son de tipo &lt;code&gt;void&lt;/code&gt; , entonces el tipo resultante es &lt;code&gt;void&lt;/code&gt; . De lo contrario, las expresiones segunda y tercera se convierten impl&amp;iacute;citamente en un tipo com&amp;uacute;n que se convierte en el tipo de resultado de la expresi&amp;oacute;n condicional.</target>
        </trans-unit>
        <trans-unit id="653d0a49e3e776a2dacb4a126f5f7199b157c776" translate="yes" xml:space="preserve">
          <source>If expression can be tested for true or false, returns the modified expression. Otherwise returns ErrorExp.</source>
          <target state="translated">Si la expresión puede ser probada como verdadera o falsa,devuelve la expresión modificada.En caso contrario,devuelve ErrorExp.</target>
        </trans-unit>
        <trans-unit id="b36e87ad6619937152cb1864f5c28a8d82857aaf" translate="yes" xml:space="preserve">
          <source>If expression is shared, check that we can access it. Give error message if not.</source>
          <target state="translated">Si la expresión es compartida,comprueba que podemos acceder a ella.Da un mensaje de error si no es así.</target>
        </trans-unit>
        <trans-unit id="b903eb11d9ca574de1d125b6a0ddd43ec7f26143" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;KeepTerminator&lt;/code&gt; is set to &lt;code&gt;KeepTerminator.yes&lt;/code&gt;, then the delimiter is included in the strings returned.</source>
          <target state="translated">Si el indicador &lt;code&gt;KeepTerminator&lt;/code&gt; se establece en &lt;code&gt;KeepTerminator.yes&lt;/code&gt; , entonces el delimitador se incluye en las cadenas devueltas.</target>
        </trans-unit>
        <trans-unit id="235b8759d68e4d6c00eac4cd7371849cd3084978" translate="yes" xml:space="preserve">
          <source>If found, return list entry that it is, else null.</source>
          <target state="translated">Si se encuentra,devuelva la entrada de la lista que es,si no es nula.</target>
        </trans-unit>
        <trans-unit id="a226618dbb0d64b00416429ba20f88cb6f590b46" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">Si func alguna vez genera un punto de tiempo mayor o igual al &lt;code&gt;front&lt;/code&gt; actual del rango, se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException .</target>
        </trans-unit>
        <trans-unit id="6bcd1b67b2b6132e6574059a063d80b5509091a8" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or less than the &lt;code&gt;begin&lt;/code&gt; of the interval.</source>
          <target state="translated">Si func alguna vez genera un punto de tiempo mayor o igual al &lt;code&gt;front&lt;/code&gt; actual del rango, se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException . El rango estar&amp;aacute; vac&amp;iacute;o y la iteraci&amp;oacute;n completa cuando func genera un punto de tiempo igual o menor que el &lt;code&gt;begin&lt;/code&gt; del intervalo.</target>
        </trans-unit>
        <trans-unit id="eefd5cc7fe1ca2c7b897d183dc4a05399326e46f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">Si func genera un punto de tiempo menor o igual que el &lt;code&gt;front&lt;/code&gt; actual del rango, se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException .</target>
        </trans-unit>
        <trans-unit id="c66509b1e052bea9e9d5481b7761f6c20d3b371f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or beyond the &lt;code&gt;end&lt;/code&gt; of the interval.</source>
          <target state="translated">Si func genera un punto de tiempo menor o igual que el &lt;code&gt;front&lt;/code&gt; actual del rango, se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException . El rango estar&amp;aacute; vac&amp;iacute;o y la iteraci&amp;oacute;n se completar&amp;aacute; cuando func genere un punto de tiempo igual o m&amp;aacute;s all&amp;aacute; del &lt;code&gt;end&lt;/code&gt; del intervalo.</target>
        </trans-unit>
        <trans-unit id="74f0c5b3f5f366de0c8aea12cba32b6bdb7a7e22" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.</source>
          <target state="translated">Si func conserva el estado que cambia como se le llama, a continuaci&amp;oacute;n, algunos algoritmos no funcionan correctamente, ya que el rango es &lt;code&gt;save&lt;/code&gt; habr&amp;aacute; fallado en realidad han estado guardado de la gama. Para evitar tales errores, no pase un delegado que no sea l&amp;oacute;gicamente puro a &lt;code&gt;fwdRange&lt;/code&gt; . Si a func se le da el mismo punto de tiempo con dos llamadas diferentes, debe devolver el mismo resultado las dos veces. Por supuesto, ninguna de las funciones de este m&amp;oacute;dulo tiene este problema, por lo que solo es relevante para los delegados personalizados.</target>
        </trans-unit>
        <trans-unit id="082731789aa3a0c2389877b2540dad5fb393fea2" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.</source>
          <target state="translated">Si func conserva el estado que cambia como se le llama, a continuaci&amp;oacute;n, algunos algoritmos no funcionan correctamente, ya que el rango es &lt;code&gt;save&lt;/code&gt; habr&amp;aacute; fallado en realidad han estado guardado de la gama. Para evitar tales errores, no pase un delegado que no sea l&amp;oacute;gicamente puro a &lt;code&gt;fwdRange&lt;/code&gt; . Si a func se le da el mismo punto de tiempo con dos llamadas diferentes, debe devolver el mismo resultado las dos veces. Por supuesto, ninguna de las funciones de este m&amp;oacute;dulo tiene este problema, por lo que solo es relevante si se crea un delegado personalizado.</target>
        </trans-unit>
        <trans-unit id="811cb1951d7eca66363f0ab4a25ab0f68bd6c804" translate="yes" xml:space="preserve">
          <source>If function a function in a base class, return that base class.</source>
          <target state="translated">Si funciona una función en una clase base,devuelve esa clase base.</target>
        </trans-unit>
        <trans-unit id="3a618122aa9fe1978f9e550b5f42d584977ec33d" translate="yes" xml:space="preserve">
          <source>If in a quoted field any quote by itself, not at the end of a field, will end processing for that field.</source>
          <target state="translated">Si en un campo citado cualquier cita por sí misma,no al final de un campo,terminará el procesamiento para ese campo.</target>
        </trans-unit>
        <trans-unit id="fc45bb57ad39df4d2be393733ec74789f2ef7133" translate="yes" xml:space="preserve">
          <source>If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, it performs a search for the first zero bit in the bitmap and sets it.</source>
          <target state="translated">Si se instancia con &lt;code&gt;No.multiblock&lt;/code&gt; , realiza una b&amp;uacute;squeda del primer bit cero en el mapa de bits y lo establece.</target>
        </trans-unit>
        <trans-unit id="7b0f6cec4d5ea8c58428ba7c40e99097b7cb2322" translate="yes" xml:space="preserve">
          <source>If isNested() returns true, isThis() should return false, unless the function needs a dual-context pointer.</source>
          <target state="translated">Si isNested()devuelve true,isThis()debería devolver false,a menos que la función necesite un puntero de doble contexto.</target>
        </trans-unit>
        <trans-unit id="b4d04375110c3b3230b38eb2d9c5c313ab9a4587" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;false&lt;/code&gt;, then the third expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; , se eval&amp;uacute;a la tercera expresi&amp;oacute;n y su resultado es el resultado de la expresi&amp;oacute;n condicional.</target>
        </trans-unit>
        <trans-unit id="ba0ab9ea37044a2e2b630f8489bf8ed0e516e703" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;true&lt;/code&gt;, then the second expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , se eval&amp;uacute;a la segunda expresi&amp;oacute;n y su resultado es el resultado de la expresi&amp;oacute;n condicional.</target>
        </trans-unit>
        <trans-unit id="828463bf31c6d8c05164e51833a7bd26ece74f35" translate="yes" xml:space="preserve">
          <source>If it is desirable to persist a &lt;code&gt;Unique!T&lt;/code&gt; outside of its original scope, then it can be transferred. The transfer can be explicit, by calling &lt;code&gt;release&lt;/code&gt;, or implicit, when returning Unique from a function. The resource &lt;code&gt;T&lt;/code&gt; can be a polymorphic class object or instance of an interface, in which case Unique behaves polymorphically too.</source>
          <target state="translated">Si es deseable mantener un &lt;code&gt;Unique!T&lt;/code&gt; fuera de su alcance original, entonces puede ser transferido. La transferencia puede ser expl&amp;iacute;cita, llamando a &lt;code&gt;release&lt;/code&gt; , o impl&amp;iacute;cita, cuando se devuelve Unique desde una funci&amp;oacute;n. El recurso &lt;code&gt;T&lt;/code&gt; puede ser un objeto de clase polim&amp;oacute;rfica o una instancia de una interfaz, en cuyo caso Unique tambi&amp;eacute;n se comporta polim&amp;oacute;rficamente.</target>
        </trans-unit>
        <trans-unit id="1a1dc588bc158cc467f4127355a3912b746c621f" translate="yes" xml:space="preserve">
          <source>If just type T is given and no variable v, then the catch clause is still executed.</source>
          <target state="translated">Si sólo se da el tipo T y no se da la variable v,entonces la cláusula de captura sigue ejecutándose.</target>
        </trans-unit>
        <trans-unit id="f71f926a6db933017567619e75df00dc6712f06e" translate="yes" xml:space="preserve">
          <source>If multiple templates with the same</source>
          <target state="translated">Si múltiples plantillas con la misma</target>
        </trans-unit>
        <trans-unit id="35c6c44f6f67de6c4c0a779716275c68fe8b37b2" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;delimiter&lt;/code&gt; is given, then one trailing &lt;code&gt;'\r'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, &lt;code&gt;'\f'&lt;/code&gt;, &lt;code&gt;'\v'&lt;/code&gt;, &lt;a href=&quot;std_uni#lineSep&quot;&gt;&lt;code&gt;std.uni.lineSep&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_uni#paraSep&quot;&gt;&lt;code&gt;std.uni.paraSep&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_uni#nelSep&quot;&gt;&lt;code&gt;std.uni.nelSep&lt;/code&gt;&lt;/a&gt; is removed from the end of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;str&lt;/code&gt; does not end with any of those characters, then it is returned unchanged.</source>
          <target state="translated">Si no se da ning&amp;uacute;n &lt;code&gt;delimiter&lt;/code&gt; , entonces uno &lt;code&gt;'\r'&lt;/code&gt; , &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; , &lt;code&gt;'\f'&lt;/code&gt; , &lt;code&gt;'\v'&lt;/code&gt; , &lt;a href=&quot;std_uni#lineSep&quot;&gt; &lt;code&gt;std.uni.lineSep&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;std_uni#paraSep&quot;&gt; &lt;code&gt;std.uni.paraSep&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;std_uni#nelSep&quot;&gt; &lt;code&gt;std.uni.nelSep&lt;/code&gt; &lt;/a&gt; se elimina del final de &lt;code&gt;str&lt;/code&gt; . Si &lt;code&gt;str&lt;/code&gt; no termina con ninguno de esos caracteres, se devuelve sin cambios.</target>
        </trans-unit>
        <trans-unit id="2b0411e822ff9871e75f5fe6e95c3d0518b1b309" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;needle&lt;/code&gt; is provided, &lt;code&gt;pred(haystack.front)&lt;/code&gt; will be evaluated on each element of the input range.</source>
          <target state="translated">Si no se proporciona ninguna &lt;code&gt;needle&lt;/code&gt; , se evaluar&amp;aacute; &lt;code&gt;pred(haystack.front)&lt;/code&gt; en cada elemento del rango de entrada.</target>
        </trans-unit>
        <trans-unit id="69633a75862efb516486b64d796be076d86f4c19" translate="yes" xml:space="preserve">
          <source>If no call to constructors via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor.</source>
          <target state="translated">Si no aparece una llamada a los constructores a trav&amp;eacute;s de &lt;code&gt;this&lt;/code&gt; o &lt;code&gt;super&lt;/code&gt; en un constructor, y la clase base tiene un constructor, se inserta una llamada a &lt;code&gt;super()&lt;/code&gt; al comienzo del constructor.</target>
        </trans-unit>
        <trans-unit id="08c68d59ef2b4bb11a75a62d44b96024d217f2ea" translate="yes" xml:space="preserve">
          <source>If no catch handlers are there for the errors, then the program gracefully exits through the default error handler with an appropriate message.</source>
          <target state="translated">Si no hay manejadores de captura para los errores,entonces el programa sale con gracia a través del manejador de errores por defecto con un mensaje apropiado.</target>
        </trans-unit>
        <trans-unit id="a3f4b45154d7d5df5948f5742dc5af04d95c91df" translate="yes" xml:space="preserve">
          <source>If no cycles are found, the ctors and tlsctors are replaced with the ones generated by this algorithm to preserve the old incorrect ordering behavior.</source>
          <target state="translated">Si no se encuentran ciclos,los ctors y tlsctors son reemplazados por los generados por este algoritmo para preservar el antiguo comportamiento de ordenamiento incorrecto.</target>
        </trans-unit>
        <trans-unit id="fd69e84bfca07a56902d7641663496f5b667fb84" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread access the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#ChunkInputRange&quot;&gt;&lt;code&gt;ChunkInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">Si no hay datos disponibles y el hilo principal accede al rango, se bloquear&amp;aacute; hasta que los datos est&amp;eacute;n disponibles. Una excepci&amp;oacute;n a esto es el m&amp;eacute;todo de &lt;code&gt;wait(Duration)&lt;/code&gt; en &lt;a href=&quot;#ChunkInputRange&quot;&gt; &lt;code&gt;ChunkInputRange&lt;/code&gt; &lt;/a&gt; . Este m&amp;eacute;todo esperar&amp;aacute; al m&amp;aacute;ximo la duraci&amp;oacute;n especificada y devolver&amp;aacute; verdadero si hay datos disponibles.</target>
        </trans-unit>
        <trans-unit id="b37f49606e8cab3bb492c893e69c1a2e75dd1924" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread accesses the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#LineInputRange&quot;&gt;&lt;code&gt;LineInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">Si no hay datos disponibles y el subproceso principal accede al rango, se bloquear&amp;aacute; hasta que los datos est&amp;eacute;n disponibles. Una excepci&amp;oacute;n a esto es el m&amp;eacute;todo de &lt;code&gt;wait(Duration)&lt;/code&gt; en &lt;a href=&quot;#LineInputRange&quot;&gt; &lt;code&gt;LineInputRange&lt;/code&gt; &lt;/a&gt; . Este m&amp;eacute;todo esperar&amp;aacute; al m&amp;aacute;ximo la duraci&amp;oacute;n especificada y devolver&amp;aacute; verdadero si hay datos disponibles.</target>
        </trans-unit>
        <trans-unit id="dee768fdd957e908ee906de5d9f09ab3f15a2b74" translate="yes" xml:space="preserve">
          <source>If no explicit seed is provided, the first element of each work unit is used as a seed. For the final reduction, the result from the first work unit is used as the seed.</source>
          <target state="translated">Si no se proporciona una semilla explícita,se utiliza como semilla el primer elemento de cada unidad de trabajo.Para la reducción final,se utiliza como semilla el resultado de la primera unidad de trabajo.</target>
        </trans-unit>
        <trans-unit id="b9beba693b6541f5c4a623aa8005a14a8c088860" translate="yes" xml:space="preserve">
          <source>If no function to call is specified, &lt;code&gt;each&lt;/code&gt; defaults to doing nothing but consuming the entire range. &lt;code&gt;r.front&lt;/code&gt; will be evaluated, but that can be avoided by specifying a lambda with a &lt;code&gt;lazy&lt;/code&gt; parameter.</source>
          <target state="translated">Si no se especifica ninguna funci&amp;oacute;n para llamar, &lt;code&gt;each&lt;/code&gt; no hace nada m&amp;aacute;s que consumir todo el rango. se evaluar&amp;aacute; &lt;code&gt;r.front&lt;/code&gt; , pero eso se puede evitar especificando una lambda con un par&amp;aacute;metro &lt;code&gt;lazy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0e9e2df565b7ef14de5d370ee2e7f5508ed495" translate="yes" xml:space="preserve">
          <source>If no needle is provided, the &lt;code&gt;haystack&lt;/code&gt; is advanced as long as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Similarly, the haystack is positioned so as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;haystack.front&lt;/code&gt;.</source>
          <target state="translated">Si no se proporciona ninguna aguja, el &lt;code&gt;haystack&lt;/code&gt; avanza siempre que &lt;code&gt;pred&lt;/code&gt; se eval&amp;uacute;e como &lt;code&gt;true&lt;/code&gt; . Del mismo modo, el pajar se coloca de manera que &lt;code&gt;pred&lt;/code&gt; eval&amp;uacute;a a &lt;code&gt;false&lt;/code&gt; para &lt;code&gt;haystack.front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8015dc4a71527e3287d7f4a1a1531193efdd9ebe" translate="yes" xml:space="preserve">
          <source>If no random number generator is passed to &lt;code&gt;randomCover&lt;/code&gt;, the thread-global RNG rndGen will be used internally.</source>
          <target state="translated">Si no se pasa ning&amp;uacute;n generador de n&amp;uacute;meros aleatorios a &lt;code&gt;randomCover&lt;/code&gt; , el RNG global de subprocesos rndGen se utilizar&amp;aacute; internamente.</target>
        </trans-unit>
        <trans-unit id="ec48dd4e26e9c9b7bb1bba08590ef49f6e8b00b5" translate="yes" xml:space="preserve">
          <source>If no separator is passed, the  predicate &lt;code&gt;isTerminator&lt;/code&gt; decides whether to accept an element of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Si no se pasa ning&amp;uacute;n separador, el predicado &lt;code&gt;isTerminator&lt;/code&gt; decide si acepta un elemento de &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5a9c9c4272e471499a4566ff40a97f218d487f9" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below): 1. Run all unit tests, tracking tests executed and passes. For each that fails, print the stack trace, and continue. 2. If there are no failures, set the summarize flag to false, and the runMain flag to true. 3. If there are failures, set the summarize flag to true, and the runMain flag to false.</source>
          <target state="translated">Si no se registran controladores personalizados de unittest, se ejecuta el siguiente algoritmo (el comportamiento puede verse afectado por el interruptor &lt;code&gt;--DRT-testmode&lt;/code&gt; a continuaci&amp;oacute;n): 1. Ejecute todas las pruebas unitarias, las pruebas de seguimiento ejecutadas y pasa. Para cada uno que falle, imprima el seguimiento de la pila y contin&amp;uacute;e. 2. Si no hay fallas, establezca el indicador de resumen en falso y el indicador runMain en verdadero. 3. Si hay fallas, establezca el indicador de resumen en verdadero y el indicador runMain en falso.</target>
        </trans-unit>
        <trans-unit id="fe70a6ffb1eaff978d001d003d35769a95cf2acb" translate="yes" xml:space="preserve">
          <source>If non-zero, prefix result with 0x (0X).</source>
          <target state="translated">Si no es cero,el resultado del prefijo es 0x (0X).</target>
        </trans-unit>
        <trans-unit id="bb201c468fcb1936a1cc835ca2cb32dd5d97a148" translate="yes" xml:space="preserve">
          <source>If none of the case expressions match, and there is a default statement, the default statement is transferred to.</source>
          <target state="translated">Si ninguna de las expresiones del caso coinciden,y hay una declaración por defecto,la declaración por defecto se transfiere a.</target>
        </trans-unit>
        <trans-unit id="ab5f1042c0495e282ce28b3b52048c3700563975" translate="yes" xml:space="preserve">
          <source>If none of the choice matches, a &lt;code&gt;SwitchError&lt;/code&gt; will be thrown. &lt;code&gt;SwitchError&lt;/code&gt; will also be thrown if not all the choices are void and a void choice was executed without throwing anything.</source>
          <target state="translated">Si ninguna de las opciones coincide, se &lt;code&gt;SwitchError&lt;/code&gt; un SwitchError . &lt;code&gt;SwitchError&lt;/code&gt; tambi&amp;eacute;n se lanzar&amp;aacute; si no todas las opciones son nulas y se ejecut&amp;oacute; una opci&amp;oacute;n nula sin arrojar nada.</target>
        </trans-unit>
        <trans-unit id="3ed3959f15bba3be1a16efa6393b19ce9aeff019" translate="yes" xml:space="preserve">
          <source>If not specified, the</source>
          <target state="translated">Si no se especifica,la</target>
        </trans-unit>
        <trans-unit id="fe9db14bd961ccfeeb8601ee73a6483367ad2a6a" translate="yes" xml:space="preserve">
          <source>If one is a better match than the other, or one compiles and the other does not, the first is selected.</source>
          <target state="translated">Si uno es mejor que el otro,o uno compila y el otro no,se selecciona el primero.</target>
        </trans-unit>
        <trans-unit id="38f309363d54cf09070c11d4dd142dc6d8bfb60d" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a NaN, the other is returned.</source>
          <target state="translated">Si uno de los argumentos es un NaN,el otro es devuelto.</target>
        </trans-unit>
        <trans-unit id="f22c395490cca8ea1c81135fd8838b0c5b0afefa" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the integral can be converted exactly (without approximation) to the floating-point number. This is in order to preserve transitivity of equality: if &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; and &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; then &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt;, in case &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are a mix of integral and floating-point numbers.</source>
          <target state="translated">Si uno de los n&amp;uacute;meros es una integral y el otro es un n&amp;uacute;mero de coma flotante, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; si y solo si la integral se puede convertir exactamente (sin aproximaci&amp;oacute;n) al n&amp;uacute;mero de coma flotante. Esto es para preservar la transitividad de la igualdad: si &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; y &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; luego &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; , en caso de que &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; sean una combinaci&amp;oacute;n de n&amp;uacute;meros integrales y de coma flotante .</target>
        </trans-unit>
        <trans-unit id="47e27965329d106e5c510ac4b7c35d3cf65701ae" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns a floating-point number that is &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; if the floating-point number is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Si uno de los n&amp;uacute;meros es una integral y el otro es un n&amp;uacute;mero de coma flotante, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; devuelve un n&amp;uacute;mero de coma flotante que es &lt;code&gt;-1&lt;/code&gt; si &lt;code&gt;x &amp;lt; y&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; si &lt;code&gt;x == y&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; si &lt;code&gt;x &amp;gt; y&lt;/code&gt; , y &lt;code&gt;NaN&lt;/code&gt; si el n&amp;uacute;mero de coma flotante es &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4188be61c77849339804ae3977d382498bd8812e" translate="yes" xml:space="preserve">
          <source>If one operand is an enum and the other is the base type of that enum, the result is the base type.</source>
          <target state="translated">Si un operando es un enum y el otro es el tipo base de ese enum,el resultado es el tipo base.</target>
        </trans-unit>
        <trans-unit id="422f2e869457e9aec8090f25e67e71da6e5ae6e8" translate="yes" xml:space="preserve">
          <source>If one or both of the operand types is an enum after undergoing the above conversions, the result type is:</source>
          <target state="translated">Si uno o ambos tipos de operandos se enumeran después de someterse a las conversiones anteriores,el tipo de resultado es:</target>
        </trans-unit>
        <trans-unit id="34b4e760890c5916b5f472cf9ec3f9d946f615cd" translate="yes" xml:space="preserve">
          <source>If one or both operands are floating point, then a floating point comparison is performed.</source>
          <target state="translated">Si uno o ambos operandos son de punto flotante,entonces se realiza una comparación de punto flotante.</target>
        </trans-unit>
        <trans-unit id="f34527129f419587a7b124534783120be01591c6" translate="yes" xml:space="preserve">
          <source>If one range is infinite and the other finite, then the finite range must be a forward range, and the infinite range can be an input range.</source>
          <target state="translated">Si un rango es infinito y el otro finito,entonces el rango finito debe ser un rango hacia adelante,y el rango infinito puede ser un rango de entrada.</target>
        </trans-unit>
        <trans-unit id="1493b0ab4b81a5a5d799727a74239f7ced24db39" translate="yes" xml:space="preserve">
          <source>If only one range is offered to &lt;code&gt;Chain&lt;/code&gt; or &lt;code&gt;chain&lt;/code&gt;, the &lt;code&gt;Chain&lt;/code&gt; type exits the picture by aliasing itself directly to that range's type.</source>
          <target state="translated">Si solo se ofrece un rango a &lt;code&gt;Chain&lt;/code&gt; o &lt;code&gt;chain&lt;/code&gt; , el tipo de &lt;code&gt;Chain&lt;/code&gt; sale de la imagen alias&amp;aacute;ndose directamente al tipo de ese rango.</target>
        </trans-unit>
        <trans-unit id="4f4dfc7af6d318725cd2bb6acc7371848e22877c" translate="yes" xml:space="preserve">
          <source>If only one type is passed, then an array of that type. Otherwise, an array of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Si solo se pasa un tipo, entonces una matriz de ese tipo. De lo contrario, una matriz de &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="f80a4ee1709480a885baa729f38d366951608f11" translate="yes" xml:space="preserve">
          <source>If operands are integral types</source>
          <target state="translated">Si los operandos son tipos integrales</target>
        </trans-unit>
        <trans-unit id="c17f6322872f795083ddb63a91c502026d7f7e3d" translate="yes" xml:space="preserve">
          <source>If overlapping is required, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt;&lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Si se requiere superposici&amp;oacute;n, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt; &lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dcfac2e8846ad57a33a3bc26acae8df77dfcdb25" translate="yes" xml:space="preserve">
          <source>If overridding &lt;code&gt;Object.opEquals()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">Si se reemplaza &lt;code&gt;Object.opEquals()&lt;/code&gt; para las clases, la firma de la funci&amp;oacute;n miembro de la clase deber&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="d70cff54f302f2d4a422baa59aebb43764d5cd42" translate="yes" xml:space="preserve">
          <source>If overriding &lt;code&gt;Object.opCmp()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">Si &lt;code&gt;Object.opCmp()&lt;/code&gt; para las clases, la firma de la funci&amp;oacute;n miembro de la clase deber&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="3e09a8be6b9d197eccbe61876283b5ca6720c550" translate="yes" xml:space="preserve">
          <source>If p is null, no operation is performed.</source>
          <target state="translated">Si la p es nula,no se realiza ninguna operación.</target>
        </trans-unit>
        <trans-unit id="352e9b1490dbc9b0a48acbedafe6ae17ff5f3152" translate="yes" xml:space="preserve">
          <source>If paramsym is null a new ScopeDsymbol is used in place of paramsym.</source>
          <target state="translated">Si el parámesis es nulo,se utiliza un nuevo ScopeDsymbol en lugar del parámesis.</target>
        </trans-unit>
        <trans-unit id="0167129cd52bf73eb27d8ebdabfdbade4013fad0" translate="yes" xml:space="preserve">
          <source>If passed in a range of code points, returns a range with equivalent capabilities.</source>
          <target state="translated">Si se pasa en un rango de puntos de código,devuelve un rango con capacidades equivalentes.</target>
        </trans-unit>
        <trans-unit id="15542b3779f094229ad4949cf6c05be1fd8cee3c" translate="yes" xml:space="preserve">
          <source>If pointers to D garbage collector allocated memory are passed to C functions, it's critical to ensure that that memory will not be collected by the garbage collector before the C function is done with it. This is accomplished by:</source>
          <target state="translated">Si los punteros del recolector de basura D asignados a la memoria se pasan a las funciones C,es fundamental asegurar que esa memoria no será recogida por el recolector de basura antes de que la función C termine con ella.Esto se logra mediante:</target>
        </trans-unit>
        <trans-unit id="0dd282293b2dd30b59ba588f24339bbfcbc55f38" translate="yes" xml:space="preserve">
          <source>If pointers to memory allocated on the D garbage collector heap are passed to C++ functions, it's critical to ensure that the referenced memory will not be collected by the D garbage collector before the C++ function is done with it. This is accomplished by:</source>
          <target state="translated">Si los punteros a la memoria asignada en el colector de basura D se pasan a las funciones de C++,es crítico asegurar que la memoria referenciada no será recogida por el colector de basura D antes de que la función de C++se haga con ella.Esto se logra mediante:</target>
        </trans-unit>
        <trans-unit id="0fae4029daa6372cee7e8e40ab986342b94efc26" translate="yes" xml:space="preserve">
          <source>If possible, convert array initializer to associative array initializer.</source>
          <target state="translated">Si es posible,convierta el inicializador de matrices en un inicializador de matrices asociativo.</target>
        </trans-unit>
        <trans-unit id="917024e995f1fa2c71d6754ac363cc3314dc229d" translate="yes" xml:space="preserve">
          <source>If present, the</source>
          <target state="translated">Si está presente,el</target>
        </trans-unit>
        <trans-unit id="0b88da18898e09a28c0b2bdc7b134ad9a375efc5" translate="yes" xml:space="preserve">
          <source>If range is a range of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 encoding.  If range is a range of ranges of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoded strings of each element of the range.  In both cases, the returned &lt;code&gt;Encoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.</source>
          <target state="translated">Si range es un rango de bytes, un &lt;code&gt;Encoder&lt;/code&gt; que itera sobre los bytes de la codificaci&amp;oacute;n Base64 correspondiente. Si rango es un rango de rangos de bytes, un &lt;code&gt;Encoder&lt;/code&gt; que itera sobre las cadenas codificadas Base64 de cada elemento del rango. En ambos casos, el &lt;code&gt;Encoder&lt;/code&gt; devuelto ser&amp;aacute; un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango directo&lt;/a&gt; si el &lt;code&gt;range&lt;/code&gt; dado es al menos un rango directo, de lo contrario ser&amp;aacute; solo un rango de entrada.</target>
        </trans-unit>
        <trans-unit id="8fcc566f870dfdc11f9cf5642881af956a3edafb" translate="yes" xml:space="preserve">
          <source>If range is a range of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 decoding.  If range is a range of ranges of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoded strings corresponding to each element of the range. In this case, the length of each subrange must be a multiple of 4; the returned decoder does not keep track of Base64 decoding state across subrange boundaries.  In both cases, the returned &lt;code&gt;Decoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.  If the input data contains characters not found in the base alphabet of the current Base64 encoding scheme, the returned range may throw a &lt;code&gt;Base64Exception&lt;/code&gt;.</source>
          <target state="translated">Si range es un rango de caracteres, un &lt;code&gt;Decoder&lt;/code&gt; que itera sobre los bytes de la decodificaci&amp;oacute;n Base64 correspondiente. Si rango es un rango de rangos de caracteres, un &lt;code&gt;Decoder&lt;/code&gt; que itera sobre las cadenas decodificadas correspondientes a cada elemento del rango. En este caso, la longitud de cada subrango debe ser un m&amp;uacute;ltiplo de 4; el decodificador devuelto no realiza un seguimiento del estado de decodificaci&amp;oacute;n Base64 a trav&amp;eacute;s de los l&amp;iacute;mites del subrango. En ambos casos, el &lt;code&gt;Decoder&lt;/code&gt; devuelto ser&amp;aacute; un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango directo&lt;/a&gt; si el &lt;code&gt;range&lt;/code&gt; dado es al menos un rango directo, de lo contrario ser&amp;aacute; solo un rango de entrada. Si los datos de entrada contienen caracteres que no se encuentran en el alfabeto base del esquema de codificaci&amp;oacute;n Base64 actual, el rango devuelto puede arrojar un &lt;code&gt;Base64Exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6eb7ddfbf5a47c6c6af2b15e78fb247a252fb4" translate="yes" xml:space="preserve">
          <source>If same exact type =&amp;gt; one call to method opEquals</source>
          <target state="translated">Si el mismo tipo exacto =&amp;gt; una llamada al m&amp;eacute;todo opEquals</target>
        </trans-unit>
        <trans-unit id="89afd532fed79af758875995d860db76e2e127dd" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately.</source>
          <target state="translated">Si se establece en tiempo de ejecuci&amp;oacute;n, &lt;code&gt;min&lt;/code&gt; y / o &lt;code&gt;max&lt;/code&gt; deben inicializarse adecuadamente.</target>
        </trans-unit>
        <trans-unit id="7d613cefcf14fab9fa1cdf592c4b64df5fd4a02e" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately. The block must have been allocated with this freelist, and no dynamic changing of &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; is allowed to occur between allocation and deallocation.</source>
          <target state="translated">Si se establece en tiempo de ejecuci&amp;oacute;n, &lt;code&gt;min&lt;/code&gt; y / o &lt;code&gt;max&lt;/code&gt; deben inicializarse adecuadamente. El bloque debe haber sido asignado con esta lista libre, y no se permite ning&amp;uacute;n cambio din&amp;aacute;mico de &lt;code&gt;min&lt;/code&gt; o &lt;code&gt;max&lt;/code&gt; entre la asignaci&amp;oacute;n y la desasignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="12dba39acb6108d02380b6b46f58548fdd12a457" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AllowDayOverflow.no&lt;/code&gt;, then day overflow is not allowed.</source>
          <target state="translated">Si se establece en &lt;code&gt;AllowDayOverflow.no&lt;/code&gt; , no se permite el desbordamiento del d&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="0c05e2e8281e59d8e307dc66be3d2cc276d8fa30" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the StopWatch is not started when it is constructed.</source>
          <target state="translated">Si se establece en &lt;code&gt;AutoStart.no&lt;/code&gt; , el StopWatch no se inicia cuando se construye.</target>
        </trans-unit>
        <trans-unit id="d6add4cf35e8c50b2af6d41b382ebe3f7e3e974a" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the stopwatch is not started when it is constructed.</source>
          <target state="translated">Si se establece en &lt;code&gt;AutoStart.no&lt;/code&gt; , el cron&amp;oacute;metro no se inicia cuando se construye.</target>
        </trans-unit>
        <trans-unit id="e084739a519921a28023083912a24037cae39c78" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;CheckDns.no&lt;/code&gt;, isEmail does not perform DNS checking.</source>
          <target state="translated">Si se establece en &lt;code&gt;CheckDns.no&lt;/code&gt; , isEmail no realiza la comprobaci&amp;oacute;n de DNS.</target>
        </trans-unit>
        <trans-unit id="0e1f47a96e002fe723252c695ba57f0bd6e6ab0f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;OpenRight.yes&lt;/code&gt;, then the interval is open to the right (last element is not included).</source>
          <target state="translated">Si se establece en &lt;code&gt;OpenRight.yes&lt;/code&gt; , entonces el intervalo est&amp;aacute; abierto a la derecha (el &amp;uacute;ltimo elemento no est&amp;aacute; incluido).</target>
        </trans-unit>
        <trans-unit id="37becabb79a088b28ac5682f3e5ecf44b42c3e44" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;PopFirst.no&lt;/code&gt;, then popFront is not called before returning the range.</source>
          <target state="translated">Si se establece en &lt;code&gt;PopFirst.no&lt;/code&gt; , no se llama a popFront antes de devolver el rango.</target>
        </trans-unit>
        <trans-unit id="c46457e61c98538473682050d8870e6910707094" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;SortOutput.no&lt;/code&gt;, the output should not be sorted.</source>
          <target state="translated">Si se establece en &lt;code&gt;SortOutput.no&lt;/code&gt; , la salida no se debe ordenar.</target>
        </trans-unit>
        <trans-unit id="00965390f3dcb757da046e66cf3e12ece6325eda" translate="yes" xml:space="preserve">
          <source>If set, 0 is the only allowed &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt; IEEE754 denormalized&lt;/a&gt; number. Requires allowDenorm and storeNormalized.</source>
          <target state="translated">Si se establece, 0 es el &amp;uacute;nico n&amp;uacute;mero &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt;desnormalizado IEEE754&lt;/a&gt; permitido . Requiere allowDenorm y storeNormalized.</target>
        </trans-unit>
        <trans-unit id="61485b68856bc9bc475231ad8439460508956a5d" translate="yes" xml:space="preserve">
          <source>If set, select an exponent bias such that max_exp = 1. i.e. so that the maximum value is &amp;gt;= 1.0 and &amp;lt; 2.0. Ignored if the exponent bias is manually specified.</source>
          <target state="translated">Si se establece, seleccione un sesgo de exponente tal que max_exp = 1. es decir, para que el valor m&amp;aacute;ximo sea&amp;gt; = 1.0 y &amp;lt;2.0. Ignorado si el sesgo del exponente se especifica manualmente.</target>
        </trans-unit>
        <trans-unit id="b15a8a24ac3c0abdda604fa6be697872fed5e457" translate="yes" xml:space="preserve">
          <source>If set, unsigned custom floats are assumed to be negative.</source>
          <target state="translated">Si se fijan,se supone que los flotadores personalizados no firmados son negativos.</target>
        </trans-unit>
        <trans-unit id="96c1d18878474b954f19c1048ca19bc4cc441ff0" translate="yes" xml:space="preserve">
          <source>If size dependencies are inevitable, put a &lt;code&gt;static assert&lt;/code&gt; in the code to verify it:</source>
          <target state="translated">Si las dependencias de tama&amp;ntilde;o son inevitables, ponga una &lt;code&gt;static assert&lt;/code&gt; en el c&amp;oacute;digo para verificarlo:</target>
        </trans-unit>
        <trans-unit id="c4932da89fb63071147ad73f57504dc48f8f86d2" translate="yes" xml:space="preserve">
          <source>If some of these fields is not NULL, it is a pointer to b_data.</source>
          <target state="translated">Si alguno de estos campos no es NULL,es un puntero a b_data.</target>
        </trans-unit>
        <trans-unit id="bf8032a0e0aff5e21ec9404228bec256c45b8757" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself and doesn't define opPostMove, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">Si la fuente tiene punteros internos que apuntan a sí misma y no define el opPostMove,no puede ser movida,y desencadenará un fallo de afirmación.</target>
        </trans-unit>
        <trans-unit id="c4372423a2292ca511a5a4c383dba5ab95bc4f7d" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">Si la fuente tiene punteros internos que apuntan a sí misma,no puede ser movida,y desencadenará un fallo de afirmación.</target>
        </trans-unit>
        <trans-unit id="b61714985a37455e4a9923539bc1db8640864a65" translate="yes" xml:space="preserve">
          <source>If splitting a string on whitespace and token compression is desired, consider using &lt;code&gt;splitter&lt;/code&gt; without specifying a separator.</source>
          <target state="translated">Si se desea dividir una cadena en espacios en blanco y compresi&amp;oacute;n de token, considere usar un &lt;code&gt;splitter&lt;/code&gt; sin especificar un separador.</target>
        </trans-unit>
        <trans-unit id="05b6ffe797342cf0d1028469f63301e251d90fab" translate="yes" xml:space="preserve">
          <source>If splitting of data transfer is enabled this callback is called after download of an individual chunk finished. Note! After this callback was set then it have to be called FOR ALL chunks. Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC. This is the reason why we don't need &quot;transfer_info&quot; parameter in this callback and we are not interested in &quot;remains&quot; parameter too.</source>
          <target state="translated">Si la división de la transferencia de datos está habilitada,esta llamada se llama después de que la descarga de un trozo individual haya terminado.¡Atención! Después de que esta devolución de llamada se ha establecido,entonces tiene que ser llamada PARA TODOS los trozos.Incluso si la descarga de este trozo fue omitida en CHUNK_BGN_FUNC.Esta es la razón por la que no necesitamos el parámetro &quot;transfer_info&quot; en esta devolución de llamada y no estamos interesados en el parámetro &quot;remains&quot; también.</target>
        </trans-unit>
        <trans-unit id="42671fc7da4232343c7b0b928fc5d03d90a644e7" translate="yes" xml:space="preserve">
          <source>If statements provide simple conditional execution of statements.</source>
          <target state="translated">Si las declaraciones proporcionan una simple ejecución condicional de las declaraciones.</target>
        </trans-unit>
        <trans-unit id="9c00c0869eed3767fe39aeae02ecce87d06c6f2e" translate="yes" xml:space="preserve">
          <source>If struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">Si el constructor de la estructura est&amp;aacute; anotado con &lt;code&gt;@disable&lt;/code&gt; y tiene una Lista de &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;par&amp;aacute;metros&lt;/i&gt;&lt;/a&gt; vac&amp;iacute;a , la estructura ha desactivado la construcci&amp;oacute;n predeterminada. La &amp;uacute;nica forma en que se puede construir es mediante una llamada a otro constructor que no est&amp;eacute; vac&amp;iacute;o</target>
        </trans-unit>
        <trans-unit id="944569416617efaa7082cf853e519ff0670f8407" translate="yes" xml:space="preserve">
          <source>If struct invariant checking is turned on, the struct invariant is called at the end of the constructor.</source>
          <target state="translated">Si se activa la comprobación de la invariante estructural,la invariante estructural se llama al final del constructor.</target>
        </trans-unit>
        <trans-unit id="d7768f4c2da4924ba7acf617ca9aea18a8c9c30c" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opCmp&lt;/code&gt; member function, it should have the following form:</source>
          <target state="translated">Si las estructuras declaran una funci&amp;oacute;n miembro &lt;code&gt;opCmp&lt;/code&gt; , deber&amp;iacute;a tener la siguiente forma:</target>
        </trans-unit>
        <trans-unit id="3992d8b7bb5105984cffe3cb78e47194ffe3ff8f" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opEquals&lt;/code&gt; member function for the identity comparison, it could have several forms, such as:</source>
          <target state="translated">Si las estructuras declaran una funci&amp;oacute;n miembro &lt;code&gt;opEquals&lt;/code&gt; para la comparaci&amp;oacute;n de identidad, podr&amp;iacute;a tener varias formas, como:</target>
        </trans-unit>
        <trans-unit id="a998ede0b415c72a4f5c3800b4d3a122980f04c1" translate="yes" xml:space="preserve">
          <source>If such a match occurs, the inout is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied.</source>
          <target state="translated">Si se produce tal coincidencia,el inout se considera el calificador común de los calificadores coincidentes.Si existen más de dos parámetros,el cálculo del calificador común se aplica de forma recursiva.</target>
        </trans-unit>
        <trans-unit id="b30b7b06cd1e2f9ae926af9377511bb1cde4d9ab" translate="yes" xml:space="preserve">
          <source>If such an</source>
          <target state="translated">Si tal</target>
        </trans-unit>
        <trans-unit id="a7624c537a3b1ba34be043fd5ddb463081b0a9fb" translate="yes" xml:space="preserve">
          <source>If template type parameters match the literal expressions on function arguments, the deduced types may consider narrowing conversions of them.</source>
          <target state="translated">Si los parámetros del tipo de plantilla coinciden con las expresiones literales de los argumentos de la función,los tipos deducidos pueden considerar la posibilidad de reducir las conversiones de los mismos.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">Si el</target>
        </trans-unit>
        <trans-unit id="47a53d62849ea833a758681edda290d5ad91413e" translate="yes" xml:space="preserve">
          <source>If the .d source file starts with the string &quot;Ddoc&quot; then it is treated as general purpose documentation, not as a D code source file. From immediately after the &quot;Ddoc&quot; string to the end of the file or any &quot;Macros:&quot; section forms the document. No automatic highlighting is done to that text, other than highlighting of D code embedded between lines delineated with --- lines. Only macro processing is done.</source>
          <target state="translated">Si el archivo fuente .d comienza con la cadena &quot;Ddoc&quot; entonces se trata como documentación de propósito general,no como un archivo fuente de código D.Desde inmediatamente después de la cadena &quot;Ddoc&quot; hasta el final del archivo o cualquier sección &quot;Macros:&quot; forma el documento.No se hace ningún resaltado automático a ese texto,excepto el resaltado del código D incrustado entre líneas delineadas con líneas ---.Sólo se realiza el procesamiento de macros.</target>
        </trans-unit>
        <trans-unit id="e8532e48c96c60a7608facfeb4a22eb5b3d9e1d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condition&lt;/i&gt;&lt;/a&gt; is satisfied, then the following</source>
          <target state="translated">Si se cumple la &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condici&amp;oacute;n&lt;/i&gt;&lt;/a&gt; , entonces lo siguiente</target>
        </trans-unit>
        <trans-unit id="e2fc51761f652cbfa928ace68e58f12bef9531f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Config.newEnv&quot;&gt;&lt;code&gt;Config.newEnv&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;config&lt;/code&gt;, the child process will</source>
          <target state="translated">Si el indicador &lt;a href=&quot;#Config.newEnv&quot;&gt; &lt;code&gt;Config.newEnv&lt;/code&gt; &lt;/a&gt; est&amp;aacute; configurado en &lt;code&gt;config&lt;/code&gt; , el proceso hijo</target>
        </trans-unit>
        <trans-unit id="43745bb1dee3dc73e7455be8ec08aff260e3ec47" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; is one token long, the parentheses can be omitted:</source>
          <target state="translated">Si &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; es un token, los par&amp;eacute;ntesis pueden omitirse:</target>
        </trans-unit>
        <trans-unit id="2d0280ee3bb99762171b658bd8c55f327440c8eb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">Si la &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; est&amp;aacute; vac&amp;iacute;a, la instancia de estructura se inicializa por defecto.</target>
        </trans-unit>
        <trans-unit id="2d70e00070ad7d208c2b59d3486718a575bd6f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">Si el objeto &lt;code&gt;BitmappedBlock&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o (no tiene una asignaci&amp;oacute;n activa), asigna toda la memoria dentro y le devuelve un segmento. De lo contrario, devuelve &lt;code&gt;null&lt;/code&gt; (es decir, no se intenta asignar el bloque m&amp;aacute;s grande disponible).</target>
        </trans-unit>
        <trans-unit id="f5b1d7f6d0725050ed31d8d5e2a2f42a77b9308e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; is managing the &lt;code&gt;File&lt;/code&gt; it logs to, this method will return a reference to this File.</source>
          <target state="translated">Si &lt;code&gt;FileLogger&lt;/code&gt; est&amp;aacute; administrando el &lt;code&gt;File&lt;/code&gt; se registra, este m&amp;eacute;todo devolver&amp;aacute; una referencia a este archivo.</target>
        </trans-unit>
        <trans-unit id="e82d2c358fbac5f6db431228cfdc4ab90afaecba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; was constructed with a filename, this method returns this filename. Otherwise an empty &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">Si el &lt;code&gt;FileLogger&lt;/code&gt; se construy&amp;oacute; con un nombre de archivo, este m&amp;eacute;todo devuelve este nombre de archivo. De lo contrario, se devuelve una &lt;code&gt;string&lt;/code&gt; vac&amp;iacute;a .</target>
        </trans-unit>
        <trans-unit id="09e9a0c0fb2463234ac2c4886cea6f7201a979f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">Si el objeto &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o (no tiene asignaci&amp;oacute;n activa), asigna toda la memoria dentro y le devuelve un segmento. De lo contrario, devuelve &lt;code&gt;null&lt;/code&gt; (es decir, no se intenta asignar el bloque m&amp;aacute;s grande disponible).</target>
        </trans-unit>
        <trans-unit id="a85af50c42d4408aee171ffd99bd37d80c84bfad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, busy spin until it's done, then return the return value. If it threw an exception, rethrow that exception.</source>
          <target state="translated">Si la &lt;code&gt;Task&lt;/code&gt; a&amp;uacute;n no se ha iniciado, ejec&amp;uacute;tela en el hilo actual. Si est&amp;aacute; hecho, devuelva su valor de retorno, si lo hay. Si est&amp;aacute; en progreso, gire ocupado hasta que termine, luego devuelva el valor de retorno. Si arroj&amp;oacute; una excepci&amp;oacute;n, vuelva a lanzar esa excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1bd6a82f193fead01ba830becd3c29303a62f4f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, wait on a condition variable. If it threw an exception, rethrow that exception.</source>
          <target state="translated">Si la &lt;code&gt;Task&lt;/code&gt; a&amp;uacute;n no se ha iniciado, ejec&amp;uacute;tela en el hilo actual. Si est&amp;aacute; hecho, devuelva su valor de retorno, si lo hay. Si est&amp;aacute; en progreso, espere una variable de condici&amp;oacute;n. Si arroj&amp;oacute; una excepci&amp;oacute;n, vuelva a lanzar esa excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9e212700918e7fcce26dacfc8ea0fc78cc9f1eec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an (associative) array, returns the length of that array. Otherwise, throws an exception.</source>
          <target state="translated">Si la &lt;code&gt;VariantN&lt;/code&gt; contiene una matriz (asociativa), devuelve la longitud de esa matriz. De lo contrario, lanza una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="aaf923f5ee1964878af77ace59cc74c4aeed3ea4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an array, applies &lt;code&gt;dg&lt;/code&gt; to each element of the array in turn. Otherwise, throws an exception.</source>
          <target state="translated">Si la &lt;code&gt;VariantN&lt;/code&gt; contiene una matriz, aplica &lt;code&gt;dg&lt;/code&gt; a cada elemento de la matriz a su vez. De lo contrario, lanza una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8cc269de3091c4d2c19acd44245d56ff558f7c59" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; object holds a value of the</source>
          <target state="translated">Si el objeto &lt;code&gt;VariantN&lt;/code&gt; tiene un valor de</target>
        </trans-unit>
        <trans-unit id="4b1509a50bbf3491d84d8a56c0c8990227dbda5d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;[ ]&lt;/code&gt; form is used, the slice is of the entire array.</source>
          <target state="translated">Si se usa el formulario &lt;code&gt;[ ]&lt;/code&gt; , el segmento es de toda la matriz.</target>
        </trans-unit>
        <trans-unit id="cc574f8cb39cc53c71da6e74a5ec0da4813bcc04" translate="yes" xml:space="preserve">
          <source>If the CURLOPT_INFILE is used, this can be used to inform libcurl about how large the file being sent really is. That allows better error checking and better verifies that the upload was successful. -1 means unknown size.</source>
          <target state="translated">Si se utiliza el CURLOPT_INFILE,éste puede ser utilizado para informar a libcurl sobre el tamaño real del archivo que se está enviando.Eso permite una mejor comprobación de errores y verifica mejor que la subida fue exitosa.-1 significa tamaño desconocido.</target>
        </trans-unit>
        <trans-unit id="05e890b0ac7f150cc9383bbef3319acbe1eb47b0" translate="yes" xml:space="preserve">
          <source>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match.</source>
          <target state="translated">Si el UDA es un tipo,entonces cualquier UDA del mismo tipo en el símbolo coincidirá.Si el UDA es una plantilla para un tipo,entonces cualquier UDA que sea una instanciación de esa plantilla coincidirá.Y si el UDA es un valor,entonces cualquier UDA del símbolo que sea igual a ese valor coincidirá.</target>
        </trans-unit>
        <trans-unit id="d6829c7076e9b081aaeb04fb4efe46caee211bea" translate="yes" xml:space="preserve">
          <source>If the [EBP] is omitted, it is assumed for local variables. If &lt;code&gt;naked&lt;/code&gt; is used, this no longer holds.</source>
          <target state="translated">Si se omite el [EBP], se supone para las variables locales. Si se usa &lt;code&gt;naked&lt;/code&gt; , esto ya no es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="1517a4666732a9b97017b3d1661df1ab091b7335" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a sequence, there can be one or two iteration symbols declared. If one, then the symbol is an</source>
          <target state="translated">Si la expresión agregada es una secuencia,puede haber uno o dos símbolos de iteración declarados.Si uno,entonces el símbolo es un</target>
        </trans-unit>
        <trans-unit id="d74660278291ee85d1999a22558014f3ea28fb7a" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a static or dynamic array of &lt;code&gt;char&lt;/code&gt;s, &lt;code&gt;wchar&lt;/code&gt;s, or &lt;code&gt;dchar&lt;/code&gt;s, then the</source>
          <target state="translated">Si la expresi&amp;oacute;n agregada es una matriz est&amp;aacute;tica o din&amp;aacute;mica de &lt;code&gt;char&lt;/code&gt; s, &lt;code&gt;wchar&lt;/code&gt; s o &lt;code&gt;dchar&lt;/code&gt; s, entonces el</target>
        </trans-unit>
        <trans-unit id="cbeacb125fa68a379271d564591b63d8e90e22ef" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, but the &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt;, or &lt;code&gt;opApplyReverse&lt;/code&gt;&lt;code&gt;foreach_reverse&lt;/code&gt; do not exist, then iteration over struct and class objects can be done with range primitives. For &lt;code&gt;foreach&lt;/code&gt;, this means the following properties and methods must be defined:</source>
          <target state="translated">Si la expresi&amp;oacute;n agregada es una estructura o un objeto de clase, pero &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt; u &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;code&gt;foreach_reverse&lt;/code&gt; no existen, entonces la iteraci&amp;oacute;n sobre los objetos struct y class se puede hacer con primitivas de rango. Para &lt;code&gt;foreach&lt;/code&gt; , esto significa que se deben definir las siguientes propiedades y m&amp;eacute;todos:</target>
        </trans-unit>
        <trans-unit id="2fc73ce3aaae537f6f799c049d4ae92b1b9bca9f" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, the &lt;code&gt;foreach&lt;/code&gt; is defined by the special &lt;span id=&quot;opApply&quot;&gt;&lt;code&gt;opApply&lt;/code&gt;&lt;/span&gt; member function, and the &lt;code&gt;foreach_reverse&lt;/code&gt; behavior is defined by the special &lt;span id=&quot;opApplyReverse&quot;&gt;&lt;code&gt;opApplyReverse&lt;/code&gt;&lt;/span&gt; member function. These functions have the type:</source>
          <target state="translated">Si la expresi&amp;oacute;n agregada es una estructura o un objeto de clase, el &lt;code&gt;foreach&lt;/code&gt; est&amp;aacute; definido por la funci&amp;oacute;n especial del miembro &lt;span id=&quot;opApply&quot;&gt; &lt;code&gt;opApply&lt;/code&gt; &lt;/span&gt; , y el comportamiento &lt;code&gt;foreach_reverse&lt;/code&gt; est&amp;aacute; definido por la funci&amp;oacute;n especial del miembro &lt;span id=&quot;opApplyReverse&quot;&gt; &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;/span&gt; . Estas funciones tienen el tipo:</target>
        </trans-unit>
        <trans-unit id="a964bd4ba66b1238ba3df838bc73bf80b6db0380" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is an associative array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">Si la expresión agregada es un conjunto asociativo,puede haber una o dos variables declaradas.Si una,entonces se dice que la variable es la</target>
        </trans-unit>
        <trans-unit id="28f986b7b478a6b80712dcbe7082b7d096f58800" translate="yes" xml:space="preserve">
          <source>If the aggregate is a static or dynamic array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">Si el agregado es un conjunto estático o dinámico,puede haber una o dos variables declaradas.Si una,entonces se dice que la variable es la</target>
        </trans-unit>
        <trans-unit id="dae323352e29801474e63b5dca9b04c0df39a8b3" translate="yes" xml:space="preserve">
          <source>If the argument is a CommaExp, set a flag to prevent deprecation messages</source>
          <target state="translated">Si el argumento es un CommaExp,ponga una bandera para evitar los mensajes de depreciación</target>
        </trans-unit>
        <trans-unit id="fd923c5e6b5ba5db493474258e601c811cb53b07" translate="yes" xml:space="preserve">
          <source>If the argument is omitted, it means default construction of the scalar type:</source>
          <target state="translated">Si se omite el argumento,significa la construcción por defecto del tipo escalar:</target>
        </trans-unit>
        <trans-unit id="c2b4ef88a634d75ab4162e14992b099e340c974e" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are abstract classes, or expressions that are typed as abstract classes, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Si los argumentos son todos tipos que son clases abstractas o expresiones que se escriben como clases abstractas, entonces se devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, se devuelve &lt;code&gt;false&lt;/code&gt; . Si no hay argumentos, se devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="870a7ff26a7a40d5a235f7261d71e7076bce3fa8" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are arithmetic types, or expressions that are typed as arithmetic types, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Si los argumentos son todos tipos que son tipos aritm&amp;eacute;ticos o expresiones que se escriben como tipos aritm&amp;eacute;ticos, entonces se devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, se devuelve &lt;code&gt;false&lt;/code&gt; . Si no hay argumentos, se devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1199d0a51996844d05cb8716b18ac074abdf063" translate="yes" xml:space="preserve">
          <source>If the assigned value type is &lt;b&gt;not&lt;/b&gt; equivalent with the AA element type, the expression could invoke operator overloading with normal indexing access:</source>
          <target state="translated">Si el tipo de valor asignado &lt;b&gt;no&lt;/b&gt; es equivalente al tipo de elemento AA, la expresi&amp;oacute;n podr&amp;iacute;a invocar la sobrecarga del operador con acceso de indexaci&amp;oacute;n normal:</target>
        </trans-unit>
        <trans-unit id="a4c8c8da96483d4e6d105c51e4ab4887f9f8b55b" translate="yes" xml:space="preserve">
          <source>If the assigned value type is equivalent with the AA element type:</source>
          <target state="translated">Si el tipo de valor asignado es equivalente con el tipo de elemento AA:</target>
        </trans-unit>
        <trans-unit id="39dbd0d9fed3f956fc2681e5931d3927843d2a46" translate="yes" xml:space="preserve">
          <source>If the bounds check in &lt;code&gt;@system&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt; code is disabled, the code correctness must still be guaranteed by the code author.</source>
          <target state="translated">Si la comprobaci&amp;oacute;n de l&amp;iacute;mites en el c&amp;oacute;digo &lt;code&gt;@system&lt;/code&gt; o &lt;code&gt;@trusted&lt;/code&gt; est&amp;aacute; deshabilitada, el autor del c&amp;oacute;digo debe garantizar la correcci&amp;oacute;n del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="cc1e679f124dc90842ff4979e66ede34a74890c6" translate="yes" xml:space="preserve">
          <source>If the callback doesn't take any arguments, the callback is invoked whenever the option is seen.</source>
          <target state="translated">Si la devolución de llamada no recibe ningún argumento,la devolución de llamada se invoca siempre que se vea la opción.</target>
        </trans-unit>
        <trans-unit id="3289fcddad88ae1df9d116fd88b6c6dc79afe870" translate="yes" xml:space="preserve">
          <source>If the callback takes one string argument, the option string (without the leading dash(es)) is passed to the callback. After that, the option string is considered handled and removed from the options array.</source>
          <target state="translated">Si la devolución de llamada toma un argumento de cadena,la cadena de opción (sin el/los guión(s)inicial(es))se pasa a la devolución de llamada.Después de eso,la cadena de opciones se considera manejada y eliminada de la matriz de opciones.</target>
        </trans-unit>
        <trans-unit id="dad4f3623ab08f61a1b3d8228c7e7a46ecb84bd7" translate="yes" xml:space="preserve">
          <source>If the callback takes two string arguments, the option string is handled as an option with one argument, and parsed accordingly. The option and its value are passed to the callback. After that, whatever was passed to the callback is considered handled and removed from the list.</source>
          <target state="translated">Si la llamada toma dos argumentos de cadena,la cadena de opción se maneja como una opción con un argumento,y se analiza en consecuencia.La opción y su valor se pasan a la llamada de retorno.Después de eso,lo que se haya pasado a la llamada de retorno se considera manejado y eliminado de la lista.</target>
        </trans-unit>
        <trans-unit id="8d6fa53ba31aeabc61edb3bbeab4d2e35828294c" translate="yes" xml:space="preserve">
          <source>If the caller is a Fiber and is not a Generator, this function will call scheduler.yield() or Fiber.yield(), as appropriate.</source>
          <target state="translated">Si el llamador es una Fibra y no es un Generador,esta función llamará a scheduler.yield()o Fiber.yield(),según corresponda.</target>
        </trans-unit>
        <trans-unit id="7fba3a81af609825439d1523a354f0ef5c6b4ecb" translate="yes" xml:space="preserve">
          <source>If the caller is a scheduled Fiber, this yields execution to another scheduled Fiber.</source>
          <target state="translated">Si la persona que llama es una Fibra programada,esto cede la ejecución a otra Fibra programada.</target>
        </trans-unit>
        <trans-unit id="682966fbc9a5573324e201e13b7ba309d84a4edb" translate="yes" xml:space="preserve">
          <source>If the capacity is increased, one should assume that all iterators to the elements are invalidated.</source>
          <target state="translated">Si se aumenta la capacidad,hay que suponer que se invalidan todos los iteradores a los elementos.</target>
        </trans-unit>
        <trans-unit id="881b45b7bdf985b220e8cd0369c0c1827fe806d8" translate="yes" xml:space="preserve">
          <source>If the chunk of memory managed is large, it may be desirable to switch management to free list from the beginning. That way, memory may be used in a more compact manner than region mode. To force free list mode, call &lt;code&gt;switchToFreeList&lt;/code&gt; shortly after construction or when deemed appropriate.</source>
          <target state="translated">Si la porci&amp;oacute;n de memoria administrada es grande, puede ser conveniente cambiar la administraci&amp;oacute;n a la lista libre desde el principio. De esa manera, la memoria se puede usar de una manera m&amp;aacute;s compacta que el modo regi&amp;oacute;n. Para forzar el modo de lista libre, llame a &lt;code&gt;switchToFreeList&lt;/code&gt; poco despu&amp;eacute;s de la construcci&amp;oacute;n o cuando lo considere apropiado.</target>
        </trans-unit>
        <trans-unit id="9ac8dd371ddada3a7fc0d5f27220ac56194a508b" translate="yes" xml:space="preserve">
          <source>If the connection proceeds too quickly then need to slow it down</source>
          <target state="translated">Si la conexión se produce demasiado rápido,entonces hay que ralentizarla...</target>
        </trans-unit>
        <trans-unit id="a0e6b5ba02714528b40c08b339b490154681d034" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (e.g. if it is &lt;code&gt;pure&lt;/code&gt;), the object can be implicitly convertible to any qualifiers.</source>
          <target state="translated">Si el constructor puede crear un objeto &amp;uacute;nico (por ejemplo, si es &lt;code&gt;pure&lt;/code&gt; ), el objeto puede convertirse impl&amp;iacute;citamente en cualquier calificador.</target>
        </trans-unit>
        <trans-unit id="cf0cf6c28f3156b6b4f9788d5978b63c0c05e84c" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (i.e. if it is &lt;code&gt;pure&lt;/code&gt;), the object is implicitly convertible to any qualifiers.</source>
          <target state="translated">Si el constructor puede crear un objeto &amp;uacute;nico (es decir, si es &lt;code&gt;pure&lt;/code&gt; ), el objeto es impl&amp;iacute;citamente convertible a cualquier calificador.</target>
        </trans-unit>
        <trans-unit id="52c26c14a7e4c3281fb4736e2032dbcd78185dac" translate="yes" xml:space="preserve">
          <source>If the current count is equal to zero, return. Otherwise, atomically decrement the count by one and return true.</source>
          <target state="translated">Si el conteo actual es igual a cero,regresa.De lo contrario,disminuya atómicamente la cuenta en uno y vuelva a ser verdadera.</target>
        </trans-unit>
        <trans-unit id="50c1fec6baa7c97f9c101593b09fc41307d590d7" translate="yes" xml:space="preserve">
          <source>If the declaration is disabled but inside a disabled function, returns &lt;code&gt;true&lt;/code&gt; but do not issue an error message.</source>
          <target state="translated">Si la declaraci&amp;oacute;n est&amp;aacute; deshabilitada pero dentro de una funci&amp;oacute;n deshabilitada, devuelve &lt;code&gt;true&lt;/code&gt; pero no emite un mensaje de error.</target>
        </trans-unit>
        <trans-unit id="553971eeba92d7bd581f90194d8554493054062d" translate="yes" xml:space="preserve">
          <source>If the default value for a parameter is given, all following parameters must also have default values.</source>
          <target state="translated">Si se da el valor por defecto de un parámetro,todos los parámetros siguientes también deben tener valores por defecto.</target>
        </trans-unit>
        <trans-unit id="aefb0c84385cb6665755448be70c3bf176cad1d9" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter is the same identifier starting at the beginning of the line:</source>
          <target state="translated">Si el delimitador es un identificador,el identificador debe ir inmediatamente seguido de una nueva línea,y el delimitador coincidente es el mismo identificador que comienza al principio de la línea:</target>
        </trans-unit>
        <trans-unit id="367e2c9e3e9e32edd1905a00926130379051ac02" translate="yes" xml:space="preserve">
          <source>If the documentation of a member function of a container takes a parameter of type &lt;code&gt;Range&lt;/code&gt;, then it refers to the primary range type of this container. Oftentimes &lt;code&gt;Take!Range&lt;/code&gt; will be used, in which case the range refers to a span of the elements in the container. Arguments to these parameters &lt;b&gt;must&lt;/b&gt; be obtained from the same container instance as the one being worked with. It is important to note that many generic range algorithms return the same range type as their input range.</source>
          <target state="translated">Si la documentaci&amp;oacute;n de una funci&amp;oacute;n miembro de un contenedor toma un par&amp;aacute;metro de tipo &lt;code&gt;Range&lt;/code&gt; , se refiere al tipo de rango primario de este contenedor. A menudo se utilizar&amp;aacute; &lt;code&gt;Take!Range&lt;/code&gt; , en cuyo caso el rango se refiere a un tramo de los elementos en el contenedor. Los argumentos de estos par&amp;aacute;metros &lt;b&gt;deben&lt;/b&gt; obtenerse de la misma instancia de contenedor con la que se est&amp;aacute; trabajando. Es importante tener en cuenta que muchos algoritmos de rango gen&amp;eacute;ricos devuelven el mismo tipo de rango que su rango de entrada.</target>
        </trans-unit>
        <trans-unit id="568a7fe362541b12ed21809dd85fad3122bbc2f4" translate="yes" xml:space="preserve">
          <source>If the download receives less than &quot;low speed limit&quot; bytes/second during &quot;low speed time&quot; seconds, the operations is aborted. You could i.e if you have a pretty high speed connection, abort if it is less than 2000 bytes/sec during 20 seconds.</source>
          <target state="translated">Si la descarga recibe menos de &quot;límite de baja velocidad&quot; bytes/segundo durante &quot;tiempo de baja velocidad&quot; segundos,las operaciones se abortan.Podrías,por ejemplo,si tienes una conexión de alta velocidad,abortar si es menor de 2000 bytes/segundo durante 20 segundos.</target>
        </trans-unit>
        <trans-unit id="3a1f560a07b490771cc9fc4811b46461cd585b36" translate="yes" xml:space="preserve">
          <source>If the email address is valid or not.</source>
          <target state="translated">Si la dirección de correo electrónico es válida o no.</target>
        </trans-unit>
        <trans-unit id="4f3a54e2dd01849ed176b274b08fe7067255fdd1" translate="yes" xml:space="preserve">
          <source>If the enum</source>
          <target state="translated">Si la lista</target>
        </trans-unit>
        <trans-unit id="657b7adb8cca95e26ff1d78ccaa8357b99612950" translate="yes" xml:space="preserve">
          <source>If the expression is a &lt;a href=&quot;function#property-functions&quot;&gt; Property Function&lt;/a&gt;, &lt;code&gt;typeof&lt;/code&gt; gives its return type.</source>
          <target state="translated">Si la expresi&amp;oacute;n es una &lt;a href=&quot;function#property-functions&quot;&gt;funci&amp;oacute;n de propiedad&lt;/a&gt; , &lt;code&gt;typeof&lt;/code&gt; proporciona su tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="bbff4334fd247c00a1664b1a8294a75098385c7e" translate="yes" xml:space="preserve">
          <source>If the extended unittest handler is registered, this function returns the result from that handler directly.</source>
          <target state="translated">Si se registra el manipulador de la prueba unitaria ampliada,esta función devuelve el resultado de ese manipulador directamente.</target>
        </trans-unit>
        <trans-unit id="638ef19a4eda5122a3e4b7247816dfcd0c978607" translate="yes" xml:space="preserve">
          <source>If the extension is empty, this function is equivalent to &lt;a href=&quot;#stripExtension&quot;&gt;&lt;code&gt;stripExtension&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si la extensi&amp;oacute;n est&amp;aacute; vac&amp;iacute;a, esta funci&amp;oacute;n es equivalente a &lt;a href=&quot;#stripExtension&quot;&gt; &lt;code&gt;stripExtension&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ef335ccbfb3536483e3c42f2775a824af19d172" translate="yes" xml:space="preserve">
          <source>If the field is initialized on one path, it must be initialized on all paths.</source>
          <target state="translated">Si el campo se inicializa en un camino,debe ser inicializado en todos los caminos.</target>
        </trans-unit>
        <trans-unit id="837d5b133d0941d97e1586686594739710856b45" translate="yes" xml:space="preserve">
          <source>If the field type has an &lt;a href=&quot;operatoroverloading#assignment&quot;&gt;&lt;code&gt;opAssign&lt;/code&gt;&lt;/a&gt; method, it will not be used for initialization.</source>
          <target state="translated">Si el tipo de campo tiene un m&amp;eacute;todo &lt;a href=&quot;operatoroverloading#assignment&quot;&gt; &lt;code&gt;opAssign&lt;/code&gt; &lt;/a&gt; , no se usar&amp;aacute; para la inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ced70cd3f9cbddd52606f9834678b1724238171b" translate="yes" xml:space="preserve">
          <source>If the field type is not mutable, multiple initialization will be rejected.</source>
          <target state="translated">Si el tipo de campo no es mutable,se rechazará la inicialización múltiple.</target>
        </trans-unit>
        <trans-unit id="03c48cf052ea3dedbdf6ccc3c7e899b230bc6471" translate="yes" xml:space="preserve">
          <source>If the file is not opened, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; for the file handle.</source>
          <target state="translated">Si el archivo no se abre, devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, devuelve &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; para el identificador de archivo.</target>
        </trans-unit>
        <trans-unit id="8450d7a55bd53dbebae5b57df534f9be1005db67" translate="yes" xml:space="preserve">
          <source>If the file is not opened, succeeds vacuously. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; for the file handle.</source>
          <target state="translated">Si el archivo no se abre, se realiza correctamente. De lo contrario, devuelve m&amp;aacute;s &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;claro&lt;/a&gt; para el identificador de archivo.</target>
        </trans-unit>
        <trans-unit id="094342c021e1489a63abd256ccc39489b9dd3b66" translate="yes" xml:space="preserve">
          <source>If the file name of a module is an invalid module name (e.g. &lt;code&gt;foo-bar.d&lt;/code&gt;), you may use a module declaration to set a valid module name:</source>
          <target state="translated">Si el nombre de archivo de un m&amp;oacute;dulo es un nombre de m&amp;oacute;dulo no v&amp;aacute;lido (por ejemplo, &lt;code&gt;foo-bar.d&lt;/code&gt; ), puede usar una declaraci&amp;oacute;n de m&amp;oacute;dulo para establecer un nombre de m&amp;oacute;dulo v&amp;aacute;lido:</target>
        </trans-unit>
        <trans-unit id="af6d8edab76ddfaae7837345a33fd73f250c8a9f" translate="yes" xml:space="preserve">
          <source>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;), throwing on error. Even if an exception is thrown, afterwards the &lt;code&gt;File&lt;/code&gt; object is empty. This is different from &lt;code&gt;detach&lt;/code&gt; in that it always closes the file; consequently, all other &lt;code&gt;File&lt;/code&gt; objects referring to the same handle will see a closed file henceforth.</source>
          <target state="translated">Si el archivo no se abri&amp;oacute;, tiene &amp;eacute;xito al vac&amp;iacute;o. De lo contrario, cierra el archivo (llamando a &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt; ), arrojando un error. Incluso si se produce una excepci&amp;oacute;n, luego el objeto &lt;code&gt;File&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o. Esto es diferente de &lt;code&gt;detach&lt;/code&gt; en que siempre cierra el archivo; en consecuencia, todos los dem&amp;aacute;s objetos de &lt;code&gt;File&lt;/code&gt; que se refieren al mismo identificador ver&amp;aacute;n un archivo cerrado en adelante.</target>
        </trans-unit>
        <trans-unit id="527ef94b697e67dac9fb104fb0ef24982a4b2044" translate="yes" xml:space="preserve">
          <source>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in &lt;code&gt;ext&lt;/code&gt; is optional.</source>
          <target state="translated">Si el nombre de archivo ya tiene una extensi&amp;oacute;n, se reemplaza. Si no, la extensi&amp;oacute;n simplemente se agrega al nombre del archivo. Incluir un punto &lt;code&gt;ext&lt;/code&gt; en ext es opcional.</target>
        </trans-unit>
        <trans-unit id="9ba4ff05c5a39476e966f563ceda94938de67867" translate="yes" xml:space="preserve">
          <source>If the first</source>
          <target state="translated">Si el primer</target>
        </trans-unit>
        <trans-unit id="fdc87c8a8b7093e7a7ff0e6b20593048b93bffda" translate="yes" xml:space="preserve">
          <source>If the first line starts with &quot;#!&quot;, then that line is ignored.</source>
          <target state="translated">Si la primera línea comienza con &quot;#!&quot;,entonces esa línea es ignorada.</target>
        </trans-unit>
        <trans-unit id="f743b99432834f349face5005529142050d8a895" translate="yes" xml:space="preserve">
          <source>If the first lookup wasn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes scope of base classes and interface (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">Si la primera b&amp;uacute;squeda no fue exitosa, se realiza una segunda en las importaciones. En la segunda fase de b&amp;uacute;squeda, los &amp;aacute;mbitos heredados se ignoran. Esto incluye el alcance de las clases base y la interfaz (en este ejemplo, las importaciones de &lt;code&gt;BaseClass&lt;/code&gt; ser&amp;iacute;an ignoradas), as&amp;iacute; como las importaciones en una &lt;code&gt;template&lt;/code&gt; mixta .</target>
        </trans-unit>
        <trans-unit id="4653edc731431a9f55f3a9c2f7b1ee0500507aaf" translate="yes" xml:space="preserve">
          <source>If the floating-point rounding mode is changed within a function, it must be restored before the function exits. If this rule is violated (for example, by the use of inline asm), the rounding mode used for subsequent calculations is undefined.</source>
          <target state="translated">Si se cambia el modo de redondeo del punto flotante dentro de una función,debe ser restaurado antes de que la función salga.Si se infringe esta regla (por ejemplo,por el uso de asm en línea),el modo de redondeo utilizado para los cálculos posteriores queda indefinido.</target>
        </trans-unit>
        <trans-unit id="06665db726ed2b3db8e693b6a8e9e8220aa3c936" translate="yes" xml:space="preserve">
          <source>If the format string is fixed, passing it as a template parameter checks the type correctness of the parameters at compile-time. This also can result in better performance.</source>
          <target state="translated">Si la cadena de formato es fija,al pasarla como parámetro de plantilla se comprueba la corrección del tipo de los parámetros en tiempo de compilación.Esto también puede resultar en un mejor rendimiento.</target>
        </trans-unit>
        <trans-unit id="f41ef8f8cc465c8df198d14584ea0805a3861563" translate="yes" xml:space="preserve">
          <source>If the fractional part of x is exactly 0.5, the return value is rounded away from zero.</source>
          <target state="translated">Si la parte fraccionaria de x es exactamente 0,5,el valor de retorno se redondea a partir de cero.</target>
        </trans-unit>
        <trans-unit id="6a44050dca10920a151c58d6983c48f0ef88a105" translate="yes" xml:space="preserve">
          <source>If the function is passed in string form, the state has name &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the zero-based index in the recurrence has name &lt;code&gt;&quot;n&quot;&lt;/code&gt;. The given string must return the desired value for &lt;code&gt;a[n]&lt;/code&gt; given &lt;code&gt;a[n - 1]&lt;/code&gt;, &lt;code&gt;a[n - 2]&lt;/code&gt;, &lt;code&gt;a[n - 3]&lt;/code&gt;,..., &lt;code&gt;a[n - stateSize]&lt;/code&gt;. The state size is dictated by the number of arguments passed to the call to &lt;code&gt;recurrence&lt;/code&gt;. The &lt;code&gt;Recurrence&lt;/code&gt; struct itself takes care of managing the recurrence's state and shifting it appropriately.</source>
          <target state="translated">Si la funci&amp;oacute;n se pasa en forma de cadena, el estado tiene el nombre &lt;code&gt;&quot;a&quot;&lt;/code&gt; y el &amp;iacute;ndice de base cero en la recurrencia tiene el nombre &lt;code&gt;&quot;n&quot;&lt;/code&gt; . La cadena dada debe devolver el valor deseado para &lt;code&gt;a[n]&lt;/code&gt; dado &lt;code&gt;a[n - 1]&lt;/code&gt; , &lt;code&gt;a[n - 2]&lt;/code&gt; , &lt;code&gt;a[n - 3]&lt;/code&gt; , ..., &lt;code&gt;a[n - stateSize]&lt;/code&gt; . El tama&amp;ntilde;o del estado est&amp;aacute; dictado por el n&amp;uacute;mero de argumentos pasados ​​a la llamada a la &lt;code&gt;recurrence&lt;/code&gt; . La estructura de &lt;code&gt;Recurrence&lt;/code&gt; misma se encarga de administrar el estado de recurrencia y cambiarlo adecuadamente.</target>
        </trans-unit>
        <trans-unit id="3c67c2406f3c735811702f591ea611c2970cdc93" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;void&lt;/code&gt;, and the first parameter is &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt;, then all subsequent &lt;code&gt;return ref&lt;/code&gt; parameters are considered as being assigned to the first parameter for lifetime checking. The &lt;code&gt;this&lt;/code&gt; reference parameter to a struct non-static member function is considered the first parameter.</source>
          <target state="translated">Si la funci&amp;oacute;n devuelve &lt;code&gt;void&lt;/code&gt; , y el primer par&amp;aacute;metro es &lt;code&gt;ref&lt;/code&gt; o &lt;code&gt;out&lt;/code&gt; , entonces todos los par&amp;aacute;metros de &lt;code&gt;return ref&lt;/code&gt; posteriores se consideran asignados al primer par&amp;aacute;metro para la verificaci&amp;oacute;n de la vida &amp;uacute;til. El par&amp;aacute;metro &lt;code&gt;this&lt;/code&gt; reference a una funci&amp;oacute;n de miembro struct no est&amp;aacute;tico se considera el primer par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="e2f91af04048a7f2df150e8629c6506bcf13c494" translate="yes" xml:space="preserve">
          <source>If the generated copy constructor fails to type check, it will receive the &lt;code&gt;@disable&lt;/code&gt; attribute.</source>
          <target state="translated">Si el constructor de la copia generada no puede escribir check, recibir&amp;aacute; el atributo &lt;code&gt;@disable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1f1e5a2ec324dd58e7c90d671571002b1fff9a" translate="yes" xml:space="preserve">
          <source>If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's &lt;code&gt;end&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;end&lt;/code&gt;. If iterating backwards, and the generated time point is before &lt;code&gt;begin&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;begin&lt;/code&gt;. In either case, the range would then be empty.</source>
          <target state="translated">Si el punto de tiempo generado pasa el borde del rango en la direcci&amp;oacute;n correcta, entonces se usar&amp;aacute; el borde de ese rango. Entonces, si itera hacia adelante, y el punto de tiempo generado pasa el &lt;code&gt;end&lt;/code&gt; del intervalo , entonces el &lt;code&gt;front&lt;/code&gt; convierte en &lt;code&gt;end&lt;/code&gt; . Si itera hacia atr&amp;aacute;s, y el punto de tiempo generado es antes de &lt;code&gt;begin&lt;/code&gt; , entonces el &lt;code&gt;front&lt;/code&gt; convierte en &lt;code&gt;begin&lt;/code&gt; . En cualquier caso, el rango estar&amp;iacute;a vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="f99397fa61eb34180bac28883c2e71092de6779b" translate="yes" xml:space="preserve">
          <source>If the given file is a symbolic link, then this returns the attributes of the symbolic link itself rather than file that it points to. If the given file is</source>
          <target state="translated">Si el archivo dado es un enlace simbólico,entonces esto devuelve los atributos del propio enlace simbólico en lugar del archivo al que apunta.Si el archivo dado es</target>
        </trans-unit>
        <trans-unit id="a8dd80adc35b72f7e72590ec9517794124fe146d" translate="yes" xml:space="preserve">
          <source>If the given header contains columns not found in the input they will be ignored.</source>
          <target state="translated">Si el encabezado dado contiene columnas no encontradas en la entrada,serán ignoradas.</target>
        </trans-unit>
        <trans-unit id="6c1edb4f30ef72dc654568216fa979bf98fad63c" translate="yes" xml:space="preserve">
          <source>If the given header does not match the order in the input, the content will return as it is found in the input.</source>
          <target state="translated">Si el encabezado dado no coincide con el orden en la entrada,el contenido regresará como se encuentra en la entrada.</target>
        </trans-unit>
        <trans-unit id="02a682f7846fb30dcf203d60bc7b6d3c76c4aec4" translate="yes" xml:space="preserve">
          <source>If the heap has room to grow, inserts &lt;code&gt;value&lt;/code&gt; into the store and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, if &lt;code&gt;less(value, front)&lt;/code&gt;, calls &lt;code&gt;replaceFront(value)&lt;/code&gt; and returns again &lt;code&gt;true&lt;/code&gt;. Otherwise, leaves the heap unaffected and returns &lt;code&gt;false&lt;/code&gt;. This method is useful in scenarios where the smallest &lt;code&gt;k&lt;/code&gt; elements of a set of candidates must be collected.</source>
          <target state="translated">Si el mont&amp;oacute;n tiene espacio para crecer, inserta &lt;code&gt;value&lt;/code&gt; en la tienda y devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, si es &lt;code&gt;less(value, front)&lt;/code&gt; , llama a &lt;code&gt;replaceFront(value)&lt;/code&gt; y vuelve a ser &lt;code&gt;true&lt;/code&gt; . De lo contrario, no afecta el mont&amp;oacute;n y devuelve &lt;code&gt;false&lt;/code&gt; . Este m&amp;eacute;todo es &amp;uacute;til en escenarios en los que se deben recopilar los &lt;code&gt;k&lt;/code&gt; elementos m&amp;aacute;s peque&amp;ntilde;os de un conjunto de candidatos.</target>
        </trans-unit>
        <trans-unit id="44b5028eff915a424d2f05a190933f50e1ca6cdc" translate="yes" xml:space="preserve">
          <source>If the indexing key already exists in the AA, the setting runs normal assignment.</source>
          <target state="translated">Si la clave de indexación ya existe en el AA,el ajuste ejecuta la asignación normal.</target>
        </trans-unit>
        <trans-unit id="ed75ab58ae875098848f819360947f45ce239d60" translate="yes" xml:space="preserve">
          <source>If the indexing key does not yet exist in AA, a new AA entry will be allocated, and it will be initialized with the assigned value.</source>
          <target state="translated">Si la clave de indización no existe todavía en AA,se asignará una nueva entrada de AA y se inicializará con el valor asignado.</target>
        </trans-unit>
        <trans-unit id="e8855e5c687d575ac4df58472c04fb490240846e" translate="yes" xml:space="preserve">
          <source>If the infinite-precision result fits in the result type, return it and do not touch &lt;code&gt;overflow&lt;/code&gt;</source>
          <target state="translated">Si el resultado de precisi&amp;oacute;n infinita encaja en el tipo de resultado, devu&amp;eacute;lvalo y no toque el &lt;code&gt;overflow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4845dcdf1de3a2fc72f78227d54d29b17278e722" translate="yes" xml:space="preserve">
          <source>If the initializer is not present, the immutable can be initialized from the corresponding constructor:</source>
          <target state="translated">Si el inicializador no está presente,el inmutable puede ser inicializado desde el constructor correspondiente:</target>
        </trans-unit>
        <trans-unit id="b6a08857ba6ae055c6d0992d75eba874a7e5568d" translate="yes" xml:space="preserve">
          <source>If the input array is already valid, this function returns the original, otherwise it constructs a new array by replacing all illegal sequences with the encoding scheme's replacement sequence.</source>
          <target state="translated">Si la matriz de entrada ya es válida,esta función devuelve el original,de lo contrario construye una nueva matriz sustituyendo todas las secuencias ilegales por la secuencia de sustitución del esquema de codificación.</target>
        </trans-unit>
        <trans-unit id="8c989250d06df7a1e7f52d0b71ed6e2b6ea2a097" translate="yes" xml:space="preserve">
          <source>If the input string is already valid, this function returns the original, otherwise it constructs a new string by replacing all illegal code unit sequences with the encoding's replacement character, Invalid sequences will be replaced with the Unicode replacement character (U+FFFD) if the character repertoire contains it, otherwise invalid sequences will be replaced with '?'.</source>
          <target state="translated">Si la cadena de entrada ya es válida,esta función devuelve el original,de lo contrario construye una nueva cadena reemplazando todas las secuencias de unidades de código ilegales con el carácter de reemplazo de la codificación,las secuencias inválidas serán reemplazadas con el carácter de reemplazo de Unicode (U+FFFD)si el repertorio de caracteres lo contiene,de lo contrario las secuencias inválidas serán reemplazadas con '?'.</target>
        </trans-unit>
        <trans-unit id="c3178232393693733f89474a2be2c7d87e890b8d" translate="yes" xml:space="preserve">
          <source>If the instance &lt;code&gt;toString&lt;/code&gt; has overridden &lt;code&gt;Object.toString&lt;/code&gt;, it is used.</source>
          <target state="translated">Si la instancia &lt;code&gt;toString&lt;/code&gt; ha anulado &lt;code&gt;Object.toString&lt;/code&gt; , se utiliza.</target>
        </trans-unit>
        <trans-unit id="3bbc396d6905590778769668af1612cc2bc09090" translate="yes" xml:space="preserve">
          <source>If the invariant does not hold, then the program enters an invalid state.</source>
          <target state="translated">Si la invariante no se mantiene,entonces el programa entra en un estado inválido.</target>
        </trans-unit>
        <trans-unit id="29f830d3a5bba4e064a4eb84cc7502640a0b8dc9" translate="yes" xml:space="preserve">
          <source>If the last template parameter in the</source>
          <target state="translated">Si el último parámetro de la plantilla en el</target>
        </trans-unit>
        <trans-unit id="88a26f48b106a357207e0f09ddece2a679970e48" translate="yes" xml:space="preserve">
          <source>If the last template parameter is set to &lt;code&gt;No.multiblock&lt;/code&gt;, the allocator will only serve allocations which require at most &lt;code&gt;theBlockSize&lt;/code&gt;. The &lt;code&gt;BitmappedBlock&lt;/code&gt; has a specialized implementation for single-block allocations which allows for greater performance, at the cost of not being able to allocate more than one block at a time.</source>
          <target state="translated">Si el &amp;uacute;ltimo par&amp;aacute;metro de plantilla se establece en &lt;code&gt;No.multiblock&lt;/code&gt; , el asignador solo servir&amp;aacute; asignaciones que requieren como m&amp;aacute;ximo &lt;code&gt;theBlockSize&lt;/code&gt; . El &lt;code&gt;BitmappedBlock&lt;/code&gt; tiene una aplicaci&amp;oacute;n especializada para la asignaci&amp;oacute;n de un solo bloque que permite un rendimiento mayor, a costa de no ser capaz de asignar m&amp;aacute;s de una cuadra a la vez.</target>
        </trans-unit>
        <trans-unit id="b95587a219c8d062823f53f5bd2f1a123f7f69f2" translate="yes" xml:space="preserve">
          <source>If the left and right operands are of the same struct type, and the struct type has a &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;, then the copy operation is as described in &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt;.</source>
          <target state="translated">Si los operandos izquierdo y derecho son del mismo tipo de estructura, y el tipo de estructura tiene un &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt; , entonces la operaci&amp;oacute;n de copia es como se describe en &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78b1fe866d2fc25a11cfe13642305ae4d6350c6d" translate="yes" xml:space="preserve">
          <source>If the left hand side of an</source>
          <target state="translated">Si el lado izquierdo de un</target>
        </trans-unit>
        <trans-unit id="eb414c8d10d773bd339d18bd7ab37e8cf26592ba" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is a slice operation on a struct or class instance, it can be overloaded by implementing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function that takes the return value of the &lt;code&gt;opSlice&lt;/code&gt; function as parameter(s). Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Si el lado izquierdo de una asignaci&amp;oacute;n es una operaci&amp;oacute;n de divisi&amp;oacute;n en una instancia de estructura o clase, se puede sobrecargar implementando una funci&amp;oacute;n miembro &lt;code&gt;opIndexAssign&lt;/code&gt; que toma el valor de retorno de la funci&amp;oacute;n &lt;code&gt;opSlice&lt;/code&gt; como par&amp;aacute;metro (s). Expresiones de la forma &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4e9f1b74401fc4cc6670aa5c593952f4aacceb0" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is an index operation on a struct or class instance, it can be overloaded by providing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function. Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Si el lado izquierdo de una asignaci&amp;oacute;n es una operaci&amp;oacute;n de &amp;iacute;ndice en una instancia de estructura o clase, se puede sobrecargar proporcionando una funci&amp;oacute;n miembro &lt;code&gt;opIndexAssign&lt;/code&gt; . Expresiones de la forma &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8a73a5f2389d0e22c2833822feb34b34d4eccd0" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;false&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">Si el operando izquierdo es &lt;code&gt;false&lt;/code&gt; , entonces se eval&amp;uacute;a el operando derecho. Si el tipo de resultado de la</target>
        </trans-unit>
        <trans-unit id="60ea3d064b90b5b8a778e152eace4b2f3ae90eb9" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;true&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">Si el operando izquierdo es &lt;code&gt;true&lt;/code&gt; , entonces se eval&amp;uacute;a el operando derecho. Si el tipo de resultado de la</target>
        </trans-unit>
        <trans-unit id="019b690c1822d6ef391c3b9bd7b26426c5f16db7" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;false&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">Si el operando izquierdo, convertido a tipo &lt;code&gt;bool&lt;/code&gt; , se eval&amp;uacute;a como &lt;code&gt;false&lt;/code&gt; , entonces el operando derecho no se eval&amp;uacute;a. Si el tipo de resultado de la</target>
        </trans-unit>
        <trans-unit id="553371891fa4522412ee1e69cce9e04315ec8432" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;true&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">Si el operando izquierdo, convertido a tipo &lt;code&gt;bool&lt;/code&gt; , se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; , entonces el operando derecho no se eval&amp;uacute;a. Si el tipo de resultado de la</target>
        </trans-unit>
        <trans-unit id="3b4965e0366e4348265d324ef6cafd070f7970a9" translate="yes" xml:space="preserve">
          <source>If the lock is held by another caller, the method returns. Otherwise, the lock is acquired if it is not already held, and then the internal counter is incremented by one.</source>
          <target state="translated">Si la cerradura es mantenida por otro llamante,el método regresa.De lo contrario,el bloqueo se adquiere si no está ya sostenido,y entonces el contador interno se incrementa en uno.</target>
        </trans-unit>
        <trans-unit id="55629f3e58b1ed6b51915672626c91dce13adbf6" translate="yes" xml:space="preserve">
          <source>If the lvalue is a static array or a slice, the behavior is as described in &lt;a href=&quot;array#array-copying&quot;&gt;Array Copying&lt;/a&gt; and &lt;a href=&quot;array#array-setting&quot;&gt;Array Setting&lt;/a&gt;.</source>
          <target state="translated">Si lvalue es una matriz est&amp;aacute;tica o un sector, el comportamiento es como se describe en &lt;a href=&quot;array#array-copying&quot;&gt;Copia de &lt;/a&gt;&lt;a href=&quot;array#array-setting&quot;&gt;matriz&lt;/a&gt; y Configuraci&amp;oacute;n de matriz .</target>
        </trans-unit>
        <trans-unit id="9eeb3d42a4d163cc9ef2cce9f7a4d552e700ff44" translate="yes" xml:space="preserve">
          <source>If the lvalue is a user-defined property, the behavior is as described in &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">Si lvalue es una propiedad definida por el usuario, el comportamiento es como se describe en &lt;a href=&quot;function#property-functions&quot;&gt;Funciones de propiedad&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e946590fb7a5bc10633af10a8d9500f37b24a5e" translate="yes" xml:space="preserve">
          <source>If the lvalue is the &lt;code&gt;.length&lt;/code&gt; property of a dynamic array, the behavior is as described in &lt;a href=&quot;array#resize&quot;&gt;Setting Dynamic Array Length&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;.length&lt;/code&gt; es la propiedad .length de una matriz din&amp;aacute;mica, el comportamiento es como se describe en &lt;a href=&quot;array#resize&quot;&gt;Configuraci&amp;oacute;n de la longitud de la matriz din&amp;aacute;mica&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbdda788f4cd04313acf31a5b41902468d969a5d" translate="yes" xml:space="preserve">
          <source>If the member is a class or struct, undefined lookups will be forwarded to the</source>
          <target state="translated">Si el miembro es una clase o estructura,las búsquedas no definidas serán enviadas al</target>
        </trans-unit>
        <trans-unit id="c199908c7f62621c91cf713b59d48d772db7abde" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;'d'&lt;/code&gt; is present, then the number of characters in &lt;code&gt;to&lt;/code&gt; may be only &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.  If the modifier &lt;code&gt;'d'&lt;/code&gt; is</source>
          <target state="translated">Si el modificador &lt;code&gt;'d'&lt;/code&gt; est&amp;aacute; presente, entonces el n&amp;uacute;mero de caracteres en &lt;code&gt;to&lt;/code&gt; puede ser s&amp;oacute;lo &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;1&lt;/code&gt; . Si el modificador &lt;code&gt;'d'&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="f37f897b787b41e685e34c136ea8c1b433cab685" translate="yes" xml:space="preserve">
          <source>If the need is to remove some elements in the range but the order of the remaining elements does not have to be preserved, you may want to pass &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; to &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">Si la necesidad es eliminar algunos elementos en el rango pero no es necesario preservar el orden de los elementos restantes, es posible que desee pasar &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; para &lt;code&gt;remove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03a264184d81bbe95136e2edec953acc73c6e493" translate="yes" xml:space="preserve">
          <source>If the new array length is longer, the remainder is filled out with the default initializer.</source>
          <target state="translated">Si la nueva longitud de la matriz es mayor,el resto se rellena con el inicializador predeterminado.</target>
        </trans-unit>
        <trans-unit id="e4175ca1068588312ee2e22b72b62b8fd2ed5c5b" translate="yes" xml:space="preserve">
          <source>If the only pointer to an object is held outside of these areas, then the collector will miss it and free the memory.</source>
          <target state="translated">Si el único puntero de un objeto se mantiene fuera de estas áreas,el coleccionista lo perderá y liberará la memoria.</target>
        </trans-unit>
        <trans-unit id="4717846b29b0f5d911b4b2433c06faa02839af64" translate="yes" xml:space="preserve">
          <source>If the operands are integral values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. Equality is defined as the bit patterns of the common type match exactly.</source>
          <target state="translated">Si los operandos son valores integrales, las &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;conversiones aritm&amp;eacute;ticas usuales&lt;/a&gt; se aplican para llevarlos a un tipo com&amp;uacute;n antes de la comparaci&amp;oacute;n. La igualdad se define como los patrones de bits del tipo com&amp;uacute;n coinciden exactamente.</target>
        </trans-unit>
        <trans-unit id="47f360c49b94c4c07ce9dc61c5e3af5635a7a2ca" translate="yes" xml:space="preserve">
          <source>If the operands are of integral types, they undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;, and then are brought to a common type using the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">Si los operandos son de tipos integrales, se someten a las &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;conversiones aritm&amp;eacute;ticas habituales&lt;/a&gt; , y luego se llevan a un tipo com&amp;uacute;n utilizando las &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;conversiones aritm&amp;eacute;ticas habituales&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84b7a8c85c49e4f67e102545e92d61c9c7d7721a" translate="yes" xml:space="preserve">
          <source>If the operands are pointers, equality is defined as the bit patterns of the operands match exactly.</source>
          <target state="translated">Si los operandos son punteros,la igualdad se define como los patrones de bits de los operandos coinciden exactamente.</target>
        </trans-unit>
        <trans-unit id="5b2963819db13f5d2cdfe8c71bec58c53fd098f3" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be the that type.</source>
          <target state="translated">Si los operandos son del mismo tipo,el resultado será de ese tipo.</target>
        </trans-unit>
        <trans-unit id="b17e0053bf5ffe1d2e67cd6799c427ff52f64545" translate="yes" xml:space="preserve">
          <source>If the operands of an associative operator + or * are floating point values, the expression is not reordered.</source>
          <target state="translated">Si los operandos de un operador asociativo+o*son valores en coma flotante,la expresión no se reordena.</target>
        </trans-unit>
        <trans-unit id="1ff3f829adb0f4d6d8dd5ae222b510bf5f3ff104" translate="yes" xml:space="preserve">
          <source>If the operation would lead to an over/underflow, this function will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Si la operaci&amp;oacute;n llevar&amp;iacute;a a un desbordamiento / desbordamiento, esta funci&amp;oacute;n devolver&amp;aacute; &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="988a22885dd9a150d46126a78cb644539f3b1a37" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, and the first operand is a pointer, and the second is an integral type, the resulting type is the type of the first operand, and the resulting value is the pointer plus (or minus) the second operand multiplied by the size of the type pointed to by the first operand.</source>
          <target state="translated">Si el operador es &lt;code&gt;+&lt;/code&gt; o &lt;code&gt;-&lt;/code&gt; , y el primer operando es un puntero, y el segundo es un tipo integral, el tipo resultante es el tipo del primer operando, y el valor resultante es el puntero m&amp;aacute;s (o menos) del segundo operando multiplicado por el tama&amp;ntilde;o del tipo se&amp;ntilde;alado por el primer operando.</target>
        </trans-unit>
        <trans-unit id="34ffd24d69741e93233760376d587038f7e6c1e1" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;=&lt;/code&gt; then it is simple assignment. The right operand is implicitly converted to the type of the left operand, and assigned to it.</source>
          <target state="translated">Si el operador es &lt;code&gt;=&lt;/code&gt; entonces es una asignaci&amp;oacute;n simple. El operando derecho se convierte impl&amp;iacute;citamente al tipo del operando izquierdo y se le asigna.</target>
        </trans-unit>
        <trans-unit id="fd1b71b4b4c55aa30d89d8186ad8ca957d4c8944" translate="yes" xml:space="preserve">
          <source>If the optional second</source>
          <target state="translated">Si el segundo opcional</target>
        </trans-unit>
        <trans-unit id="c5921859078b177e6c63e26fb0f1ad26714bef56" translate="yes" xml:space="preserve">
          <source>If the parent allocator &lt;code&gt;Allocator&lt;/code&gt; is stateful, an instance of it is stored as a member. Otherwise, &lt;code&gt;AffixAllocator&lt;/code&gt; uses &lt;code&gt;Allocator.instance&lt;/code&gt;. In either case, the name &lt;code&gt;_parent&lt;/code&gt; is uniformly used for accessing the parent allocator.</source>
          <target state="translated">Si el asignador principal &lt;code&gt;Allocator&lt;/code&gt; tiene estado, una instancia de este se almacena como miembro. De lo contrario, &lt;code&gt;AffixAllocator&lt;/code&gt; usa &lt;code&gt;Allocator.instance&lt;/code&gt; . En cualquier caso, el nombre &lt;code&gt;_parent&lt;/code&gt; se usa de manera uniforme para acceder al asignador principal.</target>
        </trans-unit>
        <trans-unit id="af9326a4bd5d7cb5b11db287f31708f748f7ca2d" translate="yes" xml:space="preserve">
          <source>If the passed buffer is not the last allocation, then &lt;code&gt;delta&lt;/code&gt; can be at most the number of bytes left on the last page. Otherwise, we can expand the last allocation until the end of the virtual address range.</source>
          <target state="translated">Si el b&amp;uacute;fer pasado no es la &amp;uacute;ltima asignaci&amp;oacute;n, entonces &lt;code&gt;delta&lt;/code&gt; puede ser como m&amp;aacute;ximo el n&amp;uacute;mero de bytes que quedan en la &amp;uacute;ltima p&amp;aacute;gina. De lo contrario, podemos expandir la &amp;uacute;ltima asignaci&amp;oacute;n hasta el final del rango de direcciones virtuales.</target>
        </trans-unit>
        <trans-unit id="e540ec8736760fd165d128b0a1be1fa92246d1c7" translate="yes" xml:space="preserve">
          <source>If the process associated with &lt;code&gt;pid&lt;/code&gt; has already terminated, &lt;code&gt;tryWait&lt;/code&gt; has the exact same effect as &lt;code&gt;wait&lt;/code&gt;. In this case, it returns a tuple where the &lt;code&gt;terminated&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;status&lt;/code&gt; field has the same interpretation as the return value of &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">Si el proceso asociado con &lt;code&gt;pid&lt;/code&gt; ya ha finalizado, &lt;code&gt;tryWait&lt;/code&gt; tiene exactamente el mismo efecto que &lt;code&gt;wait&lt;/code&gt; . En este caso, devuelve una tupla donde el campo &lt;code&gt;terminated&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; y el campo de &lt;code&gt;status&lt;/code&gt; tiene la misma interpretaci&amp;oacute;n que el valor de retorno de &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc712808d5442951029c772a2016b0fbaebf6a3" translate="yes" xml:space="preserve">
          <source>If the process has</source>
          <target state="translated">Si el proceso tiene</target>
        </trans-unit>
        <trans-unit id="8a1cda6113d7bf95379f37d69fe6660204f54b65" translate="yes" xml:space="preserve">
          <source>If the process has already terminated, this function returns directly. The exit code is cached, so that if wait() is called multiple times on the same &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; it will always return the same value.</source>
          <target state="translated">Si el proceso ya ha finalizado, esta funci&amp;oacute;n vuelve directamente. El c&amp;oacute;digo de salida se almacena en cach&amp;eacute;, de modo que si se llama a wait () varias veces en el mismo &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt; , siempre devolver&amp;aacute; el mismo valor.</target>
        </trans-unit>
        <trans-unit id="04681d73e96e38582bd8e0a705f2c67039e3da37" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, the &lt;code&gt;status&lt;/code&gt; field of the return value will contain a negative number whose absolute value is the signal number. (See &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Si el proceso finaliza con una se&amp;ntilde;al, el campo de &lt;code&gt;status&lt;/code&gt; del valor de retorno contendr&amp;aacute; un n&amp;uacute;mero negativo cuyo valor absoluto es el n&amp;uacute;mero de se&amp;ntilde;al. (Ver &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; para m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="2cb4ce468479df22f5efb3ab328110646f8f6c12" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, this function returns a negative number whose absolute value is the signal number. Since POSIX restricts normal exit codes to the range 0-255, a negative return value will always indicate termination by signal. Signal codes are defined in the &lt;code&gt;core.sys.posix.signal&lt;/code&gt; module (which corresponds to the &lt;code&gt;signal.h&lt;/code&gt; POSIX header).</source>
          <target state="translated">Si el proceso termina con una se&amp;ntilde;al, esta funci&amp;oacute;n devuelve un n&amp;uacute;mero negativo cuyo valor absoluto es el n&amp;uacute;mero de se&amp;ntilde;al. Dado que POSIX restringe los c&amp;oacute;digos de salida normales al rango 0-255, un valor de retorno negativo siempre indicar&amp;aacute; la terminaci&amp;oacute;n por se&amp;ntilde;al. Los c&amp;oacute;digos de se&amp;ntilde;al se definen en el m&amp;oacute;dulo &lt;code&gt;core.sys.posix.signal&lt;/code&gt; (que corresponde al encabezado POSIX &lt;code&gt;signal.h&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="55d51d320c375e52c1f5d554f57416c612f36789" translate="yes" xml:space="preserve">
          <source>If the range is already the lexicographically greatest even permutation, it is permuted back to the least even permutation and false is returned. Otherwise, true is returned, and the range is modified in-place to be the lexicographically next even permutation.</source>
          <target state="translated">Si el rango es ya la permutación lexicográficamente más grande y pareja,se permuta de nuevo a la permutación menos pareja y se devuelve falso.En caso contrario,se devuelve true,y el rango se modifica en el lugar para ser la siguiente permutación uniforme lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="b6341c08a4c104d5a17945be30a12feeaa49cdba" translate="yes" xml:space="preserve">
          <source>If the range is currently the lexicographically greatest permutation, it is permuted back to the least permutation and false is returned. Otherwise, true is returned. One can thus generate all permutations of a range by sorting it according to &lt;code&gt;less&lt;/code&gt;, which produces the lexicographically least permutation, and then calling nextPermutation until it returns false. This is guaranteed to generate all distinct permutations of the range exactly once. If there are</source>
          <target state="translated">Si el rango es actualmente la mayor permutaci&amp;oacute;n lexicogr&amp;aacute;fica, se permuta de nuevo a la menor permutaci&amp;oacute;n y se devuelve falso. De lo contrario, se devuelve verdadero. Por lo tanto, uno puede generar todas las permutaciones de un rango al ordenarlo de acuerdo con &lt;code&gt;less&lt;/code&gt; , lo que produce la permutaci&amp;oacute;n menos lexicogr&amp;aacute;fica, y luego llamar a nextPermutation hasta que devuelva falso. Esto garantiza generar todas las permutaciones distintas del rango exactamente una vez. Si hay</target>
        </trans-unit>
        <trans-unit id="3c682555e85edc7cea0e0b4d1aeb80e941ac4580" translate="yes" xml:space="preserve">
          <source>If the range runs out before &lt;code&gt;n&lt;/code&gt; elements, &lt;code&gt;take&lt;/code&gt; simply returns the entire range (unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, which will cause an assertion failure if the range ends prematurely):</source>
          <target state="translated">Si el rango se agota antes de &lt;code&gt;n&lt;/code&gt; elementos, &lt;code&gt;take&lt;/code&gt; simplemente devuelve todo el rango (a diferencia de &lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt; , lo que provocar&amp;aacute; un error de aserci&amp;oacute;n si el rango termina prematuramente):</target>
        </trans-unit>
        <trans-unit id="0bfb47486948f76918fc7de4a55b72efe69b4181" translate="yes" xml:space="preserve">
          <source>If the ranges are strings, &lt;code&gt;cmp&lt;/code&gt; performs UTF decoding appropriately and compares the ranges one code point at a time.</source>
          <target state="translated">Si los rangos son cadenas, &lt;code&gt;cmp&lt;/code&gt; realiza la decodificaci&amp;oacute;n UTF de manera apropiada y compara los rangos un punto de c&amp;oacute;digo a la vez.</target>
        </trans-unit>
        <trans-unit id="ea41ed6834ee0093fe72c06e40f7dc343689c14c" translate="yes" xml:space="preserve">
          <source>If the restrictions above are met, the following copy constructor is generated:</source>
          <target state="translated">Si se cumplen las restricciones anteriores,se genera el siguiente constructor de copias:</target>
        </trans-unit>
        <trans-unit id="7f1cd9d3b49d8a1f62d192e4c5f4c5d296e6ef4a" translate="yes" xml:space="preserve">
          <source>If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under). However, no attempt is made to deal with integer overflow if the return type is long.</source>
          <target state="translated">Si el tipo de retorno es int, y el resultado no puede caber en un int, entonces se usar&amp;aacute; el valor m&amp;aacute;s cercano que puede mantenerse en 32 bits (por &lt;code&gt;int.max&lt;/code&gt; tanto, int.max si se supera e &lt;code&gt;int.min&lt;/code&gt; si se reduce ) . Sin embargo, no se intenta tratar el desbordamiento de enteros si el tipo de retorno es largo.</target>
        </trans-unit>
        <trans-unit id="dd2f2570182620b9927043173b24e489663dd5b6" translate="yes" xml:space="preserve">
          <source>If the return value is not equal to x, the FE_INEXACT exception is raised.</source>
          <target state="translated">Si el valor de retorno no es igual a x,se eleva la excepción FE_INEXACT.</target>
        </trans-unit>
        <trans-unit id="d430fac68e42265828ef3bb0905404a148953d53" translate="yes" xml:space="preserve">
          <source>If the right-hand side is also a Checked but with a different hook or underlying type, the hook and underlying type of this Checked takes precedence.</source>
          <target state="translated">Si el lado derecho es también un Chequeado pero con un gancho o tipo subyacente diferente,el gancho y tipo subyacente de este Chequeado tiene prioridad.</target>
        </trans-unit>
        <trans-unit id="decd65c423494fe4dd1111ea2c9da5871cfb6a35" translate="yes" xml:space="preserve">
          <source>If the second argument's length is less than that of the range indexed, an exception is thrown.</source>
          <target state="translated">Si la longitud del segundo argumento es menor que la del rango indexado,se lanza una excepción.</target>
        </trans-unit>
        <trans-unit id="09c0c3ad5616d292e80fb1d35bad8dff429d7620" translate="yes" xml:space="preserve">
          <source>If the second character of &lt;code&gt;path&lt;/code&gt; is a colon (&lt;code&gt;':'&lt;/code&gt;), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</source>
          <target state="translated">Si el segundo car&amp;aacute;cter de la &lt;code&gt;path&lt;/code&gt; es un signo de dos puntos ( &lt;code&gt;':'&lt;/code&gt; ), el primer car&amp;aacute;cter se interpreta como una letra de unidad y debe estar en el rango AZ (no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas).</target>
        </trans-unit>
        <trans-unit id="c8d361e2ea8510e2f9b6eea1c593f762c25ea047" translate="yes" xml:space="preserve">
          <source>If the second operand is a pointer, and the first is an integral type, and the operator is &lt;code&gt;+&lt;/code&gt;, the operands are reversed and the pointer arithmetic just described is applied.</source>
          <target state="translated">Si el segundo operando es un puntero, y el primero es un tipo integral, y el operador es &lt;code&gt;+&lt;/code&gt; , los operandos se invierten y se aplica la aritm&amp;eacute;tica del puntero que se acaba de describir.</target>
        </trans-unit>
        <trans-unit id="32b0c9d866faa45199f7035225674aa790902392" translate="yes" xml:space="preserve">
          <source>If the sequence ending at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.  &lt;code&gt;cs&lt;/code&gt; indicates whether the comparisons are case sensitive.</source>
          <target state="translated">Si la secuencia que termina en &lt;code&gt;startIdx&lt;/code&gt; no representa un punto de c&amp;oacute;digo bien formado, se puede &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.utf.UTFException . &lt;code&gt;cs&lt;/code&gt; indica si las comparaciones distinguen entre may&amp;uacute;sculas y min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="a37342eba6058b3aa514ecc3e65805a0fa7ec8d8" translate="yes" xml:space="preserve">
          <source>If the sequence is a</source>
          <target state="translated">Si la secuencia es una</target>
        </trans-unit>
        <trans-unit id="6e3f474a691ae0e04c816db20a8a1ee2782164f2" translate="yes" xml:space="preserve">
          <source>If the sequence starting at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">Si la secuencia que comienza en &lt;code&gt;startIdx&lt;/code&gt; no representa un punto de c&amp;oacute;digo bien formado, se puede &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.utf.UTFException .</target>
        </trans-unit>
        <trans-unit id="2ca37c345a633b86c3f0a8d6f14512c0f7890283" translate="yes" xml:space="preserve">
          <source>If the sign bit is set (that is, it's 'negative'), NAN is less than any number; if the sign bit is not set (it is 'positive'), NAN is greater than any number;</source>
          <target state="translated">Si el bit del signo está configurado (es decir,es 'negativo'),NAN es menor que cualquier número;si el bit del signo no está configurado (es 'positivo'),NAN es mayor que cualquier número;</target>
        </trans-unit>
        <trans-unit id="ad31a32f0506299a66cf84413a7632e943786b66" translate="yes" xml:space="preserve">
          <source>If the signed type is larger than the unsigned type, the unsigned type is converted to the signed type.</source>
          <target state="translated">Si el tipo con firma es más grande que el tipo sin firma,el tipo sin firma se convierte en el tipo con firma.</target>
        </trans-unit>
        <trans-unit id="e9a551f8b9f105f8f42e469f990b7c6973a86a1b" translate="yes" xml:space="preserve">
          <source>If the slice bounds can be known at compile time, the slice expression is implicitly convertible to an lvalue of static array. For example:</source>
          <target state="translated">Si los límites de la rebanada pueden conocerse en el momento de la compilación,la expresión de la rebanada es implícitamente convertible a un valor de matriz estática.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6ad59f15848db49d072bd8cb912bde77ae2b6ed6" translate="yes" xml:space="preserve">
          <source>If the source file does not start with a BOM, then the first character must be less than or equal to U+0000007F.</source>
          <target state="translated">Si el archivo fuente no comienza con una lista de materiales,entonces el primer carácter debe ser menor o igual a U+0000007F.</target>
        </trans-unit>
        <trans-unit id="b27e4bb1c5315e54c4ca57d01e83f479ac84dbd7" translate="yes" xml:space="preserve">
          <source>If the string data is UTF-8 and can be accessed directly, return a pointer to it. Do not assume a terminating 0.</source>
          <target state="translated">Si los datos de la cadena son UTF-8 y se puede acceder a ellos directamente,devuelva un puntero a ellos.No asuma un 0 final.</target>
        </trans-unit>
        <trans-unit id="5f0ad93f155cd5ae6b24670f9767f5398de5e539" translate="yes" xml:space="preserve">
          <source>If the string does not contain an ampersand, the original will be returned.</source>
          <target state="translated">Si la cuerda no contiene un ampersand,el original será devuelto.</target>
        </trans-unit>
        <trans-unit id="1aa7c7c38f043029163560616539bec8cc7f49c1" translate="yes" xml:space="preserve">
          <source>If the string is not a legitimate IPv4 address, &lt;code&gt;ADDR_NONE&lt;/code&gt; is returned.</source>
          <target state="translated">Si la cadena no es una direcci&amp;oacute;n IPv4 leg&amp;iacute;tima, se devuelve &lt;code&gt;ADDR_NONE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b15b906e5c8636437606a7baf9615fdd3533eb67" translate="yes" xml:space="preserve">
          <source>If the string is not modified, the original will be returned.</source>
          <target state="translated">Si la cadena no se modifica,se devolverá el original.</target>
        </trans-unit>
        <trans-unit id="52f9a3df378000710aaee65a7a54a47ac2ca66c0" translate="yes" xml:space="preserve">
          <source>If the struct defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is StructName(field&lt;sub&gt;0&lt;/sub&gt;, field&lt;sub&gt;1&lt;/sub&gt;, ...) where field&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">Si la estructura define un m&amp;eacute;todo &lt;b&gt;toString ()&lt;/b&gt; , el resultado es la cadena devuelta por esta funci&amp;oacute;n. De lo contrario, el resultado es StructName (campo &lt;sub&gt;0&lt;/sub&gt; , campo &lt;sub&gt;1&lt;/sub&gt; , ...) donde el campo &lt;sub&gt;n&lt;/sub&gt; es el en&amp;eacute;simo elemento formateado con el formato predeterminado.</target>
        </trans-unit>
        <trans-unit id="479988510a7f9556e5fa41c90de2fc0cc635572b" translate="yes" xml:space="preserve">
          <source>If the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is of enum type, all the enum members must appear in the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;s.</source>
          <target state="translated">Si el modificador &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; es de tipo enum, todos los miembros de enum deben aparecer en &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="a0154ff095266436fcdfa44d46155c17b50639bb" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values: 1. &quot;run-main&quot;: even if unit tests are run (and all pass), main is still run. This is currently the default. 2. &quot;test-or-main&quot;: any unit tests present will cause the program to summarize the results and exit regardless of the result. This will be the default in 2.080. 3. &quot;test-only&quot;, the runtime will always summarize and never run main, even if no tests are present.</source>
          <target state="translated">Si el &lt;code&gt;--DRT-testmode&lt;/code&gt; se pasa al ejecutable, puede tener uno de 3 valores: 1. &quot;run-main&quot;: incluso si se ejecutan las pruebas unitarias (y todas pasan), main todav&amp;iacute;a se ejecuta. Este es actualmente el valor predeterminado. 2. &quot;test-or-main&quot;: cualquier prueba unitaria presente har&amp;aacute; que el programa resuma los resultados y salga independientemente del resultado. Este ser&amp;aacute; el valor predeterminado en 2.080. 3. &quot;solo prueba&quot;, el tiempo de ejecuci&amp;oacute;n siempre resumir&amp;aacute; y nunca ejecutar&amp;aacute; main, incluso si no hay pruebas presentes.</target>
        </trans-unit>
        <trans-unit id="cefab3eab3f045d8e153ce4eb6c35b376eb78553" translate="yes" xml:space="preserve">
          <source>If the thread hasn't been started yet, returns &lt;a href=&quot;#ThreadID&quot;&gt;&lt;code&gt;ThreadID&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.init&lt;/code&gt;. Otherwise, returns the result of &lt;code&gt;GetCurrentThreadId&lt;/code&gt; on Windows, and &lt;code&gt;pthread_self&lt;/code&gt; on POSIX.  The value is unique for the current process.</source>
          <target state="translated">Si el hilo a&amp;uacute;n no se ha iniciado, devuelve &lt;a href=&quot;#ThreadID&quot;&gt; &lt;code&gt;ThreadID&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.init&lt;/code&gt; . De lo contrario, devuelve el resultado de &lt;code&gt;GetCurrentThreadId&lt;/code&gt; en Windows y &lt;code&gt;pthread_self&lt;/code&gt; en POSIX. El valor es &amp;uacute;nico para el proceso actual.</target>
        </trans-unit>
        <trans-unit id="6c09982745040566b9680ca05a80be2c692c0e01" translate="yes" xml:space="preserve">
          <source>If the time zone is &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (or considered to be equivalent to &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; by section 4.3 of the spec), a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; with a utc offset of &lt;code&gt;0&lt;/code&gt; is used rather than &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, whereas &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si la zona horaria es &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (o se considera equivalente a &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; en la secci&amp;oacute;n 4.3 de la especificaci&amp;oacute;n), se &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt; un std.datetime.timezone.SimpleTimeZone con un desplazamiento de utc de &lt;code&gt;0&lt;/code&gt; en lugar de &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; , mientras que &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; usa &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3134e4dcc33577153221f4543bd47086f16438e4" translate="yes" xml:space="preserve">
          <source>If the two arguments are both lambda functions (or aliases to lambda functions), then they are compared for equality. For the comparison to be computed correctly, the following conditions must be met for both lambda functions:</source>
          <target state="translated">Si los dos argumentos son funciones lambda (o alias de funciones lambda),entonces se comparan por igualdad.Para que la comparación se calcule correctamente,deben cumplirse las siguientes condiciones para ambas funciones lambda:</target>
        </trans-unit>
        <trans-unit id="73a39971fe15042884479dfdbb241d4da31bea94" translate="yes" xml:space="preserve">
          <source>If the two arguments are expressions made up of literals or enums that evaluate to the same value, true is returned.</source>
          <target state="translated">Si los dos argumentos son expresiones compuestas de literales o enums que se evalúan al mismo valor,se devuelve la verdad.</target>
        </trans-unit>
        <trans-unit id="a4473404d01a76d50b04f7848135307a27ac80f3" translate="yes" xml:space="preserve">
          <source>If the two operands are different enums, the result is the closest base type common to both. A base type being closer means there is a shorter sequence of conversions to base type to get there from the original type.</source>
          <target state="translated">Si los dos operandos son enums diferentes,el resultado es el tipo de base más cercano común a ambos.El hecho de que un tipo base esté más cerca significa que hay una secuencia más corta de conversiones a tipo base para llegar al tipo original.</target>
        </trans-unit>
        <trans-unit id="b866fed7529b50ec607a768135519745618bce85" translate="yes" xml:space="preserve">
          <source>If the type is a class or struct, returns the symbol for it, else null.</source>
          <target state="translated">Si el tipo es una clase o estructura,devuelve el símbolo de la misma,si no,es nulo.</target>
        </trans-unit>
        <trans-unit id="9cf47ab4617bfcf6525f2e55361b003e49f6a33c" translate="yes" xml:space="preserve">
          <source>If the type of a function literal can be uniquely determined from its context, the parameter type inference is possible.</source>
          <target state="translated">Si el tipo de una función literal puede determinarse de manera única a partir de su contexto,la inferencia del tipo de parámetro es posible.</target>
        </trans-unit>
        <trans-unit id="bd9e26eaa127a0681e40e687c51d18388c1cb11f" translate="yes" xml:space="preserve">
          <source>If the type specialization is dependent on a type parameter, the type of that parameter is set to be the corresponding part of the type argument.</source>
          <target state="translated">Si la especialización del tipo depende de un parámetro de tipo,el tipo de ese parámetro se establece como la parte correspondiente del argumento de tipo.</target>
        </trans-unit>
        <trans-unit id="c38cd0e42755b32d0615eb6b41299ea06a9e9a58" translate="yes" xml:space="preserve">
          <source>If the union defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is the name of the union, without its contents.</source>
          <target state="translated">Si la uni&amp;oacute;n define un m&amp;eacute;todo &lt;b&gt;toString ()&lt;/b&gt; , el resultado es la cadena devuelta por esta funci&amp;oacute;n. De lo contrario, el resultado es el nombre de la uni&amp;oacute;n, sin su contenido.</target>
        </trans-unit>
        <trans-unit id="5b79753b6512691a7580a1aa8dec230051399447" translate="yes" xml:space="preserve">
          <source>If the union is larger than the first field, the remaining bits are set to 0.</source>
          <target state="translated">Si la unión es más grande que el primer campo,los bits restantes se ponen a 0.</target>
        </trans-unit>
        <trans-unit id="47d795dfceba0f8eb2492f885994a47e15c6743a" translate="yes" xml:space="preserve">
          <source>If the union is larger than the initialized field, the remaining bits are set to 0.</source>
          <target state="translated">Si la unión es mayor que el campo inicializado,los bits restantes se ponen a 0.</target>
        </trans-unit>
        <trans-unit id="c1ceb76e55274ade5913babacd57bf4f1cb70312" translate="yes" xml:space="preserve">
          <source>If the user-provided size is zero or the user-provided buffer is empty, throws an &lt;code&gt;Exception&lt;/code&gt;. In case of an I/O error throws &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">Si el tama&amp;ntilde;o proporcionado por el usuario es cero o el b&amp;uacute;fer proporcionado por el usuario est&amp;aacute; vac&amp;iacute;o, genera una &lt;code&gt;Exception&lt;/code&gt; . En caso de un error de E / S, lanza &lt;code&gt;StdioException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc7558759f1a8352a99aba9fedf7f766fc85394c" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, it will be created. If it already exists, it will be overwritten.</source>
          <target state="translated">Si la variable no existe,se creará.Si ya existe,se sobrescribirá.</target>
        </trans-unit>
        <trans-unit id="1eb649b3e71267d6372924b026c8a8d1534bf07a" translate="yes" xml:space="preserve">
          <source>If the variable isn't in the environment, this function returns successfully without doing anything.</source>
          <target state="translated">Si la variable no está en el ambiente,esta función regresa con éxito sin hacer nada.</target>
        </trans-unit>
        <trans-unit id="d13d09fdf461257eb1bc31ba932d5204cebf3e15" translate="yes" xml:space="preserve">
          <source>If the variadic parameter is an array of delegates with no parameters:</source>
          <target state="translated">Si el parámetro variado es un conjunto de delegados sin parámetros:</target>
        </trans-unit>
        <trans-unit id="a4c2f19305902bafa0ffed68f37389b9cbdc3d33" translate="yes" xml:space="preserve">
          <source>If there are fewer arguments supplied in the</source>
          <target state="translated">Si hay menos argumentos suministrados en el</target>
        </trans-unit>
        <trans-unit id="137908701928a250c21674b47c9c08664cb6489d" translate="yes" xml:space="preserve">
          <source>If there are multiple</source>
          <target state="translated">Si hay múltiples</target>
        </trans-unit>
        <trans-unit id="9d520e5d39ca368a2b272ce1cc53485c938b54ac" translate="yes" xml:space="preserve">
          <source>If there are multiple &lt;code&gt;return ref&lt;/code&gt; parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</source>
          <target state="translated">Si hay varios par&amp;aacute;metros de &lt;code&gt;return ref&lt;/code&gt; , la vida &amp;uacute;til del valor de retorno es la vida &amp;uacute;til m&amp;aacute;s peque&amp;ntilde;a de los argumentos correspondientes.</target>
        </trans-unit>
        <trans-unit id="e237e9fe68b8078484793ae54d1c1e4290772666" translate="yes" xml:space="preserve">
          <source>If there are multiple UDAs in scope for a declaration, they are concatenated:</source>
          <target state="translated">Si hay múltiples UDA en el ámbito de una declaración,se concatenan:</target>
        </trans-unit>
        <trans-unit id="d33b5562bbab16d600772bb0c4e960b31c667c22" translate="yes" xml:space="preserve">
          <source>If there are multiple pragma inlines in a function, the lexically last one takes effect.</source>
          <target state="translated">Si hay múltiples líneas pragmáticas en una función,la última léxica hace efecto.</target>
        </trans-unit>
        <trans-unit id="c4b327a5dc42638f7be9041ec07ceb89c1cacdad" translate="yes" xml:space="preserve">
          <source>If there are no arguments, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si no hay argumentos, el resultado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4600b295ae3596b41be4670d227eb72326970dd" translate="yes" xml:space="preserve">
          <source>If there are no user-defined attributes for the symbol, an empty tuple is returned. The expression tuple can be turned into a manipulatable tuple:</source>
          <target state="translated">Si no hay atributos definidos por el usuario para el símbolo,se devuelve una tupla vacía.La expresión tupla puede convertirse en una tupla manipulable:</target>
        </trans-unit>
        <trans-unit id="e49abc2a9f1f1c709edab2a411a4d0eb933f0f8e" translate="yes" xml:space="preserve">
          <source>If there are two symbols declared, the first is the</source>
          <target state="translated">Si hay dos símbolos declarados,el primero es el</target>
        </trans-unit>
        <trans-unit id="3df841c41211bfc9016bcff2ddd45752571711df" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;new (&lt;/code&gt;&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, then those arguments are passed to the class or struct specific &lt;a href=&quot;class#allocators&quot;&gt;allocator function&lt;/a&gt; after the size argument.</source>
          <target state="translated">Si hay una &lt;code&gt;new (&lt;/code&gt; &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; &lt;code&gt;)&lt;/code&gt; , esos argumentos se pasan a la &lt;a href=&quot;class#allocators&quot;&gt;funci&amp;oacute;n de asignaci&amp;oacute;n&lt;/a&gt; espec&amp;iacute;fica de clase o estructura despu&amp;eacute;s del argumento de tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="4a441171bce481c9de8d817376b233adfcdc1d3d" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the class, the constructor matching the argument list is called.</source>
          <target state="translated">Si hay un constructor definido para la clase,se llama al constructor que coincide con la lista de argumentos.</target>
        </trans-unit>
        <trans-unit id="2b9a54f4a31088d1176dc7dd4ca3c5a15fce19ea" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the struct, the constructor matching the argument list is called.</source>
          <target state="translated">Si hay un constructor definido para la estructura,se llama al constructor que coincide con la lista de argumentos.</target>
        </trans-unit>
        <trans-unit id="6070235a5fc84c6102f81ad3d99d47f62b8d7355" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, it must evaluate to either an Object or an instance of an</source>
          <target state="translated">Si hay una &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expresi&amp;oacute;n&lt;/i&gt;&lt;/a&gt; , debe evaluar un Objeto o una instancia de un</target>
        </trans-unit>
        <trans-unit id="5a13d6eff463d638a1f16cd2e1b1291d41f27d35" translate="yes" xml:space="preserve">
          <source>If there is an out postcondition (see &lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;), that postcondition is executed after the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is evaluated and before the function actually returns.</source>
          <target state="translated">Si hay una condici&amp;oacute;n posterior fuera (ver &lt;a href=&quot;contracts&quot;&gt;Programaci&amp;oacute;n del contrato&lt;/a&gt; ), esa condici&amp;oacute;n posterior se ejecuta despu&amp;eacute;s de evaluar la &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expresi&amp;oacute;n&lt;/i&gt;&lt;/a&gt; y antes de que la funci&amp;oacute;n realmente regrese.</target>
        </trans-unit>
        <trans-unit id="f306e547fcde96fa296d39ba4173abf9b358bd47" translate="yes" xml:space="preserve">
          <source>If there is more than one &lt;code&gt;scope&lt;/code&gt; variable going out of scope at the same point, then the destructors are called in the reverse order that the variables were constructed.</source>
          <target state="translated">Si hay m&amp;aacute;s de un &lt;code&gt;scope&lt;/code&gt; variable de ir fuera de alcance en el mismo punto, entonces los destructores se llaman en el orden inverso que las variables se construyeron.</target>
        </trans-unit>
        <trans-unit id="f9d4b8b7f08b3f6307ae69aa1e6c9c14710481c3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is not the first</source>
          <target state="translated">Si no hay &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; y no es el primero</target>
        </trans-unit>
        <trans-unit id="b034aafdece95219928b4d5ae1779c324d51f861" translate="yes" xml:space="preserve">
          <source>If there is no constructor for a class, but there is a constructor for the base class, a default constructor is implicitly generated with the form:</source>
          <target state="translated">Si no hay un constructor para una clase,pero sí para la clase base,se genera implícitamente un constructor por defecto con la forma:</target>
        </trans-unit>
        <trans-unit id="8a089796c9cda4645dac5b38c15d592eebc4d1ab" translate="yes" xml:space="preserve">
          <source>If there is no default return expression and the predicate does not yield true with any test expression - &lt;code&gt;SwitchError&lt;/code&gt; is thrown. &lt;code&gt;SwitchError&lt;/code&gt; is also thrown if a void return expression was executed without throwing anything.</source>
          <target state="translated">Si no hay una expresi&amp;oacute;n de retorno predeterminada y el predicado no da verdadero con ninguna expresi&amp;oacute;n de prueba, se lanza &lt;code&gt;SwitchError&lt;/code&gt; . &lt;code&gt;SwitchError&lt;/code&gt; tambi&amp;eacute;n se lanza si se ejecut&amp;oacute; una expresi&amp;oacute;n de retorno nulo sin arrojar nada.</target>
        </trans-unit>
        <trans-unit id="9c729a22e9cf50dfda75e0983406587bf80017e7" translate="yes" xml:space="preserve">
          <source>If there is no documentation comment for a declaration, that declaration may not appear in the output. To ensure it does appear in the output, put an empty declaration comment for it.</source>
          <target state="translated">Si no hay ningún comentario de documentación para una declaración,es posible que esa declaración no aparezca en el resultado.Para asegurarse de que aparece en la salida,ponga un comentario de declaración vacío para ella.</target>
        </trans-unit>
        <trans-unit id="6fce9903fe99732c7b1d983701bee8c33b687b65" translate="yes" xml:space="preserve">
          <source>If there is no time zone in the string, then &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is used. If the time zone is &quot;Z&quot;, then &lt;code&gt;UTC&lt;/code&gt; is used. Otherwise, a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; which corresponds to the given offset from UTC is used. To get the returned &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be a particular time zone, pass in that time zone and the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string).</source>
          <target state="translated">Si no hay zona horaria en la cadena, se usa &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; . Si la zona horaria es &quot;Z&quot;, se usa &lt;code&gt;UTC&lt;/code&gt; . De lo contrario, se &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt; un std.datetime.timezone.SimpleTimeZone que corresponde al desplazamiento dado desde UTC. Para que el &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; devuelto sea ​​una zona horaria particular, pase esa zona horaria y el &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; que se devolver&amp;aacute; se convertir&amp;aacute; a esa zona horaria (aunque todav&amp;iacute;a se leer&amp;aacute; como cualquier zona horaria en su cadena).</target>
        </trans-unit>
        <trans-unit id="ecb767820c42d2c1eeab40ca9731a8e9ce9ec854" translate="yes" xml:space="preserve">
          <source>If there is no type specialization for the parameter, the type of the parameter is set to the template argument.</source>
          <target state="translated">Si no hay una especialización de tipo para el parámetro,el tipo del parámetro se establece en el argumento de la plantilla.</target>
        </trans-unit>
        <trans-unit id="333c6091877decb710b52473531fc9677d023463" translate="yes" xml:space="preserve">
          <source>If there is only one member of an anonymous enum, the &lt;code&gt;{ }&lt;/code&gt; can be omitted. Gramatically speaking, this is an &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Si solo hay un miembro de una enumeraci&amp;oacute;n an&amp;oacute;nima, se puede omitir el &lt;code&gt;{ }&lt;/code&gt; . Gramaticalmente hablando, esta es una &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;Autodeclaraci&amp;oacute;n&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81c7998e55322be143bbc65f832d80e17d966603" translate="yes" xml:space="preserve">
          <source>If there's no handler for a particular error, it is handled by the runtime library default handler. If an error is ignored, it is because the programmer specifically added code to ignore an error, which presumably means it was intentional.</source>
          <target state="translated">Si no hay un controlador para un error en particular,se maneja por el controlador predeterminado de la biblioteca en tiempo de ejecución.Si se ignora un error,es porque el programador añadió específicamente código para ignorar un error,lo que presumiblemente significa que fue intencionado.</target>
        </trans-unit>
        <trans-unit id="1504a8955edcaca212d8f1b4743a707d2ef9fdb6" translate="yes" xml:space="preserve">
          <source>If these constraints aren't fulfilled, the function is considered incomparable and &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si no se cumplen estas restricciones, la funci&amp;oacute;n se considera incomparable e &lt;code&gt;isSame&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b28035cefdbe2f2deeefc61501ea02f89e4a353d" translate="yes" xml:space="preserve">
          <source>If they are both null, then they are equal. If one is null and the other is not, then they are not equal. If they are both non-null, then they are equal if their values are equal.</source>
          <target state="translated">Si ambos son nulos,entonces son iguales.Si uno es nulo y el otro no,entonces no son iguales.Si ambos son no nulos,entonces son iguales si sus valores son iguales.</target>
        </trans-unit>
        <trans-unit id="4662c9e57a2220461566af34d1a71bfb063d8fd6" translate="yes" xml:space="preserve">
          <source>If they compare equal, return 0 else value returned by fp.</source>
          <target state="translated">Si se comparan iguales,devuelven 0 de otro valor devuelto por fp.</target>
        </trans-unit>
        <trans-unit id="489bf198a6a75e62f83ca7fe9ee2482aa193539d" translate="yes" xml:space="preserve">
          <source>If they have range interface, formatted as input range.</source>
          <target state="translated">Si tienen interfaz de rango,formateado como rango de entrada.</target>
        </trans-unit>
        <trans-unit id="a2e48f2bb2a2bc86917d71f83c2b5a6ff9f995c9" translate="yes" xml:space="preserve">
          <source>If they have the same ptrs, return 1 else 0.</source>
          <target state="translated">Si tienen los mismos ptrs,devuelve 1 0 más.</target>
        </trans-unit>
        <trans-unit id="2bac3ec55e8f026836fad11da1a5ea396ba6c7f1" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +0100 or -0700). Note that the offset from UTC is</source>
          <target state="translated">Si esto &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 's zona horaria es &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; , a continuaci&amp;oacute;n, TZ est&amp;aacute; vac&amp;iacute;a. Si su zona horaria es &lt;code&gt;UTC&lt;/code&gt; , entonces es &quot;Z&quot;. De lo contrario, es el desplazamiento desde UTC (por ejemplo, +0100 o -0700). Tenga en cuenta que el desplazamiento desde UTC es</target>
        </trans-unit>
        <trans-unit id="2c514f7eb520c6d91b2201391b00ffde6396be0d" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is</source>
          <target state="translated">Si esto &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 's zona horaria es &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; , a continuaci&amp;oacute;n, TZ est&amp;aacute; vac&amp;iacute;a. Si su zona horaria es &lt;code&gt;UTC&lt;/code&gt; , entonces es &quot;Z&quot;. De lo contrario, es el desplazamiento desde UTC (por ejemplo, +01: 00 o -07: 00). Tenga en cuenta que el desplazamiento desde UTC es</target>
        </trans-unit>
        <trans-unit id="59b4585a3a599edf4de86352eceb935135d14f4b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), and that null value is not given for &lt;code&gt;nullValue&lt;/code&gt;, then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by using &lt;code&gt;T&lt;/code&gt;'s &quot;built in&quot; null value for &lt;code&gt;nullValue&lt;/code&gt;.</source>
          <target state="translated">Si este &lt;code&gt;Nullable&lt;/code&gt; envuelve un tipo que ya tiene un valor nulo (como un puntero), y ese valor nulo no se da para &lt;code&gt;nullValue&lt;/code&gt; , entonces asignar el valor nulo a este &lt;code&gt;Nullable&lt;/code&gt; no es diferente de asignar cualquier otro valor de tipo &lt;code&gt;T&lt;/code&gt; , y El c&amp;oacute;digo resultante se ver&amp;aacute; muy extra&amp;ntilde;o. Se recomienda encarecidamente que este puede evitar utilizando &lt;code&gt;T&lt;/code&gt; 's 'construido en' valor nulo para &lt;code&gt;nullValue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bacbc660925702039182b51b563933523f30696f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of &lt;code&gt;Nullable&lt;/code&gt; that takes an additional &lt;code&gt;nullValue&lt;/code&gt; template argument.</source>
          <target state="translated">Si este &lt;code&gt;Nullable&lt;/code&gt; envuelve un tipo que ya tiene un valor nulo (como un puntero), entonces asignar el valor nulo a este &lt;code&gt;Nullable&lt;/code&gt; no es diferente de asignar cualquier otro valor de tipo &lt;code&gt;T&lt;/code&gt; , y el c&amp;oacute;digo resultante se ver&amp;aacute; muy extra&amp;ntilde;o. Se recomienda encarecidamente que esto se evite utilizando en su lugar la versi&amp;oacute;n de &lt;code&gt;Nullable&lt;/code&gt; que tome un argumento de plantilla &lt;code&gt;nullValue&lt;/code&gt; adicional .</target>
        </trans-unit>
        <trans-unit id="7febe77abd33adf57e913bf0a4a63eb358541f75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Task&lt;/code&gt; was not started yet, execute it in the current thread. If it is finished, return its result. If it is in progress, execute any other &lt;code&gt;Task&lt;/code&gt; from the &lt;code&gt;TaskPool&lt;/code&gt; instance that this &lt;code&gt;Task&lt;/code&gt; was submitted to until this one is finished. If it threw an exception, rethrow that exception. If no other tasks are available or this &lt;code&gt;Task&lt;/code&gt; was executed using &lt;code&gt;executeInNewThread&lt;/code&gt;, wait on a condition variable.</source>
          <target state="translated">Si esta &lt;code&gt;Task&lt;/code&gt; a&amp;uacute;n no se inici&amp;oacute;, ejec&amp;uacute;tela en el hilo actual. Si est&amp;aacute; terminado, devuelva su resultado. Si est&amp;aacute; en progreso, ejecute cualquier otra &lt;code&gt;Task&lt;/code&gt; desde la instancia de &lt;code&gt;TaskPool&lt;/code&gt; a la que se envi&amp;oacute; esta &lt;code&gt;Task&lt;/code&gt; hasta que finalice. Si arroj&amp;oacute; una excepci&amp;oacute;n, vuelva a lanzar esa excepci&amp;oacute;n. Si no hay otras tareas disponibles o si esta &lt;code&gt;Task&lt;/code&gt; se ejecut&amp;oacute; mediante &lt;code&gt;executeInNewThread&lt;/code&gt; , espere una variable de condici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="02c1e520b882980c80752c1365bf55b4375ba858" translate="yes" xml:space="preserve">
          <source>If this declaration is compliant with any particular standard, the description of it goes here.</source>
          <target state="translated">Si esta declaración cumple con alguna norma en particular,la descripción de la misma va aquí.</target>
        </trans-unit>
        <trans-unit id="13a2f9d3fe709668a2bc4c5dc3f8ab6e710fca1e" translate="yes" xml:space="preserve">
          <source>If this is a reference, dereference it.</source>
          <target state="translated">Si esto es una referencia,derríbela.</target>
        </trans-unit>
        <trans-unit id="4f2c995ebc62fdd08dead47122c9bc13fad7a76d" translate="yes" xml:space="preserve">
          <source>If this is a shell around another type, get that other type.</source>
          <target state="translated">Si se trata de un caparazón alrededor de otro tipo,consigue ese otro tipo.</target>
        </trans-unit>
        <trans-unit id="b5dc509f5b8b27fb2d7cf6170c77f1c20cada7e8" translate="yes" xml:space="preserve">
          <source>If this is a type of something, return that something.</source>
          <target state="translated">Si esto es un tipo de algo,devuelve ese algo.</target>
        </trans-unit>
        <trans-unit id="78983652ba5d9285bc5419929ba9f7e7d2014654" translate="yes" xml:space="preserve">
          <source>If this is a type of static array, return its base element type.</source>
          <target state="translated">Si se trata de un tipo de conjunto estático,devuelva su tipo de elemento base.</target>
        </trans-unit>
        <trans-unit id="11053146fa2d89a0863002bf2113f6a22908ad90" translate="yes" xml:space="preserve">
          <source>If this lock is not already held by the caller, the lock is acquired, then the internal counter is incremented by one.</source>
          <target state="translated">Si esta cerradura no está ya en manos de la persona que llama,la cerradura se adquiere,entonces el contador interno se incrementa en uno.</target>
        </trans-unit>
        <trans-unit id="7f2c76fc93c2cea506533b01d671704af3859af8" translate="yes" xml:space="preserve">
          <source>If this statement has code that needs to run in a finally clause at the end of the current scope, return that code in the form of a Statement.</source>
          <target state="translated">Si esta declaración tiene un código que necesita ejecutarse en una cláusula final al final del alcance actual,devuelva ese código en forma de una declaración.</target>
        </trans-unit>
        <trans-unit id="0515fd6aa93cc22acea186af17b617bb6900cccc" translate="yes" xml:space="preserve">
          <source>If this symbol is really an alias for another, return that other. If needed, semantic() is invoked due to resolve forward reference.</source>
          <target state="translated">Si este símbolo es realmente un alias para otro,devuelva ese otro.Si es necesario,se invoca semantic()para resolver la referencia de avance.</target>
        </trans-unit>
        <trans-unit id="0d671d5e8525a56282bf3d43e4b2c8ef0fff443b" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Checked&lt;/code&gt; instances are involved in a binary operation and both define &lt;code&gt;hookOpBinary&lt;/code&gt;, the left-hand side hook has priority. If both define &lt;code&gt;onOverflow&lt;/code&gt;, a compile-time error occurs.</source>
          <target state="translated">Si dos &lt;code&gt;Checked&lt;/code&gt; casos est&amp;aacute;n implicadas en una operaci&amp;oacute;n binaria y ambos definen &lt;code&gt;hookOpBinary&lt;/code&gt; , el gancho de la parte izquierda tiene prioridad. Si ambos definen &lt;code&gt;onOverflow&lt;/code&gt; , se produce un error en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="000877fa3e86af7fe8754c0a2ea9639fca32104e" translate="yes" xml:space="preserve">
          <source>If two different mixins are put in the same scope, and each define a declaration with the same name, there is an ambiguity error when the declaration is referenced:</source>
          <target state="translated">Si dos mezclas diferentes se ponen en el mismo ámbito,y cada una de ellas define una declaración con el mismo nombre,se produce un error de ambigüedad al referirse a la declaración:</target>
        </trans-unit>
        <trans-unit id="a3bad367e89a048e204fc75a01e068c90ffc4712" translate="yes" xml:space="preserve">
          <source>If two or more functions have the same match level, then</source>
          <target state="translated">Si dos o más funciones tienen el mismo nivel de coincidencia,entonces</target>
        </trans-unit>
        <trans-unit id="329ee511107dbe6e7abc063f46dd137916ba7624" translate="yes" xml:space="preserve">
          <source>If unit tests are not enabled, the implementation is not required to check the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; for syntactic or semantic correctness. This is to reduce the compile time impact of larger unit test sections. The tokens must still be valid, and the implementation can merely count &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; tokens to find the end of the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt;'s &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Si las pruebas unitarias no est&amp;aacute;n habilitadas, no es necesario que la implementaci&amp;oacute;n verifique si &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest tiene&lt;/i&gt;&lt;/a&gt; una correcci&amp;oacute;n sint&amp;aacute;ctica o sem&amp;aacute;ntica. Esto es para reducir el impacto en el tiempo de compilaci&amp;oacute;n de secciones de prueba unitarias m&amp;aacute;s grandes. Las fichas deben ser v&amp;aacute;lidas todav&amp;iacute;a, y la puesta en pr&amp;aacute;ctica s&amp;oacute;lo se puede contar &lt;code&gt;{&lt;/code&gt; y &lt;code&gt;}&lt;/code&gt; fichas para encontrar el final de la &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;unittest&lt;/i&gt;&lt;/a&gt; 's &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9627f657eafec4f6faa68074956b9ef2912cb7d7" translate="yes" xml:space="preserve">
          <source>If variable has a const initializer, return that initializer.</source>
          <target state="translated">Si la variable tiene un inicializador constante,devuelva ese inicializador.</target>
        </trans-unit>
        <trans-unit id="efa87bbfad2d81b3124f9c28a0c2e92ac37d7e01" translate="yes" xml:space="preserve">
          <source>If variable has a constant expression initializer, get it. Otherwise, return null.</source>
          <target state="translated">Si la variable tiene un inicializador de expresión constante,consígalo.Si no,devuelve nulo.</target>
        </trans-unit>
        <trans-unit id="129f6b693e38ba5e18679007098a9df7fc61bc3f" translate="yes" xml:space="preserve">
          <source>If vector extensions are implemented, the &lt;a href=&quot;version#PredefinedVersions&quot;&gt;version identifier&lt;/a&gt;&lt;code&gt;D_SIMD&lt;/code&gt; is set.</source>
          <target state="translated">Si se implementan extensiones de vector, se establece el &lt;a href=&quot;version#PredefinedVersions&quot;&gt;identificador de versi&amp;oacute;n &lt;/a&gt; &lt;code&gt;D_SIMD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adbc7bef2337da263c5a713fbb0e840af6633adb" translate="yes" xml:space="preserve">
          <source>If we want the value of this expression, but do not want to call the destructor on it.</source>
          <target state="translated">Si queremos el valor de esta expresión,pero no queremos llamar al destructor en ella.</target>
        </trans-unit>
        <trans-unit id="79988e7c16e0dced67dee802d9bdb6de78ec6132" translate="yes" xml:space="preserve">
          <source>If x is not a special value, the result is the same as &lt;code&gt;cast(int) logb(x)&lt;/code&gt;.</source>
          <target state="translated">Si x no es un valor especial, el resultado es el mismo que &lt;code&gt;cast(int) logb(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bffad47163601102b19e67fa92a8c3feda0166ec" translate="yes" xml:space="preserve">
          <source>If x is subnormal, it is treated as if it were normalized. For a positive, finite x:</source>
          <target state="translated">Si x es subnormal,se trata como si estuviera normalizada.Para una x positiva y finita:</target>
        </trans-unit>
        <trans-unit id="92c403e0084ea037260c41da9c4c7e544a7d2d08" translate="yes" xml:space="preserve">
          <source>If y &amp;gt; x, the result will be the next largest floating-point value; if y &amp;lt; x, the result will be the next smallest value. If x == y, the result is y.</source>
          <target state="translated">Si y&amp;gt; x, el resultado ser&amp;aacute; el siguiente valor de punto flotante m&amp;aacute;s grande; si y &amp;lt;x, el resultado ser&amp;aacute; el siguiente valor m&amp;aacute;s peque&amp;ntilde;o. Si x == y, el resultado es y.</target>
        </trans-unit>
        <trans-unit id="51868f820cebc5e3c544468e6d407c4bd6b45485" translate="yes" xml:space="preserve">
          <source>If you have a small buffer you can use &lt;a href=&quot;#compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#uncompress&quot;&gt;&lt;code&gt;uncompress&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">Si tiene un b&amp;uacute;fer peque&amp;ntilde;o, puede usar &lt;a href=&quot;#compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#uncompress&quot;&gt; &lt;code&gt;uncompress&lt;/code&gt; &lt;/a&gt; directamente.</target>
        </trans-unit>
        <trans-unit id="b65e14bf08e45286eb114c69d33e8aa407bf4bbd" translate="yes" xml:space="preserve">
          <source>If you omit &lt;code&gt;Rhs&lt;/code&gt;, &lt;code&gt;isAssignable&lt;/code&gt; will check identity assignable of &lt;code&gt;Lhs&lt;/code&gt;.</source>
          <target state="translated">Si omite &lt;code&gt;Rhs&lt;/code&gt; , &lt;code&gt;isAssignable&lt;/code&gt; verificar&amp;aacute; la identidad asignable de &lt;code&gt;Lhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14961e1fccbf1736d47a52df390592d594e9109a" translate="yes" xml:space="preserve">
          <source>If you select &lt;code&gt;precise&lt;/code&gt; as the garbage collector via the options above, type information will be used to identify actual or possible pointers or references within heap allocated data objects. Non-pointer data will not be interpreted as a reference to other memory as a &quot;false pointer&quot;. The collector has to make pessimistic assumptions if a memory slot can contain both a pointer or an integer value, it will still be scanned (e.g. in a &lt;code&gt;union&lt;/code&gt;).</source>
          <target state="translated">Si selecciona con &lt;code&gt;precise&lt;/code&gt; como el recolector de basura a trav&amp;eacute;s de las opciones anteriores, la informaci&amp;oacute;n de tipo se utilizar&amp;aacute; para identificar punteros o referencias reales o posibles dentro de los objetos de datos asignados en el mont&amp;oacute;n. Los datos sin puntero no se interpretar&amp;aacute;n como una referencia a otra memoria como un &quot;puntero falso&quot;. El recopilador tiene que hacer suposiciones pesimistas si una ranura de memoria puede contener tanto un puntero como un valor entero, a&amp;uacute;n se escanear&amp;aacute; (por ejemplo, en una &lt;code&gt;union&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cbade680aa6ce4b2eee3b550013b504b2359a76c" translate="yes" xml:space="preserve">
          <source>If you use the GC memory functions from &lt;code&gt;core.memory&lt;/code&gt;, and plan to use it for data with a mixture of pointers and non-pointer data you should pass the TypeInfo of your allocated struct, class or type as the optional parameter. The default &lt;code&gt;null&lt;/code&gt; is interpreted as memory that might contain pointers everywhere.</source>
          <target state="translated">Si usa las funciones de memoria del GC de &lt;code&gt;core.memory&lt;/code&gt; y planea usarlo para datos con una combinaci&amp;oacute;n de punteros y datos sin puntero, debe pasar el TypeInfo de su estructura, clase o tipo asignado como par&amp;aacute;metro opcional. El valor &lt;code&gt;null&lt;/code&gt; predeterminado se interpreta como memoria que puede contener punteros en todas partes.</target>
        </trans-unit>
        <trans-unit id="50a53d6760e4f33109326a6a1af782ed05797935" translate="yes" xml:space="preserve">
          <source>If:</source>
          <target state="translated">If:</target>
        </trans-unit>
        <trans-unit id="b2403005179997fdecfad41d075986e0dccac0e9" translate="yes" xml:space="preserve">
          <source>IfStatement</source>
          <target state="translated">IfStatement</target>
        </trans-unit>
        <trans-unit id="859704f6d767666630d7b805196cab9e15bc787d" translate="yes" xml:space="preserve">
          <source>IgnoreXXXX</source>
          <target state="translated">IgnoreXXXX</target>
        </trans-unit>
        <trans-unit id="ba5ba167a98858b40c030856aa4aacb94b020392" translate="yes" xml:space="preserve">
          <source>Ignores C-style / D-style variadic arguments.</source>
          <target state="translated">Ignora los argumentos variados de estilo C y D.</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="ed701420e7f5e55b19ea82ee452968a59b8615ea" translate="yes" xml:space="preserve">
          <source>Images have the same form as reference or inline links, but add an exclamation point &lt;code&gt;!&lt;/code&gt; before the initial square bracket. What would be the link text in a normal link is used as the image's alt text.</source>
          <target state="translated">Las im&amp;aacute;genes tienen la misma forma que los enlaces de referencia o en l&amp;iacute;nea, &amp;iexcl;pero agregue un signo de exclamaci&amp;oacute;n &lt;code&gt;!&lt;/code&gt; antes del corchete inicial. Lo que ser&amp;iacute;a el texto del enlace en un enlace normal se usa como texto alternativo de la imagen.</target>
        </trans-unit>
        <trans-unit id="da8a47e84bd95dd590801199a512c81712152ddc" translate="yes" xml:space="preserve">
          <source>Immediately after the range argument, an optional work unit size argument may be provided. Work units as used by &lt;code&gt;amap&lt;/code&gt; are identical to those defined for parallel foreach. If no work unit size is provided, the default work unit size is used.</source>
          <target state="translated">Inmediatamente despu&amp;eacute;s del argumento de rango, se puede proporcionar un argumento de tama&amp;ntilde;o de unidad de trabajo opcional. Las unidades de trabajo utilizadas por &lt;code&gt;amap&lt;/code&gt; son id&amp;eacute;nticas a las definidas para foreach paralelo. Si no se proporciona el tama&amp;ntilde;o de la unidad de trabajo, se utiliza el tama&amp;ntilde;o de la unidad de trabajo predeterminado.</target>
        </trans-unit>
        <trans-unit id="79fa62caeafe3bd4c17315583aef1c8a23c5d46e" translate="yes" xml:space="preserve">
          <source>Immediately drop any connections and release socket resources. The &lt;code&gt;Socket&lt;/code&gt; object is no longer usable after &lt;code&gt;close&lt;/code&gt;. Calling &lt;code&gt;shutdown&lt;/code&gt; before &lt;code&gt;close&lt;/code&gt; is recommended for connection-oriented sockets.</source>
          <target state="translated">Inmediatamente descarte cualquier conexi&amp;oacute;n y libere recursos de socket. El objeto &lt;code&gt;Socket&lt;/code&gt; ya no se puede usar despu&amp;eacute;s del &lt;code&gt;close&lt;/code&gt; . Se recomienda llamar al &lt;code&gt;shutdown&lt;/code&gt; antes del &lt;code&gt;close&lt;/code&gt; para los z&amp;oacute;calos orientados a la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1473effc3e4965950f77d9acee523d95bdbf4b42" translate="yes" xml:space="preserve">
          <source>Immutability is transitive, meaning it applies to anything that can be referenced from the immutable type:</source>
          <target state="translated">La inmutabilidad es transitiva,lo que significa que se aplica a cualquier cosa que pueda ser referenciada del tipo inmutable:</target>
        </trans-unit>
        <trans-unit id="a3901c3fc3cbd4dda7d4b5cdbdfb146ab629c087" translate="yes" xml:space="preserve">
          <source>Immutable Member Functions</source>
          <target state="translated">Funciones del miembro inamovible</target>
        </trans-unit>
        <trans-unit id="31b83cfa7707372a1c66b40c2bffbc19a9e85eb7" translate="yes" xml:space="preserve">
          <source>Immutable Storage Class</source>
          <target state="translated">Clase de almacenamiento inmutable</target>
        </trans-unit>
        <trans-unit id="bad427b56d48a9c0418ac178e3b7e5501dbeffb2" translate="yes" xml:space="preserve">
          <source>Immutable Type</source>
          <target state="translated">Tipo Inmutable</target>
        </trans-unit>
        <trans-unit id="7a41b36410af31e02780ae8ef8f795b4c7e5c218" translate="yes" xml:space="preserve">
          <source>Immutable associative arrays are often desirable, but sometimes initialization must be done at runtime. This can be achieved with a constructor (static constructor depending on scope), a buffer associative array and &lt;code&gt;assumeUnique&lt;/code&gt;:</source>
          <target state="translated">Las matrices asociativas inmutables a menudo son deseables, pero a veces la inicializaci&amp;oacute;n debe hacerse en tiempo de ejecuci&amp;oacute;n. Esto se puede lograr con un constructor (constructor est&amp;aacute;tico dependiendo del alcance), una matriz asociativa de b&amp;uacute;fer y &lt;code&gt;assumeUnique&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1060492cd68308e42ab0d863274ead4d94e73c72" translate="yes" xml:space="preserve">
          <source>Immutable declarations can appear as lvalues, i.e. they can have their address taken, and occupy storage.</source>
          <target state="translated">Las declaraciones inamovibles pueden aparecer como valores,es decir,pueden tener su dirección tomada,y ocupar el almacenamiento.</target>
        </trans-unit>
        <trans-unit id="97deddbfb05296e5d5f6c89e8255f2cf73fed0f1" translate="yes" xml:space="preserve">
          <source>Immutable member functions are guaranteed that the object and anything referred to by the &lt;code&gt;this&lt;/code&gt; reference is immutable. They are declared as:</source>
          <target state="translated">Las funciones miembro inmutables tienen garantizado que el objeto y cualquier cosa a que se refiera &lt;code&gt;this&lt;/code&gt; referencia es inmutable. Se declaran como:</target>
        </trans-unit>
        <trans-unit id="7ca47511da5cd25a571e0550ee9181f060e3ad8e" translate="yes" xml:space="preserve">
          <source>Immutable used as a storage class is equivalent to using immutable as a type qualifier for the entire type of a declaration:</source>
          <target state="translated">El uso de inmutable como clase de almacenamiento equivale al uso de inmutable como calificador de tipo para todo el tipo de declaración:</target>
        </trans-unit>
        <trans-unit id="8cc79f379fb076727af30671cff8e81a7a78ac8f" translate="yes" xml:space="preserve">
          <source>Imperial Aramaic</source>
          <target state="translated">Arameo imperial</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="015f00e67a839cb58bb4f25641353bc270b1dc50" translate="yes" xml:space="preserve">
          <source>Impl* &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt;(const TypeInfo_AssociativeArray ti, void[] keys, void[] vals);</source>
          <target state="translated">&lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;Impl&lt;/strong&gt; * &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt; (const TypeInfo_AssociativeArray ti, void [] keys, void [] vals);</target>
        </trans-unit>
        <trans-unit id="00b783520a8a2fbc5645a580ba36a3a286254053" translate="yes" xml:space="preserve">
          <source>Implementation Details</source>
          <target state="translated">Detalles de la implementación</target>
        </trans-unit>
        <trans-unit id="4bd31434dd702d78584ad36682fd4ce02cbe35f9" translate="yes" xml:space="preserve">
          <source>Implementation helpers</source>
          <target state="translated">Ayudantes de ejecución</target>
        </trans-unit>
        <trans-unit id="cdc8095e33689a7350a694bb991dc5449ed4cc80" translate="yes" xml:space="preserve">
          <source>Implementation note: Many vector operations are expected to take advantage of any vector math instructions available on the target computer.</source>
          <target state="translated">Nota de aplicación:Se espera que muchas operaciones de vectores aprovechen cualquier instrucción matemática de vectores disponible en la computadora de destino.</target>
        </trans-unit>
        <trans-unit id="4f7fc9a2d05fa0c5c4b7879d385797376ea8299d" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;IAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built allocator type to &lt;code&gt;IAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;IAllocator&lt;/code&gt; usando &lt;code&gt;Allocator&lt;/code&gt; . Esto adapta un tipo de asignador construido est&amp;aacute;ticamente a &lt;code&gt;IAllocator&lt;/code&gt; que puede ser utilizado directamente por c&amp;oacute;digo sin plantilla.</target>
        </trans-unit>
        <trans-unit id="fafacd0c4afbb4ff4bf1edadf17fafe457e3c87e" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;ISharedAllocator&lt;/code&gt; using &lt;code&gt;Allocator&lt;/code&gt;. This adapts a statically-built, shareable across threads, allocator type to &lt;code&gt;ISharedAllocator&lt;/code&gt; that is directly usable by non-templated code.</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;ISharedAllocator&lt;/code&gt; usando &lt;code&gt;Allocator&lt;/code&gt; . Esto adapta un tipo de asignador &lt;code&gt;ISharedAllocator&lt;/code&gt; de manera est&amp;aacute;tica, que se puede compartir a trav&amp;eacute;s de subprocesos a ISharedAllocator que puede ser utilizado directamente por un c&amp;oacute;digo sin plantilla.</target>
        </trans-unit>
        <trans-unit id="bcbaffe82dd8f12aeaf4d1ff9d3011fef84404a6" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendT&lt;/code&gt; and &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;_d_arrayappendT&lt;/code&gt; y &lt;code&gt;_d_arrayappendTTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10e497f26133fe54aedbc1b0186f76a3533b685" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; and &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;_d_arrayappendcTX&lt;/code&gt; y &lt;code&gt;_d_arrayappendcTXTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7db4a8478e7cad025fd1104c777c36390076d0e1" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraycatnTX&lt;/code&gt; and &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;_d_arraycatnTX&lt;/code&gt; y &lt;code&gt;_d_arraycatnTXTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abbaa69f0e232671973ab5e6491f136e6a29871" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; and &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</source>
          <target state="translated">Implementaci&amp;oacute;n de &lt;code&gt;_d_arraysetlengthT&lt;/code&gt; y &lt;code&gt;_d_arraysetlengthTTrace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f9ad487b035fc97c0af04b8b66abb8578971a5f" translate="yes" xml:space="preserve">
          <source>Implementation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt; red-black tree&lt;/a&gt; container.</source>
          <target state="translated">Implementaci&amp;oacute;n de un contenedor de &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;&amp;aacute;rbol rojo-negro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e7df8ae1e56f997a5b65b6b6877c23f0d64f3a3" translate="yes" xml:space="preserve">
          <source>Implementation of alloca() standard C routine.</source>
          <target state="translated">Aplicación de la rutina de la norma C de alloca().</target>
        </trans-unit>
        <trans-unit id="1784dc78d2b897ccf07f36701bfc5665f7a4b791" translate="yes" xml:space="preserve">
          <source>Implementation of array assignment support routines.</source>
          <target state="translated">Implementación de rutinas de apoyo a la asignación de arreglos.</target>
        </trans-unit>
        <trans-unit id="a39c70c382be4565515493d462dbbec04eaf7781" translate="yes" xml:space="preserve">
          <source>Implementation of array copy support routines.</source>
          <target state="translated">Implementación de rutinas de soporte de copias de matrices.</target>
        </trans-unit>
        <trans-unit id="0bdc6417eff40a113a2fe81fc65ab41a4dcaba32" translate="yes" xml:space="preserve">
          <source>Implementation of associative arrays.</source>
          <target state="translated">Implementación de conjuntos asociativos.</target>
        </trans-unit>
        <trans-unit id="07784c9ff6fc80ea8be9db66531869c595761785" translate="yes" xml:space="preserve">
          <source>Implementation of code coverage analyzer.</source>
          <target state="translated">Implementación del analizador de cobertura de código.</target>
        </trans-unit>
        <trans-unit id="fad1778f18239a1620ff2a279ed8dce89c92aba4" translate="yes" xml:space="preserve">
          <source>Implementation of dynamic array property support routines.</source>
          <target state="translated">Implementación de rutinas de apoyo a las propiedades de los arreglos dinámicos.</target>
        </trans-unit>
        <trans-unit id="1c44b949de0c9066379af30ba926638e5089c3a0" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines for Win32.</source>
          <target state="translated">Implementación de rutinas de soporte de manejo de excepciones para Win32.</target>
        </trans-unit>
        <trans-unit id="7d3ce3a8f354f9946b2098d37781419df42c1fa9" translate="yes" xml:space="preserve">
          <source>Implementation of exception handling support routines.</source>
          <target state="translated">Aplicación de rutinas de apoyo al manejo de excepciones.</target>
        </trans-unit>
        <trans-unit id="4262710c1f4443ad04091f6eaee82248c8735a23" translate="yes" xml:space="preserve">
          <source>Implementation of invariant support routines.</source>
          <target state="translated">Aplicación de rutinas de apoyo invariables.</target>
        </trans-unit>
        <trans-unit id="3dad8ae42692f0a5067da5335623cc0faae36caa" translate="yes" xml:space="preserve">
          <source>Implementation of standard Base64 encoding.</source>
          <target state="translated">Implementación de la codificación estándar Base64.</target>
        </trans-unit>
        <trans-unit id="8bb4407a3328a42063117ac1cd37abce98147582" translate="yes" xml:space="preserve">
          <source>Implementation of support routines for synchronized blocks.</source>
          <target state="translated">Implementación de rutinas de apoyo para los bloques sincronizados.</target>
        </trans-unit>
        <trans-unit id="36a7e10f19e92847926357311b55d0e017f473ef" translate="yes" xml:space="preserve">
          <source>Implementations are free to assume that GC pointers are only stored on word boundaries. Unaligned pointers may be ignored entirely.</source>
          <target state="translated">Las implementaciones son libres de asumir que los punteros GC sólo se almacenan en los límites de las palabras.Los punteros no alineados pueden ser ignorados por completo.</target>
        </trans-unit>
        <trans-unit id="a8c2ed8c7bf790ca62a6ccc79e874d26201eb456" translate="yes" xml:space="preserve">
          <source>Implementations are free to run collections at any point. It is, however, recommendable to only do so when an allocation attempt happens and there is insufficient memory available.</source>
          <target state="translated">Las implementaciones son libres de ejecutar colecciones en cualquier momento.Sin embargo,es recomendable hacerlo sólo cuando se produce un intento de asignación y no hay suficiente memoria disponible.</target>
        </trans-unit>
        <trans-unit id="7bedeb01a44e9992494ae61fc2e61ab874f0844b" translate="yes" xml:space="preserve">
          <source>Implementations are free to scan the non-root heap in a precise manner, so that fields of types like &lt;code&gt;float&lt;/code&gt; will not be considered relevant when scanning the heap. Thus, casting a GC pointer to an integral type (e.g. &lt;code&gt;size_t&lt;/code&gt;) and storing it in a field of that type inside the GC heap may mean that it will not be recognized if the memory block was allocated with precise type info or with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">Las implementaciones son libres de escanear el mont&amp;oacute;n no root de manera precisa, de modo que los campos de tipos como &lt;code&gt;float&lt;/code&gt; no se considerar&amp;aacute;n relevantes al escanear el mont&amp;oacute;n. Por lo tanto, lanzar un puntero del GC a un tipo integral (por ejemplo, &lt;code&gt;size_t&lt;/code&gt; ) y almacenarlo en un campo de ese tipo dentro del mont&amp;oacute;n del GC puede significar que no se reconocer&amp;aacute; si el bloque de memoria se asign&amp;oacute; con informaci&amp;oacute;n de tipo precisa o con el &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_SCAN&quot;&gt;NO_SCAN&lt;/a&gt;&lt;/code&gt; Atributo NO_SCAN .</target>
        </trans-unit>
        <trans-unit id="3fe2d13e1a38447a1ccf3bcf63459da389a3bd8d" translate="yes" xml:space="preserve">
          <source>Implementations may restrict the file name in order to avoid directory traversal security vulnerabilities. A possible restriction might be to disallow any path components in the file name.</source>
          <target state="translated">Las implementaciones pueden restringir el nombre del archivo para evitar vulnerabilidades de seguridad en el cruce de directorios.Una posible restricción podría ser la de no permitir ningún componente de ruta en el nombre del archivo.</target>
        </trans-unit>
        <trans-unit id="41da860cb79fe7312e55548bf43ef9ac07ff278f" translate="yes" xml:space="preserve">
          <source>Implementations must diagnose an error for unrecognized</source>
          <target state="translated">Las implementaciones deben diagnosticar un error por no reconocido</target>
        </trans-unit>
        <trans-unit id="007c721ddd0f22de039d1ec5d207cce979d8d6f0" translate="yes" xml:space="preserve">
          <source>Implementations must support interior pointers. That is, if the only reference to a GC-managed memory block points into the middle of the block rather than the beginning (for example), the GC must consider the memory block live. The exception to this rule is when a memory block is allocated with the &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; attribute; it is the user's responsibility to make sure such memory blocks have a proper pointer to them when they should be considered live.</source>
          <target state="translated">Las implementaciones deben soportar punteros interiores. Es decir, si la &amp;uacute;nica referencia a un bloque de memoria administrado por GC apunta al centro del bloque en lugar de al principio (por ejemplo), el GC debe considerar el bloque de memoria en vivo. La excepci&amp;oacute;n a esta regla es cuando se asigna un bloque de memoria con &lt;code&gt;GC.BlkAttr.&lt;a href=&quot;#NO_INTERIOR&quot;&gt;NO_INTERIOR&lt;/a&gt;&lt;/code&gt; Atributo NO_INTERIOR ; Es responsabilidad del usuario asegurarse de que dichos bloques de memoria tengan un puntero adecuado cuando se los considere en vivo.</target>
        </trans-unit>
        <trans-unit id="db108dbc2de097787f6ddeb0832f02909642f907" translate="yes" xml:space="preserve">
          <source>Implementations of D on different architectures, however, are free to innovate upon the memory model, function call/return conventions, argument passing conventions, etc.</source>
          <target state="translated">Sin embargo,las implementaciones de D en diferentes arquitecturas son libres de innovar en el modelo de memoria,las convenciones de llamada/retorno de funciones,las convenciones de paso de argumentos,etc.</target>
        </trans-unit>
        <trans-unit id="d7a03fc44da9f306060241398ee57db5f3a7d7aa" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; and &lt;code&gt;pthread_condition&lt;/code&gt; on Posix and &lt;code&gt;CreateEvent&lt;/code&gt; and &lt;code&gt;SetEvent&lt;/code&gt; on Windows.</source>
          <target state="translated">Implementado usando &lt;code&gt;pthread_mutex&lt;/code&gt; y &lt;code&gt;pthread_condition&lt;/code&gt; en Posix y &lt;code&gt;CreateEvent&lt;/code&gt; y &lt;code&gt;SetEvent&lt;/code&gt; en Windows.</target>
        </trans-unit>
        <trans-unit id="9e4c63b7ecbb7ff73a2154a224607de77b4347f8" translate="yes" xml:space="preserve">
          <source>Implemented using &lt;code&gt;pthread_mutex&lt;/code&gt; on Posix and &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; on Windows.</source>
          <target state="translated">Implementado usando &lt;code&gt;pthread_mutex&lt;/code&gt; en Posix y &lt;code&gt;CRITICAL_SECTION&lt;/code&gt; en Windows.</target>
        </trans-unit>
        <trans-unit id="cf9e08c7271694a3ffd216903295953184c6b554" translate="yes" xml:space="preserve">
          <source>Implementing a Scheduler allows the concurrency mechanism used by this module to be customized according to different needs. By default, a call to spawn will create a new kernel thread that executes the supplied routine and terminates when finished. But it is possible to create Schedulers that reuse threads, that multiplex Fibers (coroutines) across a single thread, or any number of other approaches. By making the choice of Scheduler a user-level option, std.concurrency may be used for far more types of application than if this behavior were predefined.</source>
          <target state="translated">La implementación de un Planificador permite que el mecanismo de concurrencia utilizado por este módulo se adapte a las diferentes necesidades.Por defecto,una llamada a spawn creará un nuevo hilo de kernel que ejecutará la rutina suministrada y terminará cuando termine.Pero es posible crear Schedulers que reutilicen hilos,que multiplexen Fibras (coroutinas)a través de un solo hilo,o cualquier otro número de enfoques.Al hacer de la elección del Programador una opción a nivel de usuario,la concurrencia estándar puede ser utilizada para muchos más tipos de aplicaciones que si este comportamiento estuviera predefinido.</target>
        </trans-unit>
        <trans-unit id="b264d3336b750c35148a8818568f62fa13927441" translate="yes" xml:space="preserve">
          <source>Implements 3-way comparisons of &lt;code&gt;BigInt&lt;/code&gt; with &lt;code&gt;BigInt&lt;/code&gt; or &lt;code&gt;BigInt&lt;/code&gt; with built-in integers.</source>
          <target state="translated">Implementa comparaciones de 3 v&amp;iacute;as de &lt;code&gt;BigInt&lt;/code&gt; con &lt;code&gt;BigInt&lt;/code&gt; o &lt;code&gt;BigInt&lt;/code&gt; con enteros integrados.</target>
        </trans-unit>
        <trans-unit id="ff4e8dcbc761da7358b8c9aa098a3c08bb0a396c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; equality test with other &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integer types.</source>
          <target state="translated">Implementa la prueba de igualdad de &lt;code&gt;BigInt&lt;/code&gt; con otros &lt;code&gt;BigInt&lt;/code&gt; de BigInt y enteros incorporados.</target>
        </trans-unit>
        <trans-unit id="7ca26966771a4b63b83cfa749d58cb4c74bd1074" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;BigInt&lt;/code&gt; unary operators.</source>
          <target state="translated">Implementa operadores &lt;code&gt;BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3cb51c99d7f39233c1830869fb1b564b310297" translate="yes" xml:space="preserve">
          <source>Implements a &quot;tee&quot; style pipe, wrapping an input range so that elements of the range can be passed to a provided function or &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt; as they are iterated over. This is useful for printing out intermediate values in a long chain of range code, performing some operation with side-effects on each call to &lt;code&gt;front&lt;/code&gt; or &lt;code&gt;popFront&lt;/code&gt;, or diverting the elements of a range into an auxiliary &lt;a href=&quot;#OutputRange&quot;&gt;&lt;code&gt;OutputRange&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Implementa una tuber&amp;iacute;a de estilo &quot;tee&quot;, ajustando un rango de entrada para que los elementos del rango puedan pasarse a una funci&amp;oacute;n proporcionada o &lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; a&lt;/a&gt; medida que se repiten . Esto es &amp;uacute;til para imprimir valores intermedios en una cadena larga de c&amp;oacute;digo de rango, realizar alguna operaci&amp;oacute;n con efectos secundarios en cada llamada a &lt;code&gt;front&lt;/code&gt; o &lt;code&gt;popFront&lt;/code&gt; , o desviar los elementos de un rango a un &lt;a href=&quot;#OutputRange&quot;&gt; &lt;code&gt;OutputRange&lt;/code&gt; &lt;/a&gt; auxiliar .</target>
        </trans-unit>
        <trans-unit id="edd807624e1eff53b60fc0fdcb84a1a01a914908" translate="yes" xml:space="preserve">
          <source>Implements a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;binary heap&lt;/a&gt; container on top of a given random-access range type (usually &lt;code&gt;T[]&lt;/code&gt;) or a random-access container type (usually &lt;code&gt;Array!T&lt;/code&gt;). The documentation of &lt;code&gt;BinaryHeap&lt;/code&gt; will refer to the underlying range or container as the</source>
          <target state="translated">Implementa un contenedor de &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_heap&quot;&gt;almacenamiento din&amp;aacute;mico binario&lt;/a&gt; encima de un tipo de rango de acceso aleatorio dado (generalmente &lt;code&gt;T[]&lt;/code&gt; ) o un tipo de contenedor de acceso aleatorio (generalmente &lt;code&gt;Array!T&lt;/code&gt; ). La documentaci&amp;oacute;n de &lt;code&gt;BinaryHeap&lt;/code&gt; se referir&amp;aacute; al rango o contenedor subyacente como</target>
        </trans-unit>
        <trans-unit id="826e19cc42c27271edbc14035290489f9b886abe" translate="yes" xml:space="preserve">
          <source>Implements a doubly-linked list.</source>
          <target state="translated">Implementa una lista doblemente vinculada.</target>
        </trans-unit>
        <trans-unit id="6c4a9e8241b5f111ea434df2fe96c036c8c94979" translate="yes" xml:space="preserve">
          <source>Implements a narrowing remainder operation with built-in integer types.</source>
          <target state="translated">Realiza una operación de estrechamiento del resto con tipos enteros incorporados.</target>
        </trans-unit>
        <trans-unit id="27ed74a2d7c34a4b3c0b18b681929b4fe9236374" translate="yes" xml:space="preserve">
          <source>Implements a parallel foreach loop over a range. This works by implicitly creating and submitting one &lt;code&gt;Task&lt;/code&gt; to the &lt;code&gt;TaskPool&lt;/code&gt; for each worker thread. A work unit is a set of consecutive elements of &lt;code&gt;range&lt;/code&gt; to be processed by a worker thread between communication with any other thread. The number of elements processed per work unit is controlled by the &lt;code&gt;workUnitSize&lt;/code&gt; parameter. Smaller work units provide better load balancing, but larger work units avoid the overhead of communicating with other threads frequently to fetch the next work unit. Large work units also avoid false sharing in cases where the range is being modified. The less time a single iteration of the loop takes, the larger &lt;code&gt;workUnitSize&lt;/code&gt; should be. For very expensive loop bodies, &lt;code&gt;workUnitSize&lt;/code&gt; should be 1. An overload that chooses a default work unit size is also available.</source>
          <target state="translated">Implementa un bucle foreach paralelo en un rango. Esto funciona creando y enviando impl&amp;iacute;citamente una &lt;code&gt;Task&lt;/code&gt; al Grupo de &lt;code&gt;TaskPool&lt;/code&gt; para cada subproceso de trabajo. Una unidad de trabajo es un conjunto de elementos consecutivos de &lt;code&gt;range&lt;/code&gt; que debe procesar un subproceso de trabajo entre la comunicaci&amp;oacute;n con cualquier otro subproceso. El n&amp;uacute;mero de elementos procesados ​​por unidad de trabajo est&amp;aacute; controlado por el par&amp;aacute;metro &lt;code&gt;workUnitSize&lt;/code&gt; . Las unidades de trabajo m&amp;aacute;s peque&amp;ntilde;as proporcionan un mejor equilibrio de carga, pero las unidades de trabajo m&amp;aacute;s grandes evitan la sobrecarga de comunicarse con otros hilos con frecuencia para buscar la siguiente unidad de trabajo. Las unidades de trabajo grandes tambi&amp;eacute;n evitan el intercambio falso en los casos en que se modifica el rango. Cuanto menos tiempo tome una sola iteraci&amp;oacute;n del bucle, mayor &lt;code&gt;workUnitSize&lt;/code&gt; debiera ser. Para cuerpos de bucle muy caros, &lt;code&gt;workUnitSize&lt;/code&gt; debe ser 1. Tambi&amp;eacute;n est&amp;aacute; disponible una sobrecarga que elige un tama&amp;ntilde;o de unidad de trabajo predeterminado.</target>
        </trans-unit>
        <trans-unit id="826fe4a31de6fc5bfd32223112c616b546ef30ea" translate="yes" xml:space="preserve">
          <source>Implements a simple and fast singly-linked list. It can be used as a stack.</source>
          <target state="translated">Implementa una simple y rápida lista de enlaces individuales.Puede ser usada como una pila.</target>
        </trans-unit>
        <trans-unit id="1e7f8a9f41236aa959250c83a21042416cfb7001" translate="yes" xml:space="preserve">
          <source>Implements an output range that appends data to an array. This is recommended over &lt;code&gt;array ~= data&lt;/code&gt; when appending many elements because it is more efficient. &lt;code&gt;Appender&lt;/code&gt; maintains its own array metadata locally, so it can avoid global locking for each append where &lt;a href=&quot;#capacity&quot;&gt;&lt;code&gt;capacity&lt;/code&gt;&lt;/a&gt; is non-zero.</source>
          <target state="translated">Implementa un rango de salida que agrega datos a una matriz. Esto se recomienda sobre la &lt;code&gt;array ~= data&lt;/code&gt; cuando se agregan muchos elementos porque es m&amp;aacute;s eficiente. &lt;code&gt;Appender&lt;/code&gt; mantiene sus propios metadatos de matriz localmente, por lo que puede evitar el bloqueo global para cada anexo donde la &lt;a href=&quot;#capacity&quot;&gt; &lt;code&gt;capacity&lt;/code&gt; &lt;/a&gt; no sea cero.</target>
        </trans-unit>
        <trans-unit id="eb1006ae1765bc7db00ba2578ee369f0e577a7bc" translate="yes" xml:space="preserve">
          <source>Implements assignment operators from built-in integers of the form &lt;code&gt;BigInt op= integer&lt;/code&gt;.</source>
          <target state="translated">Implementa operadores de asignaci&amp;oacute;n de enteros integrados de la forma &lt;code&gt;BigInt op= integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bf741a9ca55b772fcf287918db9b994810ba0a" translate="yes" xml:space="preserve">
          <source>Implements assignment operators of the form &lt;code&gt;BigInt op= BigInt&lt;/code&gt;.</source>
          <target state="translated">Implementa operadores de asignaci&amp;oacute;n de la forma &lt;code&gt;BigInt op= BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1ea709e7bbd408cd7bf94a6f215f7f14ae10aa2" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;'s and built-in integers.</source>
          <target state="translated">Implementa operadores binarios entre &lt;code&gt;BigInt&lt;/code&gt; y enteros integrados.</target>
        </trans-unit>
        <trans-unit id="df47e55b92aed2a9c5b877779b4fc9382af7ea1f" translate="yes" xml:space="preserve">
          <source>Implements binary operators between &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">Implementa operadores binarios entre &lt;code&gt;BigInt&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="c38b2eea1063f17593adb5371b20a04e888bc589" translate="yes" xml:space="preserve">
          <source>Implements casting to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Implementa fundici&amp;oacute;n a &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="612c7a1e4ee8aa3a5eb36e62f5d1886edb7c32a6" translate="yes" xml:space="preserve">
          <source>Implements casting to integer types.</source>
          <target state="translated">Implementa el casting a tipos enteros.</target>
        </trans-unit>
        <trans-unit id="d027822363fbfc370a577e3a5cc7b4b903013cad" translate="yes" xml:space="preserve">
          <source>Implements casting to/from qualified &lt;code&gt;BigInt&lt;/code&gt;'s.</source>
          <target state="translated">Implementa el &lt;code&gt;BigInt&lt;/code&gt; a / desde BigInt 's calificados .</target>
        </trans-unit>
        <trans-unit id="ff4cc4fdb32d0e79c9536f6d66d8396bbf61c41a" translate="yes" xml:space="preserve">
          <source>Implements common functionality for StaticForeachDeclaration and StaticForeachStatement This performs the necessary lowerings before dmd.statementsem.makeTupleForeach can be used to expand the corresponding &lt;code&gt;static foreach&lt;/code&gt; declaration or statement.</source>
          <target state="translated">Implementa una funcionalidad com&amp;uacute;n para StaticForeachDeclaration y StaticForeachStatement. Esto realiza las reducciones necesarias antes de que dmd.statementsem.makeTupleForeach pueda usarse para expandir la declaraci&amp;oacute;n o declaraci&amp;oacute;n &lt;code&gt;static foreach&lt;/code&gt; correspondiente .</target>
        </trans-unit>
        <trans-unit id="33e291a05be91fd5868ef9b486e72f36172b61e4" translate="yes" xml:space="preserve">
          <source>Implements functionality to read Comma Separated Values and its variants from an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; of &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">Implementa la funcionalidad para leer valores separados por comas y sus variantes de un &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;rango&lt;/a&gt; de entrada de &lt;code&gt;dchar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78fb12359a92b10736f7ddffd604a688feb1037" translate="yes" xml:space="preserve">
          <source>Implements logging facilities.</source>
          <target state="translated">Implementa instalaciones de registro.</target>
        </trans-unit>
        <trans-unit id="1c9526ff0c5c9d17f08ea2d94e25202e075b8278" translate="yes" xml:space="preserve">
          <source>Implements low-level time primitives.</source>
          <target state="translated">Implementa primitivas de tiempo de bajo nivel.</target>
        </trans-unit>
        <trans-unit id="f10aa3fdc814d436934036f8b3d2932b2c1a116c" translate="yes" xml:space="preserve">
          <source>Implements mixin types.</source>
          <target state="translated">Implementa tipos de mezcla.</target>
        </trans-unit>
        <trans-unit id="5720cf3a68f9171f96627020e4e3f8a88a48971a" translate="yes" xml:space="preserve">
          <source>Implements operators with built-in integers on the left-hand side and &lt;code&gt;BigInt&lt;/code&gt; on the right-hand side.</source>
          <target state="translated">Implementa operadores con n&amp;uacute;meros enteros integrados en el lado izquierdo y &lt;code&gt;BigInt&lt;/code&gt; en el lado derecho.</target>
        </trans-unit>
        <trans-unit id="7e5de803b2338c86b3532da481b13f228f6a981e" translate="yes" xml:space="preserve">
          <source>Implements routines related to exceptions.</source>
          <target state="translated">Aplica rutinas relacionadas con las excepciones.</target>
        </trans-unit>
        <trans-unit id="f320bc582113b4cafa3cdb495549c72756dd174e" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; (unary and binary), &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Implementa saturaci&amp;oacute;n para operadores &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; (unario y binario), &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12ddcd2c7713838aaff094e0d8442224022b567f" translate="yes" xml:space="preserve">
          <source>Implements saturation for operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;. This hook is called if the result of the binary operation does not fit in &lt;code&gt;Lhs&lt;/code&gt; without loss of information or a change in sign.</source>
          <target state="translated">Implementa saturaci&amp;oacute;n para operadores &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; , y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; . Se llama a este &lt;code&gt;Lhs&lt;/code&gt; si el resultado de la operaci&amp;oacute;n binaria no cabe en Lhs sin p&amp;eacute;rdida de informaci&amp;oacute;n o un cambio en el signo.</target>
        </trans-unit>
        <trans-unit id="be45676fa18a18d1d8737b834959d03a5f13376c" translate="yes" xml:space="preserve">
          <source>Implements the 'common' IEEE CRC32 variant (LSB-first order, Initial value uint.max, complement result)</source>
          <target state="translated">Implementa la variante 'común' del IEEE CRC32 (LSB-primer orden,Valor inicial uint.max,resultado del complemento)</target>
        </trans-unit>
        <trans-unit id="c54fb55bf997400be69c40f0614b3e9b7db9616f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;secant method&lt;/a&gt; for finding a root of the function &lt;code&gt;fun&lt;/code&gt; starting from points &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (ideally close to the root). &lt;code&gt;Num&lt;/code&gt; may be &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">Implementa el &lt;a href=&quot;http://tinyurl.com/2zb9yr&quot;&gt;m&amp;eacute;todo secante&lt;/a&gt; para encontrar una ra&amp;iacute;z de la funci&amp;oacute;n &lt;code&gt;fun&lt;/code&gt; partir de los puntos &lt;code&gt;[xn_1, x_n]&lt;/code&gt; (idealmente cerca de la ra&amp;iacute;z). &lt;code&gt;Num&lt;/code&gt; puede ser &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; o &lt;code&gt;real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b80a316e588d021f8c65a6036707b88ad521159" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;OutputRange&lt;/code&gt; interface for all types E and wraps the &lt;code&gt;put&lt;/code&gt; method for each type &lt;code&gt;E&lt;/code&gt; in a virtual function.</source>
          <target state="translated">Implementa la interfaz &lt;code&gt;OutputRange&lt;/code&gt; para todos los tipos E y ajusta el m&amp;eacute;todo &lt;code&gt;put&lt;/code&gt; para cada tipo &lt;code&gt;E&lt;/code&gt; en una funci&amp;oacute;n virtual.</target>
        </trans-unit>
        <trans-unit id="09d37307ce6ae6ae1585ab5db7a54050805cc742" translate="yes" xml:space="preserve">
          <source>Implements the MurmurHash3 functions. You can specify the &lt;code&gt;size&lt;/code&gt; of the hash in bit. For 128 bit hashes you can specify whether to optimize for 32 or 64 bit architectures. If you don't specify the &lt;code&gt;opt&lt;/code&gt; value it will select the fastest version of the host platform.</source>
          <target state="translated">Implementa las funciones MurmurHash3. Puede especificar el &lt;code&gt;size&lt;/code&gt; del hash en bits. Para hashes de 128 bits, puede especificar si desea optimizar para arquitecturas de 32 o 64 bits. Si no especifica el valor &lt;code&gt;opt&lt;/code&gt; , seleccionar&amp;aacute; la versi&amp;oacute;n m&amp;aacute;s r&amp;aacute;pida de la plataforma de host.</target>
        </trans-unit>
        <trans-unit id="7ab18d84fa65349ea46fc1a23e6ee0555763f6a9" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json arrays.</source>
          <target state="translated">Implementa la interfaz foreach &lt;code&gt;opApply&lt;/code&gt; para matrices json.</target>
        </trans-unit>
        <trans-unit id="45e448d8088d50f1f95bb79e479da8d5a8f8521b" translate="yes" xml:space="preserve">
          <source>Implements the foreach &lt;code&gt;opApply&lt;/code&gt; interface for json objects.</source>
          <target state="translated">Implementa la interfaz foreach &lt;code&gt;opApply&lt;/code&gt; para objetos json.</target>
        </trans-unit>
        <trans-unit id="c7b156318387d032d75e77a645f93fbb91cfe8d1" translate="yes" xml:space="preserve">
          <source>Implements the higher order filter function. The predicate is passed to &lt;a href=&quot;std_functional#unaryFun&quot;&gt;&lt;code&gt;std.functional.unaryFun&lt;/code&gt;&lt;/a&gt;, and can either accept a string, or any callable that can be executed via &lt;code&gt;pred(element)&lt;/code&gt;.</source>
          <target state="translated">Implementa la funci&amp;oacute;n de filtro de orden superior. El predicado se pasa a &lt;a href=&quot;std_functional#unaryFun&quot;&gt; &lt;code&gt;std.functional.unaryFun&lt;/code&gt; &lt;/a&gt; y puede aceptar una cadena o cualquier invocable que se pueda ejecutar a trav&amp;eacute;s de &lt;code&gt;pred(element)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="881b721a1385bc8ef11d90c4f0aac7e1c9f98dea" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor.</source>
          <target state="translated">Implementa la funci&amp;oacute;n hom&amp;oacute;nima (tambi&amp;eacute;n conocida como &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; o &lt;code&gt;foldl&lt;/code&gt; ) presente en varios lenguajes de programaci&amp;oacute;n de sabor funcional.</target>
        </trans-unit>
        <trans-unit id="2de496f11d0a61e3ec35b13526a647a0eda0aa53" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. The call &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;fold!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">Implementa la funci&amp;oacute;n hom&amp;oacute;nima (tambi&amp;eacute;n conocida como &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; o &lt;code&gt;foldl&lt;/code&gt; ) presente en varios lenguajes de programaci&amp;oacute;n de sabor funcional. La llamada &lt;code&gt;fold!(fun)(range, seed)&lt;/code&gt; primero asigna la &lt;code&gt;seed&lt;/code&gt; a un &lt;code&gt;result&lt;/code&gt; ado variable interno , tambi&amp;eacute;n llamado acumulador. Luego, para cada elemento &lt;code&gt;x&lt;/code&gt; en el &lt;code&gt;range&lt;/code&gt; , se eval&amp;uacute;a &lt;code&gt;result = fun(result, x)&lt;/code&gt; . Finalmente, se devuelve el &lt;code&gt;result&lt;/code&gt; ado . La versi&amp;oacute;n de un argumento &lt;code&gt;fold!(fun)(range)&lt;/code&gt; funciona de manera similar, pero utiliza el primer elemento del rango como semilla (el rango no debe estar vac&amp;iacute;o).</target>
        </trans-unit>
        <trans-unit id="3a102abac10f402f998c7a93f6d1ecbc38ae5d29" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;accumulate&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, &lt;code&gt;inject&lt;/code&gt;, or &lt;code&gt;foldl&lt;/code&gt;) present in various programming languages of functional flavor. There is also &lt;a href=&quot;#fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; which does the same thing but with the opposite parameter order. The call &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; first assigns &lt;code&gt;seed&lt;/code&gt; to an internal variable &lt;code&gt;result&lt;/code&gt;, also called the accumulator. Then, for each element &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;result = fun(result, x)&lt;/code&gt; gets evaluated. Finally, &lt;code&gt;result&lt;/code&gt; is returned. The one-argument version &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; works similarly, but it uses the first element of the range as the seed (the range must be non-empty).</source>
          <target state="translated">Implementa la funci&amp;oacute;n hom&amp;oacute;nima (tambi&amp;eacute;n conocida como &lt;code&gt;accumulate&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; , &lt;code&gt;inject&lt;/code&gt; o &lt;code&gt;foldl&lt;/code&gt; ) presente en varios lenguajes de programaci&amp;oacute;n de sabor funcional. Tambi&amp;eacute;n hay &lt;a href=&quot;#fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; que hace lo mismo pero con el orden de par&amp;aacute;metros opuesto. La llamada &lt;code&gt;reduce!(fun)(seed, range)&lt;/code&gt; primero asigna &lt;code&gt;seed&lt;/code&gt; a un &lt;code&gt;result&lt;/code&gt; ado variable interno , tambi&amp;eacute;n llamado acumulador. Luego, para cada elemento &lt;code&gt;x&lt;/code&gt; en el &lt;code&gt;range&lt;/code&gt; , se eval&amp;uacute;a &lt;code&gt;result = fun(result, x)&lt;/code&gt; . Finalmente, se devuelve el &lt;code&gt;result&lt;/code&gt; ado . La versi&amp;oacute;n de un argumento &lt;code&gt;reduce!(fun)(range)&lt;/code&gt; funciona de manera similar, pero utiliza el primer elemento del rango como semilla (el rango no debe estar vac&amp;iacute;o).</target>
        </trans-unit>
        <trans-unit id="d222f5f35083b3fe479ec859b88f2b5c2d29bc99" translate="yes" xml:space="preserve">
          <source>Implements the homonym function (also known as &lt;code&gt;transform&lt;/code&gt;) present in many languages of functional flavor. The call &lt;code&gt;map!(fun)(range)&lt;/code&gt; returns a range of which elements are obtained by applying &lt;code&gt;fun(a)&lt;/code&gt; left to right for all elements &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;range&lt;/code&gt;. The original ranges are not changed. Evaluation is done lazily.</source>
          <target state="translated">Implementa la funci&amp;oacute;n hom&amp;oacute;nima (tambi&amp;eacute;n conocida como &lt;code&gt;transform&lt;/code&gt; aci&amp;oacute;n ) presente en muchos lenguajes de sabor funcional. &amp;iexcl;El &lt;code&gt;map!(fun)(range)&lt;/code&gt; llamadas ! (Diversi&amp;oacute;n) (rango) devuelve un rango de los elementos que se obtienen aplicando &lt;code&gt;fun(a)&lt;/code&gt; izquierda a derecha para todos los elementos &lt;code&gt;a&lt;/code&gt; en &lt;code&gt;range&lt;/code&gt; . Los rangos originales no se modifican. La evaluaci&amp;oacute;n se realiza perezosamente.</target>
        </trans-unit>
        <trans-unit id="38aa73eed2ebaa6990e6725195bf642f0bb7894e" translate="yes" xml:space="preserve">
          <source>Implements the most derived interface that &lt;code&gt;R&lt;/code&gt; works with and wraps all relevant range primitives in virtual functions. If &lt;code&gt;R&lt;/code&gt; is already derived from the &lt;code&gt;InputRange&lt;/code&gt; interface, aliases itself away.</source>
          <target state="translated">Implementa la interfaz m&amp;aacute;s derivada con la que &lt;code&gt;R&lt;/code&gt; trabaja y ajusta todas las primitivas de rango relevantes en funciones virtuales. Si &lt;code&gt;R&lt;/code&gt; ya se deriva de la interfaz &lt;code&gt;InputRange&lt;/code&gt; , el alias desaparece.</target>
        </trans-unit>
        <trans-unit id="0aed3bb7204f0f1333835ef5bde3ef0b25325996" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;back&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.back&lt;/code&gt; is equivalent to &lt;code&gt;back(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;back&lt;/code&gt; automatically returns the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">Implementa la interfaz gama primitiva &lt;code&gt;back&lt;/code&gt; para las matrices incorporado. Debido al hecho de que las funciones que no son miembros se pueden &lt;code&gt;array.back&lt;/code&gt; con el primer argumento usando la notaci&amp;oacute;n de punto, array.back es equivalente a &lt;code&gt;back(array)&lt;/code&gt; . Para &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;cadenas estrechas&lt;/a&gt; , la parte &lt;code&gt;back&lt;/code&gt; devuelve autom&amp;aacute;ticamente el &amp;uacute;ltimo &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;punto de c&amp;oacute;digo&lt;/a&gt; como &lt;code&gt;dchar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b532541671d15b35cef77598c086f1da87e05be3" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;empty&lt;/code&gt; for types that obey &lt;a href=&quot;#hasLength&quot;&gt;&lt;code&gt;hasLength&lt;/code&gt;&lt;/a&gt; property and for narrow strings. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;a.empty&lt;/code&gt; is equivalent to &lt;code&gt;empty(a)&lt;/code&gt;.</source>
          <target state="translated">Implementa la interfaz de rango primitiva &lt;code&gt;empty&lt;/code&gt; para los tipos que obedecen a la propiedad &lt;a href=&quot;#hasLength&quot;&gt; &lt;code&gt;hasLength&lt;/code&gt; &lt;/a&gt; y para cadenas estrechas. Debido al hecho de que las funciones que no son miembros pueden llamarse con el primer argumento usando la notaci&amp;oacute;n de punto, &lt;code&gt;a.empty&lt;/code&gt; es equivalente a &lt;code&gt;empty(a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62d00f3658d0160b41b82721ed86515030421a62" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;front&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.front&lt;/code&gt; is equivalent to &lt;code&gt;front(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;front&lt;/code&gt; automatically returns the first &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt; as a &lt;code&gt;dchar&lt;/code&gt;.</source>
          <target state="translated">Implementa la interfaz de rango primitivo &lt;code&gt;front&lt;/code&gt; al para matrices integradas. Debido al hecho de que las funciones que no son miembros pueden llamarse con el primer argumento usando la notaci&amp;oacute;n de punto, &lt;code&gt;array.front&lt;/code&gt; es equivalente a &lt;code&gt;front(array)&lt;/code&gt; . Para &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;cadenas estrechas&lt;/a&gt; , &lt;code&gt;front&lt;/code&gt; devuelve autom&amp;aacute;ticamente el primer &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;punto de c&amp;oacute;digo&lt;/a&gt; como &lt;code&gt;dchar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1778775edc47d955b8410b9303b511a8ed36740" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popBack&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popBack&lt;/code&gt; is equivalent to &lt;code&gt;popBack(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically eliminates the last &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;code point&lt;/a&gt;.</source>
          <target state="translated">Implementa la interfaz de rango primitiva &lt;code&gt;popBack&lt;/code&gt; para matrices integradas. Debido al hecho de que las funciones que no son miembros se pueden &lt;code&gt;array.popBack&lt;/code&gt; con el primer argumento usando la notaci&amp;oacute;n de punto, array.popBack es equivalente a &lt;code&gt;popBack(array)&lt;/code&gt; . Para &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;cadenas estrechas&lt;/a&gt; , &lt;code&gt;popFront&lt;/code&gt; elimina autom&amp;aacute;ticamente el &amp;uacute;ltimo &lt;a href=&quot;http://dlang.org/glossary.html#code%20point&quot;&gt;punto de c&amp;oacute;digo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32e1749a7e79cab97db7229f8dfe1c2b12d27951" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;popFront&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.popFront&lt;/code&gt; is equivalent to &lt;code&gt;popFront(array)&lt;/code&gt;. For &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;narrow strings&lt;/a&gt;, &lt;code&gt;popFront&lt;/code&gt; automatically advances to the next code point.</source>
          <target state="translated">Implementa la interfaz de rango primitivo &lt;code&gt;popFront&lt;/code&gt; para matrices integradas. Debido al hecho de que las funciones que no son miembros se pueden &lt;code&gt;array.popFront&lt;/code&gt; con el primer argumento usando la notaci&amp;oacute;n de punto, array.popFront es equivalente a &lt;code&gt;popFront(array)&lt;/code&gt; . Para &lt;a href=&quot;http://dlang.org/glossary.html#narrow%20strings&quot;&gt;cadenas estrechas&lt;/a&gt; , &lt;code&gt;popFront&lt;/code&gt; avanza autom&amp;aacute;ticamente al siguiente punto de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="75f6fe2cdac67a27b3428234729f0d9dae7b1837" translate="yes" xml:space="preserve">
          <source>Implements the range interface primitive &lt;code&gt;save&lt;/code&gt; for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, &lt;code&gt;array.save&lt;/code&gt; is equivalent to &lt;code&gt;save(array)&lt;/code&gt;. The function does not duplicate the content of the array, it simply returns its argument.</source>
          <target state="translated">Implementa el &lt;code&gt;save&lt;/code&gt; primitivo de la interfaz de rango para matrices integradas. Debido al hecho de que las funciones que no son miembros se pueden llamar con el primer argumento usando la notaci&amp;oacute;n de punto, &lt;code&gt;array.save&lt;/code&gt; es equivalente a &lt;code&gt;save(array)&lt;/code&gt; . La funci&amp;oacute;n no duplica el contenido de la matriz, simplemente devuelve su argumento.</target>
        </trans-unit>
        <trans-unit id="03be7c6392b5500acdd65ba4a7628363c1860d1b" translate="yes" xml:space="preserve">
          <source>Implicit Conversion of Reference Types</source>
          <target state="translated">Conversión implícita de los tipos de referencia</target>
        </trans-unit>
        <trans-unit id="65a63aa075b83c2fd9eb74a28a95e05ff02e65a6" translate="yes" xml:space="preserve">
          <source>Implicit Conversions</source>
          <target state="translated">Conversiones implícitas</target>
        </trans-unit>
        <trans-unit id="625a5d30e95ccd8e77f05af4dd624ce180fd702c" translate="yes" xml:space="preserve">
          <source>Implicit Nesting</source>
          <target state="translated">Anidación implícita</target>
        </trans-unit>
        <trans-unit id="341437e8c6d229adb9641f4f980b4bd232dec666" translate="yes" xml:space="preserve">
          <source>Implicit Qualifier Conversions</source>
          <target state="translated">Conversiones de calificadores implícitos</target>
        </trans-unit>
        <trans-unit id="e71105f02c13309129677ece5605a0283f9f1fad" translate="yes" xml:space="preserve">
          <source>Implicit Type Inference</source>
          <target state="translated">Inferencia de tipo implícito</target>
        </trans-unit>
        <trans-unit id="849cfc1637b33ec7b03284c956943ea3a6ee1ec6" translate="yes" xml:space="preserve">
          <source>Implicit conversions are used to automatically convert types as required.</source>
          <target state="translated">Las conversiones implícitas se utilizan para convertir automáticamente los tipos según sea necesario.</target>
        </trans-unit>
        <trans-unit id="16ca50dfa8d5e344f045161409c8efa6033ef01d" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue, like &lt;code&gt;toString&lt;/code&gt;, but also passes</source>
          <target state="translated">Llama impl&amp;iacute;citamente &lt;code&gt;toJSON&lt;/code&gt; en este JsonValue, como &lt;code&gt;toString&lt;/code&gt; , pero tambi&amp;eacute;n pasa</target>
        </trans-unit>
        <trans-unit id="61b604cd0d4af75ee155d0f29fe03ab209cdf393" translate="yes" xml:space="preserve">
          <source>Implicitly calls &lt;code&gt;toJSON&lt;/code&gt; on this JSONValue.</source>
          <target state="translated">Llama impl&amp;iacute;citamente &lt;code&gt;toJSON&lt;/code&gt; en este JsonValue.</target>
        </trans-unit>
        <trans-unit id="fe09202f421258205fc0af0f7cc90ba8af70d44d" translate="yes" xml:space="preserve">
          <source>Import Declaration</source>
          <target state="translated">Declaración de importación</target>
        </trans-unit>
        <trans-unit id="07b4de4b6291e3b54e69fe2f2020c76048ffb706" translate="yes" xml:space="preserve">
          <source>Import Expressions</source>
          <target state="translated">Expresiones de importación</target>
        </trans-unit>
        <trans-unit id="9633d9e6ebf62f84de8d5fc4824a9ee44e1f1708" translate="yes" xml:space="preserve">
          <source>Import declarations may be used at any scope. For example:</source>
          <target state="translated">Las declaraciones de importación pueden utilizarse en cualquier ámbito.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="e0559377cfba6b8aed12863122b1b2dcc118cb64" translate="yes" xml:space="preserve">
          <source>ImportDeclaration</source>
          <target state="translated">ImportDeclaration</target>
        </trans-unit>
        <trans-unit id="015ce9a6eb4a1d7698028975a16c0fe2ee6d7aa2" translate="yes" xml:space="preserve">
          <source>Improve behavior of allocators sensitive to allocation sizes, such as &lt;code&gt;FreeList&lt;/code&gt; and &lt;code&gt;FreeTree&lt;/code&gt;. Rounding allocation requests up makes for smaller free lists/trees at the cost of slack memory (internal fragmentation).</source>
          <target state="translated">Mejore el comportamiento de los asignadores sensibles a los tama&amp;ntilde;os de asignaci&amp;oacute;n, como &lt;code&gt;FreeList&lt;/code&gt; y &lt;code&gt;FreeTree&lt;/code&gt; . Al redondear las solicitudes de asignaci&amp;oacute;n, se crean listas / &amp;aacute;rboles libres m&amp;aacute;s peque&amp;ntilde;os a costa de memoria floja (fragmentaci&amp;oacute;n interna).</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="dcd96af0868ef4c663e6ad3dcef261c5095893f1" translate="yes" xml:space="preserve">
          <source>In C, arrays are passed to functions as pointers even if the function prototype says its an array. In D, static arrays are passed by value, not by reference. Thus, the function prototype must be adjusted to match what C expects.</source>
          <target state="translated">En C,las matrices se pasan a las funciones como punteros incluso si el prototipo de la función dice que es una matriz.En D,las matrices estáticas se pasan por valor,no por referencia.Por lo tanto,el prototipo de la función debe ajustarse para que coincida con lo que C espera.</target>
        </trans-unit>
        <trans-unit id="fb107b811fc18be0d73632390771a7270ede12ef" translate="yes" xml:space="preserve">
          <source>In Expressions</source>
          <target state="translated">En expresiones</target>
        </trans-unit>
        <trans-unit id="98ab2686a50e4805c42c072cadd55e7f182ad96a" translate="yes" xml:space="preserve">
          <source>In a Windows DLL, if this function is called via DllMain with argument DLL_PROCESS_DETACH, the thread is terminated forcefully without proper cleanup as a deadlock would happen otherwise.</source>
          <target state="translated">En una DLL de Windows,si esta función es llamada vía DllMain con el argumento DLL_PROCESS_DETACH,el hilo se termina a la fuerza sin una limpieza adecuada,ya que de lo contrario se produciría un punto muerto.</target>
        </trans-unit>
        <trans-unit id="31b5ad319495b8bf3a1c002a8507f2abf1208f6d" translate="yes" xml:space="preserve">
          <source>In a constructor body, if a delegate constructor is called, all field assignments are considered assignments. Otherwise, the first instance of field assignment is its initialization, and assignments of the form &lt;code&gt;field = expression&lt;/code&gt; are treated as equivalent to &lt;code&gt;typeof(field)(expression)&lt;/code&gt;. The values of fields may be read before initialization or construction with a delegate constructor.</source>
          <target state="translated">En un cuerpo de constructor, si se llama a un constructor delegado, todas las asignaciones de campo se consideran asignaciones. De lo contrario, la primera instancia de asignaci&amp;oacute;n de campo es su inicializaci&amp;oacute;n, y las asignaciones de la forma &lt;code&gt;field = expression&lt;/code&gt; se tratan como equivalentes a &lt;code&gt;typeof(field)(expression)&lt;/code&gt; . Los valores de los campos se pueden leer antes de la inicializaci&amp;oacute;n o construcci&amp;oacute;n con un constructor delegado.</target>
        </trans-unit>
        <trans-unit id="58b4b4504d8850da0fbabfc52a3239ec3b0e0a33" translate="yes" xml:space="preserve">
          <source>In a constructor body, the first instance of field assignment is its initialization.</source>
          <target state="translated">En un cuerpo constructor,la primera instancia de la asignación de campo es su inicialización.</target>
        </trans-unit>
        <trans-unit id="3c66c503e379c4155d015b11fbc1dc5940286649" translate="yes" xml:space="preserve">
          <source>In a declaration declaring multiple symbols, all the declarations must be of the same type:</source>
          <target state="translated">En una declaración que declara múltiples símbolos,todas las declaraciones deben ser del mismo tipo:</target>
        </trans-unit>
        <trans-unit id="9e9fe9946b014b42fb5205022b5c12ede51b25c5" translate="yes" xml:space="preserve">
          <source>In a typical application, you might also want to consider using a non-blocking socket instead of setting a timeout on a blocking one.</source>
          <target state="translated">En una aplicación típica,también podría considerar el uso de un enchufe sin bloqueo en lugar de establecer un tiempo de espera en uno con bloqueo.</target>
        </trans-unit>
        <trans-unit id="190918005b49f5fd22012e2b51e50c26bb8bb06b" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;#Variant&quot;&gt;&lt;code&gt;Variant&lt;/code&gt;&lt;/a&gt;, this module also defines the &lt;a href=&quot;#Algebraic&quot;&gt;&lt;code&gt;Algebraic&lt;/code&gt;&lt;/a&gt; type constructor. Unlike &lt;code&gt;Variant&lt;/code&gt;, &lt;code&gt;Algebraic&lt;/code&gt; only allows a finite set of types, which are specified in the instantiation (e.g. &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; may only hold an &lt;code&gt;int&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;).</source>
          <target state="translated">Adem&amp;aacute;s de &lt;a href=&quot;#Variant&quot;&gt; &lt;code&gt;Variant&lt;/code&gt; &lt;/a&gt; , este m&amp;oacute;dulo tambi&amp;eacute;n define el constructor de tipo &lt;a href=&quot;#Algebraic&quot;&gt; &lt;code&gt;Algebraic&lt;/code&gt; &lt;/a&gt; . A diferencia de &lt;code&gt;Variant&lt;/code&gt; , &lt;code&gt;Algebraic&lt;/code&gt; solo permite un conjunto finito de tipos, que se especifican en la instanciaci&amp;oacute;n (por ejemplo, &lt;code&gt;Algebraic!(int, string)&lt;/code&gt; solo puede contener un &lt;code&gt;int&lt;/code&gt; o una &lt;code&gt;string&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd56298f652baf17103962e16813e3a6aed52cf4" translate="yes" xml:space="preserve">
          <source>In addition to convenience, these functions are slightly more efficient than manually creating an Fft object for a single use, as the Fft object is deterministically destroyed before these functions return.</source>
          <target state="translated">Además de la conveniencia,estas funciones son ligeramente más eficientes que la creación manual de un objeto Fft para un solo uso,ya que el objeto Fft se destruye de forma determinante antes de que estas funciones regresen.</target>
        </trans-unit>
        <trans-unit id="570c956c4c6e2dbde87f61ff5e2c49153a8df2e6" translate="yes" xml:space="preserve">
          <source>In addition to random number generators, this module features distributions, which skew a generator's output statistical distribution in various ways. So far the uniform distribution for integers and real numbers have been implemented.</source>
          <target state="translated">Además de los generadores de números aleatorios,este módulo presenta distribuciones,que sesgan la distribución estadística de salida de un generador de varias maneras.Hasta ahora se ha implementado la distribución uniforme para números enteros y reales.</target>
        </trans-unit>
        <trans-unit id="5295840dbe23153fe2e689d001aa6ebadfba5f26" translate="yes" xml:space="preserve">
          <source>In addition, --DRT-gcopt=help will show the list of options and their current settings.</source>
          <target state="translated">Además,--DRT-gcopt=help mostrará la lista de opciones y su configuración actual.</target>
        </trans-unit>
        <trans-unit id="b2fcea4fb949d2ee554c72114c12b58084a4d18d" translate="yes" xml:space="preserve">
          <source>In addition, the data &lt;code&gt;callerSize&lt;/code&gt;, &lt;code&gt;callerModule&lt;/code&gt;, &lt;code&gt;callerFile&lt;/code&gt;, &lt;code&gt;callerLine&lt;/code&gt;, and &lt;code&gt;callerTime&lt;/code&gt; is associated with each specific allocation. This data prefixes each allocation.</source>
          <target state="translated">Adem&amp;aacute;s, los datos &lt;code&gt;callerSize&lt;/code&gt; , &lt;code&gt;callerModule&lt;/code&gt; , &lt;code&gt;callerFile&lt;/code&gt; , &lt;code&gt;callerLine&lt;/code&gt; y &lt;code&gt;callerTime&lt;/code&gt; est&amp;aacute;n asociados con cada asignaci&amp;oacute;n espec&amp;iacute;fica. Estos datos prefijan cada asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8bb9d27fa1cfa7a17c0f438e8ee45a8ac856bdb5" translate="yes" xml:space="preserve">
          <source>In algorithms partitioning ranges in two, preserve relative ordering of elements only to the left of the partition point.</source>
          <target state="translated">En los algoritmos que dividen los rangos en dos,conservan el orden relativo de los elementos sólo a la izquierda del punto de partición.</target>
        </trans-unit>
        <trans-unit id="a4c7a53fdd584b663429b65ac4f17edc28d07354" translate="yes" xml:space="preserve">
          <source>In all cases the function returns the built-in result of &lt;code&gt;lhs == rhs&lt;/code&gt;.</source>
          <target state="translated">En todos los casos, la funci&amp;oacute;n devuelve el resultado incorporado de &lt;code&gt;lhs == rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a66898347b51f7c1d0527a1edb8a6b3cf367a27a" translate="yes" xml:space="preserve">
          <source>In all cases, a two-symbols versions is also accepted, in which case the first symbol (of integral type, e.g. &lt;code&gt;ulong&lt;/code&gt; or &lt;code&gt;uint&lt;/code&gt;) tracks the zero-based number of the current line.</source>
          <target state="translated">En todos los casos, tambi&amp;eacute;n se acepta una versi&amp;oacute;n de dos s&amp;iacute;mbolos, en cuyo caso el primer s&amp;iacute;mbolo (de tipo integral, por ejemplo, &lt;code&gt;ulong&lt;/code&gt; o &lt;code&gt;uint&lt;/code&gt; ) rastrea el n&amp;uacute;mero de la l&amp;iacute;nea actual basado en cero.</target>
        </trans-unit>
        <trans-unit id="fb219f6585d8061af3f052a290762bb948e1e8d6" translate="yes" xml:space="preserve">
          <source>In all cases, returns &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt;. The result is not autocorrected in case of an erroneous comparison.</source>
          <target state="translated">En todos los casos, devuelve &lt;code&gt;lhs &amp;lt; rhs ? -1 : lhs &amp;gt; rhs&lt;/code&gt; . El resultado no se corrige autom&amp;aacute;ticamente en caso de una comparaci&amp;oacute;n err&amp;oacute;nea.</target>
        </trans-unit>
        <trans-unit id="cb4bca7a9dd4559557c8f7c4ee56255838258c7f" translate="yes" xml:space="preserve">
          <source>In all cases, the concatenation of the returned ranges spans the entire &lt;code&gt;haystack&lt;/code&gt;.</source>
          <target state="translated">En todos los casos, la concatenaci&amp;oacute;n de los rangos devueltos abarca todo el &lt;code&gt;haystack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fac8533d039fb2ca10f37bea36476dc0de1df00b" translate="yes" xml:space="preserve">
          <source>In all other cases, a simple element by element addition is done.</source>
          <target state="translated">En todos los demás casos,se hace una simple adición elemento por elemento.</target>
        </trans-unit>
        <trans-unit id="394148797f50691adb9a270f990a5eaca722863e" translate="yes" xml:space="preserve">
          <source>In all other cases, the built-in behavior is carried out.</source>
          <target state="translated">En todos los demás casos,el comportamiento incorporado se lleva a cabo.</target>
        </trans-unit>
        <trans-unit id="b68e1d58907e07140ccd3efadbc43c332f170e2d" translate="yes" xml:space="preserve">
          <source>In all other respects this function works just like &lt;code&gt;spawnProcess&lt;/code&gt;. Please refer to the &lt;a href=&quot;#spawnProcess&quot;&gt;&lt;code&gt;spawnProcess&lt;/code&gt;&lt;/a&gt; documentation for descriptions of the other function parameters, the return value and any exceptions that may be thrown.</source>
          <target state="translated">En todos los dem&amp;aacute;s aspectos, esta funci&amp;oacute;n funciona igual que &lt;code&gt;spawnProcess&lt;/code&gt; . Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;#spawnProcess&quot;&gt; &lt;code&gt;spawnProcess&lt;/code&gt; &lt;/a&gt; para obtener descripciones de los otros par&amp;aacute;metros de la funci&amp;oacute;n, el valor de retorno y cualquier excepci&amp;oacute;n que pueda generarse.</target>
        </trans-unit>
        <trans-unit id="1cc108da5c2c3788f98a6edf95e1a63a36afb311" translate="yes" xml:space="preserve">
          <source>In all string literal forms, an &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; is regarded as a single &lt;code&gt;\n&lt;/code&gt; character.</source>
          <target state="translated">En todas las formas literales de cadena, una &lt;a href=&quot;#EndOfLine&quot;&gt;&lt;i&gt;EndOfLine&lt;/i&gt;&lt;/a&gt; se considera como un &amp;uacute;nico &lt;code&gt;\n&lt;/code&gt; car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="60b9a383afd7a0fd8bdda37a3d66b0a2bbb686e7" translate="yes" xml:space="preserve">
          <source>In all the other respects, these methods are like any other methods. They can be static, have different linkages, have their address taken, etc.</source>
          <target state="translated">En todos los demás aspectos,estos métodos son como cualquier otro método.Pueden ser estáticos,tener diferentes vínculos,tener su dirección tomada,etc.</target>
        </trans-unit>
        <trans-unit id="4560285d4cfc645e0ef24ee3db5890ff1443ed09" translate="yes" xml:space="preserve">
          <source>In both C++ and D, if a struct has zero fields, the struct still has a size of 1 byte. But, in C++ if the struct with zero fields is used as a base struct, its size is zero (called the &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;Empty Base Optimization&lt;/a&gt;). There are two methods for emulating this behavior in D. The first forwards references to a function returning a faked reference to the base:</source>
          <target state="translated">Tanto en C ++ como en D, si una estructura tiene cero campos, la estructura a&amp;uacute;n tiene un tama&amp;ntilde;o de 1 byte. Pero, en C ++, si la estructura con campos cero se usa como estructura base, su tama&amp;ntilde;o es cero (llamada &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot;&gt;Optimizaci&amp;oacute;n de base vac&amp;iacute;a&lt;/a&gt; ). Hay dos m&amp;eacute;todos para emular este comportamiento en D. La primera reenv&amp;iacute;a referencias a una funci&amp;oacute;n que devuelve una referencia falsa a la base:</target>
        </trans-unit>
        <trans-unit id="b076421b0fbcae191c5dc3ef2368683aca391393" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier starting with &lt;code&gt; &quot;%(&quot;&lt;/code&gt; and ending with &lt;code&gt;&quot;%)&quot;&lt;/code&gt;, &lt;code&gt;_nested&lt;/code&gt; contains the string contained within the two separators.</source>
          <target state="translated">En el caso de un especificador de formato compuesto que comienza con &lt;code&gt; &quot;%(&quot;&lt;/code&gt; y termina con &lt;code&gt;&quot;%)&quot;&lt;/code&gt; , &lt;code&gt;_nested&lt;/code&gt; contiene la cadena contenida dentro de los dos separadores.</target>
        </trans-unit>
        <trans-unit id="b3a4dc18e455dc36e9fd73a88e062b9df8c0d722" translate="yes" xml:space="preserve">
          <source>In case of a compound format specifier, &lt;code&gt;_sep&lt;/code&gt; contains the string positioning after &lt;code&gt;&quot;%|&quot;&lt;/code&gt;. &lt;code&gt;sep is null&lt;/code&gt; means no separator else &lt;code&gt;sep.empty&lt;/code&gt; means 0 length separator.</source>
          <target state="translated">En el caso de un especificador de formato compuesto, &lt;code&gt;_sep&lt;/code&gt; contiene el posicionamiento de la cadena despu&amp;eacute;s de &lt;code&gt;&quot;%|&quot;&lt;/code&gt; . &lt;code&gt;sep is null&lt;/code&gt; significa que no hay separador m&amp;aacute;s &lt;code&gt;sep.empty&lt;/code&gt; significa separador de longitud 0.</target>
        </trans-unit>
        <trans-unit id="c172129354e9ba73756e23e6e1f6e0e605a52cb9" translate="yes" xml:space="preserve">
          <source>In case of a log message with &lt;code&gt;LogLevel.fatal&lt;/code&gt; nothing will happen.</source>
          <target state="translated">En el caso de un mensaje de registro con &lt;code&gt;LogLevel.fatal&lt;/code&gt; no suceder&amp;aacute; nada.</target>
        </trans-unit>
        <trans-unit id="3ebef375cea9cd0eca25afb26b6d5c11eab7f3f0" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, an &lt;code&gt;StdioException&lt;/code&gt; is thrown.</source>
          <target state="translated">En caso de un error de E / S, se lanza una &lt;code&gt;StdioException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39a07628e75ba54420c0ee35d2d7947fae3e6e95" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;a href=&quot;#StdioException&quot;&gt;&lt;code&gt;StdioException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En caso de un error de E / S, lanza una &lt;a href=&quot;#StdioException&quot;&gt; &lt;code&gt;StdioException&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c94ce1719c011e5c08b47d8a880eaa8ed1ab504" translate="yes" xml:space="preserve">
          <source>In case of an I/O error, throws an &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">En caso de un error de E / S, lanza una &lt;code&gt;StdioException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="072442afd2ab0da30ef9131acbdaeefa3c16749b" translate="yes" xml:space="preserve">
          <source>In case you want to only enable bundling for some of the parameters, bundling can be turned off with &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt;.</source>
          <target state="translated">En caso de que solo desee habilitar la agrupaci&amp;oacute;n para algunos de los par&amp;aacute;metros, la agrupaci&amp;oacute;n se puede desactivar con &lt;code&gt;std.getopt.config.noBundling&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01d85046192eeac78a5da365dc7670fdea8d6e86" translate="yes" xml:space="preserve">
          <source>In cases where producing the replacement is the ultimate goal &lt;a href=&quot;#replaceFirstInto&quot;&gt;&lt;code&gt;replaceFirstInto&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#replaceAllInto&quot;&gt;&lt;code&gt;replaceAllInto&lt;/code&gt;&lt;/a&gt; could come in handy as functions that avoid allocations even for replacement.</source>
          <target state="translated">En los casos en que producir el reemplazo es el objetivo final, &lt;a href=&quot;#replaceFirstInto&quot;&gt; &lt;code&gt;replaceFirstInto&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#replaceAllInto&quot;&gt; &lt;code&gt;replaceAllInto&lt;/code&gt; &lt;/a&gt; podr&amp;iacute;an ser &amp;uacute;tiles como funciones que evitan las asignaciones incluso para el reemplazo.</target>
        </trans-unit>
        <trans-unit id="e6177e81e2c8557108ce3bebc0ad228b2a46f372" translate="yes" xml:space="preserve">
          <source>In cases where the operand size is ambiguous, as in:</source>
          <target state="translated">En los casos en que el tamaño del operando es ambiguo,como en:</target>
        </trans-unit>
        <trans-unit id="a7faf0c1f2db2bcd1f30944e523bc6e5d4329044" translate="yes" xml:space="preserve">
          <source>In cases where the string in question is already normalized, it is returned unmodified and no memory allocation happens.</source>
          <target state="translated">En los casos en que la cadena en cuestión ya está normalizada,se devuelve sin modificar y no se produce ninguna asignación de memoria.</target>
        </trans-unit>
        <trans-unit id="7c2d083ad99e82982be1c8520585485c563982d6" translate="yes" xml:space="preserve">
          <source>In detail, &lt;code&gt;__delete(x)&lt;/code&gt; returns with no effect if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. Otherwise, it performs the following actions in sequence:</source>
          <target state="translated">En detalle, &lt;code&gt;__delete(x)&lt;/code&gt; regresa sin efecto si &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;null&lt;/code&gt; . De lo contrario, realiza las siguientes acciones en secuencia:</target>
        </trans-unit>
        <trans-unit id="1a253df89cf875b96f6b0b99a704c14478bd5687" translate="yes" xml:space="preserve">
          <source>In effect &lt;code&gt;takeOne(r)&lt;/code&gt; is somewhat equivalent to &lt;code&gt;take(r, 1)&lt;/code&gt; but in certain interfaces it is important to know statically that the range may only have at most one element.</source>
          <target state="translated">En efecto, &lt;code&gt;takeOne(r)&lt;/code&gt; es algo equivalente a &lt;code&gt;take(r, 1)&lt;/code&gt; pero en ciertas interfaces es importante saber est&amp;aacute;ticamente que el rango solo puede tener como m&amp;aacute;ximo un elemento.</target>
        </trans-unit>
        <trans-unit id="c7e90e95cc2e5d025786e563cb98d86e57f261c9" translate="yes" xml:space="preserve">
          <source>In either case, the content of the buffer is reused across calls. That means &lt;code&gt;front&lt;/code&gt; will not persist after &lt;code&gt;popFront&lt;/code&gt; is called, so if retention is needed, the caller must copy its contents (e.g. by calling &lt;code&gt;buffer.dup&lt;/code&gt;).  In the example above, &lt;code&gt;buffer.length&lt;/code&gt; is 4096 for all iterations, except for the last one, in which case &lt;code&gt;buffer.length&lt;/code&gt; may be less than 4096 (but always greater than zero).  With the mentioned limitations, &lt;code&gt;byChunk&lt;/code&gt; works with any algorithm compatible with input ranges.</source>
          <target state="translated">En cualquier caso, el contenido del b&amp;uacute;fer se reutiliza en las llamadas. Eso significa que &lt;code&gt;front&lt;/code&gt; no persistir&amp;aacute; despu&amp;eacute;s de &lt;code&gt;popFront&lt;/code&gt; , por lo que si se necesita retenci&amp;oacute;n, la persona que llama debe copiar su contenido (por ejemplo, llamando a &lt;code&gt;buffer.dup&lt;/code&gt; ). En el ejemplo anterior, &lt;code&gt;buffer.length&lt;/code&gt; es 4096 para todas las iteraciones, excepto la &amp;uacute;ltima, en cuyo caso &lt;code&gt;buffer.length&lt;/code&gt; puede ser menor que 4096 (pero siempre mayor que cero). Con las limitaciones mencionadas, &lt;code&gt;byChunk&lt;/code&gt; funciona con cualquier algoritmo compatible con rangos de entrada.</target>
        </trans-unit>
        <trans-unit id="8ec7633257f9bdb307965ba1607259244c489e1d" translate="yes" xml:space="preserve">
          <source>In free list mode, &lt;code&gt;KRRegion&lt;/code&gt; embeds a free blocks list onto the chunk of memory. The free list is circular, coalesced, and sorted by address at all times. Allocations and deallocations take time proportional to the number of previously deallocated blocks. (In practice the cost may be lower, e.g. if memory is deallocated in reverse order of allocation, all operations take constant time.) Memory utilization is good (small control structure and no per-allocation overhead). The disadvantages of freelist mode include proneness to fragmentation, a minimum allocation size of two words, and linear worst-case allocation and deallocation times.</source>
          <target state="translated">En el modo de lista libre, &lt;code&gt;KRRegion&lt;/code&gt; incrusta una lista de bloques libres en la porci&amp;oacute;n de memoria. La lista gratuita es circular, combinada y ordenada por direcci&amp;oacute;n en todo momento. Las asignaciones y las desasignaciones toman tiempo proporcional al n&amp;uacute;mero de bloques previamente desasignados. (En la pr&amp;aacute;ctica, el costo puede ser menor, por ejemplo, si la memoria se desasigna en orden inverso de asignaci&amp;oacute;n, todas las operaciones toman tiempo constante.) La utilizaci&amp;oacute;n de la memoria es buena (estructura de control peque&amp;ntilde;a y sin sobrecarga por asignaci&amp;oacute;n). Las desventajas del modo de lista libre incluyen la propensi&amp;oacute;n a la fragmentaci&amp;oacute;n, un tama&amp;ntilde;o m&amp;iacute;nimo de asignaci&amp;oacute;n de dos palabras y tiempos de asignaci&amp;oacute;n y desasignaci&amp;oacute;n lineal en el peor de los casos.</target>
        </trans-unit>
        <trans-unit id="cdf7807c516e1443dffb3bd59e60f6a917c9df07" translate="yes" xml:space="preserve">
          <source>In function scopes, imported symbols only become visible after the import declaration lexically appears in the function body. In other words, imported symbols at function scope cannot be forward referenced.</source>
          <target state="translated">En los alcances de las funciones,los símbolos importados sólo se hacen visibles después de que la declaración de importación aparece léxicamente en el cuerpo de la función.En otras palabras,los símbolos importados en el ámbito de la función no pueden ser referenciados hacia adelante.</target>
        </trans-unit>
        <trans-unit id="c0383119e4652a168035af7434f3705bce886b19" translate="yes" xml:space="preserve">
          <source>In functional programming languages this is typically called &lt;code&gt;scan&lt;/code&gt;, &lt;code&gt;scanl&lt;/code&gt;, &lt;code&gt;scanLeft&lt;/code&gt; or &lt;code&gt;reductions&lt;/code&gt;.</source>
          <target state="translated">En los lenguajes de programaci&amp;oacute;n funcionales, esto se suele llamar &lt;code&gt;scan&lt;/code&gt; , &lt;code&gt;scanl&lt;/code&gt; , &lt;code&gt;scanLeft&lt;/code&gt; o &lt;code&gt;reductions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fb398e80e5a7daebe5fe79cc756231990bf0b4c" translate="yes" xml:space="preserve">
          <source>In general one should always wait for child processes to terminate before exiting the parent process unless the process was spawned as detached (that was spawned with &lt;code&gt;Config.detached&lt;/code&gt; flag). Otherwise, they may become &quot;&lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;zombies&lt;/a&gt;&quot; &amp;ndash; processes that are defunct, yet still occupy a slot in the OS process table. You should not and must not wait for detached processes, since you don't own them.</source>
          <target state="translated">En general, siempre se debe esperar a que finalicen los procesos secundarios antes de salir del proceso principal a menos que el proceso se haya generado como desconectado (que se gener&amp;oacute; con el indicador &lt;code&gt;Config.detached&lt;/code&gt; ). De lo contrario, pueden convertirse en &quot; &lt;a href=&quot;http://en.wikipedia.org/wiki/Zombie_process&quot;&gt;zombis&lt;/a&gt; &quot;, procesos que est&amp;aacute;n difuntos, pero que a&amp;uacute;n ocupan un espacio en la tabla de procesos del sistema operativo. No debe y no debe esperar los procesos separados, ya que no los posee.</target>
        </trans-unit>
        <trans-unit id="2a9fd3d1c20814161b33ee0afa7c06fcf185414e" translate="yes" xml:space="preserve">
          <source>In general periodically 'reseeding' a PRNG does not improve its quality and in some cases may harm it. For an extreme example the Mersenne Twister has &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; distinct states but after &lt;code&gt;seed(uint)&lt;/code&gt; is called it can only be in one of &lt;code&gt;2 ^^ 32&lt;/code&gt; distinct states regardless of how excellent the source of entropy is.</source>
          <target state="translated">En general, &quot;resiembrar&quot; peri&amp;oacute;dicamente un PRNG no mejora su calidad y, en algunos casos, puede da&amp;ntilde;arlo. Para un ejemplo extremo, el Mersenne Twister tiene &lt;code&gt;2 ^^ 19937 - 1&lt;/code&gt; estados distintos, pero despu&amp;eacute;s de que se llama &lt;code&gt;seed(uint)&lt;/code&gt; solo puede estar en &lt;code&gt;2 ^^ 32&lt;/code&gt; estados distintos, independientemente de cu&amp;aacute;n excelente sea la fuente de entrop&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="fc32a5290aa168583cf02dd9b13039ee5589d851" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module assume that the input paths are well-formed. (That is, they should not contain invalid characters, they should follow the file system's path format, etc.) The result of calling a function on an ill-formed path is undefined. When there is a chance that a path or a file name is invalid (for instance, when it has been input by the user), it may sometimes be desirable to use the &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#isValidPath&quot;&gt;&lt;code&gt;isValidPath&lt;/code&gt;&lt;/a&gt; functions to check this.</source>
          <target state="translated">En general, las funciones de este m&amp;oacute;dulo suponen que las rutas de entrada est&amp;aacute;n bien formadas. (Es decir, no deben contener caracteres no v&amp;aacute;lidos, deben seguir el formato de ruta del sistema de archivos, etc.) El resultado de llamar a una funci&amp;oacute;n en una ruta mal formada no est&amp;aacute; definido. Cuando existe la posibilidad de que una ruta o un nombre de archivo no sea v&amp;aacute;lido (por ejemplo, cuando ha sido ingresado por el usuario), a veces puede ser conveniente utilizar las funciones &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt; e &lt;a href=&quot;#isValidPath&quot;&gt; &lt;code&gt;isValidPath&lt;/code&gt; &lt;/a&gt; para verificar esto.</target>
        </trans-unit>
        <trans-unit id="7566506eebd3c530fd7b49f9458b9e3829cd9289" translate="yes" xml:space="preserve">
          <source>In many cases, calls to sizeof() can't be used directly for getting data type sizes since cross compiling is supported and would end up using the host sizes rather than the target sizes.</source>
          <target state="translated">En muchos casos,las llamadas a sizeof()no pueden utilizarse directamente para obtener los tamaños de los tipos de datos,ya que se admite la compilación cruzada y terminaría utilizando los tamaños de los hosts en lugar de los tamaños de los objetivos.</target>
        </trans-unit>
        <trans-unit id="35dd64591779170e8008d349dad053c6fa8f2446" translate="yes" xml:space="preserve">
          <source>In nested</source>
          <target state="translated">En anidado</target>
        </trans-unit>
        <trans-unit id="8575ac5b58d78f8ffa7cfeed41b65f5b48950967" translate="yes" xml:space="preserve">
          <source>In older versions of Phobos, it used to be possible to write:</source>
          <target state="translated">En versiones antiguas de Fobos,solía ser posible escribir:</target>
        </trans-unit>
        <trans-unit id="2e095fc6159a0d37540c3fe665eef32c69ad9690" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;Logger&lt;/code&gt; must be greater or equal to the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">Para que los datos se procesen, el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;Logger&lt;/code&gt; debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; global .</target>
        </trans-unit>
        <trans-unit id="60952b4bdab4bfb5f5a8d1d83bb07430530eeffe" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; add the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para que los datos se procesen, el &lt;code&gt;LogLevel&lt;/code&gt; de &lt;code&gt;sharedLog&lt;/code&gt; debe ser mayor o igual que &lt;code&gt;defaultLogLevel&lt;/code&gt; , la condici&amp;oacute;n pasada debe ser &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e11fddcd19d6f16f616c57c6e260430b0f9d9a4" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">Para que los datos se procesen, el &lt;code&gt;LogLevel&lt;/code&gt; de &lt;code&gt;sharedLog&lt;/code&gt; debe ser mayor o igual que &lt;code&gt;defaultLogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8c65e46c163f6fc77fddc2b9a77d78f4961ef7" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para que se procesen los datos, el &lt;code&gt;LogLevel&lt;/code&gt; de la llamada de registro debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; de &lt;code&gt;sharedLog&lt;/code&gt; y el &lt;code&gt;defaultLogLevel&lt;/code&gt; , adem&amp;aacute;s, la condici&amp;oacute;n pasada debe ser &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed49a17d9874b268342f0db2f71435916af05001" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">Para que los datos se procesen, el &lt;code&gt;LogLevel&lt;/code&gt; de la llamada de registro debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; de &lt;code&gt;sharedLog&lt;/code&gt; y &lt;code&gt;defaultLogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c93e7b85e99ec02f5d168562dae2b831dda8259" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt;.</source>
          <target state="translated">Para que los datos se procesen, el &lt;code&gt;LogLevel&lt;/code&gt; de la llamada de registro debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; de &lt;code&gt;sharedLog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f87139f757185970527b89c7ad28046b560c58f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para que se procesen los datos, el &lt;code&gt;LogLevel&lt;/code&gt; de la llamada de registro debe ser mayor o igual que &lt;code&gt;defaultLogLevel&lt;/code&gt; , adem&amp;aacute;s, la condici&amp;oacute;n pasada debe ser &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a54f9edb0000f15c332443c24f6eb668c55c8501" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;defaultLogLevel&lt;/code&gt;.</source>
          <target state="translated">Para que los datos se procesen, el &lt;code&gt;LogLevel&lt;/code&gt; de la llamada de registro debe ser mayor o igual que &lt;code&gt;defaultLogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14b107fabc6c81ab2222b96dfa0c1ecd6dfba19f" translate="yes" xml:space="preserve">
          <source>In order for the data to be processed, the &lt;code&gt;LogLevel&lt;/code&gt; of the log call must be greater or equal to the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and the &lt;code&gt;defaultLogLevel&lt;/code&gt;; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para que se procesen los datos, el &lt;code&gt;LogLevel&lt;/code&gt; de la llamada de registro debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; de &lt;code&gt;sharedLog&lt;/code&gt; y &lt;code&gt;defaultLogLevel&lt;/code&gt; ; Adem&amp;aacute;s, la condici&amp;oacute;n aprobada debe ser &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bb3ac7d5c9d6c962a9241e9025396626aa9beb6" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;sharedLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;.</source>
          <target state="translated">Para que el mensaje de registro resultante se registre, el &lt;code&gt;LogLevel&lt;/code&gt; debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;sharedLog&lt;/code&gt; y debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; global . Adem&amp;aacute;s, el &lt;code&gt;LogLevel&lt;/code&gt; debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;stdSharedLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79abe30476f4ca10a8c01c609e3f868cb8a10f27" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdThreadLocalLog&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;. Additionally the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the &lt;code&gt;stdSharedLogger&lt;/code&gt;. If a condition is given, it must evaluate to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para que el mensaje de registro resultante se registre, el &lt;code&gt;LogLevel&lt;/code&gt; debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;stdThreadLocalLog&lt;/code&gt; y debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; global . Adem&amp;aacute;s, el &lt;code&gt;LogLevel&lt;/code&gt; debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;stdSharedLogger&lt;/code&gt; . Si se da una condici&amp;oacute;n, se debe evaluar como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18e494163438a3079c18b40fa80b56a34c4d5c22" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the condition passed must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para que se registre el mensaje de registro resultante, el &lt;code&gt;LogLevel&lt;/code&gt; debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;Logger&lt;/code&gt; usado y debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; global, adem&amp;aacute;s, la condici&amp;oacute;n pasada debe ser &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b84c1fc96a4a1e141069ab63dfce487512e519" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; additionally the passed condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para que se registre el mensaje de registro resultante, el &lt;code&gt;LogLevel&lt;/code&gt; debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;Logger&lt;/code&gt; utilizado y debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; global, adem&amp;aacute;s, la condici&amp;oacute;n pasada debe ser &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8530a345a9b66847038330015135156125389c" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para que se registre el mensaje de registro resultante, el &lt;code&gt;LogLevel&lt;/code&gt; debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;Logger&lt;/code&gt; utilizado y debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; global y la condici&amp;oacute;n debe ser &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20b9f3f3bdcf58be250caee88b15a55353fecc84" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; must be greater or equal than the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; and must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">Para que se registre el mensaje de registro resultante, el &lt;code&gt;LogLevel&lt;/code&gt; debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;Logger&lt;/code&gt; utilizado y debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; global .</target>
        </trans-unit>
        <trans-unit id="41a290703568517f05854f40487a48abaf094d9a" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt; and the condition must be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para que se registre el mensaje de registro resultante, el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;Logger&lt;/code&gt; usado debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; global y la condici&amp;oacute;n debe ser &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61c93a13b86326686a55e702c7620856cee5be12" translate="yes" xml:space="preserve">
          <source>In order for the resulting log message to be logged the &lt;code&gt;LogLevel&lt;/code&gt; of the used &lt;code&gt;Logger&lt;/code&gt; must be greater or equal than the global &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">Para que se registre el mensaje de registro resultante, el &lt;code&gt;LogLevel&lt;/code&gt; del &lt;code&gt;Logger&lt;/code&gt; utilizado debe ser mayor o igual que el &lt;code&gt;LogLevel&lt;/code&gt; global .</target>
        </trans-unit>
        <trans-unit id="9091984c8dee40a3793a920b8fc726ff3fb2b605" translate="yes" xml:space="preserve">
          <source>In order to be usable as an allocator, a type should implement the following methods with their respective semantics. Only &lt;code&gt;alignment&lt;/code&gt; and &lt;code&gt;allocate&lt;/code&gt; are required. If any of the other methods is missing, the allocator is assumed to not have that capability (for example some allocators do not offer manual deallocation of memory). Allocators should NOT implement unsupported methods to always fail. For example, an allocator that lacks the capability to implement &lt;code&gt;alignedAllocate&lt;/code&gt; should not define it at all (as opposed to defining it to always return &lt;code&gt;null&lt;/code&gt; or throw an exception). The missing implementation statically informs other components about the allocator's capabilities and allows them to make design decisions accordingly.</source>
          <target state="translated">Para poder ser utilizado como un asignador, un tipo debe implementar los siguientes m&amp;eacute;todos con sus respectivas sem&amp;aacute;nticas. Solo se requiere &lt;code&gt;alignment&lt;/code&gt; y &lt;code&gt;allocate&lt;/code&gt; . Si falta alguno de los otros m&amp;eacute;todos, se supone que el asignador no tiene esa capacidad (por ejemplo, algunos asignadores no ofrecen desasignaci&amp;oacute;n manual de memoria). Los asignadores NO deben implementar m&amp;eacute;todos no compatibles para que siempre fallen. Por ejemplo, un asignador que carece de la capacidad de implementar &lt;code&gt;alignedAllocate&lt;/code&gt; no deber&amp;iacute;a definirlo en absoluto (en lugar de definirlo para que siempre devuelva &lt;code&gt;null&lt;/code&gt; o arroje una excepci&amp;oacute;n). La implementaci&amp;oacute;n que falta informa est&amp;aacute;ticamente a otros componentes sobre las capacidades del asignador y les permite tomar decisiones de dise&amp;ntilde;o en consecuencia.</target>
        </trans-unit>
        <trans-unit id="6dda110f1f25b5663505eb11f44cd82e44a8c31d" translate="yes" xml:space="preserve">
          <source>In order to determine if an object &lt;code&gt;o&lt;/code&gt; is an instance of a class &lt;code&gt;B&lt;/code&gt; use a cast:</source>
          <target state="translated">Para determinar si un objeto &lt;code&gt;o&lt;/code&gt; es una instancia de una clase &lt;code&gt;B&lt;/code&gt; , use un yeso:</target>
        </trans-unit>
        <trans-unit id="1e18ff30e3740b378cdaf28cc4934f896ccbee30" translate="yes" xml:space="preserve">
          <source>In order to disable logging at compile time, pass &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; as a version argument to the &lt;code&gt;D&lt;/code&gt; compiler when compiling your program code. This will disable all logging functionality. Specific &lt;code&gt;LogLevel&lt;/code&gt; can be disabled at compile time as well. In order to disable logging with the &lt;code&gt;trace&lt;/code&gt;&lt;code&gt;LogLevel&lt;/code&gt; pass &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; as a version. The following table shows which version statement disables which &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">Para deshabilitar el registro en tiempo de compilaci&amp;oacute;n, pase &lt;code&gt;StdLoggerDisableLogging&lt;/code&gt; como argumento de versi&amp;oacute;n al compilador &lt;code&gt;D&lt;/code&gt; cuando compile el c&amp;oacute;digo de su programa. Esto deshabilitar&amp;aacute; toda la funcionalidad de registro. &lt;code&gt;LogLevel&lt;/code&gt; espec&amp;iacute;fico tambi&amp;eacute;n se puede deshabilitar en tiempo de compilaci&amp;oacute;n. Para deshabilitar el registro con el &lt;code&gt;trace&lt;/code&gt; &lt;code&gt;LogLevel&lt;/code&gt; , pase &lt;code&gt;StdLoggerDisableTrace&lt;/code&gt; como versi&amp;oacute;n. La siguiente tabla muestra qu&amp;eacute; declaraci&amp;oacute;n de versi&amp;oacute;n deshabilita qu&amp;eacute; &lt;code&gt;LogLevel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a77a52d87761074b435f02e38ba4ed22e517df1c" translate="yes" xml:space="preserve">
          <source>In order to do put the length at the front, we have to provide 16 bytes buffer space in case the block has to be aligned properly. In x86, certain SSE instructions will only work if the data is 16-byte aligned. In addition, we need the sentinel byte to prevent accidental pointers to the next block. Because of the extra overhead, we only do this for page size and above, where the overhead is minimal compared to the block size.</source>
          <target state="translated">Para poder poner la longitud en la parte delantera,tenemos que proporcionar 16 bytes de espacio de buffer en caso de que el bloque tenga que ser alineado correctamente.En x86,ciertas instrucciones SSE sólo funcionarán si los datos están alineados en 16 bytes.Además,necesitamos el byte centinela para prevenir punteros accidentales al siguiente bloque.Debido a la sobrecarga extra,sólo lo hacemos para el tamaño de la página y superior,donde la sobrecarga es mínima comparada con el tamaño del bloque.</target>
        </trans-unit>
        <trans-unit id="0cc93ffa6b67fa20835799cad3635970d48f4206" translate="yes" xml:space="preserve">
          <source>In order to work, &lt;code&gt;FallbackAllocator&lt;/code&gt; requires that &lt;code&gt;Primary&lt;/code&gt; defines the &lt;code&gt;owns&lt;/code&gt; method. This is needed in order to decide which allocator was responsible for a given allocation.</source>
          <target state="translated">Con el fin de trabajo, &lt;code&gt;FallbackAllocator&lt;/code&gt; requiere que los &lt;code&gt;Primary&lt;/code&gt; define la &lt;code&gt;owns&lt;/code&gt; m&amp;eacute;todo. Esto es necesario para decidir qu&amp;eacute; asignador fue responsable de una asignaci&amp;oacute;n dada.</target>
        </trans-unit>
        <trans-unit id="3cb2dd17fb05bd389b6b34ea2ea85ffe8dc6328a" translate="yes" xml:space="preserve">
          <source>In other words, casting literal expression will change the literal type.</source>
          <target state="translated">En otras palabras,la expresión literal del casting cambiará el tipo literal.</target>
        </trans-unit>
        <trans-unit id="675933f346891ba4fb04a779eea3dd5e21b2c0bb" translate="yes" xml:space="preserve">
          <source>In previous versions of Phobos, this was known as &lt;code&gt;TypeTuple&lt;/code&gt;.</source>
          <target state="translated">En versiones anteriores de Phobos, esto se conoc&amp;iacute;a como &lt;code&gt;TypeTuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26154800831f1a5ff6a19e1167b2ddcacfdb1c76" translate="yes" xml:space="preserve">
          <source>In principle, only thrown objects derived from this class are safe to catch inside a &lt;code&gt;catch&lt;/code&gt; block. Thrown objects not derived from Exception represent runtime errors that should not be caught, as certain runtime guarantees may not hold, making it unsafe to continue program execution.</source>
          <target state="translated">En principio, solo los objetos arrojados derivados de esta clase son seguros de atrapar dentro de un bloque de &lt;code&gt;catch&lt;/code&gt; . Los objetos lanzados que no se derivan de Exception representan errores de tiempo de ejecuci&amp;oacute;n que no deben detectarse, ya que ciertas garant&amp;iacute;as de tiempo de ejecuci&amp;oacute;n pueden no ser v&amp;aacute;lidas, por lo que no es seguro continuar la ejecuci&amp;oacute;n del programa.</target>
        </trans-unit>
        <trans-unit id="0b93464d0fbabeded10a475db02ab91f9147bd5b" translate="yes" xml:space="preserve">
          <source>In principle, this is the name of the local time zone. However, this always returns the empty string. This is because time zones cannot be uniquely identified by the attributes given by the OS (such as the &lt;code&gt;stdName&lt;/code&gt; and &lt;code&gt;dstName&lt;/code&gt;), and neither Posix systems nor Windows systems provide an easy way to get the TZ Database name of the local time zone.</source>
          <target state="translated">En principio, este es el nombre de la zona horaria local. Sin embargo, esto siempre devuelve la cadena vac&amp;iacute;a. Esto se debe a que las zonas horarias no pueden identificarse de forma exclusiva por los atributos dados por el sistema operativo (como &lt;code&gt;stdName&lt;/code&gt; y &lt;code&gt;dstName&lt;/code&gt; ), y ni los sistemas Posix ni los sistemas Windows proporcionan una manera f&amp;aacute;cil de obtener el nombre de la base de datos TZ de la zona horaria local.</target>
        </trans-unit>
        <trans-unit id="0b9fb0301ede6ae1f71c55d50ab376078de554f8" translate="yes" xml:space="preserve">
          <source>In single line mode matches any character. Otherwise it matches any character except '\n' and '\r'.</source>
          <target state="translated">En el modo de línea simple coincide con cualquier personaje.De lo contrario,coincide con cualquier carácter excepto con '\n' y '\N'.</target>
        </trans-unit>
        <trans-unit id="77c1db69e3f99eb322088fa8127b36e0134ab790" translate="yes" xml:space="preserve">
          <source>In some date calculations, adding months or years can cause the date to fall on a day of the month which is not valid (e.g. February 29th 2001 or June 31st 2000). If overflow is allowed (as is the default), then the month will be incremented accordingly (so, February 29th 2001 would become March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow is not allowed, then the day will be adjusted to the last valid day in that month (so, February 29th 2001 would become February 28th 2001 and June 31st 2000 would become June 30th 2000).</source>
          <target state="translated">En algunos cálculos de fechas,la suma de meses o años puede hacer que la fecha caiga en un día del mes que no sea válido (por ejemplo,el 29 de febrero de 2001 o el 31 de junio de 2000).Si se permite el desbordamiento (como es el caso por defecto),entonces el mes se incrementará en consecuencia (así,el 29 de febrero de 2001 se convertiría en el 1 de marzo de 2001,y el 31 de junio de 2000 se convertiría en el 1 de julio de 2000).Si no se permite el desbordamiento,entonces el día se ajustará al último día válido de ese mes (así,el 29 de febrero de 2001 se convertiría en el 28 de febrero de 2001 y el 31 de junio de 2000 en el 30 de junio de 2000).</target>
        </trans-unit>
        <trans-unit id="0f7765db47c238a56000c8a0537e8a769de4649d" translate="yes" xml:space="preserve">
          <source>In std.datetime, it is also used as the result of various arithmetic operations on time points.</source>
          <target state="translated">En std.datetime,también se utiliza como resultado de varias operaciones aritméticas en puntos de tiempo.</target>
        </trans-unit>
        <trans-unit id="9d8f072b0ee81fd114d71e25f9472d419503fd30" translate="yes" xml:space="preserve">
          <source>In the above situations the errors do not contain line numbers because the errors are regarding generated code.</source>
          <target state="translated">En las situaciones anteriores,los errores no contienen números de línea porque los errores se refieren al código generado.</target>
        </trans-unit>
        <trans-unit id="83c0d2545855dad1e2136f8a2d0797213523dbd3" translate="yes" xml:space="preserve">
          <source>In the case above, the element at slot &lt;code&gt;1&lt;/code&gt; is removed, but replaced with the last element of the range. Taking advantage of the relaxation of the stability requirement, &lt;code&gt;remove&lt;/code&gt; moved elements from the end of the array over the slots to be removed. This way there is less data movement to be done which improves the execution time of the function.</source>
          <target state="translated">En el caso anterior, el elemento en la ranura &lt;code&gt;1&lt;/code&gt; se elimina, pero se reemplaza con el &amp;uacute;ltimo elemento del rango. Aprovechando la relajaci&amp;oacute;n del requisito de estabilidad, &lt;code&gt;remove&lt;/code&gt; elementos movidos del extremo de la matriz sobre las ranuras que se eliminar&amp;aacute;n. De esta forma, hay menos movimiento de datos por hacer, lo que mejora el tiempo de ejecuci&amp;oacute;n de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d1310273f42b4567d006ba733761bffcc94a7323" translate="yes" xml:space="preserve">
          <source>In the case of multisets, considering that element &lt;code&gt;a&lt;/code&gt; appears &lt;code&gt;x&lt;/code&gt; times in &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; times and &lt;code&gt;r2&lt;/code&gt;, the number of occurences of &lt;code&gt;a&lt;/code&gt; in the resulting range is going to be &lt;code&gt;x-y&lt;/code&gt; if x &amp;gt; y or 0 otherwise.</source>
          <target state="translated">En el caso de los conjuntos m&amp;uacute;ltiples, considerando que el elemento &lt;code&gt;a&lt;/code&gt; aparece &lt;code&gt;x&lt;/code&gt; veces en &lt;code&gt;r1&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; veces y &lt;code&gt;r2&lt;/code&gt; , el n&amp;uacute;mero de ocurrencias de &lt;code&gt;a&lt;/code&gt; en el rango resultante ser&amp;aacute; &lt;code&gt;x-y&lt;/code&gt; si x&amp;gt; yo 0 de lo contrario.</target>
        </trans-unit>
        <trans-unit id="574341dd05f59907247dd44e449ed7bd5386146b" translate="yes" xml:space="preserve">
          <source>In the case of multisets, the range with the minimum number of occurences of a given element, propagates the number of occurences of this element to the resulting range.</source>
          <target state="translated">En el caso de los conjuntos múltiples,el rango con el número mínimo de ocurrencias de un elemento dado,propaga el número de ocurrencias de este elemento al rango resultante.</target>
        </trans-unit>
        <trans-unit id="c31bb38a42ef0f5a89fce05942de3e9a5d76ab7c" translate="yes" xml:space="preserve">
          <source>In the case of the monotonic time, &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; is templatized on &lt;code&gt;ClockType&lt;/code&gt;, whereas with &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt;, its a runtime argument, since in the case of the monotonic time, the type of the clock affects the resolution of a &lt;a href=&quot;#MonoTimeImpl&quot;&gt;&lt;code&gt;MonoTimeImpl&lt;/code&gt;&lt;/a&gt; object, whereas with &lt;a href=&quot;std_datetime#SysTime&quot;&gt;&lt;code&gt;std.datetime.SysTime&lt;/code&gt;&lt;/a&gt;, its resolution is always hecto-nanoseconds regardless of the source of the time.</source>
          <target state="translated">En el caso de la hora monot&amp;oacute;nica, &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; se templa en &lt;code&gt;ClockType&lt;/code&gt; , mientras que con &lt;code&gt;std.datetime.Clock.currTime&lt;/code&gt; , es un argumento de tiempo de ejecuci&amp;oacute;n, ya que en el caso de la hora monot&amp;oacute;nica, el tipo de reloj afecta la resoluci&amp;oacute;n de un objeto &lt;a href=&quot;#MonoTimeImpl&quot;&gt; &lt;code&gt;MonoTimeImpl&lt;/code&gt; &lt;/a&gt; , mientras que con &lt;a href=&quot;std_datetime#SysTime&quot;&gt; &lt;code&gt;std.datetime.SysTime&lt;/code&gt; &lt;/a&gt; , su resoluci&amp;oacute;n es siempre hecto-nanosegundos independientemente de la fuente del tiempo.</target>
        </trans-unit>
        <trans-unit id="48d19d43ba624ca8d4f15f601b46da39df170632" translate="yes" xml:space="preserve">
          <source>In the corresponding D code, &lt;code&gt;foo&lt;/code&gt; is declared as having C++ linkage and function calling conventions:</source>
          <target state="translated">En el c&amp;oacute;digo D correspondiente, se declara que &lt;code&gt;foo&lt;/code&gt; tiene enlaces C ++ y convenciones de llamada a funciones:</target>
        </trans-unit>
        <trans-unit id="c2859b376d9322070e57e0df9e0b545f1ad11ef9" translate="yes" xml:space="preserve">
          <source>In the current function, we are calling 'this' function. 1. Check to see if the current function can call 'this' function, issue error if not. 2. If the current function is not the parent of 'this' function, then add the current function to the list of siblings of 'this' function. 3. If the current function is a literal, and it's accessing an uplevel scope, then mark it as a delegate. Returns true if error occurs.</source>
          <target state="translated">En la función actual,estamos llamando a &quot;esta&quot; función.1.Comprueba si la función actual puede llamar a &quot;esta&quot; función,si no,da error.2.Si la función actual no es la madre de &quot;esta&quot; función,entonces agregue la función actual a la lista de hermanos de &quot;esta&quot; función.3.3.Si la función actual es un literal,y está accediendo a un ámbito de nivel superior,entonces márquela como delegada.Devuelve verdadero si se produce un error.</target>
        </trans-unit>
        <trans-unit id="27341e1e33d3f1a9c524981309a60954fc820a69" translate="yes" xml:space="preserve">
          <source>In the example above, &quot;--foo&quot; and &quot;--bar&quot; are recognized, but &quot;--Foo&quot;, &quot;--Bar&quot;, &quot;--FOo&quot;, &quot;--bAr&quot;, etc. are rejected. The directive is active until the end of &lt;code&gt;getopt&lt;/code&gt;, or until the converse directive &lt;code&gt;caseInsensitive&lt;/code&gt; is encountered:</source>
          <target state="translated">En el ejemplo anterior, se reconocen &quot;--foo&quot; y &quot;--bar&quot;, pero se rechazan &quot;--Foo&quot;, &quot;--Bar&quot;, &quot;--FOo&quot;, &quot;--bAr&quot;, etc. La directiva est&amp;aacute; activa hasta el final de &lt;code&gt;getopt&lt;/code&gt; , o hasta que se encuentra la directiva inversa &lt;code&gt;caseInsensitive&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4dfbc2e24539434e62842bac389911ff9852ba28" translate="yes" xml:space="preserve">
          <source>In the graph above, any directed path is a legal implicit conversion. No other qualifier combinations than the ones shown is valid. If a directed path exists between two sets of qualifiers, the types thus qualified are called &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;qualifier-convertible&lt;/a&gt;. The same information is shown below in tabular format:</source>
          <target state="translated">En el gr&amp;aacute;fico anterior, cualquier ruta dirigida es una conversi&amp;oacute;n legal impl&amp;iacute;cita. Ninguna otra combinaci&amp;oacute;n de calificadores que las mostradas es v&amp;aacute;lida. Si existe una ruta dirigida entre dos conjuntos de calificadores, los tipos as&amp;iacute; calificados se denominan &lt;a href=&quot;http://dlang.org/glossary.html#qualifier-convertible&quot;&gt;calificador convertible&lt;/a&gt; . La misma informaci&amp;oacute;n se muestra a continuaci&amp;oacute;n en formato tabular:</target>
        </trans-unit>
        <trans-unit id="02f036d56e5b0f17d6cada283807ab6e4a45c16d" translate="yes" xml:space="preserve">
          <source>In the second step, path components are compared using &lt;code&gt;filenameCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCmp&quot;&gt;&lt;code&gt;filenameCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">En el segundo paso, los componentes de la ruta se comparan usando &lt;code&gt;filenameCmp!cs&lt;/code&gt; , donde &lt;code&gt;cs&lt;/code&gt; es un par&amp;aacute;metro de plantilla opcional que determina si la comparaci&amp;oacute;n distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas o no. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;#filenameCmp&quot;&gt; &lt;code&gt;filenameCmp&lt;/code&gt; &lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="e25b68a7396b82d8e5f58fe981088b3bb4f8c195" translate="yes" xml:space="preserve">
          <source>In the special case where only a single function is provided (&lt;code&gt;F.length == 1&lt;/code&gt;), adjoin simply aliases to the single passed function (&lt;code&gt;F[0]&lt;/code&gt;).</source>
          <target state="translated">En el caso especial en el que se proporciona una sola funci&amp;oacute;n ( &lt;code&gt;F.length == 1&lt;/code&gt; ), adjunte simplemente alias a la funci&amp;oacute;n pasada simple ( &lt;code&gt;F[0]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d9fe9a61d26a09ceb6b95fd6ad82498884dadd5" translate="yes" xml:space="preserve">
          <source>In the table below, the &lt;b&gt;exact alias&lt;/b&gt;es are types of exactly the specified number of bits. The &lt;b&gt;at least alias&lt;/b&gt;es are at least the specified number of bits large, and can be larger. The &lt;b&gt;fast alias&lt;/b&gt;es are the fastest integral type supported by the processor that is at least as wide as the specified number of bits.</source>
          <target state="translated">En la tabla a continuaci&amp;oacute;n, los &lt;b&gt;alias exactos&lt;/b&gt; son tipos de exactamente el n&amp;uacute;mero especificado de bits. Los &lt;b&gt;alias al menos&lt;/b&gt; son al menos el n&amp;uacute;mero especificado de bits grandes y pueden ser m&amp;aacute;s grandes. Los &lt;b&gt;alias r&amp;aacute;pidos&lt;/b&gt; son el tipo integral m&amp;aacute;s r&amp;aacute;pido admitido por el procesador que es al menos tan ancho como el n&amp;uacute;mero especificado de bits.</target>
        </trans-unit>
        <trans-unit id="2b57bd98576c6b47e51f692ed2880671dfdcaf21" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;myAllocator&lt;/code&gt; does not obey the &lt;code&gt;IAllocator&lt;/code&gt; interface, but implements its primitives so it can work with &lt;code&gt;makeArray&lt;/code&gt; by means of duck typing.  One important thing to note about this setup is that statically-typed assembled allocators are almost always faster than allocators that go through &lt;code&gt;IAllocator&lt;/code&gt;. An important rule of thumb is: &quot;assemble allocator first, adapt to &lt;code&gt;IAllocator&lt;/code&gt; after&quot;. A good allocator implements intricate logic by means of template assembly, and gets wrapped with &lt;code&gt;IAllocator&lt;/code&gt; (usually by means of &lt;a href=&quot;#allocatorObject&quot;&gt;&lt;code&gt;allocatorObject&lt;/code&gt;&lt;/a&gt;) only once, at client level.</source>
          <target state="translated">En este caso, &lt;code&gt;myAllocator&lt;/code&gt; no obedece a la interfaz &lt;code&gt;IAllocator&lt;/code&gt; , pero implementa sus primitivas para que pueda trabajar con &lt;code&gt;makeArray&lt;/code&gt; por medio de tipeo de pato. Una cosa importante a tener en cuenta sobre esta configuraci&amp;oacute;n es que los asignadores ensamblados de tipo est&amp;aacute;tico son casi siempre m&amp;aacute;s r&amp;aacute;pidos que los asignadores que pasan por &lt;code&gt;IAllocator&lt;/code&gt; . Una regla general importante es: &quot;ensamblar el asignador primero, adaptarlo a &lt;code&gt;IAllocator&lt;/code&gt; despu&amp;eacute;s&quot;. Un buen asignador implementa una l&amp;oacute;gica intrincada mediante el ensamblaje de plantillas, y se envuelve con &lt;code&gt;IAllocator&lt;/code&gt; (generalmente mediante &lt;a href=&quot;#allocatorObject&quot;&gt; &lt;code&gt;allocatorObject&lt;/code&gt; &lt;/a&gt; ) solo una vez, a nivel del cliente.</target>
        </trans-unit>
        <trans-unit id="0dbb9df98ee1772b091a23269b418c611c6689cc" translate="yes" xml:space="preserve">
          <source>In this case, the slots at positions 1, 3, 4, and 9 are removed from the array.</source>
          <target state="translated">En este caso,las ranuras de las posiciones 1,3,4 y 9 son retiradas de la matriz.</target>
        </trans-unit>
        <trans-unit id="5961fb400c229a03dfc935fa996c5fe8fc78fdb9" translate="yes" xml:space="preserve">
          <source>In this implementation both arguments must be positive. The integral is evaluated by either a power series or continued fraction expansion, depending on the relative values of a and x.</source>
          <target state="translated">En esta aplicación ambos argumentos deben ser positivos.La integral se evalúa mediante una serie de potencias o una expansión continua de fracciones,dependiendo de los valores relativos de a y x.</target>
        </trans-unit>
        <trans-unit id="bd2e85eebf3596f12832975a35b8c3545510433f" translate="yes" xml:space="preserve">
          <source>In this situation, the assignemnts are actual assign expressions (&lt;code&gt;opAssign&lt;/code&gt; is used if defined).</source>
          <target state="translated">En esta situaci&amp;oacute;n, los asignatarios son expresiones de asignaci&amp;oacute;n reales ( se usa &lt;code&gt;opAssign&lt;/code&gt; si est&amp;aacute; definido).</target>
        </trans-unit>
        <trans-unit id="cecc30a8b51b4071bb5efaef87b2c1dec1a96284" translate="yes" xml:space="preserve">
          <source>In this table &quot;doPut&quot; is a method that places &lt;code&gt;e&lt;/code&gt; into &lt;code&gt;r&lt;/code&gt;, using the correct primitive: &lt;code&gt;r.put(e)&lt;/code&gt; if &lt;code&gt;R&lt;/code&gt; defines &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;r.front = e&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; is an input range (followed by &lt;code&gt;r.popFront()&lt;/code&gt;), or &lt;code&gt;r(e)&lt;/code&gt; otherwise.</source>
          <target state="translated">En esta tabla, &quot;doPut&quot; es un m&amp;eacute;todo que coloca &lt;code&gt;e&lt;/code&gt; en &lt;code&gt;r&lt;/code&gt; , usando la primitiva correcta: &lt;code&gt;r.put(e)&lt;/code&gt; si &lt;code&gt;R&lt;/code&gt; define &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;r.front = e&lt;/code&gt; si &lt;code&gt;r&lt;/code&gt; es un rango de entrada (seguido de &lt;code&gt;r.popFront()&lt;/code&gt; ), o &lt;code&gt;r(e)&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="02a8b5c14dc9548c1a490e9d5960a9feca99259a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were a function.</source>
          <target state="translated">De esta manera un objeto de estructura o clase puede comportarse como si fuera una función.</target>
        </trans-unit>
        <trans-unit id="17982ced0afda199d35d40c9d0672932dd55162a" translate="yes" xml:space="preserve">
          <source>In this way a struct or class object can behave as if it were an array.</source>
          <target state="translated">De esta manera un objeto de estructura o clase puede comportarse como si fuera una matriz.</target>
        </trans-unit>
        <trans-unit id="86f8f90c18dbc0f9d343ef02fb0a4cd117e4553c" translate="yes" xml:space="preserve">
          <source>In user code. This class also provides means to add version identifier to the list of global (cross module) identifiers.</source>
          <target state="translated">En código de usuario.Esta clase también proporciona medios para añadir un identificador de versión a la lista de identificadores globales (módulos cruzados).</target>
        </trans-unit>
        <trans-unit id="bdee4d1acbdd89d7f24aebad7aeee092188b3727" translate="yes" xml:space="preserve">
          <source>In, Out and Inheritance</source>
          <target state="translated">Entrada,salida y herencia</target>
        </trans-unit>
        <trans-unit id="783253f63cea9c514d69689860a1ae050327457b" translate="yes" xml:space="preserve">
          <source>In-order Pentium (Pentium1, PMMX, Atom)</source>
          <target state="translated">Pentium en orden (Pentium1,PMMX,Átomo)</target>
        </trans-unit>
        <trans-unit id="7d5a97d89ad4a3be9582069b3310a6d0aee11430" translate="yes" xml:space="preserve">
          <source>InExpression</source>
          <target state="translated">InExpression</target>
        </trans-unit>
        <trans-unit id="6b952134a590c37c3cd245f783f0cab0b35e154b" translate="yes" xml:space="preserve">
          <source>Include all of the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; options.</source>
          <target state="translated">Incluya todas las opciones de &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;IEEE754&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21d63116a735028b1065c53175a7201eb75a690c" translate="yes" xml:space="preserve">
          <source>Include none of the above options.</source>
          <target state="translated">No incluya ninguna de las opciones anteriores.</target>
        </trans-unit>
        <trans-unit id="7fb47f835a97695060fa50d3d9efcf9e0fff9c84" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanoseconds (100 ns)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (microseconds), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milliseconds), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt;, &lt;code&gt;&quot;minutes&quot;&lt;/code&gt;, &lt;code&gt;&quot;hours&quot;&lt;/code&gt;, &lt;code&gt;&quot;days&quot;&lt;/code&gt;, &lt;code&gt;&quot;weeks&quot;&lt;/code&gt;, &lt;code&gt;&quot;months&quot;&lt;/code&gt;, and &lt;code&gt;&quot;years&quot;&lt;/code&gt;</source>
          <target state="translated">Incluye &lt;code&gt;&quot;hnsecs&quot;&lt;/code&gt; (hecto-nanosegundos (100 ns)), &lt;code&gt;&quot;usecs&quot;&lt;/code&gt; (microsegundos), &lt;code&gt;&quot;msecs&quot;&lt;/code&gt; (milisegundos), &lt;code&gt;&quot;seconds&quot;&lt;/code&gt; , &lt;code&gt;&quot;minutes&quot;&lt;/code&gt; , &lt;code&gt;&quot;hours&quot;&lt;/code&gt; , &lt;code&gt;&quot;days&quot;&lt;/code&gt; , &lt;code&gt;&quot;weeks&quot;&lt;/code&gt; , &lt;code&gt;&quot;months&quot;&lt;/code&gt; y &lt;code&gt;&quot;years&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660485a4ef4f2ea299a5049e5e7f68faa3ac9dd9" translate="yes" xml:space="preserve">
          <source>Includes characters a, b, c, ..., z.</source>
          <target state="translated">Incluye los caracteres a,b,c,...,z.</target>
        </trans-unit>
        <trans-unit id="e622b4457bdf3ceb03f6cf725fab2a67de905818" translate="yes" xml:space="preserve">
          <source>Incomplete beta integral</source>
          <target state="translated">Integral beta incompleto</target>
        </trans-unit>
        <trans-unit id="861a53fcf5c388edd7cf46ce6d95a43e95f0e787" translate="yes" xml:space="preserve">
          <source>Incomplete gamma integral and its complement</source>
          <target state="translated">La integral gamma incompleta y su complemento</target>
        </trans-unit>
        <trans-unit id="2f08d5bb658237cd92aa5a4432cb1cfef1a4c7b1" translate="yes" xml:space="preserve">
          <source>Incorporate &lt;code&gt;element_count&lt;/code&gt; and finalizes the hash.</source>
          <target state="translated">Incorpora &lt;code&gt;element_count&lt;/code&gt; y finaliza el hash.</target>
        </trans-unit>
        <trans-unit id="d8c996a9761aab171974108da093507dfd302c9b" translate="yes" xml:space="preserve">
          <source>Increases the reference count of the concrete class that implements this interface.</source>
          <target state="translated">Aumenta la cuenta de referencia de la clase concreta que implementa esta interfaz.</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="6179063ceb022e0b005a77ad50121ce42a8f12e0" translate="yes" xml:space="preserve">
          <source>Incremental options.</source>
          <target state="translated">Opciones de incremento.</target>
        </trans-unit>
        <trans-unit id="84205e80c2673222d26cbdde35ee1f4333d1b71b" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;numOwns&lt;/code&gt; (per instance and and per call) and forwards to &lt;code&gt; parent.owns(b)&lt;/code&gt;.</source>
          <target state="translated">Incrementa &lt;code&gt;numOwns&lt;/code&gt; (por instancia y por llamada) y reenv&amp;iacute;a a &lt;code&gt; parent.owns(b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddaf57d4b4048098b5dfe8043020c47a13b32e0a" translate="yes" xml:space="preserve">
          <source>Independent of the parameter this Logger will never log a message.</source>
          <target state="translated">Independientemente del parámetro este Logger nunca registrará un mensaje.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="699dc9f4598bf2c18561d09ccbeb25728c70494b" translate="yes" xml:space="preserve">
          <source>Index Assignment Operator Overloading</source>
          <target state="translated">Sobrecarga del operador de asignación de índices</target>
        </trans-unit>
        <trans-unit id="71c97279cf83fc58467572ececa55bdae6e798a5" translate="yes" xml:space="preserve">
          <source>Index Expressions</source>
          <target state="translated">Expresiones del índice</target>
        </trans-unit>
        <trans-unit id="d1893a899240a1b591d897768bc60814a476fa87" translate="yes" xml:space="preserve">
          <source>Index Name NULL</source>
          <target state="translated">Nombre del índice NULL</target>
        </trans-unit>
        <trans-unit id="e71ed4c87a94b38c5cecf345cf992053ca3a47d3" translate="yes" xml:space="preserve">
          <source>Index Name Table Name</source>
          <target state="translated">Nombre del índice Nombre de la tabla</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">Índice de un parámetro con un nombre de pila</target>
        </trans-unit>
        <trans-unit id="bfb09c98cfaf2d55de0462489f758021e1b3f471" translate="yes" xml:space="preserve">
          <source>Index Op Assignment Operator Overloading</source>
          <target state="translated">Índice de asignación de operaciones Sobrecarga del operador</target>
        </trans-unit>
        <trans-unit id="49fe544cd53fba1ec8f72994e8cce9d496cf27f3" translate="yes" xml:space="preserve">
          <source>Index Operator Overloading</source>
          <target state="translated">Sobrecarga del operador de índice</target>
        </trans-unit>
        <trans-unit id="a3b9e1c8a8784dafb7f4615ab228a307d1e4a762" translate="yes" xml:space="preserve">
          <source>Index of the argument for positional parameters, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">&amp;Iacute;ndice del argumento para par&amp;aacute;metros posicionales, de &lt;code&gt;1&lt;/code&gt; a &lt;code&gt;ubyte.max&lt;/code&gt; . ( &lt;code&gt;0&lt;/code&gt; significa no utilizado).</target>
        </trans-unit>
        <trans-unit id="c34e327ac8e45e062b5805d3beb7a3e4caec8300" translate="yes" xml:space="preserve">
          <source>Index of the last argument for positional parameter range, from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ubyte.max&lt;/code&gt;. (&lt;code&gt;0&lt;/code&gt; means not used).</source>
          <target state="translated">&amp;Iacute;ndice del &amp;uacute;ltimo argumento para el rango de par&amp;aacute;metros posicionales, de &lt;code&gt;1&lt;/code&gt; a &lt;code&gt;ubyte.max&lt;/code&gt; . ( &lt;code&gt;0&lt;/code&gt; significa no utilizado).</target>
        </trans-unit>
        <trans-unit id="235d469a267eec1b21cb41bd835ec761b3be5b4a" translate="yes" xml:space="preserve">
          <source>Index of the maximal element of a range. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&amp;Iacute;ndice del elemento m&amp;aacute;ximo de un rango. &lt;code&gt;maxElement([3, 4, 1, 2])&lt;/code&gt; devuelve &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25975946b5389d6cd4927c54b6079d61210dbf05" translate="yes" xml:space="preserve">
          <source>Index of the minimal element of a range. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&amp;Iacute;ndice del elemento m&amp;iacute;nimo de un rango. &lt;code&gt;minElement([3, 4, 1, 2])&lt;/code&gt; devuelve &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a04ef38d2ddc39bb1db51cbf56276c8f962441c1" translate="yes" xml:space="preserve">
          <source>IndexExpression</source>
          <target state="translated">IndexExpression</target>
        </trans-unit>
        <trans-unit id="3b15c071f8f2a9b03d20f13f4ee4fa47f96aaf8d" translate="yes" xml:space="preserve">
          <source>Indexed!(Source, Indices) &lt;strong id=&quot;indexed&quot;&gt;indexed&lt;/strong&gt;(Source, Indices)(Source source, Indices indices);</source>
          <target state="translated">Indexado (fuente, &amp;iacute;ndices) &lt;strong id=&quot;indexed&quot;&gt;indexado&lt;/strong&gt; (fuente, &amp;iacute;ndices) (fuente, &amp;iacute;ndices &amp;iacute;ndices);</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="76508adf7decca48f64672d4079c15326fbc39f8" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Operaciones de indexaci&amp;oacute;n y corte. Solo se proporciona si &lt;code&gt;hasSlicing!Source&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74036ccb3b85a0419f22323e1fac3915c3caf378" translate="yes" xml:space="preserve">
          <source>Indexing operators yielding or modifyng the value at the specified index.</source>
          <target state="translated">Los operadores de indexación que dan o modifican el valor en el índice especificado.</target>
        </trans-unit>
        <trans-unit id="6d2692938b71d76efadfb2cea1bb4a83352f988a" translate="yes" xml:space="preserve">
          <source>Indexing, slicing and bidirectional operations and range primitives. Provided only if &lt;code&gt;hasSlicing!Source&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Operaciones de indexaci&amp;oacute;n, corte y bidireccional y primitivas de rango. Solo se proporciona si &lt;code&gt;hasSlicing!Source&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f85958353bf4bfb31d66cc4f95a9358b5bedf1c3" translate="yes" xml:space="preserve">
          <source>Indicates a direction in time. One example of its use is &lt;a href=&quot;#Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#expand&quot;&gt;&lt;code&gt;expand&lt;/code&gt;&lt;/a&gt; function which uses it to indicate whether the interval should be expanded backwards (into the past), forwards (into the future), or both.</source>
          <target state="translated">Indica una direcci&amp;oacute;n en el tiempo. Un ejemplo de su uso es la funci&amp;oacute;n de &lt;a href=&quot;#expand&quot;&gt; &lt;code&gt;expand&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; , que la utiliza para indicar si el intervalo debe expandirse hacia atr&amp;aacute;s (hacia el pasado), hacia adelante (hacia el futuro) o ambos.</target>
        </trans-unit>
        <trans-unit id="89b0fbd07a7b5dbf8da4ba701f1805d8565d86bb" translate="yes" xml:space="preserve">
          <source>Indicates if a nested aggregate prevents or not a function to be inlined. It's used to compute the cost but also to avoid a copy of the aggregate while the inliner processes.</source>
          <target state="translated">Indica si un agregado anidado impide o no que una función sea alineada.Se utiliza para calcular el costo pero también para evitar una copia del agregado mientras se procesa el inliner.</target>
        </trans-unit>
        <trans-unit id="a10ebf2fd0a4ff0f019e4879f48fae2f4e5a0b0d" translate="yes" xml:space="preserve">
          <source>Indicates that the managed memory space be minimized by returning free physical memory to the operating system. The amount of free memory returned depends on the allocator design and on program behavior.</source>
          <target state="translated">Indica que el espacio de memoria administrado se minimice devolviendo la memoria física libre al sistema operativo.La cantidad de memoria libre devuelta depende del diseño del asignador y del comportamiento del programa.</target>
        </trans-unit>
        <trans-unit id="4ec109e112fc6bfd6a9d0109f56e7e7967df8488" translate="yes" xml:space="preserve">
          <source>Indicates the checking state of various contracts.</source>
          <target state="translated">Indica el estado de comprobación de varios contratos.</target>
        </trans-unit>
        <trans-unit id="cb18c8046fd7efef0dda1d752fd5c6ff22b02f5d" translate="yes" xml:space="preserve">
          <source>Indicates the kind of scan being performed by &lt;code&gt;thread_scanAllType&lt;/code&gt;.</source>
          <target state="translated">Indica el tipo de an&amp;aacute;lisis que realiza &lt;code&gt;thread_scanAllType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f13413a46338bc9d77efe386dd1970d9c61578f" translate="yes" xml:space="preserve">
          <source>Indicates the type of a &lt;code&gt;JSONValue&lt;/code&gt;.</source>
          <target state="translated">Indica el tipo de un valor &lt;code&gt;JSONValue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee35c8aada8a6aa7b7217bd768effeae4d28769f" translate="yes" xml:space="preserve">
          <source>Indicates whether &lt;code&gt;T&lt;/code&gt; is a file handle, i.e. the type is implicitly convertable to &lt;a href=&quot;#File&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; or a pointer to a &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt;&lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Indica si &lt;code&gt;T&lt;/code&gt; es un identificador de archivo, es decir, el tipo se puede convertir impl&amp;iacute;citamente en &lt;a href=&quot;#File&quot;&gt; &lt;code&gt;File&lt;/code&gt; &lt;/a&gt; o un puntero a un &lt;a href=&quot;core_stdc_stdio#FILE&quot;&gt; &lt;code&gt;core.stdc.stdio.FILE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16f0af9200309c4bcede9c6bd76aa0d14467a310" translate="yes" xml:space="preserve">
          <source>Indicates whether an address has been marked by the GC.</source>
          <target state="translated">Indica si una dirección ha sido marcada por el GC.</target>
        </trans-unit>
        <trans-unit id="c7fabc24fed84961bce8996fe0ecd1e5cdad5e83" translate="yes" xml:space="preserve">
          <source>Indicates whether the comparisons are case sensitive.</source>
          <target state="translated">Indica si las comparaciones son sensibles a las mayúsculas y minúsculas.</target>
        </trans-unit>
        <trans-unit id="f7d28431fd9c9c5871085a5497dc7e6e1e0cf415" translate="yes" xml:space="preserve">
          <source>Indicates which contracts should be checked or not.</source>
          <target state="translated">Indica qué contratos deben ser revisados o no.</target>
        </trans-unit>
        <trans-unit id="4243a1f947d3219fb4149e60971ece346868e5f0" translate="yes" xml:space="preserve">
          <source>Individual characters (&lt;code&gt;char, &lt;/code&gt;wchar&lt;code&gt;, or &lt;/code&gt;dchar`) are formatted as Unicode characters with &lt;code&gt;%s&lt;/code&gt; and as integers with integral-specific format specs.</source>
          <target state="translated">Los caracteres individuales ( &lt;code&gt;char, &lt;/code&gt; wchar &lt;code&gt;, or &lt;/code&gt; dchar`) est&amp;aacute;n formateados como caracteres Unicode con &lt;code&gt;%s&lt;/code&gt; como enteros con especificaciones de formato espec&amp;iacute;ficas de integral.</target>
        </trans-unit>
        <trans-unit id="29597351771a3ef19075a67f20ee90c6ad63bea0" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not.</source>
          <target state="translated">Los caracteres individuales se comparan usando &lt;code&gt;filenameCharCmp!cs&lt;/code&gt; , donde &lt;code&gt;cs&lt;/code&gt; es un par&amp;aacute;metro de plantilla opcional que determina si la comparaci&amp;oacute;n distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas o no.</target>
        </trans-unit>
        <trans-unit id="49226687980b9cd956057b7a38e24b4e2409b256" translate="yes" xml:space="preserve">
          <source>Individual characters are compared using &lt;code&gt;filenameCharCmp!cs&lt;/code&gt;, where &lt;code&gt;cs&lt;/code&gt; is an optional template parameter determining whether the comparison is case sensitive or not. See the &lt;a href=&quot;#filenameCharCmp&quot;&gt;&lt;code&gt;filenameCharCmp&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">Los caracteres individuales se comparan usando &lt;code&gt;filenameCharCmp!cs&lt;/code&gt; , donde &lt;code&gt;cs&lt;/code&gt; es un par&amp;aacute;metro de plantilla opcional que determina si la comparaci&amp;oacute;n distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas o no. Consulte la documentaci&amp;oacute;n de &lt;a href=&quot;#filenameCharCmp&quot;&gt; &lt;code&gt;filenameCharCmp&lt;/code&gt; &lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="e1f361f1f9ae5992659047882bc5221a903aebb0" translate="yes" xml:space="preserve">
          <source>Individual field in the Ctor with information about its callees and location.</source>
          <target state="translated">Campo individual en el Ctor con información sobre sus callees y ubicación.</target>
        </trans-unit>
        <trans-unit id="2112ae8639e7801d8cfbbdd81cd2583bb2a4a9cd" translate="yes" xml:space="preserve">
          <source>Individual tests are specified in the unit test using &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt;. Unlike</source>
          <target state="translated">Las pruebas individuales se especifican en la prueba unitaria utilizando &lt;a href=&quot;expression#AssertExpression&quot;&gt;AssertExpressions&lt;/a&gt; . diferente a</target>
        </trans-unit>
        <trans-unit id="a1c45f8b0cd8cbcf6f1e93b6a635fb2a38dc40f6" translate="yes" xml:space="preserve">
          <source>Inequality is defined as the logical negation of equality.</source>
          <target state="translated">La desigualdad se define como la negación lógica de la igualdad.</target>
        </trans-unit>
        <trans-unit id="65b109f015e153776d80b153da2023fd8d163d9f" translate="yes" xml:space="preserve">
          <source>Infinite ranges are compatible, provided the parameter &lt;code&gt;upTo&lt;/code&gt; is specified, in which case the implementation simply returns upTo.</source>
          <target state="translated">Los rangos infinitos son compatibles, siempre que se especifique el par&amp;aacute;metro &lt;code&gt;upTo&lt;/code&gt; , en cuyo caso la implementaci&amp;oacute;n simplemente devuelve upTo.</target>
        </trans-unit>
        <trans-unit id="cc80f798db63ecb0ec11198be5af2b60c15e0345" translate="yes" xml:space="preserve">
          <source>Infinite ranges with slicing support must return an instance of &lt;a href=&quot;std_range#Take&quot;&gt;&lt;code&gt;std.range.Take&lt;/code&gt;&lt;/a&gt; when sliced with a specific lower and upper bound (see &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt;&lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt;&lt;/a&gt;); &lt;code&gt;handle&lt;/code&gt; deals with this by &lt;code&gt;take&lt;/code&gt;ing 0 from the return value of the handler function and returning that when an exception is caught.</source>
          <target state="translated">Los rangos infinitos con soporte de corte deben devolver una instancia de &lt;a href=&quot;std_range#Take&quot;&gt; &lt;code&gt;std.range.Take&lt;/code&gt; &lt;/a&gt; cuando se corta con un l&amp;iacute;mite inferior y superior espec&amp;iacute;fico (consulte &lt;a href=&quot;std_range_primitives#hasSlicing&quot;&gt; &lt;code&gt;std.range.primitives.hasSlicing&lt;/code&gt; &lt;/a&gt; ); &lt;code&gt;handle&lt;/code&gt; ofertas con esto &lt;code&gt;take&lt;/code&gt; 0 del valor de retorno de la funci&amp;oacute;n del controlador y devolvi&amp;eacute;ndolo cuando se detecta una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="27d9e5c1d05febee114a9f9e51dbec3780887c9a" translate="yes" xml:space="preserve">
          <source>Infiniteness of the wrapped range is not propagated.  Length is not propagated in the case of non-random access ranges.</source>
          <target state="translated">La infinidad del rango envuelto no se propaga.La longitud no se propaga en el caso de los rangos de acceso no aleatorio.</target>
        </trans-unit>
        <trans-unit id="266086404e3edd52081be68722aa77ff6a65cf70" translate="yes" xml:space="preserve">
          <source>Info on a file, similar to what you'd get from stat on a Posix system.</source>
          <target state="translated">Información en un archivo,similar a la que obtendrías de un sistema Posix.</target>
        </trans-unit>
        <trans-unit id="cd1b541e2d202e9ed7863df5d539d80a14d92db1" translate="yes" xml:space="preserve">
          <source>Information about an interface. When an object is accessed via an interface, an Interface* appears as the first entry in its vtbl.</source>
          <target state="translated">Información sobre una interfaz.Cuando se accede a un objeto a través de una interfaz,aparece una Interfaz*como primera entrada en su vtbl.</target>
        </trans-unit>
        <trans-unit id="cea2e687310e3b71b249c28a49288e9fd3bfa210" translate="yes" xml:space="preserve">
          <source>Information about an option.</source>
          <target state="translated">Información sobre una opción.</target>
        </trans-unit>
        <trans-unit id="e073c50eee2c368b573895c98fb35595e9133239" translate="yes" xml:space="preserve">
          <source>Information about errors should be logged with this level.</source>
          <target state="translated">La información sobre los errores debe registrarse con este nivel.</target>
        </trans-unit>
        <trans-unit id="928345681d20aa3d2b01bea36a816d52c33a48de" translate="yes" xml:space="preserve">
          <source>Information about the dynamic type of the class</source>
          <target state="translated">Información sobre el tipo dinámico de la clase</target>
        </trans-unit>
        <trans-unit id="dc5ebb2696c4fafd1bdd1b19b9d403757258f4ad" translate="yes" xml:space="preserve">
          <source>Information about the error.</source>
          <target state="translated">Información sobre el error.</target>
        </trans-unit>
        <trans-unit id="b7329bd16608fcee8af0c9e3dcd5b29f7f17343f" translate="yes" xml:space="preserve">
          <source>Information about the target operating system, environment, and CPU.</source>
          <target state="translated">Información sobre el sistema operativo,el entorno y la CPU del objetivo.</target>
        </trans-unit>
        <trans-unit id="ceccba3653730142ed262183682108d6a4b114f3" translate="yes" xml:space="preserve">
          <source>Information gathered about externally defined template member functions, member data, and member classes.</source>
          <target state="translated">Información recopilada sobre las funciones de los miembros de la plantilla definidas externamente,los datos de los miembros y las clases de miembros.</target>
        </trans-unit>
        <trans-unit id="908b94b8c3e2309d82de3bc12b0083b2f0550dd4" translate="yes" xml:space="preserve">
          <source>Information gathered about nested class friends.</source>
          <target state="translated">Información recopilada sobre los amigos de clase anidados.</target>
        </trans-unit>
        <trans-unit id="7a43d043ba9567583c6e384e6e0ac879da254eab" translate="yes" xml:space="preserve">
          <source>Information gathered about nested explicit specializations.</source>
          <target state="translated">Información reunida sobre especializaciones explícitas anidadas.</target>
        </trans-unit>
        <trans-unit id="464dcc7e55ca0baa3461154f3221489d53fa204b" translate="yes" xml:space="preserve">
          <source>Information gathered about primary member template explicit specialization.</source>
          <target state="translated">Información reunida sobre la especialización explícita de la plantilla de miembros principales.</target>
        </trans-unit>
        <trans-unit id="8bc70f913f6ebe36fcb59b26b1c9b07d1f380466" translate="yes" xml:space="preserve">
          <source>Information regarding the allocated memory block or BlkInfo.init on error.</source>
          <target state="translated">Información sobre el bloque de memoria asignado o BlkInfo.init por error.</target>
        </trans-unit>
        <trans-unit id="1675fcfc1cf455d10d63328190309be0fe262d03" translate="yes" xml:space="preserve">
          <source>Information regarding the memory block referenced by p or BlkInfo.init on error.</source>
          <target state="translated">Información sobre el bloque de memoria referida por p o BlkInfo.init en error.</target>
        </trans-unit>
        <trans-unit id="58823af05ebe1ba3ff034e5ec492dcbd5b2f86cc" translate="yes" xml:space="preserve">
          <source>Inherited</source>
          <target state="translated">Inherited</target>
        </trans-unit>
        <trans-unit id="fcb1ddc45496d5bd9bbb1d0e3e24a58c56f33281" translate="yes" xml:space="preserve">
          <source>Initial value</source>
          <target state="translated">Valor inicial</target>
        </trans-unit>
        <trans-unit id="97e0f0f5459c7f9a8a0eadb6d21739e1c19dd524" translate="yes" xml:space="preserve">
          <source>Initial_Punctuation</source>
          <target state="translated">Initial_Punctuation</target>
        </trans-unit>
        <trans-unit id="e3e40f7638a489f11f1de06365e82209954d82d0" translate="yes" xml:space="preserve">
          <source>Initialization hook, called FROM each thread. No assumptions about module initialization state should be made.</source>
          <target state="translated">Gancho de inicialización,llamado DESDE cada hilo.No se deben hacer suposiciones sobre el estado de inicialización del módulo.</target>
        </trans-unit>
        <trans-unit id="a459dff3012da591453989e5860a6fd825f63ce3" translate="yes" xml:space="preserve">
          <source>Initialize</source>
          <target state="translated">Initialize</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">Iniciar la biblioteca SQLite</target>
        </trans-unit>
        <trans-unit id="748256c78e345ebbc504f121b03e80be2a80bbca" translate="yes" xml:space="preserve">
          <source>Initialize a TOK.cantExpression Expression.</source>
          <target state="translated">Iniciar una expresión de TOK.cantExpression.</target>
        </trans-unit>
        <trans-unit id="27911a1150c0c1d2144b25e270682254f6dac63a" translate="yes" xml:space="preserve">
          <source>Initialize config variables.</source>
          <target state="translated">Inicializar las variables de configuración.</target>
        </trans-unit>
        <trans-unit id="cbe2f6d3df93f8e15ce05f5a1f98cda2b20db74a" translate="yes" xml:space="preserve">
          <source>Initialize druntime. If a C program wishes to call D code, and there's no D main(), then it must call rt_init() and rt_term().</source>
          <target state="translated">Iniciar la hora de la borrachera.Si un programa C desea llamar al código D,y no hay D main(),entonces debe llamar a rt_init()y rt_term().</target>
        </trans-unit>
        <trans-unit id="8eb8be79e89fc0c011f24c39ee8771af00f563f7" translate="yes" xml:space="preserve">
          <source>Initialize for inferring the attributes of this function.</source>
          <target state="translated">Inicializar para inferir los atributos de esta función.</target>
        </trans-unit>
        <trans-unit id="f721b948f9c83247c02645e5eb12893bfb899d86" translate="yes" xml:space="preserve">
          <source>Initialize list package.</source>
          <target state="translated">Iniciar el paquete de la lista.</target>
        </trans-unit>
        <trans-unit id="de4ea7df574920c39fb3c6bd0386ce6a9cd8fd5d" translate="yes" xml:space="preserve">
          <source>Initialize the Objective-C string using a C string.</source>
          <target state="translated">Inicie la cadena del Objetivo-C usando una cadena de C.</target>
        </trans-unit>
        <trans-unit id="ef4109d3528796628f6b2a0029715405248a578e" translate="yes" xml:space="preserve">
          <source>Initialize the Target</source>
          <target state="translated">Iniciar el objetivo</target>
        </trans-unit>
        <trans-unit id="0980ce942938201d58c731edfd7b47e45dd9efe7" translate="yes" xml:space="preserve">
          <source>Initialize the dual-context array with the context pointers.</source>
          <target state="translated">Inicie la matriz de doble contexto con los punteros de contexto.</target>
        </trans-unit>
        <trans-unit id="8e023ffe90e1164684f46dc5edc97859a5680a5f" translate="yes" xml:space="preserve">
          <source>Initialize the hidden aggregate member, vthis, with the context pointer.</source>
          <target state="translated">Inicializar el miembro agregado oculto,vthis,con el puntero de contexto.</target>
        </trans-unit>
        <trans-unit id="59c6a3b95f9730ad20a9c9db67ee73fd2a6949c4" translate="yes" xml:space="preserve">
          <source>Initialize the instance by creating a working curl handle.</source>
          <target state="translated">Inicie la instancia creando un mango de rizo que funcione.</target>
        </trans-unit>
        <trans-unit id="1a30f56d1770a9dcc7fd0bb681a1c06b14ad9d91" translate="yes" xml:space="preserve">
          <source>Initialize the memory allocator</source>
          <target state="translated">Iniciar el asignador de memoria</target>
        </trans-unit>
        <trans-unit id="494a02556f310d47be7c5338d8f5523416a42a2e" translate="yes" xml:space="preserve">
          <source>Initialize with a message and an error code.</source>
          <target state="translated">Iniciar con un mensaje y un código de error.</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="51bf015ae2898049c8dda3ee0d3b48d0b0503aac" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;init&lt;/code&gt;</source>
          <target state="translated">Inicializador &lt;code&gt;init&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b1d1b30aa70eb127392afc002aaf56ef13eddf1" translate="yes" xml:space="preserve">
          <source>Initializer &lt;code&gt;inx&lt;/code&gt;</source>
          <target state="translated">Inicializador &lt;code&gt;inx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="376a8ae3746f3bef7e7c198b9b11401e24b7d25c" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt;(Initializer init, Scope* sc);</source>
          <target state="translated">Initializer &lt;strong id=&quot;inferType&quot;&gt;inferType&lt;/strong&gt; (Initializer init, Scope * sc);</target>
        </trans-unit>
        <trans-unit id="d8d2abfa30e5c4556b8e2c9d2dc62e742af966eb" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt;(Initializer init, Scope* sc, Type t, NeedInterpret needInterpret);</source>
          <target state="translated">Initializer &lt;strong id=&quot;initializerSemantic&quot;&gt;initializerSemantic&lt;/strong&gt; (Initializer init, Scope * sc, Type t, NeedInterpret needInterpret);</target>
        </trans-unit>
        <trans-unit id="88abdada1a9385d97517a707f4ab8a5f5a3e696d" translate="yes" xml:space="preserve">
          <source>Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;syntaxCopy&lt;/strong&gt;(Initializer inx);</source>
          <target state="translated">Initializer &lt;strong id=&quot;syntaxCopy&quot;&gt;syntaxCopy&lt;/strong&gt; (Initializer inx);</target>
        </trans-unit>
        <trans-unit id="c33131a57d387e740aae854652440535c3dd0652" translate="yes" xml:space="preserve">
          <source>Initializer AST node</source>
          <target state="translated">Inicializador del nodo AST</target>
        </trans-unit>
        <trans-unit id="14b021ae9bb3f976f77030248590d743674ec1b8" translate="yes" xml:space="preserve">
          <source>Initializer AST to copy</source>
          <target state="translated">Inicializador AST para copiar</target>
        </trans-unit>
        <trans-unit id="3121cafc28fbd2cff06107236c3142ae39ff3c9a" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RefCounted&lt;/code&gt; with &lt;code&gt;val&lt;/code&gt;. The template parameter &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;RefCounted&lt;/code&gt; is inferred from &lt;code&gt;val&lt;/code&gt;. This function can be used to move non-copyable values to the heap. It also disables the &lt;code&gt;autoInit&lt;/code&gt; option of &lt;code&gt;RefCounted&lt;/code&gt;.</source>
          <target state="translated">Inicializa un &lt;code&gt;RefCounted&lt;/code&gt; con &lt;code&gt;val&lt;/code&gt; . El par&amp;aacute;metro de plantilla &lt;code&gt;T&lt;/code&gt; de &lt;code&gt;RefCounted&lt;/code&gt; se infiere de &lt;code&gt;val&lt;/code&gt; . Esta funci&amp;oacute;n se puede usar para mover valores no copiables al mont&amp;oacute;n. Tambi&amp;eacute;n deshabilita el &lt;code&gt;autoInit&lt;/code&gt; opci&amp;oacute;n de &lt;code&gt;RefCounted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5840e1604b436855e9916e7392a48763951eabf0" translate="yes" xml:space="preserve">
          <source>Initializes a barrier object which releases threads in groups of limit in size.</source>
          <target state="translated">Inicializa un objeto barrera que libera hilos en grupos de tamaño limitado.</target>
        </trans-unit>
        <trans-unit id="e7d8f005a4914e6f92d821d5b224a6bd9e5c292c" translate="yes" xml:space="preserve">
          <source>Initializes a condition object which is associated with the supplied mutex object.</source>
          <target state="translated">Inicializa un objeto de condición que se asocia con el objeto mutex suministrado.</target>
        </trans-unit>
        <trans-unit id="2e831c2f248c0c0989af9f49fabed81c26839fd7" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a dynamic D function.</source>
          <target state="translated">Inicializa un objeto de fibra que está asociado con una función D dinámica.</target>
        </trans-unit>
        <trans-unit id="af50363b8f7b4155835b77141de6a5c61fdd71a0" translate="yes" xml:space="preserve">
          <source>Initializes a fiber object which is associated with a static D function.</source>
          <target state="translated">Inicializa un objeto de fibra que está asociado con una función D estática.</target>
        </trans-unit>
        <trans-unit id="45f928a2b81b560a0de6c9239785399cedf0251c" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a dynamic D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">Inicializa un objeto generador que está asociado a una función D dinámica.La función será llamada una vez para preparar el rango para la iteración.</target>
        </trans-unit>
        <trans-unit id="d0a92e3c77360cd0a21c46127be86aca1b90b608" translate="yes" xml:space="preserve">
          <source>Initializes a generator object which is associated with a static D function. The function will be called once to prepare the range for iteration.</source>
          <target state="translated">Inicializa un objeto generador que está asociado a una función D estática.La función será llamada una vez para preparar el rango para la iteración.</target>
        </trans-unit>
        <trans-unit id="d3728c381d3549c70b43d294cf94f34b914968b0" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object and sets it as the monitor for &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">Inicializa un objeto mutex y lo establece como monitor para &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a70c8975cc02255930db5c1532e070f13d983d9" translate="yes" xml:space="preserve">
          <source>Initializes a mutex object.</source>
          <target state="translated">Inicializa un objeto mutex.</target>
        </trans-unit>
        <trans-unit id="dc21cd96d7c298b730677d5fadf1f39d6fcdc2a3" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex object with the supplied policy.</source>
          <target state="translated">Inicializa un objeto mutex de lectura/escritura con la política suministrada.</target>
        </trans-unit>
        <trans-unit id="1bf7bde2d0e1b4605f5fcc7cecf50b8041c0ee33" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex reader proxy object.</source>
          <target state="translated">Inicializa un objeto proxy lector mutex de lectura/escritura.</target>
        </trans-unit>
        <trans-unit id="cac251d6ab6ce4228fd76b8f664aca1fdce466aa" translate="yes" xml:space="preserve">
          <source>Initializes a read/write mutex writer proxy object.</source>
          <target state="translated">Inicializa un objeto de lectura/escritura de un escritor mutex.</target>
        </trans-unit>
        <trans-unit id="e9c3d0e482ee4665047c01099490677dcee2bdf1" translate="yes" xml:space="preserve">
          <source>Initializes a semaphore object with the specified initial count.</source>
          <target state="translated">Inicializa un objeto semáforo con la cuenta inicial especificada.</target>
        </trans-unit>
        <trans-unit id="b08f976531720c8d331b9fd2fe472f259a01f7f8" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a dynamic D function.</source>
          <target state="translated">Inicializa un objeto de hilo que está asociado con una función D dinámica.</target>
        </trans-unit>
        <trans-unit id="6feddfb754d931f52971603d63763097e08f646e" translate="yes" xml:space="preserve">
          <source>Initializes a thread object which is associated with a static D function.</source>
          <target state="translated">Inicializa un objeto de hilo que está asociado con una función D estática.</target>
        </trans-unit>
        <trans-unit id="02e85d0a8c0d02c068e1d5736a1954b12b36920b" translate="yes" xml:space="preserve">
          <source>Initializes all elements of &lt;code&gt;range&lt;/code&gt; with their &lt;code&gt;.init&lt;/code&gt; value. Assumes that the elements of the range are uninitialized.</source>
          <target state="translated">Inicializa todos los elementos de &lt;code&gt;range&lt;/code&gt; con su valor &lt;code&gt;.init&lt;/code&gt; . Asume que los elementos del rango no est&amp;aacute;n inicializados.</target>
        </trans-unit>
        <trans-unit id="472c952e25298d18516b57e8e37279e00d61a5fe" translate="yes" xml:space="preserve">
          <source>Initializes an event object. Does nothing if the event is already initialized.</source>
          <target state="translated">Inicializa un objeto de evento.No hace nada si el evento ya está inicializado.</target>
        </trans-unit>
        <trans-unit id="eaf4287ba6b011331efecfcdf502db022ed8e9d5" translate="yes" xml:space="preserve">
          <source>Initializes each element of &lt;code&gt;range&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. Assumes that the elements of the range are uninitialized. This is of interest for structs that define copy constructors (for all other types, &lt;a href=&quot;#fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt; and uninitializedFill are equivalent).</source>
          <target state="translated">Inicializa cada elemento del &lt;code&gt;range&lt;/code&gt; con &lt;code&gt;value&lt;/code&gt; . Asume que los elementos del rango no est&amp;aacute;n inicializados. Esto es de inter&amp;eacute;s para las estructuras que definen constructores de copia (para todos los dem&amp;aacute;s tipos, &lt;a href=&quot;#fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt; y uninitializedFill son equivalentes).</target>
        </trans-unit>
        <trans-unit id="fc7f0006265d50c993eca80b0dee1e88b813e83a" translate="yes" xml:space="preserve">
          <source>Initializes the Symbol s with the contents of the exception handler table.</source>
          <target state="translated">Inicializa el símbolo s con el contenido de la tabla de manejo de excepciones.</target>
        </trans-unit>
        <trans-unit id="ce7db86ae90730cf95765268d14c3efeca306d1a" translate="yes" xml:space="preserve">
          <source>Initializes the digest.</source>
          <target state="translated">Inicializa la digestión.</target>
        </trans-unit>
        <trans-unit id="7cc4cbbc423778a9b3a1d152d6911455078c9956" translate="yes" xml:space="preserve">
          <source>Initializes the runtime. This call is to be used in instances where the standard program initialization process is not executed. This is most often in shared libraries or in libraries linked to a C program. If the runtime was already successfully initialized this returns true. Each call to initialize must be paired by a call to &lt;a href=&quot;#terminate&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Inicializa el tiempo de ejecuci&amp;oacute;n. Esta llamada se debe utilizar en casos en los que no se ejecuta el proceso de inicializaci&amp;oacute;n del programa est&amp;aacute;ndar. Esto ocurre con mayor frecuencia en bibliotecas compartidas o en bibliotecas vinculadas a un programa en C. Si el tiempo de ejecuci&amp;oacute;n ya se inicializ&amp;oacute; con &amp;eacute;xito, esto devuelve verdadero. Cada llamada para inicializar debe ser emparejada por una llamada para &lt;a href=&quot;#terminate&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd011618a7d780c02099be5bb857d574a889ced4" translate="yes" xml:space="preserve">
          <source>Initializes the thread module. This function must be called by the garbage collector on startup and before any other thread routines are called.</source>
          <target state="translated">Inicializa el módulo del hilo.Esta función debe ser llamada por el recolector de basura en el inicio y antes de que se llamen otras rutinas de hilos.</target>
        </trans-unit>
        <trans-unit id="f7bf172cc09f5d408e5dbadd459ffc810fa40735" translate="yes" xml:space="preserve">
          <source>Initializes this object.</source>
          <target state="translated">Inicializa este objeto.</target>
        </trans-unit>
        <trans-unit id="330d0782e4b98319bc9e2fabb58b097370cccd48" translate="yes" xml:space="preserve">
          <source>Initializes var with the lazy init value in a thread-safe manner.</source>
          <target state="translated">Inicializa var con el valor de init perezoso de una manera segura.</target>
        </trans-unit>
        <trans-unit id="357baf1e97067fcd6c5956ff04a8aafd59f2e20c" translate="yes" xml:space="preserve">
          <source>Initializing a field more than once is an error:</source>
          <target state="translated">Iniciar un campo más de una vez es un error:</target>
        </trans-unit>
        <trans-unit id="7b6a85ba00f40263892051680251fc88efc22b1f" translate="yes" xml:space="preserve">
          <source>Initially, &lt;code&gt;KRRegion&lt;/code&gt; starts in &quot;region&quot; mode: allocations are served from the memory chunk in a region fashion. Thus, as long as there is enough memory left, &lt;code&gt;KRRegion.allocate&lt;/code&gt; has the performance profile of a region allocator. Deallocation inserts (in &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;) time) the deallocated blocks in an unstructured freelist, which is not read in region mode.</source>
          <target state="translated">Inicialmente, &lt;code&gt;KRRegion&lt;/code&gt; comienza en modo &quot;regi&amp;oacute;n&quot;: las asignaciones se sirven desde el fragmento de memoria en forma regional. Por lo tanto, mientras quede suficiente memoria, &lt;code&gt;KRRegion.allocate&lt;/code&gt; tiene el perfil de rendimiento de un asignador de regi&amp;oacute;n. La desasignaci&amp;oacute;n inserta (en &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ) tiempo) los bloques desasignados en una lista libre no estructurada, que no se lee en modo regi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6bcf5b308aa4ed1bdc1fe48856a7ba75e0842648" translate="yes" xml:space="preserve">
          <source>Initiate a search for all non-overlapping matches to the pattern &lt;code&gt;re&lt;/code&gt; in the given &lt;code&gt;input&lt;/code&gt;. The result is a lazy range of matches generated as they are encountered in the input going left to right.</source>
          <target state="translated">Inicie una b&amp;uacute;squeda de todas las coincidencias no superpuestas con el patr&amp;oacute;n &lt;code&gt;re&lt;/code&gt; en la &lt;code&gt;input&lt;/code&gt; dada . El resultado es un rango lento de coincidencias generadas a medida que se encuentran en la entrada que va de izquierda a derecha.</target>
        </trans-unit>
        <trans-unit id="39a92c1c48ec637efb7a0a17e58b57967f5754ea" translate="yes" xml:space="preserve">
          <source>Initiate the shutdown</source>
          <target state="translated">Iniciar el apagado</target>
        </trans-unit>
        <trans-unit id="505f260038380736b5ec292da3beb645bc7a02ab" translate="yes" xml:space="preserve">
          <source>Inline Assembler</source>
          <target state="translated">Ensamblador en línea</target>
        </trans-unit>
        <trans-unit id="e8c0903b87db76a205d27b465bff8acf36d3a3fc" translate="yes" xml:space="preserve">
          <source>Inline Code</source>
          <target state="translated">Código en línea</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">Funciones en línea</target>
        </trans-unit>
        <trans-unit id="0e581275df3e295be9dbef35d1d241b50ed09352" translate="yes" xml:space="preserve">
          <source>Inline Links</source>
          <target state="translated">Enlaces en línea</target>
        </trans-unit>
        <trans-unit id="e928c83ba27af9a3e30934913f4f5025c9156467" translate="yes" xml:space="preserve">
          <source>Inline Status</source>
          <target state="translated">Estado de la línea</target>
        </trans-unit>
        <trans-unit id="2a9bcb6f0852ea225d7f231f321da701f1352c4f" translate="yes" xml:space="preserve">
          <source>Inline assembler can be used to access hardware directly:</source>
          <target state="translated">El ensamblador en línea puede ser usado para acceder al hardware directamente:</target>
        </trans-unit>
        <trans-unit id="79759f20677d34f63a3ad16ca748c0357029c9ef" translate="yes" xml:space="preserve">
          <source>Inline assembler implementation for DMD.</source>
          <target state="translated">Implementación del ensamblador en línea para el DMD.</target>
        </trans-unit>
        <trans-unit id="8bb9331db9f6ba0e169e23c73a72b91ef379fcfb" translate="yes" xml:space="preserve">
          <source>Inline assembler is supported with the asm statement:</source>
          <target state="translated">El ensamblador en línea se apoya en la declaración del asm:</target>
        </trans-unit>
        <trans-unit id="30bd67072a99e7f0e67136dac69a9f97d8fe06e6" translate="yes" xml:space="preserve">
          <source>Inline code can be written between backtick characters (`), similarly to the syntax used on GitHub, Reddit, Stack Overflow, and other websites. Both the opening and closing ` character must appear on the same line to trigger this behavior.</source>
          <target state="translated">El código en línea puede escribirse entre caracteres de retroceso (`),de forma similar a la sintaxis utilizada en GitHub,Reddit,Stack Overflow y otros sitios web.Tanto el carácter ` de apertura como el de cierre deben aparecer en la misma línea para desencadenar este comportamiento.</target>
        </trans-unit>
        <trans-unit id="3a0d3f2169904e16efc469dbb314be7e91a83d62" translate="yes" xml:space="preserve">
          <source>Inline-style links enclose link text in square brackets and the link URL in parentheses. Like reference links, the URL may optionally be followed by title text wrapped in single or double quotes, or in parentheses:</source>
          <target state="translated">Los enlaces de estilo en línea encierran el texto del enlace entre corchetes y el URL del enlace entre paréntesis.Al igual que los enlaces de referencia,el URL puede ir opcionalmente seguido de un texto de título entre comillas simples o dobles,o entre paréntesis:</target>
        </trans-unit>
        <trans-unit id="59987901b798d3774e680b1f2e942cf43901da46" translate="yes" xml:space="preserve">
          <source>InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</source>
          <target state="translated">InlineAsmStatement &lt;code&gt;s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78d80e54409073effd7ab616e62a68493fee350d" translate="yes" xml:space="preserve">
          <source>Inout Functions</source>
          <target state="translated">Funciones de Inout</target>
        </trans-unit>
        <trans-unit id="e8e7165f5b963e02cdaf54a8eb17befc2421e96a" translate="yes" xml:space="preserve">
          <source>Inout types can be implicitly converted to const or inout const, but to nothing else. Other types cannot be implicitly converted to inout. Casting to or from inout is not allowed in @safe functions.</source>
          <target state="translated">Los tipos inout pueden ser convertidos implícitamente a const o inout const,pero a nada más.Otros tipos no pueden ser convertidos implícitamente a inout.El casting hacia o desde inout no está permitido en las funciones @safe.</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">Matriz de entrada.</target>
        </trans-unit>
        <trans-unit id="805a8fb36fe255b6fb65ad6afc87bb5c87d77739" translate="yes" xml:space="preserve">
          <source>Input range primitives.</source>
          <target state="translated">Primitivos de rango de entrada.</target>
        </trans-unit>
        <trans-unit id="2b5a3aca97f7c0ee924c45da0b642efd3933bcec" translate="yes" xml:space="preserve">
          <source>Input range primitives. Always present.</source>
          <target state="translated">Primitivos de rango de entrada.Siempre presente.</target>
        </trans-unit>
        <trans-unit id="3ea0015c09b13077d49706cf98824e19781f5a6d" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;front&lt;/code&gt;</source>
          <target state="translated">Entrada Rango &lt;code&gt;front&lt;/code&gt; al</target>
        </trans-unit>
        <trans-unit id="ea0417fdf24ea467e5d4948e4d2f763b6a7eef2b" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;haystack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="263a897da5a7d45d98fac35624cdf4deb7cf4411" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;input&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;input&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8a5a20feb07807120b419370d56d0cc41af44e6" translate="yes" xml:space="preserve">
          <source>InputRange &lt;code&gt;seq&lt;/code&gt;</source>
          <target state="translated">InputRange &lt;code&gt;seq&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ac91ede8a06926e9fd7701df246ece786ebf98" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, Element)(InputRange haystack, scope Element needle)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt; (alias pred = &quot;a == b&quot;, InputRange, Element) (InputRange haystack, scope Element needle)</target>
        </trans-unit>
        <trans-unit id="62294650ad3440bbcc9dfa642f50ca9b106dfc41" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt;(alias pred, InputRange)(InputRange haystack)</source>
          <target state="translated">InputRange &lt;strong id=&quot;find&quot;&gt;find&lt;/strong&gt; (alias pred, InputRange) (InputRange haystack)</target>
        </trans-unit>
        <trans-unit id="cd55b74bf8e8c901c82e7777b6c9deb713ab8571" translate="yes" xml:space="preserve">
          <source>InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt;(alias pred = &quot;a == b&quot;, InputRange, ForwardRange)(InputRange seq, ForwardRange choices)</source>
          <target state="translated">InputRange &lt;strong id=&quot;findAmong&quot;&gt;findAmong&lt;/strong&gt; (alias pred = &quot;a == b&quot;, InputRange, ForwardRange) (opciones InputRange seq, ForwardRange)</target>
        </trans-unit>
        <trans-unit id="215e5e329de1e54df130b5fa8c6b834e564f901b" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;r1&lt;/code&gt;</source>
          <target state="translated">InputRange1 &lt;code&gt;r1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249ee449e0f4478b44dc1191e22438bd70e851a5" translate="yes" xml:space="preserve">
          <source>InputRange1 &lt;code&gt;src&lt;/code&gt;</source>
          <target state="translated">InputRange1 &lt;code&gt;src&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c677621d3536f932357d78e1812f103084e329df" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;r2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71bdacf44f1217f068320302c2f0ee3826890d58" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;code&gt;tgt&lt;/code&gt;</source>
          <target state="translated">InputRange2 &lt;code&gt;tgt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26853b5826e342866783ec6125630078fcc1a0ef" translate="yes" xml:space="preserve">
          <source>InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt;(InputRange1, InputRange2)(InputRange1 src, InputRange2 tgt)</source>
          <target state="translated">InputRange2 &lt;strong id=&quot;moveAll&quot;&gt;moveAll&lt;/strong&gt; (InputRange1, InputRange2) (InputRange1 src, InputRange2 tgt)</target>
        </trans-unit>
        <trans-unit id="a6d9a6e40c7583de17b5334cea373d1a6f012a01" translate="yes" xml:space="preserve">
          <source>InputRangeObject!R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt;(R)(R range)</source>
          <target state="translated">InputRangeObject! R &lt;strong id=&quot;inputRangeObject&quot;&gt;inputRangeObject&lt;/strong&gt; (R) (rango R)</target>
        </trans-unit>
        <trans-unit id="54690a68ec01cec2015c43085af22e3b7ee1fd11" translate="yes" xml:space="preserve">
          <source>Inscriptional Pahlavi</source>
          <target state="translated">Pahlavi Inscripcional</target>
        </trans-unit>
        <trans-unit id="fef5264f6a30e6dcae96d08ee848ad4b86a2a3a3" translate="yes" xml:space="preserve">
          <source>Inscriptional Parthian</source>
          <target state="translated">Partiano Inscripcional</target>
        </trans-unit>
        <trans-unit id="7e7e7b17b20df161139e8ef284689d406182e357" translate="yes" xml:space="preserve">
          <source>Inscriptional_Pahlavi</source>
          <target state="translated">Inscriptional_Pahlavi</target>
        </trans-unit>
        <trans-unit id="c38bdc08ad33b7372f9f91847cd5f574862ccea5" translate="yes" xml:space="preserve">
          <source>Inscriptional_Parthian</source>
          <target state="translated">Inscriptional_Parthian</target>
        </trans-unit>
        <trans-unit id="3c215b42cade3b7a8b98554cb505256252393b54" translate="yes" xml:space="preserve">
          <source>Insert a backtick</source>
          <target state="translated">Inserte un palo de espalda</target>
        </trans-unit>
        <trans-unit id="138a4c6393efa857920b23a60fdca2a6694f91d0" translate="yes" xml:space="preserve">
          <source>Insert a dollar sign</source>
          <target state="translated">Inserte un signo de dólar</target>
        </trans-unit>
        <trans-unit id="cecb3ad08db064401b3027bd8bdfecfd625474f6" translate="yes" xml:space="preserve">
          <source>Insert a left parenthesis</source>
          <target state="translated">Insertar un paréntesis izquierdo</target>
        </trans-unit>
        <trans-unit id="cbdb76fffabdf5eb3b5ae5b2ff4c5c2a9ba7b666" translate="yes" xml:space="preserve">
          <source>Insert a line feed (newline)</source>
          <target state="translated">Insertar una línea de alimentación (línea nueva)</target>
        </trans-unit>
        <trans-unit id="c0306b572d5a694e3a6dd42bca0200f018f85238" translate="yes" xml:space="preserve">
          <source>Insert a range of elements in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">Inserte una serie de elementos en el contenedor.Obsérvese que esto no invalida ningún rango que actualmente esté iterando el contenedor.</target>
        </trans-unit>
        <trans-unit id="1a917cf9fad45f42c5f9d737b6e96f9575d41832" translate="yes" xml:space="preserve">
          <source>Insert a right parenthesis</source>
          <target state="translated">Insertar un paréntesis derecho</target>
        </trans-unit>
        <trans-unit id="327083c1ff82497e1f646caa621a2ae2d82389b4" translate="yes" xml:space="preserve">
          <source>Insert a single element in the container. Note that this does not invalidate any ranges currently iterating the container.</source>
          <target state="translated">Inserte un solo elemento en el contenedor.Obsérvese que esto no invalida ningún rango que actualmente esté iterando el contenedor.</target>
        </trans-unit>
        <trans-unit id="42c8592347a2b25e78dc2c81426ea39331669868" translate="yes" xml:space="preserve">
          <source>Insert current item from the source into the target.</source>
          <target state="translated">Insertar el elemento actual de la fuente en el objetivo.</target>
        </trans-unit>
        <trans-unit id="d776dcf131b9f5a24feff6fc21b29e6dcf5da88f" translate="yes" xml:space="preserve">
          <source>Insert finally block calls when doing a goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for EH_DWARF exception unwinding.</source>
          <target state="translated">Insertar finalmente bloqueos de llamadas cuando se hace un goto desde el interior de un bloque de prueba al exterior.Se hace después de que se generen los bloques porque entonces conocemos todos los bordes del gráfico,pero antes de que se calculen los Bpred.Sólo para el desenrollado de la excepción EH_DWARF.</target>
        </trans-unit>
        <trans-unit id="5471bf7c7cfa66ea6e595c4758d088cf1cff366e" translate="yes" xml:space="preserve">
          <source>Insert gotos to finally blocks when doing a return or goto from inside a try block to outside. Done after blocks are generated because then we know all the edges of the graph, but before the Bpred's are computed. Only for functions with no exception handling. Very similar to insertFinallyBlockCalls().</source>
          <target state="translated">Insertar gotas para finalmente bloquear cuando se hace un retorno o un goto desde el interior de un bloque de prueba hacia el exterior.Se hace después de que se generen los bloques porque entonces conocemos todos los bordes del gráfico,pero antes de que se calculen los Bpred.Sólo para funciones sin manejo de excepciones.Muy similar a insertarFinallyBlockCalls().</target>
        </trans-unit>
        <trans-unit id="dac79eb40ab7303630f93c4973c9239f694c7c19" translate="yes" xml:space="preserve">
          <source>Insert item into list at nth position.</source>
          <target state="translated">Inserte el elemento en la lista en la posición n.</target>
        </trans-unit>
        <trans-unit id="e157f7049edabd9484326a29b8f9b52a72eaeb25" translate="yes" xml:space="preserve">
          <source>Inserted in place of invalid UTF sequences.</source>
          <target state="translated">Insertado en lugar de las secuencias UTF inválidas.</target>
        </trans-unit>
        <trans-unit id="143f825d20ba520107ed764caaeba3c49e097300" translate="yes" xml:space="preserve">
          <source>Inserting if not present</source>
          <target state="translated">Insertar si no está presente</target>
        </trans-unit>
        <trans-unit id="30a6615838d01663d72779532f25d77de2451cfa" translate="yes" xml:space="preserve">
          <source>Insertion failed because database is full</source>
          <target state="translated">La inserción falló porque la base de datos está llena</target>
        </trans-unit>
        <trans-unit id="20cdd78769ce43b7cb858f988154e98a6f228025" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime may be turned off with a compiler switch &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt;&lt;code&gt;-boundscheck&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La inserci&amp;oacute;n del c&amp;oacute;digo de comprobaci&amp;oacute;n de l&amp;iacute;mites de la matriz en tiempo de ejecuci&amp;oacute;n se puede desactivar con un conmutador de compilaci&amp;oacute;n &lt;a href=&quot;https://dlang.org/dmd.html#switch-boundscheck&quot;&gt; &lt;code&gt;-boundscheck&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bdc47adb0591faa30b8ba1f2040d211a501160c" translate="yes" xml:space="preserve">
          <source>Insertion of array bounds checking code at runtime should be turned on and off with a compile time switch.</source>
          <target state="translated">La inserción del código de comprobación de los límites de la matriz en tiempo de ejecución debe ser activada y desactivada con un interruptor de tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="0fe401e132558c29c269b7fd6cffd6a1dc02d7db" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; (which must be an input range or any number of implicitly convertible items) in &lt;code&gt;array&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">Inserta &lt;code&gt;stuff&lt;/code&gt; (que deben ser un rango de entrada o cualquier n&amp;uacute;mero de elementos convertibles impl&amp;iacute;citamente) en la &lt;code&gt;array&lt;/code&gt; en la posici&amp;oacute;n &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccbf9d19e58cf1e67a852d50890252788f63b174" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a non-empty range previously extracted from this container.</source>
          <target state="translated">Inserta &lt;code&gt;stuff&lt;/code&gt; despu&amp;eacute;s del rango &lt;code&gt;r&lt;/code&gt; , que debe ser un rango no vac&amp;iacute;o previamente extra&amp;iacute;do de este contenedor.</target>
        </trans-unit>
        <trans-unit id="bbcf5a5de0747fda77b1e1e1643549b4e06e5bb8" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; after range &lt;code&gt;r&lt;/code&gt;, which must be a range previously extracted from this container. Given that all ranges for a list end at the end of the list, this function essentially appends to the list and uses &lt;code&gt;r&lt;/code&gt; as a potentially fast way to reach the last node in the list. Ideally &lt;code&gt;r&lt;/code&gt; is positioned near or at the last element of the list.</source>
          <target state="translated">Inserta &lt;code&gt;stuff&lt;/code&gt; despu&amp;eacute;s del rango &lt;code&gt;r&lt;/code&gt; , que debe ser un rango previamente extra&amp;iacute;do de este contenedor. Dado que todos los rangos de una lista finalizan al final de la lista, esta funci&amp;oacute;n se agrega esencialmente a la lista y usa &lt;code&gt;r&lt;/code&gt; como una forma potencialmente r&amp;aacute;pida de llegar al &amp;uacute;ltimo nodo de la lista. Idealmente, &lt;code&gt;r&lt;/code&gt; se coloca cerca o en el &amp;uacute;ltimo elemento de la lista.</target>
        </trans-unit>
        <trans-unit id="6f06bb00c64490bdfd0684d68ce1e50ed8931cf5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">Inserta &lt;code&gt;stuff&lt;/code&gt; antes, despu&amp;eacute;s o, en su lugar, rango &lt;code&gt;r&lt;/code&gt; , que debe ser un rango v&amp;aacute;lido previamente extra&amp;iacute;do de esta matriz. &lt;code&gt;stuff&lt;/code&gt; puede ser un valor convertible en &lt;code&gt;T&lt;/code&gt; o un rango de objetos convertible a &lt;code&gt;T&lt;/code&gt; . Tanto la versi&amp;oacute;n estable como la no estable se comportan igual y garantizan que los rangos que iteran sobre la matriz nunca se invalidan.</target>
        </trans-unit>
        <trans-unit id="f08fcf4de04b5d69b89946f0b954703523fa90fc" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; before, after, or instead range &lt;code&gt;r&lt;/code&gt;, which must be a valid range previously extracted from this array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;. Both stable and non-stable version behave the same and guarantee that ranges iterating over the array are never invalidated.</source>
          <target state="translated">Inserta &lt;code&gt;stuff&lt;/code&gt; antes, despu&amp;eacute;s o, en su lugar, rango &lt;code&gt;r&lt;/code&gt; , que debe ser un rango v&amp;aacute;lido previamente extra&amp;iacute;do de esta matriz. &lt;code&gt;stuff&lt;/code&gt; pueden ser un valor convertible a &lt;code&gt;bool&lt;/code&gt; o una gama de objetos convertibles a &lt;code&gt;bool&lt;/code&gt; . Tanto la versi&amp;oacute;n estable como la no estable se comportan igual y garantizan que los rangos que iteran sobre la matriz nunca se invalidan.</target>
        </trans-unit>
        <trans-unit id="dcb7963cdc25fdee24c788729e6be8dd4f7e3c27" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">Inserta &lt;code&gt;stuff&lt;/code&gt; al frente del contenedor. &lt;code&gt;stuff&lt;/code&gt; puede ser un valor convertible en &lt;code&gt;T&lt;/code&gt; o un rango de objetos convertible a &lt;code&gt;T&lt;/code&gt; . La versi&amp;oacute;n estable se comporta igual, pero garantiza que los rangos que iteran sobre el contenedor nunca se invalidan.</target>
        </trans-unit>
        <trans-unit id="70b0bd082af545b88841219b95946def84b1bde5" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;stuff&lt;/code&gt; to the front/back of the container. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated.</source>
          <target state="translated">Inserta &lt;code&gt;stuff&lt;/code&gt; en la parte frontal / posterior del contenedor. &lt;code&gt;stuff&lt;/code&gt; puede ser un valor convertible en &lt;code&gt;T&lt;/code&gt; o un rango de objetos convertible a &lt;code&gt;T&lt;/code&gt; . La versi&amp;oacute;n estable se comporta igual, pero garantiza que los rangos que iteran sobre el contenedor nunca se invalidan.</target>
        </trans-unit>
        <trans-unit id="98d4bdcdc44b42cf7f92f1b1fa3789c2aceb532f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the back of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Inserta &lt;code&gt;v&lt;/code&gt; en la parte posterior de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="314547f0dd75063020e998c66bb1c080e7cc353d" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;v&lt;/code&gt; at the front of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Inserta &lt;code&gt;v&lt;/code&gt; al frente de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b4118de001ef07d96ca9dc875bb736525602b3c" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the store. If the underlying store is a range and &lt;code&gt;length == capacity&lt;/code&gt;, throws an exception.</source>
          <target state="translated">Inserta &lt;code&gt;value&lt;/code&gt; en la tienda. Si la tienda subyacente es un rango y una &lt;code&gt;length == capacity&lt;/code&gt; , arroja una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7a861229c3ddec4f67c4aba3fc949701aaf45a21" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;c&lt;/code&gt; at a position (or positions) chosen by &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Inserta &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;c&lt;/code&gt; en una posici&amp;oacute;n (o posiciones) elegida por &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="804f9143c06ffa0aedcfc5172722337eadf6df16" translate="yes" xml:space="preserve">
          <source>Inserts a blank line.</source>
          <target state="translated">Inserta una línea en blanco.</target>
        </trans-unit>
        <trans-unit id="7a0447d3d52b9161fad5aa788df5312d0c9f70f2" translate="yes" xml:space="preserve">
          <source>Inserts a comment in the output.</source>
          <target state="translated">Inserta un comentario en la salida.</target>
        </trans-unit>
        <trans-unit id="7a683c9546bcec22da2c836a994b3f342b2d3aa0" translate="yes" xml:space="preserve">
          <source>Inserts a full load/store memory fence (on platforms that need it). This ensures that all loads and stores before a call to this function are executed before any loads and stores after the call.</source>
          <target state="translated">Inserta una valla de memoria de carga completa/almacenamiento (en plataformas que lo necesiten).Esto asegura que todas las cargas y almacenes antes de una llamada a esta función se ejecuten antes de cualquier carga y almacenes después de la llamada.</target>
        </trans-unit>
        <trans-unit id="a94c7ccab5212d83d09585607543df4cd0d7b0e8" translate="yes" xml:space="preserve">
          <source>Inserts a separator between overloads of a given name.</source>
          <target state="translated">Inserta un separador entre las sobrecargas de un nombre dado.</target>
        </trans-unit>
        <trans-unit id="aa15c23194538bcbb65217c20c49d6e178298d1b" translate="yes" xml:space="preserve">
          <source>Inserts inline code.</source>
          <target state="translated">Inserta el código en línea.</target>
        </trans-unit>
        <trans-unit id="be7c29e597d6483bb5cc792a0734c8430284107e" translate="yes" xml:space="preserve">
          <source>Inserts into an existing array at a given position.</source>
          <target state="translated">Se inserta en una matriz existente en una posición determinada.</target>
        </trans-unit>
        <trans-unit id="b2e6a38a54ba983c83824eb96e11fa99e1fb236e" translate="yes" xml:space="preserve">
          <source>Inserts the separator symbols ',' every</source>
          <target state="translated">Inserta los símbolos separadores ',' cada</target>
        </trans-unit>
        <trans-unit id="801258f3c2858353c18f16295039e48c4b8fb913" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;T&lt;/code&gt; or a range of objects convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Inserta los elementos especificados en la parte posterior de la matriz. &lt;code&gt;stuff&lt;/code&gt; puede ser un valor convertible en &lt;code&gt;T&lt;/code&gt; o un rango de objetos convertible a &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14cde1bdd1549aef1d369341e6d66efc2807a4bc" translate="yes" xml:space="preserve">
          <source>Inserts the specified elements at the back of the array. &lt;code&gt;stuff&lt;/code&gt; can be a value convertible to &lt;code&gt;bool&lt;/code&gt; or a range of objects convertible to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Inserta los elementos especificados en la parte posterior de la matriz. &lt;code&gt;stuff&lt;/code&gt; pueden ser un valor convertible a &lt;code&gt;bool&lt;/code&gt; o una gama de objetos convertibles a &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d605a6236091ada3048879c73c926d0efb2298d" translate="yes" xml:space="preserve">
          <source>Inside a compound format specifier, strings and characters are escaped automatically. To avoid this behavior, add &lt;b&gt;'-'&lt;/b&gt; flag to &lt;code&gt;&quot;%(&quot;&lt;/code&gt;.</source>
          <target state="translated">Dentro de un especificador de formato compuesto, las cadenas y los caracteres se escapan autom&amp;aacute;ticamente. Para evitar este comportamiento, agregue &lt;b&gt;el&lt;/b&gt; indicador &lt;b&gt;'-'&lt;/b&gt; a &lt;code&gt;&quot;%(&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa6dfe54274ed1710b82f903b6abd73713a2f05a" translate="yes" xml:space="preserve">
          <source>Instance Variables</source>
          <target state="translated">Variables de Instancia</target>
        </trans-unit>
        <trans-unit id="6dcf70f56aa9632f46bb219a5e2ab80717bd81f1" translate="yes" xml:space="preserve">
          <source>Instance shared by all callers.</source>
          <target state="translated">Instancia compartida por todos los que llaman.</target>
        </trans-unit>
        <trans-unit id="1d560aaea91ff74c40b9ba925224eb2e9cab5714" translate="yes" xml:space="preserve">
          <source>Instances of class objects are created with a &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt;:</source>
          <target state="translated">Las instancias de objetos de clase se crean con una &lt;a href=&quot;expression#NewExpression&quot;&gt;&lt;i&gt;NewExpression&lt;/i&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0e15b22639879009392385cbbbd0e07778e511d1" translate="yes" xml:space="preserve">
          <source>Instances of this object are constructed via calls to &lt;code&gt;regex&lt;/code&gt;. This is an intended form for caching and storage of frequently used regular expressions.</source>
          <target state="translated">Las instancias de este objeto se construyen mediante llamadas a &lt;code&gt;regex&lt;/code&gt; . Esta es una forma prevista para el almacenamiento en cach&amp;eacute; y el almacenamiento de expresiones regulares de uso frecuente.</target>
        </trans-unit>
        <trans-unit id="9c373dca3c1b04cc6629e642fffbe62b3a9fe4e5" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;DebugCondition&lt;/code&gt;</source>
          <target state="translated">Instanciar una nueva &lt;code&gt;DebugCondition&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3822674a7468f752517c5bf52d226dd0137e7bff" translate="yes" xml:space="preserve">
          <source>Instantiate a new &lt;code&gt;VersionCondition&lt;/code&gt;</source>
          <target state="translated">Instanciar una nueva &lt;code&gt;VersionCondition&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="152f1a2b9d65da1e9f82b24f153f213ef690987a" translate="yes" xml:space="preserve">
          <source>Instantiates the given template with the given parameters.</source>
          <target state="translated">Instala la plantilla con los parámetros dados.</target>
        </trans-unit>
        <trans-unit id="4a327f215e80d73f8ee4464a28c7b7c009445a31" translate="yes" xml:space="preserve">
          <source>Instantiation Scope</source>
          <target state="translated">Alcance de la Instanciación</target>
        </trans-unit>
        <trans-unit id="93486e626687f1b1676b1b49e1fd6518a0b454b0" translate="yes" xml:space="preserve">
          <source>Instantiation information</source>
          <target state="translated">La información de la instantánea</target>
        </trans-unit>
        <trans-unit id="dac2b060e0095872817c2470eb8b53d6b6180adb" translate="yes" xml:space="preserve">
          <source>Instatiates a new function call expression</source>
          <target state="translated">Instaura una nueva función llamada expresión</target>
        </trans-unit>
        <trans-unit id="10f4428424192063dd20e3361c36aa4d16de843c" translate="yes" xml:space="preserve">
          <source>Instead:</source>
          <target state="translated">Instead:</target>
        </trans-unit>
        <trans-unit id="a0905dbb5b366516614f7115449ef89eac51f289" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to not use any signal/alarm handlers, even when using timeouts. This option is useful for multi-threaded applications. See libcurl-the-guide for more background information.</source>
          <target state="translated">Instruye a libcurl para que no utilice ningún manejador de señales/alarmas,incluso cuando utilice los tiempos muertos.Esta opción es útil para aplicaciones con múltiples hilos.Véase libcurl-the-guide para más información de fondo.</target>
        </trans-unit>
        <trans-unit id="93df39339f21a04f493609200c104dc46ba84fa9" translate="yes" xml:space="preserve">
          <source>Instruct libcurl to use a smaller receive buffer</source>
          <target state="translated">Instruye a libcurl para que use un buffer de recepción más pequeño</target>
        </trans-unit>
        <trans-unit id="4e856d175354403c672463be1daf8914ce0f2b64" translate="yes" xml:space="preserve">
          <source>Instruct the thread module, when initialized, to use a different set of signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads. This function should be called at most once, prior to thread_init(). This function is Posix-only.</source>
          <target state="translated">Instruye al módulo de hilos,cuando se inicialice,para que utilice un conjunto diferente de señales además de SIGUSR1 y SIGUSR2 para la suspensión y reanudación de los hilos.Esta función debe ser llamada como mucho una vez,antes de thread_init().Esta función es sólo Posix.</target>
        </trans-unit>
        <trans-unit id="ea729c0363a2bc9c76992c1a2e2bf3e5220ecc9e" translate="yes" xml:space="preserve">
          <source>Instructions are selected from the target architecture to implement the semantics of the program. The typical result will be an object file, suitable for input to a linker.</source>
          <target state="translated">Las instrucciones se seleccionan de la arquitectura del objetivo para implementar la semántica del programa.El resultado típico será un archivo de objeto,adecuado para la entrada a un enlazador.</target>
        </trans-unit>
        <trans-unit id="492ad7a25e9093c89a88ab9eae0481a3d6d480b5" translate="yes" xml:space="preserve">
          <source>IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt;(Expression e);</source>
          <target state="translated">IntRange &lt;strong id=&quot;getIntRange&quot;&gt;getIntRange&lt;/strong&gt; (Expresi&amp;oacute;n e);</target>
        </trans-unit>
        <trans-unit id="562d27265f4183bba6926e62be0c6ce57f7e2097" translate="yes" xml:space="preserve">
          <source>Integer Literals</source>
          <target state="translated">literales enteros</target>
        </trans-unit>
        <trans-unit id="bd777b837ba4f419f4b02435e27128be81023ef2" translate="yes" xml:space="preserve">
          <source>Integer Promotions</source>
          <target state="translated">Promociones de números enteros</target>
        </trans-unit>
        <trans-unit id="9568ecb6786424f8ca136701942b4f686fc642d2" translate="yes" xml:space="preserve">
          <source>Integer Promotions are conversions of the following types:</source>
          <target state="translated">Las promociones de números enteros son conversiones de los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="db47076f1ac16cea001c1edc5817f57fa5127f93" translate="yes" xml:space="preserve">
          <source>Integer Whole Number: (byte, ubyte, short, ushort, int, uint, long, and ulong) ['+'|'-']digit(s)[U|L|UL]</source>
          <target state="translated">Número entero entero:(byte,ubyte,corto,ushort,int,uint,long y ulong)['+'|'-']dígito(s)[U|L|UL]</target>
        </trans-unit>
        <trans-unit id="2c1da0fff670105eb87d89c45a8168527ceeec25" translate="yes" xml:space="preserve">
          <source>Integer comparison operators</source>
          <target state="translated">Operadores de comparación de números enteros</target>
        </trans-unit>
        <trans-unit id="b5ccca1ae24a500cd1c22e7e4ca7606c1848c22a" translate="yes" xml:space="preserve">
          <source>Integer comparisons</source>
          <target state="translated">Comparaciones de números enteros</target>
        </trans-unit>
        <trans-unit id="343b406e188c4782bf6c33cf9f047756fbc9ecb9" translate="yes" xml:space="preserve">
          <source>Integer comparisons happen when both operands are integral types.</source>
          <target state="translated">Las comparaciones de números enteros ocurren cuando ambos operandos son tipos integrales.</target>
        </trans-unit>
        <trans-unit id="adcbb9dbe2818c1f42e7e40cd4eb69ffc2847624" translate="yes" xml:space="preserve">
          <source>Integer values cannot be implicitly converted to another type that cannot represent the integer bit pattern after integral promotion. For example:</source>
          <target state="translated">Los valores enteros no pueden ser convertidos implícitamente a otro tipo que no pueda representar el patrón de bits del entero después de la promoción integral.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="2745c9287a60962527a82479b71c8fcdcdfee9b5" translate="yes" xml:space="preserve">
          <source>IntegerExp &lt;strong id=&quot;literal&quot;&gt;literal&lt;/strong&gt;(int v)();</source>
          <target state="translated">IntegerExp &lt;strong id=&quot;literal&quot;&gt;literal&lt;/strong&gt; (int v) ();</target>
        </trans-unit>
        <trans-unit id="9ef2cfdc220f6cdcf3fe63e63ff8a17f54977fca" translate="yes" xml:space="preserve">
          <source>IntegerExpression</source>
          <target state="translated">IntegerExpression</target>
        </trans-unit>
        <trans-unit id="17c52e79fc66bb6ecd61f1fe24bcec43e30c42c1" translate="yes" xml:space="preserve">
          <source>IntegerLiteral</source>
          <target state="translated">IntegerLiteral</target>
        </trans-unit>
        <trans-unit id="36d10f6bb46fb8657ec9f18b1e3a960789ae3c76" translate="yes" xml:space="preserve">
          <source>Integers (that may be constant-folded).</source>
          <target state="translated">Números enteros (que pueden estar doblados de forma constante).</target>
        </trans-unit>
        <trans-unit id="f69d4a47975b227c4173e0f25508229d914b2ec7" translate="yes" xml:space="preserve">
          <source>Integers and floating point values can be implicitly converted to their vector equivalents:</source>
          <target state="translated">Los números enteros y los valores en coma flotante pueden ser convertidos implícitamente a sus equivalentes vectoriales:</target>
        </trans-unit>
        <trans-unit id="85eae330c4b91b44cc2722cee1dc4a35c6511dee" translate="yes" xml:space="preserve">
          <source>Integers can be immediately followed by one &amp;lsquo;L&amp;rsquo; or one of &amp;lsquo;u&amp;rsquo; or &amp;lsquo;U&amp;rsquo; or both. Note that there is no &amp;lsquo;l&amp;rsquo; suffix.</source>
          <target state="translated">Los enteros pueden ser seguidos inmediatamente por una 'L' o una de 'u' o 'U' o ambas. Tenga en cuenta que no hay sufijo 'l'.</target>
        </trans-unit>
        <trans-unit id="78c49e8c1cc448a9049ab277bc8754ecd4237b78" translate="yes" xml:space="preserve">
          <source>Integers can be specified in decimal, binary, or hexadecimal.</source>
          <target state="translated">Los números enteros pueden especificarse en decimal,binario o hexadecimal.</target>
        </trans-unit>
        <trans-unit id="2f0a498505f60eef0691bff5f687040cecb8e8a2" translate="yes" xml:space="preserve">
          <source>Integers can have embedded &amp;lsquo;_&amp;rsquo; characters, which are ignored.</source>
          <target state="translated">Los enteros pueden tener caracteres '_' incrustados, que se ignoran.</target>
        </trans-unit>
        <trans-unit id="e97fd09a5e159320944c7a6e53ff8dac7ae91693" translate="yes" xml:space="preserve">
          <source>Integral arithmetic operators operate on fixed width types. Results that are not representable in those fixed widths are silently truncated to fit. This module offers integral arithmetic primitives that produce the same results, but set an 'overflow' flag when such truncation occurs. The setting is sticky, meaning that numerous operations can be cascaded and then the flag need only be checked at the end. Whether the operation is signed or unsigned is indicated by an 's' or 'u' suffix, respectively. While this could be achieved without such suffixes by using overloading on the signedness of the types, the suffix makes it clear which is happening without needing to examine the types.</source>
          <target state="translated">Los operadores de aritmética integral operan en tipos de ancho fijo.Los resultados que no son representativos en esos anchos fijos se truncan silenciosamente para que encajen.Este módulo ofrece primitivos aritméticos integrales que producen los mismos resultados,pero que ponen una bandera de &quot;desbordamiento&quot; cuando se produce dicho truncamiento.El ajuste es pegajoso,lo que significa que se pueden realizar numerosas operaciones en cascada y luego sólo hay que comprobar la bandera al final.Si la operación está firmada o no,se indica con un sufijo &quot;s&quot; o &quot;u&quot;,respectivamente.Si bien esto se podría lograr sin esos sufijos utilizando una sobrecarga en la firma de los tipos,el sufijo deja claro lo que sucede sin necesidad de examinar los tipos.</target>
        </trans-unit>
        <trans-unit id="6c054c378c65fd28ca92392142534a3f43340caf" translate="yes" xml:space="preserve">
          <source>Integral ranges</source>
          <target state="translated">Gamas integrales</target>
        </trans-unit>
        <trans-unit id="3c327fe3bc8ca1ef616b394085c0f88695904ee8" translate="yes" xml:space="preserve">
          <source>Integral types will remain the same sizes between 32 and 64 bit code.</source>
          <target state="translated">Los tipos integrales seguirán teniendo el mismo tamaño entre el código de 32 y 64 bits.</target>
        </trans-unit>
        <trans-unit id="58ee21eb085c257d8a08439c9aa7bd9d6570255b" translate="yes" xml:space="preserve">
          <source>Integrals</source>
          <target state="translated">Integrals</target>
        </trans-unit>
        <trans-unit id="304d073445766b9e99ba6213d6788d69fbbe285d" translate="yes" xml:space="preserve">
          <source>Integrals are formatted like &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt;&lt;code&gt;core.stdc.stdio.printf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Las integrales est&amp;aacute;n formateadas como &lt;a href=&quot;core_stdc_stdio#printf&quot;&gt; &lt;code&gt;core.stdc.stdio.printf&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20aeee70fc77c214f263c77b05117e3b20686b33" translate="yes" xml:space="preserve">
          <source>Intel Atom 230/330 (family 6, model 0x1C) is an in-order core.</source>
          <target state="translated">El Intel Atom 230/330 (familia 6,modelo 0x1C)es un núcleo en pedido.</target>
        </trans-unit>
        <trans-unit id="25a734a01cad152ff48222d53e7362444f3ac6cd" translate="yes" xml:space="preserve">
          <source>Intel NetBurst (Pentium 4, Pentium D).</source>
          <target state="translated">Intel NetBurst (Pentium 4,Pentium D).</target>
        </trans-unit>
        <trans-unit id="40d218fe001ffffff82fbf964a99f28c6e816245" translate="yes" xml:space="preserve">
          <source>Intel P6 (PentiumPro, PII, PIII, PM, Core, Core2).</source>
          <target state="translated">Intel P6 (PentiumPro,PII,PIII,PM,Core,Core2).</target>
        </trans-unit>
        <trans-unit id="ffc1549d5dca52e99aa4ab17a1e6e08f96cd5245" translate="yes" xml:space="preserve">
          <source>Intel and AMD 32-bit processors</source>
          <target state="translated">Procesadores Intel y AMD de 32 bits</target>
        </trans-unit>
        <trans-unit id="3eaebee622e08211c80a68d4d6c79b54e2adb573" translate="yes" xml:space="preserve">
          <source>Intel and AMD 64-bit processors</source>
          <target state="translated">Procesadores Intel y AMD de 64 bits</target>
        </trans-unit>
        <trans-unit id="d9d20cde548a0781b6cf33434f83eb6eb5ef95f8" translate="yes" xml:space="preserve">
          <source>Intended as the range equivalent of the Unix &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;tail&lt;/a&gt; utility. When the length of &lt;code&gt;range&lt;/code&gt; is less than or equal to &lt;code&gt;_n&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; is returned as-is.</source>
          <target state="translated">Previsto como el rango equivalente de la utilidad de &lt;a href=&quot;http://en.wikipedia.org/wiki/Tail_%28Unix%29&quot;&gt;cola&lt;/a&gt; Unix . Cuando la longitud del &lt;code&gt;range&lt;/code&gt; es menor o igual a &lt;code&gt;_n&lt;/code&gt; , el &lt;code&gt;range&lt;/code&gt; se devuelve tal cual.</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="d88c1e8acf6c80eddca147502d3048d176708e8b" translate="yes" xml:space="preserve">
          <source>Interface for a bidirectional range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Interfaz para una gama bidireccional de tipo &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0e1da15b0eee348c354776c7e919fb0b891bd0d" translate="yes" xml:space="preserve">
          <source>Interface for a finite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Interfaz para una gama de acceso aleatorio finito de tipo &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a634a284850ac6bc64c6899e29c994e3e0d76a1" translate="yes" xml:space="preserve">
          <source>Interface for a forward range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Interfaz para un rango delantero de tipo &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a821a67cbe42a25dc97be41d2bf278fa2b3f8d9" translate="yes" xml:space="preserve">
          <source>Interface for an infinite random access range of type &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Interfase para una gama infinita de acceso aleatorio de tipo &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d0cf57e850156d9f049479c7169bad62b9af52" translate="yes" xml:space="preserve">
          <source>Interface for an output range of type &lt;code&gt;E&lt;/code&gt;. Usage is similar to the &lt;code&gt;InputRange&lt;/code&gt; interface and descendants.</source>
          <target state="translated">Interfaz para un rango de salida de tipo &lt;code&gt;E&lt;/code&gt; . El uso es similar a la interfaz &lt;code&gt;InputRange&lt;/code&gt; y descendientes.</target>
        </trans-unit>
        <trans-unit id="9460943add2d33f93432076ae984835cefe527f7" translate="yes" xml:space="preserve">
          <source>Interface for diagnostic reporting.</source>
          <target state="translated">Interfaz para la presentación de informes de diagnóstico.</target>
        </trans-unit>
        <trans-unit id="3a1df4ab19b1c423cdf62882763fa74c4af37e82" translate="yes" xml:space="preserve">
          <source>Interface member functions can have contracts even though there is no body for the function. The contracts are inherited by any class member function that implements that interface member function.</source>
          <target state="translated">Las funciones de los miembros de la interfaz pueden tener contratos aunque no haya un cuerpo para la función.Los contratos son heredados por cualquier función de miembro de clase que implemente esa función de miembro de interfaz.</target>
        </trans-unit>
        <trans-unit id="f3be3896196c198c957ce4d700b0918b399182de" translate="yes" xml:space="preserve">
          <source>Interface to C++</source>
          <target state="translated">Interfaz a C++</target>
        </trans-unit>
        <trans-unit id="d7b35a8578bedf4b2033b8a1d3efb36b51c26426" translate="yes" xml:space="preserve">
          <source>Interface to ODBC C library.</source>
          <target state="translated">Interfaz a la biblioteca de ODBC C.</target>
        </trans-unit>
        <trans-unit id="621522c8d929097b62eb853aff27378218dcc932" translate="yes" xml:space="preserve">
          <source>Interface to OS-specific allocators that support specifying alignment: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt;&lt;code&gt;posix_memalign&lt;/code&gt;&lt;/a&gt; on Posix and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt;&lt;code&gt;__aligned_xxx&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">Interfaz con asignadores espec&amp;iacute;ficos del sistema operativo que admiten la especificaci&amp;oacute;n de alineaci&amp;oacute;n: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/posix_memalign.3.html&quot;&gt; &lt;code&gt;posix_memalign&lt;/code&gt; &lt;/a&gt; en Posix y &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx&quot;&gt; &lt;code&gt;__aligned_xxx&lt;/code&gt; &lt;/a&gt; en Windows.</target>
        </trans-unit>
        <trans-unit id="da8580df0429b0473e5e3791367530334b73829e" translate="yes" xml:space="preserve">
          <source>Interface to SQLite C library.</source>
          <target state="translated">Interfaz a la biblioteca SQLite C.</target>
        </trans-unit>
        <trans-unit id="7de306419630810feb8071066cf5e31bb55e01fb" translate="yes" xml:space="preserve">
          <source>Interface to libcurl C library.</source>
          <target state="translated">Interfaz a la biblioteca de la biblioteca C de Libcurl.</target>
        </trans-unit>
        <trans-unit id="f42fa13806030306bbca72d2c1d02ced3c60299a" translate="yes" xml:space="preserve">
          <source>Interface to the C linked list type.</source>
          <target state="translated">Interfaz con el tipo de lista de enlaces C.</target>
        </trans-unit>
        <trans-unit id="e3744c2b6a83f2ded743b60e48109853d6af0029" translate="yes" xml:space="preserve">
          <source>Interface to zlib C library.</source>
          <target state="translated">Interfaz a la biblioteca zlib C.</target>
        </trans-unit>
        <trans-unit id="0e4b1bcf55c79cee225ecf64df995188b37f85a9" translate="yes" xml:space="preserve">
          <source>Interface[] &lt;strong id=&quot;interfaces&quot;&gt;interfaces&lt;/strong&gt;;</source>
          <target state="translated">Interfaz [] &lt;strong id=&quot;interfaces&quot;&gt;interfaces&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="87ef706c8b2c0856ee57ff234b67b63ee3440c74" translate="yes" xml:space="preserve">
          <source>Interfaces can be inherited and functions overridden:</source>
          <target state="translated">Las interfaces pueden ser heredadas y las funciones anuladas:</target>
        </trans-unit>
        <trans-unit id="5c38dbc7db84c5be19893f9ea37a5e4e03b244d7" translate="yes" xml:space="preserve">
          <source>Interfaces can be reimplemented in derived classes:</source>
          <target state="translated">Las interfaces pueden ser reimplementadas en clases derivadas:</target>
        </trans-unit>
        <trans-unit id="5c369ab8b0d4a9f58e24c8d22b04e27527c78058" translate="yes" xml:space="preserve">
          <source>Interfaces can have function templates in the members. All instantiated functions are implicitly &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">Las interfaces pueden tener plantillas de funciones en los miembros. Todas las funciones instanciadas son impl&amp;iacute;citamente &lt;code&gt;final&lt;/code&gt; es .</target>
        </trans-unit>
        <trans-unit id="bdf123e52e487e317a85601aa2c062c8ae21bd83" translate="yes" xml:space="preserve">
          <source>Interfaces cannot derive from classes; only from other interfaces. Classes cannot derive from an interface multiple times.</source>
          <target state="translated">Las interfaces no pueden derivar de las clases;sólo de otras interfaces.Las clases no pueden derivar de una interfaz varias veces.</target>
        </trans-unit>
        <trans-unit id="233b20e42a18eec431d3cd18cbd18fa45bf5e124" translate="yes" xml:space="preserve">
          <source>Interfaces describe a list of functions that a class that inherits from the interface must implement. A class that implements an interface can be converted to a reference to that interface.</source>
          <target state="translated">Las interfaces describen una lista de funciones que una clase que hereda de la interfaz debe implementar.Una clase que implementa una interfaz puede convertirse en una referencia a esa interfaz.</target>
        </trans-unit>
        <trans-unit id="c99b66b1687d267b80c156d483b9207e87aa2612" translate="yes" xml:space="preserve">
          <source>Interfaces to extend FTS5.</source>
          <target state="translated">Interfaces para extender el FTS5.</target>
        </trans-unit>
        <trans-unit id="737865cc9d40029ada2522214f2743a9901cb1cf" translate="yes" xml:space="preserve">
          <source>Interfaces with Contracts</source>
          <target state="translated">Interfaces con los contratos</target>
        </trans-unit>
        <trans-unit id="772a604c8c3d9a084a30e26beb308940804e19fb" translate="yes" xml:space="preserve">
          <source>Interfacing Garbage Collected Objects With Foreign Code</source>
          <target state="translated">Interconectando los objetos recolectados de la basura con el código extranjero</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
