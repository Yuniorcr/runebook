<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="d">
    <body>
      <group id="d">
        <trans-unit id="36c705a4549f55994270c31cf59dc15c22af56b1" translate="yes" xml:space="preserve">
          <source>Get type information on the contents of the type; null if not available</source>
          <target state="translated">Obtener información sobre el contenido del tipo;nulo si no está disponible</target>
        </trans-unit>
        <trans-unit id="96f72b00f8ed83794b8d1d1ca2272471a19aedec" translate="yes" xml:space="preserve">
          <source>Get underlying socket handle.</source>
          <target state="translated">Consigue el mango de la toma de corriente subyacente.</target>
        </trans-unit>
        <trans-unit id="48ec336cb3c23da76d213eaa7aef8a04ca5f0b14" translate="yes" xml:space="preserve">
          <source>Get various timings defined in &lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt;&lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt;&lt;/a&gt;. The value is usable only if the return value is equal to &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt;.</source>
          <target state="translated">Obtenga varios tiempos definidos en &lt;a href=&quot;etc_c_curl#CurlInfo&quot;&gt; &lt;code&gt;etc.c.curl.CurlInfo&lt;/code&gt; &lt;/a&gt; . El valor solo se puede usar si el valor de retorno es igual a &lt;code&gt;etc.c.curl.CurlError.ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efecd1a1ec18ed172626c58e06a872720a3ea949" translate="yes" xml:space="preserve">
          <source>Get with custom data receivers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb969faa69556a50edb8b7474adfcb5288a0eabc" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the default value of the parameters to a function symbol. If a parameter doesn't have the default value, &lt;code&gt;void&lt;/code&gt; is returned instead.</source>
          <target state="translated">Obtenga, como una tupla, el valor predeterminado de los par&amp;aacute;metros para un s&amp;iacute;mbolo de funci&amp;oacute;n. Si un par&amp;aacute;metro no tiene el valor predeterminado, se devuelve &lt;code&gt;void&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="6e5eb1b88f56e22db495838fb23d06aff7902858" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the identifiers of the parameters to a function symbol.</source>
          <target state="translated">Obtener,como una tupla,los identificadores de los parámetros a un símbolo de función.</target>
        </trans-unit>
        <trans-unit id="0d9be8cea698e918f8f5553c38491cc55f980684" translate="yes" xml:space="preserve">
          <source>Get, as a tuple, the types of the parameters to a function, a pointer to function, a delegate, a struct with an &lt;code&gt;opCall&lt;/code&gt;, a pointer to a struct with an &lt;code&gt;opCall&lt;/code&gt;, or a class with an &lt;code&gt;opCall&lt;/code&gt;.</source>
          <target state="translated">Obtenga, como una tupla, los tipos de par&amp;aacute;metros para una funci&amp;oacute;n, un puntero para funcionar, un delegado, una estructura con un &lt;code&gt;opCall&lt;/code&gt; , un puntero a una estructura con un &lt;code&gt;opCall&lt;/code&gt; o una clase con un &lt;code&gt;opCall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a2a322d7843413da4411904750627b588381236" translate="yes" xml:space="preserve">
          <source>Get/set number of elements in the array. It is of type &lt;code&gt;size_t&lt;/code&gt;.</source>
          <target state="translated">Obtener / establecer el n&amp;uacute;mero de elementos en la matriz. Es de tipo &lt;code&gt;size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e903dced1589591dccd55f4a2a573704d37b25f7" translate="yes" xml:space="preserve">
          <source>Get/set socket's blocking flag.</source>
          <target state="translated">Poner la bandera de bloqueo del enchufe.</target>
        </trans-unit>
        <trans-unit id="8143cfad11bbcb508b2faa890c629adbe90a1326" translate="yes" xml:space="preserve">
          <source>GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt;(T...)(ref string[] args, T opts);</source>
          <target state="translated">GetoptResult &lt;strong id=&quot;getopt&quot;&gt;getopt&lt;/strong&gt; (T ...) (ref string [] args, T opts);</target>
        </trans-unit>
        <trans-unit id="3639898092fae686744daf985b5a5af78426e672" translate="yes" xml:space="preserve">
          <source>Gets a &lt;a href=&quot;#Code%20point&quot;&gt;code point&lt;/a&gt; at the given index in this cluster.</source>
          <target state="translated">Obtiene un &lt;a href=&quot;#Code%20point&quot;&gt;punto de c&amp;oacute;digo&lt;/a&gt; en el &amp;iacute;ndice dado en este cl&amp;uacute;ster.</target>
        </trans-unit>
        <trans-unit id="3b7dd24ad864c772981b0d66dc0022feced1b999" translate="yes" xml:space="preserve">
          <source>Gets a larger buffer &lt;code&gt;buf&lt;/code&gt; by calling &lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt;. If &lt;code&gt;buf&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, returns &lt;code&gt;null&lt;/code&gt;. Otherwise, returns &lt;code&gt;buf[0 .. n]&lt;/code&gt;.</source>
          <target state="translated">Obtiene un b&amp;uacute;fer mayor &lt;code&gt;buf&lt;/code&gt; llamando &lt;code&gt;parent.allocate(goodAllocSize(n))&lt;/code&gt; . Si &lt;code&gt;buf&lt;/code&gt; es &lt;code&gt;null&lt;/code&gt; , devuelve &lt;code&gt;null&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;buf[0 .. n]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2c0f14712193b76cf9f29f4a2238a646ef9482c" translate="yes" xml:space="preserve">
          <source>Gets a range of key/values for &lt;code&gt;aa&lt;/code&gt;.</source>
          <target state="translated">Obtiene un rango de clave / valores para &lt;code&gt;aa&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f00eae4c2ff9337f7291213da97c9dc6aebf8d8" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo, which should be used as the default instance when info is requested for a thread not created by the Scheduler.</source>
          <target state="translated">Obtiene una instancia de hilo local de ThreadInfo,que debería utilizarse como instancia por defecto cuando se solicita información para un hilo no creado por el Programador.</target>
        </trans-unit>
        <trans-unit id="f6f18bccfb576e34d7b5fa60615448449996ea12" translate="yes" xml:space="preserve">
          <source>Gets a thread-local instance of ThreadInfo.</source>
          <target state="translated">Obtiene una instancia local de ThreadInfo.</target>
        </trans-unit>
        <trans-unit id="b472fcab365d2a6ba9fdba822432b62db948d127" translate="yes" xml:space="preserve">
          <source>Gets an object representing the reader lock for the associated mutex.</source>
          <target state="translated">Consigue un objeto que representa la cerradura del lector para el mutex asociado.</target>
        </trans-unit>
        <trans-unit id="2bad6a1697863b959c51608194a08c6aaf894ca4" translate="yes" xml:space="preserve">
          <source>Gets an object representing the writer lock for the associated mutex.</source>
          <target state="translated">Consigue un objeto que representa el candado de escritor para el mutex asociado.</target>
        </trans-unit>
        <trans-unit id="c2134c8e8821e26937fe2aedd4aa0e2891a164f8" translate="yes" xml:space="preserve">
          <source>Gets called on program shutdown just after GC is terminated.</source>
          <target state="translated">Se le llama al cierre del programa justo después de terminar el GC.</target>
        </trans-unit>
        <trans-unit id="3863a33d5ec162d09008cccc833b8dbca9f1864e" translate="yes" xml:space="preserve">
          <source>Gets called on program startup just before GC is initialized.</source>
          <target state="translated">Se le llama al inicio del programa justo antes de que se inicie el GC.</target>
        </trans-unit>
        <trans-unit id="fdc75e27ba04f67b552a395ef0dbfb72c8501519" translate="yes" xml:space="preserve">
          <source>Gets expression at offset of type. Returns NULL if not found.</source>
          <target state="translated">Obtiene la expresión en el offset de tipo.Devuelve NULL si no se encuentra.</target>
        </trans-unit>
        <trans-unit id="cc94d4edefc014f546538ff3e9cb05bec4999447" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;i&lt;/code&gt;'th bit in the &lt;code&gt;BitArray&lt;/code&gt;.</source>
          <target state="translated">Obtiene el &lt;code&gt;i&lt;/code&gt; 'th bit en el &lt;code&gt;BitArray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8011563ddbd748ff521930918dc8bcb499b269a2" translate="yes" xml:space="preserve">
          <source>Gets the OS identifier for this thread.</source>
          <target state="translated">Obtiene el identificador del sistema operativo para este hilo.</target>
        </trans-unit>
        <trans-unit id="685489f583759f962fe7c1daab0034a07cb9d516" translate="yes" xml:space="preserve">
          <source>Gets the Tid associated with name.</source>
          <target state="translated">Hace que la Tid se asocie con el nombre.</target>
        </trans-unit>
        <trans-unit id="5c6e15b07949cc6ff89428732b9e3b99b89bcdc8" translate="yes" xml:space="preserve">
          <source>Gets the current collect handler.</source>
          <target state="translated">Consigue el actual manejador de coleccionistas.</target>
        </trans-unit>
        <trans-unit id="4ee9c2ec9df011130e3394bc652f9b3e7978ed43" translate="yes" xml:space="preserve">
          <source>Gets the current legacy module unit tester.</source>
          <target state="translated">Consigue el actual probador de unidades de módulos heredados.</target>
        </trans-unit>
        <trans-unit id="b9fd850a635cce1ec806814a7cb5c442887ef8c8" translate="yes" xml:space="preserve">
          <source>Gets the current module unit tester.</source>
          <target state="translated">Consigue el comprobador de la unidad del módulo actual.</target>
        </trans-unit>
        <trans-unit id="e72b94a5c6c1c6b67ed9a2ba11a48dec6fb51fea" translate="yes" xml:space="preserve">
          <source>Gets the current state of this fiber.</source>
          <target state="translated">Obtiene el estado actual de esta fibra.</target>
        </trans-unit>
        <trans-unit id="86b54a37d38df76c69490341ad477a651e752312" translate="yes" xml:space="preserve">
          <source>Gets the current trace handler.</source>
          <target state="translated">Consigue el actual controlador de rastreo.</target>
        </trans-unit>
        <trans-unit id="48b50302326e46ace0f0f71974024ade98c4d812" translate="yes" xml:space="preserve">
          <source>Gets the daemon status for this thread. While the runtime will wait for all normal threads to complete before tearing down the process, daemon threads are effectively ignored and thus will not prevent the process from terminating. In effect, daemon threads will be terminated automatically by the OS when the process exits.</source>
          <target state="translated">Obtiene el estado de demonio para este hilo.Mientras que el tiempo de ejecución esperará a que todos los hilos normales se completen antes de interrumpir el proceso,los hilos de los demonios son efectivamente ignorados y por lo tanto no impedirán que el proceso termine.En efecto,los hilos del demonio serán terminados automáticamente por el sistema operativo cuando el proceso salga.</target>
        </trans-unit>
        <trans-unit id="6388b81675e677f57fc44bb674c4998dc61bbf09" translate="yes" xml:space="preserve">
          <source>Gets the index of the current thread relative to this &lt;code&gt;TaskPool&lt;/code&gt;. Any thread not in this pool will receive an index of 0. The worker threads in this pool receive unique indices of 1 through &lt;code&gt;this.size&lt;/code&gt;.</source>
          <target state="translated">Obtiene el &amp;iacute;ndice del subproceso actual en relaci&amp;oacute;n con este &lt;code&gt;TaskPool&lt;/code&gt; . Cualquier subproceso que no se encuentre en este grupo recibir&amp;aacute; un &amp;iacute;ndice de 0. Los subprocesos de trabajo en este grupo recibir&amp;aacute;n &amp;iacute;ndices &amp;uacute;nicos de 1 a trav&amp;eacute;s de &lt;code&gt;this.size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="397d4288bd9f56373ed42093b36baf0cf34c80d4" translate="yes" xml:space="preserve">
          <source>Gets the matching &lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;user-defined attributes&lt;/a&gt; from the given symbol.</source>
          <target state="translated">Obtiene los &lt;a href=&quot;https://dlang.org/spec/attribute.html#uda&quot;&gt;atributos&lt;/a&gt; coincidentes definidos por el usuario del s&amp;iacute;mbolo dado.</target>
        </trans-unit>
        <trans-unit id="ff4bb9618e0f172c3deb93f3fe4c73732cb67c80" translate="yes" xml:space="preserve">
          <source>Gets the mutex associated with this condition.</source>
          <target state="translated">Se asocia el mutex con esta condición.</target>
        </trans-unit>
        <trans-unit id="b1cafc8d1ad4c93a1519578fd6ef07cfbae8c0d4" translate="yes" xml:space="preserve">
          <source>Gets the nth number in the underlying representation that makes up the whole &lt;code&gt;BigInt&lt;/code&gt;.</source>
          <target state="translated">Obtiene el en&amp;eacute;simo n&amp;uacute;mero en la representaci&amp;oacute;n subyacente que constituye todo el &lt;code&gt;BigInt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="801e40683c25723cacc6326aca38101be95c4627" translate="yes" xml:space="preserve">
          <source>Gets the policy used by this mutex.</source>
          <target state="translated">Obtiene la política utilizada por este mutex.</target>
        </trans-unit>
        <trans-unit id="8aba27c226485427875db239e8c2e09071484ea6" translate="yes" xml:space="preserve">
          <source>Gets the scheduling priority for the associated thread.</source>
          <target state="translated">Tiene la prioridad de programación para el hilo asociado.</target>
        </trans-unit>
        <trans-unit id="cf58bd5c03eda3fe4cc7594124c4b61e9c109dc9" translate="yes" xml:space="preserve">
          <source>Gets the type of the &lt;code&gt;TypeInfo&lt;/code&gt; object associated with &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">Obtiene el tipo del objeto &lt;code&gt;TypeInfo&lt;/code&gt; asociado con &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9211b2fb8e24a472f1780790cfdc50455081852e" translate="yes" xml:space="preserve">
          <source>Gets the user-readable label for this thread.</source>
          <target state="translated">Tiene la etiqueta legible por el usuario para este hilo.</target>
        </trans-unit>
        <trans-unit id="611d2080794dfc9ee82363d9d9da4aa9a138b19f" translate="yes" xml:space="preserve">
          <source>Gets the value if not null. If &lt;code&gt;this&lt;/code&gt; is in the null state, and the optional parameter &lt;code&gt;fallback&lt;/code&gt; was provided, it will be returned. Without &lt;code&gt;fallback&lt;/code&gt;, calling &lt;code&gt;get&lt;/code&gt; with a null state is invalid.</source>
          <target state="translated">Obtiene el valor si no es nulo. Si &lt;code&gt;this&lt;/code&gt; est&amp;aacute; en el estado nulo, y el par&amp;aacute;metro opcional &lt;code&gt;fallback&lt;/code&gt; fue proporcionada, se le devolver&amp;aacute;. Sin &lt;code&gt;fallback&lt;/code&gt; , llamar a &lt;code&gt;get&lt;/code&gt; con un estado nulo no es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="7ce43e8e9e8874c455bc1d408b4db63789ae5ade" translate="yes" xml:space="preserve">
          <source>Gets the value. &lt;code&gt;this&lt;/code&gt; must not be in the null state. This function is also called for the implicit conversion to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Obtiene el valor. &lt;code&gt;this&lt;/code&gt; no debe estar en estado nulo. Esta funci&amp;oacute;n tambi&amp;eacute;n se llama a la conversi&amp;oacute;n impl&amp;iacute;cita a &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27ec2c5053941a53ff7bc20b3630c9aa87b310af" translate="yes" xml:space="preserve">
          <source>Gets vendor-specific type mangling for C++ ABI.</source>
          <target state="translated">Consigue un tipo de manipulación específico para el C++ABI.</target>
        </trans-unit>
        <trans-unit id="7e2612461374b070bc3713b89e3df4f4c33fbf6f" translate="yes" xml:space="preserve">
          <source>Gets/sets assert hander. null means the default handler is used.</source>
          <target state="translated">Gets/sets assert hander.null significa que se utiliza el handler por defecto.</target>
        </trans-unit>
        <trans-unit id="8a46199cc00d346a1fe72a372a1bcb52b3b1947f" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current process. This allocator must be used for allocating memory shared across threads. Objects created using this allocator can be cast to &lt;code&gt;shared&lt;/code&gt;.</source>
          <target state="translated">Obtiene / establece el asignador para el proceso actual. Este asignador debe usarse para asignar memoria compartida entre subprocesos. Los objetos creados con este asignador se pueden convertir en &lt;code&gt;shared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3f3fc74fb3ec91a1abfd15e2f2178014ba02b91" translate="yes" xml:space="preserve">
          <source>Gets/sets the allocator for the current thread. This is the default allocator that should be used for allocating thread-local memory. For allocating memory to be shared across threads, use &lt;code&gt;processAllocator&lt;/code&gt; (below). By default, &lt;code&gt;theAllocator&lt;/code&gt; ultimately fetches memory from &lt;code&gt;processAllocator&lt;/code&gt;, which in turn uses the garbage collected heap.</source>
          <target state="translated">Obtiene / establece el asignador para el subproceso actual. Este es el asignador predeterminado que debe usarse para asignar memoria local de subprocesos. Para asignar memoria para compartir entre hilos, use &lt;code&gt;processAllocator&lt;/code&gt; (a continuaci&amp;oacute;n). De forma predeterminada, el &lt;code&gt;theAllocator&lt;/code&gt; finalmente recupera la memoria del proceso &lt;code&gt;processAllocator&lt;/code&gt; , que a su vez utiliza el mont&amp;oacute;n de basura recolectada.</target>
        </trans-unit>
        <trans-unit id="ce0e5e384b0423d01fbe02461b7f604937af05a9" translate="yes" xml:space="preserve">
          <source>Getting a range of all the named captures in the regex.</source>
          <target state="translated">Obteniendo un rango de todas las capturas nombradas en el regex.</target>
        </trans-unit>
        <trans-unit id="3239f451b140324af46d3a3db896ec8a5a618fbd" translate="yes" xml:space="preserve">
          <source>Getting the benefits of multiple adaptable freelists that do not need to be tuned for one specific size but insted automatically adapts itself to frequently used sizes.</source>
          <target state="translated">Obteniendo los beneficios de múltiples listas adaptables que no necesitan ser ajustadas para un tamaño específico,sino que se adaptan automáticamente a los tamaños más utilizados.</target>
        </trans-unit>
        <trans-unit id="c7ae27f036579182bace286ba1e0cf636e5ff36f" translate="yes" xml:space="preserve">
          <source>Getting the priority of a thread that already terminated might return the default priority.</source>
          <target state="translated">Obtener la prioridad de un hilo que ya ha terminado podría devolver la prioridad por defecto.</target>
        </trans-unit>
        <trans-unit id="d5546b9dfb555ac771be9469163d9af49686adbe" translate="yes" xml:space="preserve">
          <source>Give error if we're not an lvalue. If we can, convert expression to be an lvalue.</source>
          <target state="translated">Da error si no somos un valor.Si podemos,convertir la expresión en un valor &quot;l&quot;.</target>
        </trans-unit>
        <trans-unit id="74474e23aa26985e7a98ca671962a908920e33b2" translate="yes" xml:space="preserve">
          <source>Give up.</source>
          <target state="translated">Ríndete.</target>
        </trans-unit>
        <trans-unit id="6839d82e03f5268d9a7cc97802db76c48c8cce6e" translate="yes" xml:space="preserve">
          <source>Given</source>
          <target state="translated">Given</target>
        </trans-unit>
        <trans-unit id="545c45c89bb40c5d7b7b442770eb2c94a5c06899" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a == b&lt;/code&gt; :</source>
          <target state="translated">Dado &lt;code&gt;a == b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="53726705da0088ae9fbab83c8c50c091febc70d1" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;flags&lt;/code&gt; as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values, or a type &lt;code&gt;T&lt;/code&gt;, returns the allocator that's a closest fit in capabilities.</source>
          <target state="translated">Dada &lt;code&gt;flags&lt;/code&gt; como una combinaci&amp;oacute;n de &lt;code&gt;AllocFlag&lt;/code&gt; valores, o un tipo &lt;code&gt;T&lt;/code&gt; , devuelve el asignador que es un ajuste m&amp;aacute;s cercano en capacidades.</target>
        </trans-unit>
        <trans-unit id="62b1bd97df8e740424d65deb5d1e60e2802ffce0" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;index&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt; and assuming that &lt;code&gt;index&lt;/code&gt; is at the start of a UTF sequence, &lt;code&gt;toUCSindex&lt;/code&gt; determines the number of UCS characters up to &lt;code&gt;index&lt;/code&gt;. So, &lt;code&gt;index&lt;/code&gt; is the index of a code unit at the beginning of a code point, and the return value is how many code points into the string that that code point is.</source>
          <target state="translated">Dado el &lt;code&gt;index&lt;/code&gt; en &lt;code&gt;str&lt;/code&gt; y suponiendo que el &lt;code&gt;index&lt;/code&gt; encuentra al comienzo de una secuencia UTF, &lt;code&gt;toUCSindex&lt;/code&gt; determina el n&amp;uacute;mero de caracteres UCS hasta el &lt;code&gt;index&lt;/code&gt; . Entonces, el &lt;code&gt;index&lt;/code&gt; es el &amp;iacute;ndice de una unidad de c&amp;oacute;digo al comienzo de un punto de c&amp;oacute;digo, y el valor de retorno es cu&amp;aacute;ntos puntos de c&amp;oacute;digo en la cadena es ese punto de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="bb7cf3072f3bd953aeae94de343ed5c6b8a94867" translate="yes" xml:space="preserve">
          <source>Given D code like:</source>
          <target state="translated">Dado el código D como:</target>
        </trans-unit>
        <trans-unit id="d736ecdf41cd9fce2597d330cc34519b6b941a39" translate="yes" xml:space="preserve">
          <source>Given EBP, find return address to caller, and caller's EBP.</source>
          <target state="translated">Dada la PEB,busca la dirección del remitente y la PEB de la persona que llama.</target>
        </trans-unit>
        <trans-unit id="eb6400b34d9067d59b3f43922d46e893c8d36002" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;source&lt;/code&gt; range that is expensive to iterate over, returns an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt; that asynchronously buffers the contents of &lt;code&gt;source&lt;/code&gt; into a buffer of &lt;code&gt;bufSize&lt;/code&gt; elements in a worker thread, while making previously buffered elements from a second buffer, also of size &lt;code&gt;bufSize&lt;/code&gt;, available via the range interface of the returned object. The returned range has a length iff &lt;code&gt;hasLength!S&lt;/code&gt;. &lt;code&gt;asyncBuf&lt;/code&gt; is useful, for example, when performing expensive operations on the elements of ranges that represent data on a disk or network.</source>
          <target state="translated">Dado un rango de &lt;code&gt;source&lt;/code&gt; que es costoso iterar, devuelve un &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;rango de entrada&lt;/a&gt; que almacena de forma as&amp;iacute;ncrona el contenido de la &lt;code&gt;source&lt;/code&gt; en un b&amp;uacute;fer de elementos &lt;code&gt;bufSize&lt;/code&gt; en un subproceso de trabajo, mientras que hace que los elementos previamente almacenados en un segundo b&amp;uacute;fer, tambi&amp;eacute;n de tama&amp;ntilde;o &lt;code&gt;bufSize&lt;/code&gt; , est&amp;eacute;n disponibles a trav&amp;eacute;s de La interfaz de rango del objeto devuelto. La gama devuelto si y s&amp;oacute;lo si tiene una longitud &lt;code&gt;hasLength!S&lt;/code&gt; . &lt;code&gt;asyncBuf&lt;/code&gt; es &amp;uacute;til, por ejemplo, cuando se realizan operaciones costosas en los elementos de rangos que representan datos en un disco o red.</target>
        </trans-unit>
        <trans-unit id="699c74248abd14b4250ad690ede845e5aad24631" translate="yes" xml:space="preserve">
          <source>Given a Base64 encoded string, calculates the length of the decoded string.</source>
          <target state="translated">Dada una cadena codificada en Base64,calcula la longitud de la cadena decodificada.</target>
        </trans-unit>
        <trans-unit id="bc7d61e132762100a6e8861609dacf0581eebca4" translate="yes" xml:space="preserve">
          <source>Given a C++ function in a C++ source file:</source>
          <target state="translated">Dada una función C++en un archivo fuente C++:</target>
        </trans-unit>
        <trans-unit id="7de884353daa1d02f969775316b89c9805864eba" translate="yes" xml:space="preserve">
          <source>Given a UCS index &lt;code&gt;n&lt;/code&gt; into &lt;code&gt;str&lt;/code&gt;, returns the UTF index. So, &lt;code&gt;n&lt;/code&gt; is how many code points into the string the code point is, and the array index of the code unit is returned.</source>
          <target state="translated">Dado un &amp;iacute;ndice UCS &lt;code&gt;n&lt;/code&gt; en &lt;code&gt;str&lt;/code&gt; , devuelve el &amp;iacute;ndice UTF. Entonces, &lt;code&gt;n&lt;/code&gt; es cu&amp;aacute;ntos puntos de c&amp;oacute;digo en la cadena es el punto de c&amp;oacute;digo, y se devuelve el &amp;iacute;ndice de matriz de la unidad de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="3aa76f9d8ead49fe4c4634dcc93f9d715d5abf9c" translate="yes" xml:space="preserve">
          <source>Given a and p, the function finds x such that</source>
          <target state="translated">Dada a y p,la función encuentra x tal que</target>
        </trans-unit>
        <trans-unit id="97696594fbe0457c99be87ef93b37c947e4a5703" translate="yes" xml:space="preserve">
          <source>Given a callable object &lt;code&gt;next&lt;/code&gt; that writes to a user-provided buffer and a second callable object &lt;code&gt;empty&lt;/code&gt; that determines whether more data is available to write via &lt;code&gt;next&lt;/code&gt;, returns an input range that asynchronously calls &lt;code&gt;next&lt;/code&gt; with a set of size &lt;code&gt;nBuffers&lt;/code&gt; of buffers and makes the results available in the order they were obtained via the input range interface of the returned object. Similarly to the input range overload of &lt;code&gt;asyncBuf&lt;/code&gt;, the first half of the buffers are made available via the range interface while the second half are filled and vice-versa.</source>
          <target state="translated">Dado un &lt;code&gt;next&lt;/code&gt; objeto invocable que escribe en un b&amp;uacute;fer proporcionado por el usuario y un segundo objeto invocable &lt;code&gt;empty&lt;/code&gt; que determina si hay m&amp;aacute;s datos disponibles para escribir a trav&amp;eacute;s de &lt;code&gt;next&lt;/code&gt; , devuelve un rango de entrada que invoca asincr&amp;oacute;nicamente a &lt;code&gt;next&lt;/code&gt; con un conjunto de tama&amp;ntilde;o &lt;code&gt;nBuffers&lt;/code&gt; de buffers y hace que Los resultados disponibles en el orden en que se obtuvieron a trav&amp;eacute;s de la interfaz de rango de entrada del objeto devuelto. De manera similar a la sobrecarga del rango de entrada de &lt;code&gt;asyncBuf&lt;/code&gt; , la primera mitad de los buffers est&amp;aacute;n disponibles a trav&amp;eacute;s de la interfaz de rango, mientras que la segunda mitad se llena y viceversa.</target>
        </trans-unit>
        <trans-unit id="f4bc9912c00cf7ade5e6f59f3c7bafa79a0098bb" translate="yes" xml:space="preserve">
          <source>Given a function &lt;code&gt;f&lt;/code&gt; and a range &lt;code&gt;[a .. b]&lt;/code&gt; such that &lt;code&gt;f(a)&lt;/code&gt; and &lt;code&gt;f(b)&lt;/code&gt; have opposite signs or at least one of them equals &amp;plusmn;0, returns the value of &lt;code&gt;x&lt;/code&gt; in the range which is closest to a root of &lt;code&gt;f(x)&lt;/code&gt;. If &lt;code&gt;f(x)&lt;/code&gt; has more than one root in the range, one will be chosen arbitrarily. If &lt;code&gt;f(x)&lt;/code&gt; returns NaN, NaN will be returned; otherwise, this algorithm is guaranteed to succeed.</source>
          <target state="translated">Dada una funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; y una gama &lt;code&gt;[a .. b]&lt;/code&gt; tal que &lt;code&gt;f(a)&lt;/code&gt; y &lt;code&gt;f(b)&lt;/code&gt; tienen signos opuestos, o al menos uno de ellos es igual a &amp;plusmn; 0, devuelve el valor de &lt;code&gt;x&lt;/code&gt; en el intervalo que es m&amp;aacute;s cercano a una ra&amp;iacute;z de &lt;code&gt;f(x)&lt;/code&gt; . Si &lt;code&gt;f(x)&lt;/code&gt; tiene m&amp;aacute;s de una ra&amp;iacute;z en el rango, se elegir&amp;aacute; una arbitrariamente. Si &lt;code&gt;f(x)&lt;/code&gt; devuelve NaN, se devolver&amp;aacute; NaN; de lo contrario, este algoritmo est&amp;aacute; garantizado para tener &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="b3d905355b0b0e68c40d2c94bafa678611e3caae" translate="yes" xml:space="preserve">
          <source>Given a new instance tithis of this TemplateDeclaration, see if there already exists an instance. If so, return that existing instance.</source>
          <target state="translated">Dada una nueva instancia diezmada de esta PlantillaDeclaración,ver si ya existe una instancia.Si es así,devuelva esa instancia existente.</target>
        </trans-unit>
        <trans-unit id="7902cf88ea3243b9d5f9eb153e89c6c4585563c1" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as &lt;code&gt;T&lt;/code&gt;), constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to null.</source>
          <target state="translated">Dado un &lt;code&gt;chunk&lt;/code&gt; puntero a memoria no inicializada (pero ya escrita como &lt;code&gt;T&lt;/code&gt; ), construye un objeto de tipo &lt;code&gt;T&lt;/code&gt; que no es de &lt;code&gt;class&lt;/code&gt; en esa direcci&amp;oacute;n. Si &lt;code&gt;T&lt;/code&gt; es una clase, inicializa la referencia de clase a nulo.</target>
        </trans-unit>
        <trans-unit id="abaa134bbbf8060e8ac6344879f8e8d611739ebe" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;.</source>
          <target state="translated">Dado un &lt;code&gt;chunk&lt;/code&gt; puntero a la memoria no inicializada (pero ya escrita como un tipo &lt;code&gt;T&lt;/code&gt; que no es de clase ), construye un objeto de tipo &lt;code&gt;T&lt;/code&gt; en esa direcci&amp;oacute;n a partir de argumentos &lt;code&gt;args&lt;/code&gt; . Si &lt;code&gt;T&lt;/code&gt; es una clase, inicializa la referencia de clase a &lt;code&gt;args[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58557c048614c0f1ce20fdb67b5db3ba6bf2d1b4" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;chunk&lt;/code&gt; to uninitialized memory (but already typed as a non-class type &lt;code&gt;T&lt;/code&gt;), constructs an object of type &lt;code&gt;T&lt;/code&gt; at that address from arguments &lt;code&gt;args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is a class, initializes the class reference to &lt;code&gt;args[0]&lt;/code&gt;. This function can be &lt;code&gt;@trusted&lt;/code&gt; if the corresponding constructor of &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;@safe&lt;/code&gt;.</source>
          <target state="translated">Dado un &lt;code&gt;chunk&lt;/code&gt; puntero a la memoria no inicializada (pero ya escrita como un tipo &lt;code&gt;T&lt;/code&gt; que no es de clase ), construye un objeto de tipo &lt;code&gt;T&lt;/code&gt; en esa direcci&amp;oacute;n a partir de argumentos &lt;code&gt;args&lt;/code&gt; . Si &lt;code&gt;T&lt;/code&gt; es una clase, inicializa la referencia de clase a &lt;code&gt;args[0]&lt;/code&gt; . Se puede &lt;code&gt;@trusted&lt;/code&gt; esta funci&amp;oacute;n si el constructor correspondiente de &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;@safe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18ffdf892cf328d6d063a845b68a6520844d64c2" translate="yes" xml:space="preserve">
          <source>Given a pointer: If it is an Object, return that Object. If it is an interface, return the Object implementing the interface. If it is null, return null. Else, undefined crash</source>
          <target state="translated">Dando un puntero:Si es un objeto,devuelve ese objeto.Si es una interfaz,devuelve el objeto que implementa la interfaz.Si es nulo,devuelva nulo.Si no,choque indefinido</target>
        </trans-unit>
        <trans-unit id="a2a17bffc5b9d113dc0183d4777b121f1563c333" translate="yes" xml:space="preserve">
          <source>Given a random-access range and a starting point, creates a range that alternately returns the next left and next right element to the starting point.</source>
          <target state="translated">Dado un rango de acceso aleatorio y un punto de partida,crea un rango que alternativamente devuelve el siguiente elemento izquierdo y el siguiente elemento derecho al punto de partida.</target>
        </trans-unit>
        <trans-unit id="cf77f4783176c69f24bf5139063bed48dbcdbc05" translate="yes" xml:space="preserve">
          <source>Given a range of elements, constructs an index of its top</source>
          <target state="translated">Dada una gama de elementos,construye un índice de su parte superior</target>
        </trans-unit>
        <trans-unit id="f82f27390a9cc6295ef9d3e2c499d003645adbcb" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the &lt;code&gt;n&lt;/code&gt;th element of each of the enclosed ranges. This function is similar to &lt;code&gt;unzip&lt;/code&gt; in other languages.</source>
          <target state="translated">Dada una serie de rangos, iterate transversalmente a trav&amp;eacute;s de la &lt;code&gt;n&lt;/code&gt; -&amp;eacute;simo elemento de cada uno de los intervalos cerrados. Esta funci&amp;oacute;n es similar a &lt;code&gt;unzip&lt;/code&gt; en otros idiomas.</target>
        </trans-unit>
        <trans-unit id="99d831c39b761ba6173d077a392b684dab424593" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, iterate transversally through the first elements of each of the enclosed ranges.</source>
          <target state="translated">Dada una gama de alcances,itera transversalmente a través de los primeros elementos de cada uno de los alcances cerrados.</target>
        </trans-unit>
        <trans-unit id="76deeb26e0b9b94a659a1c8d77489812eb190823" translate="yes" xml:space="preserve">
          <source>Given a range of ranges, returns a range of ranges where the</source>
          <target state="translated">Dado un rango de rangos,devuelve un rango de rangos donde el</target>
        </trans-unit>
        <trans-unit id="23b1b22050fe1a6a85e37baec0da8ef5a908711a" translate="yes" xml:space="preserve">
          <source>Given a range of sorted &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward ranges&lt;/a&gt;&lt;code&gt;ror&lt;/code&gt;, copies to &lt;code&gt;tgt&lt;/code&gt; the elements that are common to most ranges, along with their number of occurrences. All ranges in &lt;code&gt;ror&lt;/code&gt; are assumed to be sorted by &lt;code&gt;less&lt;/code&gt;. Only the most frequent &lt;code&gt;tgt.length&lt;/code&gt; elements are returned.</source>
          <target state="translated">Teniendo en cuenta una serie de ordenados &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rangos de avance &lt;/a&gt; &lt;code&gt;ror&lt;/code&gt; , copias a &lt;code&gt;tgt&lt;/code&gt; los elementos que son comunes a la mayor&amp;iacute;a de los rangos, junto con su n&amp;uacute;mero de ocurrencias. Se supone que todos los rangos en &lt;code&gt;ror&lt;/code&gt; se ordenan por &lt;code&gt;less&lt;/code&gt; . Solo se &lt;code&gt;tgt.length&lt;/code&gt; elementos tgt.length m&amp;aacute;s frecuentes .</target>
        </trans-unit>
        <trans-unit id="6cadfddfad656a52536264d1af9f3900d194ed5c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">Dado un &lt;code&gt;chunk&lt;/code&gt; &amp;aacute;rea de memoria sin procesar (pero ya escrito como una clase tipo &lt;code&gt;T&lt;/code&gt; ), construye un objeto de &lt;code&gt;class&lt;/code&gt; tipo &lt;code&gt;T&lt;/code&gt; en esa direcci&amp;oacute;n. Al constructor se le pasan los argumentos &lt;code&gt;Args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adbee075f1252282f1c423c0af02edd4265ab66b" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt; (but already typed as a class type &lt;code&gt;T&lt;/code&gt;), constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">Dado un &lt;code&gt;chunk&lt;/code&gt; &amp;aacute;rea de memoria sin procesar (pero ya escrito como una clase tipo &lt;code&gt;T&lt;/code&gt; ), construye un objeto de &lt;code&gt;class&lt;/code&gt; tipo &lt;code&gt;T&lt;/code&gt; en esa direcci&amp;oacute;n. Al constructor se le pasan los argumentos &lt;code&gt;Args&lt;/code&gt; . Si &lt;code&gt;T&lt;/code&gt; es una clase interna cuyo campo &lt;code&gt;outer&lt;/code&gt; se puede usar para acceder a una instancia de la clase que lo encierra, entonces &lt;code&gt;Args&lt;/code&gt; no debe estar vac&amp;iacute;o, y el primer miembro debe ser un inicializador v&amp;aacute;lido para ese campo &lt;code&gt;outer&lt;/code&gt; . La inicializaci&amp;oacute;n correcta de este campo es esencial para acceder a los miembros de la clase externa dentro de &lt;code&gt;T&lt;/code&gt; m&amp;eacute;todos T.</target>
        </trans-unit>
        <trans-unit id="0653a1ab81721bb4c49575b0fcabecb4d629612a" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;.</source>
          <target state="translated">Dado un &lt;code&gt;chunk&lt;/code&gt; &amp;aacute;rea de memoria sin formato , construye un objeto de &lt;code&gt;class&lt;/code&gt; tipo &lt;code&gt;T&lt;/code&gt; en esa direcci&amp;oacute;n. Al constructor se le pasan los argumentos &lt;code&gt;Args&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74cf19c0277fb6a57dd8ab3cb630a33bfe4fee0c" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of &lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;Args&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">Dado un &lt;code&gt;chunk&lt;/code&gt; &amp;aacute;rea de memoria sin formato , construye un objeto de &lt;code&gt;class&lt;/code&gt; tipo &lt;code&gt;T&lt;/code&gt; en esa direcci&amp;oacute;n. Al constructor se le pasan los argumentos &lt;code&gt;Args&lt;/code&gt; . Si &lt;code&gt;T&lt;/code&gt; es una clase interna cuyo campo &lt;code&gt;outer&lt;/code&gt; se puede usar para acceder a una instancia de la clase que lo encierra, entonces &lt;code&gt;Args&lt;/code&gt; no debe estar vac&amp;iacute;o, y el primer miembro debe ser un inicializador v&amp;aacute;lido para ese campo &lt;code&gt;outer&lt;/code&gt; . La inicializaci&amp;oacute;n correcta de este campo es esencial para acceder a los miembros de la clase externa dentro de &lt;code&gt;T&lt;/code&gt; m&amp;eacute;todos T.</target>
        </trans-unit>
        <trans-unit id="e137ad6b52d9b560e6ecf089479316e86462ce01" translate="yes" xml:space="preserve">
          <source>Given a raw memory area &lt;code&gt;chunk&lt;/code&gt;, constructs an object of non-&lt;code&gt;class&lt;/code&gt; type &lt;code&gt;T&lt;/code&gt; at that address. The constructor is passed the arguments &lt;code&gt;args&lt;/code&gt;, if any.</source>
          <target state="translated">Dado un &lt;code&gt;chunk&lt;/code&gt; &amp;aacute;rea de memoria sin formato , construye un objeto de tipo &lt;code&gt;T&lt;/code&gt; que no es de &lt;code&gt;class&lt;/code&gt; en esa direcci&amp;oacute;n. Al constructor se le pasan los argumentos &lt;code&gt;args&lt;/code&gt; , si los hay.</target>
        </trans-unit>
        <trans-unit id="f8745e4f392d96921746aba6d016d8b75a3eaf5b" translate="yes" xml:space="preserve">
          <source>Given a symbol that could be either a FuncDeclaration or a function template, resolve it to a function symbol.</source>
          <target state="translated">Si se le da un símbolo que puede ser una FuncDeclaración o una plantilla de función,resuélvalo a un símbolo de función.</target>
        </trans-unit>
        <trans-unit id="3ec7e3b2070dd15d8c86e7da24a716e09d94b001" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;S&lt;/code&gt; that is one of:</source>
          <target state="translated">Dado un tipo &lt;code&gt;S&lt;/code&gt; que es uno de:</target>
        </trans-unit>
        <trans-unit id="5bf486ff307c1ac9da00abda18e996a0151d6f51" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, returns its allocation-related flags as a combination of &lt;code&gt;AllocFlag&lt;/code&gt; values.</source>
          <target state="translated">Dado un tipo &lt;code&gt;T&lt;/code&gt; , devuelve sus indicadores relacionados con la asignaci&amp;oacute;n como una combinaci&amp;oacute;n de valores de &lt;code&gt;AllocFlag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ec656f1b47e3a570669cfd79e664b45a8112e7a" translate="yes" xml:space="preserve">
          <source>Given address that is inside a function, figure out which function it is in. Return DHandlerTable if there is one, NULL if not.</source>
          <target state="translated">Dada la dirección que está dentro de una función,averigüe en qué función está.Devuelve DHandlerTable si hay una,NULL si no.</target>
        </trans-unit>
        <trans-unit id="84fb4bae252188c74a52ee250ba7895934a71e72" translate="yes" xml:space="preserve">
          <source>Given an &lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;object factory&lt;/a&gt; of type &lt;code&gt;Factory&lt;/code&gt; or a factory function &lt;code&gt;factoryFunction&lt;/code&gt;, and optionally also &lt;code&gt;BookkeepingAllocator&lt;/code&gt; as a supplemental allocator for bookkeeping, &lt;code&gt;AllocatorList&lt;/code&gt; creates an allocator that lazily creates as many allocators are needed for satisfying client allocation requests.</source>
          <target state="translated">Dada una &lt;a href=&quot;https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)&quot;&gt;f&amp;aacute;brica&lt;/a&gt; de objetos de tipo &lt;code&gt;Factory&lt;/code&gt; o una funci&amp;oacute;n de f&amp;aacute;brica &lt;code&gt;factoryFunction&lt;/code&gt; , y opcionalmente tambi&amp;eacute;n &lt;code&gt;BookkeepingAllocator&lt;/code&gt; como asignador suplementario para la contabilidad, &lt;code&gt;AllocatorList&lt;/code&gt; crea un asignador que crea perezosamente tantos asignadores necesarios para satisfacer las solicitudes de asignaci&amp;oacute;n de clientes.</target>
        </trans-unit>
        <trans-unit id="2c2ffbad9b196900545a99b58a4a8084fb8e968f" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;AssignExp&lt;/code&gt;, determine if the lvalue will cause the contents of the rvalue to escape. Print error messages when these are detected. Infer &lt;code&gt;scope&lt;/code&gt; attribute for the lvalue where possible, in order to eliminate the error.</source>
          <target state="translated">Dado un &lt;code&gt;AssignExp&lt;/code&gt; , determine si lvalue har&amp;aacute; que el contenido del rvalue se escape. Imprime mensajes de error cuando se detectan. Inferir atributo de &lt;code&gt;scope&lt;/code&gt; para el valor de l cuando sea posible, para eliminar el error.</target>
        </trans-unit>
        <trans-unit id="f4edc9674fd3041f4bd8fcdf8c36704d26537a1f" translate="yes" xml:space="preserve">
          <source>Given an Expression, find the variable it really is.</source>
          <target state="translated">Dada una Expresión,encuentra la variable que realmente es.</target>
        </trans-unit>
        <trans-unit id="10135b6f779b47ff66661cf2060528825cdb0465" translate="yes" xml:space="preserve">
          <source>Given an allocator factory, lazily creates as many allocators as needed to satisfy allocation requests. The allocators are stored in a linked list. Requests for allocation are satisfied by searching the list in a linear manner.</source>
          <target state="translated">Dada una fábrica de asignadores,perezosamente crea tantos asignadores como sean necesarios para satisfacer las solicitudes de asignación.Los asignadores se almacenan en una lista vinculada.Las solicitudes de asignación se satisfacen buscando en la lista de manera lineal.</target>
        </trans-unit>
        <trans-unit id="c68fd4e0d6a4caa1cbbef6c7b7cc84e1b16b2800" translate="yes" xml:space="preserve">
          <source>Given an error instantiating the TemplateInstance, give the nested TemplateInstance instantiations that got us here. Those are a list threaded into the nested scopes.</source>
          <target state="translated">Dado un error en la instanciación de la TemplateInstance,déle a la TemplateInstance anidada las instancias que nos trajeron aquí.Esas son una lista enhebrada en los alcances anidados.</target>
        </trans-unit>
        <trans-unit id="0d192178ddf2961ae655bd11083f31d24b553ec6" translate="yes" xml:space="preserve">
          <source>Given an expression e that is an array, determine and set the 'length' variable.</source>
          <target state="translated">Dada una expresión e que es una matriz,determinar y establecer la variable &quot;longitud&quot;.</target>
        </trans-unit>
        <trans-unit id="13b4b240c1888ba281f7a8d067f704fc09eba179" translate="yes" xml:space="preserve">
          <source>Given array literal oldval of type ArrayLiteralExp or StringExp, of length oldlen, change its length to newlen. If the newlen is longer than oldlen, all new elements will be set to the default initializer for the element type.</source>
          <target state="translated">Dada la matriz literal oldval del tipo ArrayLiteralExp o StringExp,de longitud oldlen,cambia su longitud a newlen.Si el newlen es más largo que el oldlen,todos los nuevos elementos se ajustarán al inicializador por defecto para el tipo de elemento.</target>
        </trans-unit>
        <trans-unit id="4fe6c27981ac387048ac652b298a3c233afd1136" translate="yes" xml:space="preserve">
          <source>Given array of foreach parameters and an aggregate type, find best opApply overload, if any of the parameter types are missing, attempt to infer them from the aggregate type.</source>
          <target state="translated">Dada la variedad de parámetros de frente y un tipo de agregado,encuentre la mejor sobrecarga de opApply,si falta alguno de los tipos de parámetros,intente inferirlos a partir del tipo de agregado.</target>
        </trans-unit>
        <trans-unit id="548081a2237345a0383114c21603c8b8dab1f303" translate="yes" xml:space="preserve">
          <source>Given callable (&lt;a href=&quot;std_traits#isCallable&quot;&gt;&lt;code&gt;std.traits.isCallable&lt;/code&gt;&lt;/a&gt;) &lt;code&gt;fun&lt;/code&gt;, create as a range whose front is defined by successive calls to &lt;code&gt;fun()&lt;/code&gt;. This is especially useful to call function with global side effects (random functions), or to create ranges expressed as a single delegate, rather than an entire &lt;code&gt;front&lt;/code&gt;/&lt;code&gt;popFront&lt;/code&gt;/&lt;code&gt;empty&lt;/code&gt; structure. &lt;code&gt;fun&lt;/code&gt; maybe be passed either a template alias parameter (existing function, delegate, struct type defining &lt;code&gt;static opCall&lt;/code&gt;) or a run-time value argument (delegate, function object). The result range models an InputRange (&lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;&lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt;&lt;/a&gt;). The resulting range will call &lt;code&gt;fun()&lt;/code&gt; on construction, and every call to &lt;code&gt;popFront&lt;/code&gt;, and the cached value will be returned when &lt;code&gt;front&lt;/code&gt; is called.</source>
          <target state="translated">Dada la &lt;code&gt;fun&lt;/code&gt; invocable ( &lt;a href=&quot;std_traits#isCallable&quot;&gt; &lt;code&gt;std.traits.isCallable&lt;/code&gt; &lt;/a&gt; ) , cree como un rango cuyo frente se define mediante llamadas sucesivas a &lt;code&gt;fun()&lt;/code&gt; . Esto es especialmente &amp;uacute;til para llamar a la funci&amp;oacute;n con efectos secundarios globales (funciones aleatorias), o para crear rangos expresados ​​como un delegado &amp;uacute;nico, en lugar de una estructura &lt;code&gt;front&lt;/code&gt; al / &lt;code&gt;popFront&lt;/code&gt; / &lt;code&gt;empty&lt;/code&gt; . &lt;code&gt;fun&lt;/code&gt; puede pasarse ya sea un par&amp;aacute;metro de alias de plantilla (funci&amp;oacute;n existente, delegado, tipo de estructura que define &lt;code&gt;static opCall&lt;/code&gt; ) o un argumento de valor de tiempo de ejecuci&amp;oacute;n (delegado, objeto de funci&amp;oacute;n). El rango de resultados modela un InputRange ( &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt; &lt;code&gt;std.range.primitives.isInputRange&lt;/code&gt; &lt;/a&gt; ). El rango resultante llamar&amp;aacute; a &lt;code&gt;fun()&lt;/code&gt; en construcci&amp;oacute;n, y cada llamada a &lt;code&gt;popFront&lt;/code&gt; , y el valor almacenado en cach&amp;eacute; se devolver&amp;aacute; cuando se llame a &lt;code&gt;front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6cdf45c5874188e502ef446c2f299954ad8e06e" translate="yes" xml:space="preserve">
          <source>Given function arguments, figure out which template function to expand, and return matching result.</source>
          <target state="translated">Dados los argumentos de la función,averigüe qué función de la plantilla debe expandirse y devuelva el resultado de la coincidencia.</target>
        </trans-unit>
        <trans-unit id="2c41e0d5b6e5292f4394dbada3bf0e11b9965e54" translate="yes" xml:space="preserve">
          <source>Given that it is only called with &lt;a href=&quot;#safe-values&quot;&gt;safe values&lt;/a&gt; and &lt;a href=&quot;#safe-aliasing&quot;&gt;safe aliasing&lt;/a&gt;, a function has a safe interface when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c0666f9da353f9c6f10f1cf5edecb5189140bb" translate="yes" xml:space="preserve">
          <source>Given that the most frequent use of &lt;code&gt;InSituRegion&lt;/code&gt; is as a stack allocator, it allocates starting at the end on systems where stack grows downwards, such that hot memory is used first.</source>
          <target state="translated">Dado que el uso m&amp;aacute;s frecuente de &lt;code&gt;InSituRegion&lt;/code&gt; es como un asignador de pila, se asigna comenzando desde el final en sistemas donde la pila crece hacia abajo, de modo que la memoria activa se usa primero.</target>
        </trans-unit>
        <trans-unit id="433dfce23255598b88ff3eee832e615faf6acb1f" translate="yes" xml:space="preserve">
          <source>Given that ti is an instance of this TemplateDeclaration, deduce the types of the parameters to this, and store those deduced types in dedtypes[].</source>
          <target state="translated">Dado que ti es una instancia de esta TemplateDeclaration,deduzca los tipos de los parámetros a esto,y almacene esos tipos deducidos en los dedtipos[].</target>
        </trans-unit>
        <trans-unit id="de6b7e538358277d4d77d0a6dfdd22d328ebcdc2" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such log(x) - digamma(x) = y.</source>
          <target state="translated">Dada y,la función encuentra x tal log(x)-digamma(x)=y.</target>
        </trans-unit>
        <trans-unit id="992b94a2b2bacb1095a0b111a75eb520df8ea274" translate="yes" xml:space="preserve">
          <source>Given y, the function finds x such that</source>
          <target state="translated">Dada y,la función encuentra x de tal manera que</target>
        </trans-unit>
        <trans-unit id="b5ce07b779103b2800f63623f7d95755262b29ac" translate="yes" xml:space="preserve">
          <source>Gives a hint to the processor that the calling thread is in a 'spin-wait' loop, allowing to more efficiently allocate resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6d6838e980e7d735fe427a6cf2d72e4e8647a21" translate="yes" xml:space="preserve">
          <source>Gives a string containing all of the member variables on their own line.</source>
          <target state="translated">Da una cadena que contiene todas las variables de los miembros en su propia línea.</target>
        </trans-unit>
        <trans-unit id="7913f0379d403503a25672003418cf5f3eca8630" translate="yes" xml:space="preserve">
          <source>Gives a string in the form of &lt;code&gt;Appender!(A)(data)&lt;/code&gt;.</source>
          <target state="translated">Da una cadena en forma de &lt;code&gt;Appender!(A)(data)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8ea4a4989f9ed3007485f30bc4c477cf8cf78af" translate="yes" xml:space="preserve">
          <source>Gives a template that can be used to apply the same attributes that are on the given type &lt;code&gt;T&lt;/code&gt;. E.g. passing &lt;code&gt;inout shared int&lt;/code&gt; will return &lt;code&gt;SharedInoutOf&lt;/code&gt;.</source>
          <target state="translated">Da una plantilla que se puede usar para aplicar los mismos atributos que est&amp;aacute;n en el tipo &lt;code&gt;T&lt;/code&gt; dado . Por ejemplo, pasar &lt;code&gt;inout shared int&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;SharedInoutOf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2633d057ea2e2d5df044edc1a3e53e74d5c07e4" translate="yes" xml:space="preserve">
          <source>Gives size in bytes of the memory mapped file.</source>
          <target state="translated">Da el tamaño en bytes del archivo mapeado de la memoria.</target>
        </trans-unit>
        <trans-unit id="16bbae332a1e2ca617ea29aad4cae716be022cf2" translate="yes" xml:space="preserve">
          <source>Gives the &lt;code&gt;sizeof&lt;/code&gt; the largest type given.</source>
          <target state="translated">Da la &lt;code&gt;sizeof&lt;/code&gt; el tipo m&amp;aacute;s grande dado.</target>
        </trans-unit>
        <trans-unit id="83055a3a0dd1a147d856955312d10beee008598a" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Da la diferencia entre dos &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="7aeb61024a32a4be6fbe1fa0169b6dc0e34e0c60" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Da la diferencia entre dos &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="a3e5e3dc87d1abe001240e5d15a0f4c35cd6e9f2" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Da la diferencia entre dos &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="e0ddf7ec5492699d7655f4aa024331ee0d174c96" translate="yes" xml:space="preserve">
          <source>Gives the difference between two &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Da la diferencia entre dos &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="23a706ac15ae0a2795d3b9540c47b5bd8f3ce3a4" translate="yes" xml:space="preserve">
          <source>Gives the last power of two before &lt;code&gt;val&lt;/code&gt;. &amp;lt;&amp;gt;&amp;gt; can be any built-in numerical type.</source>
          <target state="translated">Da el &amp;uacute;ltimo poder de dos antes de &lt;code&gt;val&lt;/code&gt; . &amp;lt;&amp;gt;&amp;gt; puede ser cualquier tipo num&amp;eacute;rico incorporado.</target>
        </trans-unit>
        <trans-unit id="5eba15a4a12033f10f76ecaeb54e9264300c3d84" translate="yes" xml:space="preserve">
          <source>Gives the next power of two after &lt;code&gt;val&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; can be any built-in numerical type.</source>
          <target state="translated">Da el siguiente poder de dos despu&amp;eacute;s de &lt;code&gt;val&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; puede ser cualquier tipo num&amp;eacute;rico incorporado.</target>
        </trans-unit>
        <trans-unit id="5dcd127d912205c801dfa9fd55aab21bc7540488" translate="yes" xml:space="preserve">
          <source>Gives the precision for numeric conversions. If the precision is a &lt;b&gt;*&lt;/b&gt;, an additional argument of type &lt;b&gt;int&lt;/b&gt;, preceding the actual argument, is taken as the precision. If it is negative, it is as if there was no</source>
          <target state="translated">Da la precisi&amp;oacute;n para las conversiones num&amp;eacute;ricas. Si la precisi&amp;oacute;n es un &lt;b&gt;*&lt;/b&gt; , se toma como precisi&amp;oacute;n un argumento adicional de tipo &lt;b&gt;int&lt;/b&gt; , que precede al argumento real. Si es negativo, es como si no hubiera</target>
        </trans-unit>
        <trans-unit id="066636e1bed1369dff6efcd3fab1c1e8776d7710" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from</source>
          <target state="translated">Da el resultado de sumar o restar un &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; de</target>
        </trans-unit>
        <trans-unit id="13fd9f69f64522f3bd20d1184529d631b3677431" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Da el resultado de sumar o restar un &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; de esta &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; , as&amp;iacute; como asignar el resultado a esta &lt;a href=&quot;#Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3c64b6298caea8c356268035bf6bb2213d1e63d" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Da el resultado de sumar o restar un &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; de este &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1405f5ebc75767bb0c5bcf744b2d2f96a676122" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Da el resultado de sumar o restar un &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; de este &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; , as&amp;iacute; como asignar el resultado a este &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aea621df7ee3b5185f92bf03dc43838e74f11ab8" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Da el resultado de sumar o restar un &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; de este &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d5dfde7603919eee6582396d3e52686e64f60c3" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Da el resultado de sumar o restar un &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; de este &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; , as&amp;iacute; como asignar el resultado a este &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1b9fd1a6e616c022dd85e5f596721b33e55dad9" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a &lt;a href=&quot;core_time#Duration&quot;&gt;&lt;code&gt;core.time.Duration&lt;/code&gt;&lt;/a&gt; from this &lt;a href=&quot;#TimeOfDay&quot;&gt;&lt;code&gt;TimeOfDay&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Da el resultado de sumar o restar un &lt;a href=&quot;core_time#Duration&quot;&gt; &lt;code&gt;core.time.Duration&lt;/code&gt; &lt;/a&gt; de este &lt;a href=&quot;#TimeOfDay&quot;&gt; &lt;code&gt;TimeOfDay&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7bb55c3ac43c11992ce982a465028a297070c37" translate="yes" xml:space="preserve">
          <source>Gives the result of adding or subtracting a duration from this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, as well as assigning the result to this &lt;a href=&quot;#DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Da el resultado de sumar o restar una duraci&amp;oacute;n de este &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; , as&amp;iacute; como asignar el resultado a este &lt;a href=&quot;#DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b010645431226eb0d475a6508504f6360118e2aa" translate="yes" xml:space="preserve">
          <source>Gives the string &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; if &lt;code&gt;isNull&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is equivalent to calling &lt;a href=&quot;std_format#formattedWrite&quot;&gt;&lt;code&gt;std.format.formattedWrite&lt;/code&gt;&lt;/a&gt; on the underlying value.</source>
          <target state="translated">Da la cadena &lt;code&gt;&quot;Nullable.null&quot;&lt;/code&gt; si &lt;code&gt;isNull&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; . De lo contrario, el resultado es equivalente a llamar a &lt;a href=&quot;std_format#formattedWrite&quot;&gt; &lt;code&gt;std.format.formattedWrite&lt;/code&gt; &lt;/a&gt; en el valor subyacente.</target>
        </trans-unit>
        <trans-unit id="ee3ba1f4d58b51dacaf77da9e736c2398dd52211" translate="yes" xml:space="preserve">
          <source>Giving better error messages inside generic code than the sometimes hard to follow compiler ones.</source>
          <target state="translated">Dando mejores mensajes de error dentro del código genérico que los a veces difíciles de seguir del compilador.</target>
        </trans-unit>
        <trans-unit id="fe40132df9803a579f2616316fd9f36e8b76b6f5" translate="yes" xml:space="preserve">
          <source>Glagolitic</source>
          <target state="translated">Glagolitic</target>
        </trans-unit>
        <trans-unit id="52d16b8e3607d3a956a90dad397b270e88b2a626" translate="yes" xml:space="preserve">
          <source>Glibc C runtime</source>
          <target state="translated">Tiempo de ejecución de Glibc C</target>
        </trans-unit>
        <trans-unit id="5f1184f7df96c5928092ad9c6b550699bf887826" translate="yes" xml:space="preserve">
          <source>Global</source>
          <target state="translated">Global</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">Funciones Globales</target>
        </trans-unit>
        <trans-unit id="60d510ca3fec034b096ecb101e79c44baa3bcfa4" translate="yes" xml:space="preserve">
          <source>Global and Static Initializers</source>
          <target state="translated">Iniciadores globales y estáticos</target>
        </trans-unit>
        <trans-unit id="ad8992e0e77b510d8dd8c9f31b8493285307157f" translate="yes" xml:space="preserve">
          <source>Global names</source>
          <target state="translated">Nombres globales</target>
        </trans-unit>
        <trans-unit id="fb160cab6ebf08ae16224b7387fbe010ff67af79" translate="yes" xml:space="preserve">
          <source>Global random number generator used by various functions in this module whenever no generator is specified. It is allocated per-thread and initialized to an unpredictable value for each thread.</source>
          <target state="translated">Generador de números aleatorios globales utilizado por varias funciones de este módulo siempre que no se especifique un generador.Se asigna por hilo y se inicializa a un valor impredecible para cada hilo.</target>
        </trans-unit>
        <trans-unit id="359a7909d420e528181333df942be655d355c0d2" translate="yes" xml:space="preserve">
          <source>Global regex, repeat over the whole input.</source>
          <target state="translated">Global regex,repita en toda la entrada.</target>
        </trans-unit>
        <trans-unit id="9d8204544b72aac8944f7aa50f34d5f2b83ebda7" translate="yes" xml:space="preserve">
          <source>Global status of the CTFE engine. Mostly used for performance diagnostics</source>
          <target state="translated">Estado global del motor de la CTFE.Se utiliza principalmente para el diagnóstico del rendimiento</target>
        </trans-unit>
        <trans-unit id="3bb8f4a4ce9e8fc53902a34f5711af6100354847" translate="yes" xml:space="preserve">
          <source>Global variables.</source>
          <target state="translated">Variables globales.</target>
        </trans-unit>
        <trans-unit id="322346956002b43d1272ba3ca4fad36e87acf31f" translate="yes" xml:space="preserve">
          <source>Go through the variables in function fd that are to be allocated in a closure, and set the .offset fields for those variables to their positions relative to the start of the closure instance. Also turns off nrvo for closure variables.</source>
          <target state="translated">Revise las variables de la función fd que deben asignarse en un cierre y establezca los campos .offset de esas variables en sus posiciones relativas al inicio de la instancia de cierre.También desactiva nrvo para las variables de cierre.</target>
        </trans-unit>
        <trans-unit id="83644e2182412c095ed367b8519c41f7f1a72b2f" translate="yes" xml:space="preserve">
          <source>Good error handling code tends to clutter up what otherwise would be a neat and clean looking implementation.</source>
          <target state="translated">Un buen código de manejo de errores tiende a desordenar lo que de otra manera sería una implementación limpia y ordenada.</target>
        </trans-unit>
        <trans-unit id="a4cc20ddddd5df91dbeeeac20e28069cdc6d35d5" translate="yes" xml:space="preserve">
          <source>Gothic</source>
          <target state="translated">Gothic</target>
        </trans-unit>
        <trans-unit id="523bd87e510be4584eb678bda56047b4e81b4e41" translate="yes" xml:space="preserve">
          <source>Goto Statement</source>
          <target state="translated">Declaración de Goto</target>
        </trans-unit>
        <trans-unit id="d153d2afa0d10e789b42decd9c86f4c6ba7c4b32" translate="yes" xml:space="preserve">
          <source>GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt;;</source>
          <target state="translated">GotoCaseStatements &lt;strong id=&quot;gotoCases&quot;&gt;gotoCases&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="2d75a452fb197b862328ddf89077f60c5411007e" translate="yes" xml:space="preserve">
          <source>GotoStatement</source>
          <target state="translated">GotoStatement</target>
        </trans-unit>
        <trans-unit id="469b09861974ba8cba6608f5b50f5a4378e847aa" translate="yes" xml:space="preserve">
          <source>GotoStatements* &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt;;</source>
          <target state="translated">GotoStatements * &lt;strong id=&quot;gotos&quot;&gt;gotos&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="b1b76e26ed39195055923abbd6da5da5869145b4" translate="yes" xml:space="preserve">
          <source>Gotos with forward references</source>
          <target state="translated">Gotos con referencias de avance</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="40e6976321b98f0050106aca23fe0094f3e12aec" translate="yes" xml:space="preserve">
          <source>Grapheme &lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt;(Input)(ref Input inp)</source>
          <target state="translated">Grafema &lt;strong id=&quot;decodeGrapheme&quot;&gt;decodeGrapheme&lt;/strong&gt; (Entrada) (ref INP de entrada)</target>
        </trans-unit>
        <trans-unit id="09e21aefbc5d72becfb6e61403ad83558925c509" translate="yes" xml:space="preserve">
          <source>Grapheme cluster length in &lt;a href=&quot;#Code%20point&quot;&gt;code points&lt;/a&gt;.</source>
          <target state="translated">Longitud del grupo de grafemas en &lt;a href=&quot;#Code%20point&quot;&gt;puntos de c&amp;oacute;digo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85a58af54a6759d4a9d1a773cb4f960185f26fe4" translate="yes" xml:space="preserve">
          <source>Grapheme_Base</source>
          <target state="translated">Grapheme_Base</target>
        </trans-unit>
        <trans-unit id="9aa96ceeca035f99f4979af4785877395b3fcca9" translate="yes" xml:space="preserve">
          <source>Grapheme_Extend</source>
          <target state="translated">Grapheme_Extend</target>
        </trans-unit>
        <trans-unit id="2299a70876b7b20196c0e232824b6e303cf0f817" translate="yes" xml:space="preserve">
          <source>Grapheme_Link</source>
          <target state="translated">Grapheme_Link</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="305ccd272b16a96e13db1c4faa38b1913caf51d8" translate="yes" xml:space="preserve">
          <source>Greek Extended</source>
          <target state="translated">Griego extendido</target>
        </trans-unit>
        <trans-unit id="63e0451063c60d5f6eae102313ee1b6d993a1f76" translate="yes" xml:space="preserve">
          <source>Greek and Coptic</source>
          <target state="translated">Griego y copto</target>
        </trans-unit>
        <trans-unit id="73fb2dd5cc2643e9f02bc351410b98713e0c50c9" translate="yes" xml:space="preserve">
          <source>Group separator</source>
          <target state="translated">Separador de grupo</target>
        </trans-unit>
        <trans-unit id="10986e5fcbdd40c81d3e51dfc3ad691df9a6347c" translate="yes" xml:space="preserve">
          <source>Group!(pred, Range) &lt;strong id=&quot;group&quot;&gt;group&lt;/strong&gt;(alias pred = &quot;a == b&quot;, Range)(Range r);</source>
          <target state="translated">Grupo! (Pred, Rango) &lt;strong id=&quot;group&quot;&gt;grupo&lt;/strong&gt; (alias pred = &quot;a == b&quot;, Rango) (Rango r);</target>
        </trans-unit>
        <trans-unit id="83af1301254c2810b776d48cab533ffdca19f557" translate="yes" xml:space="preserve">
          <source>Groups consecutively equivalent elements into a single tuple of the element and the number of its repetitions.</source>
          <target state="translated">Agrupa consecutivamente elementos equivalentes en una sola tupla del elemento y el número de sus repeticiones.</target>
        </trans-unit>
        <trans-unit id="afb8bcba7055a53eb0c5db950f6c2af39388fdf2" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using &lt;code&gt;alloc&lt;/code&gt;. The extra elements added are either default- initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">Crece la &lt;code&gt;array&lt;/code&gt; agregando &lt;code&gt;delta&lt;/code&gt; m&amp;aacute;s elementos. La memoria necesaria se asigna mediante &lt;code&gt;alloc&lt;/code&gt; . Los elementos adicionales agregados se inicializan por defecto, se rellenan con copias de &lt;code&gt;init&lt;/code&gt; o se inicializan con valores obtenidos del &lt;code&gt;range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e03f30a2f53aecda689ec68c63bc0d88b73542a6" translate="yes" xml:space="preserve">
          <source>Grows &lt;code&gt;array&lt;/code&gt; by appending &lt;code&gt;delta&lt;/code&gt; more elements. The needed memory is allocated using the same allocator that was used for the array type. The extra elements added are either default-initialized, filled with copies of &lt;code&gt;init&lt;/code&gt;, or initialized with values fetched from &lt;code&gt;range&lt;/code&gt;.</source>
          <target state="translated">Crece la &lt;code&gt;array&lt;/code&gt; agregando &lt;code&gt;delta&lt;/code&gt; m&amp;aacute;s elementos. La memoria necesaria se asigna utilizando el mismo asignador que se utiliz&amp;oacute; para el tipo de matriz. Los elementos adicionales agregados se inicializan por defecto, se rellenan con copias de &lt;code&gt;init&lt;/code&gt; o se inicializan con valores obtenidos del &lt;code&gt;range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77afda6ffc95cc0f06adb904e94cef0fc69add7d" translate="yes" xml:space="preserve">
          <source>Guaranteed &amp;Omicron;(&lt;code&gt;abs(length - newLength)&lt;/code&gt;) if &lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt;. If &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; the worst case is &amp;Omicron;(&lt;code&gt;newLength&lt;/code&gt;).</source>
          <target state="translated">Garantizado &amp;Omicron; ( &lt;code&gt;abs(length - newLength)&lt;/code&gt; ) si &lt;code&gt;capacity &amp;gt;= newLength&lt;/code&gt; . Si la &lt;code&gt;capacity &amp;lt; newLength&lt;/code&gt; el peor de los casos es &amp;Omicron; ( &lt;code&gt;newLength&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="35776951606a73d6ff2bfb1c43d6ba2de2721cad" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet</source>
          <target state="translated">Guillaume Chatelet</target>
        </trans-unit>
        <trans-unit id="971317803587830757efb436fa41eeb1d9292828" translate="yes" xml:space="preserve">
          <source>Guillaume Chatelet Manu Evans</source>
          <target state="translated">Guillaume Chatelet Manu Evans</target>
        </trans-unit>
        <trans-unit id="c06c55a5bcd005bf56c5234eb953099ffc1de3f1" translate="yes" xml:space="preserve">
          <source>Gujarati</source>
          <target state="translated">Gujarati</target>
        </trans-unit>
        <trans-unit id="265e1c23debf982bad1eb28dbf1fb86580b82eab" translate="yes" xml:space="preserve">
          <source>Gurmukhi</source>
          <target state="translated">Gurmukhi</target>
        </trans-unit>
        <trans-unit id="72c5d728b8c5e13d38cf050220cb41c1803704d1" translate="yes" xml:space="preserve">
          <source>H &lt;code&gt;m&lt;/code&gt;</source>
          <target state="translated">H &lt;code&gt;m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d44602ce53397cc7e3837311abb7db1d03042b84" translate="yes" xml:space="preserve">
          <source>H. S. Teoh's &lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;tutorial on component programming with ranges&lt;/a&gt; for a real-world showcase of the influence of range-based programming on complex algorithms.</source>
          <target state="translated">&lt;a href=&quot;http://wiki.dlang.org/Component_programming_with_ranges&quot;&gt;Tutorial de&lt;/a&gt; HS Teoh sobre programaci&amp;oacute;n de componentes con rangos para una muestra del mundo real de la influencia de la programaci&amp;oacute;n basada en rangos en algoritmos complejos.</target>
        </trans-unit>
        <trans-unit id="7fa36c2d12dc8308dd96737ca9539591241ccb57" translate="yes" xml:space="preserve">
          <source>HTML can be embedded into the documentation comments, and it will be passed through to the HTML output unchanged. However, since it is not necessarily true that HTML will be the desired output format of the embedded documentation comment extractor, it is best to avoid using it where practical.</source>
          <target state="translated">El HTML se puede incrustar en los comentarios de la documentación,y se pasará a la salida del HTML sin cambios.Sin embargo,como no es necesariamente cierto que HTML sea el formato de salida deseado del extractor de comentarios de documentación incrustado,es mejor evitar utilizarlo cuando sea práctico.</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="0481530df63832f72dfdebbe0c7a51d57e32da26" translate="yes" xml:space="preserve">
          <source>HTTP &lt;code&gt;conn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;conn&lt;/code&gt; HTTP</target>
        </trans-unit>
        <trans-unit id="ca83e4b247db9f9a4bf080067c192c5cb65a0d61" translate="yes" xml:space="preserve">
          <source>HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt;();</source>
          <target state="translated">HTTP &lt;strong id=&quot;dup&quot;&gt;dup&lt;/strong&gt; ();</target>
        </trans-unit>
        <trans-unit id="e4e09a7d12cb155ba460134c8bdd1f1479d801ce" translate="yes" xml:space="preserve">
          <source>HTTP POST method</source>
          <target state="translated">Método HTTP POST</target>
        </trans-unit>
        <trans-unit id="923988ff39d0e3042c9df0f259d1de84a01fde11" translate="yes" xml:space="preserve">
          <source>HTTP PUT</source>
          <target state="translated">HTTP PUT</target>
        </trans-unit>
        <trans-unit id="cc2478137d7b71e72935b2fddc027880593e756f" translate="yes" xml:space="preserve">
          <source>HTTP client functionality.</source>
          <target state="translated">Funcionalidad del cliente HTTP.</target>
        </trans-unit>
        <trans-unit id="827e4a67a71c875b43e732a905d1fd8e7200d6d6" translate="yes" xml:space="preserve">
          <source>HTTP connect request.</source>
          <target state="translated">Solicitud de conexión HTTP.</target>
        </trans-unit>
        <trans-unit id="51449b9a0615713cbd19f5f01e23d5f58e4358b0" translate="yes" xml:space="preserve">
          <source>HTTP connection to use</source>
          <target state="translated">Conexión HTTP a utilizar</target>
        </trans-unit>
        <trans-unit id="797634e3b267b6d81699bf16ac8a0f81dc1a1ba6" translate="yes" xml:space="preserve">
          <source>HTTP connection to use  The template parameter &lt;code&gt;T&lt;/code&gt; specifies the type to return. Possible values are &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;ubyte&lt;/code&gt; to return &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;ubyte[]&lt;/code&gt;.</source>
          <target state="translated">Conexi&amp;oacute;n HTTP a utilizar El par&amp;aacute;metro de plantilla &lt;code&gt;T&lt;/code&gt; especifica el tipo a devolver. Los valores posibles son &lt;code&gt;char&lt;/code&gt; y &lt;code&gt;ubyte&lt;/code&gt; para devolver &lt;code&gt;char[]&lt;/code&gt; o &lt;code&gt;ubyte[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5b69d980b7b8a0f8d5057989430d112ecf22206" translate="yes" xml:space="preserve">
          <source>HTTP method used.</source>
          <target state="translated">Método HTTP utilizado.</target>
        </trans-unit>
        <trans-unit id="bedfc3b8a98f74436dfffc470905a4cb727d6eb4" translate="yes" xml:space="preserve">
          <source>HTTP options request.</source>
          <target state="translated">Solicitud de opciones HTTP.</target>
        </trans-unit>
        <trans-unit id="eca27a5fb0f79404f93ba2b2ff7621d850fa94c3" translate="yes" xml:space="preserve">
          <source>HTTP patch content.</source>
          <target state="translated">Contenido del parche HTTP.</target>
        </trans-unit>
        <trans-unit id="0f24bcb381b514379fb794061233a0fac483e67d" translate="yes" xml:space="preserve">
          <source>HTTP post content.</source>
          <target state="translated">El contenido de los mensajes HTTP.</target>
        </trans-unit>
        <trans-unit id="fd473bd4cc525d8634b2d06223e94be806e9169e" translate="yes" xml:space="preserve">
          <source>HTTP request, for odd commands like DELETE, TRACE and others</source>
          <target state="translated">Petición HTTP,para comandos extraños como DELETE,TRACE y otros.</target>
        </trans-unit>
        <trans-unit id="7c360b79abb627a8a4c93e546c995b917aedbbb1" translate="yes" xml:space="preserve">
          <source>HTTP status line code e.g. 200.</source>
          <target state="translated">Código de línea de estado HTTP,por ejemplo,200.</target>
        </trans-unit>
        <trans-unit id="7fb8b94d5f23dd0fd12704704bd5724a9a81dd11" translate="yes" xml:space="preserve">
          <source>HTTP status line ie. the first line returned in an HTTP response.</source>
          <target state="translated">Línea de estado HTTP,es decir,la primera línea devuelta en una respuesta HTTP.</target>
        </trans-unit>
        <trans-unit id="5c1ee2091ce3bea9e5a23e0562f6b6fd7953de16" translate="yes" xml:space="preserve">
          <source>HTTP status line of last response. One call to perform may result in several requests because of redirection.</source>
          <target state="translated">Línea de estado HTTP de la última respuesta.Una llamada a realizar puede resultar en varias solicitudes debido a la redirección.</target>
        </trans-unit>
        <trans-unit id="45f917922bd09e11086c274630d2415137d36f0f" translate="yes" xml:space="preserve">
          <source>HTTP status line reason string.</source>
          <target state="translated">Cadena de razón de la línea de estado HTTP.</target>
        </trans-unit>
        <trans-unit id="1909e6b2261783a8d317d6f55a66a50ec6cfafb1" translate="yes" xml:space="preserve">
          <source>HTTP trace request.</source>
          <target state="translated">Solicitud de rastreo HTTP.</target>
        </trans-unit>
        <trans-unit id="52f8dbc2c259a9731d9751db65ced2bb8937f72a" translate="yes" xml:space="preserve">
          <source>HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</source>
          <target state="translated">HTTP.TimeCond &lt;code&gt;cond&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a59dd0563a7efe56dbe888a8e6b63f08d0ec7b1a" translate="yes" xml:space="preserve">
          <source>HTTP/FTP delete content.</source>
          <target state="translated">HTTP/FTP borrar el contenido.</target>
        </trans-unit>
        <trans-unit id="c911addb5a09d460fe739f0ee6699cd1115b2ceb" translate="yes" xml:space="preserve">
          <source>HTTP/FTP download to local file system.</source>
          <target state="translated">Descarga HTTP/FTP al sistema de archivos local.</target>
        </trans-unit>
        <trans-unit id="444e75970e6f6b8a13c7660b530b8789eb9d1688" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks asynchronously.</source>
          <target state="translated">HTTP/FTP obtiene el contenido como un rango de trozos asincrónicamente.</target>
        </trans-unit>
        <trans-unit id="067f2a38c032292745289e6d568747297c1eb36d" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of chunks.</source>
          <target state="translated">El HTTP/FTP obtiene el contenido en forma de trozos.</target>
        </trans-unit>
        <trans-unit id="ba7a6201d2a706377c412c319526144deec7201e" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines asynchronously.</source>
          <target state="translated">HTTP/FTP obtiene el contenido como un rango de líneas asincrónicas.</target>
        </trans-unit>
        <trans-unit id="a30ab80f3f96882837554330daf0f4a6aaa048ff" translate="yes" xml:space="preserve">
          <source>HTTP/FTP fetch content as a range of lines.</source>
          <target state="translated">El HTTP/FTP recupera el contenido como un rango de líneas.</target>
        </trans-unit>
        <trans-unit id="0a0a651b4d9a70a2c11401ce60fa08020ea7c52c" translate="yes" xml:space="preserve">
          <source>HTTP/FTP get content.</source>
          <target state="translated">HTTP/FTP obtener el contenido.</target>
        </trans-unit>
        <trans-unit id="a18566ddab985dc1d64ecd1c3e55c7fe0283f6cd" translate="yes" xml:space="preserve">
          <source>HTTP/FTP put content.</source>
          <target state="translated">HTTP/FTP puso el contenido.</target>
        </trans-unit>
        <trans-unit id="fd41ab93c5537d58968dc08902626f4aedcfc790" translate="yes" xml:space="preserve">
          <source>Halfwidth and Fullwidth Forms</source>
          <target state="translated">Formas de medio ancho y ancho completo</target>
        </trans-unit>
        <trans-unit id="15710324ddc14a3ddc719e414d041bb782d93764" translate="yes" xml:space="preserve">
          <source>Han</source>
          <target state="translated">Han</target>
        </trans-unit>
        <trans-unit id="495fba644d4dd3d28a3df2c5e262bc0aa344bdc1" translate="yes" xml:space="preserve">
          <source>Handle and transcode between various text encodings.</source>
          <target state="translated">Manejar y transcodificar entre varias codificaciones de texto.</target>
        </trans-unit>
        <trans-unit id="4cae35b945ed013183aeec759fb173f2b5e74ee5" translate="yes" xml:space="preserve">
          <source>Handle enums.</source>
          <target state="translated">Maneje los enums.</target>
        </trans-unit>
        <trans-unit id="70c0fd2c64cbbc7d9a73e18bc0fd02b46b142b9f" translate="yes" xml:space="preserve">
          <source>Handle exceptions thrown from range primitives.</source>
          <target state="translated">Manejar las excepciones lanzadas de los primitivos de rango.</target>
        </trans-unit>
        <trans-unit id="ed3da861f4c68bd404277c3815bb4277903ee0c7" translate="yes" xml:space="preserve">
          <source>Handle the postblit call on lvalue, or the move of rvalue.</source>
          <target state="translated">Manejar la llamada postblit en lvalor,o el movimiento de rvalor.</target>
        </trans-unit>
        <trans-unit id="e61477ad33d711243071181209298dcaac99b754" translate="yes" xml:space="preserve">
          <source>Handle to the system-specific semaphore.</source>
          <target state="translated">Manejar hasta el semáforo específico del sistema.</target>
        </trans-unit>
        <trans-unit id="362f233bfd36bbe9ffba21ece507104cececa24e" translate="yes" xml:space="preserve">
          <source>Handlers</source>
          <target state="translated">Handlers</target>
        </trans-unit>
        <trans-unit id="bd7d4b95fcd93ad906141f781368bc43c7c7f10a" translate="yes" xml:space="preserve">
          <source>Hangul</source>
          <target state="translated">Hangul</target>
        </trans-unit>
        <trans-unit id="46a74e921ed0b81734815d203a76d63ac9b445e2" translate="yes" xml:space="preserve">
          <source>Hangul Compatibility Jamo</source>
          <target state="translated">Compatibilidad con el Hangul Jamo</target>
        </trans-unit>
        <trans-unit id="6e435e03b7ff7b49d783dd12f4139eb337e88129" translate="yes" xml:space="preserve">
          <source>Hangul Jamo</source>
          <target state="translated">Hangul Jamo</target>
        </trans-unit>
        <trans-unit id="1af30ae437546a0c8f4e8c904b38e9e32c465cd5" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-A</source>
          <target state="translated">Hangul Jamo Extendido-A</target>
        </trans-unit>
        <trans-unit id="7f76ea3a5ca65b3f7be6271028b86fb4c24ad5b4" translate="yes" xml:space="preserve">
          <source>Hangul Jamo Extended-B</source>
          <target state="translated">Hangul Jamo Extendido-B</target>
        </trans-unit>
        <trans-unit id="a3c09f1beeeb5e6518d7a5aa130f9229a5bab1c8" translate="yes" xml:space="preserve">
          <source>Hangul Syllables</source>
          <target state="translated">Sílabas del hangul</target>
        </trans-unit>
        <trans-unit id="9649db5db6338c7bb1ab5215b20988c58817b67a" translate="yes" xml:space="preserve">
          <source>Hangul syllables are not covered by this function. See &lt;code&gt;composeJamo&lt;/code&gt; below.</source>
          <target state="translated">Las s&amp;iacute;labas de Hangul no est&amp;aacute;n cubiertas por esta funci&amp;oacute;n. Ver &lt;code&gt;composeJamo&lt;/code&gt; a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ed413af43425a39818253cc0c5de7394d4a39735" translate="yes" xml:space="preserve">
          <source>Hanunoo</source>
          <target state="translated">Hanunoo</target>
        </trans-unit>
        <trans-unit id="e938944cea2d9cc40e1f9955e4a0cfe8a2544308" translate="yes" xml:space="preserve">
          <source>Hardware Control</source>
          <target state="translated">Control de Hardware</target>
        </trans-unit>
        <trans-unit id="624a7b201d0ea02f7b27a09976e5469ea739a9e3" translate="yes" xml:space="preserve">
          <source>Has the same meaning as outside of a character class.</source>
          <target state="translated">Tiene el mismo significado que fuera de una clase de personaje.</target>
        </trans-unit>
        <trans-unit id="ff69afc8afb157be53fcca5d806ead0afca8f54a" translate="yes" xml:space="preserve">
          <source>Hash &lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt;(Hash)();</source>
          <target state="translated">Hash &lt;strong id=&quot;makeDigest&quot;&gt;makeDigest&lt;/strong&gt; (Hash) ();</target>
        </trans-unit>
        <trans-unit id="512530e2001855653aa805d74cb64a05638ad3fd" translate="yes" xml:space="preserve">
          <source>Hash options.</source>
          <target state="translated">Opciones de Hash.</target>
        </trans-unit>
        <trans-unit id="82c3b55a6e6190b4ea897a708e89b49564008ef7" translate="yes" xml:space="preserve">
          <source>Hash syntax for json objects.</source>
          <target state="translated">Sintaxis de hash para los objetos json.</target>
        </trans-unit>
        <trans-unit id="8d05adeedcb7aa54cc03e4f260b3e38d1479ae1c" translate="yes" xml:space="preserve">
          <source>HashTab container for internal usage.</source>
          <target state="translated">Contenedor HashTab para uso interno.</target>
        </trans-unit>
        <trans-unit id="201cd54dff7c562fa04665ce3ec7f389323b7356" translate="yes" xml:space="preserve">
          <source>Have some variables that are maybescopes that were assigned values from other maybescope variables. Now that semantic analysis of the function is complete, we can finalize this by turning off maybescope for array elements that cannot be scope.</source>
          <target state="translated">Tienen algunas variables que son maybescopios a los que se les asignaron valores de otras variables de maybescopios.Ahora que el análisis semántico de la función está completo,podemos finalizar esto apagando el maybescopio para los elementos de la matriz que no pueden ser de alcance.</target>
        </trans-unit>
        <trans-unit id="dea56ebbd4737b0cd9262ab0c819e3683d0b5416" translate="yes" xml:space="preserve">
          <source>Having unmatched parentheses can hose the output of Ddoc, as the macros depend on properly nested parentheses. This function replaces all ( with ( and ) with ) to preserve text literally. This also means macros in the text won't be expanded.</source>
          <target state="translated">El hecho de tener paréntesis no emparejados puede regar la salida del Ddoc,ya que los macros dependen de paréntesis correctamente anidados.Esta función reemplaza todo(con(y)con)para preservar el texto literalmente.Esto también significa que las macros en el texto no se expandirán.</target>
        </trans-unit>
        <trans-unit id="71653e5271aa72abad98ba52f8927b0be428b96b" translate="yes" xml:space="preserve">
          <source>Haystack &lt;code&gt;haystack&lt;/code&gt;</source>
          <target state="translated">Pajar &lt;code&gt;haystack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0403de1effb4e88849c3d2d079f299e89f093ed" translate="yes" xml:space="preserve">
          <source>HeaderFormat &lt;code&gt;header&lt;/code&gt;</source>
          <target state="translated">HeaderFormat &lt;code&gt;header&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c97d4c3dede14ee24bc42018c52f19917fd481c9" translate="yes" xml:space="preserve">
          <source>Headings</source>
          <target state="translated">Headings</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="fbea2ec13adcf999e380e13a429a4e17dc3d8090" translate="yes" xml:space="preserve">
          <source>Help Information Generation</source>
          <target state="translated">Generación de información de ayuda</target>
        </trans-unit>
        <trans-unit id="1e7eebdb08c9dbf27c7668e2badd51e667707d3c" translate="yes" xml:space="preserve">
          <source>Helper</source>
          <target state="translated">Helper</target>
        </trans-unit>
        <trans-unit id="5e31a530e83afec402c4c09898e79e56b473dc7d" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create a string literal consisting of 'value' duplicated 'dim' times.</source>
          <target state="translated">Ayudante para NewExp Crear un literal de cadena que consista en &quot;valor&quot; duplicado en tiempos &quot;oscuros&quot;.</target>
        </trans-unit>
        <trans-unit id="766c386647e8e48a9fcd435724f1d350167f7ed5" translate="yes" xml:space="preserve">
          <source>Helper for NewExp Create an array literal consisting of 'elem' duplicated 'dim' times.</source>
          <target state="translated">Ayudante de la NewExp Crear una matriz literal que consiste en &quot;elem&quot; duplicado &quot;dim&quot; veces.</target>
        </trans-unit>
        <trans-unit id="c02c79263e4ed8c5595da2dd0c63a6d49edcd0eb" translate="yes" xml:space="preserve">
          <source>Helper function for &lt;code&gt;getRightThis()&lt;/code&gt;. Gets &lt;code&gt;this&lt;/code&gt; of the next outer aggregate.</source>
          <target state="translated">Funci&amp;oacute;n de &lt;code&gt;getRightThis()&lt;/code&gt; para getRightThis () . Obtiene &lt;code&gt;this&lt;/code&gt; del siguiente agregado externo.</target>
        </trans-unit>
        <trans-unit id="467531459771317152c9703e3f120447d81f80b5" translate="yes" xml:space="preserve">
          <source>Helper function for easy error propagation. If error occurs, returns ErrorExp. Otherwise returns NULL.</source>
          <target state="translated">Función de ayuda para facilitar la propagación de los errores.Si se produce un error,devuelve ErrorExp.En caso contrario,devuelve NULL.</target>
        </trans-unit>
        <trans-unit id="3576c823fa70ffbb40f146b4e65274f6dc08a676" translate="yes" xml:space="preserve">
          <source>Helper function for the expansion of manifest constant.</source>
          <target state="translated">Función de ayuda para la expansión de la constante manifiesta.</target>
        </trans-unit>
        <trans-unit id="f45a0f048cca01c298f3e28147b97707c3bec7c9" translate="yes" xml:space="preserve">
          <source>Helper function that returns a &lt;code&gt;FormatSpec&lt;/code&gt; for a single specifier given in &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Funci&amp;oacute;n auxiliar que devuelve un &lt;code&gt;FormatSpec&lt;/code&gt; para un solo especificador dado en &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10a93d4497e85393cb5499fb73d96c729ebc3ddb" translate="yes" xml:space="preserve">
          <source>Helper function that returns a complex number with the specified real and imaginary parts.</source>
          <target state="translated">Función de ayuda que devuelve un número complejo con las partes reales e imaginarias especificadas.</target>
        </trans-unit>
        <trans-unit id="b43936919328317134bad177cd4f68d6f84246ac" translate="yes" xml:space="preserve">
          <source>Helper function to turn operator into template argument list</source>
          <target state="translated">Función de ayuda para convertir al operador en una lista de argumentos de la plantilla</target>
        </trans-unit>
        <trans-unit id="934835a36e88b263f02948e4dbd8c5dd04401bc0" translate="yes" xml:space="preserve">
          <source>Helper functions</source>
          <target state="translated">Funciones del ayudante</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="736e7e325114a8cd6d30377592f7bf25b8688457" translate="yes" xml:space="preserve">
          <source>Hence, the following errors can be statically detected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e62a53ff4cde1bc51ffbf3814a1010c7743286" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;o&lt;/code&gt; supplies the</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;o&lt;/code&gt; suministra el</target>
        </trans-unit>
        <trans-unit id="1ede5efd1d10c5200eb2a32aa68abb7fc6f76c2f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;o&lt;/code&gt; supplies the &lt;code&gt;this&lt;/code&gt; reference to the inner class instance of &lt;code&gt;Outer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf320d31b7dd0774140c8f2ed90c8c274ff772d" translate="yes" xml:space="preserve">
          <source>Here block names are unambiguous as no scripts are searched and thus to search use simply &lt;code&gt;unicode.block.BlockName&lt;/code&gt; notation.</source>
          <target state="translated">Aqu&amp;iacute; los nombres de bloque no son ambiguos ya que no se buscan scripts y, por lo tanto, para la b&amp;uacute;squeda, simplemente &lt;code&gt;unicode.block.BlockName&lt;/code&gt; notaci&amp;oacute;n unicode.block.BlockName .</target>
        </trans-unit>
        <trans-unit id="6dcb204b7bfbc922a65c81d29d2d9fe0db1b0d9c" translate="yes" xml:space="preserve">
          <source>Here is an example function in both forms:</source>
          <target state="translated">He aquí un ejemplo de función en ambas formas:</target>
        </trans-unit>
        <trans-unit id="d0b4b9e647805e60f485e34136037cafd1a89034" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;add&lt;/code&gt; returns the base type, which doesn't implement the &lt;code&gt;remove&lt;/code&gt; method. The &lt;code&gt;template this&lt;/code&gt; parameter can be used for this purpose:</source>
          <target state="translated">Aqu&amp;iacute; el m&amp;eacute;todo &lt;code&gt;add&lt;/code&gt; devuelve el tipo base, que no implementa el m&amp;eacute;todo &lt;code&gt;remove&lt;/code&gt; . La &lt;code&gt;template this&lt;/code&gt; par&amp;aacute;metro se puede utilizar para este prop&amp;oacute;sito:</target>
        </trans-unit>
        <trans-unit id="c4a0b731de4fd47e1ec934359b73224f54545eef" translate="yes" xml:space="preserve">
          <source>Here the method &lt;code&gt;initWith&lt;/code&gt; is overloaded with two versions, one accepting &lt;code&gt;in char*&lt;/code&gt;, the other one &lt;code&gt;NSString&lt;/code&gt;. These two methods are mapped to two different Objective-C selectors, &lt;code&gt;initWithUTF8String:&lt;/code&gt; and &lt;code&gt;initWithString:&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; el m&amp;eacute;todo &lt;code&gt;initWith&lt;/code&gt; est&amp;aacute; sobrecargado con dos versiones, una que acepta &lt;code&gt;in char*&lt;/code&gt; , la otra &lt;code&gt;NSString&lt;/code&gt; . Estos dos m&amp;eacute;todos se asignan a dos selectores de Objective-C diferentes, &lt;code&gt;initWithUTF8String:&lt;/code&gt; y &lt;code&gt;initWithString:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7394eed5672426c0a80d302b8f8393ed7eec5e66" translate="yes" xml:space="preserve">
          <source>Here's an example of C code providing a callback to D code:</source>
          <target state="translated">Aquí hay un ejemplo de código C que proporciona una llamada a código D:</target>
        </trans-unit>
        <trans-unit id="ca207d127693f0056dad58049c5cee1c802022ff" translate="yes" xml:space="preserve">
          <source>Here's an example of a</source>
          <target state="translated">Aquí hay un ejemplo de un</target>
        </trans-unit>
        <trans-unit id="62b798df4ae2b665a95d9fcc9f504deddb178a54" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S&lt;/code&gt; has a temporary workspace &lt;code&gt;buf[]&lt;/code&gt;. The normal postblit will pointlessly free and reallocate it. The custom &lt;code&gt;opAssign&lt;/code&gt; will reuse the existing storage.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;S&lt;/code&gt; tiene un espacio de trabajo temporal &lt;code&gt;buf[]&lt;/code&gt; . El postblit normal lo liberar&amp;aacute; y reasignar&amp;aacute; sin sentido. El &lt;code&gt;opAssign&lt;/code&gt; personalizado reutilizar&amp;aacute; el almacenamiento existente.</target>
        </trans-unit>
        <trans-unit id="8062e6745c830b66848176f824bd120bb6ff6bff" translate="yes" xml:space="preserve">
          <source>Here, an implementation may assume (without having knowledge of the body of &lt;code&gt;make&lt;/code&gt;) that all references in &lt;code&gt;make&lt;/code&gt;'s result refer to other &lt;code&gt;List&lt;/code&gt; objects created by &lt;code&gt;make&lt;/code&gt;, and that no other part of the program refers to any of these objects.</source>
          <target state="translated">Aqu&amp;iacute;, una implementaci&amp;oacute;n puede suponer (sin tener conocimiento del cuerpo de &lt;code&gt;make&lt;/code&gt; ) que todas las referencias en el resultado de &lt;code&gt;make&lt;/code&gt; se refieren a otros objetos &lt;code&gt;List&lt;/code&gt; creados por &lt;code&gt;make&lt;/code&gt; , y que ninguna otra parte del programa se refiere a ninguno de estos objetos.</target>
        </trans-unit>
        <trans-unit id="aa7249d3729c33470954c40f7854c88ac6ea3626" translate="yes" xml:space="preserve">
          <source>Hex Strings</source>
          <target state="translated">Cuerdas Hexagonales</target>
        </trans-unit>
        <trans-unit id="55d1c93cb26fa4369bf6dcef06802017d907bd51" translate="yes" xml:space="preserve">
          <source>Hex strings allow string literals to be created using hex data. The hex data need not form valid UTF characters.</source>
          <target state="translated">Las cadenas hexagonales permiten crear literales de cadenas utilizando datos hexagonales.Los datos hexadecimales no necesitan formar caracteres UTF válidos.</target>
        </trans-unit>
        <trans-unit id="d39bdde77ca95b7a4b0450ffc2d016efdeac30d3" translate="yes" xml:space="preserve">
          <source>Hex_Digit</source>
          <target state="translated">Hex_Digit</target>
        </trans-unit>
        <trans-unit id="c45ee0a2d08a303c51fd2da33a102a3979857332" translate="yes" xml:space="preserve">
          <source>Hexadecimal floats are preceded by a &lt;b&gt;0x&lt;/b&gt; or &lt;b&gt;0X&lt;/b&gt; and the exponent is a &lt;b&gt;p&lt;/b&gt; or &lt;b&gt;P&lt;/b&gt; followed by a decimal number serving as the exponent of 2.</source>
          <target state="translated">Los flotadores hexadecimales est&amp;aacute;n precedidos por &lt;b&gt;0x&lt;/b&gt; o &lt;b&gt;0X&lt;/b&gt; y el exponente es &lt;b&gt;p&lt;/b&gt; o &lt;b&gt;P&lt;/b&gt; seguido de un n&amp;uacute;mero decimal que sirve como exponente de 2.</target>
        </trans-unit>
        <trans-unit id="f16858a5f250d36219d82e048f143333094b2747" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers are a sequence of hexadecimal digits preceded by a &amp;lsquo;0x&amp;rsquo; or &amp;lsquo;0X&amp;rsquo;.</source>
          <target state="translated">Los enteros hexadecimales son una secuencia de d&amp;iacute;gitos hexadecimales precedidos por un '0x' o '0X'.</target>
        </trans-unit>
        <trans-unit id="11ddb91ab70b44df8f22cc56bf0f33cd3a59aeec" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation</source>
          <target state="translated">Hexadecimal notation</target>
        </trans-unit>
        <trans-unit id="66364879eee2501137250fec2b98de691bb34dff" translate="yes" xml:space="preserve">
          <source>Hexadecimal notation with explicit suffixes</source>
          <target state="translated">Notación hexadecimal con sufijos explícitos</target>
        </trans-unit>
        <trans-unit id="4606d5486909f59f9ecd950c1b17f287693253b2" translate="yes" xml:space="preserve">
          <source>Hexadecimal, lower case</source>
          <target state="translated">Hexadecimal,minúsculas</target>
        </trans-unit>
        <trans-unit id="bf0117ce1416e40b23cca8ffd7b3aa016afb333f" translate="yes" xml:space="preserve">
          <source>Hexadecimal, upper case</source>
          <target state="translated">Hexadecimal,mayúscula</target>
        </trans-unit>
        <trans-unit id="30b3eea9819f7439bb0562c0c53437f8d9a50617" translate="yes" xml:space="preserve">
          <source>Hidden parameters include the &lt;code&gt;this&lt;/code&gt; parameter of a class, struct or nested function and the selector parameter for Objective-C methods.</source>
          <target state="translated">Los par&amp;aacute;metros ocultos incluyen &lt;code&gt;this&lt;/code&gt; par&amp;aacute;metro de una clase, estructura o funci&amp;oacute;n anidada y el par&amp;aacute;metro selector para m&amp;eacute;todos Objective-C.</target>
        </trans-unit>
        <trans-unit id="53541869fd4c351759ad332d3244e2355b446808" translate="yes" xml:space="preserve">
          <source>High Private Use Surrogates</source>
          <target state="translated">Sustitutos de alto uso privado</target>
        </trans-unit>
        <trans-unit id="a2c5b830397db70f03f56d26786a97a92aad7755" translate="yes" xml:space="preserve">
          <source>High Surrogates</source>
          <target state="translated">Altos Sustitutos</target>
        </trans-unit>
        <trans-unit id="f8ac1be04c27612db7a3ef64fd5edd48a9cbefb5" translate="yes" xml:space="preserve">
          <source>High level</source>
          <target state="translated">Alto nivel</target>
        </trans-unit>
        <trans-unit id="0720fad238d3af6e0d988b6041fc7aff02b725de" translate="yes" xml:space="preserve">
          <source>High level bit level manipulation, bit arrays, bit fields.</source>
          <target state="translated">Manipulación de alto nivel de bits,matrices de bits,campos de bits.</target>
        </trans-unit>
        <trans-unit id="a05a4fbe2b607cf88b24dc00ca5c949b2b6f1756" translate="yes" xml:space="preserve">
          <source>High level primitives for SMP parallelism.</source>
          <target state="translated">Primitivas de alto nivel para el paralelismo SMP.</target>
        </trans-unit>
        <trans-unit id="2ced0d4c7e1faee3d9f900306c2e846112d18012" translate="yes" xml:space="preserve">
          <source>High-level interface for allocators. Implements bundled allocation/creation and destruction/deallocation of data including &lt;code&gt;struct&lt;/code&gt;s and &lt;code&gt;class&lt;/code&gt;es, and also array primitives related to allocation. This module is the entry point for both making use of allocators and for their documentation.</source>
          <target state="translated">Interfaz de alto nivel para asignadores. Implementa la asignaci&amp;oacute;n / creaci&amp;oacute;n agrupada y la destrucci&amp;oacute;n / desasignaci&amp;oacute;n de datos que incluyen &lt;code&gt;struct&lt;/code&gt; y &lt;code&gt;class&lt;/code&gt; , y tambi&amp;eacute;n primitivas de matriz relacionadas con la asignaci&amp;oacute;n. Este m&amp;oacute;dulo es el punto de entrada tanto para el uso de asignadores como para su documentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e4a71da2c94aa8ebb4eabe525bf9bfaf87c49456" translate="yes" xml:space="preserve">
          <source>Highest generated value (&lt;code&gt;modulus - 1&lt;/code&gt;).</source>
          <target state="translated">Valor generado m&amp;aacute;s alto ( &lt;code&gt;modulus - 1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a7ebfdbeeab34f9a74c5ea30182aae05ebb58ca" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;LogLevel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LogLevel&lt;/code&gt; m&amp;aacute;s alto posible .</target>
        </trans-unit>
        <trans-unit id="464c7e7834d9d7bd5320fc6bf866ca1e41042986" translate="yes" xml:space="preserve">
          <source>Highlighting</source>
          <target state="translated">Highlighting</target>
        </trans-unit>
        <trans-unit id="b95101e7e46150f6462631854125e5fff96c059a" translate="yes" xml:space="preserve">
          <source>Highlighting of D code is performed by the following macros:</source>
          <target state="translated">El resaltado del código D se realiza mediante las siguientes macros:</target>
        </trans-unit>
        <trans-unit id="683f475e2ebb85d31bca86c12acb027ecf0e8eb2" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords</source>
          <target state="translated">Destacar las palabras clave de la D</target>
        </trans-unit>
        <trans-unit id="c4ca1644d89763135e446cfbeade41acbff8ee52" translate="yes" xml:space="preserve">
          <source>Highlighting of D keywords.</source>
          <target state="translated">Resaltando las palabras clave de la D.</target>
        </trans-unit>
        <trans-unit id="935e04346b38d14f49040acb6c379fad11a7bf81" translate="yes" xml:space="preserve">
          <source>Highlighting of a function parameter section.</source>
          <target state="translated">Resaltado de una sección de parámetros de función.</target>
        </trans-unit>
        <trans-unit id="826389bac96eaeab4717271d63b43c94f3297c72" translate="yes" xml:space="preserve">
          <source>Highlighting of a name=value function parameter.</source>
          <target state="translated">Resaltado de un parámetro de la función nombre=valor.</target>
        </trans-unit>
        <trans-unit id="51eda7a8eeff739d414894834699b4db25dca6d2" translate="yes" xml:space="preserve">
          <source>Highlighting of a template constraint.</source>
          <target state="translated">Resaltado de una restricción de plantilla.</target>
        </trans-unit>
        <trans-unit id="cc13dc42b045774509fcd534fa3f901ea5ee4636" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's individual parameters.</source>
          <target state="translated">Resaltar los parámetros individuales de una plantilla.</target>
        </trans-unit>
        <trans-unit id="61100e35b4349aa073e0605d9e5a97e7d22147a5" translate="yes" xml:space="preserve">
          <source>Highlighting of a template's parameter list.</source>
          <target state="translated">Resaltado de la lista de parámetros de una plantilla.</target>
        </trans-unit>
        <trans-unit id="c13fcc9292d599790bf9edbd77af674db96191fd" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a class.</source>
          <target state="translated">Destacando a todos los miembros de una clase.</target>
        </trans-unit>
        <trans-unit id="e4ae17c8f2cb1ec34256f6f0903677d6b391295e" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a module.</source>
          <target state="translated">Destacando a todos los miembros de un módulo.</target>
        </trans-unit>
        <trans-unit id="c09feb09e99ce22a8559d127647547ccdb5c7c15" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a struct.</source>
          <target state="translated">Destacando todos los miembros de una estructura.</target>
        </trans-unit>
        <trans-unit id="cbef76e4daad8898695a45761c2de54a52f8635b" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of a template.</source>
          <target state="translated">Destacando a todos los miembros de una plantilla.</target>
        </trans-unit>
        <trans-unit id="0faf83c3ae32ade36ccd67312a59a723e525d473" translate="yes" xml:space="preserve">
          <source>Highlighting of all the members of an enum.</source>
          <target state="translated">Destacando a todos los miembros de una lista.</target>
        </trans-unit>
        <trans-unit id="e8d93f96992576e6ba1194d00e53b1efd8bd3019" translate="yes" xml:space="preserve">
          <source>Highlighting of all the sections.</source>
          <target state="translated">Destacando todas las secciones.</target>
        </trans-unit>
        <trans-unit id="4778b67265bf5d04ac6df97ab091affb27b022ea" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected keywords</source>
          <target state="translated">Resaltado de palabras clave auto-detectadas</target>
        </trans-unit>
        <trans-unit id="dd81b3fecd0f20ab2c7c2cd23019f77363841968" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected parameters</source>
          <target state="translated">Resaltado de los parámetros auto-detectados</target>
        </trans-unit>
        <trans-unit id="2d5dbc630aa84bc9b06ad40e57222a60ed6a293a" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol</source>
          <target state="translated">Resaltado del símbolo auto-detectado</target>
        </trans-unit>
        <trans-unit id="5a59602c4760ed030bee0db0f8f2fc1e157c8fe6" translate="yes" xml:space="preserve">
          <source>Highlighting of auto-detected symbol that starts with underscore</source>
          <target state="translated">Resaltado del símbolo auto-detectado que comienza con el subrayado</target>
        </trans-unit>
        <trans-unit id="03eeb845c1ab1c169a400e57021a9975be5fcd70" translate="yes" xml:space="preserve">
          <source>Highlighting of comments</source>
          <target state="translated">Destacar los comentarios</target>
        </trans-unit>
        <trans-unit id="b342620229626113c8bd37f08c3e00019479575f" translate="yes" xml:space="preserve">
          <source>Highlighting of current declaration name</source>
          <target state="translated">Destacar el nombre de la declaración actual</target>
        </trans-unit>
        <trans-unit id="176f12498ba670eeda224994c2d82350441886fe" translate="yes" xml:space="preserve">
          <source>Highlighting of current function declaration parameters</source>
          <target state="translated">Destacar los parámetros de declaración de la función actual</target>
        </trans-unit>
        <trans-unit id="6b99cfaf4826b1d374574b650af15bdd57440bdb" translate="yes" xml:space="preserve">
          <source>Highlighting of declaration name to which a particular section is referring.</source>
          <target state="translated">Destacar el nombre de la declaración a la que se refiere una sección particular.</target>
        </trans-unit>
        <trans-unit id="0ccd215d873103285e575951e68bee16377784a3" translate="yes" xml:space="preserve">
          <source>Highlighting of ditto declarations.</source>
          <target state="translated">Destacando las mismas declaraciones.</target>
        </trans-unit>
        <trans-unit id="e60176b3b0d8bba6525dbfb5d2184816b026c16d" translate="yes" xml:space="preserve">
          <source>Highlighting of function parameters.</source>
          <target state="translated">Resaltado de los parámetros de la función.</target>
        </trans-unit>
        <trans-unit id="738f3d1a73adb20a6fc751e428562fd5770c4fbf" translate="yes" xml:space="preserve">
          <source>Highlighting of non-special sections is done.</source>
          <target state="translated">Se resaltan las secciones no especiales.</target>
        </trans-unit>
        <trans-unit id="4e9319188986e049a769be81e81ed23eb17972c2" translate="yes" xml:space="preserve">
          <source>Highlighting of string literals</source>
          <target state="translated">Resaltando los literales de las cuerdas</target>
        </trans-unit>
        <trans-unit id="9dc393c818c0c8fcccd04642b35f2031235608ef" translate="yes" xml:space="preserve">
          <source>Highlighting of the authors section.</source>
          <target state="translated">Destacado de la sección de autores.</target>
        </trans-unit>
        <trans-unit id="c04db9dc0d813c1ccd8c3f2345ab8b620b85f230" translate="yes" xml:space="preserve">
          <source>Highlighting of the base type of a class.</source>
          <target state="translated">Resaltando el tipo de base de una clase.</target>
        </trans-unit>
        <trans-unit id="a07587fe4175acb9782fe36fd142c60cdfdd6da4" translate="yes" xml:space="preserve">
          <source>Highlighting of the bugs section.</source>
          <target state="translated">Resaltando la sección de bichos.</target>
        </trans-unit>
        <trans-unit id="7882769ed43990ada8c8b23f2c29f9e27cd0f71b" translate="yes" xml:space="preserve">
          <source>Highlighting of the contents of a non-standard section.</source>
          <target state="translated">Destacar el contenido de una sección no estándar.</target>
        </trans-unit>
        <trans-unit id="4f9d3c220f1308abbd19a33e68d9159fe1a7bcac" translate="yes" xml:space="preserve">
          <source>Highlighting of the copyright section.</source>
          <target state="translated">Destacar la sección de derechos de autor.</target>
        </trans-unit>
        <trans-unit id="7d6e48fe7e09c72518d7c42b2053ac6afd252e38" translate="yes" xml:space="preserve">
          <source>Highlighting of the date section.</source>
          <target state="translated">Resaltando la sección de la fecha.</target>
        </trans-unit>
        <trans-unit id="895c3d9b137fe00aae27a823464b74cfac8c6e8b" translate="yes" xml:space="preserve">
          <source>Highlighting of the declaration.</source>
          <target state="translated">Destacando la declaración.</target>
        </trans-unit>
        <trans-unit id="63dc31f05686ee2516c9b1d4403bc34707de916c" translate="yes" xml:space="preserve">
          <source>Highlighting of the deprecated section.</source>
          <target state="translated">Resaltando la sección desaprobada.</target>
        </trans-unit>
        <trans-unit id="c8decd9303e1480e7050896c2d68e41aba55a19d" translate="yes" xml:space="preserve">
          <source>Highlighting of the description of a declaration.</source>
          <target state="translated">Destacar la descripción de una declaración.</target>
        </trans-unit>
        <trans-unit id="c34c68b3feaf8a8af047b5dc0b27284ee8a4a976" translate="yes" xml:space="preserve">
          <source>Highlighting of the description section.</source>
          <target state="translated">Resaltando la sección de descripción.</target>
        </trans-unit>
        <trans-unit id="66395af507be6d2f2c64374c4dcc34d87ba08e37" translate="yes" xml:space="preserve">
          <source>Highlighting of the examples section.</source>
          <target state="translated">Destacado de la sección de ejemplos.</target>
        </trans-unit>
        <trans-unit id="6c9891d5d62ba75e6f4bc3861099aa91d8757c3e" translate="yes" xml:space="preserve">
          <source>Highlighting of the history section.</source>
          <target state="translated">Destacado de la sección de historia.</target>
        </trans-unit>
        <trans-unit id="b7f85e62f0cd3405e5bd64486a1604e80fdbaccf" translate="yes" xml:space="preserve">
          <source>Highlighting of the license section.</source>
          <target state="translated">Resaltando la sección de la licencia.</target>
        </trans-unit>
        <trans-unit id="a1bf0eef04a7e415262c4a93c4981e89e888edcc" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter name.</source>
          <target state="translated">Resaltando el nombre del parámetro.</target>
        </trans-unit>
        <trans-unit id="f88d01cfff7b61b2efa32b18d2de859fdd295ab7" translate="yes" xml:space="preserve">
          <source>Highlighting of the parameter value.</source>
          <target state="translated">Resaltado del valor del parámetro.</target>
        </trans-unit>
        <trans-unit id="e1964e06337cb784d3309fe34806373d2ea7eb8f" translate="yes" xml:space="preserve">
          <source>Highlighting of the returns section.</source>
          <target state="translated">Resaltado de la sección de devoluciones.</target>
        </trans-unit>
        <trans-unit id="833453d17a268f3c235ee74c7f3da2609550d437" translate="yes" xml:space="preserve">
          <source>Highlighting of the section name of a non-standard section.</source>
          <target state="translated">Resaltando el nombre de la sección de una sección no estándar.</target>
        </trans-unit>
        <trans-unit id="c7903d232b908137bafe89e336276f896f569fc5" translate="yes" xml:space="preserve">
          <source>Highlighting of the see-also section.</source>
          <target state="translated">Resaltando la sección de ver-también.</target>
        </trans-unit>
        <trans-unit id="df390d31d75e9b616a073ce0adb1eeb2634d7fd5" translate="yes" xml:space="preserve">
          <source>Highlighting of the standards section.</source>
          <target state="translated">Destacar la sección de normas.</target>
        </trans-unit>
        <trans-unit id="f0d2af38c35f5e37acd97274204555972b2988bd" translate="yes" xml:space="preserve">
          <source>Highlighting of the summary section.</source>
          <target state="translated">Destacado de la sección de resumen.</target>
        </trans-unit>
        <trans-unit id="21e5f168213fe615e9ee4675e90cca4182bf4f11" translate="yes" xml:space="preserve">
          <source>Highlighting of the throws section.</source>
          <target state="translated">Resaltando la sección de lanzamientos.</target>
        </trans-unit>
        <trans-unit id="0dff0c156a9e500788193fc7d13465ffae833297" translate="yes" xml:space="preserve">
          <source>Highlighting of the type an enum is based upon</source>
          <target state="translated">Destacar el tipo en el que se basa una lista</target>
        </trans-unit>
        <trans-unit id="6b50d26c177d3621167352e70fcbe2f923cd28c3" translate="yes" xml:space="preserve">
          <source>Highlighting of the version section.</source>
          <target state="translated">Resaltando la sección de la versión.</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="835fe32e11d06c07988640ea18d5a882081aeaae" translate="yes" xml:space="preserve">
          <source>History:</source>
          <target state="translated">History:</target>
        </trans-unit>
        <trans-unit id="b44fed8b2ad60db45d1dfeb77fbed8d582ca1505" translate="yes" xml:space="preserve">
          <source>Hoist-load + hoist-store barrier. Corresponds to &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt; and C++11/C11 &lt;code&gt;memory_order_acquire&lt;/code&gt;.</source>
          <target state="translated">Alzamiento-carga + alzamiento-barrera de la tienda. Corresponde a &lt;a href=&quot;https://llvm.org/docs/Atomics.html#acquire&quot;&gt;LLVM AtomicOrdering.Acquire&lt;/a&gt; y C ++ 11 / C11 &lt;code&gt;memory_order_acquire&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e61310c65ecb57873a154d2408b9cc4403ad4a2" translate="yes" xml:space="preserve">
          <source>Holds information about a socket address retrieved by &lt;code&gt;getAddressInfo&lt;/code&gt;.</source>
          <target state="translated">Contiene informaci&amp;oacute;n sobre una direcci&amp;oacute;n de socket recuperada por &lt;code&gt;getAddressInfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c10ba96a990de4f937f02e9f283e74796b47e3f8" translate="yes" xml:space="preserve">
          <source>Home of the TZ Database files</source>
          <target state="translated">Inicio de los archivos de la base de datos de TZ</target>
        </trans-unit>
        <trans-unit id="b3e0a103daa9ae3f375b2654f0a482c7c0d36297" translate="yes" xml:space="preserve">
          <source>Hook</source>
          <target state="translated">Hook</target>
        </trans-unit>
        <trans-unit id="df83ba56b9bf84a7f6828386bfb0ec0b4ea31298" translate="yes" xml:space="preserve">
          <source>Hook &lt;strong id=&quot;hook&quot;&gt;hook&lt;/strong&gt;;</source>
          <target state="translated">Gancho &lt;strong id=&quot;hook&quot;&gt;gancho&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="c491dcee1ba5406ded29938b72d3efa58c8898bc" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values, for example &lt;code&gt;0u &amp;lt; -1&lt;/code&gt;. The call &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; is smaller than &lt;code&gt;y&lt;/code&gt; in abstract arithmetic sense.</source>
          <target state="translated">Enganche para &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;gt;=&lt;/code&gt; que garantiza que la comparaci&amp;oacute;n con valores integrales tenga el comportamiento esperado por las reglas aritm&amp;eacute;ticas habituales. La sem&amp;aacute;ntica incorporada produce un comportamiento sorprendente al comparar valores con signo con valores sin signo, por ejemplo &lt;code&gt;0u &amp;lt; -1&lt;/code&gt; . La llamada &lt;code&gt;hookOpCmp(x, y)&lt;/code&gt; devuelve &lt;code&gt;-1&lt;/code&gt; si y solo si &lt;code&gt;x&lt;/code&gt; es menor que &lt;code&gt;y&lt;/code&gt; en sentido aritm&amp;eacute;tico abstracto.</target>
        </trans-unit>
        <trans-unit id="9cf42c2609ccf8480c4c29b09d1eeb015d535402" translate="yes" xml:space="preserve">
          <source>Hook for &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values for equality, for example &lt;code&gt;uint.max == -1&lt;/code&gt; or &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt;. The call &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent the same arithmetic number.</source>
          <target state="translated">Enganche para &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;!=&lt;/code&gt; Que garantiza que la comparaci&amp;oacute;n con valores integrales tenga el comportamiento esperado por las reglas aritm&amp;eacute;ticas habituales. La sem&amp;aacute;ntica incorporada produce un comportamiento sorprendente al comparar valores con signo con valores sin signo para la igualdad, por ejemplo &lt;code&gt;uint.max == -1&lt;/code&gt; o &lt;code&gt;-1_294_967_296 == 3_000_000_000u&lt;/code&gt; . La llamada &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; si y solo si &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; representan el mismo n&amp;uacute;mero aritm&amp;eacute;tico.</target>
        </trans-unit>
        <trans-unit id="041c61fdd24218cf59730fd0cdbaa1de754b6893" translate="yes" xml:space="preserve">
          <source>Hook that implements</source>
          <target state="translated">Gancho que implementa</target>
        </trans-unit>
        <trans-unit id="b449d04fd061c7af394902d015ecf01abcf02e96" translate="yes" xml:space="preserve">
          <source>Hook that prints to &lt;code&gt;stderr&lt;/code&gt; a trace of all integral errors, without affecting default behavior.</source>
          <target state="translated">Gancho que imprime para &lt;code&gt;stderr&lt;/code&gt; un rastro de todos los errores integrales, sin afectar el comportamiento predeterminado.</target>
        </trans-unit>
        <trans-unit id="efbf28167139074d8823a898190b189c85ea78aa" translate="yes" xml:space="preserve">
          <source>Hook that provides arithmetically correct comparisons for equality and ordering. Comparing an object of type &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; against another integral (for equality or ordering) ensures that no surprising conversions from signed to unsigned integral occur before the comparison. Using &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; on either side of a comparison for equality against a floating-point number makes sure the integral can be properly converted to the floating point type, thus making sure equality is transitive.</source>
          <target state="translated">Gancho que proporciona comparaciones aritm&amp;eacute;ticamente correctas para la igualdad y el orden. La comparaci&amp;oacute;n de un objeto de tipo &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; con otra integral (para igualdad u ordenamiento) asegura que no ocurran conversiones sorprendentes de integral con signo a sin signo antes de la comparaci&amp;oacute;n. El uso de &lt;code&gt;Checked!(X, ProperCompare)&lt;/code&gt; en ambos lados de una comparaci&amp;oacute;n para la igualdad con un n&amp;uacute;mero de punto flotante asegura que la integral se pueda convertir correctamente al tipo de punto flotante, asegurando as&amp;iacute; que la igualdad sea transitiva.</target>
        </trans-unit>
        <trans-unit id="d806e6661a85f88dc9eaa221319b2117db0f755d" translate="yes" xml:space="preserve">
          <source>Hook that reserves a special value as a &quot;Not a Number&quot; representative. For signed integrals, the reserved value is &lt;code&gt;T.min&lt;/code&gt;. For signed integrals, the reserved value is &lt;code&gt;T.max&lt;/code&gt;.</source>
          <target state="translated">Gancho que se reserva un valor especial como representante &quot;No es un n&amp;uacute;mero&quot;. Para integrales con signo, el valor reservado es &lt;code&gt;T.min&lt;/code&gt; . Para integrales con signo, el valor reservado es &lt;code&gt;T.max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33488d4b3cbb5ba16b0673469e60db7094fb670e" translate="yes" xml:space="preserve">
          <source>Horizontal Rules</source>
          <target state="translated">Reglas horizontales</target>
        </trans-unit>
        <trans-unit id="7212f381e90838fabdee36fb0501fbba0ed9cd58" translate="yes" xml:space="preserve">
          <source>Horizontal tab</source>
          <target state="translated">Pestaña horizontal</target>
        </trans-unit>
        <trans-unit id="3ac6fafe4ab0f338471b45cb71f20d044e5f5cc2" translate="yes" xml:space="preserve">
          <source>Horizontal tab (U+0009).</source>
          <target state="translated">Pestaña horizontal (U+0009).</target>
        </trans-unit>
        <trans-unit id="bbb1b4f452c31b5eb2b5c0983d50e71cb342831f" translate="yes" xml:space="preserve">
          <source>Host compiler vendor string and language version.</source>
          <target state="translated">Cadena de proveedores de compiladores de host y versión de idioma.</target>
        </trans-unit>
        <trans-unit id="e118cd39d323f526da5b0f63e4f3c3b86e96af36" translate="yes" xml:space="preserve">
          <source>Hour of the day [0 - 24).</source>
          <target state="translated">Hora del día [0-24].</target>
        </trans-unit>
        <trans-unit id="47f45a8e9beb5422f5775e424c56239ab38cf0a6" translate="yes" xml:space="preserve">
          <source>Hours past midnight.</source>
          <target state="translated">Horas después de la medianoche.</target>
        </trans-unit>
        <trans-unit id="aea1f84448c4cd135127feb893d3e5b86649ead7" translate="yes" xml:space="preserve">
          <source>How Garbage Collection Works</source>
          <target state="translated">Cómo funciona la recolección de basura</target>
        </trans-unit>
        <trans-unit id="5e1ecfe3dd4c1b701a8f4295c2bd308de6db519e" translate="yes" xml:space="preserve">
          <source>How a socket is shutdown:</source>
          <target state="translated">Cómo se apaga un enchufe:</target>
        </trans-unit>
        <trans-unit id="14072cd783ee679dcd4faa9d6011722e64957f7d" translate="yes" xml:space="preserve">
          <source>How does this meet our assumptions about errors?</source>
          <target state="translated">¿Cómo cumple esto con nuestras suposiciones sobre los errores?</target>
        </trans-unit>
        <trans-unit id="2cef028c4c427db32ab248fb0fa09f711b8938d4" translate="yes" xml:space="preserve">
          <source>How does this meet our criteria?</source>
          <target state="translated">¿Cómo cumple esto con nuestros criterios?</target>
        </trans-unit>
        <trans-unit id="46c019e7726b602bf175d16d3e47d3c9855717af" translate="yes" xml:space="preserve">
          <source>How much &lt;code&gt;r&lt;/code&gt; was actually advanced, which may be less than &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;r&lt;/code&gt; did not have at least &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">Cu&amp;aacute;nto &lt;code&gt;r&lt;/code&gt; realmente se avanz&amp;oacute;, que puede ser menor que &lt;code&gt;n&lt;/code&gt; si &lt;code&gt;r&lt;/code&gt; no tuviera al menos &lt;code&gt;n&lt;/code&gt; elementos.</target>
        </trans-unit>
        <trans-unit id="39a1caec9f5c9eff0c38eb6253af004f14eeaf48" translate="yes" xml:space="preserve">
          <source>How the deprecation messages are presented to the user.</source>
          <target state="translated">Cómo se presentan los mensajes de depreciación al usuario.</target>
        </trans-unit>
        <trans-unit id="45ad0b30a0ba21c8300555e31b930fb7fa5c8e56" translate="yes" xml:space="preserve">
          <source>How to check an entire string</source>
          <target state="translated">Cómo comprobar una cadena entera</target>
        </trans-unit>
        <trans-unit id="3944bdd486c5b281b0d76b6fea24f7aa42d88928" translate="yes" xml:space="preserve">
          <source>However for class types, identity assignment is not allowed. All class types have reference semantics, so identity assignment by default rebinds the left-hand-side to the argument at the right, and this is not overridable.</source>
          <target state="translated">Sin embargo,para los tipos de clase,no se permite la asignación de identidades.Todos los tipos de clase tienen semántica de referencia,por lo que la asignación de identidad por defecto remite el lado izquierdo al argumento de la derecha,y esto no es anulable.</target>
        </trans-unit>
        <trans-unit id="d81485ead3a03b09d4ef041206a388f9ba3d1726" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; does allow reassignment, while otherwise behaving exactly like a &lt;code&gt;const Widget&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, &lt;code&gt;Rebindable!(Widget)&lt;/code&gt; permite la reasignaci&amp;oacute;n, mientras que de lo contrario se comporta exactamente como un &lt;code&gt;const Widget&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39fcf81b03ae2153072256cf5c2ed783812c0162" translate="yes" xml:space="preserve">
          <source>However, if the AA element type is a struct which supports an implicit constructor call from the assigned value, implicit construction is used for setting the AA entry:</source>
          <target state="translated">Sin embargo,si el tipo de elemento AA es una estructura que soporta una llamada implícita de constructor a partir del valor asignado,se utiliza la construcción implícita para establecer la entrada AA:</target>
        </trans-unit>
        <trans-unit id="be6cc5f771eb95dadab03bad5c4c89972ffb70a4" translate="yes" xml:space="preserve">
          <source>However, in &lt;code&gt;-betterC&lt;/code&gt;&lt;code&gt;assert&lt;/code&gt; expressions don't use Druntime's assert and are directed to &lt;code&gt;assert&lt;/code&gt; of the C runtime library instead.</source>
          <target state="translated">Sin embargo, en &lt;code&gt;-betterC&lt;/code&gt; &lt;code&gt;assert&lt;/code&gt; expresiones no utilizan aserci&amp;oacute;n de Druntime y se dirigen a la &lt;code&gt;assert&lt;/code&gt; de la biblioteca de tiempo de ejecuci&amp;oacute;n C en lugar.</target>
        </trans-unit>
        <trans-unit id="5a66b8122994e01e172373073ab6d4fa34b94942" translate="yes" xml:space="preserve">
          <source>However, it should be noted that the time zone information on Windows is frequently less accurate than that in the IANA time zone database, and if someone really wants accurate time zone information, they should use the IANA time zone database files with &lt;a href=&quot;#PosixTimeZone&quot;&gt;&lt;code&gt;PosixTimeZone&lt;/code&gt;&lt;/a&gt; on Windows rather than &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt;, whereas &lt;a href=&quot;#WindowsTimeZone&quot;&gt;&lt;code&gt;WindowsTimeZone&lt;/code&gt;&lt;/a&gt; makes more sense when trying to match what Windows will think the time is in a specific time zone.</source>
          <target state="translated">Sin embargo, debe tenerse en cuenta que la informaci&amp;oacute;n de zona horaria en Windows con frecuencia es menos precisa que la de la base de datos de zona horaria de IANA, y si alguien realmente quiere informaci&amp;oacute;n precisa de zona horaria, debe usar los archivos de base de datos de zona horaria de IANA con &lt;a href=&quot;#PosixTimeZone&quot;&gt; &lt;code&gt;PosixTimeZone&lt;/code&gt; &lt;/a&gt; en Windows que &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt; , mientras que &lt;a href=&quot;#WindowsTimeZone&quot;&gt; &lt;code&gt;WindowsTimeZone&lt;/code&gt; &lt;/a&gt; tiene m&amp;aacute;s sentido cuando intenta hacer coincidir lo que Windows pensar&amp;aacute; que es la hora en una zona horaria espec&amp;iacute;fica.</target>
        </trans-unit>
        <trans-unit id="6fe9389c4ddd121d6493079f489aee81befd5618" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Daylight Time). Regardless, it is not the same as name.</source>
          <target state="translated">Sin embargo,en Windows,puede ser el nombre no abreviado (por ejemplo,Pacific Daylight Time).Sin embargo,no es lo mismo que el nombre.</target>
        </trans-unit>
        <trans-unit id="47c13d8e213a10f9001fd45644c1b3afeb68823d" translate="yes" xml:space="preserve">
          <source>However, on Windows, it may be the unabbreviated name (e.g. Pacific Standard Time). Regardless, it is not the same as name.</source>
          <target state="translated">Sin embargo,en Windows,puede ser el nombre no abreviado (por ejemplo,Pacific Standard Time).Sin embargo,no es lo mismo que el nombre.</target>
        </trans-unit>
        <trans-unit id="eff8dd0f2d633371467a00fc8759aea595ab2872" translate="yes" xml:space="preserve">
          <source>However, when doing overload resolution, the functions in the base class are not considered:</source>
          <target state="translated">Sin embargo,al hacer la resolución de la sobrecarga,no se consideran las funciones de la clase base:</target>
        </trans-unit>
        <trans-unit id="599b7a863c6a59d1092f07e1710589a8785bdb8d" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 address in dotted-decimal form.</source>
          <target state="translated">Cadena legible por el ser humano que representa la dirección IPv4 en forma decimal punteada.</target>
        </trans-unit>
        <trans-unit id="aff39bc2ec043587101457aaa3ae19023826875e" translate="yes" xml:space="preserve">
          <source>Human readable string representing the IPv4 port.</source>
          <target state="translated">Cadena legible por el hombre que representa el puerto IPv4.</target>
        </trans-unit>
        <trans-unit id="a79746cad8ecf9d33b60d8dd5347136a9d85ef98" translate="yes" xml:space="preserve">
          <source>Human readable string representing this address.</source>
          <target state="translated">Una cadena legible por los humanos que representa esta dirección.</target>
        </trans-unit>
        <trans-unit id="4c4d996a690c3ac43662d610a18221ccc97faec3" translate="yes" xml:space="preserve">
          <source>Hyphen</source>
          <target state="translated">Hyphen</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="47af55839c3e9c9ba933349c6295cd1ce082a6a3" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;im&lt;/code&gt;</source>
          <target state="translated">Yo &lt;code&gt;im&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84ff080e0a1bf2c778d5efdc523acd4678a5928f" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;sizes&lt;/code&gt;</source>
          <target state="translated">I &lt;code&gt;sizes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4ce4e386de11613809ef416e70170284dffb219" translate="yes" xml:space="preserve">
          <source>I &lt;code&gt;startingIndex&lt;/code&gt;</source>
          <target state="translated">Yo &lt;code&gt;startingIndex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3df1df26aa4ea931d9e988f62da215ed0c3e81a7" translate="yes" xml:space="preserve">
          <source>I came, I coded, I crashed.</source>
          <target state="translated">Vine,codifiqué,me estrellé.</target>
        </trans-unit>
        <trans-unit id="81cb37800b131d16bca390e388601790ff6f313b" translate="yes" xml:space="preserve">
          <source>I.e. is it a single return statement or some compound statement that unconditionally hits a return statement.</source>
          <target state="translated">Es decir,es una declaración de retorno única o alguna declaración compuesta que golpea incondicionalmente una declaración de retorno.</target>
        </trans-unit>
        <trans-unit id="d8212950b3ac05f1c5deaff0d3a32ce51c051e7f" translate="yes" xml:space="preserve">
          <source>I/O operation successful</source>
          <target state="translated">Operación de I/O exitosa</target>
        </trans-unit>
        <trans-unit id="a07107356f25616c07b6fd35ca4ce30f409251c5" translate="yes" xml:space="preserve">
          <source>IBM Advanced Interactive eXecutive OS</source>
          <target state="translated">IBM Advanced Interactive eXecutive OS</target>
        </trans-unit>
        <trans-unit id="7e73f4b459341f6552e0a60723ed4f4fb582c963" translate="yes" xml:space="preserve">
          <source>IDS_Binary_Operator</source>
          <target state="translated">IDS_Binary_Operator</target>
        </trans-unit>
        <trans-unit id="dfddbbc74d0d43db63cde2a6e1024f6ba8221fff" translate="yes" xml:space="preserve">
          <source>IDS_Trinary_Operator</source>
          <target state="translated">IDS_Trinary_Operator</target>
        </trans-unit>
        <trans-unit id="0a50f9983af5839dd0d0dc6f249331d57b64db6f" translate="yes" xml:space="preserve">
          <source>ID_Continue</source>
          <target state="translated">ID_Continue</target>
        </trans-unit>
        <trans-unit id="92936d6f1e8f3e471e6f43d46a9887af5d007bd8" translate="yes" xml:space="preserve">
          <source>ID_Start</source>
          <target state="translated">ID_Start</target>
        </trans-unit>
        <trans-unit id="3f4e414c32b3902ba3f69c8b82e07f90e3313525" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic can set several flags based on what happened with a computation:</source>
          <target state="translated">La aritmética de punto flotante del IEEE 754 puede establecer varias banderas basadas en lo que ocurrió con un cálculo:</target>
        </trans-unit>
        <trans-unit id="ca31149be1b5f9a497eaee503fda4915c7e1c829" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point arithmetic includes the ability to set 4 different rounding modes. These are accessible via the functions in &lt;code&gt;core.stdc.fenv&lt;/code&gt;.</source>
          <target state="translated">La aritm&amp;eacute;tica de coma flotante IEEE 754 incluye la capacidad de establecer 4 modos de redondeo diferentes. Estos son accesibles a trav&amp;eacute;s de las funciones en &lt;code&gt;core.stdc.fenv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9fbff470ecc71dad6d33f5eeaccc83f4e863050" translate="yes" xml:space="preserve">
          <source>IEEE exception status flags ('sticky bits')</source>
          <target state="translated">Banderas de estado de excepción del IEEE ('bits pegajosos')</target>
        </trans-unit>
        <trans-unit id="a2584841fe85abc74e15db0f23c9cdba2dd8ab2a" translate="yes" xml:space="preserve">
          <source>IEEE hardware exceptions. By default, all exceptions are masked (disabled).</source>
          <target state="translated">Excepciones de hardware del IEEE.Por defecto,todas las excepciones están enmascaradas (deshabilitadas).</target>
        </trans-unit>
        <trans-unit id="b9e2d958b9ca41f87ae15ec8c35999c50ae4ff8c" translate="yes" xml:space="preserve">
          <source>IEEE rounding modes. The default mode is roundToNearest.</source>
          <target state="translated">Modos de redondeo del IEEE.El modo predeterminado es roundToNearest.</target>
        </trans-unit>
        <trans-unit id="7d81343ef8eab15b8d8f8c68c7c8bdb404ed88bb" translate="yes" xml:space="preserve">
          <source>ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt;;</source>
          <target state="translated">ILS &lt;strong id=&quot;inlineStatusStmt&quot;&gt;inlineStatusStmt&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="362fa36f30a060b9e1fcf247cb78ff4ce49924f2" translate="yes" xml:space="preserve">
          <source>IMP</source>
          <target state="translated">IMP</target>
        </trans-unit>
        <trans-unit id="bdc4004339f8557d5a75257afe0bb8aef0ebaaba" translate="yes" xml:space="preserve">
          <source>IP multicast hops</source>
          <target state="translated">Saltos IP multicast</target>
        </trans-unit>
        <trans-unit id="20fe7e463770b20399ece7b586c1bbb5d3def572" translate="yes" xml:space="preserve">
          <source>IP multicast interface</source>
          <target state="translated">Interfaz IP multicast</target>
        </trans-unit>
        <trans-unit id="7279e4b3160656f1f51a778df4e83b92cb83cf30" translate="yes" xml:space="preserve">
          <source>IP multicast loopback</source>
          <target state="translated">IP multicast loopback</target>
        </trans-unit>
        <trans-unit id="9ebd1fbe7ba3cf5bdc775290d0d686e15bf4c0b2" translate="yes" xml:space="preserve">
          <source>IP unicast hop limit</source>
          <target state="translated">Límite de salto unicast IP</target>
        </trans-unit>
        <trans-unit id="cc01b492cee0acdf48f0b298c26fa47256bd3faf" translate="yes" xml:space="preserve">
          <source>IPA Extensions</source>
          <target state="translated">Extensiones del IPA</target>
        </trans-unit>
        <trans-unit id="80570baac1433d8da38eb560349f85ffa3c24938" translate="yes" xml:space="preserve">
          <source>IPv6 address ends with a single colon</source>
          <target state="translated">La dirección IPv6 termina con un solo dos puntos</target>
        </trans-unit>
        <trans-unit id="f971f61e6734e2eb397d8944032e3b5547c71b4c" translate="yes" xml:space="preserve">
          <source>IPv6 address starts with a single colon</source>
          <target state="translated">La dirección IPv6 comienza con un solo dos puntos</target>
        </trans-unit>
        <trans-unit id="ffeae36229b4084ab3f5431d5a5e2894acff57f8" translate="yes" xml:space="preserve">
          <source>IPv6-enabled</source>
          <target state="translated">IPv6-enabled</target>
        </trans-unit>
        <trans-unit id="ae9887477b5a4dc86ce15b0c56db938ec92c9140" translate="yes" xml:space="preserve">
          <source>IRState* &lt;code&gt;irs&lt;/code&gt;</source>
          <target state="translated">IRState * &lt;code&gt;irs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="0f3e173e17d8fbdbf144076143d8cd16c3b60805" translate="yes" xml:space="preserve">
          <source>ISO Week Date</source>
          <target state="translated">Fecha de la semana ISO</target>
        </trans-unit>
        <trans-unit id="6edb4ac9bcba71ad7ccb4ee02897a84fda819a4e" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)</source>
          <target state="translated">ISO/IEC 9899:1999 (E)</target>
        </trans-unit>
        <trans-unit id="8e40d146e834aa0554ad9d258a39d303ac74b95c" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999 (E)  These are the various functions called by the assert() macro. They are all noreturn functions, although D doesn't have a specific attribute for that.</source>
          <target state="translated">ISO/IEC 9899:1999 (E)Estas son las diversas funciones llamadas por la macro assert().Todas son funciones de noreturn,aunque D no tiene un atributo específico para eso.</target>
        </trans-unit>
        <trans-unit id="79c91cb6efbe5dfcc03f77ea0bf59ceecfb03a1b" translate="yes" xml:space="preserve">
          <source>Iain Buclaw</source>
          <target state="translated">Iain Buclaw</target>
        </trans-unit>
        <trans-unit id="a61268b8e652624d626d166308f20560b1d3aa63" translate="yes" xml:space="preserve">
          <source>Id::max or Id::min</source>
          <target state="translated">Id::max o Id::min</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="d884429135c14548b3e978b368447365cb96cfc8" translate="yes" xml:space="preserve">
          <source>Identifier (inside Identifier.idPool) with deterministic name based on the source location.</source>
          <target state="translated">Identificador (dentro de Identifier.idPool)con nombre determinante basado en la ubicación de la fuente.</target>
        </trans-unit>
        <trans-unit id="d39412a656d9c3c7bf8a3a174965f8e76b9c6aae" translate="yes" xml:space="preserve">
          <source>Identifier : NonVoidInitializer</source>
          <target state="translated">Identificar:NonVoidInitializer</target>
        </trans-unit>
        <trans-unit id="2ea823871928966eb34d2d6331730d76f54cfc52" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;id&lt;/code&gt;</source>
          <target state="translated">Identificaci&amp;oacute;n del &lt;code&gt;id&lt;/code&gt; entificador</target>
        </trans-unit>
        <trans-unit id="fd812024edf80fc26687c86baab342484d1cca2a" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;ident&lt;/code&gt;</source>
          <target state="translated">Identificador &lt;code&gt;ident&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f032313123f1ffabc6636b37a2cdfb763957f48d" translate="yes" xml:space="preserve">
          <source>Identifier &lt;code&gt;module_&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;module_&lt;/code&gt; identificador_</target>
        </trans-unit>
        <trans-unit id="0ff20fb48822c4ece471eaa71420a8e3f17752e0" translate="yes" xml:space="preserve">
          <source>Identifier &lt;strong id=&quot;identifier&quot;&gt;identifier&lt;/strong&gt;;</source>
          <target state="translated">Identificador &lt;strong id=&quot;identifier&quot;&gt;identificador&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="964e8904f66adfee7e7841e9b8d4ec24e389fed4" translate="yes" xml:space="preserve">
          <source>Identifier Emphasis</source>
          <target state="translated">Énfasis en el identificador</target>
        </trans-unit>
        <trans-unit id="57fd2f9988cc1bead6d88fdd99fa28550daa5071" translate="yes" xml:space="preserve">
          <source>Identifier required for this condition to pass. If &lt;code&gt;null&lt;/code&gt;, this conditiion will use an integer level.</source>
          <target state="translated">Identificador requerido para que esta condici&amp;oacute;n pase. Si es &lt;code&gt;null&lt;/code&gt; , esta condici&amp;oacute;n usar&amp;aacute; un nivel entero.</target>
        </trans-unit>
        <trans-unit id="72a03d37bdb5a52d9cfa01295909001833684faa" translate="yes" xml:space="preserve">
          <source>Identifier value (e.g. &lt;code&gt;Id.unitTest&lt;/code&gt;) or &lt;code&gt;TOK.identifier&lt;/code&gt;</source>
          <target state="translated">Valor del identificador (por ejemplo, &lt;code&gt;Id.unitTest&lt;/code&gt; ) o &lt;code&gt;TOK.identifier&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22dcd4202be0468eb915e08817484731c04ef629" translate="yes" xml:space="preserve">
          <source>IdentifierList</source>
          <target state="translated">IdentifierList</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="29849b8a9887214097873771c1ada1e4a2b26c67" translate="yes" xml:space="preserve">
          <source>Identifiers in documentation comments that are function parameters or are names that are in scope at the associated declaration are emphasized in the output. This emphasis can take the form of italics, boldface, a hyperlink, etc. How it is emphasized depends on what it is</source>
          <target state="translated">Los identificadores en los comentarios de la documentación que son parámetros de la función o son nombres que están en el ámbito de la declaración asociada se destacan en el resultado.Este énfasis puede tomar la forma de cursiva,negrita,un hipervínculo,etc.La forma en que se hace hincapié depende de lo que sea</target>
        </trans-unit>
        <trans-unit id="ee26ed57025d5c31d0bf47a619bdb084494918ff" translate="yes" xml:space="preserve">
          <source>Identifiers start with a letter, &lt;code&gt;_&lt;/code&gt;, or universal alpha, and are followed by any number of letters, &lt;code&gt;_&lt;/code&gt;, digits, or universal alphas. Universal alphas are as defined in ISO/IEC 9899:1999(E) Appendix D of the C99 Standard. Identifiers can be arbitrarily long, and are case sensitive.</source>
          <target state="translated">Los identificadores comienzan con una letra, &lt;code&gt;_&lt;/code&gt; o alfa universal, y son seguidos por cualquier n&amp;uacute;mero de letras, &lt;code&gt;_&lt;/code&gt; , d&amp;iacute;gitos o alfa universales. Los alfa universales son los definidos en ISO / IEC 9899: 1999 (E) Ap&amp;eacute;ndice D de la Norma C99. Los identificadores pueden ser arbitrariamente largos y distinguen entre may&amp;uacute;sculas y min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="745651339d520944f46b951509355e65410d85d8" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;ids&lt;/code&gt;</source>
          <target state="translated">Identificadores * &lt;code&gt;ids&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8bce0759953389b7f6673a7b1dcdcbe2f5adafd6" translate="yes" xml:space="preserve">
          <source>Identifiers* &lt;code&gt;pkg_identifiers&lt;/code&gt;</source>
          <target state="translated">Identificadores * &lt;code&gt;pkg_identifiers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd196121fbac89b149b3c74f08384f1bdda01148" translate="yes" xml:space="preserve">
          <source>Identify Statement types with this enum rather than virtual functions.</source>
          <target state="translated">Identificar los tipos de declaración con esta enumeración en lugar de las funciones virtuales.</target>
        </trans-unit>
        <trans-unit id="897cc900af9b1d4567cf3ac949c0ce028e5b29c4" translate="yes" xml:space="preserve">
          <source>Identify the characteristics of the host CPU, providing information about cache sizes and assembly optimisation hints. This module is provided primarily for assembly language programmers.</source>
          <target state="translated">Identificar las características de la CPU anfitriona,proporcionando información sobre los tamaños de la caché y consejos para la optimización del montaje.Este módulo se proporciona principalmente para los programadores de lenguaje ensamblador.</target>
        </trans-unit>
        <trans-unit id="294c861b2aa613142591a5192af15c07f9d87cde" translate="yes" xml:space="preserve">
          <source>Identify the compiler used and its various features.</source>
          <target state="translated">Identificar el compilador utilizado y sus diversas características.</target>
        </trans-unit>
        <trans-unit id="2adbbf9ddb856b5eee69eb90a8ddc235f490d75b" translate="yes" xml:space="preserve">
          <source>Identify whether a variable is defined in the environment.</source>
          <target state="translated">Identificar si una variable está definida en el entorno.</target>
        </trans-unit>
        <trans-unit id="560e8754d1a43d2889127379ce8941035430acdf" translate="yes" xml:space="preserve">
          <source>Identity Assignment Overload</source>
          <target state="translated">Sobrecarga en la asignación de identidades</target>
        </trans-unit>
        <trans-unit id="feaad94f17d0151c7ee9d808da8437d06bd6ced9" translate="yes" xml:space="preserve">
          <source>Identity Expressions</source>
          <target state="translated">Expresiones de identidad</target>
        </trans-unit>
        <trans-unit id="3541f48427fcdd81e30c7c16278c379163644459" translate="yes" xml:space="preserve">
          <source>Ideographic</source>
          <target state="translated">Ideographic</target>
        </trans-unit>
        <trans-unit id="5b6b53689a3fc635c459675544040944bd74d306" translate="yes" xml:space="preserve">
          <source>Ideographic Description Characters</source>
          <target state="translated">Descripción Ideográfica Personajes</target>
        </trans-unit>
        <trans-unit id="250ad5161fad3e8519e80733a4a75b5049da3f8e" translate="yes" xml:space="preserve">
          <source>Idiomatic Use of &lt;code&gt;std.experimental.allocator&lt;/code&gt;</source>
          <target state="translated">Uso idiom&amp;aacute;tico de &lt;code&gt;std.experimental.allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="828467146cd8af7a4600851262e42a7b8fdfff46" translate="yes" xml:space="preserve">
          <source>If !is null, elements[] can be sparse and basis is used for the &quot;default&quot; element value. In other words, non-null elements[i] overrides this 'basis' value.</source>
          <target state="translated">Si !es nulo,los elementos[]pueden ser escasos y se utiliza la base para el valor &quot;por defecto&quot; del elemento.En otras palabras,los elementos no nulos[i]anulan este valor &quot;base&quot;.</target>
        </trans-unit>
        <trans-unit id="9ddd459237f2459c44b509144a91e81da646bb40" translate="yes" xml:space="preserve">
          <source>If 'e' is a tree of commas, returns the rightmost expression by stripping off it from the tree. The remained part of the tree is returned via e0. Otherwise 'e' is directly returned and e0 is set to NULL.</source>
          <target state="translated">Si &quot;e&quot; es un árbol de comas,devuelve la expresión más correcta quitándola del árbol.La parte que queda del árbol es devuelta a través de la &quot;e0&quot;.Si no,&quot;e&quot; es devuelta directamente y &quot;e0&quot; es puesta en NULL.</target>
        </trans-unit>
        <trans-unit id="1b4dc8c105f5a3f750e979db674fe11913e62d44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt;&lt;code&gt;std.range.primitives.ElementType&lt;/code&gt;&lt;/a&gt;!R is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;random-access range&lt;/a&gt; with length and slicing, then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;pairwise summation&lt;/a&gt; algorithm.</source>
          <target state="translated">Si &lt;a href=&quot;std_range_primitives#ElementType&quot;&gt; &lt;code&gt;std.range.primitives.ElementType&lt;/code&gt; &lt;/a&gt; ! R es un tipo de punto flotante y &lt;code&gt;R&lt;/code&gt; es un &lt;a href=&quot;std_range_primitives#isRandomAccessRange&quot;&gt;rango de acceso aleatorio&lt;/a&gt; con longitud y corte, entonces &lt;code&gt;sum&lt;/code&gt; usa el algoritmo de &lt;a href=&quot;http://en.wikipedia.org/wiki/Pairwise_summation&quot;&gt;suma por pares&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c45083751ac69c2e8e598d9798f65c4de37c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!!value&lt;/code&gt; is true, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; is thrown. &lt;code&gt;WindowsException&lt;/code&gt; assumes that the last operation set &lt;code&gt;GetLastError()&lt;/code&gt; appropriately.</source>
          <target state="translated">Si &lt;code&gt;!!value&lt;/code&gt; es verdadero, se devuelve el &lt;code&gt;value&lt;/code&gt; . De lo contrario, se &lt;code&gt;new WindowsException(GetLastError(), msg)&lt;/code&gt; . &lt;code&gt;WindowsException&lt;/code&gt; supone que la &amp;uacute;ltima operaci&amp;oacute;n estableci&amp;oacute; &lt;code&gt;GetLastError()&lt;/code&gt; adecuada.</target>
        </trans-unit>
        <trans-unit id="8df9d33ad5bc28652f3433433542fda31081bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!isInfinite!Source&lt;/code&gt; and &lt;code&gt;source.walkLength&lt;/code&gt; is not evenly divisible by &lt;code&gt;chunkSize&lt;/code&gt;, the back element of this range will contain fewer than &lt;code&gt;chunkSize&lt;/code&gt; elements.</source>
          <target state="translated">Si &lt;code&gt;!isInfinite!Source&lt;/code&gt; y &lt;code&gt;source.walkLength&lt;/code&gt; no es divisible por &lt;code&gt;chunkSize&lt;/code&gt; , el elemento posterior de este rango contendr&amp;aacute; menos elementos que &lt;code&gt;chunkSize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da45e2d8d90136b7f84f13e1858fb6ece371b4b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is returned. Otherwise, &lt;code&gt;new E(msg, file, line)&lt;/code&gt; is thrown. Or if &lt;code&gt;E&lt;/code&gt; doesn't take a message and can be constructed with &lt;code&gt;new E(file, line)&lt;/code&gt;, then &lt;code&gt;new E(file, line)&lt;/code&gt; will be thrown.</source>
          <target state="translated">Si &lt;code&gt;!value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , se devuelve el &lt;code&gt;value&lt;/code&gt; . De lo contrario, se lanza una &lt;code&gt;new E(msg, file, line)&lt;/code&gt; . O si &lt;code&gt;E&lt;/code&gt; no toma un mensaje y puede construirse con una &lt;code&gt;new E(file, line)&lt;/code&gt; , se generar&amp;aacute; una &lt;code&gt;new E(file, line)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ae58cb23b72d887da98d9fdd1704ba37b0874fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@live&lt;/code&gt; functions call non-&lt;code&gt;@live&lt;/code&gt; functions, those called functions are expected to present an &lt;code&gt;@live&lt;/code&gt; compatible interface, although it is not checked. if non-&lt;code&gt;@live&lt;/code&gt; functions call &lt;code&gt;@live&lt;/code&gt; functions, arguments passed are expected to follow &lt;code&gt;@live&lt;/code&gt; conventions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70bac81fdcc8ee63f8a6ffecb44cdbcf2f794c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no state, the resulting object is allocated in static shared storage.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; no tiene estado, el objeto resultante se asigna en almacenamiento compartido est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="7b2c6010fe0ff7fc814ba13aa84690947c8cb83d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is copyable, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; tiene estado y es copiable, el resultado &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; el asignador &lt;code&gt;A a&lt;/code&gt; suministrado dentro. El resultado en s&amp;iacute; mismo se asigna en su propio asignador est&amp;aacute;ticamente tipado.</target>
        </trans-unit>
        <trans-unit id="e90491f805af73197e670ba7dcdbdea4f3f9187b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state and is not copyable, the result will move the passed-in argument into the result. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; tiene estado y no es copiable, el resultado mover&amp;aacute; el argumento pasado al resultado. El resultado en s&amp;iacute; mismo se asigna en su propio asignador est&amp;aacute;ticamente tipado.</target>
        </trans-unit>
        <trans-unit id="8e3921430ef3c9cb639e4397d8b838ecfe391c50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has state, the result will &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt;&lt;code&gt;std.algorithm.mutation.move&lt;/code&gt;&lt;/a&gt; the supplied allocator &lt;code&gt;A a&lt;/code&gt; within. The result itself is allocated in its own statically-typed allocator.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; tiene estado, el resultado &lt;a href=&quot;std_algorithm_mutation#move&quot;&gt; &lt;code&gt;std.algorithm.mutation.move&lt;/code&gt; &lt;/a&gt; el asignador suministrado &lt;code&gt;A a&lt;/code&gt; dentro. El resultado en s&amp;iacute; mismo se asigna en su propio asignador est&amp;aacute;ticamente tipado.</target>
        </trans-unit>
        <trans-unit id="85c9db39cbb0a223dde8b65577a816ac4ae74ca1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Allocator&lt;/code&gt; implements &lt;code&gt;owns&lt;/code&gt;, forwards to it. Otherwise, returns &lt;code&gt;Ternary.unknown&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Allocator&lt;/code&gt; implementa &lt;code&gt;owns&lt;/code&gt; , reenv&amp;iacute;a a &amp;eacute;l. De lo contrario, devuelve &lt;code&gt;Ternary.unknown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="602c75c69645dadebf41e326ef28dced33652078" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BookkeepingAllocator&lt;/code&gt; is not &lt;code&gt;NullAllocator&lt;/code&gt;, &lt;code&gt;bkalloc&lt;/code&gt; is defined and accessible.</source>
          <target state="translated">Si &lt;code&gt;BookkeepingAllocator&lt;/code&gt; no es &lt;code&gt;NullAllocator&lt;/code&gt; , &lt;code&gt;bkalloc&lt;/code&gt; est&amp;aacute; definido y accesible.</target>
        </trans-unit>
        <trans-unit id="e61003ea748193c575ad061853d1dd56eb5e4c1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ElementType!R&lt;/code&gt; is a floating-point type and &lt;code&gt;R&lt;/code&gt; is a finite input range (but not a random-access range with slicing), then &lt;code&gt;sum&lt;/code&gt; uses the &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;Kahan summation&lt;/a&gt; algorithm.</source>
          <target state="translated">Si &lt;code&gt;ElementType!R&lt;/code&gt; es un tipo de punto flotante y &lt;code&gt;R&lt;/code&gt; es un rango de entrada finito (pero no un rango de acceso aleatorio con segmentaci&amp;oacute;n), entonces &lt;code&gt;sum&lt;/code&gt; usa el algoritmo de &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation&quot;&gt;suma Kahan&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e00af2edb93d47ac443e7418f444a801ea32bd2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;max&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">Si &lt;code&gt;FreeList&lt;/code&gt; se ha instanciado con &lt;code&gt;maxSize == chooseAtRuntime&lt;/code&gt; , entonces la propiedad &lt;code&gt;max&lt;/code&gt; se puede escribir. Establecerlo debe preceder a cualquier asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="619bff2f62db09894cc368f16063c71698b3e91a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FreeList&lt;/code&gt; has been instantiated with &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt;, then the &lt;code&gt;min&lt;/code&gt; property is writable. Setting it must precede any allocation.</source>
          <target state="translated">Si &lt;code&gt;FreeList&lt;/code&gt; se ha instanciado con &lt;code&gt;minSize == chooseAtRuntime&lt;/code&gt; , entonces la propiedad &lt;code&gt;min&lt;/code&gt; se puede escribir. Establecerlo debe preceder a cualquier asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="614802dd9535195f4c34d795221ff4407109b94d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;hookOpOpAssign&lt;/code&gt;, &lt;code&gt;opOpAssign&lt;/code&gt; forwards to &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt;, where &lt;code&gt;payload&lt;/code&gt; is a reference to the internally held data so the hook can change it.</source>
          <target state="translated">Si &lt;code&gt;Hook&lt;/code&gt; define &lt;code&gt;hookOpOpAssign&lt;/code&gt; , &lt;code&gt;opOpAssign&lt;/code&gt; reenv&amp;iacute;a a &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; , donde la &lt;code&gt;payload&lt;/code&gt; es una referencia a los datos internos para que el gancho pueda cambiarla.</target>
        </trans-unit>
        <trans-unit id="6213f7b3e2cf0b3c2b2e856da1c03c2c3603a41e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opBinary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; in case an overflow occurs.</source>
          <target state="translated">Si &lt;code&gt;Hook&lt;/code&gt; no define &lt;code&gt;hookOpBinary&lt;/code&gt; pero define &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opBinary&lt;/code&gt; reenv&amp;iacute;a a &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; en caso de que ocurra un desbordamiento.</target>
        </trans-unit>
        <trans-unit id="48a7fb4afe12c2822acfff866c271812d59b89d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpUnary&lt;/code&gt; but defines &lt;code&gt;onOverflow&lt;/code&gt;, &lt;code&gt;opUnary&lt;/code&gt; forwards to &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; in case an overflow occurs. For &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, the payload is assigned from the result of the call to &lt;code&gt;onOverflow&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Hook&lt;/code&gt; no define &lt;code&gt;hookOpUnary&lt;/code&gt; pero define &lt;code&gt;onOverflow&lt;/code&gt; , &lt;code&gt;opUnary&lt;/code&gt; reenv&amp;iacute;a a &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; en caso de que ocurra un desbordamiento. Para &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; , la carga &amp;uacute;til se asigna del resultado de la llamada a &lt;code&gt;onOverflow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10cd8aa857d486ec2d02cef4465f8ceb45e4e90d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; holds state, &lt;code&gt;parent&lt;/code&gt; is a public member of type &lt;code&gt;KRRegion&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an &lt;code&gt;alias&lt;/code&gt; for &lt;code&gt;ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ParentAllocator&lt;/code&gt; posee el estado, &lt;code&gt;parent&lt;/code&gt; es un miembro p&amp;uacute;blico de tipo &lt;code&gt;KRRegion&lt;/code&gt; . De lo contrario, &lt;code&gt;parent&lt;/code&gt; es un &lt;code&gt;alias&lt;/code&gt; para &lt;code&gt;ParentAllocator.instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bbccd514894e82c4ce13569d09888036cf3359f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, only the constructor taking &lt;code&gt;data&lt;/code&gt; is defined and the user is responsible for freeing &lt;code&gt;data&lt;/code&gt; if desired.</source>
          <target state="translated">Si &lt;code&gt;ParentAllocator&lt;/code&gt; es &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , s&amp;oacute;lo el constructor toma &lt;code&gt;data&lt;/code&gt; se define y el usuario es responsable de liberar &lt;code&gt;data&lt;/code&gt; si se desea.</target>
        </trans-unit>
        <trans-unit id="d42312f5e4b477adba48781c375b173d6250fd1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is different from &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt;&lt;code&gt;NullAllocator&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Region&lt;/code&gt; deallocates the chunk of memory during destruction.</source>
          <target state="translated">Si &lt;code&gt;ParentAllocator&lt;/code&gt; es diferente de &lt;a href=&quot;std_experimental_allocator_building_blocks_null_allocator#NullAllocator&quot;&gt; &lt;code&gt;NullAllocator&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Region&lt;/code&gt; desasigna la porci&amp;oacute;n de memoria durante la destrucci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9a65e34991edf1fabbde944025e9467eaa28acfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ParentAllocator&lt;/code&gt; is stateful, &lt;code&gt;parent&lt;/code&gt; is a property giving access to an &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt;. Otherwise, &lt;code&gt;parent&lt;/code&gt; is an alias for &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ParentAllocator&lt;/code&gt; tiene estado, &lt;code&gt;parent&lt;/code&gt; es una propiedad que da acceso a un &lt;code&gt;AffixAllocator!ParentAllocator&lt;/code&gt; . De lo contrario, &lt;code&gt;parent&lt;/code&gt; es un alias para &lt;code&gt;AffixAllocator!ParentAllocator.instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d333c4fd79ece4dce7180ff004a1dd304cfda4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is &lt;code&gt;void&lt;/code&gt;, the alignment is that of the parent. Otherwise, the alignment is the same as the &lt;code&gt;Prefix&lt;/code&gt;'s alignment.</source>
          <target state="translated">Si &lt;code&gt;Prefix&lt;/code&gt; es &lt;code&gt;void&lt;/code&gt; , la alineaci&amp;oacute;n es la del padre. De lo contrario, la alineaci&amp;oacute;n es la misma que la del &lt;code&gt;Prefix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ef958a14b28e8a87e35d39d726513cf1a24e3ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is not &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;Allocator&lt;/code&gt; must guarantee an alignment at least as large as &lt;code&gt;Prefix.alignof&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Prefix&lt;/code&gt; no es &lt;code&gt;void&lt;/code&gt; , &lt;code&gt;Allocator&lt;/code&gt; debe garantizar una alineaci&amp;oacute;n al menos tan grande como &lt;code&gt;Prefix.alignof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bde56d414db390f6de687beeb6a7de19e32b07b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; defines a destructor, the generated code for &lt;code&gt;opAssign&lt;/code&gt; is:</source>
          <target state="translated">Si &lt;code&gt;S&lt;/code&gt; define un destructor, el c&amp;oacute;digo generado para &lt;code&gt;opAssign&lt;/code&gt; es:</target>
        </trans-unit>
        <trans-unit id="8fa12abad24500172f1e1f4de478a1e097e94f32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; does not have a postblit or a destructor, but contains at least one field that defines an &lt;code&gt;opAssign&lt;/code&gt; function (which is not disabled), then the body will make member-wise assignments:</source>
          <target state="translated">Si &lt;code&gt;S&lt;/code&gt; no tiene un postblit o un destructor, pero contiene al menos un campo que define una funci&amp;oacute;n &lt;code&gt;opAssign&lt;/code&gt; (que no est&amp;aacute; deshabilitada), entonces el cuerpo realizar&amp;aacute; asignaciones para miembros:</target>
        </trans-unit>
        <trans-unit id="135d5e0bd9ac5cff9f359e01e49ee96d18ba1175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S&lt;/code&gt; has a disabled destructor or at least one field that has a disabled &lt;code&gt;opAssign&lt;/code&gt;, &lt;code&gt;S.opAssign&lt;/code&gt; is going to be generated, but marked with &lt;code&gt;@disable&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;S&lt;/code&gt; tiene un destructor deshabilitado o al menos un campo que tiene un &lt;code&gt;opAssign&lt;/code&gt; deshabilitado , se &lt;code&gt;S.opAssign&lt;/code&gt; , pero se marcar&amp;aacute; con &lt;code&gt;@disable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5d3671bcdce32a3ae79160f07ed6d9617aa8c77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; has structural conformance with the &lt;code&gt;interface&lt;/code&gt;&lt;code&gt;Targets&lt;/code&gt;, wrap creates an internal wrapper class which inherits &lt;code&gt;Targets&lt;/code&gt; and wraps the &lt;code&gt;src&lt;/code&gt; object, then returns it.</source>
          <target state="translated">Si &lt;code&gt;Source&lt;/code&gt; tiene conformidad estructural con los &lt;code&gt;Targets&lt;/code&gt; la &lt;code&gt;interface&lt;/code&gt; , wrap crea una clase de contenedor interno que hereda los &lt;code&gt;Targets&lt;/code&gt; y ajusta el objeto &lt;code&gt;src&lt;/code&gt; , luego lo devuelve.</target>
        </trans-unit>
        <trans-unit id="a6a1c6b133b0871dee66034a379d92385c6acfa0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting chunks will be input ranges consuming the same input: iterating over &lt;code&gt;front&lt;/code&gt; will shrink the chunk such that subsequent invocations of &lt;code&gt;front&lt;/code&gt; will no longer return the full chunk, and calling &lt;code&gt;popFront&lt;/code&gt; on the outer range will invalidate any lingering references to previous values of &lt;code&gt;front&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Source&lt;/code&gt; es un rango directo, el rango resultante ser&amp;aacute; tambi&amp;eacute;n rangos directos. De lo contrario, los fragmentos resultantes ser&amp;aacute;n rangos de entrada que consuman la misma entrada: iterar sobre el &lt;code&gt;front&lt;/code&gt; reducir&amp;aacute; el fragmento de manera que las invocaciones posteriores del &lt;code&gt;front&lt;/code&gt; ya no devolver&amp;aacute;n el fragmento completo, y llamar a &lt;code&gt;popFront&lt;/code&gt; en el rango externo invalidar&amp;aacute; cualquier referencia persistente a valores anteriores de &lt;code&gt;front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68e4c36f3a209b42eda6036b89cfd912aefdf8d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;StopWatch.init&lt;/code&gt; is used, then the constructed StopWatch isn't running (and can't be, since no constructor ran).</source>
          <target state="translated">Si se utiliza &lt;code&gt;StopWatch.init&lt;/code&gt; , entonces el StopWatch construido no se est&amp;aacute; ejecutando (y no se puede ejecutar, ya que no se ejecut&amp;oacute; ning&amp;uacute;n constructor).</target>
        </trans-unit>
        <trans-unit id="8fa16aaee056c365a9ba1b96bbf4c7ab3e0c7909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Store&lt;/code&gt; is a range, the &lt;code&gt;BinaryHeap&lt;/code&gt; cannot grow beyond the size of that range. If &lt;code&gt;Store&lt;/code&gt; is a container that supports &lt;code&gt;insertBack&lt;/code&gt;, the &lt;code&gt;BinaryHeap&lt;/code&gt; may grow by adding elements to the container.</source>
          <target state="translated">Si &lt;code&gt;Store&lt;/code&gt; es un rango, &lt;code&gt;BinaryHeap&lt;/code&gt; no puede crecer m&amp;aacute;s all&amp;aacute; del tama&amp;ntilde;o de ese rango. Si &lt;code&gt;Store&lt;/code&gt; es un contenedor que admite &lt;code&gt;insertBack&lt;/code&gt; , &lt;code&gt;BinaryHeap&lt;/code&gt; puede crecer agregando elementos al contenedor.</target>
        </trans-unit>
        <trans-unit id="dbe0360bc543f33ed0b90fcff8d9687e9b9ea633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, returns a reference to the created &lt;code&gt;T&lt;/code&gt; object. Otherwise, returns a &lt;code&gt;T*&lt;/code&gt; pointing to the created object. In all cases, returns &lt;code&gt;null&lt;/code&gt; if allocation failed.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de clase, devuelve una referencia al objeto &lt;code&gt;T&lt;/code&gt; creado . De lo contrario, devuelve una &lt;code&gt;T*&lt;/code&gt; apuntando al objeto creado. En todos los casos, devuelve &lt;code&gt;null&lt;/code&gt; si la asignaci&amp;oacute;n falla.</target>
        </trans-unit>
        <trans-unit id="85b009305a8588231d9cf9c49742c5425d7c6707" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a nested struct, the context pointer in &lt;code&gt;T.init&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una estructura anidada, el puntero de contexto en &lt;code&gt;T.init&lt;/code&gt; es &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86a83fbe1dd6e8e6329df1be326be31fbac7542c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct which has &lt;code&gt;@disable this();&lt;/code&gt;, &lt;code&gt;T.init&lt;/code&gt; might return a logically incorrect object.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una estructura que tiene &lt;code&gt;@disable this();&lt;/code&gt; , &lt;code&gt;T.init&lt;/code&gt; podr&amp;iacute;a devolver un objeto l&amp;oacute;gicamente incorrecto.</target>
        </trans-unit>
        <trans-unit id="28ecbbbd57ec70df9468c10b69230725191bde07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a struct with a destructor or postblit defined, source is reset to its &lt;code&gt;.init&lt;/code&gt; value after it is moved into target, otherwise it is left unchanged.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una estructura con un destructor o postblit definido, la fuente se restablece a su valor &lt;code&gt;.init&lt;/code&gt; despu&amp;eacute;s de que se mueve al destino, de lo contrario se deja sin cambios.</target>
        </trans-unit>
        <trans-unit id="be0ddbf38059d4859dc637f9816765cfecd51bd9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a value type, then &lt;code&gt;Unique!T&lt;/code&gt; will be implemented as a reference to a &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de valor, entonces &lt;code&gt;Unique!T&lt;/code&gt; ser&amp;aacute; implementado como una referencia a una &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ad884b639da3b067a89fc2f9254b6e884145e3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an inner class whose &lt;code&gt;outer&lt;/code&gt; field can be used to access an instance of the enclosing class, then &lt;code&gt;Args&lt;/code&gt; must not be empty, and the first member of it must be a valid initializer for that &lt;code&gt;outer&lt;/code&gt; field. Correct initialization of this field is essential to access members of the outer class inside &lt;code&gt;T&lt;/code&gt; methods.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una clase interna cuyo campo &lt;code&gt;outer&lt;/code&gt; se puede utilizar para acceder a una instancia de la clase que lo encierra, entonces &lt;code&gt;Args&lt;/code&gt; no debe estar vac&amp;iacute;o, y el primer miembro debe ser un inicializador v&amp;aacute;lido para ese campo &lt;code&gt;outer&lt;/code&gt; . La inicializaci&amp;oacute;n correcta de este campo es esencial para acceder a los miembros de la clase externa dentro de &lt;code&gt;T&lt;/code&gt; m&amp;eacute;todos T.</target>
        </trans-unit>
        <trans-unit id="5e5dca16a0b08e551a0873d6f42ddf6d816c0620" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s constructor throws, deallocates the allocated memory and propagates the exception.</source>
          <target state="translated">Si el constructor de &lt;code&gt;T&lt;/code&gt; arroja, desasigna la memoria asignada y propaga la excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f9ccf6d42185874390122acb61e0fffade4a1d7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpCmp&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">Si &lt;code&gt;U&lt;/code&gt; tambi&amp;eacute;n es una instancia de &lt;code&gt;Checked&lt;/code&gt; , ambos ganchos (lado izquierdo y derecho) son introspectivos para el m&amp;eacute;todo &lt;code&gt;hookOpCmp&lt;/code&gt; . Si ambos lo definen, se da prioridad al lado izquierdo.</target>
        </trans-unit>
        <trans-unit id="f714d4a1a2b46c6585bd14b3632f61dc774fe527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; is also an instance of &lt;code&gt;Checked&lt;/code&gt;, both hooks (left- and right-hand side) are introspected for the method &lt;code&gt;hookOpEquals&lt;/code&gt;. If both define it, priority is given to the left-hand side.</source>
          <target state="translated">Si &lt;code&gt;U&lt;/code&gt; tambi&amp;eacute;n es una instancia de &lt;code&gt;Checked&lt;/code&gt; , ambos ganchos (lado izquierdo y derecho) son introspectivos para el m&amp;eacute;todo &lt;code&gt;hookOpEquals&lt;/code&gt; . Si ambos lo definen, se da prioridad al lado izquierdo.</target>
        </trans-unit>
        <trans-unit id="6530603e838c2a2e64b1bcfb9217be83aec2dafc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.checkDns&lt;/code&gt; then a DNS check for MX records will be made</source>
          <target state="translated">Si la &lt;code&gt;Yes.checkDns&lt;/code&gt; es Yes.checkDns, se realizar&amp;aacute; una comprobaci&amp;oacute;n de DNS para los registros MX</target>
        </trans-unit>
        <trans-unit id="a1992ec3ad4038c0370a2f08b90896545a010903" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Si es &lt;code&gt;Yes.pipeOnPop&lt;/code&gt; , simplemente iterar el rango sin llamar al &lt;code&gt;front&lt;/code&gt; es suficiente para tener elementos de espejo en &lt;code&gt;tee&lt;/code&gt; para &lt;code&gt;outputRange&lt;/code&gt; (o, respectivamente, &lt;code&gt;fun&lt;/code&gt; ). Si &lt;code&gt;No.pipeOnPop&lt;/code&gt; , solo los elementos para los que se llama al &lt;code&gt;front&lt;/code&gt; tambi&amp;eacute;n se enviar&amp;aacute;n a &lt;code&gt;outputRange&lt;/code&gt; / &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a50176d4624d41b95b9071257e16a7702021f98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Yes.pipeOnPop&lt;/code&gt;, simply iterating the range without ever calling &lt;code&gt;front&lt;/code&gt; is enough to have &lt;code&gt;tee&lt;/code&gt; mirror elements to &lt;code&gt;outputRange&lt;/code&gt; (or, respectively, &lt;code&gt;fun&lt;/code&gt;). Note that each &lt;code&gt;popFront()&lt;/code&gt; call will mirror the old &lt;code&gt;front&lt;/code&gt; value, not the new one. This means that the last value will not be forwarded if the range isn't iterated until empty. If &lt;code&gt;No.pipeOnPop&lt;/code&gt;, only elements for which &lt;code&gt;front&lt;/code&gt; does get called will be also sent to &lt;code&gt;outputRange&lt;/code&gt;/&lt;code&gt;fun&lt;/code&gt;. If &lt;code&gt;front&lt;/code&gt; is called twice for the same element, it will still be sent only once. If this caching is undesired, consider using &lt;a href=&quot;std_algorithm_iteration#map&quot;&gt;&lt;code&gt;std.algorithm.iteration.map&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b44ae6759ea792f0bca17c48004575c328a9fdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt;, then &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; and leaves &lt;code&gt;a&lt;/code&gt; unchanged, whereas &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; advances &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;&quot;de&quot;&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a = &quot;abcde&quot;&lt;/code&gt; , &lt;code&gt;findSkip(a, &quot;x&quot;)&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; y deja &lt;code&gt;a&lt;/code&gt; sin cambios, mientras que &lt;code&gt;findSkip(a, &quot;c&quot;)&lt;/code&gt; avanza &lt;code&gt;a&lt;/code&gt; a &lt;code&gt;&quot;de&quot;&lt;/code&gt; y devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22d1d40c86b33d24346ec7f18b6caa5014b1c725" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; and &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt;, &lt;code&gt;bringToFront(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; and &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; y &lt;code&gt;b = [4, 5, 6, 7]&lt;/code&gt; , &lt;code&gt;bringToFront(a, b)&lt;/code&gt; las hojas &lt;code&gt;a = [4, 5, 6]&lt;/code&gt; y &lt;code&gt;b = [7, 1, 2, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="161672661d076244bfa4e1cb23db5cb7cee3f0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;reverse(a)&lt;/code&gt; changes it to &lt;code&gt;[3, 2, 1]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; , &lt;code&gt;reverse(a)&lt;/code&gt; cambia a &lt;code&gt;[3, 2, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c20592a36a578c54537352b677f5ac5e2a4bd22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt;, then &lt;code&gt;initializeAll(a)&lt;/code&gt; leaves &lt;code&gt;a = [double.init, double.init]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;a = [1.2, 3.4]&lt;/code&gt; , &lt;code&gt;initializeAll(a)&lt;/code&gt; deja &lt;code&gt;a = [double.init, double.init]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f19fe74876068eb9761e0ed018d3efe050a2dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; and &lt;code&gt;b = [40, 6, 15]&lt;/code&gt;, then &lt;code&gt;completeSort(a, b)&lt;/code&gt; leaves &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; and &lt;code&gt;b = [20, 30, 40]&lt;/code&gt;. The range &lt;code&gt;a&lt;/code&gt; must be sorted prior to the call, and as a result the combination &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; is sorted.</source>
          <target state="translated">Si &lt;code&gt;a = [10, 20, 30]&lt;/code&gt; y &lt;code&gt;b = [40, 6, 15]&lt;/code&gt; , a continuaci&amp;oacute;n, &lt;code&gt;completeSort(a, b)&lt;/code&gt; las hojas &lt;code&gt;a = [6, 10, 15]&lt;/code&gt; y &lt;code&gt;b = [20, 30, 40]&lt;/code&gt; . El rango &lt;code&gt;a&lt;/code&gt; debe ordenarse antes de la llamada y, como resultado, la combinaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;std_range#chain&quot;&gt;std.range.chain&lt;/a&gt;(a, b)&lt;/code&gt; se ordena.</target>
        </trans-unit>
        <trans-unit id="8653b5c90f101e5bb8cf18c8696bdaa4b97980b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt;, then &lt;code&gt;partialSort(a, 3)&lt;/code&gt; leaves &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt;. The other elements of &lt;code&gt;a&lt;/code&gt; are left in an unspecified order.</source>
          <target state="translated">Si &lt;code&gt;a = [5, 4, 3, 2, 1]&lt;/code&gt; , &lt;code&gt;partialSort(a, 3)&lt;/code&gt; deja &lt;code&gt;a[0 .. 3] = [1, 2, 3]&lt;/code&gt; . Los otros elementos de &lt;code&gt;a&lt;/code&gt; se dejan en un orden no especificado.</target>
        </trans-unit>
        <trans-unit id="761844ca385c58407529b15b7f0264a9fdc0b35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allowDuplicates&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, then inserting the same element more than once continues to add more elements. If it is &lt;code&gt;false&lt;/code&gt;, duplicate elements are ignored on insertion. If duplicates are allowed, then new elements are inserted after all existing duplicate elements.</source>
          <target state="translated">Si &lt;code&gt;allowDuplicates&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , entonces insertar el mismo elemento m&amp;aacute;s de una vez contin&amp;uacute;a agregando m&amp;aacute;s elementos. Si es &lt;code&gt;false&lt;/code&gt; , los elementos duplicados se ignoran en la inserci&amp;oacute;n. Si se permiten duplicados, se insertan nuevos elementos despu&amp;eacute;s de todos los elementos duplicados existentes.</target>
        </trans-unit>
        <trans-unit id="42df331db67fcac4570e8d97255c06bf51fcef31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;arr.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">Si &lt;code&gt;arr.length &amp;lt; delta&lt;/code&gt; , no hace nada y devuelve &lt;code&gt;false&lt;/code&gt; . De lo contrario, destruye los &amp;uacute;ltimos elementos &lt;code&gt;arr.length - delta&lt;/code&gt; en la matriz y luego reasigna el b&amp;uacute;fer de la matriz. Si la reasignaci&amp;oacute;n falla, llena la matriz con datos inicializados por defecto.</target>
        </trans-unit>
        <trans-unit id="73774d72a77acb4ae5cc4817197c7e3cc39e3e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt;, does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, destroys the last &lt;code&gt;array.length - delta&lt;/code&gt; elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data.</source>
          <target state="translated">Si &lt;code&gt;array.length &amp;lt; delta&lt;/code&gt; , no hace nada y devuelve &lt;code&gt;false&lt;/code&gt; . De lo contrario, destruye los &amp;uacute;ltimos elementos &lt;code&gt;array.length - delta&lt;/code&gt; en la matriz y luego reasigna el b&amp;uacute;fer de la matriz. Si la reasignaci&amp;oacute;n falla, llena la matriz con datos inicializados por defecto.</target>
        </trans-unit>
        <trans-unit id="7b4fa4088c1f332dc1cc2c07bd6dcf7ba46787dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b is null&lt;/code&gt;, does nothing and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, deallocates memory previously allocated with this allocator and returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise. An implementation that would not support deallocation (i.e. would always return &lt;code&gt;false&lt;/code&gt; should not define this primitive at all.)</source>
          <target state="translated">Si &lt;code&gt;b is null&lt;/code&gt; , no hace nada y devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, desasigna la memoria previamente asignada con este asignador y devuelve &lt;code&gt;true&lt;/code&gt; si tiene &amp;eacute;xito, de lo contrario , &lt;code&gt;false&lt;/code&gt; . Una implementaci&amp;oacute;n que no admitir&amp;iacute;a la desasignaci&amp;oacute;n (es decir, siempre devolver&amp;iacute;a &lt;code&gt;false&lt;/code&gt; no deber&amp;iacute;a definir esta primitiva en absoluto).</target>
        </trans-unit>
        <trans-unit id="8bae244a830c8d1176da79e2579d3599e88c12f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ba&lt;/code&gt; is zero (the default) the attributes of the existing memory will be used for an allocation. If &lt;code&gt;ba&lt;/code&gt; is not zero and no new memory is allocated, the bits in ba will replace those of the current memory block.</source>
          <target state="translated">Si &lt;code&gt;ba&lt;/code&gt; es cero (el valor predeterminado), los atributos de la memoria existente se utilizar&amp;aacute;n para una asignaci&amp;oacute;n. Si &lt;code&gt;ba&lt;/code&gt; no es cero y no se asigna memoria nueva, los bits en ba reemplazar&amp;aacute;n a los del bloque de memoria actual.</target>
        </trans-unit>
        <trans-unit id="221a7c0321e1759235e9e5a40274abe6cabee406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block.length&lt;/code&gt; is within &lt;code&gt;[min, max]&lt;/code&gt; or if the free list is unchecked (&lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt;), then inserts the block at the front of the free list. For all others, forwards to &lt;code&gt; parent.deallocate&lt;/code&gt; if &lt;code&gt;Parent.deallocate&lt;/code&gt; is defined.</source>
          <target state="translated">Si &lt;code&gt;block.length&lt;/code&gt; est&amp;aacute; dentro de &lt;code&gt;[min, max]&lt;/code&gt; o si la lista libre no est&amp;aacute; marcada ( &lt;code&gt;minSize == 0 &amp;amp;&amp;amp; maxSize == size_t.max&lt;/code&gt; ), entonces inserta el bloque al principio de la lista libre. Para todos los dem&amp;aacute;s, reenv&amp;iacute;a a &lt;code&gt; parent.deallocate&lt;/code&gt; si se define &lt;code&gt;Parent.deallocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e4b98282d9ecdaaa0277f0ab4f62ad8d1b53af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;BitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">Si &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;BitmappedBlock&lt;/code&gt; ofrece una propiedad de lectura / escritura &lt;code&gt;blockSize&lt;/code&gt; . Debe establecerse antes de cualquier uso del asignador. De lo contrario (es decir, &lt;code&gt;theBlockSize&lt;/code&gt; es una constante leg&amp;iacute;tima), &lt;code&gt;blockSize&lt;/code&gt; es un alias para &lt;code&gt;theBlockSize&lt;/code&gt; . Ya sea constante o variable, tambi&amp;eacute;n debe ser un m&amp;uacute;ltiplo de &lt;code&gt;alignment&lt;/code&gt; . Esta restricci&amp;oacute;n se &lt;code&gt;assert&lt;/code&gt; est&amp;aacute;tica y din&amp;aacute;micamente.</target>
        </trans-unit>
        <trans-unit id="f93a5a60f8514085265f3aa9ca6972ee5e3faff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt;, &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; offers a read/write property &lt;code&gt;blockSize&lt;/code&gt;. It must be set before any use of the allocator. Otherwise (i.e. &lt;code&gt;theBlockSize&lt;/code&gt; is a legit constant), &lt;code&gt;blockSize&lt;/code&gt; is an alias for &lt;code&gt;theBlockSize&lt;/code&gt;. Whether constant or variable, must also be a multiple of &lt;code&gt;alignment&lt;/code&gt;. This constraint is &lt;code&gt;assert&lt;/code&gt;ed statically and dynamically.</source>
          <target state="translated">Si &lt;code&gt;blockSize == chooseAtRuntime&lt;/code&gt; , &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; ofrece una propiedad de lectura / escritura &lt;code&gt;blockSize&lt;/code&gt; . Debe establecerse antes de cualquier uso del asignador. De lo contrario (es decir, &lt;code&gt;theBlockSize&lt;/code&gt; es una constante leg&amp;iacute;tima), &lt;code&gt;blockSize&lt;/code&gt; es un alias para &lt;code&gt;theBlockSize&lt;/code&gt; . Ya sea constante o variable, tambi&amp;eacute;n debe ser un m&amp;uacute;ltiplo de &lt;code&gt;alignment&lt;/code&gt; . Esta restricci&amp;oacute;n se &lt;code&gt;assert&lt;/code&gt; est&amp;aacute;tica y din&amp;aacute;micamente.</target>
        </trans-unit>
        <trans-unit id="8e23237ade60446568cde90bc631b8dba6e68c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode lowercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its uppercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es un &lt;a href=&quot;#Character&quot;&gt;car&amp;aacute;cter&lt;/a&gt; min&amp;uacute;sculo Unicode , se devuelve su equivalente en may&amp;uacute;scula. De lo contrario, se devuelve &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4c4b1af0ac218e5d7d40db7db18515091e62fd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a Unicode uppercase &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt;, then its lowercase equivalent is returned. Otherwise &lt;code&gt;c&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es un &lt;a href=&quot;#Character&quot;&gt;car&amp;aacute;cter en&lt;/a&gt; may&amp;uacute;scula Unicode , se devuelve su equivalente en min&amp;uacute;scula. De lo contrario, se devuelve &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9744833e493e9a4deaf2d113274c40f2b544663e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir == Direction.fwd&lt;/code&gt;, then a range iterates forward in time, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt;, then it iterates backwards in time. So, if &lt;code&gt;dir == Direction.fwd&lt;/code&gt; then &lt;code&gt;front == interval.begin&lt;/code&gt;, whereas if &lt;code&gt;dir == Direction.bwd&lt;/code&gt; then &lt;code&gt;front == interval.end&lt;/code&gt;. &lt;code&gt;func&lt;/code&gt; must generate a time point going in the proper direction of iteration, or a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. So, to iterate forward in time, the time point that &lt;code&gt;func&lt;/code&gt; generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in.</source>
          <target state="translated">Si &lt;code&gt;dir == Direction.fwd&lt;/code&gt; , entonces un rango itera hacia adelante en el tiempo, mientras que si &lt;code&gt;dir == Direction.bwd&lt;/code&gt; , itera hacia atr&amp;aacute;s en el tiempo. Entonces, si &lt;code&gt;dir == Direction.fwd&lt;/code&gt; entonces &lt;code&gt;front == interval.begin&lt;/code&gt; , mientras que si &lt;code&gt;dir == Direction.bwd&lt;/code&gt; entonces &lt;code&gt;front == interval.end&lt;/code&gt; . &lt;code&gt;func&lt;/code&gt; debe generar un punto de tiempo en la direcci&amp;oacute;n correcta de iteraci&amp;oacute;n, o se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException . Entonces, para iterar hacia adelante en el tiempo, el punto de tiempo que genera &lt;code&gt;func&lt;/code&gt; debe ser m&amp;aacute;s tarde que el que le pas&amp;oacute;. Si es id&amp;eacute;ntico o anterior, entonces una &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt;ser&amp;aacute; arrojado Para iterar hacia atr&amp;aacute;s, el punto de tiempo generado debe ser anterior al punto de tiempo que se pas&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="a610ee5ef0581a49f22c22f37935b0d33a042c3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filler&lt;/code&gt; is empty.</source>
          <target state="translated">Si el &lt;code&gt;filler&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="59e6f081398b1db2fd694d5b94d19e81b02d48a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is a &lt;code&gt;string&lt;/code&gt;, a new single parameter function  If &lt;code&gt;fun&lt;/code&gt; is not a &lt;code&gt;string&lt;/code&gt;, an alias to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;fun&lt;/code&gt; es una &lt;code&gt;string&lt;/code&gt; , una nueva funci&amp;oacute;n de par&amp;aacute;metro &amp;uacute;nico. Si &lt;code&gt;fun&lt;/code&gt; no es una &lt;code&gt;string&lt;/code&gt; , un alias de la &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="109bcbee3e25a658c4c9396a1465014de8c69b2c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fun&lt;/code&gt; is not a string, &lt;code&gt;binaryFun&lt;/code&gt; aliases itself away to &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">Si la &lt;code&gt;fun&lt;/code&gt; no es una cadena, &lt;code&gt;binaryFun&lt;/code&gt; se aleja de la &lt;code&gt;fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feeb8b9cc07251142d08e56cda48b8463e68f011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hasLength!Range&lt;/code&gt;, simply returns &lt;code&gt;range.length&lt;/code&gt; without checking &lt;code&gt;upTo&lt;/code&gt; (when specified).</source>
          <target state="translated">Si &lt;code&gt;hasLength!Range&lt;/code&gt; , simplemente devuelve &lt;code&gt;range.length&lt;/code&gt; sin marcar &lt;code&gt;upTo&lt;/code&gt; (cuando se especifica).</target>
        </trans-unit>
        <trans-unit id="46b7e88c254c5bba652608bb5aa781949149f305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;haystack&lt;/code&gt; is a random-access range, all three components of the tuple have the same type as &lt;code&gt;haystack&lt;/code&gt;. Otherwise, &lt;code&gt;haystack&lt;/code&gt; must be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the type of &lt;code&gt;result[0]&lt;/code&gt; and &lt;code&gt;result[1]&lt;/code&gt; is the same as &lt;a href=&quot;std_range#takeExactly&quot;&gt;&lt;code&gt;std.range.takeExactly&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;haystack&lt;/code&gt; es un rango de acceso aleatorio, los tres componentes de la tupla tienen el mismo tipo que &lt;code&gt;haystack&lt;/code&gt; . De lo contrario, &lt;code&gt;haystack&lt;/code&gt; debe ser un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango directo&lt;/a&gt; y el tipo de &lt;code&gt;result[0]&lt;/code&gt; y &lt;code&gt;result[1]&lt;/code&gt; es el mismo que &lt;a href=&quot;std_range#takeExactly&quot;&gt; &lt;code&gt;std.range.takeExactly&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3993b4b628968f5e6dd7d41599d550f5e0f99ef4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.alignedAllocate&lt;/code&gt; exists, calls it and returns the result. Otherwise, always returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Si existe &lt;code&gt;impl.alignedAllocate&lt;/code&gt; , lo llama y devuelve el resultado. De lo contrario, siempre devuelve &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02ba66810cd0cea189e643c4eeba55ce0d4de3e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;impl.deallocate&lt;/code&gt; is not defined, returns &lt;code&gt;false&lt;/code&gt;. Otherwise it forwards the call.</source>
          <target state="translated">Si &lt;code&gt;impl.deallocate&lt;/code&gt; no est&amp;aacute; definido, devuelve &lt;code&gt;false&lt;/code&gt; . De lo contrario, reenv&amp;iacute;a la llamada.</target>
        </trans-unit>
        <trans-unit id="48d32ce690c5f4ef93e7705c87fc34b78de3c611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt;, &lt;code&gt;needle&lt;/code&gt; can be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; too. In this case &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; is evaluated on each evaluation.</source>
          <target state="translated">Si la &lt;code&gt;input&lt;/code&gt; es un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango de avance&lt;/a&gt; , la &lt;code&gt;needle&lt;/code&gt; puede ser un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango de avance&lt;/a&gt; . En este caso, se &lt;code&gt;startsWith!pred(haystack, needle)&lt;/code&gt; en cada evaluaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="26612f521f443b434c0c471a4bb077313e418fc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;less&lt;/code&gt; is the less-than operator, which is the default option, then &lt;code&gt;BinaryHeap&lt;/code&gt; defines a so-called max-heap that optimizes extraction of the</source>
          <target state="translated">Si &lt;code&gt;less&lt;/code&gt; es el operador menor que, que es la opci&amp;oacute;n predeterminada, entonces &lt;code&gt;BinaryHeap&lt;/code&gt; define un llamado max-heap que optimiza la extracci&amp;oacute;n de</target>
        </trans-unit>
        <trans-unit id="bfc0979cbe401db983c65651eae478d6291e89b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;lhs != WithNaN.defaultValue!Lhs&lt;/code&gt; y el operador no se desborda, la funci&amp;oacute;n devuelve el mismo resultado que el operador incorporado. En todos los dem&amp;aacute;s casos, devuelve &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc27af0c815a7e79af80d07be90722649a52810" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt;, returns &lt;code&gt;double.init&lt;/code&gt;. Otherwise, has the same semantics as the default comparison.</source>
          <target state="translated">Si &lt;code&gt;lhs == WithNaN.defaultValue!Lhs&lt;/code&gt; , devuelve &lt;code&gt;double.init&lt;/code&gt; . De lo contrario, tiene la misma sem&amp;aacute;ntica que la comparaci&amp;oacute;n predeterminada.</target>
        </trans-unit>
        <trans-unit id="d151dfc3083b5628c51cfe2464aced84ec2e31e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; reference the same instance, then nothing is done.</source>
          <target state="translated">Si &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; hacen referencia a la misma instancia, entonces no se hace nada.</target>
        </trans-unit>
        <trans-unit id="1e390340bdf19475ede0638df9c1955fea065de9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;char[]&lt;/code&gt;, &lt;code&gt;wchar[]&lt;/code&gt;, &lt;code&gt;dchar[]&lt;/code&gt;, the line's content will be reused (overwritten) across reads.</source>
          <target state="translated">Si la &lt;code&gt;line&lt;/code&gt; tiene el tipo &lt;code&gt;char[]&lt;/code&gt; , &lt;code&gt;wchar[]&lt;/code&gt; , &lt;code&gt;dchar[]&lt;/code&gt; , el contenido de la l&amp;iacute;nea se reutilizar&amp;aacute; (se sobrescribir&amp;aacute;) en las lecturas.</target>
        </trans-unit>
        <trans-unit id="98f495eca2d1ec291e5bd0a688459f5f1c82028b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;immutable(ubyte)[]&lt;/code&gt;, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</source>
          <target state="translated">Si la &lt;code&gt;line&lt;/code&gt; tiene un tipo &lt;code&gt;immutable(ubyte)[]&lt;/code&gt; , el comportamiento es similar al caso (1), excepto que no se intenta ninguna comprobaci&amp;oacute;n de UTF en la entrada.</target>
        </trans-unit>
        <trans-unit id="1a835fb44628e74f7f9ff451e8b58c089bf38a93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;wstring&lt;/code&gt;, or &lt;code&gt;dstring&lt;/code&gt;, a new string of the respective type is allocated every read.</source>
          <target state="translated">Si la &lt;code&gt;line&lt;/code&gt; tiene tipo &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;wstring&lt;/code&gt; o &lt;code&gt;dstring&lt;/code&gt; , se asigna una nueva cadena del tipo respectivo en cada lectura.</target>
        </trans-unit>
        <trans-unit id="18e388959a9abaf079dbbac18945110b36067b2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;line&lt;/code&gt; has type &lt;code&gt;ubyte[]&lt;/code&gt;, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</source>
          <target state="translated">Si la &lt;code&gt;line&lt;/code&gt; tiene el tipo &lt;code&gt;ubyte[]&lt;/code&gt; , el comportamiento es similar al del caso (2), excepto que no se intenta la comprobaci&amp;oacute;n de UTF en la entrada.</target>
        </trans-unit>
        <trans-unit id="c61c7e699d18c7312070fee75c860133527ced6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;main()&lt;/code&gt; or the thread returns normally, (does not throw an exception), the static destructor is added to the list of functions to be called on thread termination.</source>
          <target state="translated">Si &lt;code&gt;main()&lt;/code&gt; o el subproceso regresa normalmente (no produce una excepci&amp;oacute;n), el destructor est&amp;aacute;tico se agrega a la lista de funciones que se invocar&amp;aacute;n en la terminaci&amp;oacute;n del subproceso.</target>
        </trans-unit>
        <trans-unit id="c93fc296f2b731310f3189f9c017eaec2be70e3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxSize == unbounded&lt;/code&gt;, returns &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt;. Otherwise, returns &lt;code&gt;max&lt;/code&gt; for sizes in the interval &lt;code&gt;[min, max]&lt;/code&gt;, and &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; otherwise.</source>
          <target state="translated">Si &lt;code&gt;maxSize == unbounded&lt;/code&gt; , devuelve &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;max&lt;/code&gt; para tama&amp;ntilde;os en el intervalo &lt;code&gt;[min, max]&lt;/code&gt; y &lt;code&gt;parent.goodAllocSize(bytes)&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="27889a42945896ba8e96a2b9190859d044697880" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt;, the algorithm has no effect and returns &lt;code&gt;r[0 .. r.length]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;n &amp;gt;= r.length&lt;/code&gt; , el algoritmo no tiene efecto y devuelve &lt;code&gt;r[0 .. r.length]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c001d68799c0a0c1fe4332536339591e3128dd5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is eligible for freelisting, returns &lt;code&gt;max&lt;/code&gt;. Otherwise, returns &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; es elegible para la lista libre, devuelve &lt;code&gt;max&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;parent.goodAllocSize(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fec7ab17fff539f84df945449516192c8415a4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is not defined, an infinite random access range with slicing.  If &lt;code&gt;n&lt;/code&gt; is defined, a random access range with slicing.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; no est&amp;aacute; definido, un rango de acceso aleatorio infinito con segmentaci&amp;oacute;n. Si se define &lt;code&gt;n&lt;/code&gt; , un rango de acceso aleatorio con segmentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7f2409b5e5208bcbd4bd9ae5b46439868d522731" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opCall&lt;/code&gt; is overridden for the struct, and the struct is initialized with a value that is of a different type, then the &lt;code&gt;opCall&lt;/code&gt; operator is called:</source>
          <target state="translated">Si &lt;code&gt;opCall&lt;/code&gt; se anula para la estructura, y la estructura se inicializa con un valor que es de un tipo diferente, entonces se &lt;code&gt;opCall&lt;/code&gt; operador opCall :</target>
        </trans-unit>
        <trans-unit id="0a8768e44be6ce84df4d8ac63955bf151c1ba410" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opIndex&lt;/code&gt; is declared with only one argument, the compile-time argument to &lt;code&gt;opDollar&lt;/code&gt; may be omitted. In this case, it is illegal to use &lt;code&gt;$&lt;/code&gt; inside an array indexing expression with more than one argument.</source>
          <target state="translated">Si &lt;code&gt;opIndex&lt;/code&gt; se declara con un solo argumento, puede omitirse el argumento en tiempo de compilaci&amp;oacute;n de &lt;code&gt;opDollar&lt;/code&gt; . En este caso, es ilegal usar &lt;code&gt;$&lt;/code&gt; dentro de una expresi&amp;oacute;n de indexaci&amp;oacute;n de matriz con m&amp;aacute;s de un argumento.</target>
        </trans-unit>
        <trans-unit id="1c029e2e84868e89d9aba168477cd4b281e4a698" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a pointer somewhere inside a block allocated with this allocator, &lt;code&gt;result&lt;/code&gt; holds a pointer to the beginning of the allocated block and returns &lt;code&gt;Ternary.yes&lt;/code&gt;. Otherwise, &lt;code&gt;result&lt;/code&gt; holds &lt;code&gt;null&lt;/code&gt; and returns &lt;code&gt;Ternary.no&lt;/code&gt;. If the pointer points immediately after an allocated block, the result is implementation defined.</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es un puntero en alg&amp;uacute;n lugar dentro de un bloque asignado con este asignador, el &lt;code&gt;result&lt;/code&gt; ado mantiene un puntero al principio del bloque asignado y devuelve &lt;code&gt;Ternary.yes&lt;/code&gt; . De lo contrario, el &lt;code&gt;result&lt;/code&gt; ado se mantiene &lt;code&gt;null&lt;/code&gt; y devuelve &lt;code&gt;Ternary.no&lt;/code&gt; . Si el puntero apunta inmediatamente despu&amp;eacute;s de un bloque asignado, el resultado es la implementaci&amp;oacute;n definida.</target>
        </trans-unit>
        <trans-unit id="e2eb2629d5b4956bd1542eca4775455139c95a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is a relative directory, return it unaltered.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; es un directorio relativo, devu&amp;eacute;lvalo sin modificaciones.</target>
        </trans-unit>
        <trans-unit id="702fecc6b0bc34adfafc2cb51d268f4825e76aef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is already absolute, return it.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; ya es absoluta, devu&amp;eacute;lvala.</target>
        </trans-unit>
        <trans-unit id="051c5165fdb7f4181c26346b52a8a370bb269c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is empty, return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; est&amp;aacute; vac&amp;iacute;a, devuelva &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de70cd968c35f871aa7f988334ddd5070ebe64cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is on the form &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (UNC path), &lt;a href=&quot;#isValidFilename&quot;&gt;&lt;code&gt;isValidFilename&lt;/code&gt;&lt;/a&gt; is applied to</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; est&amp;aacute; en el formulario &lt;code&gt;\\&lt;i&gt;server&lt;/i&gt;\&lt;i&gt;share&lt;/i&gt;\...&lt;/code&gt; (ruta UNC), &lt;a href=&quot;#isValidFilename&quot;&gt; &lt;code&gt;isValidFilename&lt;/code&gt; &lt;/a&gt; se aplica a</target>
        </trans-unit>
        <trans-unit id="5ccfc704dde80078077c0681938c9dc1e45235e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\.\&lt;/code&gt; (Win32 device namespace) this function returns &lt;code&gt;false&lt;/code&gt;; such paths are beyond the scope of this module.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; comienza con &lt;code&gt;\\.\&lt;/code&gt; (Espacio de nombres del dispositivo Win32), esta funci&amp;oacute;n devuelve &lt;code&gt;false&lt;/code&gt; ; tales caminos est&amp;aacute;n m&amp;aacute;s all&amp;aacute; del alcance de este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="891daee93beed99df04fb47b76bddba5d0aeec90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; starts with &lt;code&gt;\\?\&lt;/code&gt; (long UNC path), the only requirement for the rest of the string is that it does not contain the null character.</source>
          <target state="translated">Si la &lt;code&gt;path&lt;/code&gt; comienza con &lt;code&gt;\\?\&lt;/code&gt; (Ruta UNC larga), el &amp;uacute;nico requisito para el resto de la cadena es que no contenga el car&amp;aacute;cter nulo.</target>
        </trans-unit>
        <trans-unit id="cf0839c8941b9553277dcc1246fadae5b4af51e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;postData&lt;/code&gt; is non-null the method will be set to &lt;code&gt;post&lt;/code&gt; for HTTP requests.</source>
          <target state="translated">Si &lt;code&gt;postData&lt;/code&gt; no es nulo, el m&amp;eacute;todo se configurar&amp;aacute; para &lt;code&gt;post&lt;/code&gt; las solicitudes HTTP.</target>
        </trans-unit>
        <trans-unit id="b45cfaf55131d31d198ea2c44bd484f7f79174d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pretty&lt;/code&gt; is false no whitespaces are generated. If &lt;code&gt;pretty&lt;/code&gt; is true serialized string is formatted to be human-readable. Set the &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt;&lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;options&lt;/code&gt; to encode NaN/Infinity as strings.</source>
          <target state="translated">Si &lt;code&gt;pretty&lt;/code&gt; es falso, no se generan espacios en blanco. Si &lt;code&gt;pretty&lt;/code&gt; es cierto, la cadena serializada est&amp;aacute; formateada para que sea legible por humanos. Establezca el indicador &lt;a href=&quot;#JSONOptions.specialFloatLiterals&quot;&gt; &lt;code&gt;JSONOptions.specialFloatLiterals&lt;/code&gt; &lt;/a&gt; en las &lt;code&gt;options&lt;/code&gt; para codificar NaN / Infinity como cadenas.</target>
        </trans-unit>
        <trans-unit id="4fe6d0c26964bd6dde3a76798f875b6541f56e6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;primary&lt;/code&gt; does not own &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; is attempted. If that fails, an attempt is made to move the allocation from &lt;code&gt;fallback&lt;/code&gt; to &lt;code&gt;primary&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;primary&lt;/code&gt; no posee &lt;code&gt;b&lt;/code&gt; , entonces se intenta &lt;code&gt;fallback.reallocate(b, newSize)&lt;/code&gt; . Si eso falla, se hace un intento para mover la asignaci&amp;oacute;n de &lt;code&gt;fallback&lt;/code&gt; a &lt;code&gt;primary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45d84a0c7a2f66706678e328dd9e74e78023bd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;printf&lt;/code&gt;-style logging is needed add a &lt;b&gt;f&lt;/b&gt; to the logging call, such as &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; or &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt;. The additional &lt;b&gt;f&lt;/b&gt; appended to the function name enables &lt;code&gt;printf&lt;/code&gt;-style logging for all combinations of explicit &lt;code&gt;LogLevel&lt;/code&gt; and conditional logging functions and methods.</source>
          <target state="translated">Si se necesita el registro de estilo &lt;code&gt;printf&lt;/code&gt; , agregue una &lt;b&gt;f&lt;/b&gt; a la llamada de registro, como &lt;code&gt;myLogger.infof(&quot;Hello %s&quot;, &quot;world&quot;);&lt;/code&gt; o &lt;code&gt;fatalf(&quot;errno %d&quot;, 1337)&lt;/code&gt; . La &lt;b&gt;f&lt;/b&gt; adicional agregada al nombre de la funci&amp;oacute;n permite el registro de estilo &lt;code&gt;printf&lt;/code&gt; para todas las combinaciones de &lt;code&gt;LogLevel&lt;/code&gt; expl&amp;iacute;cito y funciones y m&amp;eacute;todos de registro condicional.</target>
        </trans-unit>
        <trans-unit id="c809d18303614396b533b1264943fb0bf373af22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; contains equivalent elements, multiple permutations of &lt;code&gt;r&lt;/code&gt; satisfy these constraints. In such cases, &lt;code&gt;pivotPartition&lt;/code&gt; attempts to distribute equivalent elements fairly to the left and right of &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;k&lt;/code&gt; stays close to &lt;code&gt;r.length / 2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; contiene elementos equivalentes, las permutaciones m&amp;uacute;ltiples de &lt;code&gt;r&lt;/code&gt; satisfacen estas restricciones. En tales casos, &lt;code&gt;pivotPartition&lt;/code&gt; intenta distribuir elementos equivalentes equitativamente a la izquierda y a la derecha de &lt;code&gt;k&lt;/code&gt; de modo que &lt;code&gt;k&lt;/code&gt; permanezca cerca de &lt;code&gt;r.length / 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23935d946a100a97c3e455c30306a633f7b98438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; has a length, then this is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, it's &amp;Omicron;(&lt;code&gt;r.length&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; tiene una longitud, entonces esto es &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ). De lo contrario, es &amp;Omicron; ( &lt;code&gt;r.length&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f163286db8bb098fc5cc4073249e55f06a301b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a string with Unicode characters in it, &lt;code&gt;padLeft&lt;/code&gt; follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call &lt;a href=&quot;std_uni#byGrapheme&quot;&gt;&lt;code&gt;std.uni.byGrapheme&lt;/code&gt;&lt;/a&gt; before calling this function.</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; es una cadena con caracteres Unicode, &lt;code&gt;padLeft&lt;/code&gt; sigue las reglas de D sobre la longitud de las cadenas, que no es el n&amp;uacute;mero de caracteres o grafemas, sino el n&amp;uacute;mero de unidades de codificaci&amp;oacute;n. Si desea tratar cada grafema como una sola unidad de codificaci&amp;oacute;n, llame a &lt;a href=&quot;std_uni#byGrapheme&quot;&gt; &lt;code&gt;std.uni.byGrapheme&lt;/code&gt; &lt;/a&gt; antes de llamar a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6a927ae2914fb825262976485c0cc9304c3da3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then &lt;code&gt;r&lt;/code&gt; is returned.  Otherwise, &lt;code&gt;r&lt;/code&gt; is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If &lt;code&gt;r&lt;/code&gt; is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions),</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; no es una cadena autodescodificable (es decir, una cadena estrecha o un tipo definido por el usuario que implique conversiones a un tipo de cadena), entonces se devuelve &lt;code&gt;r&lt;/code&gt; . De lo contrario, &lt;code&gt;r&lt;/code&gt; se convierte a su tipo de cadena correspondiente (si a&amp;uacute;n no es una cadena) y se envuelve en un rango de acceso aleatorio donde el tipo de codificaci&amp;oacute;n del elemento de la cadena (su unidad de c&amp;oacute;digo) es el tipo de elemento del rango, y ese rango devuelto El rango tiene rebanado. Si &lt;code&gt;r&lt;/code&gt; es lo suficientemente peculiar como para ser una estructura o clase que es un rango de entrada de caracteres por s&amp;iacute; solo (es decir, tiene la API de rango de entrada como funciones miembro),</target>
        </trans-unit>
        <trans-unit id="df6a47c8f433360081103c7b545791ca9cd35f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; does not have length, and &lt;code&gt;popFront&lt;/code&gt; is called when &lt;code&gt;front.index == Enumerator.max&lt;/code&gt;, the index will overflow and continue from &lt;code&gt;Enumerator.min&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;range&lt;/code&gt; no tiene longitud, y &lt;code&gt;popFront&lt;/code&gt; se llama cuando &lt;code&gt;front.index == Enumerator.max&lt;/code&gt; , el &amp;iacute;ndice se desbordar&amp;aacute; y continuar desde &lt;code&gt;Enumerator.min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e2389187db9ad1c90dc2cdb963a735557c21c35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;range&lt;/code&gt; has length, then it is an error to pass a value for &lt;code&gt;start&lt;/code&gt; so that &lt;code&gt;start + range.length&lt;/code&gt; is bigger than &lt;code&gt;Enumerator.max&lt;/code&gt;, thus it is ensured that overflow cannot happen.</source>
          <target state="translated">Si el &lt;code&gt;range&lt;/code&gt; tiene longitud, entonces es un error pasar un valor de &lt;code&gt;start&lt;/code&gt; para que &lt;code&gt;start + range.length&lt;/code&gt; sea ​​mayor que &lt;code&gt;Enumerator.max&lt;/code&gt; , por lo que se garantiza que no se produzca un desbordamiento.</target>
        </trans-unit>
        <trans-unit id="111a596bfe5993b016245842df9ecb465a3674d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;rhs != WithNaN.defaultValue!Rhs&lt;/code&gt; y el operador no se desborda, la funci&amp;oacute;n devuelve el mismo resultado que el operador incorporado. En todos los dem&amp;aacute;s casos, devuelve &lt;code&gt;WithNaN.defaultValue!(typeof(lhs + rhs))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5536ec979292168bf217723d15877e765427904" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rhs&lt;/code&gt; is &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt;, returns &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt;. Otherwise, returns &lt;code&gt;cast(Lhs) rhs&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;rhs&lt;/code&gt; es &lt;code&gt;WithNaN.defaultValue!Rhs&lt;/code&gt; , devuelve &lt;code&gt;WithNaN.defaultValue!Lhs&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;cast(Lhs) rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ede40fbc0f7d83884db066a6386fc8a519d5ed8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == 0&lt;/code&gt;, the call may return any empty slice (including &lt;code&gt;null&lt;/code&gt;). Otherwise, the call allocates &lt;code&gt;s&lt;/code&gt; bytes of memory and returns the allocated block, or &lt;code&gt;null&lt;/code&gt; if the request could not be satisfied.</source>
          <target state="translated">Si &lt;code&gt;s == 0&lt;/code&gt; , la llamada puede devolver cualquier segmento vac&amp;iacute;o (incluido &lt;code&gt;null&lt;/code&gt; ). De lo contrario, la llamada asigna &lt;code&gt;s&lt;/code&gt; bytes de memoria y devuelve el bloque asignado, o &lt;code&gt;null&lt;/code&gt; si no se puede satisfacer la solicitud.</target>
        </trans-unit>
        <trans-unit id="9eadce3ccc140e91f7b505d0328ee8cc176eeac6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt;, then elements are moved from the end of the range into the slots to be filled. In this case, the absolute minimum of moves is performed.</source>
          <target state="translated">Si &lt;code&gt;s == SwapStrategy.unstable &amp;amp;&amp;amp; isRandomAccessRange!Range &amp;amp;&amp;amp; hasLength!Range &amp;amp;&amp;amp; hasLvalueElements!Range&lt;/code&gt; , los elementos se mueven desde el final del rango a las ranuras a rellenar. En este caso, se realiza el m&amp;iacute;nimo absoluto de movimientos.</target>
        </trans-unit>
        <trans-unit id="8bbc6063db8df4c25b1d7ab2586ea771801923fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a function template, i.e. the only member of a template and that member is a function, return that template.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es una plantilla de funci&amp;oacute;n, es decir, el &amp;uacute;nico miembro de una plantilla y ese miembro es una funci&amp;oacute;n, devuelva esa plantilla.</target>
        </trans-unit>
        <trans-unit id="ac063e0ae979bd086a87ed636e906eb9690bf4e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; ends with &lt;code&gt;delimiter&lt;/code&gt;, then &lt;code&gt;str&lt;/code&gt; is returned without &lt;code&gt;delimiter&lt;/code&gt; on its end. If it &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">Si &lt;code&gt;str&lt;/code&gt; termina con &lt;code&gt;delimiter&lt;/code&gt; , entonces &lt;code&gt;str&lt;/code&gt; se devuelve sin &lt;code&gt;delimiter&lt;/code&gt; en su extremo. Si lo hace &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a851969ac104167dbde2b6f580e63232a655ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; starts with &lt;code&gt;delimiter&lt;/code&gt;, then the part of &lt;code&gt;str&lt;/code&gt; following &lt;code&gt;delimiter&lt;/code&gt; is returned. If &lt;code&gt;str&lt;/code&gt; does</source>
          <target state="translated">Si &lt;code&gt;str&lt;/code&gt; comienza con &lt;code&gt;delimiter&lt;/code&gt; , se devuelve la parte de &lt;code&gt;str&lt;/code&gt; que sigue al &lt;code&gt;delimiter&lt;/code&gt; . Si &lt;code&gt;str&lt;/code&gt; hace</target>
        </trans-unit>
        <trans-unit id="4978f696ceefb2aa4374b5f4ce674343dc8b0fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sz&lt;/code&gt; is zero, the memory referenced by p will be deallocated as if by a call to &lt;code&gt;free&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, new memory will be allocated via &lt;code&gt;malloc&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is pointing to memory not allocated from the GC or to the interior of an allocated memory block, no operation is performed and null is returned.</source>
          <target state="translated">Si &lt;code&gt;sz&lt;/code&gt; es cero, la memoria a la que hace referencia p se desasignar&amp;aacute; como si fuera una llamada a &lt;code&gt;free&lt;/code&gt; . Si &lt;code&gt;p&lt;/code&gt; es &lt;code&gt;null&lt;/code&gt; , se asignar&amp;aacute; nueva memoria a trav&amp;eacute;s de &lt;code&gt;malloc&lt;/code&gt; . Si &lt;code&gt;p&lt;/code&gt; apunta a una memoria no asignada desde el GC o al interior de un bloque de memoria asignado, no se realiza ninguna operaci&amp;oacute;n y se devuelve un valor nulo.</target>
        </trans-unit>
        <trans-unit id="b756c4e80a3354d029916e71e883d1d288090aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ticksPerSec&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then then &lt;code&gt;TickDuration&lt;/code&gt; failed to get the value of &lt;code&gt;ticksPerSec&lt;/code&gt; on the current system, and &lt;code&gt;TickDuration&lt;/code&gt; is not going to work. That would be highly abnormal though.</source>
          <target state="translated">Si &lt;code&gt;ticksPerSec&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; , entonces &lt;code&gt;TickDuration&lt;/code&gt; no pudo obtener el valor de &lt;code&gt;ticksPerSec&lt;/code&gt; en el sistema actual, y &lt;code&gt;TickDuration&lt;/code&gt; no funcionar&amp;aacute;. Sin embargo, eso ser&amp;iacute;a muy anormal.</target>
        </trans-unit>
        <trans-unit id="0a174cf4ab1d67c6c049d75173bd4c15d10ca6f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeval.tv_sec&lt;/code&gt; is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used for &lt;code&gt;tv_sec&lt;/code&gt;. (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under).</source>
          <target state="translated">Si &lt;code&gt;timeval.tv_sec&lt;/code&gt; es int, y el resultado no puede caber en un int, entonces el valor m&amp;aacute;s cercano que puede mantenerse en 32 bits se usar&amp;aacute; para &lt;code&gt;tv_sec&lt;/code&gt; . (entonces &lt;code&gt;int.max&lt;/code&gt; si se supera e &lt;code&gt;int.min&lt;/code&gt; si se reduce ).</target>
        </trans-unit>
        <trans-unit id="b737bf16441ab6f2f4b4d91936f54afa2de4c527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two objects that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">Si &lt;code&gt;toHash&lt;/code&gt; debe ser siempre el mismo valor cuando &lt;code&gt;opEquals&lt;/code&gt; devuelve verdadero. En otras palabras, dos objetos que se consideran iguales siempre deben tener el mismo valor hash. De lo contrario, se producir&amp;aacute; un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="46b829bd712225872ea6d9fe14e82ebf07db56c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;toHash&lt;/code&gt; must consistently be the same value when &lt;code&gt;opEquals&lt;/code&gt; returns true. In other words, two structs that are considered equal should always have the same hash value. Otherwise, undefined behavior will result.</source>
          <target state="translated">Si &lt;code&gt;toHash&lt;/code&gt; debe ser siempre el mismo valor cuando &lt;code&gt;opEquals&lt;/code&gt; devuelve verdadero. En otras palabras, dos estructuras que se consideran iguales siempre deben tener el mismo valor hash. De lo contrario, se producir&amp;aacute; un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="bdd34bf58210d81d6b36b3924a3e5089f87b29e6" translate="yes" xml:space="preserve">
          <source>If B to A conversion is convariant that requires offseet adjusting, all return statements should be adjusted to return expressions typed A.</source>
          <target state="translated">Si la conversión de B a A es convariante y requiere un ajuste de offset,todas las declaraciones de retorno deben ajustarse a las expresiones de retorno de tipo A.</target>
        </trans-unit>
        <trans-unit id="5f616405142623769cdbbf978f769d6bf8291c51" translate="yes" xml:space="preserve">
          <source>If JSON value is null, then operator initializes it with object and then sets &lt;code&gt;value&lt;/code&gt; for it.</source>
          <target state="translated">Si el valor JSON es nulo, el operador lo inicializa con un objeto y luego establece el &lt;code&gt;value&lt;/code&gt; para &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="b3d334f3b16094aef354285c2c419452a7b589ea" translate="yes" xml:space="preserve">
          <source>If Source is a &lt;code&gt;struct&lt;/code&gt; then wrapping/unwrapping will create a copy; it is not possible to affect the original &lt;code&gt;struct&lt;/code&gt; through the wrapper.</source>
          <target state="translated">Si Source es una &lt;code&gt;struct&lt;/code&gt; entonces envolver / desenvolver crear&amp;aacute; una copia; No es posible afectar la &lt;code&gt;struct&lt;/code&gt; original a trav&amp;eacute;s del contenedor.</target>
        </trans-unit>
        <trans-unit id="2e8ce4614eba95d281d33d622683800da451bb90" translate="yes" xml:space="preserve">
          <source>If Statement</source>
          <target state="translated">Si la declaración</target>
        </trans-unit>
        <trans-unit id="dd4a3f3a81119e68ec01207d19a926cbd1e5f669" translate="yes" xml:space="preserve">
          <source>If Targets has only one entry and Source is a class which explicitly implements it, wrap simply returns src upcasted to &lt;code&gt;Targets[0]&lt;/code&gt;.</source>
          <target state="translated">Si Targets tiene solo una entrada y Source es una clase que la implementa expl&amp;iacute;citamente, wrap simplemente devuelve src a &lt;code&gt;Targets[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">Si un</target>
        </trans-unit>
        <trans-unit id="38354ffb09e774c4e1e6d7b1ae1d349a56902b44" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; is supplied, the fields are initialized by the &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; syntax.</source>
          <target state="translated">Si se proporciona un &lt;a href=&quot;declaration#StructInitializer&quot;&gt;&lt;i&gt;StructInitializer&lt;/i&gt;&lt;/a&gt; , la sintaxis de &lt;a href=&quot;declaration#StructMemberInitializer&quot;&gt;&lt;i&gt;StructMemberInitializer&lt;/i&gt;&lt;/a&gt; inicializa los &lt;i&gt;campos&lt;/i&gt; .</target>
        </trans-unit>
        <trans-unit id="d74a8d147475df621b5e8ac9d1c6cc1de44dcbfd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;union S&lt;/code&gt; has fields that define a copy constructor, whenever an object of type &lt;code&gt;S&lt;/code&gt; is initialized by copy, an error will be issued. The same rule applies to overlapped fields (anonymous unions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82eb1a8a8a78d51182899822b5022de27e60420b" translate="yes" xml:space="preserve">
          <source>If a and b are both class objects, then the expression is rewritten as:</source>
          <target state="translated">Si a y b son ambos objetos de clase,entonces la expresión se reescribe como:</target>
        </trans-unit>
        <trans-unit id="5e7e375e1c7dad6e65f441c0e60a25b131f8701e" translate="yes" xml:space="preserve">
          <source>If a cast to a floating-point type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get == cast(T) U(get)&lt;/code&gt;. If that is not &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">Si se solicita una &lt;code&gt;onBadCast&lt;/code&gt; a un tipo de punto flotante y &lt;code&gt;Hook&lt;/code&gt; define onBadCast , la conversi&amp;oacute;n se verifica garantizando &lt;code&gt;get == cast(T) U(get)&lt;/code&gt; . Si eso no es &lt;code&gt;true&lt;/code&gt; , se &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="214d150104c62cbd9a8df607ea8c5c4b3837548b" translate="yes" xml:space="preserve">
          <source>If a cast to an integral type is requested and &lt;code&gt;Hook&lt;/code&gt; defines &lt;code&gt;onBadCast&lt;/code&gt;, the cast is verified by ensuring &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;cast(U) get&lt;/code&gt; are the same arithmetic number. (Note that &lt;code&gt;int(-1)&lt;/code&gt; and &lt;code&gt;uint(1)&lt;/code&gt; are different values arithmetically although they have the same bitwise representation and compare equal by language rules.) If the numbers are not arithmetically equal, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; is returned.</source>
          <target state="translated">Si se solicita una &lt;code&gt;onBadCast&lt;/code&gt; a un tipo integral y &lt;code&gt;Hook&lt;/code&gt; define onBadCast , la conversi&amp;oacute;n se verifica asegurando que &lt;code&gt;get&lt;/code&gt; y &lt;code&gt;cast(U) get&lt;/code&gt; sean el mismo n&amp;uacute;mero aritm&amp;eacute;tico. (Tenga en cuenta que &lt;code&gt;int(-1)&lt;/code&gt; y &lt;code&gt;uint(1)&lt;/code&gt; son diferentes valores aritm&amp;eacute;ticamente a pesar de que tienen la misma representaci&amp;oacute;n a nivel de bits y comparan iguales por las reglas del lenguaje.) Si los n&amp;uacute;meros no son aritm&amp;eacute;ticamente iguales, &lt;code&gt;hook.onBadCast!U(get)&lt;/code&gt; se devuelve .</target>
        </trans-unit>
        <trans-unit id="f50b34e635f5b3d69730e335c13e613f658b1407" translate="yes" xml:space="preserve">
          <source>If a choice's return type is void, the choice must throw an exception, unless all the choices are void. In that case, castSwitch itself will return void.</source>
          <target state="translated">Si el tipo de devolución de una elección es nulo,la elección debe lanzar una excepción,a menos que todas las elecciones sean nulas.En ese caso,el propio CastSwitch devolverá el vacío.</target>
        </trans-unit>
        <trans-unit id="fb6d0d046ebbfc4f31bb86cf82620af737d82d69" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegate constructor call, all possible execution paths through the constructor must make exactly one delegate constructor call:</source>
          <target state="translated">Si el código de un constructor contiene una llamada de constructor delegado,todas las posibles trayectorias de ejecución a través del constructor deben hacer exactamente una llamada de constructor delegado:</target>
        </trans-unit>
        <trans-unit id="289f1bcf6286485bf50554692831db27b58239e4" translate="yes" xml:space="preserve">
          <source>If a constructor's code contains a delegating constructor call, all possible execution paths through the constructor must make exactly one delegating constructor call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c7db79dd1c4bbec318c1afec835bd55146cddb" translate="yes" xml:space="preserve">
          <source>If a copy constructor is defined, implicit calls to it will be inserted in the following situations:</source>
          <target state="translated">Si se define un constructor de copias,se insertarán llamadas implícitas a él en las siguientes situaciones:</target>
        </trans-unit>
        <trans-unit id="3a4c5302b387be4ef4923c3da45ea70ef8244969" translate="yes" xml:space="preserve">
          <source>If a declaration is followed by a documented unittest, the code in the unittest will be inserted in the &lt;b&gt;example&lt;/b&gt; section of the declaration:</source>
          <target state="translated">Si una declaraci&amp;oacute;n es seguida por una prueba unitaria documentada, el c&amp;oacute;digo en la prueba unitaria se insertar&amp;aacute; en la secci&amp;oacute;n de &lt;b&gt;ejemplo&lt;/b&gt; de la declaraci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="994d2a230df4885735f193cf875a7c34425353d8" translate="yes" xml:space="preserve">
          <source>If a declaration starts with a</source>
          <target state="translated">Si una declaración comienza con un</target>
        </trans-unit>
        <trans-unit id="5abfec0c9b70a28afdd54a250553e480e8e7f188" translate="yes" xml:space="preserve">
          <source>If a delegate is passed, the safety and purity of this function are inferred from &lt;code&gt;Dg&lt;/code&gt;'s safety and purity.</source>
          <target state="translated">Si se aprueba un delegado, la seguridad y pureza de esta funci&amp;oacute;n se infieren de la seguridad y pureza de &lt;code&gt;Dg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea319443f8c57e701d411ba01a8cc3309299df11" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument to &lt;code&gt;receive&lt;/code&gt;, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="translated">Si se incluye un delegado que acepta un &lt;a href=&quot;std_variant#Variant&quot;&gt; &lt;code&gt;std.variant.Variant&lt;/code&gt; &lt;/a&gt; como &amp;uacute;ltimo argumento para &lt;code&gt;receive&lt;/code&gt; , coincidir&amp;aacute; con cualquier mensaje que no haya coincidido con un delegado anterior. Si se env&amp;iacute;a m&amp;aacute;s de un argumento, la &lt;code&gt;Variant&lt;/code&gt; e contendr&amp;aacute; un &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; de todos los valores enviados.</target>
        </trans-unit>
        <trans-unit id="7c6073aed324734814b1c5af997eb904b7a1d366" translate="yes" xml:space="preserve">
          <source>If a delegate that accepts a &lt;a href=&quot;std_variant#Variant&quot;&gt;&lt;code&gt;std.variant.Variant&lt;/code&gt;&lt;/a&gt; is included as the last argument, it will match any message that was not matched by an earlier delegate. If more than one argument is sent, the &lt;code&gt;Variant&lt;/code&gt; will contain a &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt; of all values sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6772ca1fa3a50c56b1e2254d50cd48e0b56364df" translate="yes" xml:space="preserve">
          <source>If a delegating constructor is not called, a call to the base class's default constructor is issued.</source>
          <target state="translated">Si no se llama a un constructor delegado,se llama al constructor por defecto de la clase base.</target>
        </trans-unit>
        <trans-unit id="881137e036e5d861dacc5e49c7e5ec6d46042221" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with diferrent &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="translated">Si una clase derivada anula una funci&amp;oacute;n miembro de clase base con diferentes atributos de &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;funci&amp;oacute;n&lt;/i&gt;&lt;/a&gt; , el compilador compensar&amp;aacute; autom&amp;aacute;ticamente los atributos faltantes.</target>
        </trans-unit>
        <trans-unit id="9133da665b338dc9f2d280b762259fd2a4cf7d31" translate="yes" xml:space="preserve">
          <source>If a derived class overrides a base class member function with different &lt;a href=&quot;#FunctionAttributes&quot;&gt;&lt;i&gt;FunctionAttributes&lt;/i&gt;&lt;/a&gt;, the missing attributes will be automatically compensated by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01bf1413dae9a84ffd106c13e7efc616299cc07" translate="yes" xml:space="preserve">
          <source>If a documentation comment for a declaration consists only of the identifier &lt;code&gt;ditto&lt;/code&gt; then the documentation comment for the previous declaration at the same declaration scope is applied to this declaration as well.</source>
          <target state="translated">Si un comentario de documentaci&amp;oacute;n para una declaraci&amp;oacute;n consta solo del identificador &lt;code&gt;ditto&lt;/code&gt; entonces el comentario de documentaci&amp;oacute;n para la declaraci&amp;oacute;n anterior en el mismo alcance de declaraci&amp;oacute;n tambi&amp;eacute;n se aplica a esta declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3415ea6dfee5691668c1c8232a3e5910eb9c73a0" translate="yes" xml:space="preserve">
          <source>If a field's type has disabled default construction, then it must be initialized in the constructor.</source>
          <target state="translated">Si el tipo de un campo ha desactivado la construcción por defecto,entonces debe ser inicializado en el constructor.</target>
        </trans-unit>
        <trans-unit id="d8f6fa7fc0afa2680299befa1345222924cf9276" translate="yes" xml:space="preserve">
          <source>If a floating literal has a &lt;b&gt;.&lt;/b&gt; and a type suffix, at least one digit must be in-between:</source>
          <target state="translated">Si un literal flotante tiene un &lt;b&gt;. &lt;/b&gt;y un sufijo de tipo, al menos un d&amp;iacute;gito debe estar en el medio:</target>
        </trans-unit>
        <trans-unit id="3a19adb71ebefd9a28ba0c9b27281e67156dc538" translate="yes" xml:space="preserve">
          <source>If a floating literal is followed by &lt;b&gt;i&lt;/b&gt;, then it is an</source>
          <target state="translated">Si un literal flotante es seguido por &lt;b&gt;i&lt;/b&gt; , entonces es un</target>
        </trans-unit>
        <trans-unit id="8d8575d274fd6277028e0c2b41501d26b560a2c4" translate="yes" xml:space="preserve">
          <source>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes.</source>
          <target state="translated">Si una función intenta probarse a sí misma en cuanto a esos atributos,entonces se infiere que la función no tiene esos atributos.</target>
        </trans-unit>
        <trans-unit id="a4a6cb5bd72ee43c0b82dda81af5fd129c286fde" translate="yes" xml:space="preserve">
          <source>If a function call passes no explicit argument, i.e. it would syntactically use &lt;code&gt;()&lt;/code&gt;, then these parentheses may be omitted, similar to a getter invocation of a &lt;a href=&quot;#property-functions&quot;&gt;property function&lt;/a&gt;.</source>
          <target state="translated">Si una llamada a funci&amp;oacute;n no pasa ning&amp;uacute;n argumento expl&amp;iacute;cito, es decir, usar&amp;iacute;a sint&amp;aacute;cticamente &lt;code&gt;()&lt;/code&gt; , entonces estos par&amp;eacute;ntesis pueden omitirse, de forma similar a una invocaci&amp;oacute;n getter de una &lt;a href=&quot;#property-functions&quot;&gt;funci&amp;oacute;n de propiedad&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7b8dc0678edabe73fefcc44809c2cbac6174ce" translate="yes" xml:space="preserve">
          <source>If a function in a derived class overrides a function from its super class, then only one of the &lt;code&gt;in&lt;/code&gt; contracts of the function and its base functions must be satisfied. Overriding functions then becomes a process of</source>
          <target state="translated">Si una funci&amp;oacute;n en una clase derivada anula una funci&amp;oacute;n de su super clase, entonces s&amp;oacute;lo uno de los &lt;code&gt;in&lt;/code&gt; los contratos de la funci&amp;oacute;n y sus funciones base debe ser satisfecho. Anular funciones se convierte en un proceso de</target>
        </trans-unit>
        <trans-unit id="833166b5c67f31578b3c0dc74c8f4637740cb9ae" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parantheses are required if the returned value is to be called.</source>
          <target state="translated">Si una función devuelve un delegado o un puntero de función,se requieren los paréntesis si se va a llamar al valor devuelto.</target>
        </trans-unit>
        <trans-unit id="3fb0c821f0139e65cc3fa8dd141873150a7b34b1" translate="yes" xml:space="preserve">
          <source>If a function returns a delegate or function pointer, the parentheses are required if the returned value is to be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d31581f409e137dd612d786dd84ed15f076e6f" translate="yes" xml:space="preserve">
          <source>If a function with an untyped parameter is specified, this function is called when the variant contains a type that does not match any other function. This can be used to apply the same function across multiple possible types. Exactly one generic function is allowed.</source>
          <target state="translated">Si se especifica una función con un parámetro no escrito,se llama esta función cuando la variante contiene un tipo que no coincide con ninguna otra función.Esto puede utilizarse para aplicar la misma función a varios tipos posibles.Se permite exactamente una función genérica.</target>
        </trans-unit>
        <trans-unit id="a87b66dd6db50119dfebfdc41112382fe6b81c05" translate="yes" xml:space="preserve">
          <source>If a function without parameters is specified, this function is called when &lt;code&gt;variant&lt;/code&gt; doesn't hold a value. Exactly one parameter-less function is allowed.</source>
          <target state="translated">Si se especifica una funci&amp;oacute;n sin par&amp;aacute;metros, se llama a esta funci&amp;oacute;n cuando la &lt;code&gt;variant&lt;/code&gt; e no tiene un valor. Se permite exactamente una funci&amp;oacute;n sin par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="834aeb00a2af9d1c11ab80f05c9f251ecfe858eb" translate="yes" xml:space="preserve">
          <source>If a legacy boolean returning custom handler is used, &lt;code&gt;false&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.fail&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; maps to &lt;code&gt;UnitTestResult.pass&lt;/code&gt;. This was the original behavior of the unit testing system.</source>
          <target state="translated">Si se utiliza un controlador personalizado booleano de retorno heredado, &lt;code&gt;false&lt;/code&gt; mapas falsos a &lt;code&gt;UnitTestResult.fail&lt;/code&gt; y &lt;code&gt;true&lt;/code&gt; mapas verdaderos a &lt;code&gt;UnitTestResult.pass&lt;/code&gt; . Este fue el comportamiento original del sistema de prueba de la unidad.</target>
        </trans-unit>
        <trans-unit id="82b2fe9ee0ea82740e7dc777c9a1e9340bcda42d" translate="yes" xml:space="preserve">
          <source>If a library routine cannot handle the Typedef type, you can use the &lt;code&gt;TypedefType&lt;/code&gt; template to extract the type which the Typedef wraps.</source>
          <target state="translated">Si una rutina de biblioteca no puede manejar el tipo Typedef, puede usar la plantilla &lt;code&gt;TypedefType&lt;/code&gt; para extraer el tipo que envuelve Typedef.</target>
        </trans-unit>
        <trans-unit id="6017cad6474bb7ce228682e278fda385b81e533f" translate="yes" xml:space="preserve">
          <source>If a memory object has only one pointer to it, that pointer is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aba4b8ca7c725b8d06f470a62c86a1bda5b271f" translate="yes" xml:space="preserve">
          <source>If a mixin has an</source>
          <target state="translated">Si una mezcla tiene un</target>
        </trans-unit>
        <trans-unit id="016a5428498ce2567043077b67b52a004f09c60b" translate="yes" xml:space="preserve">
          <source>If a module C imports modules A and B, any modifications to B will not silently change code in C that is dependent on A.</source>
          <target state="translated">Si un módulo C importa los módulos A y B,las modificaciones de B no cambiarán silenciosamente el código de C que depende de A.</target>
        </trans-unit>
        <trans-unit id="c291b53fa8bebca9657457c0dc4a5986d2a7e4df" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt; reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84ff68027db236d1e6d7027fe7c21486026d4f8" translate="yes" xml:space="preserve">
          <source>If a nested class has the &lt;code&gt;static&lt;/code&gt; attribute, then it can not access variables of the enclosing scope that are local to the stack or need a &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Si una clase anidada tiene el atributo &lt;code&gt;static&lt;/code&gt; , entonces no puede acceder a las variables del alcance que son locales a la pila o necesita &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="384ca96bef7bf27444107f5f4fec2bea50635462" translate="yes" xml:space="preserve">
          <source>If a new scope is desired for each expansion, use another set of braces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c79f57d1a50238baec29c9e84fb38c7b1202da" translate="yes" xml:space="preserve">
          <source>If a option is required, not passing it will result in an error</source>
          <target state="translated">Si se requiere una opción,no pasarla resultará en un error</target>
        </trans-unit>
        <trans-unit id="149e6d9194089a56d26c5e902cbd9179de1d63bd" translate="yes" xml:space="preserve">
          <source>If a parameter-less function is specified it is called when either &lt;code&gt;variant&lt;/code&gt; doesn't hold a value or holds a type which isn't handled by the visiting functions.</source>
          <target state="translated">Si se especifica una funci&amp;oacute;n sin par&amp;aacute;metros, se llama cuando cualquiera de las &lt;code&gt;variant&lt;/code&gt; es no tiene un valor o tiene un tipo que las funciones de visita no manejan.</target>
        </trans-unit>
        <trans-unit id="7beb51fb64caa2734e6c937b4e1f891bde552887" translate="yes" xml:space="preserve">
          <source>If a pointer contains a</source>
          <target state="translated">Si un puntero contiene un</target>
        </trans-unit>
        <trans-unit id="54a6b6d625a26fd15e5bed961a528f1a4d8c8d83" translate="yes" xml:space="preserve">
          <source>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter.</source>
          <target state="translated">Si una función de propiedad no tiene parámetros,funciona como un getter.Si tiene exactamente un parámetro,funciona como un &quot;setter&quot;.</target>
        </trans-unit>
        <trans-unit id="bd63b3bb30889f251334a86eb473db6c340d3649" translate="yes" xml:space="preserve">
          <source>If a protocol name is omitted, any protocol will be matched.</source>
          <target state="translated">Si se omite un nombre de protocolo,cualquier protocolo será igualado.</target>
        </trans-unit>
        <trans-unit id="bc8ed891e7a0d7d840793ac113f827ba325b777c" translate="yes" xml:space="preserve">
          <source>If a range returned by &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;asyncBuf&lt;/code&gt; is used as an input to &lt;code&gt;map&lt;/code&gt;, then as an optimization the copying from the output buffer of the first range to the input buffer of the second range is elided, even though the ranges returned by &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;asyncBuf&lt;/code&gt; are non-random access ranges. This means that the &lt;code&gt;bufSize&lt;/code&gt; parameter passed to the current call to &lt;code&gt;map&lt;/code&gt; will be ignored and the size of the buffer will be the buffer size of &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">Si un rango devuelto por &lt;code&gt;map&lt;/code&gt; o &lt;code&gt;asyncBuf&lt;/code&gt; se usa como entrada para &lt;code&gt;map&lt;/code&gt; ear , entonces, como optimizaci&amp;oacute;n, se copia la copia del buffer de salida del primer rango al buffer de entrada del segundo rango, aunque los rangos devueltos por &lt;code&gt;map&lt;/code&gt; y &lt;code&gt;asyncBuf&lt;/code&gt; son rangos de acceso no aleatorio. Esto significa que el par&amp;aacute;metro &lt;code&gt;bufSize&lt;/code&gt; pasado a la llamada actual al &lt;code&gt;map&lt;/code&gt; a se ignorar&amp;aacute; y el tama&amp;ntilde;o del b&amp;uacute;fer ser&amp;aacute; el tama&amp;ntilde;o del b&amp;uacute;fer de &lt;code&gt;source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a76bf15d9ef796c131b625f04b8d1b48403d73" translate="yes" xml:space="preserve">
          <source>If a slice operator appears as the left-hand side of an assignment expression, and the type of the right-hand side is the same as the element type of the left-hand side, then the array contents of the left-hand side are set to the right-hand side.</source>
          <target state="translated">Si un operador de rebanada aparece como el lado izquierdo de una expresión de asignación,y el tipo del lado derecho es el mismo que el tipo de elemento del lado izquierdo,entonces el contenido de la matriz del lado izquierdo se establece en el lado derecho.</target>
        </trans-unit>
        <trans-unit id="290e0c5d88ccb110cac619050e0670bb23f215bd" translate="yes" xml:space="preserve">
          <source>If a strongly pure function throws an exception or an error, the assumptions related to memoization and references do not carry to the thrown exception.</source>
          <target state="translated">Si una función fuertemente pura arroja una excepción o un error,los supuestos relacionados con la memorización y las referencias no llevan a la excepción arrojada.</target>
        </trans-unit>
        <trans-unit id="b78555ca8d430d27e26cbbff76c2b38ef65ebc11" translate="yes" xml:space="preserve">
          <source>If a struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a5f4c5b0a3ecfb344535d097fbd6472ec3aaaf" translate="yes" xml:space="preserve">
          <source>If a subexpression of an expression throws an exception, all temporaries created up to the evaluation of that subexpression will be destroyed per the rules above. No destructor calls will be issued for temporaries not yet constructed.</source>
          <target state="translated">Si una subexpresión de una expresión arroja una excepción,todos los temporales creados hasta la evaluación de esa subexpresión serán destruidos según las reglas anteriores.No se emitirán llamadas destructoras para los temporales aún no construidos.</target>
        </trans-unit>
        <trans-unit id="c750c9691a6ca511a5908ab0fae040fe6ae197ae" translate="yes" xml:space="preserve">
          <source>If a template argument matches a specialized template parameter, the argument is mangled with prefix &lt;b&gt;H&lt;/b&gt;.</source>
          <target state="translated">Si un argumento de plantilla coincide con un par&amp;aacute;metro de plantilla especializada, el argumento se ha mezclado con el prefijo &lt;b&gt;H&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="537fb8313b9340d6a7720624890b667ceaf5eabd" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier and if the type or the parameters type of these members include at least all the template parameters then these members are assumed to be referred to in a template instantiation:</source>
          <target state="translated">Si una plantilla contiene miembros cuyo nombre es el mismo que el identificador de la plantilla y si el tipo o el tipo de parámetros de estos miembros incluyen al menos todos los parámetros de la plantilla,se supone que se hace referencia a estos miembros en una instanciación de la plantilla:</target>
        </trans-unit>
        <trans-unit id="89c78b76971977e3949d885ca70ed72b7e954c2c" translate="yes" xml:space="preserve">
          <source>If a template contains members whose name is the same as the template identifier then these members are assumed to be referred to in a template instantiation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae6a5dbef8ce07c71db2a20a8cd25a725a5d57c" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template (see &lt;a href=&quot;#implicit_template_properties&quot;&gt;Eponymous Templates&lt;/a&gt;:)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e940bc97403a68b4bd6fcc2185065a84be4a8ef" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a class with the same name as the template:</source>
          <target state="translated">Si una plantilla declara exactamente un miembro,y ese miembro es una clase con el mismo nombre que la plantilla:</target>
        </trans-unit>
        <trans-unit id="7228f16c50b7195b2939cb5fdb81b9ec5f38dc52" translate="yes" xml:space="preserve">
          <source>If a template declares exactly one member, and that member is a function with the same name as the template, it is a function template declaration. Alternatively, a function template declaration is a function declaration with a &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; immediately preceding the &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Parameters&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Si una plantilla declara exactamente un miembro, y ese miembro es una funci&amp;oacute;n con el mismo nombre que la plantilla, es una declaraci&amp;oacute;n de plantilla de funci&amp;oacute;n. Alternativamente, una declaraci&amp;oacute;n de plantilla de funci&amp;oacute;n es una declaraci&amp;oacute;n de funci&amp;oacute;n con una &lt;a href=&quot;#TemplateParameterList&quot;&gt;&lt;i&gt;TemplateParameterList&lt;/i&gt;&lt;/a&gt; inmediatamente anterior a los &lt;a href=&quot;function#Parameters&quot;&gt;&lt;i&gt;Par&amp;aacute;metros&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f02f572072804182d7734d7a928006f6d805f14" translate="yes" xml:space="preserve">
          <source>If a template has a &lt;a href=&quot;#aliasparameters&quot;&gt;template alias parameter&lt;/a&gt;, and is instantiated with a local symbol, the instantiated function will implicitly become nested in order to access runtime data of the given local symbol.</source>
          <target state="translated">Si una plantilla tiene un &lt;a href=&quot;#aliasparameters&quot;&gt;par&amp;aacute;metro de alias de plantilla&lt;/a&gt; y se instancia con un s&amp;iacute;mbolo local, la funci&amp;oacute;n instanciada se anidar&amp;aacute; impl&amp;iacute;citamente para acceder a los datos de tiempo de ejecuci&amp;oacute;n del s&amp;iacute;mbolo local dado.</target>
        </trans-unit>
        <trans-unit id="996438a9f4c88ad530df79801ff8b03c0e475abe" translate="yes" xml:space="preserve">
          <source>If a template is declared in aggregate or function local scope, the instantiated functions will implicitly capture the context of the enclosing scope.</source>
          <target state="translated">Si se declara una plantilla en el ámbito local agregado o de funciones,las funciones instanciadas captarán implícitamente el contexto del ámbito adjunto.</target>
        </trans-unit>
        <trans-unit id="449794f5173b1c91e0c8a9e969999efee1d1266f" translate="yes" xml:space="preserve">
          <source>If a variable has a scope destructor call, return call for it. Otherwise, return NULL.</source>
          <target state="translated">Si una variable tiene una llamada de destructor de alcance,devuelva la llamada.De lo contrario,devuelva NULL.</target>
        </trans-unit>
        <trans-unit id="e7d0ce5000213342db830246324bf60d4a0dcc21" translate="yes" xml:space="preserve">
          <source>If after all the type arguments are examined, there are any type parameters left with no type assigned, they are assigned types corresponding to the template argument in the same position in the</source>
          <target state="translated">Si después de examinar todos los argumentos de tipo,quedan parámetros de tipo sin tipo asignado,se les asignan tipos correspondientes al argumento de plantilla en la misma posición en el</target>
        </trans-unit>
        <trans-unit id="8425958e6e0e9a1c94e548c8eed6685e1c97af18" translate="yes" xml:space="preserve">
          <source>If aliased to the same object or both null =&amp;gt; equal</source>
          <target state="translated">Si tiene alias para el mismo objeto o ambos nulo =&amp;gt; igual</target>
        </trans-unit>
        <trans-unit id="201815c4325a8fddf0539c89b74ba96e4169f933" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">Si un &lt;code&gt;auto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa6bbb7d06b0bd7ec69b77758d95900b4054089" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;enum&lt;/code&gt; is used as type, the random variate is drawn with equal probability from any of the possible values of the enum &lt;code&gt;E&lt;/code&gt;.</source>
          <target state="translated">Si un &lt;code&gt;enum&lt;/code&gt; se utiliza como tipo, el valor aleatorio se dibuja con la misma probabilidad de cualquiera de los posibles valores de la enumeraci&amp;oacute;n &lt;code&gt;E&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="168c9f0755c4bd4e21cdb3d96a893ad7470eff57" translate="yes" xml:space="preserve">
          <source>If an aggregate declaration defines an &lt;code&gt;opCmp&lt;/code&gt; or &lt;code&gt;opEquals&lt;/code&gt; method, it will take precedence to that of the aliased this member. Note that, unlike an &lt;code&gt;opCmp&lt;/code&gt; method, an &lt;code&gt;opEquals&lt;/code&gt; method is implicitly defined for a &lt;code&gt;struct&lt;/code&gt; declaration if a user defined one isn't provided; this means that if the aliased this member &lt;code&gt;opEquals&lt;/code&gt; is preferred it should be explicitly defined:</source>
          <target state="translated">Si una declaraci&amp;oacute;n agregada define un m&amp;eacute;todo &lt;code&gt;opCmp&lt;/code&gt; u &lt;code&gt;opEquals&lt;/code&gt; , tendr&amp;aacute; prioridad sobre el del miembro con alias. Tenga en cuenta que, a diferencia de un m&amp;eacute;todo &lt;code&gt;opCmp&lt;/code&gt; , un m&amp;eacute;todo &lt;code&gt;opEquals&lt;/code&gt; se define impl&amp;iacute;citamente para una declaraci&amp;oacute;n de &lt;code&gt;struct&lt;/code&gt; si no se proporciona uno definido por el usuario; Esto significa que si se prefiere el alias este miembro &lt;code&gt;opEquals&lt;/code&gt; , debe definirse expl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="2cf56dfdcc6eee095fd25bd060be3e831d6148d4" translate="yes" xml:space="preserve">
          <source>If an append must reallocate a slice with no possibility of extension, then &lt;code&gt;0&lt;/code&gt; is returned. This happens when the slice references a static array, or if another slice references elements past the end of the current slice.</source>
          <target state="translated">Si un anexo debe reasignar un segmento sin posibilidad de extensi&amp;oacute;n, se devuelve &lt;code&gt;0&lt;/code&gt; . Esto sucede cuando el segmento hace referencia a una matriz est&amp;aacute;tica, o si otro segmento hace referencia a elementos m&amp;aacute;s all&amp;aacute; del final del segmento actual.</target>
        </trans-unit>
        <trans-unit id="fbeff861e7616c530bb5c083257a7ef08f727eef" translate="yes" xml:space="preserve">
          <source>If an application needs to do its own processing of whichever arguments &lt;code&gt;getopt&lt;/code&gt; did not understand, it can pass the &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; directive to &lt;code&gt;getopt&lt;/code&gt;:</source>
          <target state="translated">Si una aplicaci&amp;oacute;n necesita hacer su propio procesamiento de cualquier argumento que &lt;code&gt;getopt&lt;/code&gt; no haya entendido, puede pasar la directiva &lt;code&gt;std.getopt.config.passThrough&lt;/code&gt; a &lt;code&gt;getopt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eaf53aac4b71af8424769f45a7b82ff0df7d317c" translate="yes" xml:space="preserve">
          <source>If an enum has as a base type one of the types in the left column, it is converted to the type in the right column.</source>
          <target state="translated">Si un enum tiene como tipo base uno de los tipos de la columna izquierda,se convierte en el tipo de la columna derecha.</target>
        </trans-unit>
        <trans-unit id="3c064315a80e4366fd87dbfa8b9a5125e74f88b6" translate="yes" xml:space="preserve">
          <source>If an error occurs during the compilation of your program, the use of overloads and overrides needs to be reexamined in the relevant classes.</source>
          <target state="translated">Si se produce un error durante la compilación de su programa,el uso de sobrecargas y anulaciones debe ser reexaminado en las clases pertinentes.</target>
        </trans-unit>
        <trans-unit id="a2623dd123c39f9f457825f03bd99064fa3431f1" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the</source>
          <target state="translated">Si se plantea una excepción en el</target>
        </trans-unit>
        <trans-unit id="180043ac16b1a016937b09456574733627d6647e" translate="yes" xml:space="preserve">
          <source>If an exception is thrown but it has an empty message, then &lt;code&gt;emptyExceptionMsg&lt;/code&gt; is returned.</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n pero tiene un mensaje vac&amp;iacute;o, se &lt;code&gt;emptyExceptionMsg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb4162f43906e6c9a7e64e7ecdf711ae4fd96612" translate="yes" xml:space="preserve">
          <source>If an identical type to &lt;code&gt;type&lt;/code&gt; is in &lt;code&gt;type.stringtable&lt;/code&gt;, return the latter one. Otherwise, add it to &lt;code&gt;type.stringtable&lt;/code&gt;. Some types don't get merged and are returned as-is.</source>
          <target state="translated">Si un tipo id&amp;eacute;ntico para &lt;code&gt;type&lt;/code&gt; est&amp;aacute; en &lt;code&gt;type.stringtable&lt;/code&gt; , devuelva el &amp;uacute;ltimo. De lo contrario, agr&amp;eacute;guelo a &lt;code&gt;type.stringtable&lt;/code&gt; . Algunos tipos no se fusionan y se devuelven tal cual.</target>
        </trans-unit>
        <trans-unit id="2efd485ddee09f5b6939ce6531c2909633020004" translate="yes" xml:space="preserve">
          <source>If an identity assignment overload is required and does not exist, an identity assignment overload function of the type &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; will be automatically generated.</source>
          <target state="translated">Si se requiere una sobrecarga de asignaci&amp;oacute;n de identidad y no existe, se generar&amp;aacute; autom&amp;aacute;ticamente una funci&amp;oacute;n de sobrecarga de asignaci&amp;oacute;n de identidad del tipo &lt;code&gt;ref S opAssign(ref S)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5e3f00360d5b8852208ee3415dc3a1a01f6dc8" translate="yes" xml:space="preserve">
          <source>If an implicit conversion is disallowed by the table, an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; may be converted if:</source>
          <target state="translated">Si la tabla no permite una conversi&amp;oacute;n impl&amp;iacute;cita, se puede convertir una &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expresi&amp;oacute;n&lt;/i&gt;&lt;/a&gt; si:</target>
        </trans-unit>
        <trans-unit id="9520036db9c2c3cb7627c2cb880cb288fe8ee7ee" translate="yes" xml:space="preserve">
          <source>If an index expression can be rewritten using &lt;code&gt;opIndexAssign&lt;/code&gt; or &lt;code&gt;opIndexOpAssign&lt;/code&gt;, those are preferred over &lt;code&gt;opIndex&lt;/code&gt;.</source>
          <target state="translated">Si una expresi&amp;oacute;n de &amp;iacute;ndice puede reescribirse usando &lt;code&gt;opIndexAssign&lt;/code&gt; u &lt;code&gt;opIndexOpAssign&lt;/code&gt; , se prefieren a &lt;code&gt;opIndex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d0247eb6c576e08ded3f7c08dff25cd606da70" translate="yes" xml:space="preserve">
          <source>If an interface has &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt; storage class, then all members of the interface are &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;immutable&lt;/code&gt;. This storage class is not inherited.</source>
          <target state="translated">Si una interfaz tiene una clase de almacenamiento &lt;code&gt;const&lt;/code&gt; ante o &lt;code&gt;immutable&lt;/code&gt; , entonces todos los miembros de la interfaz son &lt;code&gt;const&lt;/code&gt; antes o &lt;code&gt;immutable&lt;/code&gt; . Esta clase de almacenamiento no se hereda.</target>
        </trans-unit>
        <trans-unit id="7e7381c9bb35e9f77c152ce0763035229030f128" translate="yes" xml:space="preserve">
          <source>If an option is bound to a numeric type, a number is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Si una opción está vinculada a un tipo numérico,se espera que un número sea la siguiente opción,o justo dentro de la opción separada con un signo &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="e1388310610be9143f93d5757e5dd370de55e952" translate="yes" xml:space="preserve">
          <source>If an option is bound to a string, a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Si una opción está ligada a una cadena,se espera una cadena como la siguiente opción,o justo dentro de la opción separada con un signo &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="cd9d52ae8827e5578c6e463b4801745d426f4b79" translate="yes" xml:space="preserve">
          <source>If an option is bound to an array, a new element is appended to the array each time the option occurs:</source>
          <target state="translated">Si una opción está vinculada a una matriz,se añade un nuevo elemento a la matriz cada vez que se produce la opción:</target>
        </trans-unit>
        <trans-unit id="d7c493c513172131987de31a463653700c8dc123" translate="yes" xml:space="preserve">
          <source>If an option is bound to an associative array, a string of the form &quot;name=value&quot; is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Si una opción está unida a una matriz asociativa,se espera una cadena de la forma &quot;nombre=valor&quot; como la siguiente opción,o justo dentro de la opción separada con un signo &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="b6f632caf5c4044e09e5739104d63549a3fc0c34" translate="yes" xml:space="preserve">
          <source>If an option is bound to an enum, an enum symbol as a string is expected as the next option, or right within the option separated with an &quot;=&quot; sign:</source>
          <target state="translated">Si una opción está vinculada a un enum,se espera un símbolo enum como cadena como la siguiente opción,o justo dentro de la opción separada con un signo &quot;=&quot;:</target>
        </trans-unit>
        <trans-unit id="7c32990bfc4d36bb0abf0d415d84bd3e023f0845" translate="yes" xml:space="preserve">
          <source>If an option name has a &quot;+&quot; suffix and is bound to a numeric type, then the option's value tracks the number of times the option occurred on the command line:</source>
          <target state="translated">Si el nombre de una opción tiene un sufijo &quot;+&quot; y está ligado a un tipo numérico,entonces el valor de la opción sigue el número de veces que la opción se produjo en la línea de comandos:</target>
        </trans-unit>
        <trans-unit id="3bc9e305061e747e54d09f33e1d219d952240a58" translate="yes" xml:space="preserve">
          <source>If an option string is followed by another string, this string serves as a description for this option. The &lt;code&gt;getopt&lt;/code&gt; function returns a struct of type &lt;code&gt;GetoptResult&lt;/code&gt;. This return value contains information about all passed options as well a &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; flag indicating whether information about these options was requested. The &lt;code&gt;getopt&lt;/code&gt; function always adds an option for &lt;code&gt;--help|-h&lt;/code&gt; to set the flag if the option is seen on the command line.</source>
          <target state="translated">Si una cadena de opciones es seguida por otra cadena, esta cadena sirve como una descripci&amp;oacute;n para esta opci&amp;oacute;n. La funci&amp;oacute;n &lt;code&gt;getopt&lt;/code&gt; devuelve una estructura de tipo &lt;code&gt;GetoptResult&lt;/code&gt; . Este valor de retorno contiene informaci&amp;oacute;n sobre todas las opciones pasadas, as&amp;iacute; como un &lt;code&gt;bool GetoptResult.helpWanted&lt;/code&gt; que indica si se solicit&amp;oacute; informaci&amp;oacute;n sobre estas opciones. La funci&amp;oacute;n &lt;code&gt;getopt&lt;/code&gt; siempre agrega una opci&amp;oacute;n para &lt;code&gt;--help|-h&lt;/code&gt; para establecer el indicador si la opci&amp;oacute;n se ve en la l&amp;iacute;nea de comando.</target>
        </trans-unit>
        <trans-unit id="cecb4b7cfecf63467f6f4623b6ecf01515e03ef4" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;TaskPool&lt;/code&gt; with non-daemon threads is active, either &lt;code&gt;stop&lt;/code&gt; or &lt;code&gt;finish&lt;/code&gt; must be called on it before the program can terminate.</source>
          <target state="translated">Si alg&amp;uacute;n &lt;code&gt;TaskPool&lt;/code&gt; con subprocesos que no son daemon est&amp;aacute; activo, debe &lt;code&gt;stop&lt;/code&gt; o &lt;code&gt;finish&lt;/code&gt; antes de que el programa pueda finalizar.</target>
        </trans-unit>
        <trans-unit id="2442edf64b05fed93875352de9ddef61974e4dcd" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, struct default construction is also disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a14ab7622e0f011a987d4940247d86d91424d5c2" translate="yes" xml:space="preserve">
          <source>If any fields have disabled default construction, the struct default construction is also disabled.</source>
          <target state="translated">Si algún campo tiene deshabilitada la construcción por defecto,la construcción por defecto de la estructura también está deshabilitada.</target>
        </trans-unit>
        <trans-unit id="11956d46948d1d13d7ee53327bbd180ff0d5d12d" translate="yes" xml:space="preserve">
          <source>If any of &lt;code&gt;lead&lt;/code&gt; and &lt;code&gt;vowel&lt;/code&gt; are not a valid hangul jamo of the respective &lt;a href=&quot;#Character&quot;&gt;character&lt;/a&gt; class returns dchar.init.</source>
          <target state="translated">Si alguno de los &lt;code&gt;lead&lt;/code&gt; y &lt;code&gt;vowel&lt;/code&gt; no son un hangul jamo v&amp;aacute;lido de la clase de &lt;a href=&quot;#Character&quot;&gt;personaje&lt;/a&gt; respectiva , devuelve dchar.init.</target>
        </trans-unit>
        <trans-unit id="643424aa2159c0dc971a85e93b28f54bc425b055" translate="yes" xml:space="preserve">
          <source>If any of the arguments in the &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; are a</source>
          <target state="translated">Si alguno de los argumentos en &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; es un</target>
        </trans-unit>
        <trans-unit id="3744bc315bbcad378bdb3ff87a3b9de7d402fea7" translate="yes" xml:space="preserve">
          <source>If any of the checks fail, a compile error will occur.</source>
          <target state="translated">Si alguna de las comprobaciones falla,se producirá un error de compilación.</target>
        </trans-unit>
        <trans-unit id="def10a047da7cb724c42b1f59da46ab76ef31dc6" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in the</source>
          <target state="translated">Si alguna de las claves o valores en el</target>
        </trans-unit>
        <trans-unit id="41bc7edc68b18e54f236d3ac39e824893010bd91" translate="yes" xml:space="preserve">
          <source>If applying the above rules does not result in exactly one type for each template parameter, then it is an error.</source>
          <target state="translated">Si la aplicación de las reglas anteriores no da como resultado exactamente un tipo para cada parámetro de la plantilla,entonces es un error.</target>
        </trans-unit>
        <trans-unit id="a7c844c173ee0a673d9ab2e503851d6c710a834c" translate="yes" xml:space="preserve">
          <source>If assertions are enabled and &lt;code&gt;toRange&lt;/code&gt; has been called, then this WorkerLocalStorage instance is no longer worker-local and an assertion failure will result when calling this method. This is not checked when assertions are disabled for performance reasons.</source>
          <target state="translated">Si las aserciones est&amp;aacute;n habilitadas y se ha llamado a &lt;code&gt;toRange&lt;/code&gt; , entonces esta instancia de WorkerLocalStorage ya no es un trabajador local y se producir&amp;aacute; un error de aserci&amp;oacute;n al llamar a este m&amp;eacute;todo. Esto no se verifica cuando las aserciones est&amp;aacute;n deshabilitadas por razones de rendimiento.</target>
        </trans-unit>
        <trans-unit id="2a4c7b046cde0bb5e12a60d5ebe77f7e562208f5" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825f4197814b0d68b55040d1d95ed5fec00d9458" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#maxElement&quot;&gt;&lt;code&gt;std.algorithm.searching.maxElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51eb056f1717f5d30ca42a509337be76f7a52798" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments is NaN, the result is an unspecified value. See &lt;a href=&quot;std_algorithm_searching#minElement&quot;&gt;&lt;code&gt;std.algorithm.searching.minElement&lt;/code&gt;&lt;/a&gt; for examples on how to cope with NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df118ef438600490adb83de4d6beaa35bff251d8" translate="yes" xml:space="preserve">
          <source>If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all input ranges and picking the highest &lt;code&gt;tgt.length&lt;/code&gt;, weight-based ranking elements.</source>
          <target state="translated">Si al menos uno de los rangos es un conjunto m&amp;uacute;ltiple, se tienen en cuenta todas las ocurrencias de un elemento duplicado. El resultado es equivalente a fusionar todos los rangos de entrada y elegir los elementos de clasificaci&amp;oacute;n basados ​​en el peso de &lt;code&gt;tgt.length&lt;/code&gt; m&amp;aacute;s altos .</target>
        </trans-unit>
        <trans-unit id="4519d0d5950e5356f4f13b61a821ffce61eda0b3" translate="yes" xml:space="preserve">
          <source>If authentication or redirections are done then the status will be for the last response received.</source>
          <target state="translated">Si se hace una autenticación o redireccionamiento,el estado será el de la última respuesta recibida.</target>
        </trans-unit>
        <trans-unit id="cd6490598a4d93059510177bb453af0037be62bb" translate="yes" xml:space="preserve">
          <source>If autodecoding is turned off, then this is equivalent to duplicating the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742bd1e8cf3c2f25ee274ec3880df5cf7f721969" translate="yes" xml:space="preserve">
          <source>If autodecoding is turned on (default), then they are handled as a separate overload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0246e59acc96ca671df31d602e303fc5a3e9ab" translate="yes" xml:space="preserve">
          <source>If blocking argument is true, wait for all worker threads to terminate before returning. This option might be used in applications where task results are never consumed-- e.g. when &lt;code&gt;TaskPool&lt;/code&gt; is employed as a rudimentary scheduler for tasks which communicate by means other than return values.</source>
          <target state="translated">Si el argumento de bloqueo es verdadero, espere a que todos los subprocesos de trabajo finalicen antes de regresar. Esta opci&amp;oacute;n podr&amp;iacute;a usarse en aplicaciones donde los resultados de la tarea nunca se consumen, por ejemplo, cuando &lt;code&gt;TaskPool&lt;/code&gt; se emplea como un programador rudimentario para tareas que se comunican por medios distintos de los valores de retorno.</target>
        </trans-unit>
        <trans-unit id="7479ca1ded9e48be6a8e038bc9b2488efa665f70" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Primary&lt;/code&gt; and &lt;code&gt;Fallback&lt;/code&gt; are stateless, &lt;code&gt;FallbackAllocator&lt;/code&gt; defines a static instance called &lt;code&gt;instance&lt;/code&gt;.</source>
          <target state="translated">Si tanto &lt;code&gt;Primary&lt;/code&gt; como &lt;code&gt;Fallback&lt;/code&gt; no tienen estado, &lt;code&gt;FallbackAllocator&lt;/code&gt; define una instancia est&amp;aacute;tica llamada &lt;code&gt;instance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec43df7b50b565bd7b1219f8c1f3ab8b182ffb2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are integers (may be constant-folded), the slice expression can be converted to a static array type &lt;code&gt;T[b - a]&lt;/code&gt;.</source>
          <target state="translated">Si tanto &lt;code&gt;a&lt;/code&gt; como &lt;code&gt;b&lt;/code&gt; son enteros (pueden estar plegados constantemente), la expresi&amp;oacute;n de corte se puede convertir a una matriz est&amp;aacute;tica tipo &lt;code&gt;T[b - a]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0deff799fed4758452aa1b15f9e2a5541bd46d3e" translate="yes" xml:space="preserve">
          <source>If both a template with a sequence parameter and a template without a sequence parameter exactly match a template instantiation, the template without a</source>
          <target state="translated">Si tanto una plantilla con un parámetro de secuencia como una plantilla sin un parámetro de secuencia coinciden exactamente con una instanciación de la plantilla,la plantilla sin un</target>
        </trans-unit>
        <trans-unit id="220f653add85effdd5e512619500f4b49743b534" translate="yes" xml:space="preserve">
          <source>If both allocators are &lt;code&gt;shared&lt;/code&gt;, the &lt;code&gt;Segregator&lt;/code&gt; will also offer &lt;code&gt;shared&lt;/code&gt; methods.</source>
          <target state="translated">Si ambos asignadores son &lt;code&gt;shared&lt;/code&gt; , el &lt;code&gt;Segregator&lt;/code&gt; tambi&amp;eacute;n ofrecer&amp;aacute; m&amp;eacute;todos &lt;code&gt;shared&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69639385682c3a994448b82bd2bb7cf46189be9b" translate="yes" xml:space="preserve">
          <source>If both are signed or both are unsigned, the smaller type is converted to the larger.</source>
          <target state="translated">Si ambos están firmados o ambos no lo están,el tipo más pequeño se convierte en el más grande.</target>
        </trans-unit>
        <trans-unit id="05fb2e935ce549269270c5d42145fc9b4f07b7f4" translate="yes" xml:space="preserve">
          <source>If both are the same type, no more conversions are done.</source>
          <target state="translated">Si ambos son del mismo tipo,no se hacen más conversiones.</target>
        </trans-unit>
        <trans-unit id="05dd5c60a4e9b82d4adbecb6f4127f3d732ab860" translate="yes" xml:space="preserve">
          <source>If both arguments are ranges of L-values of the same type then &lt;code&gt;SetSymmetricDifference&lt;/code&gt; will also be a range of L-values of that type.</source>
          <target state="translated">Si ambos argumentos son rangos de valores L del mismo tipo, entonces &lt;code&gt;SetSymmetricDifference&lt;/code&gt; tambi&amp;eacute;n ser&amp;aacute; un rango de valores L de ese tipo.</target>
        </trans-unit>
        <trans-unit id="f20cc499ea7bfd3b9b5a7bc116d95b44ec6d1e4b" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. For example, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt;, &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;, &lt;code&gt;int.max + 1 == int.min&lt;/code&gt;, and &lt;code&gt;int.min - 1 == int.max&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1166af836d0ff22ec8996cf90c0ca104ddf9187" translate="yes" xml:space="preserve">
          <source>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. That is, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; and &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt;.</source>
          <target state="translated">Si ambos operandos son de tipos integrales y se produce un desbordamiento o un subflujo en el c&amp;aacute;lculo, se producir&amp;aacute; un ajuste. Es decir, &lt;code&gt;uint.max + 1 == uint.min&lt;/code&gt; y &lt;code&gt;uint.min - 1 == uint.max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88c921254e07ee3d3550bb0c4328e00c73dbba70" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;+&lt;/code&gt;, then it is illegal.</source>
          <target state="translated">Si ambos operandos son punteros y el operador es &lt;code&gt;+&lt;/code&gt; , entonces es ilegal.</target>
        </trans-unit>
        <trans-unit id="d175863c948db7d84910700658bc03bfa12bed2a" translate="yes" xml:space="preserve">
          <source>If both operands are pointers, and the operator is &lt;code&gt;-&lt;/code&gt;, the pointers are subtracted and the result is divided by the size of the type pointed to by the operands. In this calculation the assumed size of &lt;code&gt;void&lt;/code&gt; is one byte. It is an error if the pointers point to different types. The type of the result is &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">Si ambos operandos son punteros, y el operador es &lt;code&gt;-&lt;/code&gt; , los punteros se restan y el resultado se divide por el tama&amp;ntilde;o del tipo se&amp;ntilde;alado por los operandos. En este c&amp;aacute;lculo, el tama&amp;ntilde;o supuesto de &lt;code&gt;void&lt;/code&gt; es un byte. Es un error si los punteros apuntan a diferentes tipos. El tipo del resultado es &lt;code&gt;ptrdiff_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1abf720abea123f60d5888992d6209534bf4e09" translate="yes" xml:space="preserve">
          <source>If both ranges are finite, then one must be (at least) a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; and the other an &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;input range&lt;/a&gt;.</source>
          <target state="translated">Si ambos rangos son finitos, uno debe ser (al menos) un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango directo&lt;/a&gt; y el otro un &lt;a href=&quot;std_range_primitives#isInputRange&quot;&gt;rango de entrada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb5178f6f33c9b3fe021f6007cd182ded54b74f7" translate="yes" xml:space="preserve">
          <source>If both ranges are infinite, then both must be forward ranges.</source>
          <target state="translated">Si ambos rangos son infinitos,entonces ambos deben ser rangos hacia adelante.</target>
        </trans-unit>
        <trans-unit id="09621590d3975cfd09fe2c0811ba26754a5cdd9d" translate="yes" xml:space="preserve">
          <source>If both ranges are sets (without duplicated elements), the resulting range is going to be a set. If at least one of the ranges is a multiset, the number of occurences of an element &lt;code&gt;x&lt;/code&gt; in the resulting range is &lt;code&gt;abs(a-b)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r1&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; is the number of occurences of &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;r2&lt;/code&gt;, and &lt;code&gt;abs&lt;/code&gt; is the absolute value.</source>
          <target state="translated">Si ambos rangos son conjuntos (sin elementos duplicados), el rango resultante ser&amp;aacute; un conjunto. Si al menos uno de los rangos es un conjunto m&amp;uacute;ltiple, el n&amp;uacute;mero de ocurrencias de un elemento &lt;code&gt;x&lt;/code&gt; en el rango resultante es &lt;code&gt;abs(a-b)&lt;/code&gt; donde &lt;code&gt;a&lt;/code&gt; es el n&amp;uacute;mero de ocurrencias de &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;r1&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; es el n&amp;uacute;mero de ocurrencias de &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;r2&lt;/code&gt; , y &lt;code&gt;abs&lt;/code&gt; es el valor absoluto.</target>
        </trans-unit>
        <trans-unit id="c3cd520fd113fc0ea9747b7e4b22c4c42d0b39c5" translate="yes" xml:space="preserve">
          <source>If both ranges have a length member, this function is &amp;Omicron;(&lt;code&gt;1&lt;/code&gt;). Otherwise, this function is &amp;Omicron;(&lt;code&gt;min(r1.length, r2.length)&lt;/code&gt;).</source>
          <target state="translated">Si ambos rangos tienen un miembro de longitud, esta funci&amp;oacute;n es &amp;Omicron; ( &lt;code&gt;1&lt;/code&gt; ). De lo contrario, esta funci&amp;oacute;n es &amp;Omicron; ( &lt;code&gt;min(r1.length, r2.length)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="077a8fbc08834027e3db2ad54352fdf64c6364ae" translate="yes" xml:space="preserve">
          <source>If both x and n are 0, the result is 1. If n is negative, an integer divide error will occur at runtime, regardless of the value of x.</source>
          <target state="translated">Si tanto x como n son 0,el resultado es 1.Si n es negativo,se producirá un error de división de números enteros en tiempo de ejecución,independientemente del valor de x.</target>
        </trans-unit>
        <trans-unit id="d8d58e2935a54be899c1932e2430b1d836d6854b" translate="yes" xml:space="preserve">
          <source>If break is followed by</source>
          <target state="translated">Si la ruptura es seguida por</target>
        </trans-unit>
        <trans-unit id="133ff22691958b87ce955cf38fc2654641e5c95a" translate="yes" xml:space="preserve">
          <source>If class invariant checking is turned on, the class invariant is called at the end of the constructor.</source>
          <target state="translated">Si se activa la comprobación de la invariante de clase,la invariante de clase se llama al final del constructor.</target>
        </trans-unit>
        <trans-unit id="2873dd219021490e067fcdc56ae6ce69a60f4696" translate="yes" xml:space="preserve">
          <source>If code detects an error like &quot;out of memory,&quot; then an Error is thrown with a message saying &quot;Out of memory&quot;. The function call stack is unwound, looking for a handler for the Error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finally blocks&lt;/a&gt; are executed as the stack is unwound. If an error handler is found, execution resumes there. If not, the default Error handler is run, which displays the message and terminates the program.</source>
          <target state="translated">Si el c&amp;oacute;digo detecta un error como &quot;sin memoria&quot;, se genera un error con un mensaje que dice &quot;sin memoria&quot;. La pila de llamadas de funci&amp;oacute;n se desenrolla, buscando un controlador para el error. &lt;a href=&quot;statement#TryStatement&quot;&gt;Finalmente, los bloques&lt;/a&gt; se ejecutan cuando la pila se desenrolla. Si se encuentra un controlador de errores, la ejecuci&amp;oacute;n se reanuda all&amp;iacute;. De lo contrario, se ejecuta el controlador de errores predeterminado, que muestra el mensaje y finaliza el programa.</target>
        </trans-unit>
        <trans-unit id="026a3ed1741bfc55e99518c871b70d4250291a91" translate="yes" xml:space="preserve">
          <source>If continue is followed by</source>
          <target state="translated">Si continuar es seguido por</target>
        </trans-unit>
        <trans-unit id="6422eca509193d7e5c40c75cbc0a1df0e38709f1" translate="yes" xml:space="preserve">
          <source>If defined and &lt;code&gt;hookOpCast&lt;/code&gt; is</source>
          <target state="translated">Si se define y &lt;code&gt;hookOpCast&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="5a7e95bb168b15f4a8bcb2b5cf99f8ea675a9dca" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; is used as the default initializer of the payload.</source>
          <target state="translated">Si se define, &lt;code&gt;Hook.defaultValue!T&lt;/code&gt; se utiliza como inicializador predeterminado de la carga &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="03019d524f44be31cdffd6208c1acffd47d8953d" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.max!T&lt;/code&gt; is used as the maximum value of the payload.</source>
          <target state="translated">Si se define, &lt;code&gt;Hook.max!T&lt;/code&gt; se usa como el valor m&amp;aacute;ximo de la carga &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="f5bf55bfa3966b60e1868595f8913387e32b50a0" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;Hook.min!T&lt;/code&gt; is used as the minimum value of the payload.</source>
          <target state="translated">Si se define, &lt;code&gt;Hook.min!T&lt;/code&gt; se utiliza como el valor m&amp;iacute;nimo de la carga &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="c860109476dd6e83e225430bc70cc535b0742b87" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpBinary!op(get, rhs)&lt;/code&gt; (donde &lt;code&gt;op&lt;/code&gt; es el s&amp;iacute;mbolo del operador y &lt;code&gt;rhs&lt;/code&gt; es el operando del lado derecho) se reenv&amp;iacute;a incondicionalmente para los operadores binarios &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22acb3135b0d52c02522e9bda0aa4a9ab72a1f15" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;lhs&lt;/code&gt; is the left-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;^^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpBinaryRight!op(lhs, get)&lt;/code&gt; (donde &lt;code&gt;op&lt;/code&gt; es el s&amp;iacute;mbolo del operador y &lt;code&gt;lhs&lt;/code&gt; es el operando del lado izquierdo) se reenv&amp;iacute;a incondicionalmente para los operadores binarios &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;^^&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f903c768577a0e387a7661822b3ab6e9ea3a27" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; is forwarded to unconditionally when the payload is to be cast to type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpCast!U(get)&lt;/code&gt; se reenv&amp;iacute;a a incondicionalmente cuando la carga &amp;uacute;til es ser echado al tipo &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d39d077b66c222df35757287877d0f5e2f125e3c" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for ordering against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpCmp(get, rhs)&lt;/code&gt; se reenv&amp;iacute;a incondicionalmente cuando se compara la carga &amp;uacute;til para ordenar contra valores &lt;code&gt;rhs&lt;/code&gt; de tipo integral, coma flotante o booleano.</target>
        </trans-unit>
        <trans-unit id="61710dc38aff3803efddd69b40c8a0d534e524ab" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; is forwarded to unconditionally when the payload is compared for equality against value &lt;code&gt;rhs&lt;/code&gt; of integral, floating point, or Boolean type.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpEquals(get, rhs)&lt;/code&gt; se reenv&amp;iacute;a incondicionalmente cuando se compara la carga &amp;uacute;til para la igualdad con el valor &lt;code&gt;rhs&lt;/code&gt; de tipo integral, de punto flotante o booleano.</target>
        </trans-unit>
        <trans-unit id="78db295a6db30c78e28bbcb362075d3be4e0b84f" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol and &lt;code&gt;rhs&lt;/code&gt; is the right-hand side operand) is forwarded to unconditionally for binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpOpAssign!op(payload, rhs)&lt;/code&gt; (donde &lt;code&gt;op&lt;/code&gt; es el s&amp;iacute;mbolo del operador y &lt;code&gt;rhs&lt;/code&gt; es el operando del lado derecho) se reenv&amp;iacute;a incondicionalmente para operadores binarios &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; , y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c14604f1c472b8a4a8bbea3e846c210307c64e" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (where &lt;code&gt;op&lt;/code&gt; is the operator symbol) is forwarded to for unary operators &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. In addition, for unary operators &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; is called, where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by &lt;code&gt;Checked&lt;/code&gt; so the hook can change it.</source>
          <target state="translated">Si se define, &lt;code&gt;hook.hookOpUnary!op(get)&lt;/code&gt; (donde &lt;code&gt;op&lt;/code&gt; es el s&amp;iacute;mbolo del operador) se reenv&amp;iacute;a a los operadores unarios &lt;code&gt;-&lt;/code&gt; y &lt;code&gt;~&lt;/code&gt; . Adem&amp;aacute;s, para operadores unarios &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; , se &lt;code&gt;hook.hookOpUnary!op(payload)&lt;/code&gt; , donde &lt;code&gt;payload&lt;/code&gt; es una referencia al valor envuelto por &lt;code&gt;Checked&lt;/code&gt; para que el hook pueda cambiarlo.</target>
        </trans-unit>
        <trans-unit id="2297e50d0b2beb4cdd48e76ba56a839dcb04ab78" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (where &lt;code&gt;payload&lt;/code&gt; is a reference to the value wrapped by Checked) is forwarded to when &lt;code&gt;toHash&lt;/code&gt; is called on a Checked type. Custom hashing can be implemented in a &lt;code&gt;Hook&lt;/code&gt;, otherwise the built-in hashing is used.</source>
          <target state="translated">Si est&amp;aacute; definido, &lt;code&gt;hook.hookToHash(payload)&lt;/code&gt; (donde la &lt;code&gt;payload&lt;/code&gt; es una referencia al valor envuelto por Checked) se reenv&amp;iacute;a cuando se llama a &lt;code&gt;toHash&lt;/code&gt; en un tipo Checked. El hash personalizado se puede implementar en un &lt;code&gt;Hook&lt;/code&gt; , de lo contrario se usa el hash incorporado.</target>
        </trans-unit>
        <trans-unit id="33310de24a417af9692c142b1ec271b4bb06c9e6" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is smaller than the smallest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si se define, se &lt;code&gt;hook.onLowerBound(value, bound)&lt;/code&gt; (donde &lt;code&gt;value&lt;/code&gt; es el valor asignado) cuando el resultado de operadores binarios &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; , y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; es menor que el valor m&amp;aacute;s peque&amp;ntilde;o representable por &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6931e0e7ba4cd85c003adc62fe48bb16dad0a7" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; is forwarded to for unary operators that overflow but only if &lt;code&gt;hookOpUnary&lt;/code&gt; is not defined. Unary &lt;code&gt;~&lt;/code&gt; does not overflow; unary &lt;code&gt;-&lt;/code&gt; overflows only when the most negative value of a signed type is negated, and the result of the hook call is returned. When the increment or decrement operators overflow, the payload is assigned the result of &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt;. When a binary operator overflows, the result of &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; is returned, but only if &lt;code&gt;Hook&lt;/code&gt; does not define &lt;code&gt;hookOpBinary&lt;/code&gt;.</source>
          <target state="translated">Si se define, se &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; a los operadores unarios que se desbordan, pero solo si &lt;code&gt;hookOpUnary&lt;/code&gt; no est&amp;aacute; definido. Unary &lt;code&gt;~&lt;/code&gt; no se desborda; unario &lt;code&gt;-&lt;/code&gt; desborda solo cuando se niega el valor m&amp;aacute;s negativo de un tipo firmado y se devuelve el resultado de la llamada de enlace. Cuando los operadores de incremento o decremento se desbordan, la carga &amp;uacute;til se le asigna el resultado de &lt;code&gt;hook.onOverflow!op(get)&lt;/code&gt; . Cuando un operador binario se desborda, se &lt;code&gt;hook.onOverflow!op(get, rhs)&lt;/code&gt; el resultado de hook.onOverflow! Op (get, rhs) , pero solo si &lt;code&gt;Hook&lt;/code&gt; no define &lt;code&gt;hookOpBinary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="908a2f8c24579c24ba178c54fd857b4b41ae78ef" translate="yes" xml:space="preserve">
          <source>If defined, &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (where &lt;code&gt;value&lt;/code&gt; is the value being assigned) is forwarded to when the result of binary operators &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;*=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt;, &lt;code&gt;%=&lt;/code&gt;, &lt;code&gt;^^=&lt;/code&gt;, &lt;code&gt;&amp;amp;=&lt;/code&gt;, &lt;code&gt;|=&lt;/code&gt;, &lt;code&gt;^=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; is larger than the largest value representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si se define, se &lt;code&gt;hook.onUpperBound(value, bound)&lt;/code&gt; (donde &lt;code&gt;value&lt;/code&gt; es el valor asignado) cuando el resultado de operadores binarios &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;*=&lt;/code&gt; , &lt;code&gt;/=&lt;/code&gt; , &lt;code&gt;%=&lt;/code&gt; , &lt;code&gt;^^=&lt;/code&gt; , &lt;code&gt;&amp;amp;=&lt;/code&gt; , &lt;code&gt;|=&lt;/code&gt; , &lt;code&gt;^=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; , y &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;=&lt;/code&gt; es mayor que el valor m&amp;aacute;s grande que puede representarse por &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d3755f1788c95f9d9709ea3791ec92f2804e77a" translate="yes" xml:space="preserve">
          <source>If e is a SliceExp, constant fold it.</source>
          <target state="translated">Si e es un SliceExp,doblarlo constantemente.</target>
        </trans-unit>
        <trans-unit id="4e157bdef2847bcd47c86d8616eb969d0de41200" translate="yes" xml:space="preserve">
          <source>If e1 is a property function (template), resolve it.</source>
          <target state="translated">Si e1 es una función de propiedad (plantilla),resuélvela.</target>
        </trans-unit>
        <trans-unit id="fe36cf6a431bba3d0f0866cfcc1c8bfbdb70659d" translate="yes" xml:space="preserve">
          <source>If either is null =&amp;gt; non-equal</source>
          <target state="translated">Si cualquiera es nulo =&amp;gt; no igual</target>
        </trans-unit>
        <trans-unit id="51547fe82011becc25f7663a54c1c79b37b3b626" translate="yes" xml:space="preserve">
          <source>If either operand is &lt;code&gt;real&lt;/code&gt;, the other operand is converted to &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="translated">Si cualquiera de los operandos es &lt;code&gt;real&lt;/code&gt; , el otro operando se convierte en &lt;code&gt;real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c828619435ec0d80d0eb291888f4070be2665b9" translate="yes" xml:space="preserve">
          <source>If either operand is a floating point type, the other is implicitly converted to floating point and they are brought to a common type via the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">Si cualquiera de los operandos es un tipo de coma flotante, el otro se convierte impl&amp;iacute;citamente en coma flotante y se llevan a un tipo com&amp;uacute;n a trav&amp;eacute;s de las &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;conversiones aritm&amp;eacute;ticas habituales&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19204c26120415c2143a5e03cf2be7f558db1190" translate="yes" xml:space="preserve">
          <source>If either the second or third expressions are of type &lt;code&gt;void&lt;/code&gt;, then the resulting type is &lt;code&gt;void&lt;/code&gt;. Otherwise, the second and third expressions are implicitly converted to a common type which becomes the result type of the conditional expression.</source>
          <target state="translated">Si la segunda o la tercera expresi&amp;oacute;n son de tipo &lt;code&gt;void&lt;/code&gt; , entonces el tipo resultante es &lt;code&gt;void&lt;/code&gt; . De lo contrario, las expresiones segunda y tercera se convierten impl&amp;iacute;citamente en un tipo com&amp;uacute;n que se convierte en el tipo de resultado de la expresi&amp;oacute;n condicional.</target>
        </trans-unit>
        <trans-unit id="653d0a49e3e776a2dacb4a126f5f7199b157c776" translate="yes" xml:space="preserve">
          <source>If expression can be tested for true or false, returns the modified expression. Otherwise returns ErrorExp.</source>
          <target state="translated">Si la expresión puede ser probada como verdadera o falsa,devuelve la expresión modificada.En caso contrario,devuelve ErrorExp.</target>
        </trans-unit>
        <trans-unit id="b36e87ad6619937152cb1864f5c28a8d82857aaf" translate="yes" xml:space="preserve">
          <source>If expression is shared, check that we can access it. Give error message if not.</source>
          <target state="translated">Si la expresión es compartida,comprueba que podemos acceder a ella.Da un mensaje de error si no es así.</target>
        </trans-unit>
        <trans-unit id="b903eb11d9ca574de1d125b6a0ddd43ec7f26143" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;KeepTerminator&lt;/code&gt; is set to &lt;code&gt;KeepTerminator.yes&lt;/code&gt;, then the delimiter is included in the strings returned.</source>
          <target state="translated">Si el indicador &lt;code&gt;KeepTerminator&lt;/code&gt; se establece en &lt;code&gt;KeepTerminator.yes&lt;/code&gt; , entonces el delimitador se incluye en las cadenas devueltas.</target>
        </trans-unit>
        <trans-unit id="235b8759d68e4d6c00eac4cd7371849cd3084978" translate="yes" xml:space="preserve">
          <source>If found, return list entry that it is, else null.</source>
          <target state="translated">Si se encuentra,devuelva la entrada de la lista que es,si no es nula.</target>
        </trans-unit>
        <trans-unit id="a226618dbb0d64b00416429ba20f88cb6f590b46" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">Si func alguna vez genera un punto de tiempo mayor o igual al &lt;code&gt;front&lt;/code&gt; actual del rango, se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException .</target>
        </trans-unit>
        <trans-unit id="6bcd1b67b2b6132e6574059a063d80b5509091a8" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point greater than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or less than the &lt;code&gt;begin&lt;/code&gt; of the interval.</source>
          <target state="translated">Si func alguna vez genera un punto de tiempo mayor o igual al &lt;code&gt;front&lt;/code&gt; actual del rango, se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException . El rango estar&amp;aacute; vac&amp;iacute;o y la iteraci&amp;oacute;n completa cuando func genera un punto de tiempo igual o menor que el &lt;code&gt;begin&lt;/code&gt; del intervalo.</target>
        </trans-unit>
        <trans-unit id="eefd5cc7fe1ca2c7b897d183dc4a05399326e46f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown.</source>
          <target state="translated">Si func genera un punto de tiempo menor o igual que el &lt;code&gt;front&lt;/code&gt; actual del rango, se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException .</target>
        </trans-unit>
        <trans-unit id="c66509b1e052bea9e9d5481b7761f6c20d3b371f" translate="yes" xml:space="preserve">
          <source>If func ever generates a time point less than or equal to the current &lt;code&gt;front&lt;/code&gt; of the range, then a &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt;&lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt;&lt;/a&gt; will be thrown. The range will be empty and iteration complete when func generates a time point equal to or beyond the &lt;code&gt;end&lt;/code&gt; of the interval.</source>
          <target state="translated">Si func genera un punto de tiempo menor o igual que el &lt;code&gt;front&lt;/code&gt; actual del rango, se &lt;a href=&quot;std_datetime_date#DateTimeException&quot;&gt; &lt;code&gt;std.datetime.date.DateTimeException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.datetime.date.DateTimeException . El rango estar&amp;aacute; vac&amp;iacute;o y la iteraci&amp;oacute;n se completar&amp;aacute; cuando func genere un punto de tiempo igual o m&amp;aacute;s all&amp;aacute; del &lt;code&gt;end&lt;/code&gt; del intervalo.</target>
        </trans-unit>
        <trans-unit id="74f0c5b3f5f366de0c8aea12cba32b6bdb7a7e22" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.</source>
          <target state="translated">Si func conserva el estado que cambia como se le llama, a continuaci&amp;oacute;n, algunos algoritmos no funcionan correctamente, ya que el rango es &lt;code&gt;save&lt;/code&gt; habr&amp;aacute; fallado en realidad han estado guardado de la gama. Para evitar tales errores, no pase un delegado que no sea l&amp;oacute;gicamente puro a &lt;code&gt;fwdRange&lt;/code&gt; . Si a func se le da el mismo punto de tiempo con dos llamadas diferentes, debe devolver el mismo resultado las dos veces. Por supuesto, ninguna de las funciones de este m&amp;oacute;dulo tiene este problema, por lo que solo es relevante para los delegados personalizados.</target>
        </trans-unit>
        <trans-unit id="082731789aa3a0c2389877b2540dad5fb393fea2" translate="yes" xml:space="preserve">
          <source>If func retains state which changes as it is called, then some algorithms will not work correctly, because the range's &lt;code&gt;save&lt;/code&gt; will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to &lt;code&gt;fwdRange&lt;/code&gt;. If func is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.</source>
          <target state="translated">Si func conserva el estado que cambia como se le llama, a continuaci&amp;oacute;n, algunos algoritmos no funcionan correctamente, ya que el rango es &lt;code&gt;save&lt;/code&gt; habr&amp;aacute; fallado en realidad han estado guardado de la gama. Para evitar tales errores, no pase un delegado que no sea l&amp;oacute;gicamente puro a &lt;code&gt;fwdRange&lt;/code&gt; . Si a func se le da el mismo punto de tiempo con dos llamadas diferentes, debe devolver el mismo resultado las dos veces. Por supuesto, ninguna de las funciones de este m&amp;oacute;dulo tiene este problema, por lo que solo es relevante si se crea un delegado personalizado.</target>
        </trans-unit>
        <trans-unit id="811cb1951d7eca66363f0ab4a25ab0f68bd6c804" translate="yes" xml:space="preserve">
          <source>If function a function in a base class, return that base class.</source>
          <target state="translated">Si funciona una función en una clase base,devuelve esa clase base.</target>
        </trans-unit>
        <trans-unit id="3a618122aa9fe1978f9e550b5f42d584977ec33d" translate="yes" xml:space="preserve">
          <source>If in a quoted field any quote by itself, not at the end of a field, will end processing for that field.</source>
          <target state="translated">Si en un campo citado cualquier cita por sí misma,no al final de un campo,terminará el procesamiento para ese campo.</target>
        </trans-unit>
        <trans-unit id="fc45bb57ad39df4d2be393733ec74789f2ef7133" translate="yes" xml:space="preserve">
          <source>If instantiated with &lt;code&gt;No.multiblock&lt;/code&gt;, it performs a search for the first zero bit in the bitmap and sets it.</source>
          <target state="translated">Si se instancia con &lt;code&gt;No.multiblock&lt;/code&gt; , realiza una b&amp;uacute;squeda del primer bit cero en el mapa de bits y lo establece.</target>
        </trans-unit>
        <trans-unit id="7b0f6cec4d5ea8c58428ba7c40e99097b7cb2322" translate="yes" xml:space="preserve">
          <source>If isNested() returns true, isThis() should return false, unless the function needs a dual-context pointer.</source>
          <target state="translated">Si isNested()devuelve true,isThis()debería devolver false,a menos que la función necesite un puntero de doble contexto.</target>
        </trans-unit>
        <trans-unit id="b4d04375110c3b3230b38eb2d9c5c313ab9a4587" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;false&lt;/code&gt;, then the third expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; , se eval&amp;uacute;a la tercera expresi&amp;oacute;n y su resultado es el resultado de la expresi&amp;oacute;n condicional.</target>
        </trans-unit>
        <trans-unit id="ba0ab9ea37044a2e2b630f8489bf8ed0e516e703" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;true&lt;/code&gt;, then the second expression is evaluated, and its result is the result of the conditional expression.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , se eval&amp;uacute;a la segunda expresi&amp;oacute;n y su resultado es el resultado de la expresi&amp;oacute;n condicional.</target>
        </trans-unit>
        <trans-unit id="828463bf31c6d8c05164e51833a7bd26ece74f35" translate="yes" xml:space="preserve">
          <source>If it is desirable to persist a &lt;code&gt;Unique!T&lt;/code&gt; outside of its original scope, then it can be transferred. The transfer can be explicit, by calling &lt;code&gt;release&lt;/code&gt;, or implicit, when returning Unique from a function. The resource &lt;code&gt;T&lt;/code&gt; can be a polymorphic class object or instance of an interface, in which case Unique behaves polymorphically too.</source>
          <target state="translated">Si es deseable mantener un &lt;code&gt;Unique!T&lt;/code&gt; fuera de su alcance original, entonces puede ser transferido. La transferencia puede ser expl&amp;iacute;cita, llamando a &lt;code&gt;release&lt;/code&gt; , o impl&amp;iacute;cita, cuando se devuelve Unique desde una funci&amp;oacute;n. El recurso &lt;code&gt;T&lt;/code&gt; puede ser un objeto de clase polim&amp;oacute;rfica o una instancia de una interfaz, en cuyo caso Unique tambi&amp;eacute;n se comporta polim&amp;oacute;rficamente.</target>
        </trans-unit>
        <trans-unit id="1a1dc588bc158cc467f4127355a3912b746c621f" translate="yes" xml:space="preserve">
          <source>If just type T is given and no variable v, then the catch clause is still executed.</source>
          <target state="translated">Si sólo se da el tipo T y no se da la variable v,entonces la cláusula de captura sigue ejecutándose.</target>
        </trans-unit>
        <trans-unit id="f71f926a6db933017567619e75df00dc6712f06e" translate="yes" xml:space="preserve">
          <source>If multiple templates with the same</source>
          <target state="translated">Si múltiples plantillas con la misma</target>
        </trans-unit>
        <trans-unit id="35c6c44f6f67de6c4c0a779716275c68fe8b37b2" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;delimiter&lt;/code&gt; is given, then one trailing &lt;code&gt;'\r'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;, &lt;code&gt;'\f'&lt;/code&gt;, &lt;code&gt;'\v'&lt;/code&gt;, &lt;a href=&quot;std_uni#lineSep&quot;&gt;&lt;code&gt;std.uni.lineSep&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;std_uni#paraSep&quot;&gt;&lt;code&gt;std.uni.paraSep&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;std_uni#nelSep&quot;&gt;&lt;code&gt;std.uni.nelSep&lt;/code&gt;&lt;/a&gt; is removed from the end of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;str&lt;/code&gt; does not end with any of those characters, then it is returned unchanged.</source>
          <target state="translated">Si no se da ning&amp;uacute;n &lt;code&gt;delimiter&lt;/code&gt; , entonces uno &lt;code&gt;'\r'&lt;/code&gt; , &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; , &lt;code&gt;'\f'&lt;/code&gt; , &lt;code&gt;'\v'&lt;/code&gt; , &lt;a href=&quot;std_uni#lineSep&quot;&gt; &lt;code&gt;std.uni.lineSep&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;std_uni#paraSep&quot;&gt; &lt;code&gt;std.uni.paraSep&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;std_uni#nelSep&quot;&gt; &lt;code&gt;std.uni.nelSep&lt;/code&gt; &lt;/a&gt; se elimina del final de &lt;code&gt;str&lt;/code&gt; . Si &lt;code&gt;str&lt;/code&gt; no termina con ninguno de esos caracteres, se devuelve sin cambios.</target>
        </trans-unit>
        <trans-unit id="2b0411e822ff9871e75f5fe6e95c3d0518b1b309" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;needle&lt;/code&gt; is provided, &lt;code&gt;pred(haystack.front)&lt;/code&gt; will be evaluated on each element of the input range.</source>
          <target state="translated">Si no se proporciona ninguna &lt;code&gt;needle&lt;/code&gt; , se evaluar&amp;aacute; &lt;code&gt;pred(haystack.front)&lt;/code&gt; en cada elemento del rango de entrada.</target>
        </trans-unit>
        <trans-unit id="69633a75862efb516486b64d796be076d86f4c19" translate="yes" xml:space="preserve">
          <source>If no call to constructors via &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor.</source>
          <target state="translated">Si no aparece una llamada a los constructores a trav&amp;eacute;s de &lt;code&gt;this&lt;/code&gt; o &lt;code&gt;super&lt;/code&gt; en un constructor, y la clase base tiene un constructor, se inserta una llamada a &lt;code&gt;super()&lt;/code&gt; al comienzo del constructor.</target>
        </trans-unit>
        <trans-unit id="a6ba6c3c787fc12e247d6c67731ac7ae3ae18393" translate="yes" xml:space="preserve">
          <source>If no calls to a delegating constructor or &lt;code&gt;super&lt;/code&gt; appear in a constructor, and the base class has a nullary constructor, a call to &lt;code&gt;super()&lt;/code&gt; is inserted at the beginning of the constructor. If that base class has a constructor that requires arguments and no nullary constructor, a matching call to &lt;code&gt;super&lt;/code&gt; is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c68d59ef2b4bb11a75a62d44b96024d217f2ea" translate="yes" xml:space="preserve">
          <source>If no catch handlers are there for the errors, then the program gracefully exits through the default error handler with an appropriate message.</source>
          <target state="translated">Si no hay manejadores de captura para los errores,entonces el programa sale con gracia a través del manejador de errores por defecto con un mensaje apropiado.</target>
        </trans-unit>
        <trans-unit id="a3f4b45154d7d5df5948f5742dc5af04d95c91df" translate="yes" xml:space="preserve">
          <source>If no cycles are found, the ctors and tlsctors are replaced with the ones generated by this algorithm to preserve the old incorrect ordering behavior.</source>
          <target state="translated">Si no se encuentran ciclos,los ctors y tlsctors son reemplazados por los generados por este algoritmo para preservar el antiguo comportamiento de ordenamiento incorrecto.</target>
        </trans-unit>
        <trans-unit id="fd69e84bfca07a56902d7641663496f5b667fb84" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread access the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#ChunkInputRange&quot;&gt;&lt;code&gt;ChunkInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">Si no hay datos disponibles y el hilo principal accede al rango, se bloquear&amp;aacute; hasta que los datos est&amp;eacute;n disponibles. Una excepci&amp;oacute;n a esto es el m&amp;eacute;todo de &lt;code&gt;wait(Duration)&lt;/code&gt; en &lt;a href=&quot;#ChunkInputRange&quot;&gt; &lt;code&gt;ChunkInputRange&lt;/code&gt; &lt;/a&gt; . Este m&amp;eacute;todo esperar&amp;aacute; al m&amp;aacute;ximo la duraci&amp;oacute;n especificada y devolver&amp;aacute; verdadero si hay datos disponibles.</target>
        </trans-unit>
        <trans-unit id="b37f49606e8cab3bb492c893e69c1a2e75dd1924" translate="yes" xml:space="preserve">
          <source>If no data is available and the main thread accesses the range it will block until data becomes available. An exception to this is the &lt;code&gt;wait(Duration)&lt;/code&gt; method on the &lt;a href=&quot;#LineInputRange&quot;&gt;&lt;code&gt;LineInputRange&lt;/code&gt;&lt;/a&gt;. This method will wait at maximum for the specified duration and return true if data is available.</source>
          <target state="translated">Si no hay datos disponibles y el subproceso principal accede al rango, se bloquear&amp;aacute; hasta que los datos est&amp;eacute;n disponibles. Una excepci&amp;oacute;n a esto es el m&amp;eacute;todo de &lt;code&gt;wait(Duration)&lt;/code&gt; en &lt;a href=&quot;#LineInputRange&quot;&gt; &lt;code&gt;LineInputRange&lt;/code&gt; &lt;/a&gt; . Este m&amp;eacute;todo esperar&amp;aacute; al m&amp;aacute;ximo la duraci&amp;oacute;n especificada y devolver&amp;aacute; verdadero si hay datos disponibles.</target>
        </trans-unit>
        <trans-unit id="dee768fdd957e908ee906de5d9f09ab3f15a2b74" translate="yes" xml:space="preserve">
          <source>If no explicit seed is provided, the first element of each work unit is used as a seed. For the final reduction, the result from the first work unit is used as the seed.</source>
          <target state="translated">Si no se proporciona una semilla explícita,se utiliza como semilla el primer elemento de cada unidad de trabajo.Para la reducción final,se utiliza como semilla el resultado de la primera unidad de trabajo.</target>
        </trans-unit>
        <trans-unit id="b9beba693b6541f5c4a623aa8005a14a8c088860" translate="yes" xml:space="preserve">
          <source>If no function to call is specified, &lt;code&gt;each&lt;/code&gt; defaults to doing nothing but consuming the entire range. &lt;code&gt;r.front&lt;/code&gt; will be evaluated, but that can be avoided by specifying a lambda with a &lt;code&gt;lazy&lt;/code&gt; parameter.</source>
          <target state="translated">Si no se especifica ninguna funci&amp;oacute;n para llamar, &lt;code&gt;each&lt;/code&gt; no hace nada m&amp;aacute;s que consumir todo el rango. se evaluar&amp;aacute; &lt;code&gt;r.front&lt;/code&gt; , pero eso se puede evitar especificando una lambda con un par&amp;aacute;metro &lt;code&gt;lazy&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0e9e2df565b7ef14de5d370ee2e7f5508ed495" translate="yes" xml:space="preserve">
          <source>If no needle is provided, the &lt;code&gt;haystack&lt;/code&gt; is advanced as long as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Similarly, the haystack is positioned so as &lt;code&gt;pred&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;haystack.front&lt;/code&gt;.</source>
          <target state="translated">Si no se proporciona ninguna aguja, el &lt;code&gt;haystack&lt;/code&gt; avanza siempre que &lt;code&gt;pred&lt;/code&gt; se eval&amp;uacute;e como &lt;code&gt;true&lt;/code&gt; . Del mismo modo, el pajar se coloca de manera que &lt;code&gt;pred&lt;/code&gt; eval&amp;uacute;a a &lt;code&gt;false&lt;/code&gt; para &lt;code&gt;haystack.front&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8015dc4a71527e3287d7f4a1a1531193efdd9ebe" translate="yes" xml:space="preserve">
          <source>If no random number generator is passed to &lt;code&gt;randomCover&lt;/code&gt;, the thread-global RNG rndGen will be used internally.</source>
          <target state="translated">Si no se pasa ning&amp;uacute;n generador de n&amp;uacute;meros aleatorios a &lt;code&gt;randomCover&lt;/code&gt; , el RNG global de subprocesos rndGen se utilizar&amp;aacute; internamente.</target>
        </trans-unit>
        <trans-unit id="ec48dd4e26e9c9b7bb1bba08590ef49f6e8b00b5" translate="yes" xml:space="preserve">
          <source>If no separator is passed, the  predicate &lt;code&gt;isTerminator&lt;/code&gt; decides whether to accept an element of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Si no se pasa ning&amp;uacute;n separador, el predicado &lt;code&gt;isTerminator&lt;/code&gt; decide si acepta un elemento de &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f27eb4bbcd5d830894d40b205272557d1b8c1c3" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a9c9c4272e471499a4566ff40a97f218d487f9" translate="yes" xml:space="preserve">
          <source>If no unittest custom handlers are registered, the following algorithm is executed (the behavior can be affected by the &lt;code&gt;--DRT-testmode&lt;/code&gt; switch below): 1. Run all unit tests, tracking tests executed and passes. For each that fails, print the stack trace, and continue. 2. If there are no failures, set the summarize flag to false, and the runMain flag to true. 3. If there are failures, set the summarize flag to true, and the runMain flag to false.</source>
          <target state="translated">Si no se registran controladores personalizados de unittest, se ejecuta el siguiente algoritmo (el comportamiento puede verse afectado por el interruptor &lt;code&gt;--DRT-testmode&lt;/code&gt; a continuaci&amp;oacute;n): 1. Ejecute todas las pruebas unitarias, las pruebas de seguimiento ejecutadas y pasa. Para cada uno que falle, imprima el seguimiento de la pila y contin&amp;uacute;e. 2. Si no hay fallas, establezca el indicador de resumen en falso y el indicador runMain en verdadero. 3. Si hay fallas, establezca el indicador de resumen en verdadero y el indicador runMain en falso.</target>
        </trans-unit>
        <trans-unit id="8e742609c87c27dd7441a0c05820a232e71bfca1" translate="yes" xml:space="preserve">
          <source>If no unittests were present, set summarize to false, and runMain to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe70a6ffb1eaff978d001d003d35769a95cf2acb" translate="yes" xml:space="preserve">
          <source>If non-zero, prefix result with 0x (0X).</source>
          <target state="translated">Si no es cero,el resultado del prefijo es 0x (0X).</target>
        </trans-unit>
        <trans-unit id="bb201c468fcb1936a1cc835ca2cb32dd5d97a148" translate="yes" xml:space="preserve">
          <source>If none of the case expressions match, and there is a default statement, the default statement is transferred to.</source>
          <target state="translated">Si ninguna de las expresiones del caso coinciden,y hay una declaración por defecto,la declaración por defecto se transfiere a.</target>
        </trans-unit>
        <trans-unit id="ab5f1042c0495e282ce28b3b52048c3700563975" translate="yes" xml:space="preserve">
          <source>If none of the choice matches, a &lt;code&gt;SwitchError&lt;/code&gt; will be thrown. &lt;code&gt;SwitchError&lt;/code&gt; will also be thrown if not all the choices are void and a void choice was executed without throwing anything.</source>
          <target state="translated">Si ninguna de las opciones coincide, se &lt;code&gt;SwitchError&lt;/code&gt; un SwitchError . &lt;code&gt;SwitchError&lt;/code&gt; tambi&amp;eacute;n se lanzar&amp;aacute; si no todas las opciones son nulas y se ejecut&amp;oacute; una opci&amp;oacute;n nula sin arrojar nada.</target>
        </trans-unit>
        <trans-unit id="3ed3959f15bba3be1a16efa6393b19ce9aeff019" translate="yes" xml:space="preserve">
          <source>If not specified, the</source>
          <target state="translated">Si no se especifica,la</target>
        </trans-unit>
        <trans-unit id="fe9db14bd961ccfeeb8601ee73a6483367ad2a6a" translate="yes" xml:space="preserve">
          <source>If one is a better match than the other, or one compiles and the other does not, the first is selected.</source>
          <target state="translated">Si uno es mejor que el otro,o uno compila y el otro no,se selecciona el primero.</target>
        </trans-unit>
        <trans-unit id="6dedca9993144f5a2bfb52216f61891e811d98ea" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a &lt;code&gt;NaN&lt;/code&gt;, the other is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f309363d54cf09070c11d4dd142dc6d8bfb60d" translate="yes" xml:space="preserve">
          <source>If one of the arguments is a NaN, the other is returned.</source>
          <target state="translated">Si uno de los argumentos es un NaN,el otro es devuelto.</target>
        </trans-unit>
        <trans-unit id="f22c395490cca8ea1c81135fd8838b0c5b0afefa" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if and only if the integral can be converted exactly (without approximation) to the floating-point number. This is in order to preserve transitivity of equality: if &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; and &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; then &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt;, in case &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are a mix of integral and floating-point numbers.</source>
          <target state="translated">Si uno de los n&amp;uacute;meros es una integral y el otro es un n&amp;uacute;mero de coma flotante, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; si y solo si la integral se puede convertir exactamente (sin aproximaci&amp;oacute;n) al n&amp;uacute;mero de coma flotante. Esto es para preservar la transitividad de la igualdad: si &lt;code&gt; hookOpEquals(x, y)&lt;/code&gt; y &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; luego &lt;code&gt;hookOpEquals(y, z)&lt;/code&gt; , en caso de que &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; sean una combinaci&amp;oacute;n de n&amp;uacute;meros integrales y de coma flotante .</target>
        </trans-unit>
        <trans-unit id="47e27965329d106e5c510ac4b7c35d3cf65701ae" translate="yes" xml:space="preserve">
          <source>If one of the numbers is an integral and the other is a floating-point number, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; returns a floating-point number that is &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; if the floating-point number is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Si uno de los n&amp;uacute;meros es una integral y el otro es un n&amp;uacute;mero de coma flotante, &lt;code&gt;hookOpEquals(x, y)&lt;/code&gt; devuelve un n&amp;uacute;mero de coma flotante que es &lt;code&gt;-1&lt;/code&gt; si &lt;code&gt;x &amp;lt; y&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; si &lt;code&gt;x == y&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; si &lt;code&gt;x &amp;gt; y&lt;/code&gt; , y &lt;code&gt;NaN&lt;/code&gt; si el n&amp;uacute;mero de coma flotante es &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4188be61c77849339804ae3977d382498bd8812e" translate="yes" xml:space="preserve">
          <source>If one operand is an enum and the other is the base type of that enum, the result is the base type.</source>
          <target state="translated">Si un operando es un enum y el otro es el tipo base de ese enum,el resultado es el tipo base.</target>
        </trans-unit>
        <trans-unit id="422f2e869457e9aec8090f25e67e71da6e5ae6e8" translate="yes" xml:space="preserve">
          <source>If one or both of the operand types is an enum after undergoing the above conversions, the result type is:</source>
          <target state="translated">Si uno o ambos tipos de operandos se enumeran después de someterse a las conversiones anteriores,el tipo de resultado es:</target>
        </trans-unit>
        <trans-unit id="34b4e760890c5916b5f472cf9ec3f9d946f615cd" translate="yes" xml:space="preserve">
          <source>If one or both operands are floating point, then a floating point comparison is performed.</source>
          <target state="translated">Si uno o ambos operandos son de punto flotante,entonces se realiza una comparación de punto flotante.</target>
        </trans-unit>
        <trans-unit id="f34527129f419587a7b124534783120be01591c6" translate="yes" xml:space="preserve">
          <source>If one range is infinite and the other finite, then the finite range must be a forward range, and the infinite range can be an input range.</source>
          <target state="translated">Si un rango es infinito y el otro finito,entonces el rango finito debe ser un rango hacia adelante,y el rango infinito puede ser un rango de entrada.</target>
        </trans-unit>
        <trans-unit id="1493b0ab4b81a5a5d799727a74239f7ced24db39" translate="yes" xml:space="preserve">
          <source>If only one range is offered to &lt;code&gt;Chain&lt;/code&gt; or &lt;code&gt;chain&lt;/code&gt;, the &lt;code&gt;Chain&lt;/code&gt; type exits the picture by aliasing itself directly to that range's type.</source>
          <target state="translated">Si solo se ofrece un rango a &lt;code&gt;Chain&lt;/code&gt; o &lt;code&gt;chain&lt;/code&gt; , el tipo de &lt;code&gt;Chain&lt;/code&gt; sale de la imagen alias&amp;aacute;ndose directamente al tipo de ese rango.</target>
        </trans-unit>
        <trans-unit id="4f4dfc7af6d318725cd2bb6acc7371848e22877c" translate="yes" xml:space="preserve">
          <source>If only one type is passed, then an array of that type. Otherwise, an array of &lt;a href=&quot;std_typecons#Tuple&quot;&gt;&lt;code&gt;std.typecons.Tuple&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Si solo se pasa un tipo, entonces una matriz de ese tipo. De lo contrario, una matriz de &lt;a href=&quot;std_typecons#Tuple&quot;&gt; &lt;code&gt;std.typecons.Tuple&lt;/code&gt; &lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="f80a4ee1709480a885baa729f38d366951608f11" translate="yes" xml:space="preserve">
          <source>If operands are integral types</source>
          <target state="translated">Si los operandos son tipos integrales</target>
        </trans-unit>
        <trans-unit id="c17f6322872f795083ddb63a91c502026d7f7e3d" translate="yes" xml:space="preserve">
          <source>If overlapping is required, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt;&lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Si se requiere superposici&amp;oacute;n, use &lt;a href=&quot;https://dlang.org/phobos/std_algorithm_mutation.html#copy&quot;&gt; &lt;code&gt;std.algorithm.mutation.copy&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dcfac2e8846ad57a33a3bc26acae8df77dfcdb25" translate="yes" xml:space="preserve">
          <source>If overridding &lt;code&gt;Object.opEquals()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">Si se reemplaza &lt;code&gt;Object.opEquals()&lt;/code&gt; para las clases, la firma de la funci&amp;oacute;n miembro de la clase deber&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="d70cff54f302f2d4a422baa59aebb43764d5cd42" translate="yes" xml:space="preserve">
          <source>If overriding &lt;code&gt;Object.opCmp()&lt;/code&gt; for classes, the class member function signature should look like:</source>
          <target state="translated">Si &lt;code&gt;Object.opCmp()&lt;/code&gt; para las clases, la firma de la funci&amp;oacute;n miembro de la clase deber&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="3e09a8be6b9d197eccbe61876283b5ca6720c550" translate="yes" xml:space="preserve">
          <source>If p is null, no operation is performed.</source>
          <target state="translated">Si la p es nula,no se realiza ninguna operación.</target>
        </trans-unit>
        <trans-unit id="352e9b1490dbc9b0a48acbedafe6ae17ff5f3152" translate="yes" xml:space="preserve">
          <source>If paramsym is null a new ScopeDsymbol is used in place of paramsym.</source>
          <target state="translated">Si el parámesis es nulo,se utiliza un nuevo ScopeDsymbol en lugar del parámesis.</target>
        </trans-unit>
        <trans-unit id="0167129cd52bf73eb27d8ebdabfdbade4013fad0" translate="yes" xml:space="preserve">
          <source>If passed in a range of code points, returns a range with equivalent capabilities.</source>
          <target state="translated">Si se pasa en un rango de puntos de código,devuelve un rango con capacidades equivalentes.</target>
        </trans-unit>
        <trans-unit id="15542b3779f094229ad4949cf6c05be1fd8cee3c" translate="yes" xml:space="preserve">
          <source>If pointers to D garbage collector allocated memory are passed to C functions, it's critical to ensure that that memory will not be collected by the garbage collector before the C function is done with it. This is accomplished by:</source>
          <target state="translated">Si los punteros del recolector de basura D asignados a la memoria se pasan a las funciones C,es fundamental asegurar que esa memoria no será recogida por el recolector de basura antes de que la función C termine con ella.Esto se logra mediante:</target>
        </trans-unit>
        <trans-unit id="0dd282293b2dd30b59ba588f24339bbfcbc55f38" translate="yes" xml:space="preserve">
          <source>If pointers to memory allocated on the D garbage collector heap are passed to C++ functions, it's critical to ensure that the referenced memory will not be collected by the D garbage collector before the C++ function is done with it. This is accomplished by:</source>
          <target state="translated">Si los punteros a la memoria asignada en el colector de basura D se pasan a las funciones de C++,es crítico asegurar que la memoria referenciada no será recogida por el colector de basura D antes de que la función de C++se haga con ella.Esto se logra mediante:</target>
        </trans-unit>
        <trans-unit id="0fae4029daa6372cee7e8e40ab986342b94efc26" translate="yes" xml:space="preserve">
          <source>If possible, convert array initializer to associative array initializer.</source>
          <target state="translated">Si es posible,convierta el inicializador de matrices en un inicializador de matrices asociativo.</target>
        </trans-unit>
        <trans-unit id="917024e995f1fa2c71d6754ac363cc3314dc229d" translate="yes" xml:space="preserve">
          <source>If present, the</source>
          <target state="translated">Si está presente,el</target>
        </trans-unit>
        <trans-unit id="0b88da18898e09a28c0b2bdc7b134ad9a375efc5" translate="yes" xml:space="preserve">
          <source>If range is a range of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 encoding.  If range is a range of ranges of bytes, an &lt;code&gt;Encoder&lt;/code&gt; that iterates over the Base64 encoded strings of each element of the range.  In both cases, the returned &lt;code&gt;Encoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.</source>
          <target state="translated">Si range es un rango de bytes, un &lt;code&gt;Encoder&lt;/code&gt; que itera sobre los bytes de la codificaci&amp;oacute;n Base64 correspondiente. Si rango es un rango de rangos de bytes, un &lt;code&gt;Encoder&lt;/code&gt; que itera sobre las cadenas codificadas Base64 de cada elemento del rango. En ambos casos, el &lt;code&gt;Encoder&lt;/code&gt; devuelto ser&amp;aacute; un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango directo&lt;/a&gt; si el &lt;code&gt;range&lt;/code&gt; dado es al menos un rango directo, de lo contrario ser&amp;aacute; solo un rango de entrada.</target>
        </trans-unit>
        <trans-unit id="8fcc566f870dfdc11f9cf5642881af956a3edafb" translate="yes" xml:space="preserve">
          <source>If range is a range of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the bytes of the corresponding Base64 decoding.  If range is a range of ranges of characters, a &lt;code&gt;Decoder&lt;/code&gt; that iterates over the decoded strings corresponding to each element of the range. In this case, the length of each subrange must be a multiple of 4; the returned decoder does not keep track of Base64 decoding state across subrange boundaries.  In both cases, the returned &lt;code&gt;Decoder&lt;/code&gt; will be a &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;forward range&lt;/a&gt; if the given &lt;code&gt;range&lt;/code&gt; is at least a forward range, otherwise it will be only an input range.  If the input data contains characters not found in the base alphabet of the current Base64 encoding scheme, the returned range may throw a &lt;code&gt;Base64Exception&lt;/code&gt;.</source>
          <target state="translated">Si range es un rango de caracteres, un &lt;code&gt;Decoder&lt;/code&gt; que itera sobre los bytes de la decodificaci&amp;oacute;n Base64 correspondiente. Si rango es un rango de rangos de caracteres, un &lt;code&gt;Decoder&lt;/code&gt; que itera sobre las cadenas decodificadas correspondientes a cada elemento del rango. En este caso, la longitud de cada subrango debe ser un m&amp;uacute;ltiplo de 4; el decodificador devuelto no realiza un seguimiento del estado de decodificaci&amp;oacute;n Base64 a trav&amp;eacute;s de los l&amp;iacute;mites del subrango. En ambos casos, el &lt;code&gt;Decoder&lt;/code&gt; devuelto ser&amp;aacute; un &lt;a href=&quot;std_range_primitives#isForwardRange&quot;&gt;rango directo&lt;/a&gt; si el &lt;code&gt;range&lt;/code&gt; dado es al menos un rango directo, de lo contrario ser&amp;aacute; solo un rango de entrada. Si los datos de entrada contienen caracteres que no se encuentran en el alfabeto base del esquema de codificaci&amp;oacute;n Base64 actual, el rango devuelto puede arrojar un &lt;code&gt;Base64Exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6eb7ddfbf5a47c6c6af2b15e78fb247a252fb4" translate="yes" xml:space="preserve">
          <source>If same exact type =&amp;gt; one call to method opEquals</source>
          <target state="translated">Si el mismo tipo exacto =&amp;gt; una llamada al m&amp;eacute;todo opEquals</target>
        </trans-unit>
        <trans-unit id="89afd532fed79af758875995d860db76e2e127dd" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately.</source>
          <target state="translated">Si se establece en tiempo de ejecuci&amp;oacute;n, &lt;code&gt;min&lt;/code&gt; y / o &lt;code&gt;max&lt;/code&gt; deben inicializarse adecuadamente.</target>
        </trans-unit>
        <trans-unit id="7d613cefcf14fab9fa1cdf592c4b64df5fd4a02e" translate="yes" xml:space="preserve">
          <source>If set at runtime, &lt;code&gt;min&lt;/code&gt; and/or &lt;code&gt;max&lt;/code&gt; must be initialized appropriately. The block must have been allocated with this freelist, and no dynamic changing of &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; is allowed to occur between allocation and deallocation.</source>
          <target state="translated">Si se establece en tiempo de ejecuci&amp;oacute;n, &lt;code&gt;min&lt;/code&gt; y / o &lt;code&gt;max&lt;/code&gt; deben inicializarse adecuadamente. El bloque debe haber sido asignado con esta lista libre, y no se permite ning&amp;uacute;n cambio din&amp;aacute;mico de &lt;code&gt;min&lt;/code&gt; o &lt;code&gt;max&lt;/code&gt; entre la asignaci&amp;oacute;n y la desasignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="12dba39acb6108d02380b6b46f58548fdd12a457" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AllowDayOverflow.no&lt;/code&gt;, then day overflow is not allowed.</source>
          <target state="translated">Si se establece en &lt;code&gt;AllowDayOverflow.no&lt;/code&gt; , no se permite el desbordamiento del d&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="0c05e2e8281e59d8e307dc66be3d2cc276d8fa30" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the StopWatch is not started when it is constructed.</source>
          <target state="translated">Si se establece en &lt;code&gt;AutoStart.no&lt;/code&gt; , el StopWatch no se inicia cuando se construye.</target>
        </trans-unit>
        <trans-unit id="d6add4cf35e8c50b2af6d41b382ebe3f7e3e974a" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;AutoStart.no&lt;/code&gt;, then the stopwatch is not started when it is constructed.</source>
          <target state="translated">Si se establece en &lt;code&gt;AutoStart.no&lt;/code&gt; , el cron&amp;oacute;metro no se inicia cuando se construye.</target>
        </trans-unit>
        <trans-unit id="e084739a519921a28023083912a24037cae39c78" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;CheckDns.no&lt;/code&gt;, isEmail does not perform DNS checking.</source>
          <target state="translated">Si se establece en &lt;code&gt;CheckDns.no&lt;/code&gt; , isEmail no realiza la comprobaci&amp;oacute;n de DNS.</target>
        </trans-unit>
        <trans-unit id="0e1f47a96e002fe723252c695ba57f0bd6e6ab0f" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;OpenRight.yes&lt;/code&gt;, then the interval is open to the right (last element is not included).</source>
          <target state="translated">Si se establece en &lt;code&gt;OpenRight.yes&lt;/code&gt; , entonces el intervalo est&amp;aacute; abierto a la derecha (el &amp;uacute;ltimo elemento no est&amp;aacute; incluido).</target>
        </trans-unit>
        <trans-unit id="37becabb79a088b28ac5682f3e5ecf44b42c3e44" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;PopFirst.no&lt;/code&gt;, then popFront is not called before returning the range.</source>
          <target state="translated">Si se establece en &lt;code&gt;PopFirst.no&lt;/code&gt; , no se llama a popFront antes de devolver el rango.</target>
        </trans-unit>
        <trans-unit id="c46457e61c98538473682050d8870e6910707094" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;SortOutput.no&lt;/code&gt;, the output should not be sorted.</source>
          <target state="translated">Si se establece en &lt;code&gt;SortOutput.no&lt;/code&gt; , la salida no se debe ordenar.</target>
        </trans-unit>
        <trans-unit id="00965390f3dcb757da046e66cf3e12ece6325eda" translate="yes" xml:space="preserve">
          <source>If set, 0 is the only allowed &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt; IEEE754 denormalized&lt;/a&gt; number. Requires allowDenorm and storeNormalized.</source>
          <target state="translated">Si se establece, 0 es el &amp;uacute;nico n&amp;uacute;mero &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985#Denormalized_numbers&quot;&gt;desnormalizado IEEE754&lt;/a&gt; permitido . Requiere allowDenorm y storeNormalized.</target>
        </trans-unit>
        <trans-unit id="61485b68856bc9bc475231ad8439460508956a5d" translate="yes" xml:space="preserve">
          <source>If set, select an exponent bias such that max_exp = 1. i.e. so that the maximum value is &amp;gt;= 1.0 and &amp;lt; 2.0. Ignored if the exponent bias is manually specified.</source>
          <target state="translated">Si se establece, seleccione un sesgo de exponente tal que max_exp = 1. es decir, para que el valor m&amp;aacute;ximo sea&amp;gt; = 1.0 y &amp;lt;2.0. Ignorado si el sesgo del exponente se especifica manualmente.</target>
        </trans-unit>
        <trans-unit id="b15a8a24ac3c0abdda604fa6be697872fed5e457" translate="yes" xml:space="preserve">
          <source>If set, unsigned custom floats are assumed to be negative.</source>
          <target state="translated">Si se fijan,se supone que los flotadores personalizados no firmados son negativos.</target>
        </trans-unit>
        <trans-unit id="96c1d18878474b954f19c1048ca19bc4cc441ff0" translate="yes" xml:space="preserve">
          <source>If size dependencies are inevitable, put a &lt;code&gt;static assert&lt;/code&gt; in the code to verify it:</source>
          <target state="translated">Si las dependencias de tama&amp;ntilde;o son inevitables, ponga una &lt;code&gt;static assert&lt;/code&gt; en el c&amp;oacute;digo para verificarlo:</target>
        </trans-unit>
        <trans-unit id="c4932da89fb63071147ad73f57504dc48f8f86d2" translate="yes" xml:space="preserve">
          <source>If some of these fields is not NULL, it is a pointer to b_data.</source>
          <target state="translated">Si alguno de estos campos no es NULL,es un puntero a b_data.</target>
        </trans-unit>
        <trans-unit id="bf8032a0e0aff5e21ec9404228bec256c45b8757" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself and doesn't define opPostMove, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">Si la fuente tiene punteros internos que apuntan a sí misma y no define el opPostMove,no puede ser movida,y desencadenará un fallo de afirmación.</target>
        </trans-unit>
        <trans-unit id="c4372423a2292ca511a5a4c383dba5ab95bc4f7d" translate="yes" xml:space="preserve">
          <source>If source has internal pointers that point to itself, it cannot be moved, and will trigger an assertion failure.</source>
          <target state="translated">Si la fuente tiene punteros internos que apuntan a sí misma,no puede ser movida,y desencadenará un fallo de afirmación.</target>
        </trans-unit>
        <trans-unit id="b61714985a37455e4a9923539bc1db8640864a65" translate="yes" xml:space="preserve">
          <source>If splitting a string on whitespace and token compression is desired, consider using &lt;code&gt;splitter&lt;/code&gt; without specifying a separator.</source>
          <target state="translated">Si se desea dividir una cadena en espacios en blanco y compresi&amp;oacute;n de token, considere usar un &lt;code&gt;splitter&lt;/code&gt; sin especificar un separador.</target>
        </trans-unit>
        <trans-unit id="05b6ffe797342cf0d1028469f63301e251d90fab" translate="yes" xml:space="preserve">
          <source>If splitting of data transfer is enabled this callback is called after download of an individual chunk finished. Note! After this callback was set then it have to be called FOR ALL chunks. Even if downloading of this chunk was skipped in CHUNK_BGN_FUNC. This is the reason why we don't need &quot;transfer_info&quot; parameter in this callback and we are not interested in &quot;remains&quot; parameter too.</source>
          <target state="translated">Si la división de la transferencia de datos está habilitada,esta llamada se llama después de que la descarga de un trozo individual haya terminado.¡Atención! Después de que esta devolución de llamada se ha establecido,entonces tiene que ser llamada PARA TODOS los trozos.Incluso si la descarga de este trozo fue omitida en CHUNK_BGN_FUNC.Esta es la razón por la que no necesitamos el parámetro &quot;transfer_info&quot; en esta devolución de llamada y no estamos interesados en el parámetro &quot;remains&quot; también.</target>
        </trans-unit>
        <trans-unit id="42671fc7da4232343c7b0b928fc5d03d90a644e7" translate="yes" xml:space="preserve">
          <source>If statements provide simple conditional execution of statements.</source>
          <target state="translated">Si las declaraciones proporcionan una simple ejecución condicional de las declaraciones.</target>
        </trans-unit>
        <trans-unit id="9c00c0869eed3767fe39aeae02ecce87d06c6f2e" translate="yes" xml:space="preserve">
          <source>If struct constructor is annotated with &lt;code&gt;@disable&lt;/code&gt; and has an empty &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt;, the struct has disabled default construction. The only way it can be constructed is via a call to another constructor with a non-empty</source>
          <target state="translated">Si el constructor de la estructura est&amp;aacute; anotado con &lt;code&gt;@disable&lt;/code&gt; y tiene una Lista de &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;par&amp;aacute;metros&lt;/i&gt;&lt;/a&gt; vac&amp;iacute;a , la estructura ha desactivado la construcci&amp;oacute;n predeterminada. La &amp;uacute;nica forma en que se puede construir es mediante una llamada a otro constructor que no est&amp;eacute; vac&amp;iacute;o</target>
        </trans-unit>
        <trans-unit id="944569416617efaa7082cf853e519ff0670f8407" translate="yes" xml:space="preserve">
          <source>If struct invariant checking is turned on, the struct invariant is called at the end of the constructor.</source>
          <target state="translated">Si se activa la comprobación de la invariante estructural,la invariante estructural se llama al final del constructor.</target>
        </trans-unit>
        <trans-unit id="d7768f4c2da4924ba7acf617ca9aea18a8c9c30c" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opCmp&lt;/code&gt; member function, it should have the following form:</source>
          <target state="translated">Si las estructuras declaran una funci&amp;oacute;n miembro &lt;code&gt;opCmp&lt;/code&gt; , deber&amp;iacute;a tener la siguiente forma:</target>
        </trans-unit>
        <trans-unit id="3992d8b7bb5105984cffe3cb78e47194ffe3ff8f" translate="yes" xml:space="preserve">
          <source>If structs declare an &lt;code&gt;opEquals&lt;/code&gt; member function for the identity comparison, it could have several forms, such as:</source>
          <target state="translated">Si las estructuras declaran una funci&amp;oacute;n miembro &lt;code&gt;opEquals&lt;/code&gt; para la comparaci&amp;oacute;n de identidad, podr&amp;iacute;a tener varias formas, como:</target>
        </trans-unit>
        <trans-unit id="a998ede0b415c72a4f5c3800b4d3a122980f04c1" translate="yes" xml:space="preserve">
          <source>If such a match occurs, the inout is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied.</source>
          <target state="translated">Si se produce tal coincidencia,el inout se considera el calificador común de los calificadores coincidentes.Si existen más de dos parámetros,el cálculo del calificador común se aplica de forma recursiva.</target>
        </trans-unit>
        <trans-unit id="b30b7b06cd1e2f9ae926af9377511bb1cde4d9ab" translate="yes" xml:space="preserve">
          <source>If such an</source>
          <target state="translated">Si tal</target>
        </trans-unit>
        <trans-unit id="a7624c537a3b1ba34be043fd5ddb463081b0a9fb" translate="yes" xml:space="preserve">
          <source>If template type parameters match the literal expressions on function arguments, the deduced types may consider narrowing conversions of them.</source>
          <target state="translated">Si los parámetros del tipo de plantilla coinciden con las expresiones literales de los argumentos de la función,los tipos deducidos pueden considerar la posibilidad de reducir las conversiones de los mismos.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">Si el</target>
        </trans-unit>
        <trans-unit id="47a53d62849ea833a758681edda290d5ad91413e" translate="yes" xml:space="preserve">
          <source>If the .d source file starts with the string &quot;Ddoc&quot; then it is treated as general purpose documentation, not as a D code source file. From immediately after the &quot;Ddoc&quot; string to the end of the file or any &quot;Macros:&quot; section forms the document. No automatic highlighting is done to that text, other than highlighting of D code embedded between lines delineated with --- lines. Only macro processing is done.</source>
          <target state="translated">Si el archivo fuente .d comienza con la cadena &quot;Ddoc&quot; entonces se trata como documentación de propósito general,no como un archivo fuente de código D.Desde inmediatamente después de la cadena &quot;Ddoc&quot; hasta el final del archivo o cualquier sección &quot;Macros:&quot; forma el documento.No se hace ningún resaltado automático a ese texto,excepto el resaltado del código D incrustado entre líneas delineadas con líneas ---.Sólo se realiza el procesamiento de macros.</target>
        </trans-unit>
        <trans-unit id="e8532e48c96c60a7608facfeb4a22eb5b3d9e1d6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condition&lt;/i&gt;&lt;/a&gt; is satisfied, then the following</source>
          <target state="translated">Si se cumple la &lt;a href=&quot;#Condition&quot;&gt;&lt;i&gt;Condici&amp;oacute;n&lt;/i&gt;&lt;/a&gt; , entonces lo siguiente</target>
        </trans-unit>
        <trans-unit id="e2fc51761f652cbfa928ace68e58f12bef9531f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#Config.newEnv&quot;&gt;&lt;code&gt;Config.newEnv&lt;/code&gt;&lt;/a&gt; flag is set in &lt;code&gt;config&lt;/code&gt;, the child process will</source>
          <target state="translated">Si el indicador &lt;a href=&quot;#Config.newEnv&quot;&gt; &lt;code&gt;Config.newEnv&lt;/code&gt; &lt;/a&gt; est&amp;aacute; configurado en &lt;code&gt;config&lt;/code&gt; , el proceso hijo</target>
        </trans-unit>
        <trans-unit id="43745bb1dee3dc73e7455be8ec08aff260e3ec47" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; is one token long, the parentheses can be omitted:</source>
          <target state="translated">Si &lt;a href=&quot;#TemplateArgument&quot;&gt;&lt;i&gt;TemplateArgument&lt;/i&gt;&lt;/a&gt; es un token, los par&amp;eacute;ntesis pueden omitirse:</target>
        </trans-unit>
        <trans-unit id="2d0280ee3bb99762171b658bd8c55f327440c8eb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="translated">Si la &lt;a href=&quot;class#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; est&amp;aacute; vac&amp;iacute;a, la instancia de estructura se inicializa por defecto.</target>
        </trans-unit>
        <trans-unit id="91aa0bb3a56c8d252e49de956e4900b6178db3ed" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;function#ParameterList&quot;&gt;&lt;i&gt;ParameterList&lt;/i&gt;&lt;/a&gt; is empty, the struct instance is default initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d70e00070ad7d208c2b59d3486718a575bd6f03" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;BitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">Si el objeto &lt;code&gt;BitmappedBlock&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o (no tiene una asignaci&amp;oacute;n activa), asigna toda la memoria dentro y le devuelve un segmento. De lo contrario, devuelve &lt;code&gt;null&lt;/code&gt; (es decir, no se intenta asignar el bloque m&amp;aacute;s grande disponible).</target>
        </trans-unit>
        <trans-unit id="f5b1d7f6d0725050ed31d8d5e2a2f42a77b9308e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; is managing the &lt;code&gt;File&lt;/code&gt; it logs to, this method will return a reference to this File.</source>
          <target state="translated">Si &lt;code&gt;FileLogger&lt;/code&gt; est&amp;aacute; administrando el &lt;code&gt;File&lt;/code&gt; se registra, este m&amp;eacute;todo devolver&amp;aacute; una referencia a este archivo.</target>
        </trans-unit>
        <trans-unit id="e82d2c358fbac5f6db431228cfdc4ab90afaecba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FileLogger&lt;/code&gt; was constructed with a filename, this method returns this filename. Otherwise an empty &lt;code&gt;string&lt;/code&gt; is returned.</source>
          <target state="translated">Si el &lt;code&gt;FileLogger&lt;/code&gt; se construy&amp;oacute; con un nombre de archivo, este m&amp;eacute;todo devuelve este nombre de archivo. De lo contrario, se devuelve una &lt;code&gt;string&lt;/code&gt; vac&amp;iacute;a .</target>
        </trans-unit>
        <trans-unit id="09e9a0c0fb2463234ac2c4886cea6f7201a979f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; object is empty (has no active allocation), allocates all memory within and returns a slice to it. Otherwise, returns &lt;code&gt;null&lt;/code&gt; (i.e. no attempt is made to allocate the largest available block).</source>
          <target state="translated">Si el objeto &lt;code&gt;SharedBitmappedBlock&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o (no tiene asignaci&amp;oacute;n activa), asigna toda la memoria dentro y le devuelve un segmento. De lo contrario, devuelve &lt;code&gt;null&lt;/code&gt; (es decir, no se intenta asignar el bloque m&amp;aacute;s grande disponible).</target>
        </trans-unit>
        <trans-unit id="a85af50c42d4408aee171ffd99bd37d80c84bfad" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, busy spin until it's done, then return the return value. If it threw an exception, rethrow that exception.</source>
          <target state="translated">Si la &lt;code&gt;Task&lt;/code&gt; a&amp;uacute;n no se ha iniciado, ejec&amp;uacute;tela en el hilo actual. Si est&amp;aacute; hecho, devuelva su valor de retorno, si lo hay. Si est&amp;aacute; en progreso, gire ocupado hasta que termine, luego devuelva el valor de retorno. Si arroj&amp;oacute; una excepci&amp;oacute;n, vuelva a lanzar esa excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1bd6a82f193fead01ba830becd3c29303a62f4f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Task&lt;/code&gt; isn't started yet, execute it in the current thread. If it's done, return its return value, if any. If it's in progress, wait on a condition variable. If it threw an exception, rethrow that exception.</source>
          <target state="translated">Si la &lt;code&gt;Task&lt;/code&gt; a&amp;uacute;n no se ha iniciado, ejec&amp;uacute;tela en el hilo actual. Si est&amp;aacute; hecho, devuelva su valor de retorno, si lo hay. Si est&amp;aacute; en progreso, espere una variable de condici&amp;oacute;n. Si arroj&amp;oacute; una excepci&amp;oacute;n, vuelva a lanzar esa excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9e212700918e7fcce26dacfc8ea0fc78cc9f1eec" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an (associative) array, returns the length of that array. Otherwise, throws an exception.</source>
          <target state="translated">Si la &lt;code&gt;VariantN&lt;/code&gt; contiene una matriz (asociativa), devuelve la longitud de esa matriz. De lo contrario, lanza una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="aaf923f5ee1964878af77ace59cc74c4aeed3ea4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; contains an array, applies &lt;code&gt;dg&lt;/code&gt; to each element of the array in turn. Otherwise, throws an exception.</source>
          <target state="translated">Si la &lt;code&gt;VariantN&lt;/code&gt; contiene una matriz, aplica &lt;code&gt;dg&lt;/code&gt; a cada elemento de la matriz a su vez. De lo contrario, lanza una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8cc269de3091c4d2c19acd44245d56ff558f7c59" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;VariantN&lt;/code&gt; object holds a value of the</source>
          <target state="translated">Si el objeto &lt;code&gt;VariantN&lt;/code&gt; tiene un valor de</target>
        </trans-unit>
        <trans-unit id="4b1509a50bbf3491d84d8a56c0c8990227dbda5d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;[ ]&lt;/code&gt; form is used, the slice is of the entire array.</source>
          <target state="translated">Si se usa el formulario &lt;code&gt;[ ]&lt;/code&gt; , el segmento es de toda la matriz.</target>
        </trans-unit>
        <trans-unit id="5bc0d1d6fc33510ec1a8451afec85b978d105f76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;format&lt;/code&gt; argument is a string literal, it is verified to be a valid format string per the C99 Standard. If the &lt;code&gt;format&lt;/code&gt; parameter is followed by &lt;code&gt;...&lt;/code&gt;, the number and types of the variadic arguments are checked against the format string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc574f8cb39cc53c71da6e74a5ec0da4813bcc04" translate="yes" xml:space="preserve">
          <source>If the CURLOPT_INFILE is used, this can be used to inform libcurl about how large the file being sent really is. That allows better error checking and better verifies that the upload was successful. -1 means unknown size.</source>
          <target state="translated">Si se utiliza el CURLOPT_INFILE,éste puede ser utilizado para informar a libcurl sobre el tamaño real del archivo que se está enviando.Eso permite una mejor comprobación de errores y verifica mejor que la subida fue exitosa.-1 significa tamaño desconocido.</target>
        </trans-unit>
        <trans-unit id="05e890b0ac7f150cc9383bbef3319acbe1eb47b0" translate="yes" xml:space="preserve">
          <source>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match.</source>
          <target state="translated">Si el UDA es un tipo,entonces cualquier UDA del mismo tipo en el símbolo coincidirá.Si el UDA es una plantilla para un tipo,entonces cualquier UDA que sea una instanciación de esa plantilla coincidirá.Y si el UDA es un valor,entonces cualquier UDA del símbolo que sea igual a ese valor coincidirá.</target>
        </trans-unit>
        <trans-unit id="d6829c7076e9b081aaeb04fb4efe46caee211bea" translate="yes" xml:space="preserve">
          <source>If the [EBP] is omitted, it is assumed for local variables. If &lt;code&gt;naked&lt;/code&gt; is used, this no longer holds.</source>
          <target state="translated">Si se omite el [EBP], se supone para las variables locales. Si se usa &lt;code&gt;naked&lt;/code&gt; , esto ya no es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="1517a4666732a9b97017b3d1661df1ab091b7335" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a sequence, there can be one or two iteration symbols declared. If one, then the symbol is an</source>
          <target state="translated">Si la expresión agregada es una secuencia,puede haber uno o dos símbolos de iteración declarados.Si uno,entonces el símbolo es un</target>
        </trans-unit>
        <trans-unit id="d74660278291ee85d1999a22558014f3ea28fb7a" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a static or dynamic array of &lt;code&gt;char&lt;/code&gt;s, &lt;code&gt;wchar&lt;/code&gt;s, or &lt;code&gt;dchar&lt;/code&gt;s, then the</source>
          <target state="translated">Si la expresi&amp;oacute;n agregada es una matriz est&amp;aacute;tica o din&amp;aacute;mica de &lt;code&gt;char&lt;/code&gt; s, &lt;code&gt;wchar&lt;/code&gt; s o &lt;code&gt;dchar&lt;/code&gt; s, entonces el</target>
        </trans-unit>
        <trans-unit id="cbeacb125fa68a379271d564591b63d8e90e22ef" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, but the &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt;, or &lt;code&gt;opApplyReverse&lt;/code&gt;&lt;code&gt;foreach_reverse&lt;/code&gt; do not exist, then iteration over struct and class objects can be done with range primitives. For &lt;code&gt;foreach&lt;/code&gt;, this means the following properties and methods must be defined:</source>
          <target state="translated">Si la expresi&amp;oacute;n agregada es una estructura o un objeto de clase, pero &lt;code&gt;opApply&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt; u &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;code&gt;foreach_reverse&lt;/code&gt; no existen, entonces la iteraci&amp;oacute;n sobre los objetos struct y class se puede hacer con primitivas de rango. Para &lt;code&gt;foreach&lt;/code&gt; , esto significa que se deben definir las siguientes propiedades y m&amp;eacute;todos:</target>
        </trans-unit>
        <trans-unit id="2fc73ce3aaae537f6f799c049d4ae92b1b9bca9f" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is a struct or class object, the &lt;code&gt;foreach&lt;/code&gt; is defined by the special &lt;span id=&quot;opApply&quot;&gt;&lt;code&gt;opApply&lt;/code&gt;&lt;/span&gt; member function, and the &lt;code&gt;foreach_reverse&lt;/code&gt; behavior is defined by the special &lt;span id=&quot;opApplyReverse&quot;&gt;&lt;code&gt;opApplyReverse&lt;/code&gt;&lt;/span&gt; member function. These functions have the type:</source>
          <target state="translated">Si la expresi&amp;oacute;n agregada es una estructura o un objeto de clase, el &lt;code&gt;foreach&lt;/code&gt; est&amp;aacute; definido por la funci&amp;oacute;n especial del miembro &lt;span id=&quot;opApply&quot;&gt; &lt;code&gt;opApply&lt;/code&gt; &lt;/span&gt; , y el comportamiento &lt;code&gt;foreach_reverse&lt;/code&gt; est&amp;aacute; definido por la funci&amp;oacute;n especial del miembro &lt;span id=&quot;opApplyReverse&quot;&gt; &lt;code&gt;opApplyReverse&lt;/code&gt; &lt;/span&gt; . Estas funciones tienen el tipo:</target>
        </trans-unit>
        <trans-unit id="a964bd4ba66b1238ba3df838bc73bf80b6db0380" translate="yes" xml:space="preserve">
          <source>If the aggregate expression is an associative array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">Si la expresión agregada es un conjunto asociativo,puede haber una o dos variables declaradas.Si una,entonces se dice que la variable es la</target>
        </trans-unit>
        <trans-unit id="28f986b7b478a6b80712dcbe7082b7d096f58800" translate="yes" xml:space="preserve">
          <source>If the aggregate is a static or dynamic array, there can be one or two variables declared. If one, then the variable is said to be the</source>
          <target state="translated">Si el agregado es un conjunto estático o dinámico,puede haber una o dos variables declaradas.Si una,entonces se dice que la variable es la</target>
        </trans-unit>
        <trans-unit id="dae323352e29801474e63b5dca9b04c0df39a8b3" translate="yes" xml:space="preserve">
          <source>If the argument is a CommaExp, set a flag to prevent deprecation messages</source>
          <target state="translated">Si el argumento es un CommaExp,ponga una bandera para evitar los mensajes de depreciación</target>
        </trans-unit>
        <trans-unit id="fd923c5e6b5ba5db493474258e601c811cb53b07" translate="yes" xml:space="preserve">
          <source>If the argument is omitted, it means default construction of the scalar type:</source>
          <target state="translated">Si se omite el argumento,significa la construcción por defecto del tipo escalar:</target>
        </trans-unit>
        <trans-unit id="c2b4ef88a634d75ab4162e14992b099e340c974e" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are abstract classes, or expressions that are typed as abstract classes, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Si los argumentos son todos tipos que son clases abstractas o expresiones que se escriben como clases abstractas, entonces se devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, se devuelve &lt;code&gt;false&lt;/code&gt; . Si no hay argumentos, se devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="870a7ff26a7a40d5a235f7261d71e7076bce3fa8" translate="yes" xml:space="preserve">
          <source>If the arguments are all either types that are arithmetic types, or expressions that are typed as arithmetic types, then &lt;code&gt;true&lt;/code&gt; is returned. Otherwise, &lt;code&gt;false&lt;/code&gt; is returned. If there are no arguments, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Si los argumentos son todos tipos que son tipos aritm&amp;eacute;ticos o expresiones que se escriben como tipos aritm&amp;eacute;ticos, entonces se devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, se devuelve &lt;code&gt;false&lt;/code&gt; . Si no hay argumentos, se devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1199d0a51996844d05cb8716b18ac074abdf063" translate="yes" xml:space="preserve">
          <source>If the assigned value type is &lt;b&gt;not&lt;/b&gt; equivalent with the AA element type, the expression could invoke operator overloading with normal indexing access:</source>
          <target state="translated">Si el tipo de valor asignado &lt;b&gt;no&lt;/b&gt; es equivalente al tipo de elemento AA, la expresi&amp;oacute;n podr&amp;iacute;a invocar la sobrecarga del operador con acceso de indexaci&amp;oacute;n normal:</target>
        </trans-unit>
        <trans-unit id="a4c8c8da96483d4e6d105c51e4ab4887f9f8b55b" translate="yes" xml:space="preserve">
          <source>If the assigned value type is equivalent with the AA element type:</source>
          <target state="translated">Si el tipo de valor asignado es equivalente con el tipo de elemento AA:</target>
        </trans-unit>
        <trans-unit id="39dbd0d9fed3f956fc2681e5931d3927843d2a46" translate="yes" xml:space="preserve">
          <source>If the bounds check in &lt;code&gt;@system&lt;/code&gt; or &lt;code&gt;@trusted&lt;/code&gt; code is disabled, the code correctness must still be guaranteed by the code author.</source>
          <target state="translated">Si la comprobaci&amp;oacute;n de l&amp;iacute;mites en el c&amp;oacute;digo &lt;code&gt;@system&lt;/code&gt; o &lt;code&gt;@trusted&lt;/code&gt; est&amp;aacute; deshabilitada, el autor del c&amp;oacute;digo debe garantizar la correcci&amp;oacute;n del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="cc1e679f124dc90842ff4979e66ede34a74890c6" translate="yes" xml:space="preserve">
          <source>If the callback doesn't take any arguments, the callback is invoked whenever the option is seen.</source>
          <target state="translated">Si la devolución de llamada no recibe ningún argumento,la devolución de llamada se invoca siempre que se vea la opción.</target>
        </trans-unit>
        <trans-unit id="3289fcddad88ae1df9d116fd88b6c6dc79afe870" translate="yes" xml:space="preserve">
          <source>If the callback takes one string argument, the option string (without the leading dash(es)) is passed to the callback. After that, the option string is considered handled and removed from the options array.</source>
          <target state="translated">Si la devolución de llamada toma un argumento de cadena,la cadena de opción (sin el/los guión(s)inicial(es))se pasa a la devolución de llamada.Después de eso,la cadena de opciones se considera manejada y eliminada de la matriz de opciones.</target>
        </trans-unit>
        <trans-unit id="dad4f3623ab08f61a1b3d8228c7e7a46ecb84bd7" translate="yes" xml:space="preserve">
          <source>If the callback takes two string arguments, the option string is handled as an option with one argument, and parsed accordingly. The option and its value are passed to the callback. After that, whatever was passed to the callback is considered handled and removed from the list.</source>
          <target state="translated">Si la llamada toma dos argumentos de cadena,la cadena de opción se maneja como una opción con un argumento,y se analiza en consecuencia.La opción y su valor se pasan a la llamada de retorno.Después de eso,lo que se haya pasado a la llamada de retorno se considera manejado y eliminado de la lista.</target>
        </trans-unit>
        <trans-unit id="8d6fa53ba31aeabc61edb3bbeab4d2e35828294c" translate="yes" xml:space="preserve">
          <source>If the caller is a Fiber and is not a Generator, this function will call scheduler.yield() or Fiber.yield(), as appropriate.</source>
          <target state="translated">Si el llamador es una Fibra y no es un Generador,esta función llamará a scheduler.yield()o Fiber.yield(),según corresponda.</target>
        </trans-unit>
        <trans-unit id="7fba3a81af609825439d1523a354f0ef5c6b4ecb" translate="yes" xml:space="preserve">
          <source>If the caller is a scheduled Fiber, this yields execution to another scheduled Fiber.</source>
          <target state="translated">Si la persona que llama es una Fibra programada,esto cede la ejecución a otra Fibra programada.</target>
        </trans-unit>
        <trans-unit id="682966fbc9a5573324e201e13b7ba309d84a4edb" translate="yes" xml:space="preserve">
          <source>If the capacity is increased, one should assume that all iterators to the elements are invalidated.</source>
          <target state="translated">Si se aumenta la capacidad,hay que suponer que se invalidan todos los iteradores a los elementos.</target>
        </trans-unit>
        <trans-unit id="881b45b7bdf985b220e8cd0369c0c1827fe806d8" translate="yes" xml:space="preserve">
          <source>If the chunk of memory managed is large, it may be desirable to switch management to free list from the beginning. That way, memory may be used in a more compact manner than region mode. To force free list mode, call &lt;code&gt;switchToFreeList&lt;/code&gt; shortly after construction or when deemed appropriate.</source>
          <target state="translated">Si la porci&amp;oacute;n de memoria administrada es grande, puede ser conveniente cambiar la administraci&amp;oacute;n a la lista libre desde el principio. De esa manera, la memoria se puede usar de una manera m&amp;aacute;s compacta que el modo regi&amp;oacute;n. Para forzar el modo de lista libre, llame a &lt;code&gt;switchToFreeList&lt;/code&gt; poco despu&amp;eacute;s de la construcci&amp;oacute;n o cuando lo considere apropiado.</target>
        </trans-unit>
        <trans-unit id="9ac8dd371ddada3a7fc0d5f27220ac56194a508b" translate="yes" xml:space="preserve">
          <source>If the connection proceeds too quickly then need to slow it down</source>
          <target state="translated">Si la conexión se produce demasiado rápido,entonces hay que ralentizarla...</target>
        </trans-unit>
        <trans-unit id="a0e6b5ba02714528b40c08b339b490154681d034" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (e.g. if it is &lt;code&gt;pure&lt;/code&gt;), the object can be implicitly convertible to any qualifiers.</source>
          <target state="translated">Si el constructor puede crear un objeto &amp;uacute;nico (por ejemplo, si es &lt;code&gt;pure&lt;/code&gt; ), el objeto puede convertirse impl&amp;iacute;citamente en cualquier calificador.</target>
        </trans-unit>
        <trans-unit id="cf0cf6c28f3156b6b4f9788d5978b63c0c05e84c" translate="yes" xml:space="preserve">
          <source>If the constructor can create a unique object (i.e. if it is &lt;code&gt;pure&lt;/code&gt;), the object is implicitly convertible to any qualifiers.</source>
          <target state="translated">Si el constructor puede crear un objeto &amp;uacute;nico (es decir, si es &lt;code&gt;pure&lt;/code&gt; ), el objeto es impl&amp;iacute;citamente convertible a cualquier calificador.</target>
        </trans-unit>
        <trans-unit id="52c26c14a7e4c3281fb4736e2032dbcd78185dac" translate="yes" xml:space="preserve">
          <source>If the current count is equal to zero, return. Otherwise, atomically decrement the count by one and return true.</source>
          <target state="translated">Si el conteo actual es igual a cero,regresa.De lo contrario,disminuya atómicamente la cuenta en uno y vuelva a ser verdadera.</target>
        </trans-unit>
        <trans-unit id="50c1fec6baa7c97f9c101593b09fc41307d590d7" translate="yes" xml:space="preserve">
          <source>If the declaration is disabled but inside a disabled function, returns &lt;code&gt;true&lt;/code&gt; but do not issue an error message.</source>
          <target state="translated">Si la declaraci&amp;oacute;n est&amp;aacute; deshabilitada pero dentro de una funci&amp;oacute;n deshabilitada, devuelve &lt;code&gt;true&lt;/code&gt; pero no emite un mensaje de error.</target>
        </trans-unit>
        <trans-unit id="553971eeba92d7bd581f90194d8554493054062d" translate="yes" xml:space="preserve">
          <source>If the default value for a parameter is given, all following parameters must also have default values.</source>
          <target state="translated">Si se da el valor por defecto de un parámetro,todos los parámetros siguientes también deben tener valores por defecto.</target>
        </trans-unit>
        <trans-unit id="aefb0c84385cb6665755448be70c3bf176cad1d9" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter is the same identifier starting at the beginning of the line:</source>
          <target state="translated">Si el delimitador es un identificador,el identificador debe ir inmediatamente seguido de una nueva línea,y el delimitador coincidente es el mismo identificador que comienza al principio de la línea:</target>
        </trans-unit>
        <trans-unit id="76a3cf7d70aa80e5130f9aadda4aeef632729f66" translate="yes" xml:space="preserve">
          <source>If the delimiter is an identifier, the identifier must be immediately followed by a newline, and the matching delimiter must be the same identifier starting at the beginning of the line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367e2c9e3e9e32edd1905a00926130379051ac02" translate="yes" xml:space="preserve">
          <source>If the documentation of a member function of a container takes a parameter of type &lt;code&gt;Range&lt;/code&gt;, then it refers to the primary range type of this container. Oftentimes &lt;code&gt;Take!Range&lt;/code&gt; will be used, in which case the range refers to a span of the elements in the container. Arguments to these parameters &lt;b&gt;must&lt;/b&gt; be obtained from the same container instance as the one being worked with. It is important to note that many generic range algorithms return the same range type as their input range.</source>
          <target state="translated">Si la documentaci&amp;oacute;n de una funci&amp;oacute;n miembro de un contenedor toma un par&amp;aacute;metro de tipo &lt;code&gt;Range&lt;/code&gt; , se refiere al tipo de rango primario de este contenedor. A menudo se utilizar&amp;aacute; &lt;code&gt;Take!Range&lt;/code&gt; , en cuyo caso el rango se refiere a un tramo de los elementos en el contenedor. Los argumentos de estos par&amp;aacute;metros &lt;b&gt;deben&lt;/b&gt; obtenerse de la misma instancia de contenedor con la que se est&amp;aacute; trabajando. Es importante tener en cuenta que muchos algoritmos de rango gen&amp;eacute;ricos devuelven el mismo tipo de rango que su rango de entrada.</target>
        </trans-unit>
        <trans-unit id="568a7fe362541b12ed21809dd85fad3122bbc2f4" translate="yes" xml:space="preserve">
          <source>If the download receives less than &quot;low speed limit&quot; bytes/second during &quot;low speed time&quot; seconds, the operations is aborted. You could i.e if you have a pretty high speed connection, abort if it is less than 2000 bytes/sec during 20 seconds.</source>
          <target state="translated">Si la descarga recibe menos de &quot;límite de baja velocidad&quot; bytes/segundo durante &quot;tiempo de baja velocidad&quot; segundos,las operaciones se abortan.Podrías,por ejemplo,si tienes una conexión de alta velocidad,abortar si es menor de 2000 bytes/segundo durante 20 segundos.</target>
        </trans-unit>
        <trans-unit id="3a1f560a07b490771cc9fc4811b46461cd585b36" translate="yes" xml:space="preserve">
          <source>If the email address is valid or not.</source>
          <target state="translated">Si la dirección de correo electrónico es válida o no.</target>
        </trans-unit>
        <trans-unit id="4f3a54e2dd01849ed176b274b08fe7067255fdd1" translate="yes" xml:space="preserve">
          <source>If the enum</source>
          <target state="translated">Si la lista</target>
        </trans-unit>
        <trans-unit id="c1aaeeb72f410c4e6aff61a784ecba88ce60daf3" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to false the functions are never inlined, otherwise they are always inlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657b7adb8cca95e26ff1d78ccaa8357b99612950" translate="yes" xml:space="preserve">
          <source>If the expression is a &lt;a href=&quot;function#property-functions&quot;&gt; Property Function&lt;/a&gt;, &lt;code&gt;typeof&lt;/code&gt; gives its return type.</source>
          <target state="translated">Si la expresi&amp;oacute;n es una &lt;a href=&quot;function#property-functions&quot;&gt;funci&amp;oacute;n de propiedad&lt;/a&gt; , &lt;code&gt;typeof&lt;/code&gt; proporciona su tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="bbff4334fd247c00a1664b1a8294a75098385c7e" translate="yes" xml:space="preserve">
          <source>If the extended unittest handler is registered, this function returns the result from that handler directly.</source>
          <target state="translated">Si se registra el manipulador de la prueba unitaria ampliada,esta función devuelve el resultado de ese manipulador directamente.</target>
        </trans-unit>
        <trans-unit id="638ef19a4eda5122a3e4b7247816dfcd0c978607" translate="yes" xml:space="preserve">
          <source>If the extension is empty, this function is equivalent to &lt;a href=&quot;#stripExtension&quot;&gt;&lt;code&gt;stripExtension&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si la extensi&amp;oacute;n est&amp;aacute; vac&amp;iacute;a, esta funci&amp;oacute;n es equivalente a &lt;a href=&quot;#stripExtension&quot;&gt; &lt;code&gt;stripExtension&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ef335ccbfb3536483e3c42f2775a824af19d172" translate="yes" xml:space="preserve">
          <source>If the field is initialized on one path, it must be initialized on all paths.</source>
          <target state="translated">Si el campo se inicializa en un camino,debe ser inicializado en todos los caminos.</target>
        </trans-unit>
        <trans-unit id="837d5b133d0941d97e1586686594739710856b45" translate="yes" xml:space="preserve">
          <source>If the field type has an &lt;a href=&quot;operatoroverloading#assignment&quot;&gt;&lt;code&gt;opAssign&lt;/code&gt;&lt;/a&gt; method, it will not be used for initialization.</source>
          <target state="translated">Si el tipo de campo tiene un m&amp;eacute;todo &lt;a href=&quot;operatoroverloading#assignment&quot;&gt; &lt;code&gt;opAssign&lt;/code&gt; &lt;/a&gt; , no se usar&amp;aacute; para la inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ced70cd3f9cbddd52606f9834678b1724238171b" translate="yes" xml:space="preserve">
          <source>If the field type is not mutable, multiple initialization will be rejected.</source>
          <target state="translated">Si el tipo de campo no es mutable,se rechazará la inicialización múltiple.</target>
        </trans-unit>
        <trans-unit id="03c48cf052ea3dedbdf6ccc3c7e899b230bc6471" translate="yes" xml:space="preserve">
          <source>If the file is not opened, returns &lt;code&gt;true&lt;/code&gt;. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; for the file handle.</source>
          <target state="translated">Si el archivo no se abre, devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, devuelve &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/ferror.html&quot;&gt;ferror&lt;/a&gt; para el identificador de archivo.</target>
        </trans-unit>
        <trans-unit id="8450d7a55bd53dbebae5b57df534f9be1005db67" translate="yes" xml:space="preserve">
          <source>If the file is not opened, succeeds vacuously. Otherwise, returns &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;clearerr&lt;/a&gt; for the file handle.</source>
          <target state="translated">Si el archivo no se abre, se realiza correctamente. De lo contrario, devuelve m&amp;aacute;s &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/clearerr.html&quot;&gt;claro&lt;/a&gt; para el identificador de archivo.</target>
        </trans-unit>
        <trans-unit id="094342c021e1489a63abd256ccc39489b9dd3b66" translate="yes" xml:space="preserve">
          <source>If the file name of a module is an invalid module name (e.g. &lt;code&gt;foo-bar.d&lt;/code&gt;), you may use a module declaration to set a valid module name:</source>
          <target state="translated">Si el nombre de archivo de un m&amp;oacute;dulo es un nombre de m&amp;oacute;dulo no v&amp;aacute;lido (por ejemplo, &lt;code&gt;foo-bar.d&lt;/code&gt; ), puede usar una declaraci&amp;oacute;n de m&amp;oacute;dulo para establecer un nombre de m&amp;oacute;dulo v&amp;aacute;lido:</target>
        </trans-unit>
        <trans-unit id="af6d8edab76ddfaae7837345a33fd73f250c8a9f" translate="yes" xml:space="preserve">
          <source>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt;), throwing on error. Even if an exception is thrown, afterwards the &lt;code&gt;File&lt;/code&gt; object is empty. This is different from &lt;code&gt;detach&lt;/code&gt; in that it always closes the file; consequently, all other &lt;code&gt;File&lt;/code&gt; objects referring to the same handle will see a closed file henceforth.</source>
          <target state="translated">Si el archivo no se abri&amp;oacute;, tiene &amp;eacute;xito al vac&amp;iacute;o. De lo contrario, cierra el archivo (llamando a &lt;a href=&quot;http://cplusplus.com/reference/clibrary/cstdio/fclose.html&quot;&gt;fclose&lt;/a&gt; ), arrojando un error. Incluso si se produce una excepci&amp;oacute;n, luego el objeto &lt;code&gt;File&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o. Esto es diferente de &lt;code&gt;detach&lt;/code&gt; en que siempre cierra el archivo; en consecuencia, todos los dem&amp;aacute;s objetos de &lt;code&gt;File&lt;/code&gt; que se refieren al mismo identificador ver&amp;aacute;n un archivo cerrado en adelante.</target>
        </trans-unit>
        <trans-unit id="527ef94b697e67dac9fb104fb0ef24982a4b2044" translate="yes" xml:space="preserve">
          <source>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in &lt;code&gt;ext&lt;/code&gt; is optional.</source>
          <target state="translated">Si el nombre de archivo ya tiene una extensi&amp;oacute;n, se reemplaza. Si no, la extensi&amp;oacute;n simplemente se agrega al nombre del archivo. Incluir un punto &lt;code&gt;ext&lt;/code&gt; en ext es opcional.</target>
        </trans-unit>
        <trans-unit id="9ba4ff05c5a39476e966f563ceda94938de67867" translate="yes" xml:space="preserve">
          <source>If the first</source>
          <target state="translated">Si el primer</target>
        </trans-unit>
        <trans-unit id="fdc87c8a8b7093e7a7ff0e6b20593048b93bffda" translate="yes" xml:space="preserve">
          <source>If the first line starts with &quot;#!&quot;, then that line is ignored.</source>
          <target state="translated">Si la primera línea comienza con &quot;#!&quot;,entonces esa línea es ignorada.</target>
        </trans-unit>
        <trans-unit id="0759e4efe42fd76d83650d76ffb9cbdc81cfccae" translate="yes" xml:space="preserve">
          <source>If the first lookup isn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes the scope of base classes and interfaces (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f743b99432834f349face5005529142050d8a895" translate="yes" xml:space="preserve">
          <source>If the first lookup wasn't successful, a second one is performed on imports. In the second lookup phase inherited scopes are ignored. This includes scope of base classes and interface (in this example, &lt;code&gt;BaseClass&lt;/code&gt;'s imports would be ignored), as well as imports in mixed-in &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">Si la primera b&amp;uacute;squeda no fue exitosa, se realiza una segunda en las importaciones. En la segunda fase de b&amp;uacute;squeda, los &amp;aacute;mbitos heredados se ignoran. Esto incluye el alcance de las clases base y la interfaz (en este ejemplo, las importaciones de &lt;code&gt;BaseClass&lt;/code&gt; ser&amp;iacute;an ignoradas), as&amp;iacute; como las importaciones en una &lt;code&gt;template&lt;/code&gt; mixta .</target>
        </trans-unit>
        <trans-unit id="4653edc731431a9f55f3a9c2f7b1ee0500507aaf" translate="yes" xml:space="preserve">
          <source>If the floating-point rounding mode is changed within a function, it must be restored before the function exits. If this rule is violated (for example, by the use of inline asm), the rounding mode used for subsequent calculations is undefined.</source>
          <target state="translated">Si se cambia el modo de redondeo del punto flotante dentro de una función,debe ser restaurado antes de que la función salga.Si se infringe esta regla (por ejemplo,por el uso de asm en línea),el modo de redondeo utilizado para los cálculos posteriores queda indefinido.</target>
        </trans-unit>
        <trans-unit id="06665db726ed2b3db8e693b6a8e9e8220aa3c936" translate="yes" xml:space="preserve">
          <source>If the format string is fixed, passing it as a template parameter checks the type correctness of the parameters at compile-time. This also can result in better performance.</source>
          <target state="translated">Si la cadena de formato es fija,al pasarla como parámetro de plantilla se comprueba la corrección del tipo de los parámetros en tiempo de compilación.Esto también puede resultar en un mejor rendimiento.</target>
        </trans-unit>
        <trans-unit id="f41ef8f8cc465c8df198d14584ea0805a3861563" translate="yes" xml:space="preserve">
          <source>If the fractional part of x is exactly 0.5, the return value is rounded away from zero.</source>
          <target state="translated">Si la parte fraccionaria de x es exactamente 0,5,el valor de retorno se redondea a partir de cero.</target>
        </trans-unit>
        <trans-unit id="6a44050dca10920a151c58d6983c48f0ef88a105" translate="yes" xml:space="preserve">
          <source>If the function is passed in string form, the state has name &lt;code&gt;&quot;a&quot;&lt;/code&gt; and the zero-based index in the recurrence has name &lt;code&gt;&quot;n&quot;&lt;/code&gt;. The given string must return the desired value for &lt;code&gt;a[n]&lt;/code&gt; given &lt;code&gt;a[n - 1]&lt;/code&gt;, &lt;code&gt;a[n - 2]&lt;/code&gt;, &lt;code&gt;a[n - 3]&lt;/code&gt;,..., &lt;code&gt;a[n - stateSize]&lt;/code&gt;. The state size is dictated by the number of arguments passed to the call to &lt;code&gt;recurrence&lt;/code&gt;. The &lt;code&gt;Recurrence&lt;/code&gt; struct itself takes care of managing the recurrence's state and shifting it appropriately.</source>
          <target state="translated">Si la funci&amp;oacute;n se pasa en forma de cadena, el estado tiene el nombre &lt;code&gt;&quot;a&quot;&lt;/code&gt; y el &amp;iacute;ndice de base cero en la recurrencia tiene el nombre &lt;code&gt;&quot;n&quot;&lt;/code&gt; . La cadena dada debe devolver el valor deseado para &lt;code&gt;a[n]&lt;/code&gt; dado &lt;code&gt;a[n - 1]&lt;/code&gt; , &lt;code&gt;a[n - 2]&lt;/code&gt; , &lt;code&gt;a[n - 3]&lt;/code&gt; , ..., &lt;code&gt;a[n - stateSize]&lt;/code&gt; . El tama&amp;ntilde;o del estado est&amp;aacute; dictado por el n&amp;uacute;mero de argumentos pasados ​​a la llamada a la &lt;code&gt;recurrence&lt;/code&gt; . La estructura de &lt;code&gt;Recurrence&lt;/code&gt; misma se encarga de administrar el estado de recurrencia y cambiarlo adecuadamente.</target>
        </trans-unit>
        <trans-unit id="3c67c2406f3c735811702f591ea611c2970cdc93" translate="yes" xml:space="preserve">
          <source>If the function returns &lt;code&gt;void&lt;/code&gt;, and the first parameter is &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;out&lt;/code&gt;, then all subsequent &lt;code&gt;return ref&lt;/code&gt; parameters are considered as being assigned to the first parameter for lifetime checking. The &lt;code&gt;this&lt;/code&gt; reference parameter to a struct non-static member function is considered the first parameter.</source>
          <target state="translated">Si la funci&amp;oacute;n devuelve &lt;code&gt;void&lt;/code&gt; , y el primer par&amp;aacute;metro es &lt;code&gt;ref&lt;/code&gt; o &lt;code&gt;out&lt;/code&gt; , entonces todos los par&amp;aacute;metros de &lt;code&gt;return ref&lt;/code&gt; posteriores se consideran asignados al primer par&amp;aacute;metro para la verificaci&amp;oacute;n de la vida &amp;uacute;til. El par&amp;aacute;metro &lt;code&gt;this&lt;/code&gt; reference a una funci&amp;oacute;n de miembro struct no est&amp;aacute;tico se considera el primer par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="e2f91af04048a7f2df150e8629c6506bcf13c494" translate="yes" xml:space="preserve">
          <source>If the generated copy constructor fails to type check, it will receive the &lt;code&gt;@disable&lt;/code&gt; attribute.</source>
          <target state="translated">Si el constructor de la copia generada no puede escribir check, recibir&amp;aacute; el atributo &lt;code&gt;@disable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b1f1e5a2ec324dd58e7c90d671571002b1fff9a" translate="yes" xml:space="preserve">
          <source>If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's &lt;code&gt;end&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;end&lt;/code&gt;. If iterating backwards, and the generated time point is before &lt;code&gt;begin&lt;/code&gt;, then &lt;code&gt;front&lt;/code&gt; becomes &lt;code&gt;begin&lt;/code&gt;. In either case, the range would then be empty.</source>
          <target state="translated">Si el punto de tiempo generado pasa el borde del rango en la direcci&amp;oacute;n correcta, entonces se usar&amp;aacute; el borde de ese rango. Entonces, si itera hacia adelante, y el punto de tiempo generado pasa el &lt;code&gt;end&lt;/code&gt; del intervalo , entonces el &lt;code&gt;front&lt;/code&gt; convierte en &lt;code&gt;end&lt;/code&gt; . Si itera hacia atr&amp;aacute;s, y el punto de tiempo generado es antes de &lt;code&gt;begin&lt;/code&gt; , entonces el &lt;code&gt;front&lt;/code&gt; convierte en &lt;code&gt;begin&lt;/code&gt; . En cualquier caso, el rango estar&amp;iacute;a vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="f99397fa61eb34180bac28883c2e71092de6779b" translate="yes" xml:space="preserve">
          <source>If the given file is a symbolic link, then this returns the attributes of the symbolic link itself rather than file that it points to. If the given file is</source>
          <target state="translated">Si el archivo dado es un enlace simbólico,entonces esto devuelve los atributos del propio enlace simbólico en lugar del archivo al que apunta.Si el archivo dado es</target>
        </trans-unit>
        <trans-unit id="a8dd80adc35b72f7e72590ec9517794124fe146d" translate="yes" xml:space="preserve">
          <source>If the given header contains columns not found in the input they will be ignored.</source>
          <target state="translated">Si el encabezado dado contiene columnas no encontradas en la entrada,serán ignoradas.</target>
        </trans-unit>
        <trans-unit id="6c1edb4f30ef72dc654568216fa979bf98fad63c" translate="yes" xml:space="preserve">
          <source>If the given header does not match the order in the input, the content will return as it is found in the input.</source>
          <target state="translated">Si el encabezado dado no coincide con el orden en la entrada,el contenido regresará como se encuentra en la entrada.</target>
        </trans-unit>
        <trans-unit id="02a682f7846fb30dcf203d60bc7b6d3c76c4aec4" translate="yes" xml:space="preserve">
          <source>If the heap has room to grow, inserts &lt;code&gt;value&lt;/code&gt; into the store and returns &lt;code&gt;true&lt;/code&gt;. Otherwise, if &lt;code&gt;less(value, front)&lt;/code&gt;, calls &lt;code&gt;replaceFront(value)&lt;/code&gt; and returns again &lt;code&gt;true&lt;/code&gt;. Otherwise, leaves the heap unaffected and returns &lt;code&gt;false&lt;/code&gt;. This method is useful in scenarios where the smallest &lt;code&gt;k&lt;/code&gt; elements of a set of candidates must be collected.</source>
          <target state="translated">Si el mont&amp;oacute;n tiene espacio para crecer, inserta &lt;code&gt;value&lt;/code&gt; en la tienda y devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, si es &lt;code&gt;less(value, front)&lt;/code&gt; , llama a &lt;code&gt;replaceFront(value)&lt;/code&gt; y vuelve a ser &lt;code&gt;true&lt;/code&gt; . De lo contrario, no afecta el mont&amp;oacute;n y devuelve &lt;code&gt;false&lt;/code&gt; . Este m&amp;eacute;todo es &amp;uacute;til en escenarios en los que se deben recopilar los &lt;code&gt;k&lt;/code&gt; elementos m&amp;aacute;s peque&amp;ntilde;os de un conjunto de candidatos.</target>
        </trans-unit>
        <trans-unit id="44b5028eff915a424d2f05a190933f50e1ca6cdc" translate="yes" xml:space="preserve">
          <source>If the indexing key already exists in the AA, the setting runs normal assignment.</source>
          <target state="translated">Si la clave de indexación ya existe en el AA,el ajuste ejecuta la asignación normal.</target>
        </trans-unit>
        <trans-unit id="ed75ab58ae875098848f819360947f45ce239d60" translate="yes" xml:space="preserve">
          <source>If the indexing key does not yet exist in AA, a new AA entry will be allocated, and it will be initialized with the assigned value.</source>
          <target state="translated">Si la clave de indización no existe todavía en AA,se asignará una nueva entrada de AA y se inicializará con el valor asignado.</target>
        </trans-unit>
        <trans-unit id="e8855e5c687d575ac4df58472c04fb490240846e" translate="yes" xml:space="preserve">
          <source>If the infinite-precision result fits in the result type, return it and do not touch &lt;code&gt;overflow&lt;/code&gt;</source>
          <target state="translated">Si el resultado de precisi&amp;oacute;n infinita encaja en el tipo de resultado, devu&amp;eacute;lvalo y no toque el &lt;code&gt;overflow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4845dcdf1de3a2fc72f78227d54d29b17278e722" translate="yes" xml:space="preserve">
          <source>If the initializer is not present, the immutable can be initialized from the corresponding constructor:</source>
          <target state="translated">Si el inicializador no está presente,el inmutable puede ser inicializado desde el constructor correspondiente:</target>
        </trans-unit>
        <trans-unit id="b6a08857ba6ae055c6d0992d75eba874a7e5568d" translate="yes" xml:space="preserve">
          <source>If the input array is already valid, this function returns the original, otherwise it constructs a new array by replacing all illegal sequences with the encoding scheme's replacement sequence.</source>
          <target state="translated">Si la matriz de entrada ya es válida,esta función devuelve el original,de lo contrario construye una nueva matriz sustituyendo todas las secuencias ilegales por la secuencia de sustitución del esquema de codificación.</target>
        </trans-unit>
        <trans-unit id="8c989250d06df7a1e7f52d0b71ed6e2b6ea2a097" translate="yes" xml:space="preserve">
          <source>If the input string is already valid, this function returns the original, otherwise it constructs a new string by replacing all illegal code unit sequences with the encoding's replacement character, Invalid sequences will be replaced with the Unicode replacement character (U+FFFD) if the character repertoire contains it, otherwise invalid sequences will be replaced with '?'.</source>
          <target state="translated">Si la cadena de entrada ya es válida,esta función devuelve el original,de lo contrario construye una nueva cadena reemplazando todas las secuencias de unidades de código ilegales con el carácter de reemplazo de la codificación,las secuencias inválidas serán reemplazadas con el carácter de reemplazo de Unicode (U+FFFD)si el repertorio de caracteres lo contiene,de lo contrario las secuencias inválidas serán reemplazadas con '?'.</target>
        </trans-unit>
        <trans-unit id="c3178232393693733f89474a2be2c7d87e890b8d" translate="yes" xml:space="preserve">
          <source>If the instance &lt;code&gt;toString&lt;/code&gt; has overridden &lt;code&gt;Object.toString&lt;/code&gt;, it is used.</source>
          <target state="translated">Si la instancia &lt;code&gt;toString&lt;/code&gt; ha anulado &lt;code&gt;Object.toString&lt;/code&gt; , se utiliza.</target>
        </trans-unit>
        <trans-unit id="3bbc396d6905590778769668af1612cc2bc09090" translate="yes" xml:space="preserve">
          <source>If the invariant does not hold, then the program enters an invalid state.</source>
          <target state="translated">Si la invariante no se mantiene,entonces el programa entra en un estado inválido.</target>
        </trans-unit>
        <trans-unit id="29f830d3a5bba4e064a4eb84cc7502640a0b8dc9" translate="yes" xml:space="preserve">
          <source>If the last template parameter in the</source>
          <target state="translated">Si el último parámetro de la plantilla en el</target>
        </trans-unit>
        <trans-unit id="88a26f48b106a357207e0f09ddece2a679970e48" translate="yes" xml:space="preserve">
          <source>If the last template parameter is set to &lt;code&gt;No.multiblock&lt;/code&gt;, the allocator will only serve allocations which require at most &lt;code&gt;theBlockSize&lt;/code&gt;. The &lt;code&gt;BitmappedBlock&lt;/code&gt; has a specialized implementation for single-block allocations which allows for greater performance, at the cost of not being able to allocate more than one block at a time.</source>
          <target state="translated">Si el &amp;uacute;ltimo par&amp;aacute;metro de plantilla se establece en &lt;code&gt;No.multiblock&lt;/code&gt; , el asignador solo servir&amp;aacute; asignaciones que requieren como m&amp;aacute;ximo &lt;code&gt;theBlockSize&lt;/code&gt; . El &lt;code&gt;BitmappedBlock&lt;/code&gt; tiene una aplicaci&amp;oacute;n especializada para la asignaci&amp;oacute;n de un solo bloque que permite un rendimiento mayor, a costa de no ser capaz de asignar m&amp;aacute;s de una cuadra a la vez.</target>
        </trans-unit>
        <trans-unit id="b95587a219c8d062823f53f5bd2f1a123f7f69f2" translate="yes" xml:space="preserve">
          <source>If the left and right operands are of the same struct type, and the struct type has a &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt;, then the copy operation is as described in &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt;.</source>
          <target state="translated">Si los operandos izquierdo y derecho son del mismo tipo de estructura, y el tipo de estructura tiene un &lt;a href=&quot;struct#Postblit&quot;&gt;&lt;i&gt;Postblit&lt;/i&gt;&lt;/a&gt; , entonces la operaci&amp;oacute;n de copia es como se describe en &lt;a href=&quot;struct#struct-postblit&quot;&gt;Struct Postblit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78b1fe866d2fc25a11cfe13642305ae4d6350c6d" translate="yes" xml:space="preserve">
          <source>If the left hand side of an</source>
          <target state="translated">Si el lado izquierdo de un</target>
        </trans-unit>
        <trans-unit id="eb414c8d10d773bd339d18bd7ab37e8cf26592ba" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is a slice operation on a struct or class instance, it can be overloaded by implementing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function that takes the return value of the &lt;code&gt;opSlice&lt;/code&gt; function as parameter(s). Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Si el lado izquierdo de una asignaci&amp;oacute;n es una operaci&amp;oacute;n de divisi&amp;oacute;n en una instancia de estructura o clase, se puede sobrecargar implementando una funci&amp;oacute;n miembro &lt;code&gt;opIndexAssign&lt;/code&gt; que toma el valor de retorno de la funci&amp;oacute;n &lt;code&gt;opSlice&lt;/code&gt; como par&amp;aacute;metro (s). Expresiones de la forma &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4e9f1b74401fc4cc6670aa5c593952f4aacceb0" translate="yes" xml:space="preserve">
          <source>If the left hand side of an assignment is an index operation on a struct or class instance, it can be overloaded by providing an &lt;code&gt;opIndexAssign&lt;/code&gt; member function. Expressions of the form &lt;code&gt;a[&lt;/code&gt;</source>
          <target state="translated">Si el lado izquierdo de una asignaci&amp;oacute;n es una operaci&amp;oacute;n de &amp;iacute;ndice en una instancia de estructura o clase, se puede sobrecargar proporcionando una funci&amp;oacute;n miembro &lt;code&gt;opIndexAssign&lt;/code&gt; . Expresiones de la forma &lt;code&gt;a[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8a73a5f2389d0e22c2833822feb34b34d4eccd0" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;false&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">Si el operando izquierdo es &lt;code&gt;false&lt;/code&gt; , entonces se eval&amp;uacute;a el operando derecho. Si el tipo de resultado de la</target>
        </trans-unit>
        <trans-unit id="60ea3d064b90b5b8a778e152eace4b2f3ae90eb9" translate="yes" xml:space="preserve">
          <source>If the left operand is &lt;code&gt;true&lt;/code&gt;, then the right operand is evaluated. If the result type of the</source>
          <target state="translated">Si el operando izquierdo es &lt;code&gt;true&lt;/code&gt; , entonces se eval&amp;uacute;a el operando derecho. Si el tipo de resultado de la</target>
        </trans-unit>
        <trans-unit id="019b690c1822d6ef391c3b9bd7b26426c5f16db7" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;false&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">Si el operando izquierdo, convertido a tipo &lt;code&gt;bool&lt;/code&gt; , se eval&amp;uacute;a como &lt;code&gt;false&lt;/code&gt; , entonces el operando derecho no se eval&amp;uacute;a. Si el tipo de resultado de la</target>
        </trans-unit>
        <trans-unit id="553371891fa4522412ee1e69cce9e04315ec8432" translate="yes" xml:space="preserve">
          <source>If the left operand, converted to type &lt;code&gt;bool&lt;/code&gt;, evaluates to &lt;code&gt;true&lt;/code&gt;, then the right operand is not evaluated. If the result type of the</source>
          <target state="translated">Si el operando izquierdo, convertido a tipo &lt;code&gt;bool&lt;/code&gt; , se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; , entonces el operando derecho no se eval&amp;uacute;a. Si el tipo de resultado de la</target>
        </trans-unit>
        <trans-unit id="3b4965e0366e4348265d324ef6cafd070f7970a9" translate="yes" xml:space="preserve">
          <source>If the lock is held by another caller, the method returns. Otherwise, the lock is acquired if it is not already held, and then the internal counter is incremented by one.</source>
          <target state="translated">Si la cerradura es mantenida por otro llamante,el método regresa.De lo contrario,el bloqueo se adquiere si no está ya sostenido,y entonces el contador interno se incrementa en uno.</target>
        </trans-unit>
        <trans-unit id="55629f3e58b1ed6b51915672626c91dce13adbf6" translate="yes" xml:space="preserve">
          <source>If the lvalue is a static array or a slice, the behavior is as described in &lt;a href=&quot;array#array-copying&quot;&gt;Array Copying&lt;/a&gt; and &lt;a href=&quot;array#array-setting&quot;&gt;Array Setting&lt;/a&gt;.</source>
          <target state="translated">Si lvalue es una matriz est&amp;aacute;tica o un sector, el comportamiento es como se describe en &lt;a href=&quot;array#array-copying&quot;&gt;Copia de &lt;/a&gt;&lt;a href=&quot;array#array-setting&quot;&gt;matriz&lt;/a&gt; y Configuraci&amp;oacute;n de matriz .</target>
        </trans-unit>
        <trans-unit id="9eeb3d42a4d163cc9ef2cce9f7a4d552e700ff44" translate="yes" xml:space="preserve">
          <source>If the lvalue is a user-defined property, the behavior is as described in &lt;a href=&quot;function#property-functions&quot;&gt;Property Functions&lt;/a&gt;.</source>
          <target state="translated">Si lvalue es una propiedad definida por el usuario, el comportamiento es como se describe en &lt;a href=&quot;function#property-functions&quot;&gt;Funciones de propiedad&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e946590fb7a5bc10633af10a8d9500f37b24a5e" translate="yes" xml:space="preserve">
          <source>If the lvalue is the &lt;code&gt;.length&lt;/code&gt; property of a dynamic array, the behavior is as described in &lt;a href=&quot;array#resize&quot;&gt;Setting Dynamic Array Length&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;.length&lt;/code&gt; es la propiedad .length de una matriz din&amp;aacute;mica, el comportamiento es como se describe en &lt;a href=&quot;array#resize&quot;&gt;Configuraci&amp;oacute;n de la longitud de la matriz din&amp;aacute;mica&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbdda788f4cd04313acf31a5b41902468d969a5d" translate="yes" xml:space="preserve">
          <source>If the member is a class or struct, undefined lookups will be forwarded to the</source>
          <target state="translated">Si el miembro es una clase o estructura,las búsquedas no definidas serán enviadas al</target>
        </trans-unit>
        <trans-unit id="c199908c7f62621c91cf713b59d48d772db7abde" translate="yes" xml:space="preserve">
          <source>If the modifier &lt;code&gt;'d'&lt;/code&gt; is present, then the number of characters in &lt;code&gt;to&lt;/code&gt; may be only &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.  If the modifier &lt;code&gt;'d'&lt;/code&gt; is</source>
          <target state="translated">Si el modificador &lt;code&gt;'d'&lt;/code&gt; est&amp;aacute; presente, entonces el n&amp;uacute;mero de caracteres en &lt;code&gt;to&lt;/code&gt; puede ser s&amp;oacute;lo &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;1&lt;/code&gt; . Si el modificador &lt;code&gt;'d'&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="f37f897b787b41e685e34c136ea8c1b433cab685" translate="yes" xml:space="preserve">
          <source>If the need is to remove some elements in the range but the order of the remaining elements does not have to be preserved, you may want to pass &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; to &lt;code&gt;remove&lt;/code&gt;.</source>
          <target state="translated">Si la necesidad es eliminar algunos elementos en el rango pero no es necesario preservar el orden de los elementos restantes, es posible que desee pasar &lt;code&gt;SwapStrategy.unstable&lt;/code&gt; para &lt;code&gt;remove&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03a264184d81bbe95136e2edec953acc73c6e493" translate="yes" xml:space="preserve">
          <source>If the new array length is longer, the remainder is filled out with the default initializer.</source>
          <target state="translated">Si la nueva longitud de la matriz es mayor,el resto se rellena con el inicializador predeterminado.</target>
        </trans-unit>
        <trans-unit id="e4175ca1068588312ee2e22b72b62b8fd2ed5c5b" translate="yes" xml:space="preserve">
          <source>If the only pointer to an object is held outside of these areas, then the collector will miss it and free the memory.</source>
          <target state="translated">Si el único puntero de un objeto se mantiene fuera de estas áreas,el coleccionista lo perderá y liberará la memoria.</target>
        </trans-unit>
        <trans-unit id="4717846b29b0f5d911b4b2433c06faa02839af64" translate="yes" xml:space="preserve">
          <source>If the operands are integral values, the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt; are applied to bring them to a common type before comparison. Equality is defined as the bit patterns of the common type match exactly.</source>
          <target state="translated">Si los operandos son valores integrales, las &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;conversiones aritm&amp;eacute;ticas usuales&lt;/a&gt; se aplican para llevarlos a un tipo com&amp;uacute;n antes de la comparaci&amp;oacute;n. La igualdad se define como los patrones de bits del tipo com&amp;uacute;n coinciden exactamente.</target>
        </trans-unit>
        <trans-unit id="47f360c49b94c4c07ce9dc61c5e3af5635a7a2ca" translate="yes" xml:space="preserve">
          <source>If the operands are of integral types, they undergo the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;, and then are brought to a common type using the &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;Usual Arithmetic Conversions&lt;/a&gt;.</source>
          <target state="translated">Si los operandos son de tipos integrales, se someten a las &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;conversiones aritm&amp;eacute;ticas habituales&lt;/a&gt; , y luego se llevan a un tipo com&amp;uacute;n utilizando las &lt;a href=&quot;type#usual-arithmetic-conversions&quot;&gt;conversiones aritm&amp;eacute;ticas habituales&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84b7a8c85c49e4f67e102545e92d61c9c7d7721a" translate="yes" xml:space="preserve">
          <source>If the operands are pointers, equality is defined as the bit patterns of the operands match exactly.</source>
          <target state="translated">Si los operandos son punteros,la igualdad se define como los patrones de bits de los operandos coinciden exactamente.</target>
        </trans-unit>
        <trans-unit id="d6d2f3784c99d4e2535bc4e5ff87e942828bc905" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be of that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2963819db13f5d2cdfe8c71bec58c53fd098f3" translate="yes" xml:space="preserve">
          <source>If the operands are the same type, the result will be the that type.</source>
          <target state="translated">Si los operandos son del mismo tipo,el resultado será de ese tipo.</target>
        </trans-unit>
        <trans-unit id="b17e0053bf5ffe1d2e67cd6799c427ff52f64545" translate="yes" xml:space="preserve">
          <source>If the operands of an associative operator + or * are floating point values, the expression is not reordered.</source>
          <target state="translated">Si los operandos de un operador asociativo+o*son valores en coma flotante,la expresión no se reordena.</target>
        </trans-unit>
        <trans-unit id="1ff3f829adb0f4d6d8dd5ae222b510bf5f3ff104" translate="yes" xml:space="preserve">
          <source>If the operation would lead to an over/underflow, this function will return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Si la operaci&amp;oacute;n llevar&amp;iacute;a a un desbordamiento / desbordamiento, esta funci&amp;oacute;n devolver&amp;aacute; &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="988a22885dd9a150d46126a78cb644539f3b1a37" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, and the first operand is a pointer, and the second is an integral type, the resulting type is the type of the first operand, and the resulting value is the pointer plus (or minus) the second operand multiplied by the size of the type pointed to by the first operand.</source>
          <target state="translated">Si el operador es &lt;code&gt;+&lt;/code&gt; o &lt;code&gt;-&lt;/code&gt; , y el primer operando es un puntero, y el segundo es un tipo integral, el tipo resultante es el tipo del primer operando, y el valor resultante es el puntero m&amp;aacute;s (o menos) del segundo operando multiplicado por el tama&amp;ntilde;o del tipo se&amp;ntilde;alado por el primer operando.</target>
        </trans-unit>
        <trans-unit id="34ffd24d69741e93233760376d587038f7e6c1e1" translate="yes" xml:space="preserve">
          <source>If the operator is &lt;code&gt;=&lt;/code&gt; then it is simple assignment. The right operand is implicitly converted to the type of the left operand, and assigned to it.</source>
          <target state="translated">Si el operador es &lt;code&gt;=&lt;/code&gt; entonces es una asignaci&amp;oacute;n simple. El operando derecho se convierte impl&amp;iacute;citamente al tipo del operando izquierdo y se le asigna.</target>
        </trans-unit>
        <trans-unit id="fd1b71b4b4c55aa30d89d8186ad8ca957d4c8944" translate="yes" xml:space="preserve">
          <source>If the optional second</source>
          <target state="translated">Si el segundo opcional</target>
        </trans-unit>
        <trans-unit id="c5921859078b177e6c63e26fb0f1ad26714bef56" translate="yes" xml:space="preserve">
          <source>If the parent allocator &lt;code&gt;Allocator&lt;/code&gt; is stateful, an instance of it is stored as a member. Otherwise, &lt;code&gt;AffixAllocator&lt;/code&gt; uses &lt;code&gt;Allocator.instance&lt;/code&gt;. In either case, the name &lt;code&gt;_parent&lt;/code&gt; is uniformly used for accessing the parent allocator.</source>
          <target state="translated">Si el asignador principal &lt;code&gt;Allocator&lt;/code&gt; tiene estado, una instancia de este se almacena como miembro. De lo contrario, &lt;code&gt;AffixAllocator&lt;/code&gt; usa &lt;code&gt;Allocator.instance&lt;/code&gt; . En cualquier caso, el nombre &lt;code&gt;_parent&lt;/code&gt; se usa de manera uniforme para acceder al asignador principal.</target>
        </trans-unit>
        <trans-unit id="af9326a4bd5d7cb5b11db287f31708f748f7ca2d" translate="yes" xml:space="preserve">
          <source>If the passed buffer is not the last allocation, then &lt;code&gt;delta&lt;/code&gt; can be at most the number of bytes left on the last page. Otherwise, we can expand the last allocation until the end of the virtual address range.</source>
          <target state="translated">Si el b&amp;uacute;fer pasado no es la &amp;uacute;ltima asignaci&amp;oacute;n, entonces &lt;code&gt;delta&lt;/code&gt; puede ser como m&amp;aacute;ximo el n&amp;uacute;mero de bytes que quedan en la &amp;uacute;ltima p&amp;aacute;gina. De lo contrario, podemos expandir la &amp;uacute;ltima asignaci&amp;oacute;n hasta el final del rango de direcciones virtuales.</target>
        </trans-unit>
        <trans-unit id="e540ec8736760fd165d128b0a1be1fa92246d1c7" translate="yes" xml:space="preserve">
          <source>If the process associated with &lt;code&gt;pid&lt;/code&gt; has already terminated, &lt;code&gt;tryWait&lt;/code&gt; has the exact same effect as &lt;code&gt;wait&lt;/code&gt;. In this case, it returns a tuple where the &lt;code&gt;terminated&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;status&lt;/code&gt; field has the same interpretation as the return value of &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">Si el proceso asociado con &lt;code&gt;pid&lt;/code&gt; ya ha finalizado, &lt;code&gt;tryWait&lt;/code&gt; tiene exactamente el mismo efecto que &lt;code&gt;wait&lt;/code&gt; . En este caso, devuelve una tupla donde el campo &lt;code&gt;terminated&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; y el campo de &lt;code&gt;status&lt;/code&gt; tiene la misma interpretaci&amp;oacute;n que el valor de retorno de &lt;code&gt;wait&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cc712808d5442951029c772a2016b0fbaebf6a3" translate="yes" xml:space="preserve">
          <source>If the process has</source>
          <target state="translated">Si el proceso tiene</target>
        </trans-unit>
        <trans-unit id="8a1cda6113d7bf95379f37d69fe6660204f54b65" translate="yes" xml:space="preserve">
          <source>If the process has already terminated, this function returns directly. The exit code is cached, so that if wait() is called multiple times on the same &lt;a href=&quot;#Pid&quot;&gt;&lt;code&gt;Pid&lt;/code&gt;&lt;/a&gt; it will always return the same value.</source>
          <target state="translated">Si el proceso ya ha finalizado, esta funci&amp;oacute;n vuelve directamente. El c&amp;oacute;digo de salida se almacena en cach&amp;eacute;, de modo que si se llama a wait () varias veces en el mismo &lt;a href=&quot;#Pid&quot;&gt; &lt;code&gt;Pid&lt;/code&gt; &lt;/a&gt; , siempre devolver&amp;aacute; el mismo valor.</target>
        </trans-unit>
        <trans-unit id="04681d73e96e38582bd8e0a705f2c67039e3da37" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, the &lt;code&gt;status&lt;/code&gt; field of the return value will contain a negative number whose absolute value is the signal number. (See &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Si el proceso finaliza con una se&amp;ntilde;al, el campo de &lt;code&gt;status&lt;/code&gt; del valor de retorno contendr&amp;aacute; un n&amp;uacute;mero negativo cuyo valor absoluto es el n&amp;uacute;mero de se&amp;ntilde;al. (Ver &lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; para m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="2cb4ce468479df22f5efb3ab328110646f8f6c12" translate="yes" xml:space="preserve">
          <source>If the process is terminated by a signal, this function returns a negative number whose absolute value is the signal number. Since POSIX restricts normal exit codes to the range 0-255, a negative return value will always indicate termination by signal. Signal codes are defined in the &lt;code&gt;core.sys.posix.signal&lt;/code&gt; module (which corresponds to the &lt;code&gt;signal.h&lt;/code&gt; POSIX header).</source>
          <target state="translated">Si el proceso termina con una se&amp;ntilde;al, esta funci&amp;oacute;n devuelve un n&amp;uacute;mero negativo cuyo valor absoluto es el n&amp;uacute;mero de se&amp;ntilde;al. Dado que POSIX restringe los c&amp;oacute;digos de salida normales al rango 0-255, un valor de retorno negativo siempre indicar&amp;aacute; la terminaci&amp;oacute;n por se&amp;ntilde;al. Los c&amp;oacute;digos de se&amp;ntilde;al se definen en el m&amp;oacute;dulo &lt;code&gt;core.sys.posix.signal&lt;/code&gt; (que corresponde al encabezado POSIX &lt;code&gt;signal.h&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="55d51d320c375e52c1f5d554f57416c612f36789" translate="yes" xml:space="preserve">
          <source>If the range is already the lexicographically greatest even permutation, it is permuted back to the least even permutation and false is returned. Otherwise, true is returned, and the range is modified in-place to be the lexicographically next even permutation.</source>
          <target state="translated">Si el rango es ya la permutación lexicográficamente más grande y pareja,se permuta de nuevo a la permutación menos pareja y se devuelve falso.En caso contrario,se devuelve true,y el rango se modifica en el lugar para ser la siguiente permutación uniforme lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="b6341c08a4c104d5a17945be30a12feeaa49cdba" translate="yes" xml:space="preserve">
          <source>If the range is currently the lexicographically greatest permutation, it is permuted back to the least permutation and false is returned. Otherwise, true is returned. One can thus generate all permutations of a range by sorting it according to &lt;code&gt;less&lt;/code&gt;, which produces the lexicographically least permutation, and then calling nextPermutation until it returns false. This is guaranteed to generate all distinct permutations of the range exactly once. If there are</source>
          <target state="translated">Si el rango es actualmente la mayor permutaci&amp;oacute;n lexicogr&amp;aacute;fica, se permuta de nuevo a la menor permutaci&amp;oacute;n y se devuelve falso. De lo contrario, se devuelve verdadero. Por lo tanto, uno puede generar todas las permutaciones de un rango al ordenarlo de acuerdo con &lt;code&gt;less&lt;/code&gt; , lo que produce la permutaci&amp;oacute;n menos lexicogr&amp;aacute;fica, y luego llamar a nextPermutation hasta que devuelva falso. Esto garantiza generar todas las permutaciones distintas del rango exactamente una vez. Si hay</target>
        </trans-unit>
        <trans-unit id="3c682555e85edc7cea0e0b4d1aeb80e941ac4580" translate="yes" xml:space="preserve">
          <source>If the range runs out before &lt;code&gt;n&lt;/code&gt; elements, &lt;code&gt;take&lt;/code&gt; simply returns the entire range (unlike &lt;a href=&quot;#takeExactly&quot;&gt;&lt;code&gt;takeExactly&lt;/code&gt;&lt;/a&gt;, which will cause an assertion failure if the range ends prematurely):</source>
          <target state="translated">Si el rango se agota antes de &lt;code&gt;n&lt;/code&gt; elementos, &lt;code&gt;take&lt;/code&gt; simplemente devuelve todo el rango (a diferencia de &lt;a href=&quot;#takeExactly&quot;&gt; &lt;code&gt;takeExactly&lt;/code&gt; &lt;/a&gt; , lo que provocar&amp;aacute; un error de aserci&amp;oacute;n si el rango termina prematuramente):</target>
        </trans-unit>
        <trans-unit id="0bfb47486948f76918fc7de4a55b72efe69b4181" translate="yes" xml:space="preserve">
          <source>If the ranges are strings, &lt;code&gt;cmp&lt;/code&gt; performs UTF decoding appropriately and compares the ranges one code point at a time.</source>
          <target state="translated">Si los rangos son cadenas, &lt;code&gt;cmp&lt;/code&gt; realiza la decodificaci&amp;oacute;n UTF de manera apropiada y compara los rangos un punto de c&amp;oacute;digo a la vez.</target>
        </trans-unit>
        <trans-unit id="ea41ed6834ee0093fe72c06e40f7dc343689c14c" translate="yes" xml:space="preserve">
          <source>If the restrictions above are met, the following copy constructor is generated:</source>
          <target state="translated">Si se cumplen las restricciones anteriores,se genera el siguiente constructor de copias:</target>
        </trans-unit>
        <trans-unit id="7f1cd9d3b49d8a1f62d192e4c5f4c5d296e6ef4a" translate="yes" xml:space="preserve">
          <source>If the return type is int, and the result can't fit in an int, then the closest value that can be held in 32 bits will be used (so &lt;code&gt;int.max&lt;/code&gt; if it goes over and &lt;code&gt;int.min&lt;/code&gt; if it goes under). However, no attempt is made to deal with integer overflow if the return type is long.</source>
          <target state="translated">Si el tipo de retorno es int, y el resultado no puede caber en un int, entonces se usar&amp;aacute; el valor m&amp;aacute;s cercano que puede mantenerse en 32 bits (por &lt;code&gt;int.max&lt;/code&gt; tanto, int.max si se supera e &lt;code&gt;int.min&lt;/code&gt; si se reduce ) . Sin embargo, no se intenta tratar el desbordamiento de enteros si el tipo de retorno es largo.</target>
        </trans-unit>
        <trans-unit id="dd2f2570182620b9927043173b24e489663dd5b6" translate="yes" xml:space="preserve">
          <source>If the return value is not equal to x, the FE_INEXACT exception is raised.</source>
          <target state="translated">Si el valor de retorno no es igual a x,se eleva la excepción FE_INEXACT.</target>
        </trans-unit>
        <trans-unit id="d430fac68e42265828ef3bb0905404a148953d53" translate="yes" xml:space="preserve">
          <source>If the right-hand side is also a Checked but with a different hook or underlying type, the hook and underlying type of this Checked takes precedence.</source>
          <target state="translated">Si el lado derecho es también un Chequeado pero con un gancho o tipo subyacente diferente,el gancho y tipo subyacente de este Chequeado tiene prioridad.</target>
        </trans-unit>
        <trans-unit id="decd65c423494fe4dd1111ea2c9da5871cfb6a35" translate="yes" xml:space="preserve">
          <source>If the second argument's length is less than that of the range indexed, an exception is thrown.</source>
          <target state="translated">Si la longitud del segundo argumento es menor que la del rango indexado,se lanza una excepción.</target>
        </trans-unit>
        <trans-unit id="09c0c3ad5616d292e80fb1d35bad8dff429d7620" translate="yes" xml:space="preserve">
          <source>If the second character of &lt;code&gt;path&lt;/code&gt; is a colon (&lt;code&gt;':'&lt;/code&gt;), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</source>
          <target state="translated">Si el segundo car&amp;aacute;cter de la &lt;code&gt;path&lt;/code&gt; es un signo de dos puntos ( &lt;code&gt;':'&lt;/code&gt; ), el primer car&amp;aacute;cter se interpreta como una letra de unidad y debe estar en el rango AZ (no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas).</target>
        </trans-unit>
        <trans-unit id="c8d361e2ea8510e2f9b6eea1c593f762c25ea047" translate="yes" xml:space="preserve">
          <source>If the second operand is a pointer, and the first is an integral type, and the operator is &lt;code&gt;+&lt;/code&gt;, the operands are reversed and the pointer arithmetic just described is applied.</source>
          <target state="translated">Si el segundo operando es un puntero, y el primero es un tipo integral, y el operador es &lt;code&gt;+&lt;/code&gt; , los operandos se invierten y se aplica la aritm&amp;eacute;tica del puntero que se acaba de describir.</target>
        </trans-unit>
        <trans-unit id="32b0c9d866faa45199f7035225674aa790902392" translate="yes" xml:space="preserve">
          <source>If the sequence ending at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.  &lt;code&gt;cs&lt;/code&gt; indicates whether the comparisons are case sensitive.</source>
          <target state="translated">Si la secuencia que termina en &lt;code&gt;startIdx&lt;/code&gt; no representa un punto de c&amp;oacute;digo bien formado, se puede &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.utf.UTFException . &lt;code&gt;cs&lt;/code&gt; indica si las comparaciones distinguen entre may&amp;uacute;sculas y min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="a37342eba6058b3aa514ecc3e65805a0fa7ec8d8" translate="yes" xml:space="preserve">
          <source>If the sequence is a</source>
          <target state="translated">Si la secuencia es una</target>
        </trans-unit>
        <trans-unit id="6e3f474a691ae0e04c816db20a8a1ee2782164f2" translate="yes" xml:space="preserve">
          <source>If the sequence starting at &lt;code&gt;startIdx&lt;/code&gt; does not represent a well formed codepoint, then a &lt;a href=&quot;std_utf#UTFException&quot;&gt;&lt;code&gt;std.utf.UTFException&lt;/code&gt;&lt;/a&gt; may be thrown.</source>
          <target state="translated">Si la secuencia que comienza en &lt;code&gt;startIdx&lt;/code&gt; no representa un punto de c&amp;oacute;digo bien formado, se puede &lt;a href=&quot;std_utf#UTFException&quot;&gt; &lt;code&gt;std.utf.UTFException&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n std.utf.UTFException .</target>
        </trans-unit>
        <trans-unit id="2ca37c345a633b86c3f0a8d6f14512c0f7890283" translate="yes" xml:space="preserve">
          <source>If the sign bit is set (that is, it's 'negative'), NAN is less than any number; if the sign bit is not set (it is 'positive'), NAN is greater than any number;</source>
          <target state="translated">Si el bit del signo está configurado (es decir,es 'negativo'),NAN es menor que cualquier número;si el bit del signo no está configurado (es 'positivo'),NAN es mayor que cualquier número;</target>
        </trans-unit>
        <trans-unit id="ad31a32f0506299a66cf84413a7632e943786b66" translate="yes" xml:space="preserve">
          <source>If the signed type is larger than the unsigned type, the unsigned type is converted to the signed type.</source>
          <target state="translated">Si el tipo con firma es más grande que el tipo sin firma,el tipo sin firma se convierte en el tipo con firma.</target>
        </trans-unit>
        <trans-unit id="e9a551f8b9f105f8f42e469f990b7c6973a86a1b" translate="yes" xml:space="preserve">
          <source>If the slice bounds can be known at compile time, the slice expression is implicitly convertible to an lvalue of static array. For example:</source>
          <target state="translated">Si los límites de la rebanada pueden conocerse en el momento de la compilación,la expresión de la rebanada es implícitamente convertible a un valor de matriz estática.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="6ad59f15848db49d072bd8cb912bde77ae2b6ed6" translate="yes" xml:space="preserve">
          <source>If the source file does not start with a BOM, then the first character must be less than or equal to U+0000007F.</source>
          <target state="translated">Si el archivo fuente no comienza con una lista de materiales,entonces el primer carácter debe ser menor o igual a U+0000007F.</target>
        </trans-unit>
        <trans-unit id="b27e4bb1c5315e54c4ca57d01e83f479ac84dbd7" translate="yes" xml:space="preserve">
          <source>If the string data is UTF-8 and can be accessed directly, return a pointer to it. Do not assume a terminating 0.</source>
          <target state="translated">Si los datos de la cadena son UTF-8 y se puede acceder a ellos directamente,devuelva un puntero a ellos.No asuma un 0 final.</target>
        </trans-unit>
        <trans-unit id="5f0ad93f155cd5ae6b24670f9767f5398de5e539" translate="yes" xml:space="preserve">
          <source>If the string does not contain an ampersand, the original will be returned.</source>
          <target state="translated">Si la cuerda no contiene un ampersand,el original será devuelto.</target>
        </trans-unit>
        <trans-unit id="1aa7c7c38f043029163560616539bec8cc7f49c1" translate="yes" xml:space="preserve">
          <source>If the string is not a legitimate IPv4 address, &lt;code&gt;ADDR_NONE&lt;/code&gt; is returned.</source>
          <target state="translated">Si la cadena no es una direcci&amp;oacute;n IPv4 leg&amp;iacute;tima, se devuelve &lt;code&gt;ADDR_NONE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b15b906e5c8636437606a7baf9615fdd3533eb67" translate="yes" xml:space="preserve">
          <source>If the string is not modified, the original will be returned.</source>
          <target state="translated">Si la cadena no se modifica,se devolverá el original.</target>
        </trans-unit>
        <trans-unit id="52f9a3df378000710aaee65a7a54a47ac2ca66c0" translate="yes" xml:space="preserve">
          <source>If the struct defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is StructName(field&lt;sub&gt;0&lt;/sub&gt;, field&lt;sub&gt;1&lt;/sub&gt;, ...) where field&lt;sub&gt;n&lt;/sub&gt; is the nth element formatted with the default format.</source>
          <target state="translated">Si la estructura define un m&amp;eacute;todo &lt;b&gt;toString ()&lt;/b&gt; , el resultado es la cadena devuelta por esta funci&amp;oacute;n. De lo contrario, el resultado es StructName (campo &lt;sub&gt;0&lt;/sub&gt; , campo &lt;sub&gt;1&lt;/sub&gt; , ...) donde el campo &lt;sub&gt;n&lt;/sub&gt; es el en&amp;eacute;simo elemento formateado con el formato predeterminado.</target>
        </trans-unit>
        <trans-unit id="479988510a7f9556e5fa41c90de2fc0cc635572b" translate="yes" xml:space="preserve">
          <source>If the switch &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is of enum type, all the enum members must appear in the &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt;s.</source>
          <target state="translated">Si el modificador &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; es de tipo enum, todos los miembros de enum deben aparecer en &lt;a href=&quot;#CaseStatement&quot;&gt;&lt;i&gt;CaseStatement&lt;/i&gt;&lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="392ee3a5c086f39b17e3a3bb06e7ae5f17a147b6" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0154ff095266436fcdfa44d46155c17b50639bb" translate="yes" xml:space="preserve">
          <source>If the switch &lt;code&gt;--DRT-testmode&lt;/code&gt; is passed to the executable, it can have one of 3 values: 1. &quot;run-main&quot;: even if unit tests are run (and all pass), main is still run. This is currently the default. 2. &quot;test-or-main&quot;: any unit tests present will cause the program to summarize the results and exit regardless of the result. This will be the default in 2.080. 3. &quot;test-only&quot;, the runtime will always summarize and never run main, even if no tests are present.</source>
          <target state="translated">Si el &lt;code&gt;--DRT-testmode&lt;/code&gt; se pasa al ejecutable, puede tener uno de 3 valores: 1. &quot;run-main&quot;: incluso si se ejecutan las pruebas unitarias (y todas pasan), main todav&amp;iacute;a se ejecuta. Este es actualmente el valor predeterminado. 2. &quot;test-or-main&quot;: cualquier prueba unitaria presente har&amp;aacute; que el programa resuma los resultados y salga independientemente del resultado. Este ser&amp;aacute; el valor predeterminado en 2.080. 3. &quot;solo prueba&quot;, el tiempo de ejecuci&amp;oacute;n siempre resumir&amp;aacute; y nunca ejecutar&amp;aacute; main, incluso si no hay pruebas presentes.</target>
        </trans-unit>
        <trans-unit id="cefab3eab3f045d8e153ce4eb6c35b376eb78553" translate="yes" xml:space="preserve">
          <source>If the thread hasn't been started yet, returns &lt;a href=&quot;#ThreadID&quot;&gt;&lt;code&gt;ThreadID&lt;/code&gt;&lt;/a&gt;&lt;code&gt;.init&lt;/code&gt;. Otherwise, returns the result of &lt;code&gt;GetCurrentThreadId&lt;/code&gt; on Windows, and &lt;code&gt;pthread_self&lt;/code&gt; on POSIX.  The value is unique for the current process.</source>
          <target state="translated">Si el hilo a&amp;uacute;n no se ha iniciado, devuelve &lt;a href=&quot;#ThreadID&quot;&gt; &lt;code&gt;ThreadID&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.init&lt;/code&gt; . De lo contrario, devuelve el resultado de &lt;code&gt;GetCurrentThreadId&lt;/code&gt; en Windows y &lt;code&gt;pthread_self&lt;/code&gt; en POSIX. El valor es &amp;uacute;nico para el proceso actual.</target>
        </trans-unit>
        <trans-unit id="6c09982745040566b9680ca05a80be2c692c0e01" translate="yes" xml:space="preserve">
          <source>If the time zone is &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (or considered to be equivalent to &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; by section 4.3 of the spec), a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; with a utc offset of &lt;code&gt;0&lt;/code&gt; is used rather than &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;, whereas &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; uses &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt;&lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si la zona horaria es &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; (o se considera equivalente a &lt;code&gt;&quot;-0000&quot;&lt;/code&gt; en la secci&amp;oacute;n 4.3 de la especificaci&amp;oacute;n), se &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt; un std.datetime.timezone.SimpleTimeZone con un desplazamiento de utc de &lt;code&gt;0&lt;/code&gt; en lugar de &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; , mientras que &lt;code&gt;&quot;+0000&quot;&lt;/code&gt; usa &lt;a href=&quot;std_datetime_timezone#UTC&quot;&gt; &lt;code&gt;std.datetime.timezone.UTC&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3134e4dcc33577153221f4543bd47086f16438e4" translate="yes" xml:space="preserve">
          <source>If the two arguments are both lambda functions (or aliases to lambda functions), then they are compared for equality. For the comparison to be computed correctly, the following conditions must be met for both lambda functions:</source>
          <target state="translated">Si los dos argumentos son funciones lambda (o alias de funciones lambda),entonces se comparan por igualdad.Para que la comparación se calcule correctamente,deben cumplirse las siguientes condiciones para ambas funciones lambda:</target>
        </trans-unit>
        <trans-unit id="73a39971fe15042884479dfdbb241d4da31bea94" translate="yes" xml:space="preserve">
          <source>If the two arguments are expressions made up of literals or enums that evaluate to the same value, true is returned.</source>
          <target state="translated">Si los dos argumentos son expresiones compuestas de literales o enums que se evalúan al mismo valor,se devuelve la verdad.</target>
        </trans-unit>
        <trans-unit id="de4732a957b75ea4620f562388e09ef879657bc9" translate="yes" xml:space="preserve">
          <source>If the two arguments are tuples then &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the two tuples, after expansion, have the same length and if each pair of nth argument respects the constraints previously specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4473404d01a76d50b04f7848135307a27ac80f3" translate="yes" xml:space="preserve">
          <source>If the two operands are different enums, the result is the closest base type common to both. A base type being closer means there is a shorter sequence of conversions to base type to get there from the original type.</source>
          <target state="translated">Si los dos operandos son enums diferentes,el resultado es el tipo de base más cercano común a ambos.El hecho de que un tipo base esté más cerca significa que hay una secuencia más corta de conversiones a tipo base para llegar al tipo original.</target>
        </trans-unit>
        <trans-unit id="7903bedffa68e879ccc58bd5af9a496c7c800c23" translate="yes" xml:space="preserve">
          <source>If the two ranges are different kinds of UTF code unit (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar&lt;/code&gt;, or &lt;code&gt;dchar&lt;/code&gt;), then the arrays are compared using UTF decoding to avoid accidentally integer-promoting units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b866fed7529b50ec607a768135519745618bce85" translate="yes" xml:space="preserve">
          <source>If the type is a class or struct, returns the symbol for it, else null.</source>
          <target state="translated">Si el tipo es una clase o estructura,devuelve el símbolo de la misma,si no,es nulo.</target>
        </trans-unit>
        <trans-unit id="9cf47ab4617bfcf6525f2e55361b003e49f6a33c" translate="yes" xml:space="preserve">
          <source>If the type of a function literal can be uniquely determined from its context, the parameter type inference is possible.</source>
          <target state="translated">Si el tipo de una función literal puede determinarse de manera única a partir de su contexto,la inferencia del tipo de parámetro es posible.</target>
        </trans-unit>
        <trans-unit id="bd9e26eaa127a0681e40e687c51d18388c1cb11f" translate="yes" xml:space="preserve">
          <source>If the type specialization is dependent on a type parameter, the type of that parameter is set to be the corresponding part of the type argument.</source>
          <target state="translated">Si la especialización del tipo depende de un parámetro de tipo,el tipo de ese parámetro se establece como la parte correspondiente del argumento de tipo.</target>
        </trans-unit>
        <trans-unit id="c38cd0e42755b32d0615eb6b41299ea06a9e9a58" translate="yes" xml:space="preserve">
          <source>If the union defines a &lt;b&gt;toString()&lt;/b&gt; method the result is the string returned from this function. Otherwise the result is the name of the union, without its contents.</source>
          <target state="translated">Si la uni&amp;oacute;n define un m&amp;eacute;todo &lt;b&gt;toString ()&lt;/b&gt; , el resultado es la cadena devuelta por esta funci&amp;oacute;n. De lo contrario, el resultado es el nombre de la uni&amp;oacute;n, sin su contenido.</target>
        </trans-unit>
        <trans-unit id="5b79753b6512691a7580a1aa8dec230051399447" translate="yes" xml:space="preserve">
          <source>If the union is larger than the first field, the remaining bits are set to 0.</source>
          <target state="translated">Si la unión es más grande que el primer campo,los bits restantes se ponen a 0.</target>
        </trans-unit>
        <trans-unit id="47d795dfceba0f8eb2492f885994a47e15c6743a" translate="yes" xml:space="preserve">
          <source>If the union is larger than the initialized field, the remaining bits are set to 0.</source>
          <target state="translated">Si la unión es mayor que el campo inicializado,los bits restantes se ponen a 0.</target>
        </trans-unit>
        <trans-unit id="c1ceb76e55274ade5913babacd57bf4f1cb70312" translate="yes" xml:space="preserve">
          <source>If the user-provided size is zero or the user-provided buffer is empty, throws an &lt;code&gt;Exception&lt;/code&gt;. In case of an I/O error throws &lt;code&gt;StdioException&lt;/code&gt;.</source>
          <target state="translated">Si el tama&amp;ntilde;o proporcionado por el usuario es cero o el b&amp;uacute;fer proporcionado por el usuario est&amp;aacute; vac&amp;iacute;o, genera una &lt;code&gt;Exception&lt;/code&gt; . En caso de un error de E / S, lanza &lt;code&gt;StdioException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc7558759f1a8352a99aba9fedf7f766fc85394c" translate="yes" xml:space="preserve">
          <source>If the variable does not exist, it will be created. If it already exists, it will be overwritten.</source>
          <target state="translated">Si la variable no existe,se creará.Si ya existe,se sobrescribirá.</target>
        </trans-unit>
        <trans-unit id="1eb649b3e71267d6372924b026c8a8d1534bf07a" translate="yes" xml:space="preserve">
          <source>If the variable isn't in the environment, this function returns successfully without doing anything.</source>
          <target state="translated">Si la variable no está en el ambiente,esta función regresa con éxito sin hacer nada.</target>
        </trans-unit>
        <trans-unit id="d13d09fdf461257eb1bc31ba932d5204cebf3e15" translate="yes" xml:space="preserve">
          <source>If the variadic parameter is an array of delegates with no parameters:</source>
          <target state="translated">Si el parámetro variado es un conjunto de delegados sin parámetros:</target>
        </trans-unit>
        <trans-unit id="a4c2f19305902bafa0ffed68f37389b9cbdc3d33" translate="yes" xml:space="preserve">
          <source>If there are fewer arguments supplied in the</source>
          <target state="translated">Si hay menos argumentos suministrados en el</target>
        </trans-unit>
        <trans-unit id="137908701928a250c21674b47c9c08664cb6489d" translate="yes" xml:space="preserve">
          <source>If there are multiple</source>
          <target state="translated">Si hay múltiples</target>
        </trans-unit>
        <trans-unit id="9d520e5d39ca368a2b272ce1cc53485c938b54ac" translate="yes" xml:space="preserve">
          <source>If there are multiple &lt;code&gt;return ref&lt;/code&gt; parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</source>
          <target state="translated">Si hay varios par&amp;aacute;metros de &lt;code&gt;return ref&lt;/code&gt; , la vida &amp;uacute;til del valor de retorno es la vida &amp;uacute;til m&amp;aacute;s peque&amp;ntilde;a de los argumentos correspondientes.</target>
        </trans-unit>
        <trans-unit id="e237e9fe68b8078484793ae54d1c1e4290772666" translate="yes" xml:space="preserve">
          <source>If there are multiple UDAs in scope for a declaration, they are concatenated:</source>
          <target state="translated">Si hay múltiples UDA en el ámbito de una declaración,se concatenan:</target>
        </trans-unit>
        <trans-unit id="d33b5562bbab16d600772bb0c4e960b31c667c22" translate="yes" xml:space="preserve">
          <source>If there are multiple pragma inlines in a function, the lexically last one takes effect.</source>
          <target state="translated">Si hay múltiples líneas pragmáticas en una función,la última léxica hace efecto.</target>
        </trans-unit>
        <trans-unit id="c4b327a5dc42638f7be9041ec07ceb89c1cacdad" translate="yes" xml:space="preserve">
          <source>If there are no arguments, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si no hay argumentos, el resultado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4600b295ae3596b41be4670d227eb72326970dd" translate="yes" xml:space="preserve">
          <source>If there are no user-defined attributes for the symbol, an empty tuple is returned. The expression tuple can be turned into a manipulatable tuple:</source>
          <target state="translated">Si no hay atributos definidos por el usuario para el símbolo,se devuelve una tupla vacía.La expresión tupla puede convertirse en una tupla manipulable:</target>
        </trans-unit>
        <trans-unit id="e49abc2a9f1f1c709edab2a411a4d0eb933f0f8e" translate="yes" xml:space="preserve">
          <source>If there are two symbols declared, the first is the</source>
          <target state="translated">Si hay dos símbolos declarados,el primero es el</target>
        </trans-unit>
        <trans-unit id="3df841c41211bfc9016bcff2ddd45752571711df" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;new (&lt;/code&gt;&lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt;&lt;code&gt;)&lt;/code&gt;, then those arguments are passed to the class or struct specific &lt;a href=&quot;class#allocators&quot;&gt;allocator function&lt;/a&gt; after the size argument.</source>
          <target state="translated">Si hay una &lt;code&gt;new (&lt;/code&gt; &lt;a href=&quot;#ArgumentList&quot;&gt;&lt;i&gt;ArgumentList&lt;/i&gt;&lt;/a&gt; &lt;code&gt;)&lt;/code&gt; , esos argumentos se pasan a la &lt;a href=&quot;class#allocators&quot;&gt;funci&amp;oacute;n de asignaci&amp;oacute;n&lt;/a&gt; espec&amp;iacute;fica de clase o estructura despu&amp;eacute;s del argumento de tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="4a441171bce481c9de8d817376b233adfcdc1d3d" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the class, the constructor matching the argument list is called.</source>
          <target state="translated">Si hay un constructor definido para la clase,se llama al constructor que coincide con la lista de argumentos.</target>
        </trans-unit>
        <trans-unit id="2b9a54f4a31088d1176dc7dd4ca3c5a15fce19ea" translate="yes" xml:space="preserve">
          <source>If there is a constructor defined for the struct, the constructor matching the argument list is called.</source>
          <target state="translated">Si hay un constructor definido para la estructura,se llama al constructor que coincide con la lista de argumentos.</target>
        </trans-unit>
        <trans-unit id="6070235a5fc84c6102f81ad3d99d47f62b8d7355" translate="yes" xml:space="preserve">
          <source>If there is an &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt;, it must evaluate to either an Object or an instance of an</source>
          <target state="translated">Si hay una &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expresi&amp;oacute;n&lt;/i&gt;&lt;/a&gt; , debe evaluar un Objeto o una instancia de un</target>
        </trans-unit>
        <trans-unit id="5a13d6eff463d638a1f16cd2e1b1291d41f27d35" translate="yes" xml:space="preserve">
          <source>If there is an out postcondition (see &lt;a href=&quot;contracts&quot;&gt;Contract Programming&lt;/a&gt;), that postcondition is executed after the &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expression&lt;/i&gt;&lt;/a&gt; is evaluated and before the function actually returns.</source>
          <target state="translated">Si hay una condici&amp;oacute;n posterior fuera (ver &lt;a href=&quot;contracts&quot;&gt;Programaci&amp;oacute;n del contrato&lt;/a&gt; ), esa condici&amp;oacute;n posterior se ejecuta despu&amp;eacute;s de evaluar la &lt;a href=&quot;expression#Expression&quot;&gt;&lt;i&gt;Expresi&amp;oacute;n&lt;/i&gt;&lt;/a&gt; y antes de que la funci&amp;oacute;n realmente regrese.</target>
        </trans-unit>
        <trans-unit id="f306e547fcde96fa296d39ba4173abf9b358bd47" translate="yes" xml:space="preserve">
          <source>If there is more than one &lt;code&gt;scope&lt;/code&gt; variable going out of scope at the same point, then the destructors are called in the reverse order that the variables were constructed.</source>
          <target state="translated">Si hay m&amp;aacute;s de un &lt;code&gt;scope&lt;/code&gt; variable de ir fuera de alcance en el mismo punto, entonces los destructores se llaman en el orden inverso que las variables se construyeron.</target>
        </trans-unit>
        <trans-unit id="f9d4b8b7f08b3f6307ae69aa1e6c9c14710481c3" translate="yes" xml:space="preserve">
          <source>If there is no &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; and it is not the first</source>
          <target state="translated">Si no hay &lt;a href=&quot;expression#AssignExpression&quot;&gt;&lt;i&gt;AssignExpression&lt;/i&gt;&lt;/a&gt; y no es el primero</target>
        </trans-unit>
        <trans-unit id="b034aafdece95219928b4d5ae1779c324d51f861" translate="yes" xml:space="preserve">
          <source>If there is no constructor for a class, but there is a constructor for the base class, a default constructor is implicitly generated with the form:</source>
          <target state="translated">Si no hay un constructor para una clase,pero sí para la clase base,se genera implícitamente un constructor por defecto con la forma:</target>
        </trans-unit>
        <trans-unit id="8a089796c9cda4645dac5b38c15d592eebc4d1ab" translate="yes" xml:space="preserve">
          <source>If there is no default return expression and the predicate does not yield true with any test expression - &lt;code&gt;SwitchError&lt;/code&gt; is thrown. &lt;code&gt;SwitchError&lt;/code&gt; is also thrown if a void return expression was executed without throwing anything.</source>
          <target state="translated">Si no hay una expresi&amp;oacute;n de retorno predeterminada y el predicado no da verdadero con ninguna expresi&amp;oacute;n de prueba, se lanza &lt;code&gt;SwitchError&lt;/code&gt; . &lt;code&gt;SwitchError&lt;/code&gt; tambi&amp;eacute;n se lanza si se ejecut&amp;oacute; una expresi&amp;oacute;n de retorno nulo sin arrojar nada.</target>
        </trans-unit>
        <trans-unit id="9c729a22e9cf50dfda75e0983406587bf80017e7" translate="yes" xml:space="preserve">
          <source>If there is no documentation comment for a declaration, that declaration may not appear in the output. To ensure it does appear in the output, put an empty declaration comment for it.</source>
          <target state="translated">Si no hay ningún comentario de documentación para una declaración,es posible que esa declaración no aparezca en el resultado.Para asegurarse de que aparece en la salida,ponga un comentario de declaración vacío para ella.</target>
        </trans-unit>
        <trans-unit id="6fce9903fe99732c7b1d983701bee8c33b687b65" translate="yes" xml:space="preserve">
          <source>If there is no time zone in the string, then &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt; is used. If the time zone is &quot;Z&quot;, then &lt;code&gt;UTC&lt;/code&gt; is used. Otherwise, a &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt;&lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt;&lt;/a&gt; which corresponds to the given offset from UTC is used. To get the returned &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be a particular time zone, pass in that time zone and the &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt; to be returned will be converted to that time zone (though it will still be read in as whatever time zone is in its string).</source>
          <target state="translated">Si no hay zona horaria en la cadena, se usa &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; . Si la zona horaria es &quot;Z&quot;, se usa &lt;code&gt;UTC&lt;/code&gt; . De lo contrario, se &lt;a href=&quot;std_datetime_timezone#SimpleTimeZone&quot;&gt; &lt;code&gt;std.datetime.timezone.SimpleTimeZone&lt;/code&gt; &lt;/a&gt; un std.datetime.timezone.SimpleTimeZone que corresponde al desplazamiento dado desde UTC. Para que el &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; devuelto sea ​​una zona horaria particular, pase esa zona horaria y el &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; que se devolver&amp;aacute; se convertir&amp;aacute; a esa zona horaria (aunque todav&amp;iacute;a se leer&amp;aacute; como cualquier zona horaria en su cadena).</target>
        </trans-unit>
        <trans-unit id="ecb767820c42d2c1eeab40ca9731a8e9ce9ec854" translate="yes" xml:space="preserve">
          <source>If there is no type specialization for the parameter, the type of the parameter is set to the template argument.</source>
          <target state="translated">Si no hay una especialización de tipo para el parámetro,el tipo del parámetro se establece en el argumento de la plantilla.</target>
        </trans-unit>
        <trans-unit id="333c6091877decb710b52473531fc9677d023463" translate="yes" xml:space="preserve">
          <source>If there is only one member of an anonymous enum, the &lt;code&gt;{ }&lt;/code&gt; can be omitted. Gramatically speaking, this is an &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;AutoDeclaration&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Si solo hay un miembro de una enumeraci&amp;oacute;n an&amp;oacute;nima, se puede omitir el &lt;code&gt;{ }&lt;/code&gt; . Gramaticalmente hablando, esta es una &lt;a href=&quot;declaration#AutoDeclaration&quot;&gt;&lt;i&gt;Autodeclaraci&amp;oacute;n&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81c7998e55322be143bbc65f832d80e17d966603" translate="yes" xml:space="preserve">
          <source>If there's no handler for a particular error, it is handled by the runtime library default handler. If an error is ignored, it is because the programmer specifically added code to ignore an error, which presumably means it was intentional.</source>
          <target state="translated">Si no hay un controlador para un error en particular,se maneja por el controlador predeterminado de la biblioteca en tiempo de ejecución.Si se ignora un error,es porque el programador añadió específicamente código para ignorar un error,lo que presumiblemente significa que fue intencionado.</target>
        </trans-unit>
        <trans-unit id="1504a8955edcaca212d8f1b4743a707d2ef9fdb6" translate="yes" xml:space="preserve">
          <source>If these constraints aren't fulfilled, the function is considered incomparable and &lt;code&gt;isSame&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si no se cumplen estas restricciones, la funci&amp;oacute;n se considera incomparable e &lt;code&gt;isSame&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b28035cefdbe2f2deeefc61501ea02f89e4a353d" translate="yes" xml:space="preserve">
          <source>If they are both null, then they are equal. If one is null and the other is not, then they are not equal. If they are both non-null, then they are equal if their values are equal.</source>
          <target state="translated">Si ambos son nulos,entonces son iguales.Si uno es nulo y el otro no,entonces no son iguales.Si ambos son no nulos,entonces son iguales si sus valores son iguales.</target>
        </trans-unit>
        <trans-unit id="4662c9e57a2220461566af34d1a71bfb063d8fd6" translate="yes" xml:space="preserve">
          <source>If they compare equal, return 0 else value returned by fp.</source>
          <target state="translated">Si se comparan iguales,devuelven 0 de otro valor devuelto por fp.</target>
        </trans-unit>
        <trans-unit id="489bf198a6a75e62f83ca7fe9ee2482aa193539d" translate="yes" xml:space="preserve">
          <source>If they have range interface, formatted as input range.</source>
          <target state="translated">Si tienen interfaz de rango,formateado como rango de entrada.</target>
        </trans-unit>
        <trans-unit id="a2e48f2bb2a2bc86917d71f83c2b5a6ff9f995c9" translate="yes" xml:space="preserve">
          <source>If they have the same ptrs, return 1 else 0.</source>
          <target state="translated">Si tienen los mismos ptrs,devuelve 1 0 más.</target>
        </trans-unit>
        <trans-unit id="2bac3ec55e8f026836fad11da1a5ea396ba6c7f1" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +0100 or -0700). Note that the offset from UTC is</source>
          <target state="translated">Si esto &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 's zona horaria es &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; , a continuaci&amp;oacute;n, TZ est&amp;aacute; vac&amp;iacute;a. Si su zona horaria es &lt;code&gt;UTC&lt;/code&gt; , entonces es &quot;Z&quot;. De lo contrario, es el desplazamiento desde UTC (por ejemplo, +0100 o -0700). Tenga en cuenta que el desplazamiento desde UTC es</target>
        </trans-unit>
        <trans-unit id="2c514f7eb520c6d91b2201391b00ffde6396be0d" translate="yes" xml:space="preserve">
          <source>If this &lt;a href=&quot;#SysTime&quot;&gt;&lt;code&gt;SysTime&lt;/code&gt;&lt;/a&gt;'s time zone is &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt;&lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt;&lt;/a&gt;, then TZ is empty. If its time zone is &lt;code&gt;UTC&lt;/code&gt;, then it is &quot;Z&quot;. Otherwise, it is the offset from UTC (e.g. +01:00 or -07:00). Note that the offset from UTC is</source>
          <target state="translated">Si esto &lt;a href=&quot;#SysTime&quot;&gt; &lt;code&gt;SysTime&lt;/code&gt; &lt;/a&gt; 's zona horaria es &lt;a href=&quot;std_datetime_timezone#LocalTime&quot;&gt; &lt;code&gt;std.datetime.timezone.LocalTime&lt;/code&gt; &lt;/a&gt; , a continuaci&amp;oacute;n, TZ est&amp;aacute; vac&amp;iacute;a. Si su zona horaria es &lt;code&gt;UTC&lt;/code&gt; , entonces es &quot;Z&quot;. De lo contrario, es el desplazamiento desde UTC (por ejemplo, +01: 00 o -07: 00). Tenga en cuenta que el desplazamiento desde UTC es</target>
        </trans-unit>
        <trans-unit id="59b4585a3a599edf4de86352eceb935135d14f4b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), and that null value is not given for &lt;code&gt;nullValue&lt;/code&gt;, then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by using &lt;code&gt;T&lt;/code&gt;'s &quot;built in&quot; null value for &lt;code&gt;nullValue&lt;/code&gt;.</source>
          <target state="translated">Si este &lt;code&gt;Nullable&lt;/code&gt; envuelve un tipo que ya tiene un valor nulo (como un puntero), y ese valor nulo no se da para &lt;code&gt;nullValue&lt;/code&gt; , entonces asignar el valor nulo a este &lt;code&gt;Nullable&lt;/code&gt; no es diferente de asignar cualquier otro valor de tipo &lt;code&gt;T&lt;/code&gt; , y El c&amp;oacute;digo resultante se ver&amp;aacute; muy extra&amp;ntilde;o. Se recomienda encarecidamente que este puede evitar utilizando &lt;code&gt;T&lt;/code&gt; 's 'construido en' valor nulo para &lt;code&gt;nullValue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bacbc660925702039182b51b563933523f30696f" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Nullable&lt;/code&gt; wraps a type that already has a null value (such as a pointer), then assigning the null value to this &lt;code&gt;Nullable&lt;/code&gt; is no different than assigning any other value of type &lt;code&gt;T&lt;/code&gt;, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of &lt;code&gt;Nullable&lt;/code&gt; that takes an additional &lt;code&gt;nullValue&lt;/code&gt; template argument.</source>
          <target state="translated">Si este &lt;code&gt;Nullable&lt;/code&gt; envuelve un tipo que ya tiene un valor nulo (como un puntero), entonces asignar el valor nulo a este &lt;code&gt;Nullable&lt;/code&gt; no es diferente de asignar cualquier otro valor de tipo &lt;code&gt;T&lt;/code&gt; , y el c&amp;oacute;digo resultante se ver&amp;aacute; muy extra&amp;ntilde;o. Se recomienda encarecidamente que esto se evite utilizando en su lugar la versi&amp;oacute;n de &lt;code&gt;Nullable&lt;/code&gt; que tome un argumento de plantilla &lt;code&gt;nullValue&lt;/code&gt; adicional .</target>
        </trans-unit>
        <trans-unit id="7febe77abd33adf57e913bf0a4a63eb358541f75" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Task&lt;/code&gt; was not started yet, execute it in the current thread. If it is finished, return its result. If it is in progress, execute any other &lt;code&gt;Task&lt;/code&gt; from the &lt;code&gt;TaskPool&lt;/code&gt; instance that this &lt;code&gt;Task&lt;/code&gt; was submitted to until this one is finished. If it threw an exception, rethrow that exception. If no other tasks are available or this &lt;code&gt;Task&lt;/code&gt; was executed using &lt;code&gt;executeInNewThread&lt;/code&gt;, wait on a condition variable.</source>
          <target state="translated">Si esta &lt;code&gt;Task&lt;/code&gt; a&amp;uacute;n no se inici&amp;oacute;, ejec&amp;uacute;tela en el hilo actual. Si est&amp;aacute; terminado, devuelva su resultado. Si est&amp;aacute; en progreso, ejecute cualquier otra &lt;code&gt;Task&lt;/code&gt; desde la instancia de &lt;code&gt;TaskPool&lt;/code&gt; a la que se envi&amp;oacute; esta &lt;code&gt;Task&lt;/code&gt; hasta que finalice. Si arroj&amp;oacute; una excepci&amp;oacute;n, vuelva a lanzar esa excepci&amp;oacute;n. Si no hay otras tareas disponibles o si esta &lt;code&gt;Task&lt;/code&gt; se ejecut&amp;oacute; mediante &lt;code&gt;executeInNewThread&lt;/code&gt; , espere una variable de condici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="02c1e520b882980c80752c1365bf55b4375ba858" translate="yes" xml:space="preserve">
          <source>If this declaration is compliant with any particular standard, the description of it goes here.</source>
          <target state="translated">Si esta declaración cumple con alguna norma en particular,la descripción de la misma va aquí.</target>
        </trans-unit>
        <trans-unit id="13a2f9d3fe709668a2bc4c5dc3f8ab6e710fca1e" translate="yes" xml:space="preserve">
          <source>If this is a reference, dereference it.</source>
          <target state="translated">Si esto es una referencia,derríbela.</target>
        </trans-unit>
        <trans-unit id="4f2c995ebc62fdd08dead47122c9bc13fad7a76d" translate="yes" xml:space="preserve">
          <source>If this is a shell around another type, get that other type.</source>
          <target state="translated">Si se trata de un caparazón alrededor de otro tipo,consigue ese otro tipo.</target>
        </trans-unit>
        <trans-unit id="b5dc509f5b8b27fb2d7cf6170c77f1c20cada7e8" translate="yes" xml:space="preserve">
          <source>If this is a type of something, return that something.</source>
          <target state="translated">Si esto es un tipo de algo,devuelve ese algo.</target>
        </trans-unit>
        <trans-unit id="78983652ba5d9285bc5419929ba9f7e7d2014654" translate="yes" xml:space="preserve">
          <source>If this is a type of static array, return its base element type.</source>
          <target state="translated">Si se trata de un tipo de conjunto estático,devuelva su tipo de elemento base.</target>
        </trans-unit>
        <trans-unit id="11053146fa2d89a0863002bf2113f6a22908ad90" translate="yes" xml:space="preserve">
          <source>If this lock is not already held by the caller, the lock is acquired, then the internal counter is incremented by one.</source>
          <target state="translated">Si esta cerradura no está ya en manos de la persona que llama,la cerradura se adquiere,entonces el contador interno se incrementa en uno.</target>
        </trans-unit>
        <trans-unit id="7f2c76fc93c2cea506533b01d671704af3859af8" translate="yes" xml:space="preserve">
          <source>If this statement has code that needs to run in a finally clause at the end of the current scope, return that code in the form of a Statement.</source>
          <target state="translated">Si esta declaración tiene un código que necesita ejecutarse en una cláusula final al final del alcance actual,devuelva ese código en forma de una declaración.</target>
        </trans-unit>
        <trans-unit id="0515fd6aa93cc22acea186af17b617bb6900cccc" translate="yes" xml:space="preserve">
          <source>If this symbol is really an alias for another, return that other. If needed, semantic() is invoked due to resolve forward reference.</source>
          <target state="translated">Si este símbolo es realmente un alias para otro,devuelva ese otro.Si es necesario,se invoca semantic()para resolver la referencia de avance.</target>
        </trans-unit>
        <trans-unit id="0d671d5e8525a56282bf3d43e4b2c8ef0fff443b" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Checked&lt;/code&gt; instances are involved in a binary operation and both define &lt;code&gt;hookOpBinary&lt;/code&gt;, the left-hand side hook has priority. If both define &lt;code&gt;onOverflow&lt;/code&gt;, a compile-time error occurs.</source>
          <target state="translated">Si dos &lt;code&gt;Checked&lt;/code&gt; casos est&amp;aacute;n implicadas en una operaci&amp;oacute;n binaria y ambos definen &lt;code&gt;hookOpBinary&lt;/code&gt; , el gancho de la parte izquierda tiene prioridad. Si ambos definen &lt;code&gt;onOverflow&lt;/code&gt; , se produce un error en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="000877fa3e86af7fe8754c0a2ea9639fca32104e" translate="yes" xml:space="preserve">
          <source>If two different mixins are put in the same scope, and each define a declaration with the same name, there is an ambiguity error when the declaration is referenced:</source>
          <target state="translated">Si dos mezclas diferentes se ponen en el mismo ámbito,y cada una de ellas define una declaración con el mismo nombre,se produce un error de ambigüedad al referirse a la declaración:</target>
        </trans-unit>
        <trans-unit id="a3bad367e89a048e204fc75a01e068c90ffc4712" translate="yes" xml:space="preserve">
          <source>If two or more functions have the same match level, then</source>
          <target state="translated">Si dos o más funciones tienen el mismo nivel de coincidencia,entonces</target>
        </trans-unit>
        <trans-unit id="329ee511107dbe6e7abc063f46dd137916ba7624" translate="yes" xml:space="preserve">
          <source>If unit tests are not enabled, the implementation is not required to check the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt; for syntactic or semantic correctness. This is to reduce the compile time impact of larger unit test sections. The tokens must still be valid, and the implementation can merely count &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; tokens to find the end of the &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest&lt;/i&gt;&lt;/a&gt;'s &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt;.</source>
          <target state="translated">Si las pruebas unitarias no est&amp;aacute;n habilitadas, no es necesario que la implementaci&amp;oacute;n verifique si &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;UnitTest tiene&lt;/i&gt;&lt;/a&gt; una correcci&amp;oacute;n sint&amp;aacute;ctica o sem&amp;aacute;ntica. Esto es para reducir el impacto en el tiempo de compilaci&amp;oacute;n de secciones de prueba unitarias m&amp;aacute;s grandes. Las fichas deben ser v&amp;aacute;lidas todav&amp;iacute;a, y la puesta en pr&amp;aacute;ctica s&amp;oacute;lo se puede contar &lt;code&gt;{&lt;/code&gt; y &lt;code&gt;}&lt;/code&gt; fichas para encontrar el final de la &lt;a href=&quot;#UnitTest&quot;&gt;&lt;i&gt;unittest&lt;/i&gt;&lt;/a&gt; 's &lt;a href=&quot;statement#BlockStatement&quot;&gt;&lt;i&gt;BlockStatement&lt;/i&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9627f657eafec4f6faa68074956b9ef2912cb7d7" translate="yes" xml:space="preserve">
          <source>If variable has a const initializer, return that initializer.</source>
          <target state="translated">Si la variable tiene un inicializador constante,devuelva ese inicializador.</target>
        </trans-unit>
        <trans-unit id="efa87bbfad2d81b3124f9c28a0c2e92ac37d7e01" translate="yes" xml:space="preserve">
          <source>If variable has a constant expression initializer, get it. Otherwise, return null.</source>
          <target state="translated">Si la variable tiene un inicializador de expresión constante,consígalo.Si no,devuelve nulo.</target>
        </trans-unit>
        <trans-unit id="129f6b693e38ba5e18679007098a9df7fc61bc3f" translate="yes" xml:space="preserve">
          <source>If vector extensions are implemented, the &lt;a href=&quot;version#PredefinedVersions&quot;&gt;version identifier&lt;/a&gt;&lt;code&gt;D_SIMD&lt;/code&gt; is set.</source>
          <target state="translated">Si se implementan extensiones de vector, se establece el &lt;a href=&quot;version#PredefinedVersions&quot;&gt;identificador de versi&amp;oacute;n &lt;/a&gt; &lt;code&gt;D_SIMD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adbc7bef2337da263c5a713fbb0e840af6633adb" translate="yes" xml:space="preserve">
          <source>If we want the value of this expression, but do not want to call the destructor on it.</source>
          <target state="translated">Si queremos el valor de esta expresión,pero no queremos llamar al destructor en ella.</target>
        </trans-unit>
        <trans-unit id="ec18bd660a5b36aeac802e90948287ace69121eb" translate="yes" xml:space="preserve">
          <source>If x is 0 and n is negative, the result is the same as the result of a division by zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79988e7c16e0dced67dee802d9bdb6de78ec6132" translate="yes" xml:space="preserve">
          <source>If x is not a special value, the result is the same as &lt;code&gt;cast(int) logb(x)&lt;/code&gt;.</source>
          <target state="translated">Si x no es un valor especial, el resultado es el mismo que &lt;code&gt;cast(int) logb(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bffad47163601102b19e67fa92a8c3feda0166ec" translate="yes" xml:space="preserve">
          <source>If x is subnormal, it is treated as if it were normalized. For a positive, finite x:</source>
          <target state="translated">Si x es subnormal,se trata como si estuviera normalizada.Para una x positiva y finita:</target>
        </trans-unit>
        <trans-unit id="92c403e0084ea037260c41da9c4c7e544a7d2d08" translate="yes" xml:space="preserve">
          <source>If y &amp;gt; x, the result will be the next largest floating-point value; if y &amp;lt; x, the result will be the next smallest value. If x == y, the result is y.</source>
          <target state="translated">Si y&amp;gt; x, el resultado ser&amp;aacute; el siguiente valor de punto flotante m&amp;aacute;s grande; si y &amp;lt;x, el resultado ser&amp;aacute; el siguiente valor m&amp;aacute;s peque&amp;ntilde;o. Si x == y, el resultado es y.</target>
        </trans-unit>
        <trans-unit id="9dc7acb3598875395fe18b41fd6f909c4555485e" translate="yes" xml:space="preserve">
          <source>If y &amp;gt; x, the result will be the next largest floating-point value; if y &amp;lt; x, the result will be the next smallest value. If x == y, the result is y. If x or y is a NaN, the result is a NaN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51868f820cebc5e3c544468e6d407c4bd6b45485" translate="yes" xml:space="preserve">
          <source>If you have a small buffer you can use &lt;a href=&quot;#compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#uncompress&quot;&gt;&lt;code&gt;uncompress&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">Si tiene un b&amp;uacute;fer peque&amp;ntilde;o, puede usar &lt;a href=&quot;#compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#uncompress&quot;&gt; &lt;code&gt;uncompress&lt;/code&gt; &lt;/a&gt; directamente.</target>
        </trans-unit>
        <trans-unit id="b65e14bf08e45286eb114c69d33e8aa407bf4bbd" translate="yes" xml:space="preserve">
          <source>If you omit &lt;code&gt;Rhs&lt;/code&gt;, &lt;code&gt;isAssignable&lt;/code&gt; will check identity assignable of &lt;code&gt;Lhs&lt;/code&gt;.</source>
          <target state="translated">Si omite &lt;code&gt;Rhs&lt;/code&gt; , &lt;code&gt;isAssignable&lt;/code&gt; verificar&amp;aacute; la identidad asignable de &lt;code&gt;Lhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14961e1fccbf1736d47a52df390592d594e9109a" translate="yes" xml:space="preserve">
          <source>If you select &lt;code&gt;precise&lt;/code&gt; as the garbage collector via the options above, type information will be used to identify actual or possible pointers or references within heap allocated data objects. Non-pointer data will not be interpreted as a reference to other memory as a &quot;false pointer&quot;. The collector has to make pessimistic assumptions if a memory slot can contain both a pointer or an integer value, it will still be scanned (e.g. in a &lt;code&gt;union&lt;/code&gt;).</source>
          <target state="translated">Si selecciona con &lt;code&gt;precise&lt;/code&gt; como el recolector de basura a trav&amp;eacute;s de las opciones anteriores, la informaci&amp;oacute;n de tipo se utilizar&amp;aacute; para identificar punteros o referencias reales o posibles dentro de los objetos de datos asignados en el mont&amp;oacute;n. Los datos sin puntero no se interpretar&amp;aacute;n como una referencia a otra memoria como un &quot;puntero falso&quot;. El recopilador tiene que hacer suposiciones pesimistas si una ranura de memoria puede contener tanto un puntero como un valor entero, a&amp;uacute;n se escanear&amp;aacute; (por ejemplo, en una &lt;code&gt;union&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cbade680aa6ce4b2eee3b550013b504b2359a76c" translate="yes" xml:space="preserve">
          <source>If you use the GC memory functions from &lt;code&gt;core.memory&lt;/code&gt;, and plan to use it for data with a mixture of pointers and non-pointer data you should pass the TypeInfo of your allocated struct, class or type as the optional parameter. The default &lt;code&gt;null&lt;/code&gt; is interpreted as memory that might contain pointers everywhere.</source>
          <target state="translated">Si usa las funciones de memoria del GC de &lt;code&gt;core.memory&lt;/code&gt; y planea usarlo para datos con una combinaci&amp;oacute;n de punteros y datos sin puntero, debe pasar el TypeInfo de su estructura, clase o tipo asignado como par&amp;aacute;metro opcional. El valor &lt;code&gt;null&lt;/code&gt; predeterminado se interpreta como memoria que puede contener punteros en todas partes.</target>
        </trans-unit>
        <trans-unit id="14f517123cdd1f4b658824c0835eb8cdf537909f" translate="yes" xml:space="preserve">
          <source>If you want to get NaN as a result if a NaN is present in the range, you can use &lt;a href=&quot;std.algorithm_iteration#fold&quot;&gt;&lt;code&gt;std.algorithm.iteration.fold&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_math#isNaN&quot;&gt;&lt;code&gt;std.math.isNaN&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8308d29073b832847e261fe8f0df371b23a239" translate="yes" xml:space="preserve">
          <source>If you want to ignore NaNs, you can use &lt;a href=&quot;std_algorithm_iteration#filter&quot;&gt;&lt;code&gt;std.algorithm.iteration.filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;std_math#isNaN&quot;&gt;&lt;code&gt;std.math.isNaN&lt;/code&gt;&lt;/a&gt; to remove them, before applying minElement. Add a suitable seed, to avoid error messages if all elements are NaNs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a53d6760e4f33109326a6a1af782ed05797935" translate="yes" xml:space="preserve">
          <source>If:</source>
          <target state="translated">If:</target>
        </trans-unit>
        <trans-unit id="b2403005179997fdecfad41d075986e0dccac0e9" translate="yes" xml:space="preserve">
          <source>IfStatement</source>
          <target state="translated">IfStatement</target>
        </trans-unit>
        <trans-unit id="859704f6d767666630d7b805196cab9e15bc787d" translate="yes" xml:space="preserve">
          <source>IgnoreXXXX</source>
          <target state="translated">IgnoreXXXX</target>
        </trans-unit>
        <trans-unit id="78eb97c1d35a57cc7692fed2d6ffb3818790b0e0" translate="yes" xml:space="preserve">
          <source>Ignored mismatches are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5ba167a98858b40c030856aa4aacb94b020392" translate="yes" xml:space="preserve">
          <source>Ignores C-style / D-style variadic arguments.</source>
          <target state="translated">Ignora los argumentos variados de estilo C y D.</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="ed701420e7f5e55b19ea82ee452968a59b8615ea" translate="yes" xml:space="preserve">
          <source>Images have the same form as reference or inline links, but add an exclamation point &lt;code&gt;!&lt;/code&gt; before the initial square bracket. What would be the link text in a normal link is used as the image's alt text.</source>
          <target state="translated">Las im&amp;aacute;genes tienen la misma forma que los enlaces de referencia o en l&amp;iacute;nea, &amp;iexcl;pero agregue un signo de exclamaci&amp;oacute;n &lt;code&gt;!&lt;/code&gt; antes del corchete inicial. Lo que ser&amp;iacute;a el texto del enlace en un enlace normal se usa como texto alternativo de la imagen.</target>
        </trans-unit>
        <trans-unit id="da8a47e84bd95dd590801199a512c81712152ddc" translate="yes" xml:space="preserve">
          <source>Immediately after the range argument, an optional work unit size argument may be provided. Work units as used by &lt;code&gt;amap&lt;/code&gt; are identical to those defined for parallel foreach. If no work unit size is provided, the default work unit size is used.</source>
          <target state="translated">Inmediatamente despu&amp;eacute;s del argumento de rango, se puede proporcionar un argumento de tama&amp;ntilde;o de unidad de trabajo opcional. Las unidades de trabajo utilizadas por &lt;code&gt;amap&lt;/code&gt; son id&amp;eacute;nticas a las definidas para foreach paralelo. Si no se proporciona el tama&amp;ntilde;o de la unidad de trabajo, se utiliza el tama&amp;ntilde;o de la unidad de trabajo predeterminado.</target>
        </trans-unit>
        <trans-unit id="79fa62caeafe3bd4c17315583aef1c8a23c5d46e" translate="yes" xml:space="preserve">
          <source>Immediately drop any connections and release socket resources. The &lt;code&gt;Socket&lt;/code&gt; object is no longer usable after &lt;code&gt;close&lt;/code&gt;. Calling &lt;code&gt;shutdown&lt;/code&gt; before &lt;code&gt;close&lt;/code&gt; is recommended for connection-oriented sockets.</source>
          <target state="translated">Inmediatamente descarte cualquier conexi&amp;oacute;n y libere recursos de socket. El objeto &lt;code&gt;Socket&lt;/code&gt; ya no se puede usar despu&amp;eacute;s del &lt;code&gt;close&lt;/code&gt; . Se recomienda llamar al &lt;code&gt;shutdown&lt;/code&gt; antes del &lt;code&gt;close&lt;/code&gt; para los z&amp;oacute;calos orientados a la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1473effc3e4965950f77d9acee523d95bdbf4b42" translate="yes" xml:space="preserve">
          <source>Immutability is transitive, meaning it applies to anything that can be referenced from the immutable type:</source>
          <target state="translated">La inmutabilidad es transitiva,lo que significa que se aplica a cualquier cosa que pueda ser referenciada del tipo inmutable:</target>
        </trans-unit>
        <trans-unit id="a3901c3fc3cbd4dda7d4b5cdbdfb146ab629c087" translate="yes" xml:space="preserve">
          <source>Immutable Member Functions</source>
          <target state="translated">Funciones del miembro inamovible</target>
        </trans-unit>
        <trans-unit id="31b83cfa7707372a1c66b40c2bffbc19a9e85eb7" translate="yes" xml:space="preserve">
          <source>Immutable Storage Class</source>
          <target state="translated">Clase de almacenamiento inmutable</target>
        </trans-unit>
        <trans-unit id="bad427b56d48a9c0418ac178e3b7e5501dbeffb2" translate="yes" xml:space="preserve">
          <source>Immutable Type</source>
          <target state="translated">Tipo Inmutable</target>
        </trans-unit>
        <trans-unit id="7a41b36410af31e02780ae8ef8f795b4c7e5c218" translate="yes" xml:space="preserve">
          <source>Immutable associative arrays are often desirable, but sometimes initialization must be done at runtime. This can be achieved with a constructor (static constructor depending on scope), a buffer associative array and &lt;code&gt;assumeUnique&lt;/code&gt;:</source>
          <target state="translated">Las matrices asociativas inmutables a menudo son deseables, pero a veces la inicializaci&amp;oacute;n debe hacerse en tiempo de ejecuci&amp;oacute;n. Esto se puede lograr con un constructor (constructor est&amp;aacute;tico dependiendo del alcance), una matriz asociativa de b&amp;uacute;fer y &lt;code&gt;assumeUnique&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1060492cd68308e42ab0d863274ead4d94e73c72" translate="yes" xml:space="preserve">
          <source>Immutable declarations can appear as lvalues, i.e. they can have their address taken, and occupy storage.</source>
          <target state="translated">Las declaraciones inamovibles pueden aparecer como valores,es decir,pueden tener su dirección tomada,y ocupar el almacenamiento.</target>
        </trans-unit>
        <trans-unit id="97deddbfb05296e5d5f6c89e8255f2cf73fed0f1" translate="yes" xml:space="preserve">
          <source>Immutable member functions are guaranteed that the object and anything referred to by the &lt;code&gt;this&lt;/code&gt; reference is immutable. They are declared as:</source>
          <target state="translated">Las funciones miembro inmutables tienen garantizado que el objeto y cualquier cosa a que se refiera &lt;code&gt;this&lt;/code&gt; referencia es inmutable. Se declaran como:</target>
        </trans-unit>
        <trans-unit id="fab70056c0a3ce1186e48366f6111f2b7210dc49" translate="yes" xml:space="preserve">
          <source>Immutable memory locations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca47511da5cd25a571e0550ee9181f060e3ad8e" translate="yes" xml:space="preserve">
          <source>Immutable used as a storage class is equivalent to using immutable as a type qualifier for the entire type of a declaration:</source>
          <target state="translated">El uso de inmutable como clase de almacenamiento equivale al uso de inmutable como calificador de tipo para todo el tipo de declaración:</target>
        </trans-unit>
        <trans-unit id="8cc79f379fb076727af30671cff8e81a7a78ac8f" translate="yes" xml:space="preserve">
          <source>Imperial Aramaic</source>
          <target state="translated">Arameo imperial</target>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="015f00e67a839cb58bb4f25641353bc270b1dc50" translate="yes" xml:space="preserve">
          <source>Impl* &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt;(const TypeInfo_AssociativeArray ti, void[] keys, void[] vals);</source>
          <target state="translated">&lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;Impl&lt;/strong&gt; * &lt;strong id=&quot;_d_assocarrayliteralTX&quot;&gt;_d_assocarrayliteralTX&lt;/strong&gt; (const TypeInfo_AssociativeArray ti, void [] keys, void [] vals);</target>
        </trans-unit>
        <trans-unit id="00b783520a8a2fbc5645a580ba36a3a286254053" translate="yes" xml:space="preserve">
          <source>Implementation Details</source>
          <target state="translated">Detalles de la implementación</target>
        </trans-unit>
        <trans-unit id="4bd31434dd702d78584ad36682fd4ce02cbe35f9" translate="yes" xml:space="preserve">
          <source>Implementation helpers</source>
          <target state="translated">Ayudantes de ejecución</target>
        </trans-unit>
        <trans-unit id="cdc8095e33689a7350a694bb991dc5449ed4cc80" translate="yes" xml:space="preserve">
          <source>Implementation note: Many vector operations are expected to take advantage of any vector math instructions available on the target computer.</source>
          <target state="translated">Nota de aplicación:Se espera que muchas operaciones de vectores aprovechen cualquier instrucción matemática de vectores disponible en la computadora de destino.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
