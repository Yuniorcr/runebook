<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="ec51423103ee76d239e2db02b64cd5e5d54bd6dd" translate="yes" xml:space="preserve">
          <source>Suppose you call a function like this:</source>
          <target state="translated">Supongamos que llamas a una función como esta:</target>
        </trans-unit>
        <trans-unit id="7e31f28cfa61c430f0678908e4c1e7dab7ebb3a5" translate="yes" xml:space="preserve">
          <source>Suppose you want to do something a bit more complicated and use the name of a file in the variable &lt;code&gt;file&lt;/code&gt; as an argument to a command. You can use &lt;code&gt;$&lt;/code&gt; for interpolation much as you would in a string literal (see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Strings&lt;/a&gt;):</source>
          <target state="translated">Suponga que quiere hacer algo un poco m&amp;aacute;s complicado y usar el nombre de un archivo en el &lt;code&gt;file&lt;/code&gt; variables como argumento para un comando. Puede usar &lt;code&gt;$&lt;/code&gt; para la interpolaci&amp;oacute;n como lo har&amp;iacute;a en un literal de cadena (consulte &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Cadenas&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="65c84912a9e97ab9bad5206974c59d357a999187" translate="yes" xml:space="preserve">
          <source>Suppose you want to do something a bit more complicated and use the name of a file in the variable &lt;code&gt;file&lt;/code&gt; as an argument to a command. You can use &lt;code&gt;$&lt;/code&gt; for interpolation much as you would in a string literal (see &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/ast/#Strings&quot;&gt;Strings&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a051e98d8d71e37b46dbe98d45c2cc9c61d69cca" translate="yes" xml:space="preserve">
          <source>Suppose you were willing to allocate a temporary for the computation (which would eliminate most of the point of making &lt;code&gt;*=&lt;/code&gt; work in-place); if you took advantage of the mutability of &lt;code&gt;x&lt;/code&gt;, then this function would behave differently for mutable vs. immutable inputs. In particular, for immutable &lt;code&gt;x&lt;/code&gt;, after the call you'd have (in general) &lt;code&gt;y != x&lt;/code&gt;, but for mutable &lt;code&gt;x&lt;/code&gt; you'd have &lt;code&gt;y == x&lt;/code&gt;.</source>
          <target state="translated">Suponga que est&amp;aacute; dispuesto a asignar un temporal para el c&amp;aacute;lculo (lo que eliminar&amp;iacute;a la mayor parte del punto de hacer &lt;code&gt;*=&lt;/code&gt; trabajar en el lugar); si aprovechara la mutabilidad de &lt;code&gt;x&lt;/code&gt; , entonces esta funci&amp;oacute;n se comportar&amp;iacute;a de manera diferente para entradas mutables e inmutables. En particular, para &lt;code&gt;x&lt;/code&gt; inmutable , despu&amp;eacute;s de la llamada tendr&amp;iacute;as (en general) &lt;code&gt;y != x&lt;/code&gt; , pero para &lt;code&gt;x&lt;/code&gt; mutable tendr&amp;iacute;as &lt;code&gt;y == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ab646baedc9dd22f188651743d4f15248da82d7" translate="yes" xml:space="preserve">
          <source>Surface Integral</source>
          <target state="translated">Integral de la superficie</target>
        </trans-unit>
        <trans-unit id="17daa74b4ef9134312485788d9f1641a90336c0f" translate="yes" xml:space="preserve">
          <source>Surfer</source>
          <target state="translated">Surfer</target>
        </trans-unit>
        <trans-unit id="c8c7bd468d1aa59989cc45f0885429f1cf6ed2c3" translate="yes" xml:space="preserve">
          <source>Surround text that should be displayed as mathematics using $\LaTeX$ syntax with double backticks, &lt;code&gt;``&lt;/code&gt; .</source>
          <target state="translated">Texto envolvente que debe mostrarse como matem&amp;aacute;tico usando la sintaxis $ \ LaTeX $ con comillas invertidas dobles, &lt;code&gt;``&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92a7b6e5715227886b18e3f8f91b9c36dfc5369e" translate="yes" xml:space="preserve">
          <source>Surround text that should be displayed exactly as written with single backticks, &lt;code&gt;`&lt;/code&gt; .</source>
          <target state="translated">Texto envolvente que debe mostrarse exactamente como est&amp;aacute; escrito con comillas simples, &lt;code&gt;`&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83bffe5f5bc6bf97e1966b45cd2db4c1bcc58652" translate="yes" xml:space="preserve">
          <source>Surround words with one asterisk, &lt;code&gt;*&lt;/code&gt;, to display the enclosed text in italics.</source>
          <target state="translated">Rodee las palabras con un asterisco, &lt;code&gt;*&lt;/code&gt; , para mostrar el texto adjunto en cursiva.</target>
        </trans-unit>
        <trans-unit id="3a1145c55802eb89506200bd2ff9a16655c333b8" translate="yes" xml:space="preserve">
          <source>Surround words with two asterisks, &lt;code&gt;**&lt;/code&gt;, to display the enclosed text in boldface.</source>
          <target state="translated">Rodee las palabras con dos asteriscos, &lt;code&gt;**&lt;/code&gt; , para mostrar el texto adjunto en negrita.</target>
        </trans-unit>
        <trans-unit id="25e2d663550b8401fc89f3e8e446533086519e41" translate="yes" xml:space="preserve">
          <source>Sushi</source>
          <target state="translated">Sushi</target>
        </trans-unit>
        <trans-unit id="4b69a79697ed3f157a8f14b72eb302695d487ae6" translate="yes" xml:space="preserve">
          <source>Suspends execution for &lt;code&gt;s&lt;/code&gt; seconds. This function does not yield to Julia's scheduler and therefore blocks the Julia thread that it is running on for the duration of the sleep time.</source>
          <target state="translated">Suspende la ejecuci&amp;oacute;n durante &lt;code&gt;s&lt;/code&gt; segundos. Esta funci&amp;oacute;n no cede al programador de Julia y, por lo tanto, bloquea el subproceso de Julia en el que se est&amp;aacute; ejecutando durante el tiempo de suspensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="973888c30a491df5bbae163d9bc214c808d088f6" translate="yes" xml:space="preserve">
          <source>Suspension Railway</source>
          <target state="translated">Ferrocarril de suspensión</target>
        </trans-unit>
        <trans-unit id="71d18f43d49f2f47456648385efbfe0cb4d0c149" translate="yes" xml:space="preserve">
          <source>Swimmer</source>
          <target state="translated">Swimmer</target>
        </trans-unit>
        <trans-unit id="3e44c920427e845df4958295eb8c3045b55fcfd5" translate="yes" xml:space="preserve">
          <source>Switch</source>
          <target state="translated">Switch</target>
        </trans-unit>
        <trans-unit id="a4abe2e6561ee4e0b3b06b8ee33d70d04583aff2" translate="yes" xml:space="preserve">
          <source>Switch to the given task. The first time a task is switched to, the task's function is called with no arguments. On subsequent switches, &lt;code&gt;arg&lt;/code&gt; is returned from the task's last call to &lt;code&gt;yieldto&lt;/code&gt;. This is a low-level call that only switches tasks, not considering states or scheduling in any way. Its use is discouraged.</source>
          <target state="translated">Cambie a la tarea dada. La primera vez que se cambia a una tarea, se llama a la funci&amp;oacute;n de la tarea sin argumentos. En los cambios posteriores, se devuelve &lt;code&gt;arg&lt;/code&gt; de la &amp;uacute;ltima llamada de la tarea a &lt;code&gt;yieldto&lt;/code&gt; . Esta es una llamada de bajo nivel que solo cambia tareas, sin considerar estados o programaci&amp;oacute;n de ninguna manera. Se desaconseja su uso.</target>
        </trans-unit>
        <trans-unit id="8347671d999d16381b5c0feb325df8120cc6f75d" translate="yes" xml:space="preserve">
          <source>Switch to the scheduler to allow another scheduled task to run. A task that calls this function is still runnable, and will be restarted immediately if there are no other runnable tasks.</source>
          <target state="translated">Cambie al programador para permitir que se ejecute otra tarea programada.Una tarea que llama a esta función sigue siendo ejecutable,y se reiniciará inmediatamente si no hay otras tareas ejecutables.</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="1b2b779caa2c156291622711d5449bc4e0c50caf" translate="yes" xml:space="preserve">
          <source>Symbols do not belong to any package, and do not contain any values &lt;em&gt;per se&lt;/em&gt;. &lt;code&gt;M.var&lt;/code&gt; evaluates the symbol &lt;code&gt;var&lt;/code&gt; in the module &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac5aec6d1effd8a82fbef4c4c88712086df0e89" translate="yes" xml:space="preserve">
          <source>Symmetric matrix</source>
          <target state="translated">Matriz simétrica</target>
        </trans-unit>
        <trans-unit id="3f0921e5bff6794f52edd645b52ae45f6f732f4a" translate="yes" xml:space="preserve">
          <source>Symmetric real tridiagonal</source>
          <target state="translated">Tridiagonal real simétrica</target>
        </trans-unit>
        <trans-unit id="ca10a61f0da269816a5c9d408bb8aa1f417f179d" translate="yes" xml:space="preserve">
          <source>Symmetric tridiagonal matrix</source>
          <target state="translated">Matriz tridimensional simétrica</target>
        </trans-unit>
        <trans-unit id="cbcf7ae51d210c4ce6c53f74b6ecb4c2b26819b4" translate="yes" xml:space="preserve">
          <source>Synchronization</source>
          <target state="translated">Synchronization</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="df02dad62c7357a982f0b8b91e3712d365096846" translate="yes" xml:space="preserve">
          <source>Syntax / Keyword</source>
          <target state="translated">Sintaxis/Palabra clave</target>
        </trans-unit>
        <trans-unit id="dd6effb9dc1e87cae1ff2fb15208ededa0c5b6cc" translate="yes" xml:space="preserve">
          <source>Syntax Conflicts</source>
          <target state="translated">Conflictos de sintaxis</target>
        </trans-unit>
        <trans-unit id="3655179938bda8b64c156fa5a6ab6ed93c568007" translate="yes" xml:space="preserve">
          <source>Syntax Guide</source>
          <target state="translated">Guía de sintaxis</target>
        </trans-unit>
        <trans-unit id="49b8645cb3d5d028f81e3ff546436dea1e75203f" translate="yes" xml:space="preserve">
          <source>Syringe</source>
          <target state="translated">Syringe</target>
        </trans-unit>
        <trans-unit id="eea5f6535cf1464538bf913c29432e06b44c8a00" translate="yes" xml:space="preserve">
          <source>Sys</source>
          <target state="translated">Sys</target>
        </trans-unit>
        <trans-unit id="5b15446e1a2df96945de25b580d31fd7781e5677" translate="yes" xml:space="preserve">
          <source>Sys.ARCH</source>
          <target state="translated">Sys.ARCH</target>
        </trans-unit>
        <trans-unit id="ea549709c8d36e5b671637c93ae8042e833fb6c7" translate="yes" xml:space="preserve">
          <source>Sys.BINDIR</source>
          <target state="translated">Sys.BINDIR</target>
        </trans-unit>
        <trans-unit id="cbd1d907a3f81eed0265ef8833d42ad375912b5f" translate="yes" xml:space="preserve">
          <source>Sys.CPU_THREADS</source>
          <target state="translated">Sys.CPU_THREADS</target>
        </trans-unit>
        <trans-unit id="15b4b8619f588da9848eb54f4bf8375e81de8ba4" translate="yes" xml:space="preserve">
          <source>Sys.KERNEL</source>
          <target state="translated">Sys.KERNEL</target>
        </trans-unit>
        <trans-unit id="ddf91742e9bfe2e15760cc0904b02e0241b87da2" translate="yes" xml:space="preserve">
          <source>Sys.MACHINE</source>
          <target state="translated">Sys.MACHINE</target>
        </trans-unit>
        <trans-unit id="796735660de3fec9cc6a7ccbfddbef088428a267" translate="yes" xml:space="preserve">
          <source>Sys.WORD_SIZE</source>
          <target state="translated">Sys.WORD_SIZE</target>
        </trans-unit>
        <trans-unit id="375901ce98140a171ed6632260dde67cf6259438" translate="yes" xml:space="preserve">
          <source>Sys.free_memory()</source>
          <target state="translated">Sys.free_memory()</target>
        </trans-unit>
        <trans-unit id="7fa56fc341a0cdcf2e078d2b91be8fdea785a838" translate="yes" xml:space="preserve">
          <source>Sys.get_process_title()</source>
          <target state="translated">Sys.get_process_title()</target>
        </trans-unit>
        <trans-unit id="39dc0ce5e6f1d0c9e651677c3e12e7f1757cbcba" translate="yes" xml:space="preserve">
          <source>Sys.isapple()</source>
          <target state="translated">Sys.isapple()</target>
        </trans-unit>
        <trans-unit id="03119912a2c03ee07527224e883b39a922bdadc4" translate="yes" xml:space="preserve">
          <source>Sys.isbsd()</source>
          <target state="translated">Sys.isbsd()</target>
        </trans-unit>
        <trans-unit id="22a24965517e80c9d1727c9f7fc5d84adf3ce605" translate="yes" xml:space="preserve">
          <source>Sys.isdragonfly()</source>
          <target state="translated">Sys.isdragonfly()</target>
        </trans-unit>
        <trans-unit id="27a4af1930d284707ac8426c9dfb34043828ecd1" translate="yes" xml:space="preserve">
          <source>Sys.isfreebsd()</source>
          <target state="translated">Sys.isfreebsd()</target>
        </trans-unit>
        <trans-unit id="a2965d91481a0bbc8f3ee0bd36632e37c4e173eb" translate="yes" xml:space="preserve">
          <source>Sys.islinux()</source>
          <target state="translated">Sys.islinux()</target>
        </trans-unit>
        <trans-unit id="a0e775e7d914f8aac6d1a328e138a3a3c3c2a11d" translate="yes" xml:space="preserve">
          <source>Sys.isnetbsd()</source>
          <target state="translated">Sys.isnetbsd()</target>
        </trans-unit>
        <trans-unit id="a4cd0ca152f09ceeda470eb8f4454f9c05f7de4e" translate="yes" xml:space="preserve">
          <source>Sys.isopenbsd()</source>
          <target state="translated">Sys.isopenbsd()</target>
        </trans-unit>
        <trans-unit id="44d1250110223056dac1d302e658cb39d616dc4b" translate="yes" xml:space="preserve">
          <source>Sys.isunix()</source>
          <target state="translated">Sys.isunix()</target>
        </trans-unit>
        <trans-unit id="1d8055070eda84bf6013fc0792786c9e9266c1f4" translate="yes" xml:space="preserve">
          <source>Sys.iswindows()</source>
          <target state="translated">Sys.iswindows()</target>
        </trans-unit>
        <trans-unit id="029e67926c34e0658c17d66ac464b0e6d925adb6" translate="yes" xml:space="preserve">
          <source>Sys.set_process_title()</source>
          <target state="translated">Sys.set_process_title()</target>
        </trans-unit>
        <trans-unit id="c06dd39312f9e01848f09c4e56f06f3a5d14a622" translate="yes" xml:space="preserve">
          <source>Sys.total_memory()</source>
          <target state="translated">Sys.total_memory()</target>
        </trans-unit>
        <trans-unit id="235f7cf2ef4a9196211511f0a01512f001e55ff9" translate="yes" xml:space="preserve">
          <source>Sys.windows_version()</source>
          <target state="translated">Sys.windows_version()</target>
        </trans-unit>
        <trans-unit id="bc0792d8dc81e8aa30b987246a5ce97c40cd6833" translate="yes" xml:space="preserve">
          <source>System</source>
          <target state="translated">System</target>
        </trans-unit>
        <trans-unit id="47e68638ef3b94e3c34563e1179f97e827fb9bec" translate="yes" xml:space="preserve">
          <source>SystemError</source>
          <target state="translated">SystemError</target>
        </trans-unit>
        <trans-unit id="14398aaa3709921f04833f4eb9d880847302976e" translate="yes" xml:space="preserve">
          <source>T-Shirt</source>
          <target state="translated">T-Shirt</target>
        </trans-unit>
        <trans-unit id="5e3f230d5d2963950b06367aa593d1b64588e341" translate="yes" xml:space="preserve">
          <source>TR</source>
          <target state="translated">TR</target>
        </trans-unit>
        <trans-unit id="eb8b89e8c468a2f2b0bf3f62ac7419a0270f3b4b" translate="yes" xml:space="preserve">
          <source>Tab completion</source>
          <target state="translated">Completar la pestaña</target>
        </trans-unit>
        <trans-unit id="62b315a7c84a121cc5728c13d37733f905c0d329" translate="yes" xml:space="preserve">
          <source>Tab completion can also help completing fields:</source>
          <target state="translated">Completar las pestañas también puede ayudar a completar los campos:</target>
        </trans-unit>
        <trans-unit id="96d8de29ef10f4e4538a1cb749404c8f188732bc" translate="yes" xml:space="preserve">
          <source>Tab completion can help with investigation of the available methods matching the input arguments:</source>
          <target state="translated">La finalización de las pestañas puede ayudar en la investigación de los métodos disponibles que coinciden con los argumentos de entrada:</target>
        </trans-unit>
        <trans-unit id="ec37058ab8c801341a2164838991c7b36baf606c" translate="yes" xml:space="preserve">
          <source>Tab completion sequence(s)</source>
          <target state="translated">Secuencia(s)de finalización de pestañas</target>
        </trans-unit>
        <trans-unit id="193daf137ed8b89de36d47c3df5fd8f66c0e1d14" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="translated">Tables</target>
        </trans-unit>
        <trans-unit id="f6142c5e7f7b37b008f0934abccaace0a6f434f0" translate="yes" xml:space="preserve">
          <source>Take a raw file descriptor wrap it in a Julia-aware IO type, and take ownership of the fd handle. Call &lt;code&gt;open(Libc.dup(fd))&lt;/code&gt; to avoid the ownership capture of the original handle.</source>
          <target state="translated">Tome un descriptor de archivo sin formato, envu&amp;eacute;lvalo en un tipo de E / S compatible con Julia y tome posesi&amp;oacute;n del identificador fd. Llame a &lt;code&gt;open(Libc.dup(fd))&lt;/code&gt; para evitar la captura de propiedad del identificador original.</target>
        </trans-unit>
        <trans-unit id="028c707e8657f2ad234b365e0bd3fd169e21c888" translate="yes" xml:space="preserve">
          <source>Take a snapshot of the current state of the repository &lt;code&gt;repo&lt;/code&gt;, storing the current HEAD, index, and any uncommitted work. The output &lt;code&gt;State&lt;/code&gt; can be used later during a call to &lt;a href=&quot;#LibGit2.restore&quot;&gt;&lt;code&gt;restore&lt;/code&gt;&lt;/a&gt; to return the repository to the snapshotted state.</source>
          <target state="translated">Tomar una instant&amp;aacute;nea del estado actual del repositorio &lt;code&gt;repo&lt;/code&gt; , el almacenamiento de la CABEZA actual, &amp;iacute;ndice, y cualquier trabajo comprometido. El &lt;code&gt;State&lt;/code&gt; salida se puede utilizar m&amp;aacute;s tarde durante una llamada para &lt;a href=&quot;#LibGit2.restore&quot;&gt; &lt;code&gt;restore&lt;/code&gt; &lt;/a&gt; y devolver el repositorio al estado de instant&amp;aacute;nea.</target>
        </trans-unit>
        <trans-unit id="417b76383d90f18e7280ea7c153cd0ec7f4143f1" translate="yes" xml:space="preserve">
          <source>Take the expression &lt;code&gt;x&lt;/code&gt; and return an equivalent expression with all macros removed (expanded) for executing in module &lt;code&gt;m&lt;/code&gt;. The &lt;code&gt;recursive&lt;/code&gt; keyword controls whether deeper levels of nested macros are also expanded. This is demonstrated in the example below:</source>
          <target state="translated">Tome la expresi&amp;oacute;n &lt;code&gt;x&lt;/code&gt; y devuelva una expresi&amp;oacute;n equivalente con todas las macros eliminadas (expandidas) para ejecutar en el m&amp;oacute;dulo &lt;code&gt;m&lt;/code&gt; . La palabra clave &lt;code&gt;recursive&lt;/code&gt; controla si tambi&amp;eacute;n se expanden niveles m&amp;aacute;s profundos de macros anidadas. Esto se demuestra en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="d28f2931bbad698b16249ed36b449a3b14fb39b6" translate="yes" xml:space="preserve">
          <source>Take the given &lt;code&gt;Date&lt;/code&gt; and return the number of days since the rounding epoch (&lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;) as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tome la &lt;code&gt;Date&lt;/code&gt; dada y devuelva el n&amp;uacute;mero de d&amp;iacute;as desde la &amp;eacute;poca de redondeo ( &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; ) como un &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c44da3302da9152e79b3157eb63204c185052ad" translate="yes" xml:space="preserve">
          <source>Take the given &lt;code&gt;DateTime&lt;/code&gt; and return the number of Julian calendar days since the julian epoch &lt;code&gt;-4713-11-24T12:00:00&lt;/code&gt; as a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tome el &lt;code&gt;DateTime&lt;/code&gt; dado y devuelva el n&amp;uacute;mero de d&amp;iacute;as del calendario juliano desde la &amp;eacute;poca juliana &lt;code&gt;-4713-11-24T12:00:00&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ce37312d945672925e211e70623bf1d7a6b2f2" translate="yes" xml:space="preserve">
          <source>Take the given &lt;code&gt;DateTime&lt;/code&gt; and return the number of milliseconds since the rounding epoch (&lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;) as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tome el &lt;code&gt;DateTime&lt;/code&gt; dado y devuelva el n&amp;uacute;mero de milisegundos desde la &amp;eacute;poca de redondeo ( &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; ) como un &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b90d8b1442620b2460ac29cdc4af299f9431cbe7" translate="yes" xml:space="preserve">
          <source>Take the given &lt;code&gt;DateTime&lt;/code&gt; and return the number of seconds since the unix epoch &lt;code&gt;1970-01-01T00:00:00&lt;/code&gt; as a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Tome el &lt;code&gt;DateTime&lt;/code&gt; dado y devuelva el n&amp;uacute;mero de segundos desde la &amp;eacute;poca de Unix &lt;code&gt;1970-01-01T00:00:00&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52e8457357f9105fd0f6a09d1e22e555734202d0" translate="yes" xml:space="preserve">
          <source>Take the inverse of &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;m&lt;/code&gt;: &lt;code&gt;y&lt;/code&gt; such that $x y = 1 \pmod m$, with $div(x,y) = 0$. This is undefined for $m = 0$, or if $gcd(x,m) \neq 1$.</source>
          <target state="translated">Tome la inversa de &lt;code&gt;x&lt;/code&gt; m&amp;oacute;dulo &lt;code&gt;m&lt;/code&gt; : &lt;code&gt;y&lt;/code&gt; tal que $ xy = 1 \ pmod m $, con $ div (x, y) = 0 $. Esto no est&amp;aacute; definido para $ m = 0 $, o si $ gcd (x, m) \ neq 1 $.</target>
        </trans-unit>
        <trans-unit id="ac65d0f278e58fa9f0d56cc7d33997e42273d3be" translate="yes" xml:space="preserve">
          <source>Take the number of Julian calendar days since epoch &lt;code&gt;-4713-11-24T12:00:00&lt;/code&gt; and return the corresponding &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">Tome el n&amp;uacute;mero de d&amp;iacute;as del calendario juliano desde epoch &lt;code&gt;-4713-11-24T12:00:00&lt;/code&gt; y devuelva el &lt;code&gt;DateTime&lt;/code&gt; correspondiente .</target>
        </trans-unit>
        <trans-unit id="651f47947b58a46afe82a3eb965d1ee5bbbb30a9" translate="yes" xml:space="preserve">
          <source>Take the number of Rata Die days since epoch &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; and return the corresponding &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">Tome el n&amp;uacute;mero de d&amp;iacute;as Rata Die desde la &amp;eacute;poca &lt;code&gt;0000-12-31T00:00:00&lt;/code&gt; y devuelva el &lt;code&gt;DateTime&lt;/code&gt; correspondiente .</target>
        </trans-unit>
        <trans-unit id="c4192143b648e1063359b65a375c87d5eaac8a3f" translate="yes" xml:space="preserve">
          <source>Take the number of days since the rounding epoch (&lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;) and return the corresponding &lt;code&gt;Date&lt;/code&gt;.</source>
          <target state="translated">Tome el n&amp;uacute;mero de d&amp;iacute;as desde la &amp;eacute;poca de redondeo ( &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; ) y devuelva la &lt;code&gt;Date&lt;/code&gt; correspondiente .</target>
        </trans-unit>
        <trans-unit id="8ff629efbee246780761d817ac2092dd33354876" translate="yes" xml:space="preserve">
          <source>Take the number of milliseconds since the rounding epoch (&lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;) and return the corresponding &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">Tome el n&amp;uacute;mero de milisegundos desde la &amp;eacute;poca de redondeo ( &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; ) y devuelva el &lt;code&gt;DateTime&lt;/code&gt; correspondiente .</target>
        </trans-unit>
        <trans-unit id="fdec858b0f40b88512aa7f1bc4fef283de2775ca" translate="yes" xml:space="preserve">
          <source>Take the number of seconds since unix epoch &lt;code&gt;1970-01-01T00:00:00&lt;/code&gt; and convert to the corresponding &lt;code&gt;DateTime&lt;/code&gt;.</source>
          <target state="translated">Tome el n&amp;uacute;mero de segundos desde unix epoch &lt;code&gt;1970-01-01T00:00:00&lt;/code&gt; y convi&amp;eacute;rtalo al &lt;code&gt;DateTime&lt;/code&gt; correspondiente .</target>
        </trans-unit>
        <trans-unit id="df4eac27878e48240f59f94254ce1aad5866d1eb" translate="yes" xml:space="preserve">
          <source>Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for &quot;vectorized&quot; (element-wise) functions, the convenient syntax &lt;code&gt;x .= f.(y)&lt;/code&gt; can be used for in-place operations with fused loops and no temporary arrays (see the &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax for vectorizing functions&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cf08645b24660e17958eeaca8edbd4e94b3d71" translate="yes" xml:space="preserve">
          <source>Taken to its extreme, pre-allocation can make your code uglier, so performance measurements and some judgment may be required. However, for &quot;vectorized&quot; (element-wise) functions, the convenient syntax &lt;code&gt;x .= f.(y)&lt;/code&gt; can be used for in-place operations with fused loops and no temporary arrays (see the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax for vectorizing functions&lt;/a&gt;).</source>
          <target state="translated">Llevado al extremo, la asignaci&amp;oacute;n previa puede hacer que su c&amp;oacute;digo sea m&amp;aacute;s feo, por lo que es posible que se requieran mediciones de rendimiento y cierto criterio. Sin embargo, para funciones &quot;vectorizadas&quot; (por elementos), la sintaxis conveniente &lt;code&gt;x .= f.(y)&lt;/code&gt; se puede utilizar para operaciones en el lugar con bucles fusionados y sin matrices temporales (consulte la &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;sintaxis de puntos para las funciones de vectorizaci&amp;oacute;n&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="068e523ef955dcbff5853a974467b5a1dfd337be" translate="yes" xml:space="preserve">
          <source>Taken together, &lt;code&gt;whence&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; uniquely identify a reference across all workers.</source>
          <target state="translated">Tomados en conjunto, de &lt;code&gt;whence&lt;/code&gt; e &lt;code&gt;id&lt;/code&gt; identifican de forma &amp;uacute;nica una referencia entre todos los trabajadores.</target>
        </trans-unit>
        <trans-unit id="de9377a78118014a32619a7a3fae9e2c93076858" translate="yes" xml:space="preserve">
          <source>Takes a &lt;code&gt;StackTrace&lt;/code&gt; (a vector of &lt;code&gt;StackFrames&lt;/code&gt;) and a function name (a &lt;code&gt;Symbol&lt;/code&gt;) and removes the &lt;code&gt;StackFrame&lt;/code&gt; specified by the function name from the &lt;code&gt;StackTrace&lt;/code&gt; (also removing all frames above the specified function). Primarily used to remove &lt;code&gt;StackTraces&lt;/code&gt; functions from the &lt;code&gt;StackTrace&lt;/code&gt; prior to returning it.</source>
          <target state="translated">Toma un &lt;code&gt;StackTrace&lt;/code&gt; (un vector de &lt;code&gt;StackFrames&lt;/code&gt; ) y un nombre de funci&amp;oacute;n (un &lt;code&gt;Symbol&lt;/code&gt; ) y elimina el &lt;code&gt;StackFrame&lt;/code&gt; especificado por el nombre de la funci&amp;oacute;n del &lt;code&gt;StackTrace&lt;/code&gt; (tambi&amp;eacute;n elimina todos los marcos por encima de la funci&amp;oacute;n especificada). Se utiliza principalmente para eliminar &lt;code&gt;StackTraces&lt;/code&gt; funciones de la &lt;code&gt;StackTrace&lt;/code&gt; antes de devolverlo.</target>
        </trans-unit>
        <trans-unit id="d364a68aa146d3f3bf91f5e5cefd025c8e63eb18" translate="yes" xml:space="preserve">
          <source>Takes one or two &lt;code&gt;BroadcastStyle&lt;/code&gt;s and combines them using &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt; to determine a common &lt;code&gt;BroadcastStyle&lt;/code&gt;.</source>
          <target state="translated">Toma uno o dos &lt;code&gt;BroadcastStyle&lt;/code&gt; y los combina usando &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt; para determinar un &lt;code&gt;BroadcastStyle&lt;/code&gt; com&amp;uacute;n .</target>
        </trans-unit>
        <trans-unit id="0f5b4f7c8c50f94fb9b9fa5a4c40c9fc953fc239" translate="yes" xml:space="preserve">
          <source>Takes the expression &lt;code&gt;x&lt;/code&gt; and returns an equivalent expression in lowered form for executing in module &lt;code&gt;m&lt;/code&gt;. See also &lt;a href=&quot;#Base.code_lowered&quot;&gt;&lt;code&gt;code_lowered&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Toma la expresi&amp;oacute;n &lt;code&gt;x&lt;/code&gt; y devuelve una expresi&amp;oacute;n equivalente en forma reducida para ejecutar en el m&amp;oacute;dulo &lt;code&gt;m&lt;/code&gt; . Consulte tambi&amp;eacute;n &lt;a href=&quot;#Base.code_lowered&quot;&gt; &lt;code&gt;code_lowered&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0f75dfe8be08da7413ff205308db3988d48c238" translate="yes" xml:space="preserve">
          <source>Taking any locks: C code you call out to may use locks internally, (for example, it is not problematic to call &lt;code&gt;malloc&lt;/code&gt;, even though most implementations require locks internally) but don't attempt to hold or acquire any while executing Julia code.</source>
          <target state="translated">Tomar cualquier bloqueo: el c&amp;oacute;digo C al que llama puede usar bloqueos internamente (por ejemplo, no es problem&amp;aacute;tico llamar a &lt;code&gt;malloc&lt;/code&gt; , aunque la mayor&amp;iacute;a de las implementaciones requieren bloqueos internamente) pero no intente retener o adquirir ninguno mientras ejecuta el c&amp;oacute;digo Julia.</target>
        </trans-unit>
        <trans-unit id="0c204d1420d355840b7090b04468d71687143fa6" translate="yes" xml:space="preserve">
          <source>Tanabata Tree</source>
          <target state="translated">Árbol de Tanabata</target>
        </trans-unit>
        <trans-unit id="540da3c8235d6a0dd4fb058287e70d93a6ac769f" translate="yes" xml:space="preserve">
          <source>Tangerine</source>
          <target state="translated">Tangerine</target>
        </trans-unit>
        <trans-unit id="01b941006f02b16df67545cd411e591988012b12" translate="yes" xml:space="preserve">
          <source>Task operations are built on a low-level primitive called &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;yieldto(task, value)&lt;/code&gt; suspends the current task, switches to the specified &lt;code&gt;task&lt;/code&gt;, and causes that task's last &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; call to return the specified &lt;code&gt;value&lt;/code&gt;. Notice that &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called &quot;symmetric coroutines&quot;; each task is switched to and from using the same mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e55dab266b437d3555af520a2b5749154eb13c2" translate="yes" xml:space="preserve">
          <source>Task states</source>
          <target state="translated">La tarea establece</target>
        </trans-unit>
        <trans-unit id="090ec5f560fc50377fcd95e5cda128e91b276e98" translate="yes" xml:space="preserve">
          <source>Tasks</source>
          <target state="translated">Tasks</target>
        </trans-unit>
        <trans-unit id="0b35cd483f5048f80cbf6983b2b06a9cd32bcd14" translate="yes" xml:space="preserve">
          <source>Tasks (aka Coroutines)</source>
          <target state="translated">Tareas (alias Coroutines)</target>
        </trans-unit>
        <trans-unit id="df3ca43deba3d5d7f0127736b100d3e238341ae0" translate="yes" xml:space="preserve">
          <source>Tasks and events</source>
          <target state="translated">Tareas y eventos</target>
        </trans-unit>
        <trans-unit id="8eab10a59a1438147c2e463f755d257993fd8a07" translate="yes" xml:space="preserve">
          <source>Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner. This feature is sometimes called by other names, such as symmetric coroutines, lightweight threads, cooperative multitasking, or one-shot continuations.</source>
          <target state="translated">Las tareas son una característica del flujo de control que permite suspender y reanudar los cálculos de manera flexible.Esta característica se denomina a veces con otros nombres,como cortinas simétricas,hilos ligeros,multitarea cooperativa o continuaciones de un solo disparo.</target>
        </trans-unit>
        <trans-unit id="3cc270b1ec293008662eb882aad48af33750fd03" translate="yes" xml:space="preserve">
          <source>Tasks are a control flow feature that allows computations to be suspended and resumed in a flexible manner. We mention them here only for completeness; for a full discussion see &lt;a href=&quot;../asynchronous-programming/index#man-asynchronous&quot;&gt;Asynchronous Programming&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb3658baf2d7e7d43b5b8f372fd5ca23bdc053a" translate="yes" xml:space="preserve">
          <source>Tasks have a &lt;code&gt;state&lt;/code&gt; field that describes their execution status. A &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;&lt;code&gt;state&lt;/code&gt; is one of the following symbols:</source>
          <target state="translated">Las tareas tienen un campo de &lt;code&gt;state&lt;/code&gt; que describe su estado de ejecuci&amp;oacute;n. Un &lt;code&gt;state&lt;/code&gt; &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; es uno de los siguientes s&amp;iacute;mbolos:</target>
        </trans-unit>
        <trans-unit id="c5e606e056ade44a820632a75114e5367860a0b9" translate="yes" xml:space="preserve">
          <source>Taurus</source>
          <target state="translated">Taurus</target>
        </trans-unit>
        <trans-unit id="82e2b91027511aadd8b52aa9401729c10793ba39" translate="yes" xml:space="preserve">
          <source>Taxi</source>
          <target state="translated">Taxi</target>
        </trans-unit>
        <trans-unit id="0a57f37badaa7ec48014346cc98c84cac7d2ade4" translate="yes" xml:space="preserve">
          <source>Teacup Without Handle</source>
          <target state="translated">Taza de té sin mango</target>
        </trans-unit>
        <trans-unit id="8e757d58b37dccc7e4c0b2a497f65a5ed9d48db3" translate="yes" xml:space="preserve">
          <source>Tear-Off Calendar</source>
          <target state="translated">Calendario de Desgarramiento</target>
        </trans-unit>
        <trans-unit id="b36b5c8399292bab447511d6002f7a7d4e7be9ba" translate="yes" xml:space="preserve">
          <source>Technically, the &lt;code&gt;MIME&quot;mime&quot;&lt;/code&gt; macro defines a singleton type for the given &lt;code&gt;mime&lt;/code&gt; string, which allows us to exploit Julia's dispatch mechanisms in determining how to display objects of any given type.</source>
          <target state="translated">T&amp;eacute;cnicamente, la macro &lt;code&gt;MIME&quot;mime&quot;&lt;/code&gt; define un tipo singleton para la cadena &lt;code&gt;mime&lt;/code&gt; dada , lo que nos permite explotar los mecanismos de despacho de Julia para determinar c&amp;oacute;mo mostrar objetos de cualquier tipo dado.</target>
        </trans-unit>
        <trans-unit id="e8591fccea0433d35b0f909dc027997ba9cf40af" translate="yes" xml:space="preserve">
          <source>Telephone Receiver</source>
          <target state="translated">Receptor de teléfono</target>
        </trans-unit>
        <trans-unit id="6fdcfe42f30940ceb992fdf61a9d918ee098d622" translate="yes" xml:space="preserve">
          <source>Telephone Recorder</source>
          <target state="translated">Grabadora telefónica</target>
        </trans-unit>
        <trans-unit id="e5b83a241ff8a2dcd5e8a0e8480a8c3a13d035b9" translate="yes" xml:space="preserve">
          <source>Telescope</source>
          <target state="translated">Telescope</target>
        </trans-unit>
        <trans-unit id="a77b1903c8e3b2f68e74c12f0e476b3e4533624b" translate="yes" xml:space="preserve">
          <source>Television</source>
          <target state="translated">Television</target>
        </trans-unit>
        <trans-unit id="3024b128d3cb0369c884d0466a1f023cd5ca5d2d" translate="yes" xml:space="preserve">
          <source>Tells the compiler to apply the polyhedral optimizer Polly to a function.</source>
          <target state="translated">Le dice al compilador que aplique el optimizador poliédrico Polly a una función.</target>
        </trans-unit>
        <trans-unit id="82c8638d126af0aea69ce9d89f262926c474dc0b" translate="yes" xml:space="preserve">
          <source>Tells the compiler to inline a function while retaining the caller's inbounds context.</source>
          <target state="translated">Le dice al compilador que ponga en línea una función conservando el contexto inbounds de la persona que llama.</target>
        </trans-unit>
        <trans-unit id="f664957d0ea8b87df32ae92b4fd24aa1a46ea0d6" translate="yes" xml:space="preserve">
          <source>Temporarily change the current working directory to &lt;code&gt;dir&lt;/code&gt;, apply function &lt;code&gt;f&lt;/code&gt; and finally return to the original directory.</source>
          <target state="translated">Cambie temporalmente el directorio de trabajo actual a &lt;code&gt;dir&lt;/code&gt; , aplique la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; y finalmente regrese al directorio original.</target>
        </trans-unit>
        <trans-unit id="5368df43ad530996bb634ca556da7a94b51b1f83" translate="yes" xml:space="preserve">
          <source>Temporarily protect the given objects from being garbage collected, even if they would otherwise be unreferenced.</source>
          <target state="translated">Proteger temporalmente los objetos dados para que no se recojan como basura,aunque de otro modo no se les haga referencia.</target>
        </trans-unit>
        <trans-unit id="7aa6cf11b9fd650712f5d0d45e4ebbfbd3c41157" translate="yes" xml:space="preserve">
          <source>Tennis Racquet And Ball</source>
          <target state="translated">Raqueta y pelota de tenis</target>
        </trans-unit>
        <trans-unit id="eae12d19e86e1dd6bdd687f86d4bf2b6b0796fe8" translate="yes" xml:space="preserve">
          <source>Tent</source>
          <target state="translated">Tent</target>
        </trans-unit>
        <trans-unit id="e78f2b53804e241d64d7b89461c2a0d69af83b51" translate="yes" xml:space="preserve">
          <source>TerminalMenus</source>
          <target state="translated">TerminalMenus</target>
        </trans-unit>
        <trans-unit id="13fa61ab6513a29d350b01bb431ceafe6fa30f37" translate="yes" xml:space="preserve">
          <source>TerminalMenus is a submodule of the Julia REPL and enables small, low-profile interactive menus in the terminal.</source>
          <target state="translated">TerminalMenus es un submódulo del Julia REPL y permite pequeños menús interactivos de bajo perfil en la terminal.</target>
        </trans-unit>
        <trans-unit id="2139b2bddeeaa577530e84c69430b174701f95a8" translate="yes" xml:space="preserve">
          <source>Test sets can also be nested:</source>
          <target state="translated">Los conjuntos de pruebas también pueden anidarse:</target>
        </trans-unit>
        <trans-unit id="905795e622786e111cc0f710b821ee73ef40ef36" translate="yes" xml:space="preserve">
          <source>Test that a factorization of a matrix succeeded.</source>
          <target state="translated">Prueba que una factorización de una matriz tuvo éxito.</target>
        </trans-unit>
        <trans-unit id="b044b22b39c04d0d12ff81df1380d3e1a16e02ee" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;A&lt;/code&gt; is lower triangular starting from the &lt;code&gt;k&lt;/code&gt;th superdiagonal.</source>
          <target state="translated">Pruebe si &lt;code&gt;A&lt;/code&gt; es triangular inferior a partir de la &lt;code&gt;k&lt;/code&gt; - &amp;eacute;sima superdiagonal.</target>
        </trans-unit>
        <trans-unit id="e4cf2b6626c76618b63816a9d2821ac9a2e3d9dd" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;A&lt;/code&gt; is upper triangular starting from the &lt;code&gt;k&lt;/code&gt;th superdiagonal.</source>
          <target state="translated">Pruebe si &lt;code&gt;A&lt;/code&gt; es triangular superior a partir de la &lt;code&gt;k&lt;/code&gt; - &amp;eacute;sima superdiagonal.</target>
        </trans-unit>
        <trans-unit id="98fd1b482df7fb574b54488f598a98d5212dc3a9" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;n&lt;/code&gt; is a power of two.</source>
          <target state="translated">Pruebe si &lt;code&gt;n&lt;/code&gt; es una potencia de dos.</target>
        </trans-unit>
        <trans-unit id="27c9d85a5238374f74460ae2f5d8d739f24f5e58" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;x&lt;/code&gt; is less than &lt;code&gt;y&lt;/code&gt;, according to a fixed total order. &lt;code&gt;isless&lt;/code&gt; is not defined on all pairs of values &lt;code&gt;(x, y)&lt;/code&gt;. However, if it is defined, it is expected to satisfy the following:</source>
          <target state="translated">Pruebe si &lt;code&gt;x&lt;/code&gt; es menor que &lt;code&gt;y&lt;/code&gt; , de acuerdo con un orden total fijo. &lt;code&gt;isless&lt;/code&gt; no est&amp;aacute; definido en todos los pares de valores &lt;code&gt;(x, y)&lt;/code&gt; . Sin embargo, si se define, se espera que satisfaga lo siguiente:</target>
        </trans-unit>
        <trans-unit id="4e089adb509ccd09b24baf13faa8a1eebdb92d73" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;x&lt;/code&gt; is numerically equal to some integer.</source>
          <target state="translated">Pruebe si &lt;code&gt;x&lt;/code&gt; es num&amp;eacute;ricamente igual a alg&amp;uacute;n n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="129659df829e85df63605534482b69287911ce83" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;x&lt;/code&gt; or all its elements are numerically equal to some real number including infinities and NaNs. &lt;code&gt;isreal(x)&lt;/code&gt; is true if &lt;code&gt;isequal(x, real(x))&lt;/code&gt; is true.</source>
          <target state="translated">Pruebe si &lt;code&gt;x&lt;/code&gt; o todos sus elementos son num&amp;eacute;ricamente iguales a alg&amp;uacute;n n&amp;uacute;mero real, incluidos los infinitos y los NaN. &lt;code&gt;isreal(x)&lt;/code&gt; es verdadero si &lt;code&gt;isequal(x, real(x))&lt;/code&gt; es verdadero.</target>
        </trans-unit>
        <trans-unit id="600f2a45d487a92b3e1acfc026b5358d6258b900" translate="yes" xml:space="preserve">
          <source>Test whether a character belongs to the ASCII character set, or whether this is true for all elements of a string.</source>
          <target state="translated">Comprobar si un carácter pertenece al conjunto de caracteres ASCII,o si esto es cierto para todos los elementos de una cadena.</target>
        </trans-unit>
        <trans-unit id="ff3201c5d4b7bfd8db4e7a4f29a3f69497556eca" translate="yes" xml:space="preserve">
          <source>Test whether a character is a letter. A character is classified as a letter if it belongs to the Unicode general category Letter, i.e. a character whose category code begins with 'L'.</source>
          <target state="translated">Pruebe si un personaje es una letra.Un carácter se clasifica como una letra si pertenece a la categoría general de Unicode Carta,es decir,un carácter cuyo código de categoría comienza con &quot;L&quot;.</target>
        </trans-unit>
        <trans-unit id="b813a818e8d7c67e7e9a9f0231fbac7c47fefadd" translate="yes" xml:space="preserve">
          <source>Test whether a character is a valid hexadecimal digit. Note that this does not include &lt;code&gt;x&lt;/code&gt; (as in the standard &lt;code&gt;0x&lt;/code&gt; prefix).</source>
          <target state="translated">Prueba si un car&amp;aacute;cter es un d&amp;iacute;gito hexadecimal v&amp;aacute;lido. Tenga en cuenta que esto no incluye &lt;code&gt;x&lt;/code&gt; (como en el prefijo est&amp;aacute;ndar &lt;code&gt;0x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e0cacc8325a8d7f460c1842e48e751e6577dc0aa" translate="yes" xml:space="preserve">
          <source>Test whether a floating point number is not a number (NaN).</source>
          <target state="translated">Prueba si un número de punto flotante no es un número (NaN).</target>
        </trans-unit>
        <trans-unit id="d7419a87e49114034dc9b13f27d841429ec6cc7c" translate="yes" xml:space="preserve">
          <source>Test whether a floating point number is subnormal.</source>
          <target state="translated">Pruebe si un número de punto flotante es subnormal.</target>
        </trans-unit>
        <trans-unit id="2ab2650250d6d0753ef232f30dc775ab55d17e25" translate="yes" xml:space="preserve">
          <source>Test whether a matrix is Hermitian.</source>
          <target state="translated">Prueba si una matriz es Hermitiana.</target>
        </trans-unit>
        <trans-unit id="82b9f1f281541be3d753c0180e9a9b9c68a4213c" translate="yes" xml:space="preserve">
          <source>Test whether a matrix is diagonal.</source>
          <target state="translated">Pruebe si una matriz es diagonal.</target>
        </trans-unit>
        <trans-unit id="d10ee2b732be6df553fcdf2c02967046d343062a" translate="yes" xml:space="preserve">
          <source>Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of &lt;code&gt;A&lt;/code&gt;, overwriting &lt;code&gt;A&lt;/code&gt; in the process. See also &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Pruebe si una matriz es positiva definida (y hermitiana) tratando de realizar una factorizaci&amp;oacute;n Cholesky de &lt;code&gt;A&lt;/code&gt; , sobrescribiendo &lt;code&gt;A&lt;/code&gt; en el proceso. Consulte tambi&amp;eacute;n &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="348072f52243282048adc6be8377b4069538c3e2" translate="yes" xml:space="preserve">
          <source>Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of &lt;code&gt;A&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.isposdef!&quot;&gt;&lt;code&gt;isposdef!&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Probar si una matriz es definida positiva (y hermitiana) por intentar realizar una factorizaci&amp;oacute;n de Cholesky de &lt;code&gt;A&lt;/code&gt; . Consulte tambi&amp;eacute;n &lt;a href=&quot;#LinearAlgebra.isposdef!&quot;&gt; &lt;code&gt;isposdef!&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="07adbca0475dd6e20bdd50fc2143d233a16e3c32" translate="yes" xml:space="preserve">
          <source>Test whether a matrix is symmetric.</source>
          <target state="translated">Prueba si una matriz es simétrica.</target>
        </trans-unit>
        <trans-unit id="3599ca56d6716dfc1dda935750874c488e247ef1" translate="yes" xml:space="preserve">
          <source>Test whether a number is finite.</source>
          <target state="translated">Prueba si un número es finito.</target>
        </trans-unit>
        <trans-unit id="73368aa2af01f69082a351e93d003d22094d90ad" translate="yes" xml:space="preserve">
          <source>Test whether a number is infinite.</source>
          <target state="translated">Prueba si un número es infinito.</target>
        </trans-unit>
        <trans-unit id="d75260ba4af82ac9b6c50155871969bea358f4b9" translate="yes" xml:space="preserve">
          <source>Test whether a number value is a NaN, an indeterminate value which is neither an infinity nor a finite number (&quot;not a number&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d5538dd4fb443f30fc719de96fea5e3c4be074" translate="yes" xml:space="preserve">
          <source>Test whether a vector is in sorted order. The &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;by&lt;/code&gt; and &lt;code&gt;rev&lt;/code&gt; keywords modify what order is considered to be sorted just as they do for &lt;a href=&quot;#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Pruebe si un vector est&amp;aacute; en orden. Las palabras clave &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;by&lt;/code&gt; y &lt;code&gt;rev&lt;/code&gt; modifican el orden que se considera ordenado, al igual que lo hacen para &lt;a href=&quot;#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="042172a78d48aeda17bafb91d25140f851ffb91a" translate="yes" xml:space="preserve">
          <source>Test whether all elements of a boolean collection are &lt;code&gt;true&lt;/code&gt;, returning &lt;code&gt;false&lt;/code&gt; as soon as the first &lt;code&gt;false&lt;/code&gt; value in &lt;code&gt;itr&lt;/code&gt; is encountered (short-circuiting).</source>
          <target state="translated">Pruebe si todos los elementos de una colecci&amp;oacute;n booleana son &lt;code&gt;true&lt;/code&gt; , devolviendo &lt;code&gt;false&lt;/code&gt; tan pronto como se encuentre el primer valor &lt;code&gt;false&lt;/code&gt; en &lt;code&gt;itr&lt;/code&gt; (cortocircuito).</target>
        </trans-unit>
        <trans-unit id="07c60c5c1f0ceba07eb9c4e3e6adeed9269c406c" translate="yes" xml:space="preserve">
          <source>Test whether all values in &lt;code&gt;A&lt;/code&gt; along the singleton dimensions of &lt;code&gt;r&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Pruebe si todos los valores en &lt;code&gt;A&lt;/code&gt; a lo largo de las dimensiones singleton de &lt;code&gt;r&lt;/code&gt; son &lt;code&gt;true&lt;/code&gt; y escriba los resultados en &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3d64b16b12423728af4949449874717f8930e1" translate="yes" xml:space="preserve">
          <source>Test whether an I/O stream is at end-of-file. If the stream is not yet exhausted, this function will block to wait for more data if necessary, and then return &lt;code&gt;false&lt;/code&gt;. Therefore it is always safe to read one byte after seeing &lt;code&gt;eof&lt;/code&gt; return &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;eof&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; as long as buffered data is still available, even if the remote end of a connection is closed.</source>
          <target state="translated">Pruebe si una secuencia de E / S est&amp;aacute; al final del archivo. Si el flujo a&amp;uacute;n no se ha agotado, esta funci&amp;oacute;n se bloquear&amp;aacute; para esperar m&amp;aacute;s datos si es necesario y luego devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; . Por lo tanto, siempre es seguro leer un byte despu&amp;eacute;s de ver que &lt;code&gt;eof&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;eof&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; siempre que los datos almacenados en b&amp;uacute;fer est&amp;eacute;n disponibles, incluso si el extremo remoto de una conexi&amp;oacute;n est&amp;aacute; cerrado.</target>
        </trans-unit>
        <trans-unit id="a9e4f6b06e3064db079558e13017dc87dfe1fa0e" translate="yes" xml:space="preserve">
          <source>Test whether any elements of a boolean collection are &lt;code&gt;true&lt;/code&gt;, returning &lt;code&gt;true&lt;/code&gt; as soon as the first &lt;code&gt;true&lt;/code&gt; value in &lt;code&gt;itr&lt;/code&gt; is encountered (short-circuiting).</source>
          <target state="translated">Pruebe si alg&amp;uacute;n elemento de una colecci&amp;oacute;n booleana es &lt;code&gt;true&lt;/code&gt; , devolviendo &lt;code&gt;true&lt;/code&gt; tan pronto como se encuentre el primer valor &lt;code&gt;true&lt;/code&gt; en &lt;code&gt;itr&lt;/code&gt; (cortocircuito).</target>
        </trans-unit>
        <trans-unit id="e348af6e654acbf2a94a256de0eb0dbfdadfb336" translate="yes" xml:space="preserve">
          <source>Test whether any values in &lt;code&gt;A&lt;/code&gt; along the singleton dimensions of &lt;code&gt;r&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Pruebe si alg&amp;uacute;n valor en &lt;code&gt;A&lt;/code&gt; a lo largo de las dimensiones singleton de &lt;code&gt;r&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; y escriba los resultados en &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd46b89139e604585bd7adc7fd76ca1664e06ca" translate="yes" xml:space="preserve">
          <source>Test whether evaluating &lt;code&gt;expr&lt;/code&gt; results in &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; output that contains the &lt;code&gt;msg&lt;/code&gt; string or matches the &lt;code&gt;msg&lt;/code&gt; regular expression. If &lt;code&gt;msg&lt;/code&gt; is a boolean function, tests whether &lt;code&gt;msg(output)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;msg&lt;/code&gt; is a tuple or array, checks that the error output contains/matches each item in &lt;code&gt;msg&lt;/code&gt;. Returns the result of evaluating &lt;code&gt;expr&lt;/code&gt;.</source>
          <target state="translated">Pruebe si la evaluaci&amp;oacute;n de &lt;code&gt;expr&lt;/code&gt; da como resultado una salida &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; que contiene la cadena &lt;code&gt;msg&lt;/code&gt; o coincide con la expresi&amp;oacute;n regular &lt;code&gt;msg&lt;/code&gt; . Si &lt;code&gt;msg&lt;/code&gt; es una funci&amp;oacute;n booleana, prueba si &lt;code&gt;msg(output)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; . Si &lt;code&gt;msg&lt;/code&gt; es una tupla o matriz, verifica que la salida de error contenga / coincida con cada elemento de &lt;code&gt;msg&lt;/code&gt; . Devuelve el resultado de evaluar &lt;code&gt;expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c503325cf6d409b8a3c8deb8bb14aeb0c9c653" translate="yes" xml:space="preserve">
          <source>Test whether evaluating &lt;code&gt;expr&lt;/code&gt; results in empty &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; output (no warnings or other messages). Returns the result of evaluating &lt;code&gt;expr&lt;/code&gt;.</source>
          <target state="translated">Pruebe si la evaluaci&amp;oacute;n de &lt;code&gt;expr&lt;/code&gt; da como resultado una salida &lt;a href=&quot;../../base/io-network/index#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; vac&amp;iacute;a (sin advertencias ni otros mensajes). Devuelve el resultado de evaluar &lt;code&gt;expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fb141979c927fd73f20cd08901b19019dd16fdc" translate="yes" xml:space="preserve">
          <source>Test whether string &lt;code&gt;a&lt;/code&gt; comes before string &lt;code&gt;b&lt;/code&gt; in alphabetical order (technically, in lexicographical order by Unicode code points).</source>
          <target state="translated">Pruebe si la cadena &lt;code&gt;a&lt;/code&gt; viene antes de la cadena &lt;code&gt;b&lt;/code&gt; en orden alfab&amp;eacute;tico (t&amp;eacute;cnicamente, en orden lexicogr&amp;aacute;fico por puntos de c&amp;oacute;digo Unicode).</target>
        </trans-unit>
        <trans-unit id="af1d2d0bea1baef660017807a8fc1e76d51825f5" translate="yes" xml:space="preserve">
          <source>Test whether the bits of &lt;code&gt;val&lt;/code&gt; indexed by &lt;code&gt;flag&lt;/code&gt; are set (&lt;code&gt;1&lt;/code&gt;) or unset (&lt;code&gt;0&lt;/code&gt;).</source>
          <target state="translated">Pruebe si los bits de &lt;code&gt;val&lt;/code&gt; indexados por &lt;code&gt;flag&lt;/code&gt; est&amp;aacute;n activados ( &lt;code&gt;1&lt;/code&gt; ) o no establecidos ( &lt;code&gt;0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="03c61a2f3d90dc00f68f5e2ed78c218e3afa629e" translate="yes" xml:space="preserve">
          <source>Test whether the given array has a value associated with index &lt;code&gt;i&lt;/code&gt;. Return &lt;code&gt;false&lt;/code&gt; if the index is out of bounds, or has an undefined reference.</source>
          <target state="translated">Pruebe si la matriz dada tiene un valor asociado con el &amp;iacute;ndice &lt;code&gt;i&lt;/code&gt; . Devuelve &lt;code&gt;false&lt;/code&gt; si el &amp;iacute;ndice est&amp;aacute; fuera de los l&amp;iacute;mites o tiene una referencia indefinida.</target>
        </trans-unit>
        <trans-unit id="beda63ee049bff8ccbc0434c5189adc1f6390d8f" translate="yes" xml:space="preserve">
          <source>Test whether two strings are equal character by character (technically, Unicode code point by code point).</source>
          <target state="translated">Comprobar si dos cadenas son iguales carácter por carácter (técnicamente,código Unicode punto por punto).</target>
        </trans-unit>
        <trans-unit id="49bf5d839411dd44ef27726c0fd5d3673c683947" translate="yes" xml:space="preserve">
          <source>Test-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, different synchronization approaches should be considered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf06dc89873a4ef4739014da9b0503ac82ea142" translate="yes" xml:space="preserve">
          <source>Test-and-test-and-set spin locks are quickest up to about 30ish contending threads. If you have more contention than that, perhaps a lock is the wrong way to synchronize.</source>
          <target state="translated">Los bloqueos de giro de prueba son más rápidos hasta unos 30 hilos contendientes.Si tienes más contención que eso,tal vez un bloqueo es la forma incorrecta de sincronizar.</target>
        </trans-unit>
        <trans-unit id="2d37dbc036f72363555168a219582cc080650c2c" translate="yes" xml:space="preserve">
          <source>Test.@inferred</source>
          <target state="translated">Test.@inferred</target>
        </trans-unit>
        <trans-unit id="67c3de69a1559a69f4d736c324dbd0345e8ce841" translate="yes" xml:space="preserve">
          <source>Test.@test</source>
          <target state="translated">Test.@test</target>
        </trans-unit>
        <trans-unit id="bd238279fd968d439f9885d950b9239d42041d37" translate="yes" xml:space="preserve">
          <source>Test.@test_broken</source>
          <target state="translated">Test.@test_broken</target>
        </trans-unit>
        <trans-unit id="77f427edbc1109c9ae775e8fe246045b182ad14f" translate="yes" xml:space="preserve">
          <source>Test.@test_deprecated</source>
          <target state="translated">Test.@test_deprecated</target>
        </trans-unit>
        <trans-unit id="5f31db08afdef0dd5283f2187bca919c2925c8f7" translate="yes" xml:space="preserve">
          <source>Test.@test_logs</source>
          <target state="translated">Test.@test_logs</target>
        </trans-unit>
        <trans-unit id="de547b50f8053308f0a2ee21b90aaae3dcceb9ad" translate="yes" xml:space="preserve">
          <source>Test.@test_nowarn</source>
          <target state="translated">Test.@test_nowarn</target>
        </trans-unit>
        <trans-unit id="615ef519b12005068f8a41a5b369ca5e1c35c1df" translate="yes" xml:space="preserve">
          <source>Test.@test_skip</source>
          <target state="translated">Test.@test_skip</target>
        </trans-unit>
        <trans-unit id="95afc1bc6b103ad5f46190e8654549af904b5ca5" translate="yes" xml:space="preserve">
          <source>Test.@test_throws</source>
          <target state="translated">Test.@test_throws</target>
        </trans-unit>
        <trans-unit id="9d03989391caa1d6637c00c4e3593a97718e2d0c" translate="yes" xml:space="preserve">
          <source>Test.@test_warn</source>
          <target state="translated">Test.@test_warn</target>
        </trans-unit>
        <trans-unit id="9c32cdd553427e36cbe90d4bd95ba370b53cfa1f" translate="yes" xml:space="preserve">
          <source>Test.@testset</source>
          <target state="translated">Test.@testset</target>
        </trans-unit>
        <trans-unit id="066c25bc74518d73302b5533ce6478389885f805" translate="yes" xml:space="preserve">
          <source>Test.finish()</source>
          <target state="translated">Test.finish()</target>
        </trans-unit>
        <trans-unit id="631cdc0a519d0e288b565285a0850351da1807ff" translate="yes" xml:space="preserve">
          <source>Test.get_testset()</source>
          <target state="translated">Test.get_testset()</target>
        </trans-unit>
        <trans-unit id="faa7d1071b0518cdce8349dea77288299aaf1de4" translate="yes" xml:space="preserve">
          <source>Test.get_testset_depth()</source>
          <target state="translated">Test.get_testset_depth()</target>
        </trans-unit>
        <trans-unit id="c13bc73ec3123a7311ed203c0f38cc895a803bbc" translate="yes" xml:space="preserve">
          <source>Test.record()</source>
          <target state="translated">Test.record()</target>
        </trans-unit>
        <trans-unit id="cfa7ab2b3a16142765d21a4e0e0bb623e5059861" translate="yes" xml:space="preserve">
          <source>Testing Base Julia</source>
          <target state="translated">Base de pruebas Julia</target>
        </trans-unit>
        <trans-unit id="4987ea8354d4ae570352dab5aa6d2a2a221c5e60" translate="yes" xml:space="preserve">
          <source>Testing log events</source>
          <target state="translated">Prueba de eventos de registro</target>
        </trans-unit>
        <trans-unit id="9f285f003655f9f610bc2da7f8c3424ca3aeec50" translate="yes" xml:space="preserve">
          <source>Tests if</source>
          <target state="translated">Prueba si</target>
        </trans-unit>
        <trans-unit id="f004ea40cf1865fa970c6555dac7feb5082b5754" translate="yes" xml:space="preserve">
          <source>Tests if an IP address is a link-local address. Link-local addresses are not guaranteed to be unique beyond their network segment, therefore routers do not forward them. Link-local addresses are from the address blocks &lt;code&gt;169.254.0.0/16&lt;/code&gt; or &lt;code&gt;fe80::/10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14917cac8a358ec6de88c1ed38efe9ab513ca635" translate="yes" xml:space="preserve">
          <source>Tests that the call expression &lt;code&gt;f(x)&lt;/code&gt; returns a value of the same type inferred by the compiler. It is useful to check for type stability.</source>
          <target state="translated">Prueba que la expresi&amp;oacute;n de llamada &lt;code&gt;f(x)&lt;/code&gt; devuelve un valor del mismo tipo inferido por el compilador. Es &amp;uacute;til comprobar la estabilidad del tipo.</target>
        </trans-unit>
        <trans-unit id="f51e24e7a72028a134722e0d08788caab74f1323" translate="yes" xml:space="preserve">
          <source>Tests that the expression &lt;code&gt;ex&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;. Returns a &lt;code&gt;Pass&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it does, a &lt;code&gt;Fail&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it is &lt;code&gt;false&lt;/code&gt;, and an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it could not be evaluated.</source>
          <target state="translated">Comprueba que la expresi&amp;oacute;n &lt;code&gt;ex&lt;/code&gt; se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; . Devuelve un &lt;code&gt;Pass&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; ado si lo hace, una &lt;code&gt;Fail&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; ado si es &lt;code&gt;false&lt;/code&gt; , y un &lt;code&gt;Error&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; ado si no se pudo evaluar.</target>
        </trans-unit>
        <trans-unit id="17b9894fca3ff1649ca921b070f540e392fa37b8" translate="yes" xml:space="preserve">
          <source>Tests that the expression &lt;code&gt;expr&lt;/code&gt; throws &lt;code&gt;exception&lt;/code&gt;. The exception may specify either a type, or a value (which will be tested for equality by comparing fields). Note that &lt;code&gt;@test_throws&lt;/code&gt; does not support a trailing keyword form.</source>
          <target state="translated">Prueba que la expresi&amp;oacute;n &lt;code&gt;expr&lt;/code&gt; arroja una &lt;code&gt;exception&lt;/code&gt; . La excepci&amp;oacute;n puede especificar un tipo o un valor (cuya igualdad se probar&amp;aacute; comparando campos). Tenga en cuenta que &lt;code&gt;@test_throws&lt;/code&gt; no admite un formulario de palabra clave final.</target>
        </trans-unit>
        <trans-unit id="ae181d6002e3e7b8e7869d12db427e89bc76200b" translate="yes" xml:space="preserve">
          <source>Tests whether a character belongs to the Unicode general category Punctuation, i.e. a character whose category code begins with 'P'.</source>
          <target state="translated">Comprueba si un personaje pertenece a la categoría general de Unicode Puntuación,es decir,un personaje cuyo código de categoría comienza con 'P'.</target>
        </trans-unit>
        <trans-unit id="2a7a2ddabfc89454537a4dc9c09df6337da0be84" translate="yes" xml:space="preserve">
          <source>Tests whether a character is a control character. Control characters are the non-printing characters of the Latin-1 subset of Unicode.</source>
          <target state="translated">Prueba si un personaje es un personaje de control.Los caracteres de control son los caracteres sin impresión del subconjunto Latin-1 de Unicode.</target>
        </trans-unit>
        <trans-unit id="c61df5952425542bbe698c6186d9e662be2fad8c" translate="yes" xml:space="preserve">
          <source>Tests whether a character is a decimal digit (0-9).</source>
          <target state="translated">Comprueba si un carácter es un dígito decimal (0-9).</target>
        </trans-unit>
        <trans-unit id="0ac236a3ea7a0e9ead5326f9e44c423dc78ebc26" translate="yes" xml:space="preserve">
          <source>Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.</source>
          <target state="translated">Prueba si un personaje es una letra minúscula.Un carácter se clasifica como minúscula si pertenece a la categoría de Unicode Ll,Letra:Minúscula.</target>
        </trans-unit>
        <trans-unit id="91cdaf6d3cfe470a11194162162137ec98b73f57" translate="yes" xml:space="preserve">
          <source>Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.</source>
          <target state="translated">Prueba si un personaje es una letra mayúscula.Un personaje se clasifica como mayúscula si pertenece a la categoría Lu de Unicode,Carta:Mayúscula,o Lt,Letra:Titlecase.</target>
        </trans-unit>
        <trans-unit id="45909810023531a635329b57dc9f15acb810e806" translate="yes" xml:space="preserve">
          <source>Tests whether a character is any whitespace character. Includes ASCII characters '\t', '\n', '\v', '\f', '\r', and ' ', Latin-1 character U+0085, and characters in Unicode category Zs.</source>
          <target state="translated">Prueba si un personaje es un personaje de espacio en blanco.Incluye los caracteres ASCII '\t','\N','\Nv','\Nf','\Nr',y ' ' ',el carácter Latin-1 U+0085,y los caracteres de la categoría Zs del Unicode.</target>
        </trans-unit>
        <trans-unit id="b0a4dc18e63052a8e4b050ac6060b42fea1cafaa" translate="yes" xml:space="preserve">
          <source>Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with 'N'.</source>
          <target state="translated">Comprueba si un personaje es numérico.Un carácter se clasifica como numérico si pertenece a la categoría general de Unicode Número,es decir,un carácter cuyo código de categoría comienza con 'N'.</target>
        </trans-unit>
        <trans-unit id="982f0addad2d0da939982a5caca6283ccb1d7eb4" translate="yes" xml:space="preserve">
          <source>Tests whether a character is printable, including spaces, but not a control character.</source>
          <target state="translated">Prueba si un personaje es imprimible,incluyendo espacios,pero no un personaje de control.</target>
        </trans-unit>
        <trans-unit id="e49525a9628b3bad0a6106685a8ac5eeac97a7e1" translate="yes" xml:space="preserve">
          <source>Tests whether a global variable or object field is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index.</source>
          <target state="translated">Comprueba si se define una variable global o un campo de objeto.Los argumentos pueden ser un módulo y un símbolo o un objeto compuesto y un nombre de campo (como un símbolo)o un índice.</target>
        </trans-unit>
        <trans-unit id="b292cfab7944ffbf6199920c5349913e95d9eeb7" translate="yes" xml:space="preserve">
          <source>Tests whether variable &lt;code&gt;s&lt;/code&gt; is defined in the current scope.</source>
          <target state="translated">Comprueba si la variable &lt;code&gt;s&lt;/code&gt; est&amp;aacute; definida en el &amp;aacute;mbito actual.</target>
        </trans-unit>
        <trans-unit id="109f7c2f219315f947611c43c343d61302c960d4" translate="yes" xml:space="preserve">
          <source>Text I/O</source>
          <target state="translated">Texto I/O</target>
        </trans-unit>
        <trans-unit id="ea824a563aca9df06f453afa8aed6e59740fd02e" translate="yes" xml:space="preserve">
          <source>Text from external sources, such as quotations from books or websites, can be quoted using &lt;code&gt;&amp;gt;&lt;/code&gt; characters prepended to each line of the quote as follows.</source>
          <target state="translated">El texto de fuentes externas, como citas de libros o sitios web, se puede citar utilizando caracteres &lt;code&gt;&amp;gt;&lt;/code&gt; antepuestos a cada l&amp;iacute;nea de la cita de la siguiente manera.</target>
        </trans-unit>
        <trans-unit id="fbe2b75f7fbda9be349dabaf963a9b88611d5493" translate="yes" xml:space="preserve">
          <source>That is really all there is to using promotions. The rest is just a matter of clever application, the most typical &quot;clever&quot; application being the definition of catch-all methods for numeric operations like the arithmetic operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;. Here are some of the catch-all method definitions given in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Eso es realmente todo lo que hay que hacer para usar promociones. El resto es s&amp;oacute;lo una cuesti&amp;oacute;n de aplicaci&amp;oacute;n inteligente, siendo la aplicaci&amp;oacute;n &quot;inteligente&quot; m&amp;aacute;s t&amp;iacute;pica la definici&amp;oacute;n de m&amp;eacute;todos generales para operaciones num&amp;eacute;ricas como los operadores aritm&amp;eacute;ticos &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; y &lt;code&gt;/&lt;/code&gt; . A continuaci&amp;oacute;n, se muestran algunas de las definiciones de m&amp;eacute;todos generales que se ofrecen en &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a55180ee0e35250f4a5e86928557c4ebfc2a5b49" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;fdot(x)&lt;/code&gt; is ten times faster and allocates 1/6 the memory of &lt;code&gt;f(x)&lt;/code&gt;, because each &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; operation in &lt;code&gt;f(x)&lt;/code&gt; allocates a new temporary array and executes in a separate loop. (Of course, if you just do &lt;code&gt;f.(x)&lt;/code&gt; then it is as fast as &lt;code&gt;fdot(x)&lt;/code&gt; in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)</source>
          <target state="translated">Es decir, &lt;code&gt;fdot(x)&lt;/code&gt; es diez veces m&amp;aacute;s r&amp;aacute;pido y asigna 1/6 de la memoria de &lt;code&gt;f(x)&lt;/code&gt; , porque cada operaci&amp;oacute;n &lt;code&gt;*&lt;/code&gt; y &lt;code&gt;+&lt;/code&gt; en &lt;code&gt;f(x)&lt;/code&gt; asigna una nueva matriz temporal y se ejecuta en un ciclo separado. (Por supuesto, si solo hace &lt;code&gt;f.(x)&lt;/code&gt; entonces es tan r&amp;aacute;pido como &lt;code&gt;fdot(x)&lt;/code&gt; en este ejemplo, pero en muchos contextos es m&amp;aacute;s conveniente rociar algunos puntos en sus expresiones en lugar de definir una funci&amp;oacute;n separada para cada operaci&amp;oacute;n vectorizada.)</target>
        </trans-unit>
        <trans-unit id="96ae6d125bf587e76e862ea35e250d9a1dd1ac01" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;maxintfloat&lt;/code&gt; returns the smallest positive integer-valued floating-point number &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;n+1&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exactly representable in the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Esto es, &lt;code&gt;maxintfloat&lt;/code&gt; devuelve el n&amp;uacute;mero m&amp;aacute;s peque&amp;ntilde;o positivo de valor entero de punto flotante &lt;code&gt;n&lt;/code&gt; tal que &lt;code&gt;n+1&lt;/code&gt; es &lt;em&gt;no&lt;/em&gt; exactamente representable en el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5135aa1a424ac6b5ea53a127625ebc585292c35c" translate="yes" xml:space="preserve">
          <source>That is, in the first call, the expression &lt;code&gt;:(1 == 1.0)&lt;/code&gt; is spliced into the test condition slot, while the value of &lt;code&gt;string(:(1 == 1.0))&lt;/code&gt; is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the &lt;code&gt;@assert&lt;/code&gt; macro call occurs. Then at execution time, if the test expression evaluates to true, then &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; is returned, whereas if the test is false, an error is raised indicating the asserted expression that was false. Notice that it would not be possible to write this as a function, since only the &lt;em&gt;value&lt;/em&gt; of the condition is available and it would be impossible to display the expression that computed it in the error message.</source>
          <target state="translated">Es decir, en la primera llamada, la expresi&amp;oacute;n &lt;code&gt;:(1 == 1.0)&lt;/code&gt; se empalma en la ranura de la condici&amp;oacute;n de prueba, mientras que el valor de la &lt;code&gt;string(:(1 == 1.0))&lt;/code&gt; se empalma en la ranura del mensaje de aserci&amp;oacute;n. La expresi&amp;oacute;n completa, as&amp;iacute; construida, se coloca en el &amp;aacute;rbol de sintaxis donde ocurre la llamada de macro &lt;code&gt;@assert&lt;/code&gt; . Luego, en el momento de la ejecuci&amp;oacute;n, si la expresi&amp;oacute;n de prueba se eval&amp;uacute;a como verdadera, &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; se devuelve nada , mientras que si la prueba es falsa, se genera un error que indica la expresi&amp;oacute;n afirmada que era falsa. Observe que no ser&amp;iacute;a posible escribir esto como una funci&amp;oacute;n, ya que solo est&amp;aacute; disponible el &lt;em&gt;valor&lt;/em&gt; de la condici&amp;oacute;n y ser&amp;iacute;a imposible mostrar la expresi&amp;oacute;n que lo calcul&amp;oacute; en el mensaje de error.</target>
        </trans-unit>
        <trans-unit id="a5c2c27899b95213132fa8a21acc33667eaa425d" translate="yes" xml:space="preserve">
          <source>That is, write:</source>
          <target state="translated">Es decir,escribe:</target>
        </trans-unit>
        <trans-unit id="d78e12b42ebbdc9ccff0d1ee38bf8bf79ad2272d" translate="yes" xml:space="preserve">
          <source>That may seem confusing, given that the hour (12) is not divisible by 10. The reason that &lt;code&gt;2016-07-17T12:00:00&lt;/code&gt; was chosen is that it is 17,676,660 hours after &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;, and 17,676,660 is divisible by 10.</source>
          <target state="translated">Eso puede parecer confuso, dado que la hora (12) no es divisible por 10. La raz&amp;oacute;n por la que se &lt;code&gt;2016-07-17T12:00:00&lt;/code&gt; es que son 17,676,660 horas despu&amp;eacute;s de &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; , y 17.676.660 es divisible por 10.</target>
        </trans-unit>
        <trans-unit id="8eac926841ffd7462f202ab5376273deeb8cd2ba" translate="yes" xml:space="preserve">
          <source>That's all. This macro says that the literal contents of the string literal &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; should be passed to the &lt;code&gt;@r_str&lt;/code&gt; macro and the result of that expansion should be placed in the syntax tree where the string literal occurs. In other words, the expression &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; is equivalent to placing the following object directly into the syntax tree:</source>
          <target state="translated">Eso es todo. Esta macro dice que el contenido literal de la cadena literal &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; Debe pasarse a la macro &lt;code&gt;@r_str&lt;/code&gt; y el resultado de esa expansi&amp;oacute;n debe colocarse en el &amp;aacute;rbol de sintaxis donde la cadena literal ocurre. En otras palabras, la expresi&amp;oacute;n &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; Equivale a colocar el siguiente objeto directamente en el &amp;aacute;rbol de sintaxis:</target>
        </trans-unit>
        <trans-unit id="ececc5f47222691560cc9e3bee59dad9b3d640dc" translate="yes" xml:space="preserve">
          <source>The &quot;splat&quot; operator, &lt;code&gt;...&lt;/code&gt;, represents a sequence of arguments. &lt;code&gt;...&lt;/code&gt; can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. &lt;code&gt;...&lt;/code&gt; can also be used to apply a function to a sequence of arguments.</source>
          <target state="translated">El operador &quot;splat&quot;, &lt;code&gt;...&lt;/code&gt; , representa una secuencia de argumentos. &lt;code&gt;...&lt;/code&gt; se puede utilizar en las definiciones de funciones para indicar que la funci&amp;oacute;n acepta un n&amp;uacute;mero arbitrario de argumentos. &lt;code&gt;...&lt;/code&gt; tambi&amp;eacute;n se puede utilizar para aplicar una funci&amp;oacute;n a una secuencia de argumentos.</target>
        </trans-unit>
        <trans-unit id="6e87b92b09ff210cf587ecb8ad71387d805a3837" translate="yes" xml:space="preserve">
          <source>The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value &lt;code&gt;0x04030201&lt;/code&gt;. Big-endian machines will contain the value &lt;code&gt;0x01020304&lt;/code&gt;.</source>
          <target state="translated">La marca de orden de bytes de 32 bits indica el orden de bytes nativo de la m&amp;aacute;quina host. Las m&amp;aacute;quinas Little-endian contendr&amp;aacute;n el valor &lt;code&gt;0x04030201&lt;/code&gt; . Las m&amp;aacute;quinas Big-endian contendr&amp;aacute;n el valor &lt;code&gt;0x01020304&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc0d418f0a58caa5e7b5119be0993120b5604ac3" translate="yes" xml:space="preserve">
          <source>The 32-bit floating-point literal expression &lt;code&gt;1.5f22&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;1.5&lt;/code&gt; multiplied by the variable &lt;code&gt;f22&lt;/code&gt;.</source>
          <target state="translated">La expresi&amp;oacute;n literal de coma flotante de 32 bits &lt;code&gt;1.5f22&lt;/code&gt; podr&amp;iacute;a interpretarse como el literal num&amp;eacute;rico &lt;code&gt;1.5&lt;/code&gt; multiplicado por la variable &lt;code&gt;f22&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0554b963c33c05a019079c25e9e8af324781e9db" translate="yes" xml:space="preserve">
          <source>The 5 allocations seen are from running the &lt;code&gt;@time&lt;/code&gt; macro itself in global scope. If we instead run the timing in a function, we can see that indeed no allocations are performed:</source>
          <target state="translated">Las 5 asignaciones que se ven provienen de ejecutar la macro &lt;code&gt;@time&lt;/code&gt; en s&amp;iacute; en el &amp;aacute;mbito global. Si, en cambio, ejecutamos la sincronizaci&amp;oacute;n en una funci&amp;oacute;n, podemos ver que de hecho no se realizan asignaciones:</target>
        </trans-unit>
        <trans-unit id="f454420e121c88ed4ff052968b927a4892010960" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.@NamedTuple&quot;&gt;&lt;code&gt;@NamedTuple&lt;/code&gt;&lt;/a&gt; macro can be used for conveniently declaring &lt;code&gt;NamedTuple&lt;/code&gt; types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dea49356c38a6636e3d8df6877285b62b149f3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.CoreLogging.shouldlog&quot;&gt;&lt;code&gt;Logging.shouldlog&lt;/code&gt;&lt;/a&gt; function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically. Most usefully, &lt;code&gt;shouldlog&lt;/code&gt; is passed an event &lt;code&gt;id&lt;/code&gt; which can be used to discard events early based on a cached predicate.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;#Base.CoreLogging.shouldlog&quot;&gt; &lt;code&gt;Logging.shouldlog&lt;/code&gt; &lt;/a&gt; se llama con el registrador actual, tomando informaci&amp;oacute;n m&amp;iacute;nima (nivel, m&amp;oacute;dulo, grupo, id) que se puede calcular est&amp;aacute;ticamente. Lo m&amp;aacute;s &amp;uacute;til es que a &lt;code&gt;shouldlog&lt;/code&gt; se le pasa un &lt;code&gt;id&lt;/code&gt; evento que se puede usar para descartar eventos en forma anticipada bas&amp;aacute;ndose en un predicado en cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="9817feb15ee575eea4a8ff720d63067615a333e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types implements arbitrary-precision floating point and integer arithmetic, respectively. For &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; the &lt;a href=&quot;https://www.mpfr.org/&quot;&gt;GNU MPFR library&lt;/a&gt; is used, and for &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; is used.</source>
          <target state="translated">Los tipos &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; implementan aritm&amp;eacute;tica de n&amp;uacute;meros enteros y de coma flotante de precisi&amp;oacute;n arbitraria, respectivamente. Para &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; la &lt;a href=&quot;https://www.mpfr.org/&quot;&gt;biblioteca GNU MPFR&lt;/a&gt; se utiliza, y por &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; el &lt;a href=&quot;https://gmplib.org&quot;&gt;m&amp;uacute;ltiple de precisi&amp;oacute;n aritm&amp;eacute;tica Biblioteca GNU (GMP)&lt;/a&gt; se utiliza.</target>
        </trans-unit>
        <trans-unit id="ad3f2b7adf33af93573e441a9559f7a7900079c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; functions ultimately call &lt;code&gt;show&lt;/code&gt; in order to write an object &lt;code&gt;x&lt;/code&gt; as a given &lt;code&gt;mime&lt;/code&gt; type to a given I/O stream &lt;code&gt;io&lt;/code&gt; (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type &lt;code&gt;T&lt;/code&gt;, it is only necessary to define a new &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;T&lt;/code&gt;, via: &lt;code&gt;show(io, ::MIME&quot;mime&quot;, x::T) = ...&lt;/code&gt;, where &lt;code&gt;mime&lt;/code&gt; is a MIME-type string and the function body calls &lt;a href=&quot;#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; (or similar) to write that representation of &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;io&lt;/code&gt;. (Note that the &lt;code&gt;MIME&quot;&quot;&lt;/code&gt; notation only supports literal strings; to construct &lt;code&gt;MIME&lt;/code&gt; types in a more flexible manner use &lt;code&gt;MIME{Symbol(&quot;&quot;)}&lt;/code&gt;.)</source>
          <target state="translated">Las funciones de &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt; &amp;uacute;ltima instancia llaman a &lt;code&gt;show&lt;/code&gt; para escribir un objeto &lt;code&gt;x&lt;/code&gt; como un tipo de &lt;code&gt;mime&lt;/code&gt; dado en un flujo de E / S dado &lt;code&gt;io&lt;/code&gt; (normalmente un b&amp;uacute;fer de memoria), si es posible. Para proporcionar una rica representaci&amp;oacute;n multimedia de un tipo &lt;code&gt;T&lt;/code&gt; definido por el usuario , solo es necesario definir un nuevo m&amp;eacute;todo &lt;code&gt;show&lt;/code&gt; para &lt;code&gt;T&lt;/code&gt; , a trav&amp;eacute;s de: &lt;code&gt;show(io, ::MIME&quot;mime&quot;, x::T) = ...&lt;/code&gt; , donde &lt;code&gt;mime&lt;/code&gt; es una cadena de tipo MIME y el cuerpo de la funci&amp;oacute;n llama a &lt;a href=&quot;#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; (o similar) para escribir esa representaci&amp;oacute;n de &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;io&lt;/code&gt; . (Tenga en cuenta que el &lt;code&gt;MIME&quot;&quot;&lt;/code&gt; la notaci&amp;oacute;n solo admite cadenas literales; para construir tipos &lt;code&gt;MIME&lt;/code&gt; de una manera m&amp;aacute;s flexible, use &lt;code&gt;MIME{Symbol(&quot;&quot;)}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="5436a7d5a656260665ad063d5ab1e6eff72c987d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.Rounding.RoundingMode&quot;&gt;&lt;code&gt;RoundingMode&lt;/code&gt;&lt;/a&gt;&lt;code&gt;r&lt;/code&gt; controls the direction of the rounding; the default is &lt;a href=&quot;#Base.Rounding.RoundNearest&quot;&gt;&lt;code&gt;RoundNearest&lt;/code&gt;&lt;/a&gt;, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that &lt;code&gt;round&lt;/code&gt; may give incorrect results if the global rounding mode is changed (see &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Los &lt;a href=&quot;#Base.Rounding.RoundingMode&quot;&gt; &lt;code&gt;RoundingMode&lt;/code&gt; &lt;/a&gt; &lt;code&gt;r&lt;/code&gt; controla la direcci&amp;oacute;n de redondeo; el valor predeterminado es &lt;a href=&quot;#Base.Rounding.RoundNearest&quot;&gt; &lt;code&gt;RoundNearest&lt;/code&gt; &lt;/a&gt; , que se redondea al n&amp;uacute;mero entero m&amp;aacute;s cercano, con empates (valores fraccionarios de 0,5) que se redondean al n&amp;uacute;mero entero par m&amp;aacute;s cercano. Tenga en cuenta que el &lt;code&gt;round&lt;/code&gt; puede dar resultados incorrectos si se cambia el modo de redondeo global (ver &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="36e18d121f5a838cc6709524d85e5f444560cd8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Dates.dayname&quot;&gt;&lt;code&gt;dayname&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.monthname&quot;&gt;&lt;code&gt;monthname&lt;/code&gt;&lt;/a&gt; methods can also take an optional &lt;code&gt;locale&lt;/code&gt; keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely &lt;a href=&quot;#Dates.dayabbr&quot;&gt;&lt;code&gt;dayabbr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.monthabbr&quot;&gt;&lt;code&gt;monthabbr&lt;/code&gt;&lt;/a&gt;. First the mapping is loaded into the &lt;code&gt;LOCALES&lt;/code&gt; variable:</source>
          <target state="translated">Los m&amp;eacute;todos &lt;a href=&quot;#Dates.dayname&quot;&gt; &lt;code&gt;dayname&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#Dates.monthname&quot;&gt; &lt;code&gt;monthname&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n pueden tomar una palabra clave de &lt;code&gt;locale&lt;/code&gt; opcional que se puede utilizar para devolver el nombre del d&amp;iacute;a o mes del a&amp;ntilde;o para otros idiomas / configuraciones regionales. Tambi&amp;eacute;n hay versiones de estas funciones que devuelven los nombres abreviados, a saber, &lt;a href=&quot;#Dates.dayabbr&quot;&gt; &lt;code&gt;dayabbr&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#Dates.monthabbr&quot;&gt; &lt;code&gt;monthabbr&lt;/code&gt; &lt;/a&gt; . Primero, el mapeo se carga en la variable &lt;code&gt;LOCALES&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b0ea31c9b36eaba5425ec694eab3ed041d8c9eef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Logging.Logging&quot;&gt;&lt;code&gt;Logging&lt;/code&gt;&lt;/a&gt; module provides a way to record the history and progress of a computation as a log of events. Events are created by inserting a logging statement into the source code, for example:</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;a href=&quot;#Logging.Logging&quot;&gt; &lt;code&gt;Logging&lt;/code&gt; &lt;/a&gt; proporciona una forma de registrar el historial y el progreso de un c&amp;aacute;lculo como un registro de eventos. Los eventos se crean insertando una declaraci&amp;oacute;n de registro en el c&amp;oacute;digo fuente, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="3c601dd00846e1bc1e44a6ddd894b45f7d42da42" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Logging.shouldlog&quot;&gt;&lt;code&gt;Logging.shouldlog&lt;/code&gt;&lt;/a&gt; function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically. Most usefully, &lt;code&gt;shouldlog&lt;/code&gt; is passed an event &lt;code&gt;id&lt;/code&gt; which can be used to discard events early based on a cached predicate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb88735d7a5a0928051c7ed6f644aff1c31082e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Rounding-functions&quot;&gt;Rounding functions&lt;/a&gt; take a type &lt;code&gt;T&lt;/code&gt; as an optional argument. For example, &lt;code&gt;round(Int,x)&lt;/code&gt; is a shorthand for &lt;code&gt;Int(round(x))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0d2cdace4e12d15a4692bf023ef78f32612455" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Rounding-functions-1&quot;&gt;Rounding functions&lt;/a&gt; take a type &lt;code&gt;T&lt;/code&gt; as an optional argument. For example, &lt;code&gt;round(Int,x)&lt;/code&gt; is a shorthand for &lt;code&gt;Int(round(x))&lt;/code&gt;.</source>
          <target state="translated">Las &lt;a href=&quot;#Rounding-functions-1&quot;&gt;funciones de redondeo&lt;/a&gt; toman un tipo &lt;code&gt;T&lt;/code&gt; como argumento opcional. Por ejemplo, &lt;code&gt;round(Int,x)&lt;/code&gt; es una abreviatura de &lt;code&gt;Int(round(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5eb87235a3e582308fdae141ff9f8e2932202086" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a vector &lt;code&gt;I&lt;/code&gt; of row indices, a vector &lt;code&gt;J&lt;/code&gt; of column indices, and a vector &lt;code&gt;V&lt;/code&gt; of stored values (this is also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;COO (coordinate) format&lt;/a&gt;). &lt;code&gt;sparse(I,J,V)&lt;/code&gt; then constructs a sparse matrix such that &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt;. The equivalent sparse vector constructor is &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt;&lt;code&gt;sparsevec&lt;/code&gt;&lt;/a&gt;, which takes the (row) index vector &lt;code&gt;I&lt;/code&gt; and the vector &lt;code&gt;V&lt;/code&gt; with the stored values and constructs a sparse vector &lt;code&gt;R&lt;/code&gt; such that &lt;code&gt;R[I[k]] = V[k]&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; es a menudo una forma pr&amp;aacute;ctica de construir matrices dispersas. Por ejemplo, para construir una matriz dispersa, podemos ingresar un vector &lt;code&gt;I&lt;/code&gt; de &amp;iacute;ndices de fila, un vector &lt;code&gt;J&lt;/code&gt; de &amp;iacute;ndices de columna y un vector &lt;code&gt;V&lt;/code&gt; de valores almacenados (esto tambi&amp;eacute;n se conoce como &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;formato COO (coordenadas)&lt;/a&gt; ). &lt;code&gt;sparse(I,J,V)&lt;/code&gt; luego construye una matriz dispersa tal que &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt; . El constructor de vector disperso equivalente es &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt; &lt;code&gt;sparsevec&lt;/code&gt; &lt;/a&gt; , que toma el vector &amp;iacute;ndice (fila) &lt;code&gt;I&lt;/code&gt; y el vector &lt;code&gt;V&lt;/code&gt; con los valores almacenados y construye un vector disperso &lt;code&gt;R&lt;/code&gt; tal que &lt;code&gt;R[I[k]] = V[k]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b105317bea9286064ba65c3dd65ad287bf9e16f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.@NamedTuple&quot;&gt;&lt;code&gt;@NamedTuple&lt;/code&gt;&lt;/a&gt; macro provides a more convenient &lt;code&gt;struct&lt;/code&gt;-like syntax for declaring &lt;code&gt;NamedTuple&lt;/code&gt; types via &lt;code&gt;key::Type&lt;/code&gt; declarations, where an omitted &lt;code&gt;::Type&lt;/code&gt; corresponds to &lt;code&gt;::Any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce4dd4aa2504c940aa48ceeab07c53ca96b6449" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt;&lt;code&gt;@eval&lt;/code&gt;&lt;/a&gt; macro rewrites this call to be precisely equivalent to the above longer versions. For longer blocks of generated code, the expression argument given to &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt;&lt;code&gt;@eval&lt;/code&gt;&lt;/a&gt; can be a block:</source>
          <target state="translated">La macro &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt; &lt;code&gt;@eval&lt;/code&gt; &lt;/a&gt; reescribe esta llamada para que sea exactamente equivalente a las versiones m&amp;aacute;s largas anteriores. Para bloques m&amp;aacute;s largos de c&amp;oacute;digo generado, el argumento de expresi&amp;oacute;n dado a &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt; &lt;code&gt;@eval&lt;/code&gt; &lt;/a&gt; puede ser un bloque:</target>
        </trans-unit>
        <trans-unit id="38ef0a3b168bd74d25880aec3b78cf19271d94b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.Enums.@enum&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/a&gt; macro makes use of &lt;code&gt;@__doc__&lt;/code&gt; to allow for documenting &lt;a href=&quot;../../base/base/index#Base.Enums.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;s. Examining its definition should serve as an example of how to use &lt;code&gt;@__doc__&lt;/code&gt; correctly.</source>
          <target state="translated">La macro &lt;a href=&quot;../../base/base/index#Base.Enums.@enum&quot;&gt; &lt;code&gt;@enum&lt;/code&gt; &lt;/a&gt; hace uso de &lt;code&gt;@__doc__&lt;/code&gt; para permitir la documentaci&amp;oacute;n de &lt;a href=&quot;../../base/base/index#Base.Enums.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; s. Examinar su definici&amp;oacute;n deber&amp;iacute;a servir como un ejemplo de c&amp;oacute;mo usar &lt;code&gt;@__doc__&lt;/code&gt; correctamente.</target>
        </trans-unit>
        <trans-unit id="acfadefe2bb6121d5e848cbd0b9afe7e8768d52d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function is used to produce an &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; that interrupts the normal flow of control.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;a href=&quot;../../base/base/index#Base.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; se utiliza para producir una &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt; que interrumpe el flujo normal de control.</target>
        </trans-unit>
        <trans-unit id="fd385b6cfaa8837c37589622c3c706028ad36f1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt; operator is another exception: &lt;code&gt;missing&lt;/code&gt; is considered as greater than any other value. This operator is used by &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, which therefore places &lt;code&gt;missing&lt;/code&gt; values after all other values.</source>
          <target state="translated">El operador &lt;a href=&quot;../../base/base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt; es otra excepci&amp;oacute;n: la &lt;code&gt;missing&lt;/code&gt; se considera mayor que cualquier otro valor. Este operador se utiliza por &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; , por lo que coloca &lt;code&gt;missing&lt;/code&gt; valores faltantes despu&amp;eacute;s de todos los dem&amp;aacute;s valores.</target>
        </trans-unit>
        <trans-unit id="4d17e67e8157d57768d314d2878bcbffb2b8fe95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; functions also apply to floating-point types:</source>
          <target state="translated">Las funciones &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n se aplican a los tipos de punto flotante:</target>
        </trans-unit>
        <trans-unit id="ebd60a4f944bf87ca60e53bffccdaf6c4d569a54" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; function confirms that the &quot;two&quot; constructed instances of &lt;code&gt;NoFields&lt;/code&gt; are actually one and the same. Singleton types are described in further detail &lt;a href=&quot;#man-singleton-types&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de73ba08a71f852e7d2733fa6dfed62a7f72340d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; function confirms that the &quot;two&quot; constructed instances of &lt;code&gt;NoFields&lt;/code&gt; are actually one and the same. Singleton types are described in further detail &lt;a href=&quot;#man-singleton-types-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; confirma que las &quot;dos&quot; instancias construidas de &lt;code&gt;NoFields&lt;/code&gt; son en realidad una y la misma. Los tipos de singleton se describen con m&amp;aacute;s detalle a &lt;a href=&quot;#man-singleton-types-1&quot;&gt;continuaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d77ec66ab2077f795aecb0927e53656b9c9cc945" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; constructor takes any number of arguments and creates a new symbol by concatenating their string representations together:</source>
          <target state="translated">El constructor de &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; toma cualquier n&amp;uacute;mero de argumentos y crea un nuevo s&amp;iacute;mbolo concatenando sus representaciones de cadena:</target>
        </trans-unit>
        <trans-unit id="414514dfacecedf70ecbd06d5fef52f6a37552e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa&lt;/code&gt;&lt;/a&gt; function tests if an object is of a given type and returns true or false:</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa&lt;/code&gt; &lt;/a&gt; prueba si un objeto es de un tipo determinado y devuelve verdadero o falso:</target>
        </trans-unit>
        <trans-unit id="bf1b3d1c04844d76b7ef3cb166b81958a1f65c08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; function</source>
          <target state="translated">La funci&amp;oacute;n de &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b96dfc29471c7f4e7faf38271fb34f184e922afa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt; function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, types are objects, they also have types, and we can ask what their types are:</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt; &lt;code&gt;typeof&lt;/code&gt; &lt;/a&gt; , que ya se utiliza a lo largo del manual en ejemplos, devuelve el tipo de su argumento. Dado que, como se se&amp;ntilde;al&amp;oacute; anteriormente, los tipos son objetos, tambi&amp;eacute;n tienen tipos, y podemos preguntar cu&amp;aacute;les son sus tipos:</target>
        </trans-unit>
        <trans-unit id="0d827a86b6df88cc411d1f3d30cdcddabf2bc33a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; keyword supports the same syntax as &lt;a href=&quot;../../base/base/index#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt;, but only operates on a single name at a time. It does not add modules to be searched the way &lt;code&gt;using&lt;/code&gt; does. &lt;code&gt;import&lt;/code&gt; also differs from &lt;code&gt;using&lt;/code&gt; in that functions imported using &lt;code&gt;import&lt;/code&gt; can be extended with new methods.</source>
          <target state="translated">La palabra clave &lt;a href=&quot;../../base/base/index#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; admite la misma sintaxis que &lt;a href=&quot;../../base/base/index#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt; , pero solo funciona con un nombre a la vez. No agrega m&amp;oacute;dulos para buscar como lo hace el &lt;code&gt;using&lt;/code&gt; . &lt;code&gt;import&lt;/code&gt; tambi&amp;eacute;n difiere de la &lt;code&gt;using&lt;/code&gt; en que las funciones importadas mediante la &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n se pueden ampliar con nuevos m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="fb6064acb840b23c310e96e72bfc362b78efc865" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; keyword supports the same syntax as &lt;a href=&quot;../../base/base/index#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt;. It does not add modules to be searched the way &lt;code&gt;using&lt;/code&gt; does. &lt;code&gt;import&lt;/code&gt; also differs from &lt;code&gt;using&lt;/code&gt; in that functions imported using &lt;code&gt;import&lt;/code&gt; can be extended with new methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec874bb7238b430b76f31f6a2f70602d5cd36c3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/c/index#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt; type is essentially a synonym for &lt;code&gt;Ptr{UInt8}&lt;/code&gt;, except the conversion to &lt;code&gt;Cstring&lt;/code&gt; throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator). If you are passing a &lt;code&gt;char*&lt;/code&gt; to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use &lt;code&gt;Ptr{UInt8}&lt;/code&gt; as the argument type. &lt;code&gt;Cstring&lt;/code&gt; can also be used as the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.</source>
          <target state="translated">El tipo &lt;a href=&quot;../../base/c/index#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; &lt;/a&gt; es esencialmente un sin&amp;oacute;nimo de &lt;code&gt;Ptr{UInt8}&lt;/code&gt; , excepto que la conversi&amp;oacute;n a &lt;code&gt;Cstring&lt;/code&gt; arroja un error si la cadena Julia contiene caracteres NUL incrustados (lo que har&amp;iacute;a que la cadena se truncara silenciosamente si la rutina C trata a NUL como terminador) . Si est&amp;aacute; pasando un &lt;code&gt;char*&lt;/code&gt; a una rutina C que no asume una terminaci&amp;oacute;n NUL (por ejemplo, porque pasa una longitud de cadena expl&amp;iacute;cita), o si sabe con certeza que su cadena de Julia no contiene NUL y desea omitir la verificaci&amp;oacute;n, puede usar &lt;code&gt;Ptr{UInt8}&lt;/code&gt; como tipo de argumento. &lt;code&gt;Cstring&lt;/code&gt; tambi&amp;eacute;n se puede utilizar como &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; tipo de retorno, pero en ese caso, obviamente, no introduce ning&amp;uacute;n control adicional y solo est&amp;aacute; destinado a mejorar la legibilidad de la llamada.</target>
        </trans-unit>
        <trans-unit id="2ca3ede71d20c319ef4b7f43097716ec7d74586d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt;&lt;code&gt;irange&lt;/code&gt; specifies indices of the sorted eigenvalues to search for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe5df294c64ae2bc17b6c645704bd7bc62ca16b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;Base.filter&lt;/code&gt;&lt;/a&gt; method can be used to obtain all valid dates/moments in a specified range:</source>
          <target state="translated">El m&amp;eacute;todo &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;Base.filter&lt;/code&gt; &lt;/a&gt; se puede utilizar para obtener todas las fechas / momentos v&amp;aacute;lidos en un rango espec&amp;iacute;fico:</target>
        </trans-unit>
        <trans-unit id="32116ae8c0495cf49f4c9c66e837a3e4255f5c44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/io-network/index#Base.dump&quot;&gt;&lt;code&gt;dump&lt;/code&gt;&lt;/a&gt; function provides indented and annotated display of &lt;code&gt;Expr&lt;/code&gt; objects:</source>
          <target state="translated">La funci&amp;oacute;n de &lt;a href=&quot;../../base/io-network/index#Base.dump&quot;&gt; &lt;code&gt;dump&lt;/code&gt; &lt;/a&gt; proporciona una visualizaci&amp;oacute;n con sangr&amp;iacute;a y anotaciones de objetos &lt;code&gt;Expr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="63e3ea8e88f5b981ca22a0c9f75818db8e88281d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt;&lt;code&gt;@threadcall&lt;/code&gt;&lt;/a&gt; macro addresses scenarios where we do not want a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to block the main Julia event loop. It schedules a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the threadpool is controlled via environment variable &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt;. While waiting for a free thread, and during function execution once a thread is available, the requesting task (on the main Julia event loop) yields to other tasks. Note that &lt;code&gt;@threadcall&lt;/code&gt; does not return till the execution is complete. From a user point of view, it is therefore a blocking call like other Julia APIs.</source>
          <target state="translated">La macro &lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt; &lt;code&gt;@threadcall&lt;/code&gt; &lt;/a&gt; aborda escenarios en los que no queremos que una &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; bloquee el bucle principal de eventos de Julia. Programa una funci&amp;oacute;n C para su ejecuci&amp;oacute;n en un hilo separado. Para ello, se utiliza un grupo de subprocesos con un tama&amp;ntilde;o predeterminado de 4. El tama&amp;ntilde;o del grupo de subprocesos se controla mediante la variable de entorno &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; . Mientras espera un hilo libre y durante la ejecuci&amp;oacute;n de la funci&amp;oacute;n una vez que un hilo est&amp;aacute; disponible, la tarea solicitante (en el bucle de eventos principal de Julia) cede el paso a otras tareas. Tenga en cuenta que &lt;code&gt;@threadcall&lt;/code&gt; no regresa hasta que se completa la ejecuci&amp;oacute;n. Por lo tanto, desde el punto de vista del usuario, es una llamada de bloqueo como otras API de Julia.</target>
        </trans-unit>
        <trans-unit id="c1836413cdf1d297fe2f1a01545184ccffbd9cb1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt;&lt;code&gt;@threadcall&lt;/code&gt;&lt;/a&gt; macro provides a way to avoid stalling execution in such a scenario. It schedules a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the threadpool is controlled via environment variable &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt;. While waiting for a free thread, and during function execution once a thread is available, the requesting task (on the main Julia event loop) yields to other tasks. Note that &lt;code&gt;@threadcall&lt;/code&gt; does not return until the execution is complete. From a user point of view, it is therefore a blocking call like other Julia APIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9980cd05996241c9e77ece29af3cb2e812c97a73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; type is a direct child type of &lt;code&gt;Any&lt;/code&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is its child. In turn, &lt;code&gt;Real&lt;/code&gt; has two children (it has more, but only two are shown here; we'll get to the others later): &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt;, separating the world into representations of integers and representations of real numbers. Representations of real numbers include, of course, floating-point types, but also include other types, such as rationals. Hence, &lt;code&gt;AbstractFloat&lt;/code&gt; is a proper subtype of &lt;code&gt;Real&lt;/code&gt;, including only floating-point representations of real numbers. Integers are further subdivided into &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt; varieties.</source>
          <target state="translated">El tipo &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; es un tipo hijo directo de &lt;code&gt;Any&lt;/code&gt; y &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; es su hijo. A su vez, &lt;code&gt;Real&lt;/code&gt; tiene dos hijos (tiene m&amp;aacute;s, pero aqu&amp;iacute; solo se muestran dos; llegaremos a los otros m&amp;aacute;s adelante): &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt; , separando el mundo en representaciones de enteros y representaciones de n&amp;uacute;meros reales. Las representaciones de n&amp;uacute;meros reales incluyen, por supuesto, tipos de punto flotante, pero tambi&amp;eacute;n incluyen otros tipos, como los racionales. Por lo tanto, &lt;code&gt;AbstractFloat&lt;/code&gt; es un subtipo adecuado de &lt;code&gt;Real&lt;/code&gt; , que incluye solo representaciones de punto flotante de n&amp;uacute;meros reales. Los n&amp;uacute;meros enteros se subdividen en &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt; variedades.</target>
        </trans-unit>
        <trans-unit id="baf410f301db00bfb07a3204858e468ec6990386" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; function blocks the calling task until some other task finishes. So for example if you type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61c350b843f41f66bd6a94fb06646bf09f7c269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method is called asynchronously in a separate task. The termination of this task signals that all requested workers have been launched. Hence the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; function MUST exit as soon as all the requested workers have been launched.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; se llama de forma asincr&amp;oacute;nica en una tarea separada. La finalizaci&amp;oacute;n de esta tarea indica que se han puesto en marcha todos los trabajadores solicitados. Por lo tanto, la funci&amp;oacute;n de &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; DEBE salir tan pronto como se hayan lanzado todos los trabajadores solicitados.</target>
        </trans-unit>
        <trans-unit id="e5928b30867a053dbff6206d1bc20c56f14e738b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method takes the following arguments:</source>
          <target state="translated">El m&amp;eacute;todo de &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; toma los siguientes argumentos:</target>
        </trans-unit>
        <trans-unit id="f3209cd500cde4d2208651c2f2fd51b7059c49bc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients&quot;&gt;literal numeric coefficient notation&lt;/a&gt; does not work when constructing a complex number from variables. Instead, the multiplication must be explicitly written out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b33ac485b0a3f8ebfda5064c9e3efc2a8bcfdcf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;literal numeric coefficient notation&lt;/a&gt; does not work when constructing a complex number from variables. Instead, the multiplication must be explicitly written out:</source>
          <target state="translated">La &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;notaci&amp;oacute;n de coeficiente num&amp;eacute;rico literal&lt;/a&gt; no funciona cuando se construye un n&amp;uacute;mero complejo a partir de variables. En cambio, la multiplicaci&amp;oacute;n debe escribirse expl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="caedc4f0f18d64cfcc829cf6a132a779a017790d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../strings/index#man-concatenation&quot;&gt;main argument&lt;/a&gt; against &lt;code&gt;+&lt;/code&gt; is that string concatenation is not commutative, while &lt;code&gt;+&lt;/code&gt; is generally used as a commutative operator. While the Julia community recognizes that other languages use different operators and &lt;code&gt;*&lt;/code&gt; may be unfamiliar for some users, it communicates certain algebraic properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="275af0000e44bc521cd56c3026533fc5cd78a5de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../strings/index#man-concatenation-1&quot;&gt;main argument&lt;/a&gt; against &lt;code&gt;+&lt;/code&gt; is that string concatenation is not commutative, while &lt;code&gt;+&lt;/code&gt; is generally used as a commutative operator. While the Julia community recognizes that other languages use different operators and &lt;code&gt;*&lt;/code&gt; may be unfamiliar for some users, it communicates certain algebraic properties.</source>
          <target state="translated">El &lt;a href=&quot;../strings/index#man-concatenation-1&quot;&gt;principal argumento en&lt;/a&gt; contra de &lt;code&gt;+&lt;/code&gt; es que la concatenaci&amp;oacute;n de cadenas no es conmutativa, mientras que &lt;code&gt;+&lt;/code&gt; se utiliza generalmente como operador conmutativo. Si bien la comunidad de Julia reconoce que otros lenguajes usan operadores diferentes y &lt;code&gt;*&lt;/code&gt; puede ser desconocido para algunos usuarios, comunica ciertas propiedades algebraicas.</target>
        </trans-unit>
        <trans-unit id="c14035985c996abe00f4042cc746b4176aab2201" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames package&lt;/a&gt; provides data frames.</source>
          <target state="translated">El &lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;paquete DataFrames&lt;/a&gt; proporciona marcos de datos.</target>
        </trans-unit>
        <trans-unit id="1d1ea15f36c87296348b2ee87ead9f02bdc36c83" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JunoLab/Traceur.jl&quot;&gt;Traceur&lt;/a&gt; package can help you find common performance problems in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ebf2c6b9c4eb22391edbc55310df1678b26195" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/MikeInnes/Traceur.jl&quot;&gt;Traceur&lt;/a&gt; package can help you find common performance problems in your code.</source>
          <target state="translated">El paquete &lt;a href=&quot;https://github.com/MikeInnes/Traceur.jl&quot;&gt;Traceur&lt;/a&gt; puede ayudarlo a encontrar problemas de rendimiento comunes en su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="09270743df4b19bd666f57937fe0296a7b3d369a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU Scientific Library&lt;/a&gt; (here assumed to be accessible through &lt;code&gt;:libgsl&lt;/code&gt;) defines an opaque pointer, &lt;code&gt;gsl_permutation *&lt;/code&gt;, as the return type of the C function &lt;code&gt;gsl_permutation_alloc&lt;/code&gt;. As user code never has to look inside the &lt;code&gt;gsl_permutation&lt;/code&gt; struct, the corresponding Julia wrapper simply needs a new type declaration, &lt;code&gt;gsl_permutation&lt;/code&gt;, that has no internal fields and whose sole purpose is to be placed in the type parameter of a &lt;code&gt;Ptr&lt;/code&gt; type. The return type of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is declared as &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, since the memory allocated and pointed to by &lt;code&gt;output_ptr&lt;/code&gt; is controlled by C (and not Julia).</source>
          <target state="translated">La &lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;biblioteca cient&amp;iacute;fica GNU&lt;/a&gt; (que aqu&amp;iacute; se supone que es accesible a trav&amp;eacute;s de &lt;code&gt;:libgsl&lt;/code&gt; ) define un puntero opaco, &lt;code&gt;gsl_permutation *&lt;/code&gt; , como el tipo de retorno de la funci&amp;oacute;n C &lt;code&gt;gsl_permutation_alloc&lt;/code&gt; . Como el c&amp;oacute;digo de usuario nunca tiene que buscar dentro de la estructura &lt;code&gt;gsl_permutation&lt;/code&gt; , el contenedor de Julia correspondiente simplemente necesita una nueva declaraci&amp;oacute;n de tipo, &lt;code&gt;gsl_permutation&lt;/code&gt; , que no tiene campos internos y cuyo &amp;uacute;nico prop&amp;oacute;sito es colocarse en el par&amp;aacute;metro de tipo de un tipo &lt;code&gt;Ptr&lt;/code&gt; . El tipo de retorno de &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; se declara como &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; , ya que la memoria asignada y apuntada por &lt;code&gt;output_ptr&lt;/code&gt; est&amp;aacute; controlado por C (y no Julia).</target>
        </trans-unit>
        <trans-unit id="a5024e48ba7e7691b4d6acf8617bee0fb07d889c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU Scientific Library&lt;/a&gt; (here assumed to be accessible through &lt;code&gt;:libgsl&lt;/code&gt;) defines an opaque pointer, &lt;code&gt;gsl_permutation *&lt;/code&gt;, as the return type of the C function &lt;code&gt;gsl_permutation_alloc&lt;/code&gt;. As user code never has to look inside the &lt;code&gt;gsl_permutation&lt;/code&gt; struct, the corresponding Julia wrapper simply needs a new type declaration, &lt;code&gt;gsl_permutation&lt;/code&gt;, that has no internal fields and whose sole purpose is to be placed in the type parameter of a &lt;code&gt;Ptr&lt;/code&gt; type. The return type of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is declared as &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, since the memory allocated and pointed to by &lt;code&gt;output_ptr&lt;/code&gt; is controlled by C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add9fe6066c4b3711f11f5e626b62cf52c5e5aee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; characters are still parsed as string interpolation or start of an escape sequence in docstrings too. The &lt;code&gt;raw&quot;&quot;&lt;/code&gt; string macro together with the &lt;code&gt;@doc&lt;/code&gt; macro can be used to avoid having to escape them. This is handy when the docstrings include LaTeX or Julia source code examples containing interpolation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ea3eda7ce888d73eff517a4ef953491525adf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; syntax is deprecated, use the &lt;code&gt;Ref{T}&lt;/code&gt; argument type instead.</source>
          <target state="translated">La sintaxis &lt;code&gt;&amp;amp;&lt;/code&gt; est&amp;aacute; obsoleta, use el tipo de argumento &lt;code&gt;Ref{T}&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="ff8eac00092307ddc7d1e59e50812b91cc8012ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;:&lt;/code&gt; operator in general means &quot;is a subtype of&quot;, and, used in declarations like this, declares the right-hand type to be an immediate supertype of the newly declared type. It can also be used in expressions as a subtype operator which returns &lt;code&gt;true&lt;/code&gt; when its left operand is a subtype of its right operand:</source>
          <target state="translated">El operador &lt;code&gt;&amp;lt;:&lt;/code&gt; en general significa &quot;es un subtipo de&quot; y, usado en declaraciones como esta, declara que el tipo de la derecha es un supertipo inmediato del tipo reci&amp;eacute;n declarado. Tambi&amp;eacute;n se puede usar en expresiones como un operador de subtipo que devuelve &lt;code&gt;true&lt;/code&gt; cuando su operando izquierdo es un subtipo de su operando derecho:</target>
        </trans-unit>
        <trans-unit id="1d1649fbe8e01a8ee7d8ead051328750570da1e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(:function, &quot;library&quot;)&lt;/code&gt; pair, return type, and input types must be literal constants (i.e., they can't be variables, but see &lt;a href=&quot;#Non-constant-Function-Specifications&quot;&gt;Non-constant Function Specifications&lt;/a&gt; below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462f03c3cade5b2449ca60ca2d04cc3130736218" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; delimiter can be used to separate command-line arguments intended for the script file from arguments intended for Julia:</source>
          <target state="translated">El delimitador &lt;code&gt;--&lt;/code&gt; se puede utilizar para separar los argumentos de la l&amp;iacute;nea de comandos destinados al archivo de script de los argumentos destinados a Julia:</target>
        </trans-unit>
        <trans-unit id="b62e329ad97e7f8cc85f80ec7eb642548e51e86b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; command line argument requires at least Julia 1.5. In older versions you must use the environment variable instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715fb1cbad5e27d977534841ecb00d2691680981" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;2x + y&lt;/code&gt; definition is only used in the first case, while the &lt;code&gt;2x - y&lt;/code&gt; definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt;, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. &lt;sup&gt;&lt;a href=&quot;#footnote-Clarke61&quot; id=&quot;citeref-Clarke61&quot;&gt;[Clarke61]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396147a6b9dfacff46d28874aadee188884bc052" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;2x + y&lt;/code&gt; definition is only used in the first case, while the &lt;code&gt;2x - y&lt;/code&gt; definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. &lt;a href=&quot;#footnote-Clarke61&quot;&gt;[Clarke61]&lt;/a&gt;</source>
          <target state="translated">La definici&amp;oacute;n &lt;code&gt;2x + y&lt;/code&gt; solo se usa en el primer caso, mientras que la definici&amp;oacute;n &lt;code&gt;2x - y&lt;/code&gt; se usa en los dem&amp;aacute;s. No se realiza ninguna conversi&amp;oacute;n o conversi&amp;oacute;n autom&amp;aacute;tica de argumentos de funci&amp;oacute;n: toda conversi&amp;oacute;n en Julia no es m&amp;aacute;gica y es completamente expl&amp;iacute;cita. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversi&amp;oacute;n y promoci&amp;oacute;n&lt;/a&gt; , sin embargo, muestra c&amp;oacute;mo la aplicaci&amp;oacute;n inteligente de tecnolog&amp;iacute;a suficientemente avanzada puede ser indistinguible de la magia. &lt;a href=&quot;#footnote-Clarke61&quot;&gt;[Clarke61]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="702c47148e007cd263dc6deb6727c14f26afb82e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; operator can be used to attach type annotations to expressions and variables in programs. There are two primary reasons to do this:</source>
          <target state="translated">El operador &lt;code&gt;::&lt;/code&gt; se puede usar para adjuntar anotaciones de tipo a expresiones y variables en programas. Hay dos razones principales para hacer esto:</target>
        </trans-unit>
        <trans-unit id="a4ee1c478f2612aec54bd174690fa6ea35ddb91f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;/code&gt; character has two syntactic purposes in Julia. The first form creates a &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;interned string&lt;/a&gt; used as one building-block of expressions:</source>
          <target state="translated">El car&amp;aacute;cter &lt;code&gt;:&lt;/code&gt; tiene dos prop&amp;oacute;sitos sint&amp;aacute;cticos en Julia. La primera forma crea un &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; , una &lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;cadena interna que se&lt;/a&gt; utiliza como un bloque de construcci&amp;oacute;n de expresiones:</target>
        </trans-unit>
        <trans-unit id="353d9f2d22e6c55c71578ee1d9f5c97d21c6a0cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:any&lt;/code&gt; argument is available as of Julia 1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c311a5c224de0110d74a449183e9149c5a0fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@assert&lt;/code&gt; macro makes great use of splicing into quoted expressions to simplify the manipulation of expressions inside the macro body.</source>
          <target state="translated">La macro &lt;code&gt;@assert&lt;/code&gt; hace un gran uso del empalme en expresiones entre comillas para simplificar la manipulaci&amp;oacute;n de expresiones dentro del cuerpo de la macro.</target>
        </trans-unit>
        <trans-unit id="801ed9019f04c0f8f529dacee5be7631d5e276fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@boundscheck&lt;/code&gt; annotation allows you, as a library writer, to opt-in to allowing &lt;em&gt;other code&lt;/em&gt; to remove your bounds checks with &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;. As noted there, the caller must verify&amp;mdash;using information they can access&amp;mdash;that their accesses are valid before using &lt;code&gt;@inbounds&lt;/code&gt;. For indexing into your &lt;a href=&quot;../arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; subclasses, for example, this involves checking the indices against its &lt;a href=&quot;../arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;code&gt;@boundscheck&lt;/code&gt; annotations should only be added to a &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; implementation after you are certain its behavior is correct.</source>
          <target state="translated">La anotaci&amp;oacute;n &lt;code&gt;@boundscheck&lt;/code&gt; le permite, como escritor de la biblioteca, optar por permitir que &lt;em&gt;otro c&amp;oacute;digo&lt;/em&gt; elimine sus controles de l&amp;iacute;mites con &lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt; . Como se indica all&amp;iacute;, la persona que llama debe verificar, utilizando informaci&amp;oacute;n a la que puede acceder, que sus accesos son v&amp;aacute;lidos antes de usar &lt;code&gt;@inbounds&lt;/code&gt; . Para indexar en sus subclases &lt;a href=&quot;../arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; , por ejemplo, esto implica comparar los &amp;iacute;ndices con su &lt;a href=&quot;../arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; . Por lo tanto, &lt;code&gt;@boundscheck&lt;/code&gt; anotaciones de @boundscheck solo deben agregarse a un &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; implementaci&amp;oacute;n despu&amp;eacute;s de estar seguro de que su comportamiento es correcto.</target>
        </trans-unit>
        <trans-unit id="ec599750f5ec83c5af3c5362e9301d9cdbbe1ec1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@doc&lt;/code&gt; macro associates its first argument with its second in a per-module dictionary called &lt;code&gt;META&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d04719fe4369bb879f4c27763dea9901ff5736f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@doc&lt;/code&gt; macro associates its first argument with its second in a per-module dictionary called &lt;code&gt;META&lt;/code&gt;. By default, documentation is expected to be written in Markdown, and the &lt;code&gt;doc&quot;&quot;&lt;/code&gt; string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.</source>
          <target state="translated">La macro &lt;code&gt;@doc&lt;/code&gt; asocia su primer argumento con su segundo en un diccionario por m&amp;oacute;dulo llamado &lt;code&gt;META&lt;/code&gt; . De forma predeterminada, se espera que la documentaci&amp;oacute;n est&amp;eacute; escrita en Markdown, y la macro de cadena &lt;code&gt;doc&quot;&quot;&lt;/code&gt; simplemente crea un objeto que representa el contenido de Markdown. En el futuro, es probable que haga cosas m&amp;aacute;s avanzadas, como permitir rutas de enlace o im&amp;aacute;genes relativas.</target>
        </trans-unit>
        <trans-unit id="3901521653150d23278fa27f787a9dbcf11d8111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@simd&lt;/code&gt; does not assert by default that the loop is completely free of loop-carried memory dependencies, which is an assumption that can easily be violated in generic code. If you are writing non-generic code, you can use &lt;code&gt;@simd ivdep for ... end&lt;/code&gt; to also assert that:</source>
          <target state="translated">El &lt;code&gt;@simd&lt;/code&gt; no lo hace de forma predeterminada afirman que el bucle est&amp;aacute; completamente libre de dependencias de memoria de bucle realizado, que es una suposici&amp;oacute;n que puede ser f&amp;aacute;cilmente violada en c&amp;oacute;digo gen&amp;eacute;rico. Si est&amp;aacute; escribiendo c&amp;oacute;digo no gen&amp;eacute;rico, puede usar &lt;code&gt;@simd ivdep for ... end&lt;/code&gt; para afirmar tambi&amp;eacute;n que:</target>
        </trans-unit>
        <trans-unit id="22755b36a58e8494f0fc686a468ea1d881c82d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test f(args...) key=val...&lt;/code&gt; form is equivalent to writing &lt;code&gt;@test f(args..., key=val...)&lt;/code&gt; which can be useful when the expression is a call using infix syntax such as approximate comparisons:</source>
          <target state="translated">La forma &lt;code&gt;@test f(args...) key=val...&lt;/code&gt; es equivalente a escribir &lt;code&gt;@test f(args..., key=val...)&lt;/code&gt; que puede ser &amp;uacute;til cuando la expresi&amp;oacute;n es una llamada usando sintaxis infija como comparaciones aproximadas:</target>
        </trans-unit>
        <trans-unit id="16c63b805f73cc977b60037a10997e30bb4b9947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test_broken f(args...) key=val...&lt;/code&gt; form works as for the &lt;code&gt;@test&lt;/code&gt; macro.</source>
          <target state="translated">La forma &lt;code&gt;@test_broken f(args...) key=val...&lt;/code&gt; funciona como para la macro &lt;code&gt;@test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abdc5ad65294f55eba9140a8f0b4f4933db8d022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test_skip f(args...) key=val...&lt;/code&gt; form works as for the &lt;code&gt;@test&lt;/code&gt; macro.</source>
          <target state="translated">La forma &lt;code&gt;@test_skip f(args...) key=val...&lt;/code&gt; funciona como para la macro &lt;code&gt;@test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d32bc610a43028740032f0894a8d5b65d4647e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@testset&lt;/code&gt; macro can be used to group tests into &lt;em&gt;sets&lt;/em&gt;. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a &lt;code&gt;TestSetException&lt;/code&gt;.</source>
          <target state="translated">La macro &lt;code&gt;@testset&lt;/code&gt; se puede utilizar para agrupar pruebas en &lt;em&gt;conjuntos&lt;/em&gt; . Se ejecutar&amp;aacute;n todas las pruebas de un conjunto de prueba y, al final del conjunto de prueba, se imprimir&amp;aacute; un resumen. Si alguna de las pruebas fall&amp;oacute;, o no se pudo evaluar debido a un error, el conjunto de pruebas arrojar&amp;aacute; una &lt;code&gt;TestSetException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e1109eb4b0b82fe1adad014b7f4cf1b1315fb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@threadcall&lt;/code&gt; macro is called in the same way as &lt;a href=&quot;../c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main &lt;code&gt;julia&lt;/code&gt; thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; environment variable and restarting the &lt;code&gt;julia&lt;/code&gt; process.</source>
          <target state="translated">La macro &lt;code&gt;@threadcall&lt;/code&gt; se llama de la misma manera que &lt;a href=&quot;../c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; pero hace el trabajo en un hilo diferente. Esto es &amp;uacute;til cuando desea llamar a una funci&amp;oacute;n de bloqueo de C sin que el hilo principal de &lt;code&gt;julia&lt;/code&gt; se bloquee. La concurrencia est&amp;aacute; limitada por el tama&amp;ntilde;o del grupo de subprocesos libuv, que por defecto es de 4 subprocesos, pero se puede aumentar configurando la variable de entorno &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; y reiniciando el proceso &lt;code&gt;julia&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be390301ffbdbbfe0c2a21aa488c727a5bb08d3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@threads&lt;/code&gt; Macro</source>
          <target state="translated">La macro &lt;code&gt;@threads&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3926862dd6a57d44f61884e7fbb13c9a98fc27be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@views&lt;/code&gt; macro only affects &lt;code&gt;array[...]&lt;/code&gt; expressions that appear explicitly in the given &lt;code&gt;expression&lt;/code&gt;, not array slicing that occurs in functions called by that code.</source>
          <target state="translated">La macro &lt;code&gt;@views&lt;/code&gt; solo afecta a las expresiones &lt;code&gt;array[...]&lt;/code&gt; que aparecen expl&amp;iacute;citamente en la &lt;code&gt;expression&lt;/code&gt; dada , no al corte de matriz que se produce en funciones llamadas por ese c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="744985bd7018fe47b7df392a0c9d1bf69ee2f566" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractArray&lt;/code&gt; type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; type should generally implement at least &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size(A)&lt;/code&gt;&lt;/a&gt; (returning an &lt;code&gt;Int&lt;/code&gt; tuple), &lt;code&gt;getindex(A,i)&lt;/code&gt; and &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt;&lt;/a&gt;; mutable arrays should also implement &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;. It is recommended that these operations have nearly constant time complexity, or technically &amp;Otilde;(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt;&lt;/a&gt; method, which is used to allocate a similar array for &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; and other out-of-place operations. No matter how an &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; is represented internally, &lt;code&gt;T&lt;/code&gt; is the type of object returned by &lt;em&gt;integer&lt;/em&gt; indexing (&lt;code&gt;A[1, ..., 1]&lt;/code&gt;, when &lt;code&gt;A&lt;/code&gt; is not empty) and &lt;code&gt;N&lt;/code&gt; should be the length of the tuple returned by &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. For more details on defining custom &lt;code&gt;AbstractArray&lt;/code&gt; implementations, see the &lt;a href=&quot;../interfaces/index#man-interface-array&quot;&gt;array interface guide in the interfaces chapter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1624bacdb2ea72aa9e204c460f79dbfffe8ac6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractArray&lt;/code&gt; type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; type should generally implement at least &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size(A)&lt;/code&gt;&lt;/a&gt; (returning an &lt;code&gt;Int&lt;/code&gt; tuple), &lt;code&gt;getindex(A,i)&lt;/code&gt; and &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt;&lt;/a&gt;; mutable arrays should also implement &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;. It is recommended that these operations have nearly constant time complexity, or technically &amp;Otilde;(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt;&lt;/a&gt; method, which is used to allocate a similar array for &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; and other out-of-place operations. No matter how an &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; is represented internally, &lt;code&gt;T&lt;/code&gt; is the type of object returned by &lt;em&gt;integer&lt;/em&gt; indexing (&lt;code&gt;A[1, ..., 1]&lt;/code&gt;, when &lt;code&gt;A&lt;/code&gt; is not empty) and &lt;code&gt;N&lt;/code&gt; should be the length of the tuple returned by &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. For more details on defining custom &lt;code&gt;AbstractArray&lt;/code&gt; implementations, see the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;array interface guide in the interfaces chapter&lt;/a&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;AbstractArray&lt;/code&gt; incluye cualquier cosa vagamente parecida a una matriz, y sus implementaciones pueden ser bastante diferentes de las matrices convencionales. Por ejemplo, los elementos pueden calcularse a pedido en lugar de almacenarse. Sin embargo, cualquier tipo concreto de &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; generalmente deber&amp;iacute;a implementar al menos &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size(A)&lt;/code&gt; &lt;/a&gt; (devolviendo una tupla &lt;code&gt;Int&lt;/code&gt; ), &lt;code&gt;getindex(A,i)&lt;/code&gt; y &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt; &lt;/a&gt; ; Las matrices mutables tambi&amp;eacute;n deber&amp;iacute;an implementar &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; . Se recomienda que estas operaciones tengan una complejidad de tiempo casi constante, o t&amp;eacute;cnicamente &amp;Otilde; (1) complejidad, ya que de lo contrario algunas funciones de la matriz pueden ser inesperadamente lentas. Los tipos de hormig&amp;oacute;n tambi&amp;eacute;n deber&amp;iacute;an proporcionar&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt; &lt;/a&gt; m&amp;eacute;todo, que se utiliza para asignar una matriz similar para&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; y otras operaciones fuera de lugar. No importa c&amp;oacute;mose represente internamenteun &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; es el tipo de objeto devuelto por&lt;em&gt; la&lt;/em&gt; indexaci&amp;oacute;n de&lt;em&gt; enteros&lt;/em&gt; ( &lt;code&gt;A[1, ..., 1]&lt;/code&gt; , cuando &lt;code&gt;A&lt;/code&gt; no est&amp;aacute; vac&amp;iacute;o) y &lt;code&gt;N&lt;/code&gt; debe ser la longitud del tupla devuelta por&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; . Para obtener m&amp;aacute;s detalles sobre la definici&amp;oacute;n deimplementaciones de &lt;code&gt;AbstractArray&lt;/code&gt; personalizadas, consulte la&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt; gu&amp;iacute;a de interfaz de matriz en el cap&amp;iacute;tulo de interfaces&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1a42131bfca003806ea94dc4875800e91fc9149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractChar&lt;/code&gt; type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the &lt;a href=&quot;#Base.codepoint&quot;&gt;&lt;code&gt;codepoint&lt;/code&gt;&lt;/a&gt; function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;, for example. New &lt;code&gt;T &amp;lt;: AbstractChar&lt;/code&gt; types should define a &lt;code&gt;codepoint(::T)&lt;/code&gt; method and a &lt;code&gt;T(::UInt32)&lt;/code&gt; constructor, at minimum.</source>
          <target state="translated">El tipo &lt;code&gt;AbstractChar&lt;/code&gt; es el supertipo de todas las implementaciones de caracteres en Julia. Un car&amp;aacute;cter representa un punto de c&amp;oacute;digo Unicode y se puede convertir en un n&amp;uacute;mero entero a trav&amp;eacute;s de la funci&amp;oacute;n de &lt;a href=&quot;#Base.codepoint&quot;&gt; &lt;code&gt;codepoint&lt;/code&gt; &lt;/a&gt; para obtener el valor num&amp;eacute;rico del punto de c&amp;oacute;digo, o construirse a partir del mismo n&amp;uacute;mero entero. Estos valores num&amp;eacute;ricos determinan c&amp;oacute;mo se comparan los caracteres con &lt;code&gt;&amp;lt;&lt;/code&gt; y &lt;code&gt;==&lt;/code&gt; , por ejemplo. Los nuevos tipos &lt;code&gt;T &amp;lt;: AbstractChar&lt;/code&gt; deben definir un m&amp;eacute;todo de &lt;code&gt;codepoint(::T)&lt;/code&gt; y un constructor &lt;code&gt;T(::UInt32)&lt;/code&gt; , como m&amp;iacute;nimo.</target>
        </trans-unit>
        <trans-unit id="1c7306a482beca890d3fe61802010a334de7540c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConfigEntry&lt;/code&gt; would look like the following:</source>
          <target state="translated">El &lt;code&gt;ConfigEntry&lt;/code&gt; se ver&amp;iacute;a como la siguiente:</target>
        </trans-unit>
        <trans-unit id="ba9c45997f3e5b0258d17d45edce07e2353ce6d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module approach tries to follow the simple principle of trying to change as little as possible when doing &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; arithmetic. This approach is also often known as &lt;em&gt;calendrical&lt;/em&gt; arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let's take a classic example: add 1 month to January 31st, 2014. What's the answer? Javascript will say &lt;a href=&quot;https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/&quot;&gt;March 3&lt;/a&gt; (assumes 31 days). PHP says &lt;a href=&quot;https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month&quot;&gt;March 2&lt;/a&gt; (assumes 30 days). The fact is, there is no right answer. In the &lt;code&gt;Dates&lt;/code&gt; module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.</source>
          <target state="translated">Las &lt;code&gt;Dates&lt;/code&gt; m&amp;oacute;dulo de intentos de aproximaci&amp;oacute;n a seguir el principio simple de tratar de cambiar lo menos posible cuando se hace &lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; o&lt;/a&gt; aritm&amp;eacute;tica. Este enfoque tambi&amp;eacute;n se conoce a menudo como aritm&amp;eacute;tica &lt;em&gt;calend&amp;aacute;rica&lt;/em&gt; o lo que probablemente adivinar&amp;iacute;a si alguien le preguntara el mismo c&amp;aacute;lculo en una conversaci&amp;oacute;n. &amp;iquest;Por qu&amp;eacute; tanto alboroto por esto? Tomemos un ejemplo cl&amp;aacute;sico: agregue 1 mes al 31 de enero de 2014. &amp;iquest;Cu&amp;aacute;l es la respuesta? Javascript dir&amp;aacute; &lt;a href=&quot;https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/&quot;&gt;el 3 de marzo&lt;/a&gt; (asume 31 d&amp;iacute;as). PHP dice &lt;a href=&quot;https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month&quot;&gt;2 de marzo&lt;/a&gt; (asume 30 d&amp;iacute;as). El hecho es que no hay una respuesta correcta. En el m&amp;oacute;dulo de &lt;code&gt;Dates&lt;/code&gt; , da el resultado del 28 de febrero. &amp;iquest;C&amp;oacute;mo se da cuenta de eso? Me gusta pensar en el cl&amp;aacute;sico juego de apuestas 7-7-7 en los casinos.</target>
        </trans-unit>
        <trans-unit id="f3b7289c36cdd40212d2c06b1045bb17b9239ebc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module provides the &lt;em&gt;adjuster&lt;/em&gt; API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; as input and return or &lt;em&gt;adjust to&lt;/em&gt; the first or last of the desired period relative to the input.</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;code&gt;Dates&lt;/code&gt; proporciona la API del &lt;em&gt;ajustador a&lt;/em&gt; trav&amp;eacute;s de varios m&amp;eacute;todos convenientes que ayudan a expresar las reglas temporales de manera simple y sucinta. El primer grupo de m&amp;eacute;todos de ajustador se ocupa de la primera y la &amp;uacute;ltima semana, mes, trimestre y a&amp;ntilde;o. Cada uno toma un solo &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; como entrada y regresa o se &lt;em&gt;ajusta al&lt;/em&gt; primero o al &amp;uacute;ltimo del per&amp;iacute;odo deseado en relaci&amp;oacute;n con la entrada.</target>
        </trans-unit>
        <trans-unit id="822dabd74f61866145ac5d6c2a28ae2c68643b5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module provides two types for working with dates: &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, representing day and millisecond precision, respectively; both are subtypes of the abstract &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;. The motivation for distinct types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don't have to be dealt with. For example, since the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; type only resolves to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Dates&lt;/code&gt; proporciona dos tipos para trabajar con fechas: &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; , que representan la precisi&amp;oacute;n del d&amp;iacute;a y milisegundos, respectivamente; ambos son subtipos del &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; abstracto . La motivaci&amp;oacute;n para los distintos tipos es simple: algunas operaciones son mucho m&amp;aacute;s simples, tanto en t&amp;eacute;rminos de c&amp;oacute;digo como de razonamiento mental, cuando no es necesario abordar las complejidades de mayor precisi&amp;oacute;n. Por ejemplo, dado que el tipo &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; solo se resuelve con la precisi&amp;oacute;n de una sola fecha (es decir, sin horas, minutos o segundos), las consideraciones normales para las zonas horarias, el horario de verano / verano y los segundos intercalares son innecesarios y se evitan.</target>
        </trans-unit>
        <trans-unit id="47e6ad22d3652de8f0079c299b50b93cf7e90cb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Docs&lt;/code&gt; module provides the &lt;code&gt;@doc&lt;/code&gt; macro which can be used to set and retrieve documentation metadata for Julia objects.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Docs&lt;/code&gt; proporciona la macro &lt;code&gt;@doc&lt;/code&gt; que se puede usar para configurar y recuperar metadatos de documentaci&amp;oacute;n para objetos Julia.</target>
        </trans-unit>
        <trans-unit id="6709d2ae00bff6f93afe9f0a943f4102d4f4b039" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Future&lt;/code&gt; module implements future behavior of already existing functions, which will replace the current version in a future release of Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21bb014706065802683533ccfbc183fd2f75ab09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GitHash&lt;/code&gt; of the target object of &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;GitHash&lt;/code&gt; del objeto de destino de la &lt;code&gt;tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3fa0171d91b22777ce2dc8384f8c21045a536e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JL_GC_POP&lt;/code&gt; call releases the references established by the previous &lt;code&gt;JL_GC_PUSH&lt;/code&gt;. Note that &lt;code&gt;JL_GC_PUSH&lt;/code&gt; stores references on the C stack, so it must be exactly paired with a &lt;code&gt;JL_GC_POP&lt;/code&gt; before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; was invoked.</source>
          <target state="translated">La llamada &lt;code&gt;JL_GC_POP&lt;/code&gt; libera las referencias establecidas por el &lt;code&gt;JL_GC_PUSH&lt;/code&gt; anterior . Tenga en cuenta que &lt;code&gt;JL_GC_PUSH&lt;/code&gt; almacena referencias en la pila C, por lo que debe emparejarse exactamente con un &lt;code&gt;JL_GC_POP&lt;/code&gt; antes de salir del alcance. Es decir, antes de que la funci&amp;oacute;n regrese o el flujo de control abandone el bloque en el que se invoc&amp;oacute; &lt;code&gt;JL_GC_PUSH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b348f9eede2ca6e62ca6337bddb047633174b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt;&lt;code&gt;DEPOT_PATH&lt;/code&gt;&lt;/a&gt; variable, which controls where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files.</source>
          <target state="translated">La variable de entorno &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; se utiliza para &lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt; &lt;code&gt;DEPOT_PATH&lt;/code&gt; &lt;/a&gt; variable global Julia DEPOT_PATH , que controla d&amp;oacute;nde el administrador de paquetes, as&amp;iacute; como los mecanismos de carga de c&amp;oacute;digo de Julia, buscan registros de paquetes, paquetes instalados, entornos con nombre, clones de repositorios, im&amp;aacute;genes de paquetes compilados en cach&amp;eacute; y configuraci&amp;oacute;n archivos.</target>
        </trans-unit>
        <trans-unit id="cec94ad32872cc8ab93d55723729ae88908f0085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt;&lt;code&gt;DEPOT_PATH&lt;/code&gt;&lt;/a&gt; variable, which controls where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, configuration files, and the default location of the REPL's history file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b53844bde8803b551065f9d379c45987bf2bcfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; variable, which determines which packages can be loaded via &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;using&lt;/code&gt; (see &lt;a href=&quot;../code-loading/index#Code-Loading&quot;&gt;Code Loading&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69afeb6e2b2ee8e42ee83f53cc80115effd30019" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; variable, which determines which packages can be loaded via &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;using&lt;/code&gt; (see &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;).</source>
          <target state="translated">La variable de entorno &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; se usa para &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; &lt;/a&gt; variable global Julia LOAD_PATH , que determina qu&amp;eacute; paquetes se pueden cargar mediante la &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n y el &lt;code&gt;using&lt;/code&gt; (consulte &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Carga de c&amp;oacute;digo&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="34bade2917d4a413edb80c43d8efdb3c090b4bcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profile&lt;/code&gt; module provides tools to help developers improve the performance of their code. When used, it takes measurements on running code, and produces output that helps you understand how much time is spent on individual line(s). The most common usage is to identify &quot;bottlenecks&quot; as targets for optimization.</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;code&gt;Profile&lt;/code&gt; proporciona herramientas para ayudar a los desarrolladores a mejorar el rendimiento de su c&amp;oacute;digo. Cuando se usa, toma medidas en el c&amp;oacute;digo en ejecuci&amp;oacute;n y produce resultados que le ayudan a comprender cu&amp;aacute;nto tiempo se dedica a las l&amp;iacute;neas individuales. El uso m&amp;aacute;s com&amp;uacute;n es identificar &quot;cuellos de botella&quot; como objetivos de optimizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dee6516fb82f5277170e1ea0a8d04d1ed4092fd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pub&lt;/code&gt; package is in the user depot, where packages installed by the user live. These are only available to the user who installed them.</source>
          <target state="translated">El paquete &lt;code&gt;Pub&lt;/code&gt; est&amp;aacute; en el dep&amp;oacute;sito del usuario, donde residen los paquetes instalados por el usuario. Estos solo est&amp;aacute;n disponibles para el usuario que los instal&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="351bc5d2c88b2e50ba19e5df5f7c41cf0b55e7ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Random&lt;/code&gt; module defines a customizable framework for obtaining random values that can address these issues. Each invocation of &lt;code&gt;rand&lt;/code&gt; generates a &lt;em&gt;sampler&lt;/em&gt; which can be customized with the above trade-offs in mind, by adding methods to &lt;code&gt;Sampler&lt;/code&gt;, which in turn can dispatch on the random number generator, the object that characterizes the distribution, and a suggestion for the number of repetitions. Currently, for the latter, &lt;code&gt;Val{1}&lt;/code&gt; (for a single sample) and &lt;code&gt;Val{Inf}&lt;/code&gt; (for an arbitrary number) are used, with &lt;code&gt;Random.Repetition&lt;/code&gt; an alias for both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c1397c7dbb153add27fc9553cd4c77cee5bc54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Regex()&lt;/code&gt; constructor may be used to create a valid regex string programmatically. This permits using the contents of string variables and other string operations when constructing the regex string. Any of the regex codes above can be used within the single string argument to &lt;code&gt;Regex()&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">El constructor &lt;code&gt;Regex()&lt;/code&gt; se puede utilizar para crear una cadena de expresiones regulares v&amp;aacute;lida mediante programaci&amp;oacute;n. Esto permite usar el contenido de las variables de cadena y otras operaciones de cadena al construir la cadena de expresiones regulares. Cualquiera de los c&amp;oacute;digos de expresiones regulares anteriores se puede usar dentro del argumento de cadena &amp;uacute;nica para &lt;code&gt;Regex()&lt;/code&gt; . Aqu&amp;iacute; hay unos ejemplos:</target>
        </trans-unit>
        <trans-unit id="db31bac9b865cc662808ada884b07e698cf41290" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SamplerSimple&lt;/code&gt; type is sufficient for most use cases with precomputed data. However, in order to demonstrate how to use custom sampler types, here we implement something similar to &lt;code&gt;SamplerSimple&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ca6d3bf4c447b201b63ae9bba284f7ce5a10d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StackTraces&lt;/code&gt; module provides simple stack traces that are both human readable and easy to use programmatically.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;StackTraces&lt;/code&gt; proporciona rastreos de pila simples que son legibles por humanos y f&amp;aacute;ciles de usar mediante programaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c7aa3a52368467c889b31b4e2156567453a420c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Test&lt;/code&gt; module provides simple &lt;em&gt;unit testing&lt;/em&gt; functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;code&gt;Test&lt;/code&gt; proporciona una funcionalidad de &lt;em&gt;prueba unitaria&lt;/em&gt; simple . La prueba unitaria es una forma de ver si su c&amp;oacute;digo es correcto al verificar que los resultados sean los esperados. Puede ser &amp;uacute;til asegurarse de que su c&amp;oacute;digo siga funcionando despu&amp;eacute;s de realizar los cambios, y puede usarse durante el desarrollo como una forma de especificar los comportamientos que debe tener su c&amp;oacute;digo cuando est&amp;eacute; completo.</target>
        </trans-unit>
        <trans-unit id="3a54216422a2392050b1e4b2adcb38fe041e32d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UTInstant&lt;/code&gt; represents a machine timeline based on UT time (1 day = one revolution of the earth). The &lt;code&gt;T&lt;/code&gt; is a &lt;code&gt;Period&lt;/code&gt; parameter that indicates the resolution or precision of the instant.</source>
          <target state="translated">El &lt;code&gt;UTInstant&lt;/code&gt; representa una l&amp;iacute;nea de tiempo de la m&amp;aacute;quina basada en el tiempo UT (1 d&amp;iacute;a = una revoluci&amp;oacute;n de la tierra). La &lt;code&gt;T&lt;/code&gt; es un par&amp;aacute;metro de &lt;code&gt;Period&lt;/code&gt; o que indica la resoluci&amp;oacute;n o precisi&amp;oacute;n del instante.</target>
        </trans-unit>
        <trans-unit id="f172eb4712d1e651ca4443a247edaddae0c02ffc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnitRange&lt;/code&gt;&lt;code&gt;irange&lt;/code&gt; specifies indices of the sorted eigenvalues to search for.</source>
          <target state="translated">Los &lt;code&gt;UnitRange&lt;/code&gt; &lt;code&gt;irange&lt;/code&gt; Especifica los &amp;iacute;ndices de los valores propios ordenados a buscar.</target>
        </trans-unit>
        <trans-unit id="ec153c629332b5ec9f45e8c540e2078292ed5e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;/code&gt; character should be escaped appropriately if the text is embedded in a Julia source code, for example, &lt;code&gt;&quot;``\\LaTeX`` syntax in a docstring.&quot;&lt;/code&gt;, since it is interpreted as a string literal. Alternatively, in order to avoid escaping, it is possible to use the &lt;code&gt;raw&lt;/code&gt; string macro together with the &lt;code&gt;@doc&lt;/code&gt; macro:</source>
          <target state="translated">El car&amp;aacute;cter &lt;code&gt;\&lt;/code&gt; debe escaparse de forma apropiada si el texto est&amp;aacute; incrustado en un c&amp;oacute;digo fuente de Julia, por ejemplo, &lt;code&gt;&quot;``\\LaTeX`` syntax in a docstring.&quot;&lt;/code&gt; , ya que se interpreta como una cadena literal. Alternativamente, para evitar escapar, es posible usar la macro de cadena sin &lt;code&gt;raw&lt;/code&gt; junto con la macro &lt;code&gt;@doc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="81508e7a2286289f4f9b4e988f086408435f8b86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;/code&gt; operation here performs the linear solution. The left-division operator is pretty powerful and it's easy to write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.</source>
          <target state="translated">La operaci&amp;oacute;n &lt;code&gt;\&lt;/code&gt; aqu&amp;iacute; realiza la soluci&amp;oacute;n lineal. El operador de divisi&amp;oacute;n a la izquierda es bastante poderoso y es f&amp;aacute;cil escribir c&amp;oacute;digo compacto y legible que sea lo suficientemente flexible como para resolver todo tipo de sistemas de ecuaciones lineales.</target>
        </trans-unit>
        <trans-unit id="70fe69b8656c0c45fea00d261b4a1573767bfc08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abstract type&lt;/code&gt; keyword introduces a new abstract type, whose name is given by &lt;code&gt;&amp;laquo;name&amp;raquo;&lt;/code&gt;. This name can be optionally followed by &lt;code&gt;&amp;lt;:&lt;/code&gt; and an already-existing type, indicating that the newly declared abstract type is a subtype of this &quot;parent&quot; type.</source>
          <target state="translated">La palabra clave de &lt;code&gt;abstract type&lt;/code&gt; introduce un nuevo tipo abstracto, cuyo nombre viene dado por &lt;code&gt;&amp;laquo;name&amp;raquo;&lt;/code&gt; . Este nombre puede ir seguido opcionalmente por &lt;code&gt;&amp;lt;:&lt;/code&gt; y un tipo ya existente, lo que indica que el tipo abstracto reci&amp;eacute;n declarado es un subtipo de este tipo &quot;principal&quot;.</target>
        </trans-unit>
        <trans-unit id="39c37e363f5430e97a4dfa887fff2d0a51efccac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alg&lt;/code&gt; keyword argument requires Julia 1.3 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9421706ce1251dd1a3a86cb4c9ef2ac4b3c269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allowed_types&lt;/code&gt; contains a bitmask of &lt;code&gt;LibGit2.Consts.GIT_CREDTYPE&lt;/code&gt; values specifying which authentication methods should be attempted.</source>
          <target state="translated">Los &lt;code&gt;allowed_types&lt;/code&gt; contienen una m&amp;aacute;scara de bits de valores &lt;code&gt;LibGit2.Consts.GIT_CREDTYPE&lt;/code&gt; que especifican qu&amp;eacute; m&amp;eacute;todos de autenticaci&amp;oacute;n deben intentarse.</target>
        </trans-unit>
        <trans-unit id="8b06ca131e63337ccd916fd14f532e8185770099" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;atol&lt;/code&gt; and &lt;code&gt;rtol&lt;/code&gt; keyword arguments requires at least Julia 1.1. In Julia 1.0 &lt;code&gt;rtol&lt;/code&gt; is available as a positional argument, but this will be deprecated in Julia 2.0.</source>
          <target state="translated">Los argumentos de las palabras clave &lt;code&gt;atol&lt;/code&gt; y &lt;code&gt;rtol&lt;/code&gt; requieren al menos Julia 1.1. En Julia 1.0, &lt;code&gt;rtol&lt;/code&gt; est&amp;aacute; disponible como argumento posicional, pero quedar&amp;aacute; obsoleto en Julia 2.0.</target>
        </trans-unit>
        <trans-unit id="8c5e3a41d3bdc968b371bacefc8b137db06a4e1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; argument is a pointer to an array of length &lt;code&gt;nmemb&lt;/code&gt;, with elements of &lt;code&gt;size&lt;/code&gt; bytes each. &lt;code&gt;compare&lt;/code&gt; is a callback function which takes pointers to two elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and returns an integer less/greater than zero if &lt;code&gt;a&lt;/code&gt; should appear before/after &lt;code&gt;b&lt;/code&gt; (or zero if any order is permitted).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a8f8106813dc53840cdd36136d9eb3701004f27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; argument is a pointer to an array of length &lt;code&gt;nmemb&lt;/code&gt;, with elements of &lt;code&gt;size&lt;/code&gt; bytes each. &lt;code&gt;compare&lt;/code&gt; is a callback function which takes pointers to two elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and returns an integer less/greater than zero if &lt;code&gt;a&lt;/code&gt; should appear before/after &lt;code&gt;b&lt;/code&gt; (or zero if any order is permitted). Now, suppose that we have a 1d array &lt;code&gt;A&lt;/code&gt; of values in Julia that we want to sort using the &lt;code&gt;qsort&lt;/code&gt; function (rather than Julia's built-in &lt;code&gt;sort&lt;/code&gt; function). Before we worry about calling &lt;code&gt;qsort&lt;/code&gt; and passing arguments, we need to write a comparison function that works for some arbitrary objects (which define &lt;code&gt;&amp;lt;&lt;/code&gt;):</source>
          <target state="translated">El argumento &lt;code&gt;base&lt;/code&gt; es un puntero a una matriz de longitud &lt;code&gt;nmemb&lt;/code&gt; , con elementos de &lt;code&gt;size&lt;/code&gt; bytes cada uno. &lt;code&gt;compare&lt;/code&gt; es una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que toma punteros a dos elementos &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; y devuelve un entero menor / mayor que cero si &lt;code&gt;a&lt;/code&gt; debe aparecer antes / despu&amp;eacute;s de &lt;code&gt;b&lt;/code&gt; (o cero si se permite cualquier orden). Ahora, suponga que tenemos una matriz 1d &lt;code&gt;A&lt;/code&gt; de valores en Julia que queremos ordenar usando la funci&amp;oacute;n &lt;code&gt;qsort&lt;/code&gt; (en lugar de la funci&amp;oacute;n de &lt;code&gt;sort&lt;/code&gt; incorporada de Julia ). Antes de preocuparnos por llamar a &lt;code&gt;qsort&lt;/code&gt; y pasando argumentos, necesitamos escribir una funci&amp;oacute;n de comparaci&amp;oacute;n que funcione para algunos objetos arbitrarios (que definen &lt;code&gt;&amp;lt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="2208a0a1e673c387c0482cabd9f5481f4d468aa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;baseline&lt;/code&gt; is the tree to be used for comparison to the working directory and index; defaults to HEAD.</source>
          <target state="translated">La &lt;code&gt;baseline&lt;/code&gt; es el &amp;aacute;rbol que se utilizar&amp;aacute; para la comparaci&amp;oacute;n con el directorio y el &amp;iacute;ndice de trabajo; por defecto es HEAD.</target>
        </trans-unit>
        <trans-unit id="2423af315b07d14dbe0beca5286d61ecc80d3806" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;blocksize&lt;/code&gt; keyword argument requires Julia 1.4 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b441ac8e59d2fd60c5cee59a3c67db4265556f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chnl&lt;/code&gt; object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed &lt;code&gt;Channel&lt;/code&gt; objects.</source>
          <target state="translated">El objeto &lt;code&gt;chnl&lt;/code&gt; se puede cerrar expl&amp;iacute;citamente independientemente de la finalizaci&amp;oacute;n de la tarea. La terminaci&amp;oacute;n de tareas no tiene ning&amp;uacute;n efecto sobre los objetos de &lt;code&gt;Channel&lt;/code&gt; ya cerrados .</target>
        </trans-unit>
        <trans-unit id="90a04897ae4361417810ae9870dce7c36f780876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cleanup&lt;/code&gt; option controls whether the process attempts to delete the returned path automatically when the process exits. Note that the &lt;code&gt;tempname&lt;/code&gt; function does not create any file or directory at the returned location, so there is nothing to cleanup unless you create a file or directory there. If you do and &lt;code&gt;clean&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; it will be deleted upon process termination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa868ba15d4c70e293eebe72c9574ee9fe6fe35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; declaration should only be used in global scope on globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a &lt;code&gt;const&lt;/code&gt; declaration solves this performance problem.</source>
          <target state="translated">La declaraci&amp;oacute;n &lt;code&gt;const&lt;/code&gt; solo debe usarse en el &amp;aacute;mbito global en globales. Es dif&amp;iacute;cil para el compilador optimizar el c&amp;oacute;digo que involucra variables globales, ya que sus valores (o incluso sus tipos) pueden cambiar en casi cualquier momento. Si una variable global no cambia, agregar una declaraci&amp;oacute;n &lt;code&gt;const&lt;/code&gt; ante resuelve este problema de rendimiento.</target>
        </trans-unit>
        <trans-unit id="5822b594c5a7a77089ae64b02006c257e39cc153" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;contains&lt;/code&gt; function requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b4a67ce4add4334b6cfa9f5f2082d426131b2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;convert&lt;/code&gt; function generally takes two arguments: the first is a type object and the second is a value to convert to that type. The returned value is the value converted to an instance of given type. The simplest way to understand this function is to see it in action:</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;convert&lt;/code&gt; generalmente toma dos argumentos: el primero es un objeto de tipo y el segundo es un valor para convertir a ese tipo. El valor devuelto es el valor convertido a una instancia de un tipo determinado. La forma m&amp;aacute;s sencilla de entender esta funci&amp;oacute;n es verla en acci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e7cb3fc07af13ab851df995a0b91fc4d68f51c39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;current&lt;/code&gt; status object may be a &lt;code&gt;StatStruct&lt;/code&gt;, an &lt;code&gt;EOFError&lt;/code&gt; (indicating the timeout elapsed), or some other &lt;code&gt;Exception&lt;/code&gt; subtype (if the &lt;code&gt;stat&lt;/code&gt; operation failed - for example, if the path does not exist).</source>
          <target state="translated">El objeto de estado &lt;code&gt;current&lt;/code&gt; puede ser un &lt;code&gt;StatStruct&lt;/code&gt; , un &lt;code&gt;EOFError&lt;/code&gt; (que indica el tiempo de espera transcurrido) o alg&amp;uacute;n otro subtipo de &lt;code&gt;Exception&lt;/code&gt; (si la operaci&amp;oacute;n &lt;code&gt;stat&lt;/code&gt; fall&amp;oacute;, por ejemplo, si la ruta no existe).</target>
        </trans-unit>
        <trans-unit id="940a17c26916de1b6351b6066b3e6217426d4df2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dest&lt;/code&gt; array must be distinct from the &lt;code&gt;src&lt;/code&gt; array (they cannot alias each other).</source>
          <target state="translated">La matriz &lt;code&gt;dest&lt;/code&gt; debe ser distinta de la matriz &lt;code&gt;src&lt;/code&gt; (no pueden alias entre s&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="611e9863b6fe56ca0563d7d25daad5883ed6f0ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dir&lt;/code&gt; keyword argument can be used to specify a working directory for the command.</source>
          <target state="translated">El argumento de la palabra clave &lt;code&gt;dir&lt;/code&gt; se puede utilizar para especificar un directorio de trabajo para el comando.</target>
        </trans-unit>
        <trans-unit id="a4bff47d996768873bcc39999935a98007b3cec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do x&lt;/code&gt; syntax creates an anonymous function with argument &lt;code&gt;x&lt;/code&gt; and passes it as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Similarly, &lt;code&gt;do a,b&lt;/code&gt; would create a two-argument anonymous function, and a plain &lt;code&gt;do&lt;/code&gt; would declare that what follows is an anonymous function of the form &lt;code&gt;() -&amp;gt; ...&lt;/code&gt;.</source>
          <target state="translated">La sintaxis &lt;code&gt;do x&lt;/code&gt; crea una funci&amp;oacute;n an&amp;oacute;nima con el argumento &lt;code&gt;x&lt;/code&gt; y la pasa como primer argumento a &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; ear&lt;/a&gt; . Del mismo modo, &lt;code&gt;do a,b&lt;/code&gt; crear&amp;iacute;a una funci&amp;oacute;n an&amp;oacute;nima de dos argumentos, y una llanura &lt;code&gt;do&lt;/code&gt; declarar&amp;iacute;a que lo que sigue es una funci&amp;oacute;n an&amp;oacute;nima de la forma &lt;code&gt;() -&amp;gt; ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38f76b197c154b053fc67ebe8a0b86d9c54ffd48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used. The condition expressions in the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; construct are evaluated until the first one evaluates to &lt;code&gt;true&lt;/code&gt;, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.</source>
          <target state="translated">Los bloques &lt;code&gt;elseif&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; son opcionales y se pueden utilizar tantos bloques &lt;code&gt;elseif&lt;/code&gt; como se desee. Las expresiones de condici&amp;oacute;n en la construcci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; se eval&amp;uacute;an hasta que la primera se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; , despu&amp;eacute;s de lo cual se eval&amp;uacute;a el bloque asociado y no se eval&amp;uacute;an m&amp;aacute;s expresiones de condici&amp;oacute;n o bloques.</target>
        </trans-unit>
        <trans-unit id="dabea74759059aade9a04e98141814de885b1362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; where the logging macro occurs in the source code.</source>
          <target state="translated">El &lt;code&gt;file&lt;/code&gt; y la &lt;code&gt;line&lt;/code&gt; donde ocurre la macro de registro en el c&amp;oacute;digo fuente.</target>
        </trans-unit>
        <trans-unit id="40928cdd855b3408cd94e2ea60dca71441758515" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fn&lt;/code&gt; argument is a function that determines how to open a file with the given editor. It should take three arguments, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baef46876dcf6509194a8000268158d1d7c2494a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop makes common repeated evaluation idioms easier to write. Since counting up and down like the above &lt;code&gt;while&lt;/code&gt; loop does is so common, it can be expressed more concisely with a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">El bucle &lt;code&gt;for&lt;/code&gt; facilita la escritura de los modismos comunes de evaluaci&amp;oacute;n repetida. Dado que contar hacia arriba y hacia abajo como lo hace el bucle &lt;code&gt;while&lt;/code&gt; anterior es tan com&amp;uacute;n, se puede expresar de manera m&amp;aacute;s concisa con un bucle &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ee6a3346a6698b43646ee623779b34ee8b0963c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grow&lt;/code&gt; keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is &amp;lt; requested array size). Write privileges are required to grow the file.</source>
          <target state="translated">El argumento de la palabra clave &lt;code&gt;grow&lt;/code&gt; especifica si el archivo de disco debe crecer para adaptarse al tama&amp;ntilde;o solicitado de la matriz (si el tama&amp;ntilde;o total del archivo es &amp;lt;tama&amp;ntilde;o de la matriz solicitada). Se requieren privilegios de escritura para hacer crecer el archivo.</target>
        </trans-unit>
        <trans-unit id="944e976cee83757342402d268820319c708e7f02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello&lt;/code&gt; is the output of the &lt;code&gt;echo&lt;/code&gt; command, sent to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;. The run method itself returns &lt;code&gt;nothing&lt;/code&gt;, and throws an &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; if the external command fails to run successfully.</source>
          <target state="translated">El &lt;code&gt;hello&lt;/code&gt; es la salida del comando &lt;code&gt;echo&lt;/code&gt; , enviado a &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; . El m&amp;eacute;todo de ejecuci&amp;oacute;n en s&amp;iacute; &lt;code&gt;nothing&lt;/code&gt; devuelve nada y arroja una &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt; si el comando externo no se ejecuta correctamente.</target>
        </trans-unit>
        <trans-unit id="3728644266a88dfcc97848c625f08a3fe62768b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ipv6only&lt;/code&gt; parameter disables dual stack mode. If &lt;code&gt;ipv6only=true&lt;/code&gt;, only an IPv6 stack is created.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;ipv6only&lt;/code&gt; deshabilita el modo de pila dual. Si &lt;code&gt;ipv6only=true&lt;/code&gt; , solo se crea una pila IPv6.</target>
        </trans-unit>
        <trans-unit id="9a83013fd8954052be45bbcebac7dcd162b9bddd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;join&lt;/code&gt; and &lt;code&gt;sort&lt;/code&gt; keyword arguments require at least Julia 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9131ac4a45cc03434a2d1d252e0b9eb47948d016" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt;th diagonal of a matrix, as a vector.</source>
          <target state="translated">La &lt;code&gt;k&lt;/code&gt; - &amp;eacute;sima diagonal de una matriz, como vector.</target>
        </trans-unit>
        <trans-unit id="586747034b4744d9048e093e3d358be130046659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; block creates a new variable &lt;code&gt;r&lt;/code&gt; whose scope is only the inner function. The second technique recovers full language performance in the presence of captured variables. Note that this is a rapidly evolving aspect of the compiler, and it is likely that future releases will not require this degree of programmer annotation to attain performance. In the mean time, some user-contributed packages like &lt;a href=&quot;https://github.com/c42f/FastClosures.jl&quot;&gt;FastClosures&lt;/a&gt; automate the insertion of &lt;code&gt;let&lt;/code&gt; statements as in &lt;code&gt;abmult3&lt;/code&gt;.</source>
          <target state="translated">El bloque &lt;code&gt;let&lt;/code&gt; crea una nueva variable &lt;code&gt;r&lt;/code&gt; cuyo alcance es solo la funci&amp;oacute;n interna. La segunda t&amp;eacute;cnica recupera el rendimiento completo del lenguaje en presencia de variables capturadas. Tenga en cuenta que este es un aspecto del compilador que evoluciona r&amp;aacute;pidamente y es probable que las versiones futuras no requieran este grado de anotaci&amp;oacute;n del programador para lograr el rendimiento. Mientras tanto, algunos paquetes aportados por usuarios como &lt;a href=&quot;https://github.com/c42f/FastClosures.jl&quot;&gt;FastClosures&lt;/a&gt; automatizan la inserci&amp;oacute;n de sentencias &lt;code&gt;let&lt;/code&gt; como en &lt;code&gt;abmult3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="404db33b1806403679f9afdc7e45d8ad145e7ae6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; keywords can also be applied to destructuring assignments, e.g. &lt;code&gt;local x, y = 1, 2&lt;/code&gt;. In this case the keyword affects all listed variables.</source>
          <target state="translated">Las palabras clave &lt;code&gt;local&lt;/code&gt; es y &lt;code&gt;global&lt;/code&gt; es tambi&amp;eacute;n se pueden aplicar a asignaciones de desestructuraci&amp;oacute;n, por ejemplo, &lt;code&gt;local x, y = 1, 2&lt;/code&gt; . En este caso, la palabra clave afecta a todas las variables enumeradas.</target>
        </trans-unit>
        <trans-unit id="e6f28358dd1bfb5022d94e86f119a98a067084c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock&lt;/code&gt; argument is available as of Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90d836f6ddde99c9e10f3c6026b387d7de48843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock&lt;/code&gt; keyword argument controls whether operations will be locked for safe multi-threaded access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d442e907c59ccc9e130f30539a3ad937b37db4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loopback&lt;/code&gt; keyword argument dictates whether loopback addresses (e.g. &lt;code&gt;ip&quot;127.0.0.1&quot;&lt;/code&gt;, &lt;code&gt;ip&quot;::1&quot;&lt;/code&gt;) are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e455fac98bba78f84dcce75d6fd177f25053bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loopback&lt;/code&gt; keyword argument dictates whether loopback addresses are included.</source>
          <target state="translated">El argumento de la palabra clave de &lt;code&gt;loopback&lt;/code&gt; dicta si se incluyen las direcciones de loopback.</target>
        </trans-unit>
        <trans-unit id="43f03591f994b72dda2b585d5125cc1a285cbfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; in which the logging macro was expanded.</source>
          <target state="translated">El &lt;code&gt;module&lt;/code&gt; en el que se expandi&amp;oacute; la macro de registro.</target>
        </trans-unit>
        <trans-unit id="4522c3b2f49470689410e3676d64813c5ddeff60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt;-norm is defined as</source>
          <target state="translated">La &lt;code&gt;p&lt;/code&gt; -norm se define como</target>
        </trans-unit>
        <trans-unit id="e0a5498fb62d227e0dfc45c4ea76fe12397ce61d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parent&lt;/code&gt; and &lt;code&gt;cleanup&lt;/code&gt; arguments were added in 1.4. Prior to Julia 1.4 the path &lt;code&gt;tempname&lt;/code&gt; would never be cleaned up at process termination.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302ea1391975a513d95c23abf51eb7e6812df7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; argument is a string, regular expression, or an array of strings and regular expressions. For the &lt;code&gt;fn&lt;/code&gt; to be called, one of the patterns must match the value of &lt;code&gt;EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;JULIA_EDITOR&lt;/code&gt;. For strings, the string must equal the &lt;a href=&quot;../../base/file/index#Base.Filesystem.basename&quot;&gt;&lt;code&gt;basename&lt;/code&gt;&lt;/a&gt; of the first word of the editor command, with its extension, if any, removed. E.g. &quot;vi&quot; doesn't match &quot;vim -g&quot; but matches &quot;/usr/bin/vi -m&quot;; it also matches &lt;code&gt;vi.exe&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; is a regex it is matched against all of the editor command as a shell-escaped string. An array pattern matches if any of its items match. If multiple editors match, the one added most recently is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b88a0b1c328d1e6bd27b342609d1fb54652c60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;promote&lt;/code&gt; function converts all its arguments to a common type &amp;ndash; in this case &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition, the &lt;code&gt;Point&lt;/code&gt; constructor promotes its arguments the same way that numeric operators like &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; do, and works for all kinds of real numbers:</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;promote&lt;/code&gt; convierte todos sus argumentos a un tipo com&amp;uacute;n, en este caso &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; . Con esta definici&amp;oacute;n de m&amp;eacute;todo, el constructor &lt;code&gt;Point&lt;/code&gt; promueve sus argumentos de la misma manera que lo hacen los operadores num&amp;eacute;ricos como &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , y funciona para todo tipo de n&amp;uacute;meros reales:</target>
        </trans-unit>
        <trans-unit id="8297e1ed549bbae968b6d4d9056ddd08eaa6ab7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;promote_rule&lt;/code&gt; function is used as a building block to define a second function called &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which, given any number of type objects, returns the common type to which those values, as arguments to &lt;code&gt;promote&lt;/code&gt; should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use &lt;code&gt;promote_type&lt;/code&gt;:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;promote_rule&lt;/code&gt; se utiliza como un bloque de construcci&amp;oacute;n para definir una segunda funci&amp;oacute;n llamada &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; , que, dado cualquier n&amp;uacute;mero de objetos de tipo, devuelve el tipo com&amp;uacute;n al que se deben &lt;code&gt;promote&lt;/code&gt; esos valores, como argumentos para promover . Por lo tanto, si uno quiere saber, en ausencia de valores reales, a qu&amp;eacute; tipo se promover&amp;iacute;a una colecci&amp;oacute;n de valores de ciertos tipos, se puede usar &lt;code&gt;promote_type&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3b692555ebed7ff435cd42db277bcbc90f0f6b5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r&quot;...&quot;&lt;/code&gt; literal is constructed without interpolation and unescaping (except for quotation mark &lt;code&gt;&quot;&lt;/code&gt; which still has to be escaped). Here is an example showing the difference from standard string literals:</source>
          <target state="translated">El literal &lt;code&gt;r&quot;...&quot;&lt;/code&gt; se construye sin interpolaci&amp;oacute;n y sin escape (excepto por las comillas &lt;code&gt;&quot;&lt;/code&gt; que a&amp;uacute;n deben escaparse). A continuaci&amp;oacute;n, se muestra un ejemplo que muestra la diferencia con los literales de cadena est&amp;aacute;ndar:</target>
        </trans-unit>
        <trans-unit id="2a6072b422e59a959f8b81bd76474b677710288a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; Keyword</source>
          <target state="translated">La palabra clave de &lt;code&gt;return&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbd3a71fad13cb9858c23c4a3ef4f996112c52ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_type_numeric&lt;/code&gt; function behaves much like the &lt;code&gt;same_type&lt;/code&gt; function defined above, but is only defined for pairs of numbers.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;same_type_numeric&lt;/code&gt; se comporta de manera muy similar a la funci&amp;oacute;n &lt;code&gt;same_type&lt;/code&gt; definida anteriormente, pero solo se define para pares de n&amp;uacute;meros.</target>
        </trans-unit>
        <trans-unit id="82ca08e2caba29401264be1575cf38e6bdfde40e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schedule&lt;/code&gt; argument can be used to request a particular scheduling policy. The only currently supported value is &lt;code&gt;:static&lt;/code&gt;, which creates one task per thread and divides the iterations equally among them. Specifying &lt;code&gt;:static&lt;/code&gt; is an error if used from inside another &lt;code&gt;@threads&lt;/code&gt; loop or from a thread other than 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0faccd874b145bf90dea0ffa9ea23d2d84a128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schedule&lt;/code&gt; argument is available as of Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fab5a03f87c103ae23a4670919e1023dea2f659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; keyword argument specifies whether the resulting &lt;code&gt;Array&lt;/code&gt; and changes made to it will be visible to other processes mapping the same file.</source>
          <target state="translated">El argumento de palabra clave &lt;code&gt;shared&lt;/code&gt; especifica si el &lt;code&gt;Array&lt;/code&gt; resultante y los cambios realizados en &amp;eacute;l ser&amp;aacute;n visibles para otros procesos que mapean el mismo archivo.</target>
        </trans-unit>
        <trans-unit id="0931d123977915d4a1d899bba2683bbb5d1cf496" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shred&lt;/code&gt; keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to &lt;code&gt;false&lt;/code&gt; during testing.</source>
          <target state="translated">La palabra clave &lt;code&gt;shred&lt;/code&gt; controla si la informaci&amp;oacute;n confidencial en el campo de credenciales de carga &amp;uacute;til debe destruirse. Solo debe establecerse en &lt;code&gt;false&lt;/code&gt; durante la prueba.</target>
        </trans-unit>
        <trans-unit id="4faa585381b0ef3fd8f6f635485b6d01da652249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;spawn=&lt;/code&gt; parameter was added in Julia 1.3. This constructor was added in Julia 1.3. In earlier versions of Julia, Channel used keyword arguments to set &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;, but those constructors are deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd95653810075abbd2a6979c3286487161ebaa1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; object may be anything, and should be chosen appropriately for each iterable type. See the &lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration&quot;&gt;manual section on the iteration interface&lt;/a&gt; for more details about defining a custom iterable type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe58d87c8dd555b134b1d599492862c038b6d10f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; object may be anything, and should be chosen appropriately for each iterable type. See the &lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration-1&quot;&gt;manual section on the iteration interface&lt;/a&gt; for more details about defining a custom iterable type.</source>
          <target state="translated">El objeto de &lt;code&gt;state&lt;/code&gt; puede ser cualquier cosa y debe elegirse de manera apropiada para cada tipo iterable. Consulte la &lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration-1&quot;&gt;secci&amp;oacute;n&lt;/a&gt; del manual sobre la interfaz de iteraci&amp;oacute;n para obtener m&amp;aacute;s detalles sobre la definici&amp;oacute;n de un tipo iterable personalizado.</target>
        </trans-unit>
        <trans-unit id="197a5a1cfcc6bf414db454749ace6bc6b46270e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transcode&lt;/code&gt; function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;transcode&lt;/code&gt; tiene &amp;eacute;xito siempre que los datos de entrada puedan representarse razonablemente en la codificaci&amp;oacute;n de destino; siempre tiene &amp;eacute;xito para conversiones entre codificaciones UTF-XX, incluso para datos Unicode no v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="25bce1e285bcf1b8934e0d8620acac52150b4abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try/catch&lt;/code&gt; statement</source>
          <target state="translated">La declaraci&amp;oacute;n &lt;code&gt;try/catch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2c1155010a79df372e519698f4e8f431ee252c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try/catch&lt;/code&gt; statement allows for &lt;code&gt;Exception&lt;/code&gt;s to be tested for, and for the graceful handling of things that may ordinarily break your application. For example, in the below code the function for square root would normally throw an exception. By placing a &lt;code&gt;try/catch&lt;/code&gt; block around it we can mitigate that here. You may choose how you wish to handle this exception, whether logging it, return a placeholder value or as in the case below where we just printed out a statement. One thing to think about when deciding how to handle unexpected situations is that using a &lt;code&gt;try/catch&lt;/code&gt; block is much slower than using conditional branching to handle those situations. Below there are more examples of handling exceptions with a &lt;code&gt;try/catch&lt;/code&gt; block:</source>
          <target state="translated">La declaraci&amp;oacute;n &lt;code&gt;try/catch&lt;/code&gt; permite probar las &lt;code&gt;Exception&lt;/code&gt; y el manejo elegante de las cosas que normalmente pueden romper su aplicaci&amp;oacute;n. Por ejemplo, en el siguiente c&amp;oacute;digo, la funci&amp;oacute;n de ra&amp;iacute;z cuadrada normalmente arrojar&amp;iacute;a una excepci&amp;oacute;n. Al colocar un bloque &lt;code&gt;try/catch&lt;/code&gt; a su alrededor, podemos mitigar eso aqu&amp;iacute;. Puede elegir c&amp;oacute;mo desea manejar esta excepci&amp;oacute;n, ya sea registr&amp;aacute;ndola, devolviendo un valor de marcador de posici&amp;oacute;n o como en el caso a continuaci&amp;oacute;n, donde acabamos de imprimir una declaraci&amp;oacute;n. Una cosa en la que pensar al decidir c&amp;oacute;mo manejar situaciones inesperadas es que usar un bloque &lt;code&gt;try/catch&lt;/code&gt; es mucho m&amp;aacute;s lento que usar la ramificaci&amp;oacute;n condicional para manejar esas situaciones. A continuaci&amp;oacute;n, hay m&amp;aacute;s ejemplos de manejo de excepciones con un &lt;code&gt;try/catch&lt;/code&gt; bloquear:</target>
        </trans-unit>
        <trans-unit id="8de2b2884ad5c0d59519c41370d411d31e17c8aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointer &lt;code&gt;p&lt;/code&gt; to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">El prefijo &lt;code&gt;unsafe&lt;/code&gt; en esta funci&amp;oacute;n indica que no se realiza ninguna validaci&amp;oacute;n en el puntero &lt;code&gt;p&lt;/code&gt; para garantizar que sea v&amp;aacute;lido. El uso incorrecto puede da&amp;ntilde;ar o da&amp;ntilde;ar su programa, de la misma manera que C.</target>
        </trans-unit>
        <trans-unit id="1ad1cf514621d9bd7509c63edb01e709a946f374" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointer &lt;code&gt;p&lt;/code&gt; to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.</source>
          <target state="translated">El prefijo &lt;code&gt;unsafe&lt;/code&gt; en esta funci&amp;oacute;n indica que no se realiza ninguna validaci&amp;oacute;n en el puntero &lt;code&gt;p&lt;/code&gt; para garantizar que sea v&amp;aacute;lido. El uso incorrecto puede segmentar su programa o devolver respuestas basura, de la misma manera que C.</target>
        </trans-unit>
        <trans-unit id="ffd2fc5d018bc4147802a9ab69acc1302211d9d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointers &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">El prefijo &lt;code&gt;unsafe&lt;/code&gt; en esta funci&amp;oacute;n indica que no se realiza ninguna validaci&amp;oacute;n en los punteros &lt;code&gt;dest&lt;/code&gt; y &lt;code&gt;src&lt;/code&gt; para garantizar que sean v&amp;aacute;lidos. El uso incorrecto puede da&amp;ntilde;ar o da&amp;ntilde;ar su programa, de la misma manera que C.</target>
        </trans-unit>
        <trans-unit id="c545e57ea20b7dee78b3ead6faf2e0dd60dec4ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">El prefijo &lt;code&gt;unsafe&lt;/code&gt; en esta funci&amp;oacute;n indica que no se realiza ninguna validaci&amp;oacute;n para garantizar que N est&amp;eacute; dentro de los l&amp;iacute;mites de cualquiera de las matrices. El uso incorrecto puede da&amp;ntilde;ar o da&amp;ntilde;ar su programa, de la misma manera que C.</target>
        </trans-unit>
        <trans-unit id="f4d657f988d9e3352165918f5b958ddc6e9310c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that using the result of this function after the &lt;code&gt;x&lt;/code&gt; argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.</source>
          <target state="translated">El prefijo &lt;code&gt;unsafe&lt;/code&gt; en esta funci&amp;oacute;n indica que el uso del resultado de esta funci&amp;oacute;n despu&amp;eacute;s de que el argumento &lt;code&gt;x&lt;/code&gt; de esta funci&amp;oacute;n ya no sea accesible para el programa puede causar un comportamiento indefinido, incluida la corrupci&amp;oacute;n del programa o los segfaults, en cualquier momento posterior.</target>
        </trans-unit>
        <trans-unit id="1f00bb06127cf74d0a7a977235b45b41a807deea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;userdata&lt;/code&gt; field is used to store information for each worker by external managers.</source>
          <target state="translated">El campo de datos de &lt;code&gt;userdata&lt;/code&gt; se utiliza para almacenar informaci&amp;oacute;n de cada trabajador por parte de administradores externos.</target>
        </trans-unit>
        <trans-unit id="ea1c59c30ca45a88d468b07114183bcee1a4d149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; keyword creates a type that is an iterated union of other types, over all values of some variable. For example &lt;code&gt;Vector{T} where T&amp;lt;:Real&lt;/code&gt; includes all &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt;s where the element type is some kind of &lt;code&gt;Real&lt;/code&gt; number.</source>
          <target state="translated">La palabra clave &lt;code&gt;where&lt;/code&gt; crea un tipo que es una uni&amp;oacute;n iterada de otros tipos, sobre todos los valores de alguna variable. Por ejemplo, &lt;code&gt;Vector{T} where T&amp;lt;:Real&lt;/code&gt; incluye todos los &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt; donde el tipo de elemento es alg&amp;uacute;n tipo de n&amp;uacute;mero &lt;code&gt;Real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2963a52dada4be3a4b826619d947c135b0ff9a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; keyword itself can be nested inside a more complex declaration. For example, consider the two types created by the following declarations:</source>
          <target state="translated">La palabra clave &lt;code&gt;where&lt;/code&gt; en s&amp;iacute; se puede anidar dentro de una declaraci&amp;oacute;n m&amp;aacute;s compleja. Por ejemplo, considere los dos tipos creados por las siguientes declaraciones:</target>
        </trans-unit>
        <trans-unit id="998cd2a7738c69cc615469e2df80e3038aa7e4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; loop evaluates the condition expression (&lt;code&gt;i &amp;lt;= 5&lt;/code&gt; in this case), and as long it remains &lt;code&gt;true&lt;/code&gt;, keeps also evaluating the body of the &lt;code&gt;while&lt;/code&gt; loop. If the condition expression is &lt;code&gt;false&lt;/code&gt; when the &lt;code&gt;while&lt;/code&gt; loop is first reached, the body is never evaluated.</source>
          <target state="translated">El &lt;code&gt;while&lt;/code&gt; bucle eval&amp;uacute;a la expresi&amp;oacute;n de condici&amp;oacute;n ( &lt;code&gt;i &amp;lt;= 5&lt;/code&gt; en este caso), y mientras se mantiene &lt;code&gt;true&lt;/code&gt; , mantiene tambi&amp;eacute;n evaluar el cuerpo de la &lt;code&gt;while&lt;/code&gt; bucle. Si la expresi&amp;oacute;n de la condici&amp;oacute;n es &lt;code&gt;false&lt;/code&gt; cuando se alcanza por primera &lt;code&gt;while&lt;/code&gt; ciclo while, el cuerpo nunca se eval&amp;uacute;a.</target>
        </trans-unit>
        <trans-unit id="c9eac2e060f4090d788f5a1733519b89ab4b4ae0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;binomial coefficient&lt;/em&gt;$\binom{n}{k}$, being the coefficient of the $k$th term in the polynomial expansion of $(1+x)^n$.</source>
          <target state="translated">El &lt;em&gt;coeficiente binomial&lt;/em&gt; $ \ binom {n} {k} $, que es el coeficiente del t&amp;eacute;rmino $ k $ &amp;eacute;simo en la expansi&amp;oacute;n polinomial de $ (1 + x) ^ n $.</target>
        </trans-unit>
        <trans-unit id="5f58dd4e346415c12b8a2bde13968a9b1deff1c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;log level&lt;/em&gt; is a broad category for the message that is used for early filtering. There are several standard levels of type &lt;a href=&quot;#Base.CoreLogging.LogLevel&quot;&gt;&lt;code&gt;LogLevel&lt;/code&gt;&lt;/a&gt;; user-defined levels are also possible.</source>
          <target state="translated">El &lt;em&gt;nivel de registro&lt;/em&gt; es una categor&amp;iacute;a amplia para el mensaje que se utiliza para el filtrado temprano. Hay varios niveles est&amp;aacute;ndar de tipo &lt;a href=&quot;#Base.CoreLogging.LogLevel&quot;&gt; &lt;code&gt;LogLevel&lt;/code&gt; &lt;/a&gt; ; Tambi&amp;eacute;n son posibles niveles definidos por el usuario.</target>
        </trans-unit>
        <trans-unit id="3159599b94059581dc5ff890d9483fac4c0d5266" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;log level&lt;/em&gt; is a broad category for the message that is used for early filtering. There are several standard levels of type &lt;a href=&quot;#Logging.LogLevel&quot;&gt;&lt;code&gt;LogLevel&lt;/code&gt;&lt;/a&gt;; user-defined levels are also possible. Each is distinct in purpose:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="620317702e34b9f6f3d4d6b07a30259367383fd0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;message&lt;/em&gt; is an object describing the event. By convention &lt;code&gt;AbstractString&lt;/code&gt;s passed as messages are assumed to be in markdown format. Other types will be displayed using &lt;code&gt;print(io, obj)&lt;/code&gt; or &lt;code&gt;string(obj)&lt;/code&gt; for text-based output and possibly &lt;code&gt;show(io,mime,obj)&lt;/code&gt; for other multimedia displays used in the installed logger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fe1c7ad22ee14f0705951a3acf51f247460513" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;message&lt;/em&gt; is an object describing the event. By convention &lt;code&gt;AbstractString&lt;/code&gt;s passed as messages are assumed to be in markdown format. Other types will be displayed using &lt;code&gt;show(io,mime,obj)&lt;/code&gt; according to the display capabilities of the installed logger.</source>
          <target state="translated">El &lt;em&gt;mensaje&lt;/em&gt; es un objeto que describe el evento. Por convenci&amp;oacute;n, se supone que los mensajes &lt;code&gt;AbstractString&lt;/code&gt; pasados ​​como mensajes est&amp;aacute;n en formato de rebajas. Otros tipos se mostrar&amp;aacute;n usando &lt;code&gt;show(io,mime,obj)&lt;/code&gt; acuerdo con las capacidades de visualizaci&amp;oacute;n del registrador instalado.</target>
        </trans-unit>
        <trans-unit id="ff35386d12b40dc9ba6f11aed8e1486efcf6f63b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primary environment&lt;/em&gt;&amp;mdash;i.e. the first environment in a stack&amp;mdash;is faithfully embedded in a stacked environment. The full dependency graph of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all dependencies.</source>
          <target state="translated">El &lt;em&gt;entorno principal, es&lt;/em&gt; decir, el primer entorno de una pila, est&amp;aacute; fielmente integrado en un entorno apilado. Se garantiza que el gr&amp;aacute;fico de dependencia completo del primer entorno de una pila se incluir&amp;aacute; intacto en el entorno apilado, incluidas las mismas versiones de todas las dependencias.</target>
        </trans-unit>
        <trans-unit id="f56a5c0b72490015a89e1c362931e81a9ffdc753" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called &lt;code&gt;x&lt;/code&gt; without the two &lt;code&gt;x&lt;/code&gt;'s referring to the same thing. Similarly, there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn't refer to the same thing are called scope rules; this section spells them out in detail.</source>
          <target state="translated">El &lt;em&gt;alcance&lt;/em&gt; de una variable es la regi&amp;oacute;n de c&amp;oacute;digo dentro de la cual una variable es visible. El alcance variable ayuda a evitar conflictos de nombres de variables. El concepto es intuitivo: dos funciones pueden tener argumentos llamados &lt;code&gt;x&lt;/code&gt; sin que las dos &lt;code&gt;x&lt;/code&gt; se refieran a la misma cosa. De manera similar, hay muchos otros casos en los que diferentes bloques de c&amp;oacute;digo pueden usar el mismo nombre sin referirse a lo mismo. Las reglas para cuando el mismo nombre de variable se refiere o no a lo mismo se denominan reglas de alcance; esta secci&amp;oacute;n los detalla en detalle.</target>
        </trans-unit>
        <trans-unit id="e823801b39157cff5d7794c3183a7d1989add808" translate="yes" xml:space="preserve">
          <source>The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the &lt;code&gt;Random&lt;/code&gt; module. For example, it's typically sufficient to implement one &lt;code&gt;rand&lt;/code&gt; method in order to have all other usual methods work automatically.</source>
          <target state="translated">La API para 1) es bastante funcional, pero es relativamente reciente, por lo que es posible que a&amp;uacute;n tenga que evolucionar en versiones posteriores del m&amp;oacute;dulo &lt;code&gt;Random&lt;/code&gt; . Por ejemplo, normalmente es suficiente implementar un m&amp;eacute;todo &lt;code&gt;rand&lt;/code&gt; para que todos los dem&amp;aacute;s m&amp;eacute;todos habituales funcionen autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="8ab319b5b160e68efa740a64380d05f1be87039a" translate="yes" xml:space="preserve">
          <source>The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types of generated values.</source>
          <target state="translated">La API para el 2)sigue siendo rudimentaria y puede requerir más trabajo del estrictamente necesario por parte del ejecutor,a fin de soportar los tipos habituales de valores generados.</target>
        </trans-unit>
        <trans-unit id="c48202b29b3f0136388eb79e46b027ab787228ea" translate="yes" xml:space="preserve">
          <source>The API for atomic operations has not yet been finalized and is likely to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9630cea145272914a5264c86a31f652e4069fa" translate="yes" xml:space="preserve">
          <source>The API is not clearly defined yet, but as a rule of thumb:</source>
          <target state="translated">La API todavía no está claramente definida,pero como regla general:</target>
        </trans-unit>
        <trans-unit id="a2cac855dd1e1320bc002428689d4b74c6a1a9ec" translate="yes" xml:space="preserve">
          <source>The ASCII string &quot;DATA&quot; corresponds to the bytes 68, 65, 84, 65. &lt;code&gt;\xff&lt;/code&gt; produces the single byte 255. The Unicode escape &lt;code&gt;\u2200&lt;/code&gt; is encoded in UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte array does not correspond to a valid UTF-8 string:</source>
          <target state="translated">La cadena ASCII &quot;DATA&quot; corresponde a los bytes 68, 65, 84, 65. &lt;code&gt;\xff&lt;/code&gt; produce el byte &amp;uacute;nico 255. El escape Unicode &lt;code&gt;\u2200&lt;/code&gt; est&amp;aacute; codificado en UTF-8 como los tres bytes 226, 136, 128. Tenga en cuenta que el La matriz de bytes resultante no corresponde a una cadena UTF-8 v&amp;aacute;lida:</target>
        </trans-unit>
        <trans-unit id="39a538bac8d2eeb537bfbc18fea41895f84fba1e" translate="yes" xml:space="preserve">
          <source>The C &lt;code&gt;getenv&lt;/code&gt; function indicates an error by returning &lt;code&gt;NULL&lt;/code&gt;, but other standard C functions indicate errors in various different ways, including by returning -1, 0, 1 and other special values. This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent environment variable:</source>
          <target state="translated">La funci&amp;oacute;n C &lt;code&gt;getenv&lt;/code&gt; indica un error al devolver &lt;code&gt;NULL&lt;/code&gt; , pero otras funciones C est&amp;aacute;ndar indican errores de varias formas diferentes, incluso devolviendo -1, 0, 1 y otros valores especiales. Este contenedor arroja una excepci&amp;oacute;n que indica claramente el problema si la persona que llama intenta obtener una variable de entorno inexistente:</target>
        </trans-unit>
        <trans-unit id="bb0be6121167f43ded0796e444ece3ab2ece1c9f" translate="yes" xml:space="preserve">
          <source>The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array &lt;code&gt;result_array&lt;/code&gt;. This variable can only be used with corresponding input type declaration &lt;code&gt;Ref{Cdouble}&lt;/code&gt;, since its memory is allocated and managed by Julia, not C. The implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt;&lt;/a&gt; unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</source>
          <target state="translated">La funci&amp;oacute;n C envuelta devuelve un c&amp;oacute;digo de error entero; los resultados de la evaluaci&amp;oacute;n real de la funci&amp;oacute;n Bessel J pueblan la matriz de Julia &lt;code&gt;result_array&lt;/code&gt; . Esta variable solo se puede usar con la declaraci&amp;oacute;n de tipo de entrada correspondiente &lt;code&gt;Ref{Cdouble}&lt;/code&gt; , ya que su memoria es asignada y administrada por Julia, no C. La llamada impl&amp;iacute;cita a &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt; &lt;/a&gt; el puntero de Julia a un Estructura de datos de matriz de Julia en una forma comprensible para C.</target>
        </trans-unit>
        <trans-unit id="07b891ed69432f32d091d715fe2a8f62e3c9dfac" translate="yes" xml:space="preserve">
          <source>The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array &lt;code&gt;result_array&lt;/code&gt;. This variable is declared as a &lt;code&gt;Ref{Cdouble}&lt;/code&gt;, since its memory is allocated and managed by Julia. The implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt;&lt;/a&gt; unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e369993cdb5fa6e70590fdbba6d637a46744b422" translate="yes" xml:space="preserve">
          <source>The C null pointer constant, sometimes used when calling external code.</source>
          <target state="translated">La constante de puntero nulo C,a veces utilizada cuando se llama a un código externo.</target>
        </trans-unit>
        <trans-unit id="1266dcff3400e720f05ea76935c60007b496fe2d" translate="yes" xml:space="preserve">
          <source>The Darwin kernel descends from BSD, which means that &lt;code&gt;Sys.isbsd()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; on macOS systems. To exclude macOS from a predicate, use &lt;code&gt;Sys.isbsd() &amp;amp;&amp;amp; !Sys.isapple()&lt;/code&gt;.</source>
          <target state="translated">El kernel de Darwin desciende de BSD, lo que significa que &lt;code&gt;Sys.isbsd()&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; en los sistemas macOS. Para excluir macOS de un predicado, use &lt;code&gt;Sys.isbsd() &amp;amp;&amp;amp; !Sys.isapple()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d062d595ac22ed3de2b1695d4234bbdd4c8970f" translate="yes" xml:space="preserve">
          <source>The Examples folder &lt;code&gt;clustermanager/simple&lt;/code&gt; is an example that shows a simple implementation using UNIX domain sockets for cluster setup.</source>
          <target state="translated">La carpeta de ejemplos &lt;code&gt;clustermanager/simple&lt;/code&gt; es un ejemplo que muestra una implementaci&amp;oacute;n simple usando sockets de dominio UNIX para la configuraci&amp;oacute;n del cl&amp;uacute;ster.</target>
        </trans-unit>
        <trans-unit id="47538569b998ba670f072a1e4a838d9065a41d8f" translate="yes" xml:space="preserve">
          <source>The GC can be allowed to deallocate a variable by removing the reference to it from &lt;code&gt;refs&lt;/code&gt; using the function &lt;code&gt;delete!&lt;/code&gt;, provided that no other reference to the variable is kept anywhere:</source>
          <target state="translated">Se puede permitir que el GC desasigne una variable eliminando la referencia a ella de las &lt;code&gt;refs&lt;/code&gt; utilizando la funci&amp;oacute;n &lt;code&gt;delete!&lt;/code&gt; , siempre que no se mantenga ninguna otra referencia a la variable en ning&amp;uacute;n lugar:</target>
        </trans-unit>
        <trans-unit id="9114ec3ce1d9b68ea428c28233e88219f98a90cb" translate="yes" xml:space="preserve">
          <source>The GC can only run when Julia objects are allocated. Calls like &lt;code&gt;jl_box_float64&lt;/code&gt; perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between &lt;code&gt;jl_...&lt;/code&gt; calls. But in order to make sure that values can survive &lt;code&gt;jl_...&lt;/code&gt; calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; macros:</source>
          <target state="translated">El GC solo se puede ejecutar cuando se asignan objetos Julia. Las llamadas como &lt;code&gt;jl_box_float64&lt;/code&gt; realizan la asignaci&amp;oacute;n, y la asignaci&amp;oacute;n tambi&amp;eacute;n puede ocurrir en cualquier punto de la ejecuci&amp;oacute;n del c&amp;oacute;digo de Julia. Sin embargo, generalmente es seguro usar punteros entre llamadas &lt;code&gt;jl_...&lt;/code&gt; Pero para asegurarnos de que los valores puedan sobrevivir a las llamadas &lt;code&gt;jl_...&lt;/code&gt; , tenemos que decirle a Julia que tenemos una referencia a un valor de Julia. Esto se puede hacer usando las macros &lt;code&gt;JL_GC_PUSH&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b9622f1df591a3459173814aa7b8701ce73b0cc6" translate="yes" xml:space="preserve">
          <source>The GC can only run when Julia objects are allocated. Calls like &lt;code&gt;jl_box_float64&lt;/code&gt; perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between &lt;code&gt;jl_...&lt;/code&gt; calls. But in order to make sure that values can survive &lt;code&gt;jl_...&lt;/code&gt; calls, we have to tell Julia that we still hold a reference to Julia &lt;a href=&quot;https://www.cs.purdue.edu/homes/hosking/690M/p611-fenichel.pdf&quot;&gt;root&lt;/a&gt; values, a process called &quot;GC rooting&quot;. Rooting a value will ensure that the garbage collector does not accidentally identify this value as unused and free the memory backing that value. This can be done using the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; macros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c26097947d8e62d93e95f7bb8a753aa81198a0d" translate="yes" xml:space="preserve">
          <source>The Julia REPL</source>
          <target state="translated">La Julia REPL</target>
        </trans-unit>
        <trans-unit id="933a15ce4387b92a310db748193668c12bc6df9b" translate="yes" xml:space="preserve">
          <source>The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (&lt;code&gt;^D&lt;/code&gt; to exit, &lt;code&gt;^R&lt;/code&gt; and &lt;code&gt;^S&lt;/code&gt; for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so), or pressing Esc and then the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966cbe6fa0ef45947b54d91f086e0f21369273f7" translate="yes" xml:space="preserve">
          <source>The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (&lt;code&gt;^D&lt;/code&gt; to exit, &lt;code&gt;^R&lt;/code&gt; and &lt;code&gt;^S&lt;/code&gt; for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so).</source>
          <target state="translated">Julia REPL hace un gran uso de las combinaciones de teclas. Ya se introdujeron varias combinaciones de teclas de control anteriormente ( &lt;code&gt;^D&lt;/code&gt; para salir, &lt;code&gt;^R&lt;/code&gt; y &lt;code&gt;^S&lt;/code&gt; para buscar), pero hay muchas m&amp;aacute;s. Adem&amp;aacute;s de la tecla de control, tambi&amp;eacute;n hay enlaces de meta-teclas. &amp;Eacute;stos var&amp;iacute;an m&amp;aacute;s seg&amp;uacute;n la plataforma, pero la mayor&amp;iacute;a de los terminales utilizan de forma predeterminada alt o la opci&amp;oacute;n presionada con una tecla para enviar la meta-clave (o se pueden configurar para hacerlo).</target>
        </trans-unit>
        <trans-unit id="78a8d27e5d46846612931d336af5427fb48eaefb" translate="yes" xml:space="preserve">
          <source>The Julia internal variable &lt;a href=&quot;../../base/constants/index#Base.Sys.WORD_SIZE&quot;&gt;&lt;code&gt;Sys.WORD_SIZE&lt;/code&gt;&lt;/a&gt; indicates whether the target system is 32-bit or 64-bit:</source>
          <target state="translated">La variable interna de Julia &lt;a href=&quot;../../base/constants/index#Base.Sys.WORD_SIZE&quot;&gt; &lt;code&gt;Sys.WORD_SIZE&lt;/code&gt; &lt;/a&gt; indica si el sistema de destino es de 32 bits o de 64 bits:</target>
        </trans-unit>
        <trans-unit id="1693b1af11374cde64dabe11066916f7ee8e88c7" translate="yes" xml:space="preserve">
          <source>The Julia process running the driver script in the example above has an &lt;code&gt;id&lt;/code&gt; equal to 1, just like a process providing an interactive prompt.</source>
          <target state="translated">El proceso de Julia que ejecuta el script del controlador en el ejemplo anterior tiene una &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n igual a 1, al igual que un proceso que proporciona un mensaje interactivo.</target>
        </trans-unit>
        <trans-unit id="aa8416476707db541c2333530ff960a4433eec90" translate="yes" xml:space="preserve">
          <source>The Julian mode</source>
          <target state="translated">El modo Juliano</target>
        </trans-unit>
        <trans-unit id="6db1584071cd3b6081826f70375b838eede7d0f5" translate="yes" xml:space="preserve">
          <source>The LQ decomposition is the QR decomposition of &lt;code&gt;transpose(A)&lt;/code&gt;, and it is useful in order to compute the minimum-norm solution &lt;code&gt;lq(A) \ b&lt;/code&gt; to an underdetermined system of equations (&lt;code&gt;A&lt;/code&gt; has more columns than rows, but has full row rank).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c675577bb25cbb84233bfad40ea840727c87ba" translate="yes" xml:space="preserve">
          <source>The LQ decomposition is the QR decomposition of &lt;code&gt;transpose(A)&lt;/code&gt;.</source>
          <target state="translated">La descomposici&amp;oacute;n LQ es la descomposici&amp;oacute;n QR de la &lt;code&gt;transpose(A)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b05b84454661b0ad77fcf176c57484bf1c0a4367" translate="yes" xml:space="preserve">
          <source>The LibGit2 module provides bindings to &lt;a href=&quot;https://libgit2.org/&quot;&gt;libgit2&lt;/a&gt;, a portable C library that implements core functionality for the &lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt; version control system. These bindings are currently used to power Julia's package manager. It is expected that this module will eventually be moved into a separate package.</source>
          <target state="translated">El m&amp;oacute;dulo LibGit2 proporciona enlaces a &lt;a href=&quot;https://libgit2.org/&quot;&gt;libgit2&lt;/a&gt; , una biblioteca C port&amp;aacute;til que implementa la funcionalidad principal para el sistema de control de versiones de &lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt; . Estos enlaces se utilizan actualmente para impulsar el administrador de paquetes de Julia. Se espera que este m&amp;oacute;dulo eventualmente se traslade a un paquete separado.</target>
        </trans-unit>
        <trans-unit id="9bf2cc298d975bbd37b6f7fd047fb42694bf8a90" translate="yes" xml:space="preserve">
          <source>The MethodInstance containing the execution context (if it could be found).</source>
          <target state="translated">El MétodoInstancia que contiene el contexto de ejecución (si se pudo encontrar).</target>
        </trans-unit>
        <trans-unit id="09f175ba6c5dae9885fb192f636fd6ea181b8da1" translate="yes" xml:space="preserve">
          <source>The MultiSelectMenu allows users to select many choices from a list.</source>
          <target state="translated">El menú de selección múltiple permite a los usuarios seleccionar muchas opciones de una lista.</target>
        </trans-unit>
        <trans-unit id="e79dc73e951d809603b22dcb8e0be503a1e70e20" translate="yes" xml:space="preserve">
          <source>The Perl expression needs to be in single quotes for two reasons: so that spaces don't break the expression into multiple shell words, and so that uses of Perl variables like &lt;code&gt;$|&lt;/code&gt; (yes, that's the name of a variable in Perl), don't cause interpolation. In other instances, you may want to use double quotes so that interpolation &lt;em&gt;does&lt;/em&gt; occur:</source>
          <target state="translated">La expresi&amp;oacute;n de Perl debe estar entre comillas simples por dos razones: para que los espacios no dividan la expresi&amp;oacute;n en varias palabras de shell y para que se utilicen variables de Perl como &lt;code&gt;$|&lt;/code&gt; (s&amp;iacute;, ese es el nombre de una variable en Perl), no provoque interpolaci&amp;oacute;n. En otros casos, es posible que desee utilizar comillas dobles para que la interpolaci&amp;oacute;n &lt;em&gt;no&lt;/em&gt; se produzca:</target>
        </trans-unit>
        <trans-unit id="8c980de45243fb6623e03d7762f46ca10e22fb57" translate="yes" xml:space="preserve">
          <source>The REPL approximates being in the body of a function by deciding whether assignment inside the loop assigns to a global or creates new local based on whether a global variable by that name is defined or not. If a global by the name exists, then the assignment updates it. If no global exists, then the assignment creates a new local variable. In this example we see both cases in action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac56e6a222fd8496371258c1e3e6d866939f3927" translate="yes" xml:space="preserve">
          <source>The REPL has four main modes of operation. The first and most common is the Julian prompt. It is the default mode of operation; each new line initially starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt;. It is here that you can enter Julia expressions. Hitting return or enter after a complete expression has been entered will evaluate the entry and show the result of the last expression.</source>
          <target state="translated">El REPL tiene cuatro modos principales de funcionamiento. El primero y m&amp;aacute;s com&amp;uacute;n es el indicador juliano. Es el modo de funcionamiento predeterminado; cada nueva l&amp;iacute;nea comienza inicialmente con &lt;code&gt;julia&amp;gt;&lt;/code&gt; . Es aqu&amp;iacute; donde puede ingresar expresiones de Julia. Al presionar regresar o ingresar despu&amp;eacute;s de ingresar una expresi&amp;oacute;n completa, se evaluar&amp;aacute; la entrada y se mostrar&amp;aacute; el resultado de la &amp;uacute;ltima expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7b885d623b0799b11114ac06066f9470abd82025" translate="yes" xml:space="preserve">
          <source>The RadioMenu allows the user to select one option from the list. The &lt;code&gt;request&lt;/code&gt; function displays the interactive menu and returns the index of the selected choice. If a user presses 'q' or &lt;code&gt;ctrl-c&lt;/code&gt;, &lt;code&gt;request&lt;/code&gt; will return a &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">El RadioMenu permite al usuario seleccionar una opci&amp;oacute;n de la lista. La funci&amp;oacute;n de &lt;code&gt;request&lt;/code&gt; muestra el men&amp;uacute; interactivo y devuelve el &amp;iacute;ndice de la opci&amp;oacute;n seleccionada. Si un usuario presiona 'q' o &lt;code&gt;ctrl-c&lt;/code&gt; , la &lt;code&gt;request&lt;/code&gt; devolver&amp;aacute; un &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc95763180c94c043c7cbd64909fa3879451e300" translate="yes" xml:space="preserve">
          <source>The Stable version of Julia is the latest released version of Julia, this is the version most people will want to run. It has the latest features, including improved performance. The Stable version of Julia is versioned according to &lt;a href=&quot;https://semver.org/&quot;&gt;SemVer&lt;/a&gt; as v1.x.y. A new minor release of Julia corresponding to a new Stable version is made approximately every 4-5 months after a few weeks of testing as a release candidate. Unlike the LTS version the a Stable version will not normally recieve bugfixes after another Stable version of Julia has been released. However, upgrading to the next Stable release will always be possible as each release of Julia v1.x will continue to run code written for earlier versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e9b2d3e677af4a8fc2eebaa65445429cdf1c63" translate="yes" xml:space="preserve">
          <source>The Statistics module contains basic statistics functionality.</source>
          <target state="translated">El módulo de estadísticas contiene la funcionalidad básica de las estadísticas.</target>
        </trans-unit>
        <trans-unit id="a6cb2cfa7ad804a669566fbac23d8bb1a6bb5c00" translate="yes" xml:space="preserve">
          <source>The Statistics standard library module contains basic statistics functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d7e2a5c0d018541c4ea58100e6545824bf9830" translate="yes" xml:space="preserve">
          <source>The ability to define function behavior across many combinations of argument types via &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;</source>
          <target state="translated">La capacidad de definir el comportamiento de la funci&amp;oacute;n en muchas combinaciones de tipos de argumentos a trav&amp;eacute;s de &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;m&amp;uacute;ltiples env&amp;iacute;os&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cbecc736377010eae111d725b15330296dbcf5e" translate="yes" xml:space="preserve">
          <source>The above cross referencing is &lt;em&gt;not&lt;/em&gt; a Markdown feature, and relies on &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;Documenter.jl&lt;/a&gt;, which is used to build base Julia's documentation.</source>
          <target state="translated">La referencia cruzada anterior &lt;em&gt;no&lt;/em&gt; es una funci&amp;oacute;n de Markdown y se basa en &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;Documenter.jl&lt;/a&gt; , que se utiliza para crear la documentaci&amp;oacute;n base de Julia.</target>
        </trans-unit>
        <trans-unit id="96d64d7232abba83a2151348646c44806eda095b" translate="yes" xml:space="preserve">
          <source>The above mentioned functions can then be used to perform the queries:</source>
          <target state="translated">Las funciones mencionadas pueden utilizarse entonces para realizar las consultas:</target>
        </trans-unit>
        <trans-unit id="b1864a2a8cdc1de40a1915df6dd632015d943dc9" translate="yes" xml:space="preserve">
          <source>The above results are all &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. Literal &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; values can be entered by writing an &lt;code&gt;f&lt;/code&gt; in place of &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="translated">Los resultados anteriores son todos valores &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; valores literales de Float32 se pueden ingresar escribiendo una &lt;code&gt;f&lt;/code&gt; en lugar de &lt;code&gt;e&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8361f38beb9f62ba5d41300ac34886cea61348b7" translate="yes" xml:space="preserve">
          <source>The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies.</source>
          <target state="translated">Las mejoras sintácticas anteriores reducen significativamente el ruido visual que se produce al escribir fórmulas matemáticas comunes.Obsérvese que ningún espacio en blanco puede interponerse entre un coeficiente numérico literal y el identificador o la expresión entre paréntesis que multiplica.</target>
        </trans-unit>
        <trans-unit id="60fe34a8f000c3fae237bc0700dfba4695829533" translate="yes" xml:space="preserve">
          <source>The above would transfer &lt;code&gt;foo&lt;/code&gt; only once to each worker.</source>
          <target state="translated">Lo anterior transferir&amp;iacute;a &lt;code&gt;foo&lt;/code&gt; solo una vez a cada trabajador.</target>
        </trans-unit>
        <trans-unit id="b269bbaa9bb906bbb27460a932677dba11288dd6" translate="yes" xml:space="preserve">
          <source>The absolute path &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; of the REPL's history file. If &lt;code&gt;$JULIA_HISTORY&lt;/code&gt; is not set, then &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; defaults to</source>
          <target state="translated">La ruta absoluta &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; del archivo hist&amp;oacute;rico de REPL. Si &lt;code&gt;$JULIA_HISTORY&lt;/code&gt; no est&amp;aacute; configurado, entonces &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; defecto es</target>
        </trans-unit>
        <trans-unit id="3648e183f2c998051f65ea547854578d5a18dead" translate="yes" xml:space="preserve">
          <source>The absolute path of the directory containing the Julia executable, which sets the global variable &lt;a href=&quot;../../base/constants/index#Base.Sys.BINDIR&quot;&gt;&lt;code&gt;Sys.BINDIR&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;$JULIA_BINDIR&lt;/code&gt; is not set, then Julia determines the value &lt;code&gt;Sys.BINDIR&lt;/code&gt; at run-time.</source>
          <target state="translated">La ruta absoluta del directorio que contiene el ejecutable de Julia, que establece la variable global &lt;a href=&quot;../../base/constants/index#Base.Sys.BINDIR&quot;&gt; &lt;code&gt;Sys.BINDIR&lt;/code&gt; &lt;/a&gt; . Si no se establece &lt;code&gt;$JULIA_BINDIR&lt;/code&gt; , Julia determina el valor &lt;code&gt;Sys.BINDIR&lt;/code&gt; en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8927a0d24697e123dd4df5a3afe112eef67df6d2" translate="yes" xml:space="preserve">
          <source>The absolute path of the shell with which Julia should execute external commands (via &lt;code&gt;Base.repl_cmd()&lt;/code&gt;). Defaults to the environment variable &lt;code&gt;$SHELL&lt;/code&gt;, and falls back to &lt;code&gt;/bin/sh&lt;/code&gt; if &lt;code&gt;$SHELL&lt;/code&gt; is unset.</source>
          <target state="translated">La ruta absoluta del shell con la que Julia deber&amp;iacute;a ejecutar comandos externos (a trav&amp;eacute;s de &lt;code&gt;Base.repl_cmd()&lt;/code&gt; ). Tiene como valor predeterminado la variable de entorno &lt;code&gt;$SHELL&lt;/code&gt; y vuelve a &lt;code&gt;/bin/sh&lt;/code&gt; si &lt;code&gt;$SHELL&lt;/code&gt; est&amp;aacute; establecido.</target>
        </trans-unit>
        <trans-unit id="5eb992db79bc340c73f7d0c78a81caf2c5fb6b5d" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">El valor absoluto de &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc93eeda62c80f4972fdd152957671d0189f643" translate="yes" xml:space="preserve">
          <source>The abstract supertype of all enumerated types defined with &lt;a href=&quot;#Base.Enums.@enum&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El supertipo abstracto de todos los tipos enumerados definidos con &lt;a href=&quot;#Base.Enums.@enum&quot;&gt; &lt;code&gt;@enum&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="001842608bb84d463cf1f0db5f50ad22ca07a767" translate="yes" xml:space="preserve">
          <source>The actual argument values to be passed to the function, if any; each is a separate parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580f4961193cdce395b23ec3d5fef77701e0ce25" translate="yes" xml:space="preserve">
          <source>The actual body of the function is a single &lt;code&gt;leaq&lt;/code&gt; instruction, which computes the integer multiply and add at once. This is even more beneficial when &lt;code&gt;f&lt;/code&gt; gets inlined into another function:</source>
          <target state="translated">El cuerpo real de la funci&amp;oacute;n es una &amp;uacute;nica instrucci&amp;oacute;n &lt;code&gt;leaq&lt;/code&gt; , que calcula el n&amp;uacute;mero entero multiplicar y sumar a la vez. Esto es a&amp;uacute;n m&amp;aacute;s beneficioso cuando &lt;code&gt;f&lt;/code&gt; se inserta en otra funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="630238b36b114a948ff90dc6c02413e6edb7bf0d" translate="yes" xml:space="preserve">
          <source>The actual definition of &lt;code&gt;@assert&lt;/code&gt; in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments (&lt;a href=&quot;../functions/index#Varargs-Functions&quot;&gt;Varargs Functions&lt;/a&gt;), this is specified with an ellipses following the last argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18e2a05bc75f9cb445304a890f63b9983ea2e1c" translate="yes" xml:space="preserve">
          <source>The actual definition of &lt;code&gt;@assert&lt;/code&gt; in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;), this is specified with an ellipses following the last argument:</source>
          <target state="translated">La definici&amp;oacute;n real de &lt;code&gt;@assert&lt;/code&gt; en Julia Base es m&amp;aacute;s complicada. Permite al usuario especificar opcionalmente su propio mensaje de error, en lugar de simplemente imprimir la expresi&amp;oacute;n fallida. Al igual que en las funciones con un n&amp;uacute;mero variable de argumentos ( &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Funciones Varargs&lt;/a&gt; ), esto se especifica con puntos suspensivos despu&amp;eacute;s del &amp;uacute;ltimo argumento:</target>
        </trans-unit>
        <trans-unit id="3249b07e810b7bf455aef815d32c41a4e16eda1a" translate="yes" xml:space="preserve">
          <source>The addition of a &lt;code&gt;Date&lt;/code&gt; with a &lt;code&gt;Time&lt;/code&gt; produces a &lt;code&gt;DateTime&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;Time&lt;/code&gt; are used along with the year, month, and day of the &lt;code&gt;Date&lt;/code&gt; to create the new &lt;code&gt;DateTime&lt;/code&gt;. Non-zero microseconds or nanoseconds in the &lt;code&gt;Time&lt;/code&gt; type will result in an &lt;code&gt;InexactError&lt;/code&gt; being thrown.</source>
          <target state="translated">La adici&amp;oacute;n de una &lt;code&gt;Date&lt;/code&gt; con un &lt;code&gt;Time&lt;/code&gt; produce un &lt;code&gt;DateTime&lt;/code&gt; . La hora, minuto, segundo y milisegundo partes del &lt;code&gt;Time&lt;/code&gt; se utilizan junto con el a&amp;ntilde;o, mes y d&amp;iacute;a de la &lt;code&gt;Date&lt;/code&gt; para crear la nueva &lt;code&gt;DateTime&lt;/code&gt; . Los microsegundos o nanosegundos distintos de cero en el tipo de &lt;code&gt;Time&lt;/code&gt; dar&amp;aacute;n como resultado un &lt;code&gt;InexactError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3453c8422824806e0089fba52c363bf6cdb622f4" translate="yes" xml:space="preserve">
          <source>The adjoint operator &lt;code&gt;'&lt;/code&gt; in Julia returns an adjoint of a vector (a lazy representation of row vector), whereas the transpose operator &lt;code&gt;.T&lt;/code&gt; over a vector in Python returns the original vector (non-op).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0f2aeb81b016f9f8ad15cc7fa177089d4b107f" translate="yes" xml:space="preserve">
          <source>The advantage is that your testing code is now contained in a module and does not use the global scope in &lt;code&gt;Main&lt;/code&gt; for definitions, which is a bit more tidy.</source>
          <target state="translated">La ventaja es que su c&amp;oacute;digo de prueba ahora est&amp;aacute; contenido en un m&amp;oacute;dulo y no usa el alcance global en &lt;code&gt;Main&lt;/code&gt; para las definiciones, que es un poco m&amp;aacute;s ordenado.</target>
        </trans-unit>
        <trans-unit id="f20a70b4f6a41daccbadde162c2965a4719810ba" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">El algoritmo devuelve un estimador de la desviaci&amp;oacute;n est&amp;aacute;ndar de la distribuci&amp;oacute;n generativa bajo el supuesto de que cada entrada de &lt;code&gt;itr&lt;/code&gt; es un IID extra&amp;iacute;do de esa distribuci&amp;oacute;n generativa. Para matrices, este c&amp;aacute;lculo equivale a calcular &lt;code&gt;sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt; . Si &lt;code&gt;corrected&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces la suma se escala con &lt;code&gt;n-1&lt;/code&gt; , mientras que la suma se escala con &lt;code&gt;n&lt;/code&gt; si se &lt;code&gt;corrected&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; con &lt;code&gt;n&lt;/code&gt; el n&amp;uacute;mero de elementos en &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5d718f1e39513cb56beb2116bcad02f80b82c53" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If&lt;/code&gt;corrected&lt;code&gt;is&lt;/code&gt;true&lt;code&gt;, then the sum is scaled with&lt;/code&gt;n-1&lt;code&gt;, whereas the sum is scaled with&lt;/code&gt;n&lt;code&gt;if&lt;/code&gt;corrected&lt;code&gt;is&lt;/code&gt;false&lt;code&gt;with&lt;/code&gt;n&lt;code&gt;the number of elements in&lt;/code&gt;itr`.</source>
          <target state="translated">El algoritmo devuelve un estimador de la varianza de la distribuci&amp;oacute;n generativa bajo el supuesto de que cada entrada de &lt;code&gt;itr&lt;/code&gt; es un IID extra&amp;iacute;do de esa distribuci&amp;oacute;n generativa. Para matrices, este c&amp;aacute;lculo equivale a calcular la &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If&lt;/code&gt; corregido &lt;code&gt;is&lt;/code&gt; verdadero &lt;code&gt;, then the sum is scaled with&lt;/code&gt; n-1 &lt;code&gt;, whereas the sum is scaled with&lt;/code&gt; n &lt;code&gt;if&lt;/code&gt; corrige &lt;code&gt;is&lt;/code&gt; falso &lt;code&gt;with&lt;/code&gt; n &lt;code&gt;the number of elements in&lt;/code&gt; itr`.</target>
        </trans-unit>
        <trans-unit id="57033835ec26e53b58132bc74e3f700bdc54d641" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01293a961a773cd4d130208dbabeea56d0a5c61c" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">El algoritmo devuelve un estimador de la varianza de la distribuci&amp;oacute;n generativa bajo el supuesto de que cada entrada de &lt;code&gt;itr&lt;/code&gt; es un IID extra&amp;iacute;do de esa distribuci&amp;oacute;n generativa. Para matrices, este c&amp;aacute;lculo equivale a calcular la &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)&lt;/code&gt; . Si &lt;code&gt;corrected&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces la suma se escala con &lt;code&gt;n-1&lt;/code&gt; , mientras que la suma se escala con &lt;code&gt;n&lt;/code&gt; si se &lt;code&gt;corrected&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; con &lt;code&gt;n&lt;/code&gt; el n&amp;uacute;mero de elementos en &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa6e80fec84c6187fde0dd2ae7b8f5dc4c529c00" translate="yes" xml:space="preserve">
          <source>The alternative form &lt;code&gt;rethrow(e)&lt;/code&gt; allows you to associate an alternative exception object &lt;code&gt;e&lt;/code&gt; with the current backtrace. However this misrepresents the program state at the time of the error so you're encouraged to instead throw a new exception using &lt;code&gt;throw(e)&lt;/code&gt;. In Julia 1.1 and above, using &lt;code&gt;throw(e)&lt;/code&gt; will preserve the root cause exception on the stack, as described in &lt;a href=&quot;#Base.catch_stack&quot;&gt;&lt;code&gt;catch_stack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac2877c35123766a145f522e7dfc5430f0ca77c" translate="yes" xml:space="preserve">
          <source>The analogue of extracting (or &quot;dereferencing&quot;) all elements of a cell array, e.g. in &lt;code&gt;vertcat(A{:})&lt;/code&gt; in MATLAB, is written using the splat operator in Julia, e.g. as &lt;code&gt;vcat(A...)&lt;/code&gt;.</source>
          <target state="translated">El an&amp;aacute;logo de extraer (o &quot;desreferenciar&quot;) todos los elementos de una matriz de celdas, por ejemplo, en &lt;code&gt;vertcat(A{:})&lt;/code&gt; en MATLAB, se escribe usando el operador splat en Julia, por ejemplo, como &lt;code&gt;vcat(A...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3f2e21d1a797762aaea13aa49c6c7d374ab6e23" translate="yes" xml:space="preserve">
          <source>The annotation &lt;code&gt;@fastmath&lt;/code&gt; re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression &lt;code&gt;1 / (2*dx)&lt;/code&gt; in the function &lt;code&gt;deriv&lt;/code&gt; is hoisted out of the loop (i.e. calculated outside the loop), as if one had written &lt;code&gt;idx = 1 / (2*dx)&lt;/code&gt;. In the loop, the expression &lt;code&gt;... / (2*dx)&lt;/code&gt; then becomes &lt;code&gt;... * idx&lt;/code&gt;, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia's &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_native&quot;&gt;&lt;code&gt;code_native&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">La anotaci&amp;oacute;n &lt;code&gt;@fastmath&lt;/code&gt; reordena las expresiones de punto flotante, por ejemplo, cambiando el orden de evaluaci&amp;oacute;n o asumiendo que ciertos casos especiales (inf, nan) no pueden ocurrir. En este caso (y en esta computadora en particular), la principal diferencia es que la expresi&amp;oacute;n &lt;code&gt;1 / (2*dx)&lt;/code&gt; en la funci&amp;oacute;n &lt;code&gt;deriv&lt;/code&gt; a se saca del bucle (es decir, se calcula fuera del bucle), como si se hubiera escrito &lt;code&gt;idx = 1 / (2*dx)&lt;/code&gt; . En el ciclo, la expresi&amp;oacute;n &lt;code&gt;... / (2*dx)&lt;/code&gt; se convierte en &lt;code&gt;... * idx&lt;/code&gt; , que es mucho m&amp;aacute;s r&amp;aacute;pido de evaluar. Por supuesto, tanto la optimizaci&amp;oacute;n real que aplica el compilador como la aceleraci&amp;oacute;n resultante dependen en gran medida del hardware. Puede examinar el cambio en el c&amp;oacute;digo generado utilizando la funci&amp;oacute;n &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_native&quot;&gt; &lt;code&gt;code_native&lt;/code&gt; &lt;/a&gt; de Julia .</target>
        </trans-unit>
        <trans-unit id="91407676de179a11323fecebc90b0b28f6220397" translate="yes" xml:space="preserve">
          <source>The application also depends on the &lt;code&gt;Pub&lt;/code&gt; package, which in turn depends on the public &lt;code&gt;Priv&lt;/code&gt; and the same &lt;code&gt;Zebra&lt;/code&gt; package that the private &lt;code&gt;Priv&lt;/code&gt; package depends on.</source>
          <target state="translated">La aplicaci&amp;oacute;n tambi&amp;eacute;n depende del paquete &lt;code&gt;Pub&lt;/code&gt; , que a su vez depende del &lt;code&gt;Priv&lt;/code&gt; p&amp;uacute;blico y del mismo paquete &lt;code&gt;Zebra&lt;/code&gt; del que depende el paquete &lt;code&gt;Priv&lt;/code&gt; privado .</target>
        </trans-unit>
        <trans-unit id="d108508038e64416f7594e79cff0ba0d5c60ed1c" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;A&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt;&lt;code&gt;lu!&lt;/code&gt;&lt;/a&gt;), and performance-critical situations requiring &lt;code&gt;ldiv!&lt;/code&gt; usually also require fine-grained control over the factorization of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">El argumento &lt;code&gt;A&lt;/code&gt; &lt;em&gt;no&lt;/em&gt; deber&amp;iacute;a ser una matriz. M&amp;aacute;s bien, en lugar de matrices, deber&amp;iacute;a ser un objeto de factorizaci&amp;oacute;n (por ejemplo, producido por &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; ). La raz&amp;oacute;n de esto es que la factorizaci&amp;oacute;n en s&amp;iacute; es costosa y t&amp;iacute;picamente asigna memoria (aunque tambi&amp;eacute;n se puede hacer en el lugar a trav&amp;eacute;s de, por ejemplo, &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt; &lt;code&gt;lu!&lt;/code&gt; &lt;/a&gt; ), Y situaciones cr&amp;iacute;ticas de rendimiento que requieren &lt;code&gt;ldiv!&lt;/code&gt; por lo general tambi&amp;eacute;n requieren un control preciso sobre la factorizaci&amp;oacute;n de &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba5f6815e327ac58578c3c74637303b6ebdc780" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;B&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt;&lt;code&gt;lu!&lt;/code&gt;&lt;/a&gt;), and performance-critical situations requiring &lt;code&gt;rdiv!&lt;/code&gt; usually also require fine-grained control over the factorization of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">El argumento &lt;code&gt;B&lt;/code&gt; &lt;em&gt;no&lt;/em&gt; deber&amp;iacute;a ser una matriz. M&amp;aacute;s bien, en lugar de matrices, deber&amp;iacute;a ser un objeto de factorizaci&amp;oacute;n (por ejemplo, producido por &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; ). La raz&amp;oacute;n de esto es que la factorizaci&amp;oacute;n en s&amp;iacute; es costosa y, por lo general, asigna memoria (aunque tambi&amp;eacute;n se puede hacer en el lugar a trav&amp;eacute;s de, por ejemplo, &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt; &lt;code&gt;lu!&lt;/code&gt; &lt;/a&gt; ), Y situaciones cr&amp;iacute;ticas para el rendimiento que requieren &lt;code&gt;rdiv!&lt;/code&gt; por lo general tambi&amp;eacute;n requieren un control preciso sobre la factorizaci&amp;oacute;n de &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6947ba42284e98465ca0fe899c7260684fa80d0" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;__module__&lt;/code&gt; provides information (in the form of a &lt;code&gt;Module&lt;/code&gt; object) about the expansion context of the macro invocation. This allows macros to look up contextual information, such as existing bindings, or to insert the value as an extra argument to a runtime function call doing self-reflection in the current module.</source>
          <target state="translated">El argumento &lt;code&gt;__module__&lt;/code&gt; proporciona informaci&amp;oacute;n (en forma de un objeto &lt;code&gt;Module&lt;/code&gt; ) sobre el contexto de expansi&amp;oacute;n de la invocaci&amp;oacute;n de la macro. Esto permite a las macros buscar informaci&amp;oacute;n contextual, como enlaces existentes, o insertar el valor como un argumento adicional a una llamada de funci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n haciendo autorreflexi&amp;oacute;n en el m&amp;oacute;dulo actual.</target>
        </trans-unit>
        <trans-unit id="118cff9af4b8de3b0527244748b6b6cdd9ccdeb6" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;__source__&lt;/code&gt; provides information (in the form of a &lt;code&gt;LineNumberNode&lt;/code&gt; object) about the parser location of the &lt;code&gt;@&lt;/code&gt; sign from the macro invocation. This allows macros to include better error diagnostic information, and is commonly used by logging, string-parser macros, and docs, for example, as well as to implement the &lt;a href=&quot;../../base/file/index#Base.@__LINE__&quot;&gt;&lt;code&gt;@__LINE__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/file/index#Base.@__DIR__&quot;&gt;&lt;code&gt;@__DIR__&lt;/code&gt;&lt;/a&gt; macros.</source>
          <target state="translated">El argumento &lt;code&gt;__source__&lt;/code&gt; proporciona informaci&amp;oacute;n (en forma de un objeto &lt;code&gt;LineNumberNode&lt;/code&gt; ) sobre la ubicaci&amp;oacute;n del analizador del signo &lt;code&gt;@&lt;/code&gt; de la invocaci&amp;oacute;n de la macro. Esto permite que las macros incluyan mejor informaci&amp;oacute;n de diagn&amp;oacute;stico de errores, y se usa com&amp;uacute;nmente en registros, macros de analizador de cadenas y documentos, por ejemplo, as&amp;iacute; como para implementar las &lt;a href=&quot;../../base/file/index#Base.@__LINE__&quot;&gt; &lt;code&gt;@__LINE__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/file/index#Base.@__DIR__&quot;&gt; &lt;code&gt;@__DIR__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28332afec21b48c8f9eedddb529063711d48dde4" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;val&lt;/code&gt; to a function or constructor is outside the valid domain.</source>
          <target state="translated">El argumento &lt;code&gt;val&lt;/code&gt; para una funci&amp;oacute;n o constructor est&amp;aacute; fuera del dominio v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="c5eb1e5a4cdcda6110ebd89f0ecb14ceede7e9cb" translate="yes" xml:space="preserve">
          <source>The argument goes on the &lt;em&gt;left&lt;/em&gt; side of a matrix-matrix operation.</source>
          <target state="translated">El argumento va en el lado &lt;em&gt;izquierdo&lt;/em&gt; de una operaci&amp;oacute;n matriz-matriz.</target>
        </trans-unit>
        <trans-unit id="7b59a99385d1b11a2ad5b866d4ec7b5957c8ab4c" translate="yes" xml:space="preserve">
          <source>The argument goes on the &lt;em&gt;right&lt;/em&gt; side of a matrix-matrix operation.</source>
          <target state="translated">El argumento va en el lado &lt;em&gt;derecho&lt;/em&gt; de una operaci&amp;oacute;n matriz-matriz.</target>
        </trans-unit>
        <trans-unit id="1401afc18591a21d5a01e530b4ce757f985dd757" translate="yes" xml:space="preserve">
          <source>The arguments may be integer and rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="884d75c174d0479198ef02863fa90299587b8335" translate="yes" xml:space="preserve">
          <source>The array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)</source>
          <target state="translated">Los datos de la matriz deben representarse en formato binario (por ejemplo,no se puede admitir un formato ASCII como el CSV)</target>
        </trans-unit>
        <trans-unit id="b10872dab02eb4daf575beb40c2f7b4e9635a0b7" translate="yes" xml:space="preserve">
          <source>The asserted condition did not evaluate to &lt;code&gt;true&lt;/code&gt;. Optional argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">La condici&amp;oacute;n afirmada no se evalu&amp;oacute; como &lt;code&gt;true&lt;/code&gt; . El argumento opcional &lt;code&gt;msg&lt;/code&gt; es una cadena de error descriptiva.</target>
        </trans-unit>
        <trans-unit id="9ef046749eb00971a20635012815c9aa3fe8e4de" translate="yes" xml:space="preserve">
          <source>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like &lt;code&gt;let x = x&lt;/code&gt; since the two &lt;code&gt;x&lt;/code&gt; variables are distinct and have separate storage. Here is an example where the behavior of &lt;code&gt;let&lt;/code&gt; is needed:</source>
          <target state="translated">Las asignaciones se eval&amp;uacute;an en orden, con cada lado derecho evaluado en el alcance antes de que se haya introducido la nueva variable del lado izquierdo. Por lo tanto, tiene sentido escribir algo como &lt;code&gt;let x = x&lt;/code&gt; ya que las dos variables &lt;code&gt;x&lt;/code&gt; son distintas y tienen un almacenamiento separado. Aqu&amp;iacute; hay un ejemplo donde se necesita el comportamiento de &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="332e2ebabecf595b9a10dedb9752fafc32737dcf" translate="yes" xml:space="preserve">
          <source>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like &lt;code&gt;let x = x&lt;/code&gt;, since the two &lt;code&gt;x&lt;/code&gt; variables are distinct and have separate storage.</source>
          <target state="translated">Las asignaciones se eval&amp;uacute;an en orden, con cada lado derecho evaluado en el alcance antes de que se haya introducido la nueva variable del lado izquierdo. Por lo tanto, tiene sentido escribir algo como &lt;code&gt;let x = x&lt;/code&gt; , ya que las dos variables &lt;code&gt;x&lt;/code&gt; son distintas y tienen un almacenamiento separado.</target>
        </trans-unit>
        <trans-unit id="cb5c5acb0ed1217a3a242c8796f09db063ffe31c" translate="yes" xml:space="preserve">
          <source>The associativity of the reduction is implementation dependent. This means that you can't use non-associative operations like &lt;code&gt;-&lt;/code&gt; because it is undefined whether &lt;code&gt;reduce(-,[1,2,3])&lt;/code&gt; should be evaluated as &lt;code&gt;(1-2)-3&lt;/code&gt; or &lt;code&gt;1-(2-3)&lt;/code&gt;. Use &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt; instead for guaranteed left or right associativity.</source>
          <target state="translated">La asociatividad de la reducci&amp;oacute;n depende de la implementaci&amp;oacute;n. Esto significa que no puede usar operaciones no asociativas como &lt;code&gt;-&lt;/code&gt; porque no est&amp;aacute; definido si &lt;code&gt;reduce(-,[1,2,3])&lt;/code&gt; debe evaluarse como &lt;code&gt;(1-2)-3&lt;/code&gt; o &lt;code&gt;1-(2-3)&lt;/code&gt; . En su lugar, utilice &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; &lt;/a&gt; para garantizar la asociatividad izquierda o derecha.</target>
        </trans-unit>
        <trans-unit id="8e83411f941380eef1e4e97a62a5d00092492f0f" translate="yes" xml:space="preserve">
          <source>The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of &lt;code&gt;f&lt;/code&gt; for elements that appear multiple times in &lt;code&gt;itr&lt;/code&gt;. Use &lt;a href=&quot;#Base.mapfoldl-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapfoldl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.mapfoldr-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapfoldr&lt;/code&gt;&lt;/a&gt; instead for guaranteed left or right associativity and invocation of &lt;code&gt;f&lt;/code&gt; for every value.</source>
          <target state="translated">La asociatividad de la reducci&amp;oacute;n depende de la implementaci&amp;oacute;n. Adem&amp;aacute;s, algunas implementaciones pueden reutilizar el valor de retorno de &lt;code&gt;f&lt;/code&gt; para elementos que aparecen varias veces en &lt;code&gt;itr&lt;/code&gt; . Utilice &lt;a href=&quot;#Base.mapfoldl-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapfoldl&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#Base.mapfoldr-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapfoldr&lt;/code&gt; &lt;/a&gt; en su lugar para garantizar la asociatividad izquierda o derecha y la invocaci&amp;oacute;n de &lt;code&gt;f&lt;/code&gt; para cada valor.</target>
        </trans-unit>
        <trans-unit id="fa2ffdac4b6b173468c64bdf00df48adef8f3782" translate="yes" xml:space="preserve">
          <source>The available color keys can be seen by typing &lt;code&gt;Base.text_colors&lt;/code&gt; in the help mode of the REPL. In addition, the integers 0 to 255 can be used as color keys for terminals with 256 color support.</source>
          <target state="translated">Las claves de colores disponibles se pueden ver escribiendo &lt;code&gt;Base.text_colors&lt;/code&gt; en el modo de ayuda del REPL. Adem&amp;aacute;s, los n&amp;uacute;meros enteros del 0 al 255 se pueden utilizar como claves de color para terminales con compatibilidad con 256 colores.</target>
        </trans-unit>
        <trans-unit id="d6514960ce535f34b9eb969fcb1b4f9c39742102" translate="yes" xml:space="preserve">
          <source>The base Julia installation has in-built support for two types of clusters:</source>
          <target state="translated">La instalación de la base Julia tiene incorporado el soporte para dos tipos de cúmulos:</target>
        </trans-unit>
        <trans-unit id="562f643f12db492fbdb1e985351909d826402fa4" translate="yes" xml:space="preserve">
          <source>The base Julia runtime provides only plain-text display, but richer displays may be enabled by loading external modules or by using graphical Julia environments (such as the IPython-based IJulia notebook).</source>
          <target state="translated">El tiempo de ejecución de la base Julia sólo proporciona una pantalla de texto plano,pero se pueden habilitar pantallas más ricas cargando módulos externos o utilizando entornos gráficos Julia (como el cuaderno IJulia basado en IPython).</target>
        </trans-unit>
        <trans-unit id="002dc05c0d427615b628a5faca800a873b359de7" translate="yes" xml:space="preserve">
          <source>The base array type in Julia is the abstract type &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray{T,N}&lt;/code&gt;&lt;/a&gt;. It is parameterized by the number of dimensions &lt;code&gt;N&lt;/code&gt; and the element type &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;../../base/arrays/index#Base.AbstractVector&quot;&gt;&lt;code&gt;AbstractVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.AbstractMatrix&quot;&gt;&lt;code&gt;AbstractMatrix&lt;/code&gt;&lt;/a&gt; are aliases for the 1-d and 2-d cases. Operations on &lt;code&gt;AbstractArray&lt;/code&gt; objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.</source>
          <target state="translated">El tipo de matriz base en Julia es el tipo abstracto &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; &lt;/a&gt; . Se parametrizada por el n&amp;uacute;mero de dimensiones &lt;code&gt;N&lt;/code&gt; y el tipo de elemento &lt;code&gt;T&lt;/code&gt; . &lt;a href=&quot;../../base/arrays/index#Base.AbstractVector&quot;&gt; &lt;code&gt;AbstractVector&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/arrays/index#Base.AbstractMatrix&quot;&gt; &lt;code&gt;AbstractMatrix&lt;/code&gt; &lt;/a&gt; son alias para los casos 1-d y 2-d. Las operaciones en objetos &lt;code&gt;AbstractArray&lt;/code&gt; se definen utilizando operadores y funciones de nivel superior, de forma independiente del almacenamiento subyacente. Estas operaciones generalmente funcionan correctamente como respaldo para cualquier implementaci&amp;oacute;n de matriz espec&amp;iacute;fica.</target>
        </trans-unit>
        <trans-unit id="b29d93a344c231f0373e8777552dd842d0c0ae6b" translate="yes" xml:space="preserve">
          <source>The base library of Julia. &lt;code&gt;Base&lt;/code&gt; is a module that contains basic functionality (the contents of &lt;code&gt;base/&lt;/code&gt;). All modules implicitly contain &lt;code&gt;using Base&lt;/code&gt;, since this is needed in the vast majority of cases.</source>
          <target state="translated">La biblioteca base de Julia. &lt;code&gt;Base&lt;/code&gt; es un m&amp;oacute;dulo que contiene la funcionalidad b&amp;aacute;sica (el contenido de &lt;code&gt;base/&lt;/code&gt; ). Todos los m&amp;oacute;dulos contienen impl&amp;iacute;citamente el &lt;code&gt;using Base&lt;/code&gt; , ya que es necesario en la gran mayor&amp;iacute;a de los casos.</target>
        </trans-unit>
        <trans-unit id="f9d1c85fa2408916e8a238b5528b77d6327d21e9" translate="yes" xml:space="preserve">
          <source>The basic function for waiting for an event is &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. Several objects implement &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;; for example, given a &lt;code&gt;Process&lt;/code&gt; object, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; will wait for it to exit. &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; is often implicit; for example, a &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; can happen inside a call to &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; to wait for data to be available.</source>
          <target state="translated">La funci&amp;oacute;n b&amp;aacute;sica para esperar un evento es &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; . Varios objetos implementan &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; ; por ejemplo, dado un objeto &lt;code&gt;Process&lt;/code&gt; , &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; esperar&amp;aacute; a que salga. &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; suele estar impl&amp;iacute;cita; por ejemplo, puede ocurrir una &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; dentro de una llamada para &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; para esperar a que los datos est&amp;eacute;n disponibles.</target>
        </trans-unit>
        <trans-unit id="14cf1a6587ccfeb2916e3241169682e31c9f7659" translate="yes" xml:space="preserve">
          <source>The basic issue is that there is &lt;em&gt;nothing special about Julia's compiler&lt;/em&gt;: we use a commonplace compiler (LLVM) with no &amp;ldquo;secret sauce&amp;rdquo; that other language developers don't know about. Indeed, Julia's compiler is in many ways much simpler than those of other dynamic languages (e.g. PyPy or LuaJIT). Julia's performance advantage derives almost entirely from its front-end: its language semantics allow a &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;well-written Julia program&lt;/a&gt; to &lt;em&gt;give more opportunities to the compiler&lt;/em&gt; to generate efficient code and memory layouts. If you tried to compile Matlab or Python code to Julia, our compiler would be limited by the semantics of Matlab or Python to producing code no better than that of existing compilers for those languages (and probably worse). The key role of semantics is also why several existing Python compilers (like Numba and Pythran) only attempt to optimize a small subset of the language (e.g. operations on Numpy arrays and scalars), and for this subset they are already doing at least as well as we could for the same semantics. The people working on those projects are incredibly smart and have accomplished amazing things, but retrofitting a compiler onto a language that was designed to be interpreted is a very difficult problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38afa5a3f5d12c0c2e4c45c469ff70f9f6584c66" translate="yes" xml:space="preserve">
          <source>The basic syntax is simple: any string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called &lt;em&gt;docstrings&lt;/em&gt;). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:</source>
          <target state="translated">La sintaxis b&amp;aacute;sica es simple: cualquier cadena que aparezca en el nivel superior justo antes de un objeto (funci&amp;oacute;n, macro, tipo o instancia) se interpretar&amp;aacute; como que lo documenta (se denominan &lt;em&gt;cadenas de documentaci&amp;oacute;n&lt;/em&gt; ). Tenga en cuenta que no pueden intervenir l&amp;iacute;neas en blanco o comentarios entre una cadena de documentos y el objeto documentado. A continuaci&amp;oacute;n, se muestra un ejemplo b&amp;aacute;sico:</target>
        </trans-unit>
        <trans-unit id="33dcf1261b96e1096c0d88cf03a127c00532ab23" translate="yes" xml:space="preserve">
          <source>The basic syntax is simple: any string appearing at the toplevel right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called &lt;em&gt;docstrings&lt;/em&gt;). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6788f6ee76ef14250b1c48634160dc28850751" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;missing&lt;/code&gt; values follows one basic rule: &lt;code&gt;missing&lt;/code&gt; values &lt;em&gt;propagate&lt;/em&gt; automatically when passed to standard operators and functions, in particular mathematical functions. Uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means an operation involving a &lt;code&gt;missing&lt;/code&gt; value generally returns &lt;code&gt;missing&lt;/code&gt;</source>
          <target state="translated">El comportamiento de &lt;code&gt;missing&lt;/code&gt; valores perdidos sigue una regla b&amp;aacute;sica: &lt;code&gt;missing&lt;/code&gt; valores perdidos se &lt;em&gt;propagan&lt;/em&gt; autom&amp;aacute;ticamente cuando se pasan a operadores y funciones est&amp;aacute;ndar, en particular funciones matem&amp;aacute;ticas. La incertidumbre sobre el valor de uno de los operandos induce incertidumbre sobre el resultado. En la pr&amp;aacute;ctica, esto significa que una operaci&amp;oacute;n que involucra un valor &lt;code&gt;missing&lt;/code&gt; generalmente devuelve &lt;code&gt;missing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7e648e6d6c87b02acc6c1db84cf592e9a9a93a8" translate="yes" xml:space="preserve">
          <source>The behavior of the logical &quot;and&quot; operator &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; is similar to that of the &lt;code&gt;|&lt;/code&gt; operator, with the difference that missingness does not propagate when one of the operands is &lt;code&gt;false&lt;/code&gt;. For example, when that is the case of the first operand</source>
          <target state="translated">El comportamiento del operador l&amp;oacute;gico &quot;y&quot; &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; es similar al del &lt;code&gt;|&lt;/code&gt; operador, con la diferencia de que la falta no se propaga cuando uno de los operandos es &lt;code&gt;false&lt;/code&gt; . Por ejemplo, cuando ese es el caso del primer operando</target>
        </trans-unit>
        <trans-unit id="ab054bf408727eebc7e261fecbdce6bbcf7910b4" translate="yes" xml:space="preserve">
          <source>The best approach is to avoid defining &lt;em&gt;either&lt;/em&gt; of these methods: instead, rely on a generic method &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; and make sure this method is implemented with generic calls (like &lt;code&gt;similar&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) that do the right thing for each container type and element type &lt;em&gt;separately&lt;/em&gt;. This is just a more complex variant of the advice to &lt;a href=&quot;#man-methods-orthogonalize&quot;&gt;orthogonalize&lt;/a&gt; your methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b67ccc64e36fcf07f7c05aa43c8c2a633077f18" translate="yes" xml:space="preserve">
          <source>The best approach is to avoid defining &lt;em&gt;either&lt;/em&gt; of these methods: instead, rely on a generic method &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; and make sure this method is implemented with generic calls (like &lt;code&gt;similar&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) that do the right thing for each container type and element type &lt;em&gt;separately&lt;/em&gt;. This is just a more complex variant of the advice to &lt;a href=&quot;#man-methods-orthogonalize-1&quot;&gt;orthogonalize&lt;/a&gt; your methods.</source>
          <target state="translated">El mejor enfoque es evitar definir &lt;em&gt;cualquiera&lt;/em&gt; de estos m&amp;eacute;todos: en su lugar, conf&amp;iacute;e en un m&amp;eacute;todo gen&amp;eacute;rico &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; y aseg&amp;uacute;rese de que este m&amp;eacute;todo se implemente con llamadas gen&amp;eacute;ricas (como &lt;code&gt;similar&lt;/code&gt; y &lt;code&gt;-&lt;/code&gt; ) que hacen lo correcto para cada tipo de contenedor y tipo de elemento por &lt;em&gt;separado&lt;/em&gt; . Esta es solo una variante m&amp;aacute;s compleja del consejo para &lt;a href=&quot;#man-methods-orthogonalize-1&quot;&gt;ortogonalizar&lt;/a&gt; sus m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="24e50b0f52b6b5a46a65d54e76552fe8b8d70561" translate="yes" xml:space="preserve">
          <source>The best way to ensure this is to acquire a lock around any access to data that can be observed from multiple threads. For example, in most cases you should use the following code pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d958f10307af7b028b81ab80b4d640f64af23b08" translate="yes" xml:space="preserve">
          <source>The better design would be to define your call hierarchy like this:</source>
          <target state="translated">El mejor diseño sería definir su jerarquía de llamadas de esta manera:</target>
        </trans-unit>
        <trans-unit id="3983e66c166493bdb9b9e27ea74aedeb9d2d8cf1" translate="yes" xml:space="preserve">
          <source>The biggest advantage of &lt;code&gt;advection_shared!&lt;/code&gt; is that it minimizes traffic among the workers, allowing each to compute for an extended time on the assigned piece.</source>
          <target state="translated">&amp;iexcl;La mayor ventaja de &lt;code&gt;advection_shared!&lt;/code&gt; es que minimiza el tr&amp;aacute;fico entre los trabajadores, permitiendo que cada uno compute por un tiempo extendido en la pieza asignada.</target>
        </trans-unit>
        <trans-unit id="194659e7083e920d17f0c59327a653e32e8cfe4a" translate="yes" xml:space="preserve">
          <source>The binary operator &lt;code&gt;&amp;asymp;&lt;/code&gt; is equivalent to &lt;code&gt;isapprox&lt;/code&gt; with the default arguments, and &lt;code&gt;x ≉ y&lt;/code&gt; is equivalent to &lt;code&gt;!isapprox(x,y)&lt;/code&gt;.</source>
          <target state="translated">El operador binario &lt;code&gt;&amp;asymp;&lt;/code&gt; es equivalente a &lt;code&gt;isapprox&lt;/code&gt; con los argumentos predeterminados, y &lt;code&gt;x ≉ y&lt;/code&gt; es equivalente a &lt;code&gt;!isapprox(x,y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ba294c6e25bcc46b7feed1d1a73c0b3e0ef49e3" translate="yes" xml:space="preserve">
          <source>The blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for iterating through the characters in a string, since you can just use the string as an iterable object, no exception handling required:</source>
          <target state="translated">Las líneas en blanco en realidad tienen espacios en ellas.Afortunadamente,la torpeza del lenguaje anterior es innecesaria para iterar a través de los caracteres de una cadena,ya que sólo se puede usar la cadena como un objeto iterable,sin necesidad de hacer excepciones:</target>
        </trans-unit>
        <trans-unit id="de9db3cae53c5214143033ee37e23b9bcca06442" translate="yes" xml:space="preserve">
          <source>The block size for QR decomposition can be specified by keyword argument &lt;code&gt;blocksize :: Integer&lt;/code&gt; when &lt;code&gt;pivot == Val(false)&lt;/code&gt; and &lt;code&gt;A isa StridedMatrix{&amp;lt;:BlasFloat}&lt;/code&gt;. It is ignored when &lt;code&gt;blocksize &amp;gt; minimum(size(A))&lt;/code&gt;. See &lt;a href=&quot;#LinearAlgebra.QRCompactWY&quot;&gt;&lt;code&gt;QRCompactWY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586252847b0a965d3d0a5b40259b311ee19d7146" translate="yes" xml:space="preserve">
          <source>The broadcast style is computed for every broadcasting operation to allow for dispatch and specialization. The actual allocation of the result array is handled by &lt;code&gt;similar&lt;/code&gt;, using the Broadcasted object as its first argument.</source>
          <target state="translated">El estilo de transmisi&amp;oacute;n se calcula para cada operaci&amp;oacute;n de transmisi&amp;oacute;n para permitir el env&amp;iacute;o y la especializaci&amp;oacute;n. La asignaci&amp;oacute;n real de la matriz de resultados se maneja de manera &lt;code&gt;similar&lt;/code&gt; , utilizando el objeto Broadcasted como su primer argumento.</target>
        </trans-unit>
        <trans-unit id="5232abbd2579e189a3c4536c48fbc58adcc52edd" translate="yes" xml:space="preserve">
          <source>The built-in concrete type used for strings (and string literals) in Julia is &lt;code&gt;String&lt;/code&gt;. This supports the full range of &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; characters via the &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; encoding. (A &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert to/from other Unicode encodings.)</source>
          <target state="translated">El tipo de concreto incorporado que se usa para cadenas (y literales de cadena) en Julia es &lt;code&gt;String&lt;/code&gt; . Esto admite la gama completa de caracteres &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode a&lt;/a&gt; trav&amp;eacute;s de la &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;codificaci&amp;oacute;n UTF-8&lt;/a&gt; . (Se proporciona una funci&amp;oacute;n de &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt; para convertir hacia / desde otras codificaciones Unicode).</target>
        </trans-unit>
        <trans-unit id="dc25d16dd1aba7b0c5bea6b12ba6118124030ae4" translate="yes" xml:space="preserve">
          <source>The byte offset of field &lt;code&gt;i&lt;/code&gt; of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:</source>
          <target state="translated">El desplazamiento de bytes del campo &lt;code&gt;i&lt;/code&gt; de un tipo relativo al inicio de los datos. Por ejemplo, podr&amp;iacute;amos usarlo de la siguiente manera para resumir informaci&amp;oacute;n sobre una estructura:</target>
        </trans-unit>
        <trans-unit id="2947adec00e452cbe7215d4a9d5ddd5347c0e1b7" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;time&lt;/code&gt; is delayed by wrapping it in a 0-argument anonymous function that is called only when the requested key is absent from &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df22a65b46868ee938e0477154f053724ad2e34c" translate="yes" xml:space="preserve">
          <source>The callback you pass to C should only execute a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;:uv_async_send&lt;/code&gt;, passing &lt;code&gt;cond.handle&lt;/code&gt; as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.</source>
          <target state="translated">La devoluci&amp;oacute;n de llamada que le pasa a C solo debe ejecutar una &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; a &lt;code&gt;:uv_async_send&lt;/code&gt; , pasando &lt;code&gt;cond.handle&lt;/code&gt; como argumento, teniendo cuidado de evitar asignaciones u otras interacciones con el tiempo de ejecuci&amp;oacute;n de Julia.</target>
        </trans-unit>
        <trans-unit id="1914d99c521314d189e5cd08206a81317617d28f" translate="yes" xml:space="preserve">
          <source>The caller must be holding the &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; that owns &lt;code&gt;c&lt;/code&gt; before calling this method. The calling task will be blocked until some other task wakes it, usually by calling &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e65b00ae78a0300e89eb33901bc2c6dff08184" translate="yes" xml:space="preserve">
          <source>The caller must be holding the &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; that owns &lt;code&gt;c&lt;/code&gt; before calling this method. The calling task will be blocked until some other task wakes it, usually by calling &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;` on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.</source>
          <target state="translated">La persona que llama debe tener el &lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; que posee &lt;code&gt;c&lt;/code&gt; antes de llamar a este m&amp;eacute;todo. La tarea que realiza la llamada se bloquear&amp;aacute; hasta que otra tarea la active, normalmente llamando a &lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; `en el mismo objeto Condici&amp;oacute;n. El candado se liberar&amp;aacute; at&amp;oacute;micamente al bloquear (incluso si se bloque&amp;oacute; de forma recursiva) y se volver&amp;aacute; a adquirir antes de regresar.</target>
        </trans-unit>
        <trans-unit id="b9769cfc324c619140bf4882f569b4d5be45feda" translate="yes" xml:space="preserve">
          <source>The case of &lt;code&gt;rand&lt;/code&gt; is a bit more complex as we have to ensure that each thread uses non-overlapping pseudorandom number sequences. This can be simply ensured by using &lt;code&gt;Future.randjump&lt;/code&gt; function:</source>
          <target state="translated">El caso de &lt;code&gt;rand&lt;/code&gt; es un poco m&amp;aacute;s complejo ya que tenemos que asegurarnos de que cada hilo use secuencias de n&amp;uacute;meros pseudoaleatorios que no se superpongan. Esto se puede asegurar simplemente usando la funci&amp;oacute;n &lt;code&gt;Future.randjump&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5555fa452d0454119cd31b5aa3d13eec12b96796" translate="yes" xml:space="preserve">
          <source>The channels example from above can be modified for interprocess communication, as shown below.</source>
          <target state="translated">El ejemplo de los canales de arriba puede modificarse para la comunicación entre procesos,como se muestra a continuación.</target>
        </trans-unit>
        <trans-unit id="89b722bb0d4e7814b2f6957c408ca31cc4584902" translate="yes" xml:space="preserve">
          <source>The choice of which method to execute when a function is applied is called &lt;em&gt;dispatch&lt;/em&gt;. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to &quot;belong&quot; to one argument more than any of the others: does the addition operation in &lt;code&gt;x + y&lt;/code&gt; belong to &lt;code&gt;x&lt;/code&gt; any more than it does to &lt;code&gt;y&lt;/code&gt;? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.</source>
          <target state="translated">La elecci&amp;oacute;n de qu&amp;eacute; m&amp;eacute;todo ejecutar cuando se aplica una funci&amp;oacute;n se llama &lt;em&gt;despacho&lt;/em&gt; . Julia permite que el proceso de env&amp;iacute;o elija cu&amp;aacute;l de los m&amp;eacute;todos de una funci&amp;oacute;n llamar en funci&amp;oacute;n del n&amp;uacute;mero de argumentos dados y de los tipos de todos los argumentos de la funci&amp;oacute;n. Esto es diferente a los lenguajes tradicionales orientados a objetos, donde el env&amp;iacute;o ocurre bas&amp;aacute;ndose solo en el primer argumento, que a menudo tiene una sintaxis de argumento especial, y a veces est&amp;aacute; impl&amp;iacute;cito en lugar de escrito expl&amp;iacute;citamente como un argumento. &lt;a href=&quot;#footnote-1&quot;&gt;[1] El&lt;/a&gt; uso de todos los argumentos de una funci&amp;oacute;n para elegir qu&amp;eacute; m&amp;eacute;todo debe invocarse, en lugar del primero, se conoce como &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;env&amp;iacute;o m&amp;uacute;ltiple.&lt;/a&gt;. El env&amp;iacute;o m&amp;uacute;ltiple es particularmente &amp;uacute;til para el c&amp;oacute;digo matem&amp;aacute;tico, donde tiene poco sentido considerar artificialmente que las operaciones &quot;pertenecen&quot; a un argumento m&amp;aacute;s que a cualquiera de los otros: &amp;iquest;la operaci&amp;oacute;n de suma en &lt;code&gt;x + y&lt;/code&gt; pertenece a &lt;code&gt;x&lt;/code&gt; m&amp;aacute;s que a &lt;code&gt;y&lt;/code&gt; ? La implementaci&amp;oacute;n de un operador matem&amp;aacute;tico generalmente depende de los tipos de todos sus argumentos. Sin embargo, incluso m&amp;aacute;s all&amp;aacute; de las operaciones matem&amp;aacute;ticas, el env&amp;iacute;o m&amp;uacute;ltiple termina siendo un paradigma poderoso y conveniente para estructurar y organizar programas.</target>
        </trans-unit>
        <trans-unit id="13ecd81245d046d8f7c6febb538d3020c7b75542" translate="yes" xml:space="preserve">
          <source>The choice of which method to execute when a function is applied is called &lt;em&gt;dispatch&lt;/em&gt;. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to &quot;belong&quot; to one argument more than any of the others: does the addition operation in &lt;code&gt;x + y&lt;/code&gt; belong to &lt;code&gt;x&lt;/code&gt; any more than it does to &lt;code&gt;y&lt;/code&gt;? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810842d6186800c0a575092bdf409289f500ddec" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;x-&amp;gt;x&lt;/code&gt; carries a reference to &lt;code&gt;Foo&lt;/code&gt;, and since &lt;code&gt;Foo&lt;/code&gt; is unavailable on node 2, an &lt;code&gt;UndefVarError&lt;/code&gt; is thrown.</source>
          <target state="translated">El cierre &lt;code&gt;x-&amp;gt;x&lt;/code&gt; lleva una referencia a &lt;code&gt;Foo&lt;/code&gt; , y dado que &lt;code&gt;Foo&lt;/code&gt; no est&amp;aacute; disponible en el nodo 2, se lanza un &lt;code&gt;UndefVarError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd31f7bc6251a511018cdc2ef8ff1b65e61abb04" translate="yes" xml:space="preserve">
          <source>The cluster manager captures the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; of each worker and makes it available to the master process.</source>
          <target state="translated">El administrador del cl&amp;uacute;ster captura la &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; de cada trabajador y la pone a disposici&amp;oacute;n del proceso maestro.</target>
        </trans-unit>
        <trans-unit id="232fd0535972887717b19fb5bb8c4cfab94a62e6" translate="yes" xml:space="preserve">
          <source>The code above is equivalent to calling &lt;code&gt;get&lt;/code&gt; with an anonymous function containing the code enclosed between &lt;code&gt;do&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c5bc198a3439c620845fc2e6da1bcc9a273974" translate="yes" xml:space="preserve">
          <source>The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fPIC&lt;/code&gt; options. The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. (Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. When both libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations that can even optimize across this boundary, but Julia does not yet support that. In the future, however, it may do so, yielding even greater performance gains.)</source>
          <target state="translated">El c&amp;oacute;digo que se va a llamar debe estar disponible como biblioteca compartida. La mayor&amp;iacute;a de las bibliotecas de C y Fortran ya se env&amp;iacute;an compiladas como bibliotecas compartidas, pero si est&amp;aacute; compilando el c&amp;oacute;digo usted mismo usando GCC (o Clang), deber&amp;aacute; usar &lt;code&gt;-shared&lt;/code&gt; y &lt;code&gt;-fPIC&lt;/code&gt; opciones. Las instrucciones de la m&amp;aacute;quina generadas por el JIT de Julia son las mismas que las de una llamada C nativa, por lo que la sobrecarga resultante es la misma que la de llamar a una funci&amp;oacute;n de biblioteca desde el c&amp;oacute;digo C. (Las llamadas a funciones que no son de biblioteca tanto en C como en Julia pueden estar integradas y, por lo tanto, pueden tener incluso menos sobrecarga que las llamadas a funciones de biblioteca compartida. Cuando LLVM genera tanto las bibliotecas como los ejecutables, es posible realizar optimizaciones de todo el programa que pueden incluso optimizar a trav&amp;eacute;s de este l&amp;iacute;mite, pero Julia a&amp;uacute;n no lo admite. Sin embargo, en el futuro, puede hacerlo, lo que producir&amp;aacute; ganancias de rendimiento a&amp;uacute;n mayores).</target>
        </trans-unit>
        <trans-unit id="34cdd974b77024d3560260c4b5ac606cb2155811" translate="yes" xml:space="preserve">
          <source>The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fPIC&lt;/code&gt; options. The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f830d6caf7ed0451c6b75d05afceaf2e516b19" translate="yes" xml:space="preserve">
          <source>The collection must not be empty.</source>
          <target state="translated">La colección no debe estar vacía.</target>
        </trans-unit>
        <trans-unit id="b1b1444de74c16e81499ba99fc21db058cdbcd70" translate="yes" xml:space="preserve">
          <source>The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the following to your &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file, which is to be placed inside your home directory:</source>
          <target state="translated">Los colores utilizados por Julia y el REPL tambi&amp;eacute;n se pueden personalizar. Para cambiar el color del indicador de Julia, puede agregar algo como lo siguiente a su &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; , que se colocar&amp;aacute; dentro de su directorio de inicio:</target>
        </trans-unit>
        <trans-unit id="6ae3351e931cdaf68574bd5908ad25710f928fca" translate="yes" xml:space="preserve">
          <source>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">Se supone que las columnas est&amp;aacute;n separadas por uno o m&amp;aacute;s espacios en blanco. El delimitador de final de l&amp;iacute;nea se toma como &lt;code&gt;\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b166229d69582696f7886d8f6669f9f89c33f90c" translate="yes" xml:space="preserve">
          <source>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">Se supone que las columnas est&amp;aacute;n separadas por uno o m&amp;aacute;s espacios en blanco. El delimitador de final de l&amp;iacute;nea se toma como &lt;code&gt;\n&lt;/code&gt; . Si todos los datos son num&amp;eacute;ricos, el resultado ser&amp;aacute; una matriz num&amp;eacute;rica. Si algunos elementos no se pueden analizar como n&amp;uacute;meros, se devuelve una matriz heterog&amp;eacute;nea de n&amp;uacute;meros y cadenas.</target>
        </trans-unit>
        <trans-unit id="c128fcb09c50ebb22346ed7e858f0e921632da46" translate="yes" xml:space="preserve">
          <source>The combination of a high-level programming language, a first-class command abstraction, and automatic setup of pipes between processes is a powerful one. To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples, with apologies for the excessive use of Perl one-liners:</source>
          <target state="translated">La combinación de un lenguaje de programación de alto nivel,una abstracción de comandos de primera clase y la configuración automática de tuberías entre procesos es muy poderosa.Para dar una idea de las complejas tuberías que pueden ser creadas fácilmente,aquí hay algunos ejemplos más sofisticados,con disculpas por el uso excesivo de Perl de una sola línea:</target>
        </trans-unit>
        <trans-unit id="6a7191f54d1d0a0057ae059656a933d9b6a26e58" translate="yes" xml:space="preserve">
          <source>The command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately interpolating variables and splitting on words as the shell would, respecting shell quoting syntax. The command is run as &lt;code&gt;julia&lt;/code&gt;'s immediate child process, using &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; calls.</source>
          <target state="translated">El comando nunca se ejecuta con un shell. En cambio, Julia analiza la sintaxis del comando directamente, interpolando apropiadamente las variables y dividiendo las palabras como lo har&amp;iacute;a el shell, respetando la sintaxis de comillas del shell. El comando se ejecuta como el proceso hijo inmediato de &lt;code&gt;julia&lt;/code&gt; , utilizando llamadas &lt;code&gt;fork&lt;/code&gt; y &lt;code&gt;exec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a0dcc8c9826601bed0e074d703f3ff7a640f8d1" translate="yes" xml:space="preserve">
          <source>The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use &lt;code&gt;LinearIndices(x)&lt;/code&gt; or &lt;code&gt;eachindex(x)&lt;/code&gt; instead (see also &lt;a href=&quot;https://docs.julialang.org/en/latest/devdocs/offset-arrays/&quot;&gt;offset-arrays&lt;/a&gt;).</source>
          <target state="translated">El lenguaje com&amp;uacute;n de usar 1: n para indexar en un AbstractArray no es seguro si el Array usa indexaci&amp;oacute;n no convencional y puede causar una falla de segmentaci&amp;oacute;n si la verificaci&amp;oacute;n de l&amp;iacute;mites est&amp;aacute; desactivada. Use &lt;code&gt;LinearIndices(x)&lt;/code&gt; o &lt;code&gt;eachindex(x)&lt;/code&gt; lugar (vea tambi&amp;eacute;n &lt;a href=&quot;https://docs.julialang.org/en/latest/devdocs/offset-arrays/&quot;&gt;arreglos de compensaci&amp;oacute;n&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0bf4109d6939a09708619e91409334de90fe3c1c" translate="yes" xml:space="preserve">
          <source>The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use &lt;code&gt;LinearIndices(x)&lt;/code&gt; or &lt;code&gt;eachindex(x)&lt;/code&gt; instead (see also &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;Arrays with custom indices&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0451ae3f3f75dd1173ec1688aaf529347960c71" translate="yes" xml:space="preserve">
          <source>The commonly used &lt;code&gt;Int&lt;/code&gt; type corresponds to the machine integer type (&lt;code&gt;Int32&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt;). This means it will overflow, such that &lt;code&gt;2^64 == 0&lt;/code&gt;. If you need larger values use another appropriate type, such as &lt;code&gt;Int128&lt;/code&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or a floating point type like &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">El tipo de &lt;code&gt;Int&lt;/code&gt; com&amp;uacute;nmente utilizado corresponde al tipo de entero de la m&amp;aacute;quina ( &lt;code&gt;Int32&lt;/code&gt; o &lt;code&gt;Int64&lt;/code&gt; ). Esto significa que se desbordar&amp;aacute;, de modo que &lt;code&gt;2^64 == 0&lt;/code&gt; . Si necesita valores m&amp;aacute;s grandes, use otro tipo apropiado, como &lt;code&gt;Int128&lt;/code&gt; , &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; o un tipo de punto flotante como &lt;code&gt;Float64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="282c5d6af8a85d4583f2090ba3bf0607d51cccb2" translate="yes" xml:space="preserve">
          <source>The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer. The Julia compiler is able to generate efficient code in the presence of &lt;code&gt;Union&lt;/code&gt; types with a small number of types &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;, by generating specialized code in separate branches for each possible type.</source>
          <target state="translated">Los compiladores de muchos lenguajes tienen una construcci&amp;oacute;n de uni&amp;oacute;n interna para razonar sobre tipos; Julia simplemente se lo expone al programador. El compilador de Julia es capaz de generar c&amp;oacute;digo eficiente en presencia de tipos &lt;code&gt;Union&lt;/code&gt; con un peque&amp;ntilde;o n&amp;uacute;mero de tipos &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; , generando c&amp;oacute;digo especializado en ramas separadas para cada tipo posible.</target>
        </trans-unit>
        <trans-unit id="1be479cb36a150784847fcc775f7e727a4aeb4b9" translate="yes" xml:space="preserve">
          <source>The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer. The Julia compiler is able to generate efficient code in the presence of &lt;code&gt;Union&lt;/code&gt; types with a small number of types &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;, by generating specialized code in separate branches for each possible type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9aee61fefed95ed11583fb480004204213f80db" translate="yes" xml:space="preserve">
          <source>The complete list is in the parser code: https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d307808f74aeaa37d8dbbea9a15606c901a4cae0" translate="yes" xml:space="preserve">
          <source>The completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable.</source>
          <target state="translated">La cumplimentación de los campos para la salida de las funciones utiliza la inferencia de tipo,y sólo puede sugerir campos si la función es de tipo estable.</target>
        </trans-unit>
        <trans-unit id="d3138fe1fc8f7174a34adb1898449525528a913c" translate="yes" xml:space="preserve">
          <source>The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from functions. The function needs to be type stable for the completion to be able to remove non-matching methods.</source>
          <target state="translated">La terminación de los métodos utiliza la inferencia de tipo y por lo tanto puede ver si los argumentos coinciden incluso si los argumentos son resultado de funciones.La función debe ser de tipo estable para que la finalización pueda eliminar los métodos que no coinciden.</target>
        </trans-unit>
        <trans-unit id="6f83f5850ac6b62e295ec56f0e83533e7801ad37" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;rand(rng, s::Union{AbstractDict,AbstractSet})&lt;/code&gt; is linear in the length of &lt;code&gt;s&lt;/code&gt;, unless an optimized method with constant complexity is available, which is the case for &lt;code&gt;Dict&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;BitSet&lt;/code&gt;. For more than a few calls, use &lt;code&gt;rand(rng, collect(s))&lt;/code&gt; instead, or either &lt;code&gt;rand(rng, Dict(s))&lt;/code&gt; or &lt;code&gt;rand(rng, Set(s))&lt;/code&gt; as appropriate.</source>
          <target state="translated">La complejidad de &lt;code&gt;rand(rng, s::Union{AbstractDict,AbstractSet})&lt;/code&gt; es lineal en la longitud de &lt;code&gt;s&lt;/code&gt; , a menos que est&amp;eacute; disponible un m&amp;eacute;todo optimizado con complejidad constante, que es el caso de &lt;code&gt;Dict&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; y &lt;code&gt;BitSet&lt;/code&gt; . Para m&amp;aacute;s de unas pocas llamadas, use &lt;code&gt;rand(rng, collect(s))&lt;/code&gt; lugar, o bien &lt;code&gt;rand(rng, Dict(s))&lt;/code&gt; o &lt;code&gt;rand(rng, Set(s))&lt;/code&gt; seg&amp;uacute;n corresponda.</target>
        </trans-unit>
        <trans-unit id="311dcfe3310c4c1e71b8fdd71e07a972ef0dc132" translate="yes" xml:space="preserve">
          <source>The components of tuples can optionally be named, in which case a &lt;em&gt;named tuple&lt;/em&gt; is constructed:</source>
          <target state="translated">Los componentes de las tuplas se pueden nombrar opcionalmente, en cuyo caso se construye una &lt;em&gt;tupla con nombre&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="3e9339bf8ddc8517e7daf0c8e7c807dbe19f1e27" translate="yes" xml:space="preserve">
          <source>The compressed sparse column storage makes it easy and quick to access the elements in the column of a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations such as insertion of previously unstored entries one at a time in the CSC structure tend to be slow. This is because all elements of the sparse matrix that are beyond the point of insertion have to be moved one place over.</source>
          <target state="translated">El almacenamiento comprimido de la columna dispersa hace que sea fácil y rápido acceder a los elementos de la columna de una matriz dispersa,mientras que el acceso a la matriz dispersa por filas es considerablemente más lento.Las operaciones como la inserción de entradas no almacenadas previamente una a una en la estructura de la CSC tienden a ser lentas.Esto se debe a que todos los elementos de la matriz dispersa que están más allá del punto de inserción tienen que ser movidos un lugar más allá.</target>
        </trans-unit>
        <trans-unit id="8b1889cfa906d5de7f417dbba5d8a75294042a14" translate="yes" xml:space="preserve">
          <source>The concatenation functions are used so often that they have special syntax:</source>
          <target state="translated">Las funciones de concatenación se utilizan con tanta frecuencia que tienen una sintaxis especial:</target>
        </trans-unit>
        <trans-unit id="79be6aae51e8c401b2476f5b4f2a107a9fdc32ef" translate="yes" xml:space="preserve">
          <source>The constant pi.</source>
          <target state="translated">La constante pi.</target>
        </trans-unit>
        <trans-unit id="cdd946b3bbe64931ddb3bd5e7f32f9d59fbf8fe0" translate="yes" xml:space="preserve">
          <source>The constant ℯ.</source>
          <target state="translated">La constante ℯ.</target>
        </trans-unit>
        <trans-unit id="9cefd93a0c7128d9cee7f50ca451b5a8198bc929" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;RemoteChannel(f::Function, pid)()&lt;/code&gt; allows us to construct references to channels holding more than one value of a specific type. &lt;code&gt;f&lt;/code&gt; is a function executed on &lt;code&gt;pid&lt;/code&gt; and it must return an &lt;code&gt;AbstractChannel&lt;/code&gt;.</source>
          <target state="translated">El constructor &lt;code&gt;RemoteChannel(f::Function, pid)()&lt;/code&gt; nos permite construir referencias a canales que contienen m&amp;aacute;s de un valor de un tipo espec&amp;iacute;fico. &lt;code&gt;f&lt;/code&gt; es una funci&amp;oacute;n que se ejecuta en &lt;code&gt;pid&lt;/code&gt; y debe devolver un &lt;code&gt;AbstractChannel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76232e9ec80692ffa1332b97fa1e6fc3973cc15d" translate="yes" xml:space="preserve">
          <source>The constructor for a shared array is of the form:</source>
          <target state="translated">El constructor de un conjunto compartido es de la forma:</target>
        </trans-unit>
        <trans-unit id="821d6810ac6b95dcd6b7cb3ce13745f711f223d5" translate="yes" xml:space="preserve">
          <source>The constructs introducing scope blocks are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f297e05974522f0c6701c3e5abf5ccf2ee32ab" translate="yes" xml:space="preserve">
          <source>The contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;item two&lt;/code&gt;.</source>
          <target state="translated">El contenido de cada elemento de la lista debe coincidir con la primera l&amp;iacute;nea del elemento. En el ejemplo anterior, el bloque de c&amp;oacute;digo delimitado debe tener una sangr&amp;iacute;a de cuatro espacios para alinearse con la &lt;code&gt;i&lt;/code&gt; en el &lt;code&gt;item two&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a711e2ee96d05b52332ef79c64c2aa17ad5865e1" translate="yes" xml:space="preserve">
          <source>The cookie may be passed to the workers at startup via argument &lt;code&gt;--worker=&amp;lt;cookie&amp;gt;&lt;/code&gt;. If argument &lt;code&gt;--worker&lt;/code&gt; is specified without the cookie, the worker tries to read the cookie from its standard input (&lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;stdin&lt;/code&gt; is closed immediately after the cookie is retrieved.</source>
          <target state="translated">La cookie se puede pasar a los trabajadores al inicio mediante el argumento &lt;code&gt;--worker=&amp;lt;cookie&amp;gt;&lt;/code&gt; . Si se especifica el argumento &lt;code&gt;--worker&lt;/code&gt; sin la cookie, el trabajador intenta leer la cookie desde su entrada est&amp;aacute;ndar ( &lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; ). El &lt;code&gt;stdin&lt;/code&gt; se cierra inmediatamente despu&amp;eacute;s de que se recupera la cookie.</target>
        </trans-unit>
        <trans-unit id="964f5d9426cfdc6c758d47e988ded861b6315851" translate="yes" xml:space="preserve">
          <source>The core language imposes very little; Julia Base and the standard library are written in Julia itself, including primitive operations like integer arithmetic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870af6ba603446abce307b3e8bfd11194f33f900" translate="yes" xml:space="preserve">
          <source>The core language imposes very little; Julia Base and the standard library is written in Julia itself, including primitive operations like integer arithmetic</source>
          <target state="translated">El lenguaje central impone muy poco;la base de Julia y la biblioteca estándar está escrita en la propia Julia,incluyendo operaciones primitivas como la aritmética de números enteros</target>
        </trans-unit>
        <trans-unit id="3bc4ff368fbfc76c3ff3eaa70599d7710f608522" translate="yes" xml:space="preserve">
          <source>The current logger state is looked up and the message level checked against the logger's cached minimum level, as found by calling &lt;a href=&quot;#Base.CoreLogging.min_enabled_level&quot;&gt;&lt;code&gt;Logging.min_enabled_level&lt;/code&gt;&lt;/a&gt;. This behavior can be overridden via environment variables (more on this later).</source>
          <target state="translated">Se busca el estado actual del registrador y el nivel del mensaje se compara con el nivel m&amp;iacute;nimo almacenado en cach&amp;eacute; del registrador, como se encuentra llamando a &lt;a href=&quot;#Base.CoreLogging.min_enabled_level&quot;&gt; &lt;code&gt;Logging.min_enabled_level&lt;/code&gt; &lt;/a&gt; . Este comportamiento se puede anular mediante variables de entorno (m&amp;aacute;s sobre esto m&amp;aacute;s adelante).</target>
        </trans-unit>
        <trans-unit id="0146df473ce231b1bd3f1a030488e3df426f1fa7" translate="yes" xml:space="preserve">
          <source>The current logger state is looked up and the message level checked against the logger's cached minimum level, as found by calling &lt;a href=&quot;#Logging.min_enabled_level&quot;&gt;&lt;code&gt;Logging.min_enabled_level&lt;/code&gt;&lt;/a&gt;. This behavior can be overridden via environment variables (more on this later).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7f546fa478be5baf73e1d9a88ce7b4f22fd7b5" translate="yes" xml:space="preserve">
          <source>The current version of Julia multiplexes all tasks onto a single OS thread. Thus, while tasks involving I/O operations benefit from parallel execution, compute bound tasks are effectively executed sequentially on a single OS thread. Future versions of Julia may support scheduling of tasks on multiple threads, in which case compute bound tasks will see benefits of parallel execution too.</source>
          <target state="translated">La versión actual de Julia multiplexa todas las tareas en un solo hilo del sistema operativo.Así,mientras que las tareas que implican operaciones de E/S se benefician de la ejecución en paralelo,las tareas vinculadas al cálculo se ejecutan efectivamente de forma secuencial en un único hilo del SO.Las futuras versiones de Julia pueden soportar la programación de tareas en múltiples hilos,en cuyo caso las tareas vinculadas al cálculo también se beneficiarán de la ejecución paralela.</target>
        </trans-unit>
        <trans-unit id="76aeeb5da0056ec0aaaca0d1c584f7796e1043fc" translate="yes" xml:space="preserve">
          <source>The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</source>
          <target state="translated">Los peligros de abusar del envío múltiple (alias,más en los tipos con valores como parámetros)</target>
        </trans-unit>
        <trans-unit id="61e6dec9a93ab50439a3df7d4ed79515ae264595" translate="yes" xml:space="preserve">
          <source>The day of month of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El d&amp;iacute;a del mes de &lt;code&gt;Date&lt;/code&gt; o &lt;code&gt;DateTime&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="299252ee9be4ede7afdc82ba83cfa67ed6efb411" translate="yes" xml:space="preserve">
          <source>The declared types of all fields in a composite DataType &lt;code&gt;T&lt;/code&gt; as a tuple.</source>
          <target state="translated">Los tipos declarados de todos los campos en un DataType &lt;code&gt;T&lt;/code&gt; compuesto como una tupla.</target>
        </trans-unit>
        <trans-unit id="2ef7bb84da109de096d6179f580e39fcc330d135" translate="yes" xml:space="preserve">
          <source>The dedentation level is determined as the longest common starting sequence of spaces or tabs in all lines, excluding the line following the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; and lines containing only spaces or tabs (the line containing the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is always included). Then for all lines, excluding the text following the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;, the common starting sequence is removed (including lines containing only spaces and tabs if they start with this sequence), e.g.:</source>
          <target state="translated">El nivel de dedentaci&amp;oacute;n se determina como la secuencia de inicio com&amp;uacute;n m&amp;aacute;s larga de espacios o tabulaciones en todas las l&amp;iacute;neas, excluyendo la l&amp;iacute;nea que sigue a la apertura &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; y las l&amp;iacute;neas que contienen solo espacios o tabulaciones (la l&amp;iacute;nea que contiene el cierre &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; siempre se incluye). Luego, para todas las l&amp;iacute;neas, excluyendo el texto que sigue a la apertura &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; , se elimina la secuencia de inicio com&amp;uacute;n (incluidas las l&amp;iacute;neas que contienen solo espacios y tabulaciones si comienzan con esta secuencia), por ejemplo:</target>
        </trans-unit>
        <trans-unit id="2356f962c8d3ff60eecc6a182ea052ea39664b67" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pid&lt;/code&gt; is the current process.</source>
          <target state="translated">El &lt;code&gt;pid&lt;/code&gt; predeterminado es el proceso actual.</target>
        </trans-unit>
        <trans-unit id="60227207bf9b873d43f880cb82175cc1c4120101" translate="yes" xml:space="preserve">
          <source>The default MIME type is &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt;. There is a fallback definition for &lt;code&gt;text/plain&lt;/code&gt; output that calls &lt;code&gt;show&lt;/code&gt; with 2 arguments, so it is not always necessary to add a method for that case. If a type benefits from custom human-readable output though, &lt;code&gt;show(::IO, ::MIME&quot;text/plain&quot;, ::T)&lt;/code&gt; should be defined. For example, the &lt;code&gt;Day&lt;/code&gt; type uses &lt;code&gt;1 day&lt;/code&gt; as the output for the &lt;code&gt;text/plain&lt;/code&gt; MIME type, and &lt;code&gt;Day(1)&lt;/code&gt; as the output of 2-argument &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13fb2cffe54cc4ab8a1dd2c832ae7310589c0943" translate="yes" xml:space="preserve">
          <source>The default MIME type is &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt;. There is a fallback definition for &lt;code&gt;text/plain&lt;/code&gt; output that calls &lt;code&gt;show&lt;/code&gt; with 2 arguments. Therefore, this case should be handled by defining a 2-argument &lt;code&gt;show(io::IO, x::MyType)&lt;/code&gt; method.</source>
          <target state="translated">El tipo MIME predeterminado es &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt; . Hay una definici&amp;oacute;n alternativa para &lt;code&gt;text/plain&lt;/code&gt; salida simple que &lt;code&gt;show&lt;/code&gt; llamadas con 2 argumentos. Por lo tanto, este caso debe manejarse definiendo un m&amp;eacute;todo &lt;code&gt;show(io::IO, x::MyType)&lt;/code&gt; 2 argumentos .</target>
        </trans-unit>
        <trans-unit id="e57baa92c6f6a7e34ff4590072c999e03c2e6a26" translate="yes" xml:space="preserve">
          <source>The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia functions without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously &quot;untyped&quot; code. Adding annotations serves three primary purposes: to take advantage of Julia's powerful multiple-dispatch mechanism, to improve human readability, and to catch programmer errors.</source>
          <target state="translated">El comportamiento por defecto en Julia cuando se omiten los tipos es permitir que los valores sean de cualquier tipo.Así,uno puede escribir muchas funciones útiles de Julia sin usar nunca explícitamente los tipos.Sin embargo,cuando se necesita una expresividad adicional,es fácil introducir gradualmente anotaciones de tipo explícitas en el código previamente &quot;sin escribir&quot;.La adición de anotaciones tiene tres propósitos principales:aprovechar el poderoso mecanismo de envío múltiple de Julia,mejorar la legibilidad humana y detectar errores de programación.</target>
        </trans-unit>
        <trans-unit id="d1df4775c1a0c6149628da164ef2c2add2aea3bd" translate="yes" xml:space="preserve">
          <source>The default behaviour is to remove leading whitespace and delimiters: see &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt; for precise details.</source>
          <target state="translated">El comportamiento predeterminado es eliminar los espacios en blanco &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; y los delimitadores: consulte isspace para obtener detalles precisos.</target>
        </trans-unit>
        <trans-unit id="1c11c76e6a974f0248876da7137e97c01ffa7caf" translate="yes" xml:space="preserve">
          <source>The default behaviour is to remove trailing whitespace and delimiters: see &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt; for precise details.</source>
          <target state="translated">El comportamiento predeterminado es eliminar los espacios en blanco finales y los delimitadores: consulte &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; para obtener detalles precisos.</target>
        </trans-unit>
        <trans-unit id="d5b48a4ab8a2d4ed833b136d5a3a24148da74e18" translate="yes" xml:space="preserve">
          <source>The default constructor &lt;code&gt;Channel()&lt;/code&gt; and default &lt;code&gt;size=0&lt;/code&gt; were added in Julia 1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855bff164720a2c745d8e506987fbf1482013980" translate="yes" xml:space="preserve">
          <source>The default implementation (which uses TCP/IP sockets) is implemented as &lt;code&gt;connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)&lt;/code&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n predeterminada (que usa sockets TCP / IP) se implementa como &lt;code&gt;connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78e7fa17aefadd075c2be825658630ae2cf9c235" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;isequal&lt;/code&gt; calls &lt;code&gt;==&lt;/code&gt;, so a type that does not involve floating-point values generally only needs to define &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n predeterminada de &lt;code&gt;isequal&lt;/code&gt; llama a &lt;code&gt;==&lt;/code&gt; , por lo que un tipo que no involucra valores de punto flotante generalmente solo necesita definir &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48bcbdbff411080a8ce1e0c1f60de9f518c30398" translate="yes" xml:space="preserve">
          <source>The default implementations of the above (on a &lt;code&gt;AbstractWorkerPool&lt;/code&gt;) require fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40594727e32e7ffa62fc7c197ea4f5e0449e9039" translate="yes" xml:space="preserve">
          <source>The default implementations of the above (on a &lt;code&gt;AbstractWorkerPool&lt;/code&gt;) require fields channel::Channel{Int} workers::Set{Int} where &lt;code&gt;channel&lt;/code&gt; contains free worker pids and &lt;code&gt;workers&lt;/code&gt; is the set of all workers associated with this pool.</source>
          <target state="translated">Las implementaciones predeterminadas de lo anterior (en un &lt;code&gt;AbstractWorkerPool&lt;/code&gt; ) requieren campos channel :: Channel {Int} workers :: Set {Int} donde el &lt;code&gt;channel&lt;/code&gt; contiene pids de trabajadores libres y &lt;code&gt;workers&lt;/code&gt; es el conjunto de todos los trabajadores asociados con este grupo.</target>
        </trans-unit>
        <trans-unit id="90d0098a5b9857be430bc6bdbd24d7771a71aa03" translate="yes" xml:space="preserve">
          <source>The default is &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El valor predeterminado es &lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="939929b76e159e18d5e7761850ea7b359afa492d" translate="yes" xml:space="preserve">
          <source>The default mode used is always &lt;a href=&quot;../../base/math/index#Base.Rounding.RoundNearest&quot;&gt;&lt;code&gt;RoundNearest&lt;/code&gt;&lt;/a&gt;, which rounds to the nearest representable value, with ties rounded towards the nearest value with an even least significant bit.</source>
          <target state="translated">El modo predeterminado utilizado es siempre &lt;a href=&quot;../../base/math/index#Base.Rounding.RoundNearest&quot;&gt; &lt;code&gt;RoundNearest&lt;/code&gt; &lt;/a&gt; , que se redondea al valor representable m&amp;aacute;s cercano, con v&amp;iacute;nculos redondeados hacia el valor m&amp;aacute;s cercano con un bit incluso menos significativo.</target>
        </trans-unit>
        <trans-unit id="bb41fa3202534d6677ac2f342e3bce0fdc60f379" translate="yes" xml:space="preserve">
          <source>The default precision (in number of bits of the significand) and rounding mode of &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; operations can be changed globally by calling &lt;a href=&quot;../../base/numbers/index#Base.MPFR.setprecision&quot;&gt;&lt;code&gt;setprecision&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;setrounding&lt;/code&gt;, and all further calculations will take these changes in account. Alternatively, the precision or the rounding can be changed only within the execution of a particular block of code by using the same functions with a &lt;code&gt;do&lt;/code&gt; block:</source>
          <target state="translated">La precisi&amp;oacute;n predeterminada (en n&amp;uacute;mero de bits del significado) y el modo de redondeo de &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; operaciones de BigFloat se pueden cambiar globalmente llamando a &lt;a href=&quot;../../base/numbers/index#Base.MPFR.setprecision&quot;&gt; &lt;code&gt;setprecision&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;setrounding&lt;/code&gt; , y todos los c&amp;aacute;lculos posteriores tendr&amp;aacute;n en cuenta estos cambios. Alternativamente, la precisi&amp;oacute;n o el redondeo se puede cambiar solo dentro de la ejecuci&amp;oacute;n de un bloque de c&amp;oacute;digo en particular usando las mismas funciones con un bloque &lt;code&gt;do&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf260c790afbd5fd76456a214c3da2bfee6f596b" translate="yes" xml:space="preserve">
          <source>The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.</source>
          <target state="translated">El modo de redondeo por defecto.Se redondea al entero más cercano,con los empates (valores fraccionarios de 0,5)redondeados al entero par más cercano.</target>
        </trans-unit>
        <trans-unit id="cd46d911f48a459503193b1169b7d8853a54b000" translate="yes" xml:space="preserve">
          <source>The default schedule (used when no &lt;code&gt;schedule&lt;/code&gt; argument is present) is subject to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8d023ed2ec488f600d82c5f04099bb7053c6343" translate="yes" xml:space="preserve">
          <source>The default sorting algorithms are chosen on the basis that they are fast and stable, or &lt;em&gt;appear&lt;/em&gt; to be so. For numeric types indeed, &lt;code&gt;QuickSort&lt;/code&gt; is selected as it is faster and indistinguishable in this case from a stable sort (unless the array records its mutations in some way). The stability property comes at a non-negligible cost, so if you don't need it, you may want to explicitly specify your preferred algorithm, e.g. &lt;code&gt;sort!(v, alg=QuickSort)&lt;/code&gt;.</source>
          <target state="translated">Los algoritmos de clasificaci&amp;oacute;n predeterminados se eligen sobre la base de que son r&amp;aacute;pidos y estables, o &lt;em&gt;parecen&lt;/em&gt; serlo. De hecho, para los tipos num&amp;eacute;ricos, se selecciona &lt;code&gt;QuickSort&lt;/code&gt; ya que es m&amp;aacute;s r&amp;aacute;pido e indistinguible en este caso de un tipo estable (a menos que la matriz registre sus mutaciones de alguna manera). La propiedad de estabilidad tiene un costo no despreciable, por lo que si no la necesita, es posible que desee especificar expl&amp;iacute;citamente su algoritmo preferido, por ejemplo, &lt;code&gt;sort!(v, alg=QuickSort)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e4b294c96581c70e29314614e72dd9c556dd867" translate="yes" xml:space="preserve">
          <source>The default type for an integer literal depends on whether the target system has a 32-bit architecture or a 64-bit architecture:</source>
          <target state="translated">El tipo por defecto para un literal entero depende de si el sistema objetivo tiene una arquitectura de 32 bits o de 64 bits:</target>
        </trans-unit>
        <trans-unit id="0025d7cf20de7d8585d610cdb20c478776196150" translate="yes" xml:space="preserve">
          <source>The default value (for iterators that do not define this function) is &lt;code&gt;HasLength()&lt;/code&gt;. This means that most iterators are assumed to implement &lt;a href=&quot;#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El valor predeterminado (para iteradores que no definen esta funci&amp;oacute;n) es &lt;code&gt;HasLength()&lt;/code&gt; . Esto significa que se supone que la mayor&amp;iacute;a de los iteradores implementan la &lt;a href=&quot;#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed1fec164addf150bd6fc4ed074c8bde6086195e" translate="yes" xml:space="preserve">
          <source>The default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.</source>
          <target state="translated">El valor predeterminado cuando no se pasan palabras clave es abrir los archivos sólo para lectura.Devuelve un flujo para acceder al archivo abierto.</target>
        </trans-unit>
        <trans-unit id="46ad04b79597833ac2971450ca4faf1a5ac755c0" translate="yes" xml:space="preserve">
          <source>The definitive guide to floating point arithmetic is the &lt;a href=&quot;https://standards.ieee.org/standard/754-2008.html&quot;&gt;IEEE 754-2008 Standard&lt;/a&gt;; however, it is not available for free online.</source>
          <target state="translated">La gu&amp;iacute;a definitiva para la aritm&amp;eacute;tica de coma flotante es el &lt;a href=&quot;https://standards.ieee.org/standard/754-2008.html&quot;&gt;est&amp;aacute;ndar IEEE 754-2008&lt;/a&gt; ; sin embargo, no est&amp;aacute; disponible de forma gratuita en l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="c7a1e185817162d29c3ca02c640a39cf90726456" translate="yes" xml:space="preserve">
          <source>The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.</source>
          <target state="translated">La cadena de descripción acepta la interpolación de los índices de bucle.Si no se proporciona una descripción,se construye una basada en las variables.</target>
        </trans-unit>
        <trans-unit id="b9783bd3f57cabbb7dcb6efff07a6fb2ce7cf2be" translate="yes" xml:space="preserve">
          <source>The destructuring feature can also be used within a function argument. If a function argument name is written as a tuple (e.g. &lt;code&gt;(x, y)&lt;/code&gt;) instead of just a symbol, then an assignment &lt;code&gt;(x, y) = argument&lt;/code&gt; will be inserted for you:</source>
          <target state="translated">La caracter&amp;iacute;stica de desestructuraci&amp;oacute;n tambi&amp;eacute;n se puede utilizar dentro de un argumento de funci&amp;oacute;n. Si el nombre de un argumento de funci&amp;oacute;n se escribe como una tupla (por ejemplo, &lt;code&gt;(x, y)&lt;/code&gt; ) en lugar de solo un s&amp;iacute;mbolo, entonces se insertar&amp;aacute; una asignaci&amp;oacute;n &lt;code&gt;(x, y) = argument&lt;/code&gt; para usted:</target>
        </trans-unit>
        <trans-unit id="dca7fd4aaff137c3b5ad312f731763865f2c4777" translate="yes" xml:space="preserve">
          <source>The diagonal of the matrix &lt;code&gt;X&lt;/code&gt; is assumed to be all ones.</source>
          <target state="translated">Se supone que la diagonal de la matriz &lt;code&gt;X&lt;/code&gt; son todos unos.</target>
        </trans-unit>
        <trans-unit id="65475d5b108ff8d6ff4d0b451b5957edd3247c0c" translate="yes" xml:space="preserve">
          <source>The diagonal values of the matrix &lt;code&gt;X&lt;/code&gt; will be read.</source>
          <target state="translated">Se leer&amp;aacute;n los valores diagonales de la matriz &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35294cd283107f3ea2ad299c610959761013b001" translate="yes" xml:space="preserve">
          <source>The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator &lt;code&gt;p&lt;/code&gt;-norm of a &lt;code&gt;1 &amp;times; n&lt;/code&gt; matrix.</source>
          <target state="translated">La diferencia en la norma entre un espacio vectorial y su dual surge para preservar la relaci&amp;oacute;n entre la dualidad y el producto escalar , y el resultado es consistente con el operador &lt;code&gt;p&lt;/code&gt; -norm de una matriz &lt;code&gt;1 &amp;times; n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe30caaca3ec896d42d37e2680c6fbcc22f3fc58" translate="yes" xml:space="preserve">
          <source>The difference seems trivial, but in fact is quite significant due to the behavior of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt;. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.</source>
          <target state="translated">La diferencia parece trivial, pero de hecho es bastante significativa debido al comportamiento de &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; . En el primer m&amp;eacute;todo, se construye una matriz aleatoria localmente y luego se env&amp;iacute;a a otro proceso donde se eleva al cuadrado. En el segundo m&amp;eacute;todo, se construye una matriz aleatoria y se eleva al cuadrado en otro proceso. Por lo tanto, el segundo m&amp;eacute;todo env&amp;iacute;a muchos menos datos que el primero.</target>
        </trans-unit>
        <trans-unit id="eb05e878344722c287b20da3054e1a3329545a60" translate="yes" xml:space="preserve">
          <source>The difference seems trivial, but in fact is quite significant due to the behavior of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt;. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515d7afeaf87e8c8538070fa94ff623cdced8f10" translate="yes" xml:space="preserve">
          <source>The different prompt modes</source>
          <target state="translated">Los diferentes modos de indicación</target>
        </trans-unit>
        <trans-unit id="cf7712c8e857525e49eb6c6feac8d5fe578af7a4" translate="yes" xml:space="preserve">
          <source>The discussion in the preceding paragraph referred to the &quot;parser&quot;, that is, the phase of compilation that takes place when the module containing &lt;code&gt;abmult&lt;/code&gt; is first loaded, as opposed to the later phase when it is first invoked. The parser does not &quot;know&quot; that &lt;code&gt;Int&lt;/code&gt; is a fixed type, or that the statement &lt;code&gt;r = -r&lt;/code&gt; transforms an &lt;code&gt;Int&lt;/code&gt; to another &lt;code&gt;Int&lt;/code&gt;. The magic of type inference takes place in the later phase of compilation.</source>
          <target state="translated">La discusi&amp;oacute;n en el p&amp;aacute;rrafo anterior se refiere al &quot;analizador&quot;, es decir, la fase de compilaci&amp;oacute;n que tiene lugar cuando el m&amp;oacute;dulo que contiene &lt;code&gt;abmult&lt;/code&gt; se carga por primera vez, a diferencia de la fase posterior cuando se invoca por primera vez. El analizador no &quot;sabe&quot; que &lt;code&gt;Int&lt;/code&gt; es un tipo fijo, o que la instrucci&amp;oacute;n &lt;code&gt;r = -r&lt;/code&gt; transforma un &lt;code&gt;Int&lt;/code&gt; en otro &lt;code&gt;Int&lt;/code&gt; . La magia de la inferencia de tipos tiene lugar en la &amp;uacute;ltima fase de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="228846c17a2f8eda9af9e04280c4e7e004d8ecbb" translate="yes" xml:space="preserve">
          <source>The discussion of trait-based promotion provides a transition into our next design pattern: computing the output element type for a matrix operation.</source>
          <target state="translated">La discusión de la promoción basada en rasgos proporciona una transición a nuestro siguiente patrón de diseño:computar el tipo de elemento de salida para una operación de matriz.</target>
        </trans-unit>
        <trans-unit id="c9eeea461d08f16f6e9e3e76a2854c7413f10de0" translate="yes" xml:space="preserve">
          <source>The distance between two adjacent representable floating-point numbers is not constant, but is smaller for smaller values and larger for larger values. In other words, the representable floating-point numbers are densest in the real number line near zero, and grow sparser exponentially as one moves farther away from zero. By definition, &lt;code&gt;eps(1.0)&lt;/code&gt; is the same as &lt;code&gt;eps(Float64)&lt;/code&gt; since &lt;code&gt;1.0&lt;/code&gt; is a 64-bit floating-point value.</source>
          <target state="translated">La distancia entre dos n&amp;uacute;meros de coma flotante representables adyacentes no es constante, pero es menor para valores menores y mayor para valores mayores. En otras palabras, los n&amp;uacute;meros de coma flotante representables son m&amp;aacute;s densos en la recta num&amp;eacute;rica real cerca de cero y crecen exponencialmente m&amp;aacute;s dispersos a medida que uno se aleja de cero. Por definici&amp;oacute;n, &lt;code&gt;eps(1.0)&lt;/code&gt; es lo mismo que &lt;code&gt;eps(Float64)&lt;/code&gt; ya que &lt;code&gt;1.0&lt;/code&gt; es un valor de punto flotante de 64 bits.</target>
        </trans-unit>
        <trans-unit id="17711720acdfc250d4da5bdf1c59e4156516b762" translate="yes" xml:space="preserve">
          <source>The distinction between inheriting global scope and nesting local scope can lead to some slight differences between functions defined in local versus global scopes for variable assignments. Consider the modification of the last example by moving &lt;code&gt;bar&lt;/code&gt; to the global scope:</source>
          <target state="translated">La distinci&amp;oacute;n entre heredar el alcance global y anidar el alcance local puede dar lugar a ligeras diferencias entre las funciones definidas en los &amp;aacute;mbitos local y global para las asignaciones de variables. Considere la modificaci&amp;oacute;n del &amp;uacute;ltimo ejemplo moviendo la &lt;code&gt;bar&lt;/code&gt; ra al alcance global:</target>
        </trans-unit>
        <trans-unit id="bcbd86bd1c455f650a19858504ec03684521d39b" translate="yes" xml:space="preserve">
          <source>The documentation is also available in PDF format: &lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.2.0.pdf&quot;&gt;julia-1.2.0.pdf&lt;/a&gt;.</source>
          <target state="translated">La documentaci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; disponible en formato PDF: &lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.2.0.pdf&quot;&gt;julia-1.2.0.pdf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adc54fa69d8c5b645a51e5f0c26507e3e5712011" translate="yes" xml:space="preserve">
          <source>The documentation is also available in PDF format: &lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.5.3.pdf&quot;&gt;julia-1.5.3.pdf&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c976d9d02fc2e4f087f2db86ac987d2cebacc0" translate="yes" xml:space="preserve">
          <source>The easiest way to learn and experiment with Julia is by starting an interactive session (also known as a read-eval-print loop or &quot;REPL&quot;) by double-clicking the Julia executable or running &lt;code&gt;julia&lt;/code&gt; from the command line:</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil de aprender y experimentar con Julia es iniciando una sesi&amp;oacute;n interactiva (tambi&amp;eacute;n conocida como ciclo de lectura-evaluaci&amp;oacute;n-impresi&amp;oacute;n o &quot;REPL&quot;) haciendo doble clic en el ejecutable de Julia o ejecutando &lt;code&gt;julia&lt;/code&gt; desde la l&amp;iacute;nea de comando:</target>
        </trans-unit>
        <trans-unit id="2182ffaca8a0c2d19e2f394d632b220a4bda55b5" translate="yes" xml:space="preserve">
          <source>The easiest way to understand this behavior is to see an example. In the previous example, the &lt;code&gt;println&lt;/code&gt; call is shared by all three branches: the only real choice is which literal string to print. This could be written more concisely using the ternary operator. For the sake of clarity, let's try a two-way version first:</source>
          <target state="translated">La forma m&amp;aacute;s sencilla de comprender este comportamiento es ver un ejemplo. En el ejemplo anterior, las tres ramas comparten la llamada &lt;code&gt;println&lt;/code&gt; : la &amp;uacute;nica opci&amp;oacute;n real es qu&amp;eacute; cadena literal imprimir. Esto podr&amp;iacute;a escribirse de forma m&amp;aacute;s concisa utilizando el operador ternario. En aras de la claridad, probemos primero una versi&amp;oacute;n bidireccional:</target>
        </trans-unit>
        <trans-unit id="56dd1399973b5466f5b438f54aa5084eb3d4b3fd" translate="yes" xml:space="preserve">
          <source>The editor can be changed by setting &lt;code&gt;JULIA_EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;EDITOR&lt;/code&gt; as an environment variable.</source>
          <target state="translated">El editor se puede cambiar configurando &lt;code&gt;JULIA_EDITOR&lt;/code&gt; , &lt;code&gt;VISUAL&lt;/code&gt; o &lt;code&gt;EDITOR&lt;/code&gt; como variable de entorno.</target>
        </trans-unit>
        <trans-unit id="8d60f89821e0be17d3c10fd641e166470b0fae98" translate="yes" xml:space="preserve">
          <source>The editor returned by &lt;code&gt;InteractiveUtils.editor()&lt;/code&gt; and used in, e.g., &lt;code&gt;InteractiveUtils.edit&lt;/code&gt;, referring to the command of the preferred editor, for instance &lt;code&gt;vim&lt;/code&gt;.</source>
          <target state="translated">El editor devuelto por &lt;code&gt;InteractiveUtils.editor()&lt;/code&gt; y utilizado en, por ejemplo, &lt;code&gt;InteractiveUtils.edit&lt;/code&gt; , refiri&amp;eacute;ndose al comando del editor preferido, por ejemplo, &lt;code&gt;vim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f31493a5d545803d2bc443ac0f38b3d641d141b" translate="yes" xml:space="preserve">
          <source>The efficiency gained by being able to store &lt;code&gt;Point{Float64}&lt;/code&gt; objects with immediate values is magnified enormously in the case of arrays: an &lt;code&gt;Array{Float64}&lt;/code&gt; can be stored as a contiguous memory block of 64-bit floating-point values, whereas an &lt;code&gt;Array{Real}&lt;/code&gt; must be an array of pointers to individually allocated &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; objects &amp;ndash; which may well be &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing&quot;&gt;boxed&lt;/a&gt; 64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to be implementations of the &lt;code&gt;Real&lt;/code&gt; abstract type.</source>
          <target state="translated">La eficiencia obtenida al poder almacenar objetos &lt;code&gt;Point{Float64}&lt;/code&gt; con valores inmediatos se magnifica enormemente en el caso de las matrices: una &lt;code&gt;Array{Float64}&lt;/code&gt; se puede almacenar como un bloque de memoria contiguo de valores de coma flotante de 64 bits, mientras que una &lt;code&gt;Array{Real}&lt;/code&gt; debe ser una matriz de punteros a objetos &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; asignados individualmente , que pueden ser valores de coma flotante de 64 bits en &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing&quot;&gt;caja&lt;/a&gt; , pero tambi&amp;eacute;n pueden ser objetos complejos arbitrariamente grandes, que se declaran implementaciones del tipo abstracto &lt;code&gt;Real&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77656128da3c3e27758883f72427b834f3cb4b6e" translate="yes" xml:space="preserve">
          <source>The eigenvalues are returned in &lt;code&gt;W&lt;/code&gt; and the eigenvectors in &lt;code&gt;Z&lt;/code&gt;.</source>
          <target state="translated">Los valores propios son devueltos en &lt;code&gt;W&lt;/code&gt; y los vectores propios en &lt;code&gt;Z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="709d89b2d19663c267d1c6a4862d61316a231e84" translate="yes" xml:space="preserve">
          <source>The element type of the result is chosen using promotion (see &lt;a href=&quot;../base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;) based on the element type of &lt;code&gt;A&lt;/code&gt; and on the types of the &lt;code&gt;new&lt;/code&gt; values in pairs. If &lt;code&gt;count&lt;/code&gt; is omitted and the element type of &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Union&lt;/code&gt;, the element type of the result will not include singleton types which are replaced with values of a different type: for example, &lt;code&gt;Union{T,Missing}&lt;/code&gt; will become &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;missing&lt;/code&gt; is replaced.</source>
          <target state="translated">El tipo de elemento del resultado se elige mediante la promoci&amp;oacute;n (ver &lt;a href=&quot;../base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; ) en funci&amp;oacute;n del tipo de elemento de &lt;code&gt;A&lt;/code&gt; y de los tipos de los &lt;code&gt;new&lt;/code&gt; valores en pares. Si se omite el &lt;code&gt;count&lt;/code&gt; y el tipo de elemento de &lt;code&gt;A&lt;/code&gt; es una &lt;code&gt;Union&lt;/code&gt; , el tipo de elemento del resultado no incluir&amp;aacute; tipos de singleton que se reemplacen con valores de un tipo diferente: por ejemplo, &lt;code&gt;Union{T,Missing}&lt;/code&gt; se convertir&amp;aacute; en &lt;code&gt;T&lt;/code&gt; si &lt;code&gt;missing&lt;/code&gt; es sustituido.</target>
        </trans-unit>
        <trans-unit id="14b4f332ac46b505bad4228677357909dd03b266" translate="yes" xml:space="preserve">
          <source>The element type of the tuple must be an instance of &lt;code&gt;VecElement{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a primitive type that is 1, 2, 4 or 8 bytes.</source>
          <target state="translated">El tipo de elemento de la tupla debe ser una instancia de &lt;code&gt;VecElement{T}&lt;/code&gt; donde &lt;code&gt;T&lt;/code&gt; es un tipo primitivo de 1, 2, 4 u 8 bytes.</target>
        </trans-unit>
        <trans-unit id="c9296fda074d952d1c87394f1441913d330aa413" translate="yes" xml:space="preserve">
          <source>The empty (or &quot;bottom&quot;) type, written as &lt;code&gt;Union{}&lt;/code&gt; (an empty union type), is a type with no values and no subtypes (except itself). You will generally not need to use this type.</source>
          <target state="translated">El tipo vac&amp;iacute;o (o &quot;inferior&quot;), escrito como &lt;code&gt;Union{}&lt;/code&gt; (un tipo de uni&amp;oacute;n vac&amp;iacute;o), es un tipo sin valores ni subtipos (excepto &amp;eacute;l mismo). Por lo general, no necesitar&amp;aacute; utilizar este tipo.</target>
        </trans-unit>
        <trans-unit id="3534ea1366da3151258e1f770bb393a26a8c9156" translate="yes" xml:space="preserve">
          <source>The empty tuple (&lt;code&gt;()&lt;/code&gt;) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.</source>
          <target state="translated">La tupla vac&amp;iacute;a ( &lt;code&gt;()&lt;/code&gt; ) es otra forma de nada. Pero, en realidad, no debe considerarse como nada, sino m&amp;aacute;s bien como una tupla de valores cero.</target>
        </trans-unit>
        <trans-unit id="f2bd3a290bc2b2f98102d89ff212080bf2528200" translate="yes" xml:space="preserve">
          <source>The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">El delimitador de final de l&amp;iacute;nea se toma como &lt;code&gt;\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13d242b1b1e933d4ec26a29014e675d01b5c3b93" translate="yes" xml:space="preserve">
          <source>The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">El delimitador de final de l&amp;iacute;nea se toma como &lt;code&gt;\n&lt;/code&gt; . Si todos los datos son num&amp;eacute;ricos, el resultado ser&amp;aacute; una matriz num&amp;eacute;rica. Si algunos elementos no se pueden analizar como n&amp;uacute;meros, se devuelve una matriz heterog&amp;eacute;nea de n&amp;uacute;meros y cadenas.</target>
        </trans-unit>
        <trans-unit id="646c7a5bc743f5d4a67f86e4404a7cfd381dff26" translate="yes" xml:space="preserve">
          <source>The endianness of the written value depends on the endianness of the host system. Convert to/from a fixed endianness when writing/reading (e.g. using &lt;a href=&quot;#Base.htol&quot;&gt;&lt;code&gt;htol&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.ltoh&quot;&gt;&lt;code&gt;ltoh&lt;/code&gt;&lt;/a&gt;) to get results that are consistent across platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c21a922512e76aea89910e75ca40814c713417b" translate="yes" xml:space="preserve">
          <source>The entries of &lt;code&gt;F.D1&lt;/code&gt; and &lt;code&gt;F.D2&lt;/code&gt; are related, as explained in the LAPACK documentation for the &lt;a href=&quot;http://www.netlib.org/lapack/lug/node36.html&quot;&gt;generalized SVD&lt;/a&gt; and the &lt;a href=&quot;http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html&quot;&gt;xGGSVD3&lt;/a&gt; routine which is called underneath (in LAPACK 3.6.0 and newer).</source>
          <target state="translated">Las entradas de &lt;code&gt;F.D1&lt;/code&gt; y &lt;code&gt;F.D2&lt;/code&gt; est&amp;aacute;n relacionadas, como se explica en la documentaci&amp;oacute;n de LAPACK para la &lt;a href=&quot;http://www.netlib.org/lapack/lug/node36.html&quot;&gt;SVD generalizada&lt;/a&gt; y la rutina &lt;a href=&quot;http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html&quot;&gt;xGGSVD3,&lt;/a&gt; que se llama debajo (en LAPACK 3.6.0 y m&amp;aacute;s reciente).</target>
        </trans-unit>
        <trans-unit id="3ee9b3b4fb75bbbf3de3deed96398c0ab2d5522c" translate="yes" xml:space="preserve">
          <source>The environment variables that Julia uses generally start with &lt;code&gt;JULIA&lt;/code&gt;. If &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt;&lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt;&lt;/a&gt; is called with the keyword &lt;code&gt;verbose=true&lt;/code&gt;, then the output will list any defined environment variables relevant for Julia, including those which include &lt;code&gt;JULIA&lt;/code&gt; in their names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6e8a6592578860941072596b3389f0e39bd834" translate="yes" xml:space="preserve">
          <source>The environment variables that Julia uses generally start with &lt;code&gt;JULIA&lt;/code&gt;. If &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt;&lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt;&lt;/a&gt; is called with the keyword &lt;code&gt;verbose=true&lt;/code&gt;, then the output will list defined environment variables relevant for Julia, including those for which &lt;code&gt;JULIA&lt;/code&gt; appears in the name.</source>
          <target state="translated">Las variables de entorno que utiliza Julia generalmente comienzan con &lt;code&gt;JULIA&lt;/code&gt; . Si se llama a &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt; &lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt; &lt;/a&gt; con la palabra clave &lt;code&gt;verbose=true&lt;/code&gt; , la salida mostrar&amp;aacute; una lista de las variables de entorno definidas relevantes para Julia, incluidas aquellas para las que &lt;code&gt;JULIA&lt;/code&gt; aparece en el nombre.</target>
        </trans-unit>
        <trans-unit id="2e01139cb5620c6fbb793874bc029ba48692801b" translate="yes" xml:space="preserve">
          <source>The equivalent of an &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; HTML tag can be achieved using three hyphens (&lt;code&gt;---&lt;/code&gt;). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ebc4dca8e995a281e980c9657b899d8cf0df29e" translate="yes" xml:space="preserve">
          <source>The equivalent of an &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; HTML tag can be written using the following syntax:</source>
          <target state="translated">El equivalente a una etiqueta HTML &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; se puede escribir con la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="74efd542b7345e98fdaed051a7a6183a8d020db5" translate="yes" xml:space="preserve">
          <source>The example generated function &lt;code&gt;foo&lt;/code&gt; above did not do anything a normal function &lt;code&gt;foo(x) = x * x&lt;/code&gt; could not do (except printing the type on the first invocation, and incurring higher overhead). However, the power of a generated function lies in its ability to compute different quoted expressions depending on the types passed to it:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;foo&lt;/code&gt; generada del ejemplo anterior no hizo nada que una funci&amp;oacute;n normal &lt;code&gt;foo(x) = x * x&lt;/code&gt; no pudiera hacer (excepto imprimir el tipo en la primera invocaci&amp;oacute;n e incurrir en una sobrecarga m&amp;aacute;s alta). Sin embargo, el poder de una funci&amp;oacute;n generada radica en su capacidad para calcular diferentes expresiones entre comillas seg&amp;uacute;n los tipos que se le pasan:</target>
        </trans-unit>
        <trans-unit id="4cb49bdc57a779962ff666ac722912890cdcf08f" translate="yes" xml:space="preserve">
          <source>The example in the previous section glossed over the implementation details of &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt;, which both operate in terms of these traits. When iterating over a matrix, such as in the implementation of &lt;code&gt;map&lt;/code&gt;, one important question is what order to use to traverse the data. When &lt;code&gt;AbstractArray&lt;/code&gt; subtypes implement the &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;Base.IndexStyle&lt;/code&gt;&lt;/a&gt; trait, other functions such as &lt;code&gt;map&lt;/code&gt; can dispatch on this information to pick the best algorithm (see &lt;a href=&quot;../interfaces/index#man-interface-array&quot;&gt;Abstract Array Interface&lt;/a&gt;). This means that each subtype does not need to implement a custom version of &lt;code&gt;map&lt;/code&gt;, since the generic definitions + trait classes will enable the system to select the fastest version. Here a toy implementation of &lt;code&gt;map&lt;/code&gt; illustrating the trait-based dispatch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e119c6a2d56d3760f8ebb0ae8619e173f79b4b25" translate="yes" xml:space="preserve">
          <source>The example in the previous section glossed over the implementation details of &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt;, which both operate in terms of these traits. When iterating over a matrix, such as in the implementation of &lt;code&gt;map&lt;/code&gt;, one important question is what order to use to traverse the data. When &lt;code&gt;AbstractArray&lt;/code&gt; subtypes implement the &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;Base.IndexStyle&lt;/code&gt;&lt;/a&gt; trait, other functions such as &lt;code&gt;map&lt;/code&gt; can dispatch on this information to pick the best algorithm (see &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;Abstract Array Interface&lt;/a&gt;). This means that each subtype does not need to implement a custom version of &lt;code&gt;map&lt;/code&gt;, since the generic definitions + trait classes will enable the system to select the fastest version. Here a toy implementation of &lt;code&gt;map&lt;/code&gt; illustrating the trait-based dispatch:</source>
          <target state="translated">El ejemplo de la secci&amp;oacute;n anterior pas&amp;oacute; por alto los detalles de implementaci&amp;oacute;n de &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; a&lt;/a&gt; y &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt; , que operan en t&amp;eacute;rminos de estos rasgos. Al iterar sobre una matriz, como en la implementaci&amp;oacute;n de un &lt;code&gt;map&lt;/code&gt; a , una pregunta importante es qu&amp;eacute; orden utilizar para recorrer los datos. Cuando los subtipos &lt;code&gt;AbstractArray&lt;/code&gt; implementan el rasgo &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;Base.IndexStyle&lt;/code&gt; &lt;/a&gt; , otras funciones como &lt;code&gt;map&lt;/code&gt; pueden enviar esta informaci&amp;oacute;n para elegir el mejor algoritmo (ver &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;Interfaz Abstract Array&lt;/a&gt; ). Esto significa que cada subtipo no necesita implementar una versi&amp;oacute;n personalizada del &lt;code&gt;map&lt;/code&gt; a., ya que las definiciones gen&amp;eacute;ricas + clases de rasgos permitir&amp;aacute;n al sistema seleccionar la versi&amp;oacute;n m&amp;aacute;s r&amp;aacute;pida. Aqu&amp;iacute; una implementaci&amp;oacute;n de juguete del &lt;code&gt;map&lt;/code&gt; a que ilustra el env&amp;iacute;o basado en rasgos:</target>
        </trans-unit>
        <trans-unit id="c4e7ac687a3c1938fcc96d92a705ce561c8d3bfd" translate="yes" xml:space="preserve">
          <source>The exception is that quotation marks still must be escaped, e.g. &lt;code&gt;raw&quot;\&quot;&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt;. To make it possible to express all strings, backslashes then also must be escaped, but only when appearing right before a quote character:</source>
          <target state="translated">La excepci&amp;oacute;n es que las comillas a&amp;uacute;n deben ser de escape, por ejemplo, &lt;code&gt;raw&quot;\&quot;&quot;&lt;/code&gt; formato es equivalente a &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; . Para que sea posible expresar todas las cadenas, las barras invertidas tambi&amp;eacute;n deben escaparse, pero solo cuando aparecen justo antes de un car&amp;aacute;cter de comillas:</target>
        </trans-unit>
        <trans-unit id="806a2c6eb838f5063922dc987163b721668d0145" translate="yes" xml:space="preserve">
          <source>The exception stack is stored on the &lt;code&gt;Task&lt;/code&gt; where the exceptions occurred. When a task fails with uncaught exceptions, &lt;code&gt;catch_stack(task)&lt;/code&gt; may be used to inspect the exception stack for that task.</source>
          <target state="translated">La pila de excepciones se almacena en la &lt;code&gt;Task&lt;/code&gt; donde ocurrieron las excepciones. Cuando una tarea falla con excepciones no &lt;code&gt;catch_stack(task)&lt;/code&gt; , catch_stack (tarea) puede usarse para inspeccionar la pila de excepciones para esa tarea.</target>
        </trans-unit>
        <trans-unit id="8f5394bfbaefac45354c9007a6d28e58fb286a9b" translate="yes" xml:space="preserve">
          <source>The exceptions to this rule are the smallest and largest finite values (e.g. &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; and &lt;code&gt;prevfloat(Inf)&lt;/code&gt; for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;), which round to the smaller of the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928c8d0396de54cd800b9aede32ea561fba936f5" translate="yes" xml:space="preserve">
          <source>The exceptions to this rule are the smallest and largest finite values (e.g. &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; and &lt;code&gt;prevfloat(Inf)&lt;/code&gt; for &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;), which round to the smaller of the values.</source>
          <target state="translated">Las excepciones a esta regla son los valores finitos m&amp;aacute;s peque&amp;ntilde;os y m&amp;aacute;s grandes (por ejemplo, &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; y &lt;code&gt;prevfloat(Inf)&lt;/code&gt; para &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ), que redondean al menor de los valores.</target>
        </trans-unit>
        <trans-unit id="116c955b734ab2654b5573c4e02330a021559f49" translate="yes" xml:space="preserve">
          <source>The exceptions to this rule are the smallest and largest finite values (e.g. &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; and &lt;code&gt;prevfloat(Inf)&lt;/code&gt; for &lt;a href=&quot;numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;), which round to the smaller of the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def91518b0989f4a83def2144fe01cdce215a440" translate="yes" xml:space="preserve">
          <source>The executable itself is one of</source>
          <target state="translated">El ejecutable en sí mismo es uno de</target>
        </trans-unit>
        <trans-unit id="0db1c4486699e7de0f4ce2a483205ec8ce5f38db" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;a&lt;/code&gt;, before the &lt;code&gt;?&lt;/code&gt;, is a condition expression, and the ternary operation evaluates the expression &lt;code&gt;b&lt;/code&gt;, before the &lt;code&gt;:&lt;/code&gt;, if the condition &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or the expression &lt;code&gt;c&lt;/code&gt;, after the &lt;code&gt;:&lt;/code&gt;, if it is &lt;code&gt;false&lt;/code&gt;. Note that the spaces around &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; are mandatory: an expression like &lt;code&gt;a?b:c&lt;/code&gt; is not a valid ternary expression (but a newline is acceptable after both the &lt;code&gt;?&lt;/code&gt; and the &lt;code&gt;:&lt;/code&gt;).</source>
          <target state="translated">La expresi&amp;oacute;n &lt;code&gt;a&lt;/code&gt; , antes de &lt;code&gt;?&lt;/code&gt; , es una expresi&amp;oacute;n de condici&amp;oacute;n, y la operaci&amp;oacute;n ternaria eval&amp;uacute;a la expresi&amp;oacute;n &lt;code&gt;b&lt;/code&gt; , antes de &lt;code&gt;:&lt;/code&gt; , si la condici&amp;oacute;n &lt;code&gt;a&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; o la expresi&amp;oacute;n &lt;code&gt;c&lt;/code&gt; , despu&amp;eacute;s de &lt;code&gt;:&lt;/code&gt; , si es &lt;code&gt;false&lt;/code&gt; . Tenga en cuenta que los espacios alrededor &lt;code&gt;?&lt;/code&gt; y &lt;code&gt;:&lt;/code&gt; son obligatorios: una expresi&amp;oacute;n como &lt;code&gt;a?b:c&lt;/code&gt; no es una expresi&amp;oacute;n ternaria v&amp;aacute;lida (pero una nueva l&amp;iacute;nea es aceptable despu&amp;eacute;s de &lt;code&gt;?&lt;/code&gt; y &lt;code&gt;:&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="465bf593bbe53b12eb7783b96c9712a167cf8578" translate="yes" xml:space="preserve">
          <source>The expression passed to the &lt;a href=&quot;#Base.Meta.parse-Tuple%7BAbstractString,Int64%7D&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function could not be interpreted as a valid Julia expression.</source>
          <target state="translated">La expresi&amp;oacute;n pasada a la funci&amp;oacute;n de &lt;a href=&quot;#Base.Meta.parse-Tuple%7BAbstractString,Int64%7D&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; no se pudo interpretar como una expresi&amp;oacute;n de Julia v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="a177c1288ef44211cc6e949df284aa83f006f7fc" translate="yes" xml:space="preserve">
          <source>The extension given by the constant &lt;code&gt;dlext&lt;/code&gt; (&lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dll&lt;/code&gt;, or &lt;code&gt;.dylib&lt;/code&gt;) can be omitted from the &lt;code&gt;libfile&lt;/code&gt; string, as it is automatically appended if needed. If &lt;code&gt;libfile&lt;/code&gt; is not an absolute path name, then the paths in the array &lt;code&gt;DL_LOAD_PATH&lt;/code&gt; are searched for &lt;code&gt;libfile&lt;/code&gt;, followed by the system load path.</source>
          <target state="translated">La extensi&amp;oacute;n propuesta por el constante &lt;code&gt;dlext&lt;/code&gt; ( &lt;code&gt;.so&lt;/code&gt; , &lt;code&gt;.dll&lt;/code&gt; , o &lt;code&gt;.dylib&lt;/code&gt; ) se puede omitir de la &lt;code&gt;libfile&lt;/code&gt; cadena, ya que se a&amp;ntilde;ade autom&amp;aacute;ticamente si es necesario. Si &lt;code&gt;libfile&lt;/code&gt; no es un nombre de ruta absoluto, entonces se buscan las rutas de la matriz &lt;code&gt;DL_LOAD_PATH&lt;/code&gt; para &lt;code&gt;libfile&lt;/code&gt; , seguidas de la ruta de carga del sistema.</target>
        </trans-unit>
        <trans-unit id="36c16e65be4afc2c66cb3288c6300982f05c7ad1" translate="yes" xml:space="preserve">
          <source>The fact that the type of &lt;code&gt;m.a&lt;/code&gt; is known from &lt;code&gt;m&lt;/code&gt;'s type&amp;mdash;coupled with the fact that its type cannot change mid-function&amp;mdash;allows the compiler to generate highly-optimized code for objects like &lt;code&gt;m&lt;/code&gt; but not for objects like &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">El hecho de que el tipo de &lt;code&gt;m.a&lt;/code&gt; se conozca a partir del tipo de &lt;code&gt;m&lt;/code&gt; &amp;mdash; junto con el hecho de que su tipo no puede cambiar en funci&amp;oacute;n de la mitad &amp;mdash; permite al compilador generar c&amp;oacute;digo altamente optimizado para objetos como &lt;code&gt;m&lt;/code&gt; pero no para objetos como &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c52690600fcbcb99da1f62c4bac2b9e5d6f697" translate="yes" xml:space="preserve">
          <source>The fallback definition is</source>
          <target state="translated">La definición alternativa es</target>
        </trans-unit>
        <trans-unit id="ee6beb39d94f4bf27bb085bd2200c292b19c5e9a" translate="yes" xml:space="preserve">
          <source>The fields represent:</source>
          <target state="translated">Los campos representan:</target>
        </trans-unit>
        <trans-unit id="c9020dd8336689ac7fec628824c2784dbf9a80fb" translate="yes" xml:space="preserve">
          <source>The file is passed via the stream argument, either as an open &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; or filename string. When you initialize the stream, use &lt;code&gt;&quot;r&quot;&lt;/code&gt; for a &quot;read-only&quot; array, and &lt;code&gt;&quot;w+&quot;&lt;/code&gt; to create a new array used to write values to disk.</source>
          <target state="translated">El archivo se pasa a trav&amp;eacute;s del argumento de flujo, ya sea como un &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt; abierto o una cadena de nombre de archivo. Cuando inicialice la secuencia, utilice &lt;code&gt;&quot;r&quot;&lt;/code&gt; para una matriz de &quot;solo lectura&quot; y &lt;code&gt;&quot;w+&quot;&lt;/code&gt; para crear una nueva matriz que se utilizar&amp;aacute; para escribir valores en el disco.</target>
        </trans-unit>
        <trans-unit id="689e05efadfddad191a25330c014009d3e84b447" translate="yes" xml:space="preserve">
          <source>The file-system preferred block size for the file</source>
          <target state="translated">El tamaño de bloque preferido por el sistema de archivos para el archivo</target>
        </trans-unit>
        <trans-unit id="c3038fc2cf1255c7ec1e11b0a18b74e94018430a" translate="yes" xml:space="preserve">
          <source>The final call to &lt;code&gt;qsort&lt;/code&gt; looks like this:</source>
          <target state="translated">La llamada final a &lt;code&gt;qsort&lt;/code&gt; se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7d988c680830d3c098bed962d30d54cd701b74ad" translate="yes" xml:space="preserve">
          <source>The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:</source>
          <target state="translated">El último problema que aún no se ha abordado es la construcción de objetos autorreferenciales,o más generalmente,estructuras de datos recursivos.Como la dificultad fundamental puede no ser inmediatamente obvia,vamos a explicarla brevemente.Consideremos la siguiente declaración de tipo recursivo:</target>
        </trans-unit>
        <trans-unit id="2c490723b997dd55f5ce00727bf52c98838be748" translate="yes" xml:space="preserve">
          <source>The first &quot;important&quot; line in this output is this one:</source>
          <target state="translated">La primera línea &quot;importante&quot; en esta salida es esta:</target>
        </trans-unit>
        <trans-unit id="355a754edd3ac1108f8aa47f09609e4797573a28" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;old&lt;/code&gt; is the signature of the deprecated method, the second one &lt;code&gt;new&lt;/code&gt; is the call which replaces it. &lt;code&gt;@deprecate&lt;/code&gt; exports &lt;code&gt;old&lt;/code&gt; unless the optional third argument is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">El primer argumento &lt;code&gt;old&lt;/code&gt; es la firma del m&amp;eacute;todo obsoleto, el segundo &lt;code&gt;new&lt;/code&gt; es la llamada que lo reemplaza. &lt;code&gt;@deprecate&lt;/code&gt; exporta &lt;code&gt;old&lt;/code&gt; menos que el tercer argumento opcional sea &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca4a6f093dfc816b748358bcada908fd4397bf69" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; can be marked with a &lt;code&gt;$&lt;/code&gt;, in which case the return value will instead be a &lt;code&gt;struct CFunction&lt;/code&gt; which closes over the argument. You must ensure that this return object is kept alive until all uses of it are done. The contents and code at the cfunction pointer will be erased via a &lt;a href=&quot;../../base/base/index#Base.finalizer&quot;&gt;&lt;code&gt;finalizer&lt;/code&gt;&lt;/a&gt; when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don't provide a separate closure environment parameter.</source>
          <target state="translated">El primer argumento de &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt; se puede marcar con un &lt;code&gt;$&lt;/code&gt; , en cuyo caso el valor de retorno ser&amp;aacute; una &lt;code&gt;struct CFunction&lt;/code&gt; que se cierra sobre el argumento. Debe asegurarse de que este objeto de devoluci&amp;oacute;n se mantenga activo hasta que se realicen todos los usos. El contenido y el c&amp;oacute;digo en el puntero de funci&amp;oacute;n se borrar&amp;aacute;n a trav&amp;eacute;s de un &lt;a href=&quot;../../base/base/index#Base.finalizer&quot;&gt; &lt;code&gt;finalizer&lt;/code&gt; &lt;/a&gt; cuando esta referencia se elimine y desaparezca. Por lo general, esto no es necesario, ya que esta funcionalidad no est&amp;aacute; presente en C, pero puede ser &amp;uacute;til para tratar con API mal dise&amp;ntilde;adas que no proporcionan un par&amp;aacute;metro de entorno de cierre separado.</target>
        </trans-unit>
        <trans-unit id="693dd527818a9b4cb2e07e46d1435896bbc1c434" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; can also be an expression evaluated at run time. In this case, the expression must evaluate to a &lt;code&gt;Ptr&lt;/code&gt;, which will be used as the address of the native function to call. This behavior occurs when the first &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.</source>
          <target state="translated">El primer argumento de &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n puede ser una expresi&amp;oacute;n evaluada en tiempo de ejecuci&amp;oacute;n. En este caso, la expresi&amp;oacute;n debe evaluar a un &lt;code&gt;Ptr&lt;/code&gt; , que se utilizar&amp;aacute; como la direcci&amp;oacute;n de la funci&amp;oacute;n nativa a llamar. Este comportamiento se produce cuando el primer argumento &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; contiene referencias a no constantes, como variables locales, argumentos de funci&amp;oacute;n o globales no constantes.</target>
        </trans-unit>
        <trans-unit id="145bbc0abe5deab0a11d30eff56416193fa999ea" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;remotecall&lt;/code&gt; is the function to call. Most parallel programming in Julia does not reference specific processes or the number of processes available, but &lt;code&gt;remotecall&lt;/code&gt; is considered a low-level interface providing finer control. The second argument to &lt;code&gt;remotecall&lt;/code&gt; is the &lt;code&gt;id&lt;/code&gt; of the process that will do the work, and the remaining arguments will be passed to the function being called.</source>
          <target state="translated">El primer argumento para &lt;code&gt;remotecall&lt;/code&gt; es la funci&amp;oacute;n a llamar. La mayor&amp;iacute;a de la programaci&amp;oacute;n paralela en Julia no hace referencia a procesos espec&amp;iacute;ficos ni al n&amp;uacute;mero de procesos disponibles, pero &lt;code&gt;remotecall&lt;/code&gt; se considera una interfaz de bajo nivel que proporciona un control m&amp;aacute;s preciso . El segundo argumento para &lt;code&gt;remotecall&lt;/code&gt; es la &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n del proceso que har&amp;aacute; el trabajo, y los argumentos restantes se pasar&amp;aacute;n a la funci&amp;oacute;n que se llama.</target>
        </trans-unit>
        <trans-unit id="25e1aab2d5890f1ec3fee29d387628c8119eeb0c" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;show&lt;/code&gt; can be an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; specifying output format properties. See &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">El primer argumento a &lt;code&gt;show&lt;/code&gt; puede ser un &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; que&lt;/a&gt; especifique las propiedades del formato de salida. Consulte &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="52b90970f0dc891c8696d7672a072123d726419a" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; is executed when &lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; is called. The resulting expression contains &lt;em&gt;only&lt;/em&gt; the second &lt;code&gt;println&lt;/code&gt;:</source>
          <target state="translated">La primera llamada a &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt; se ejecuta cuando se llama a &lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; &lt;/a&gt; . La expresi&amp;oacute;n resultante contiene &lt;em&gt;solo&lt;/em&gt; el segundo &lt;code&gt;println&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8464368be55c0ee0f473e53693ff139c3f5a4a18" translate="yes" xml:space="preserve">
          <source>The first case works, because the last character &lt;code&gt;y&lt;/code&gt; and the space are one-byte characters, whereas &lt;code&gt;end-2&lt;/code&gt; indexes into the middle of the &lt;code&gt;&amp;exist;&lt;/code&gt; multibyte representation. The correct way for this case is using &lt;code&gt;prevind(s, lastindex(s), 2)&lt;/code&gt; or, if you're using that value to index into &lt;code&gt;s&lt;/code&gt; you can write &lt;code&gt;s[prevind(s, end, 2)]&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; expands to &lt;code&gt;lastindex(s)&lt;/code&gt;.</source>
          <target state="translated">El primer caso funciona, porque el &amp;uacute;ltimo car&amp;aacute;cter &lt;code&gt;y&lt;/code&gt; y el espacio son caracteres de un byte, mientras que &lt;code&gt;end-2&lt;/code&gt; indexa en el medio de la representaci&amp;oacute;n &lt;code&gt;&amp;exist;&lt;/code&gt; multibyte. La forma correcta para este caso es usar &lt;code&gt;prevind(s, lastindex(s), 2)&lt;/code&gt; o, si est&amp;aacute; usando ese valor para indexar en &lt;code&gt;s&lt;/code&gt; , puede escribir &lt;code&gt;s[prevind(s, end, 2)]&lt;/code&gt; y &lt;code&gt;end&lt;/code&gt; se expande a &lt;code&gt;lastindex(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cae7754ed7d4e8921dc21019e00cb20a90b09dbc" translate="yes" xml:space="preserve">
          <source>The first construct is used when you need the value, but not index, of each element. In the second construct, &lt;code&gt;i&lt;/code&gt; will be an &lt;code&gt;Int&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an array type with fast linear indexing; otherwise, it will be a &lt;code&gt;CartesianIndex&lt;/code&gt;:</source>
          <target state="translated">La primera construcci&amp;oacute;n se usa cuando necesita el valor, pero no el &amp;iacute;ndice, de cada elemento. En la segunda construcci&amp;oacute;n, &lt;code&gt;i&lt;/code&gt; ser&amp;aacute; un &lt;code&gt;Int&lt;/code&gt; si &lt;code&gt;A&lt;/code&gt; es un tipo de matriz con indexaci&amp;oacute;n lineal r&amp;aacute;pida; de lo contrario, ser&amp;aacute; un &lt;code&gt;CartesianIndex&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a131f32e4f6815b22742934540634fef42489da" translate="yes" xml:space="preserve">
          <source>The first entry is the &quot;user depot&quot; and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.</source>
          <target state="translated">La primera entrada es el &quot;depósito del usuario&quot; y debe ser escribible y propiedad del usuario actual.El depósito del usuario es donde:se clonan los registros,se instalan nuevas versiones de los paquetes,se crean y actualizan los entornos con nombre,se clonan los repositorios de paquetes,se guardan los archivos de imagen de los paquetes recién compilados,se escriben los archivos de registro,se comprueban los paquetes de desarrollo de forma predeterminada y se guardan los datos de configuración global.Las entradas posteriores en la ruta de depósito se tratan como de sólo lectura y son apropiadas para los registros,paquetes,etc.instalados y gestionados por los administradores del sistema.</target>
        </trans-unit>
        <trans-unit id="006a5d47461c1a2f566eaae2f91fca6d12ba4594" translate="yes" xml:space="preserve">
          <source>The first five control flow mechanisms are standard to high-level programming languages. &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s are not so standard: they provide non-local control flow, making it possible to switch between temporarily-suspended computations. This is a powerful construct: both exception handling and cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no direct usage of tasks, but certain problems can be solved much more easily by using tasks.</source>
          <target state="translated">Los primeros cinco mecanismos de control de flujo son est&amp;aacute;ndar para lenguajes de programaci&amp;oacute;n de alto nivel. &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; no son tan est&amp;aacute;ndar: proporcionan un flujo de control no local, lo que permite cambiar entre c&amp;aacute;lculos suspendidos temporalmente. Esta es una construcci&amp;oacute;n poderosa: tanto el manejo de excepciones como la multitarea cooperativa se implementan en Julia usando tareas. La programaci&amp;oacute;n diaria no requiere el uso directo de tareas, pero ciertos problemas se pueden resolver mucho m&amp;aacute;s f&amp;aacute;cilmente mediante el uso de tareas.</target>
        </trans-unit>
        <trans-unit id="bc720da072f28a4dbfd483b203295a21a9e3bf91" translate="yes" xml:space="preserve">
          <source>The first index</source>
          <target state="translated">El primer índice</target>
        </trans-unit>
        <trans-unit id="2eaf288e228785826b1d737a1c9027a7797306cf" translate="yes" xml:space="preserve">
          <source>The first index, used in &lt;code&gt;X[begin]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb11ec038c2596553227120950a5afbedeee7655" translate="yes" xml:space="preserve">
          <source>The first line &amp;ndash; &lt;code&gt;struct OurRational{T&amp;lt;:Integer} &amp;lt;: Real&lt;/code&gt; &amp;ndash; declares that &lt;code&gt;OurRational&lt;/code&gt; takes one type parameter of an integer type, and is itself a real type. The field declarations &lt;code&gt;num::T&lt;/code&gt; and &lt;code&gt;den::T&lt;/code&gt; indicate that the data held in a &lt;code&gt;OurRational{T}&lt;/code&gt; object are a pair of integers of type &lt;code&gt;T&lt;/code&gt;, one representing the rational value's numerator and the other representing its denominator.</source>
          <target state="translated">La primera l&amp;iacute;nea - &lt;code&gt;struct OurRational{T&amp;lt;:Integer} &amp;lt;: Real&lt;/code&gt; - declara que &lt;code&gt;OurRational&lt;/code&gt; toma un par&amp;aacute;metro de tipo de un tipo entero y es en s&amp;iacute; mismo un tipo real. Las declaraciones de campo &lt;code&gt;num::T&lt;/code&gt; y &lt;code&gt;den::T&lt;/code&gt; indican que los datos contenidos en un objeto &lt;code&gt;OurRational{T}&lt;/code&gt; son un par de enteros de tipo &lt;code&gt;T&lt;/code&gt; , uno que representa el numerador del valor racional y el otro que representa su denominador.</target>
        </trans-unit>
        <trans-unit id="427adf0e5c19944f265b6711e004071ffee6d958" translate="yes" xml:space="preserve">
          <source>The first line shows that 80 backtraces were taken at line 73 of &lt;code&gt;event.jl&lt;/code&gt;, but it's not that this line was &quot;expensive&quot; on its own: the third line reveals that all 80 of these backtraces were actually triggered inside its call to &lt;code&gt;eval_user_input&lt;/code&gt;, and so on. To find out which operations are actually taking the time, we need to look deeper in the call chain.</source>
          <target state="translated">La primera l&amp;iacute;nea muestra que se tomaron 80 backtraces en la l&amp;iacute;nea 73 de &lt;code&gt;event.jl&lt;/code&gt; , pero no es que esta l&amp;iacute;nea fuera &quot;costosa&quot; por s&amp;iacute; sola: la tercera l&amp;iacute;nea revela que los 80 de estos backtraces en realidad se activaron dentro de su llamada a &lt;code&gt;eval_user_input&lt;/code&gt; , y as&amp;iacute;. Para averiguar qu&amp;eacute; operaciones est&amp;aacute;n tomando realmente el tiempo necesario, debemos profundizar en la cadena de llamadas.</target>
        </trans-unit>
        <trans-unit id="37442d0cb92e69637999d8ebca28303617dca96e" translate="yes" xml:space="preserve">
          <source>The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of the same type:</source>
          <target state="translated">El primer método se aplica siempre que ambos argumentos son del mismo tipo concreto,independientemente del tipo que sea,mientras que el segundo método actúa como un &quot;catch-all&quot;,abarcando todos los demás casos.Así,en conjunto,esto define una función booleana que comprueba si sus dos argumentos son del mismo tipo:</target>
        </trans-unit>
        <trans-unit id="babb1cbcd790c4e72ac9f6036b92d0c0da3483a5" translate="yes" xml:space="preserve">
          <source>The first rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator type is the result of promotion of its numerator/denominator type with the other integer type. The second rule applies the same logic to two different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The third and final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the float.</source>
          <target state="translated">La primera regla dice que la promoción de un número racional con cualquier otro tipo de número entero promueve a un tipo racional cuyo tipo numerador/denominador es el resultado de la promoción de su tipo numerador/denominador con el otro tipo de número entero.La segunda regla aplica la misma lógica a dos tipos diferentes de números racionales,resultando en una racionalidad de la promoción de sus respectivos tipos de numerador/denominador.La tercera y última regla dicta que la promoción de un racional con un flotador resulta en el mismo tipo que la promoción del tipo numerador/denominador con el flotador.</target>
        </trans-unit>
        <trans-unit id="5020af03736f636ddf8f18f7a30cb8b1c77d29b4" translate="yes" xml:space="preserve">
          <source>The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling &lt;code&gt;jl_init&lt;/code&gt;, which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to load, use &lt;code&gt;jl_init_with_image&lt;/code&gt; instead.</source>
          <target state="translated">Lo primero que debe hacerse antes de llamar a cualquier otra funci&amp;oacute;n de Julia C es inicializar Julia. Esto se hace llamando a &lt;code&gt;jl_init&lt;/code&gt; , que intenta determinar autom&amp;aacute;ticamente la ubicaci&amp;oacute;n de instalaci&amp;oacute;n de Julia. Si necesita especificar una ubicaci&amp;oacute;n personalizada, o especificar qu&amp;eacute; imagen del sistema cargar, use &lt;code&gt;jl_init_with_image&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="e2b9f2f10b840e10d0a053fb01cc746ce6f7be51" translate="yes" xml:space="preserve">
          <source>The first thing to note is that the above argument declarations are equivalent to &lt;code&gt;x::Any&lt;/code&gt; and &lt;code&gt;y::Any&lt;/code&gt;. When this function is invoked, say as &lt;code&gt;myplus(2,5)&lt;/code&gt;, the dispatcher chooses the most specific method named &lt;code&gt;myplus&lt;/code&gt; that matches the given arguments. (See &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt; for more information on multiple dispatch.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823f93752a3686f8e2124abf1332680955d50534" translate="yes" xml:space="preserve">
          <source>The first thing to note is that the above argument declarations are equivalent to &lt;code&gt;x::Any&lt;/code&gt; and &lt;code&gt;y::Any&lt;/code&gt;. When this function is invoked, say as &lt;code&gt;myplus(2,5)&lt;/code&gt;, the dispatcher chooses the most specific method named &lt;code&gt;myplus&lt;/code&gt; that matches the given arguments. (See &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on multiple dispatch.)</source>
          <target state="translated">Lo primero que hay que tener en cuenta es que las declaraciones de los argumentos anteriores son equivalentes &lt;code&gt;x::Any&lt;/code&gt; y &lt;code&gt;y::Any&lt;/code&gt; . Cuando se invoca esta funci&amp;oacute;n, digamos como &lt;code&gt;myplus(2,5)&lt;/code&gt; , el despachador elige el m&amp;eacute;todo m&amp;aacute;s espec&amp;iacute;fico llamado &lt;code&gt;myplus&lt;/code&gt; que coincide con los argumentos dados. (Consulte &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;M&amp;eacute;todos&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el env&amp;iacute;o m&amp;uacute;ltiple).</target>
        </trans-unit>
        <trans-unit id="a6f07b43794fd555596c18f4ead21c7719a2dcd3" translate="yes" xml:space="preserve">
          <source>The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:</source>
          <target state="translated">La primera versión del código forma una cadena,luego la escribe en el archivo,mientras que la segunda versión escribe los valores directamente en el archivo.También noten que en algunos casos la interpolación de cadenas puede ser más difícil de leer.Considere:</target>
        </trans-unit>
        <trans-unit id="7b79b92115c47e04b621f66bea7584e8b8cc8d6b" translate="yes" xml:space="preserve">
          <source>The floating-point literal expression &lt;code&gt;1e10&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;1&lt;/code&gt; multiplied by the variable &lt;code&gt;e10&lt;/code&gt;, and similarly with the equivalent &lt;code&gt;E&lt;/code&gt; form.</source>
          <target state="translated">La expresi&amp;oacute;n literal de coma flotante &lt;code&gt;1e10&lt;/code&gt; podr&amp;iacute;a interpretarse como el literal num&amp;eacute;rico &lt;code&gt;1&lt;/code&gt; multiplicado por la variable &lt;code&gt;e10&lt;/code&gt; , y de manera similar con la forma &lt;code&gt;E&lt;/code&gt; equivalente .</target>
        </trans-unit>
        <trans-unit id="cbff4b9b06b08e6ec4a779cfee60c358c056ae65" translate="yes" xml:space="preserve">
          <source>The floored quotient and modulus after division. A convenience wrapper for &lt;code&gt;divrem(x, y, RoundDown)&lt;/code&gt;. Equivalent to &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f774bd2a3cc1859a12b8ce9ea22d04daec926b" translate="yes" xml:space="preserve">
          <source>The floored quotient and modulus after division. Equivalent to &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt;.</source>
          <target state="translated">El cociente y el m&amp;oacute;dulo de suelo despu&amp;eacute;s de la divisi&amp;oacute;n. Equivalente a &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc58e18ac764f385326b970e654dea814c444fa3" translate="yes" xml:space="preserve">
          <source>The folder &lt;code&gt;clustermanager/0mq&lt;/code&gt; in the &lt;a href=&quot;https://github.com/JuliaAttic/Examples&quot;&gt;Examples repository&lt;/a&gt; contains an example of using ZeroMQ to connect Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all &lt;em&gt;logically&lt;/em&gt; connected to each other&amp;ndash;any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer.</source>
          <target state="translated">La carpeta &lt;code&gt;clustermanager/0mq&lt;/code&gt; en el &lt;a href=&quot;https://github.com/JuliaAttic/Examples&quot;&gt;repositorio de ejemplos&lt;/a&gt; contiene un ejemplo del uso de ZeroMQ para conectar a los trabajadores de Julia en una topolog&amp;iacute;a en estrella con un br&amp;oacute;ker 0MQ en el medio. Nota: Los procesos de Julia todav&amp;iacute;a est&amp;aacute;n conectados &lt;em&gt;l&amp;oacute;gicamente&lt;/em&gt; entre s&amp;iacute;; cualquier trabajador puede enviar mensajes a cualquier otro trabajador directamente sin darse cuenta de que 0MQ se utiliza como capa de transporte.</target>
        </trans-unit>
        <trans-unit id="a25bab23609fe72a03f9f2d28cbc6e4cfaac93b5" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations&quot;&gt;arithmetic operators&lt;/a&gt; are supported on all primitive numeric types:</source>
          <target state="translated">Los siguientes &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations&quot;&gt;operadores aritm&amp;eacute;ticos&lt;/a&gt; son compatibles con todos los tipos num&amp;eacute;ricos primitivos:</target>
        </trans-unit>
        <trans-unit id="b432537d382d58fcb2012895b80fa177f57617f4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators&quot;&gt;bitwise operators&lt;/a&gt; are supported on all primitive integer types:</source>
          <target state="translated">Los siguientes &lt;a href=&quot;https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators&quot;&gt;operadores bit a bit&lt;/a&gt; son compatibles con todos los tipos de enteros primitivos:</target>
        </trans-unit>
        <trans-unit id="bc2ce27e5cd51f5b5da2d26eef20e592177e82dd" translate="yes" xml:space="preserve">
          <source>The following Julia code calls &lt;code&gt;dist&lt;/code&gt; using &lt;code&gt;ccall&lt;/code&gt;:</source>
          <target state="translated">El siguiente c&amp;oacute;digo de Julia llama a &lt;code&gt;dist&lt;/code&gt; usando &lt;code&gt;ccall&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="82ab1c7eae6116d2e86f4fd6447f19f5008f2767" translate="yes" xml:space="preserve">
          <source>The following are Julia's primitive numeric types:</source>
          <target state="translated">Los siguientes son los tipos numéricos primitivos de Julia:</target>
        </trans-unit>
        <trans-unit id="68261312da3f6e4277114d21e46489769870f01a" translate="yes" xml:space="preserve">
          <source>The following arguments, if any, are the actual argument values passed to the function.</source>
          <target state="translated">Los siguientes argumentos,si los hay,son los valores reales de los argumentos pasados a la función.</target>
        </trans-unit>
        <trans-unit id="33f4f41b4dfa9a0ce6359f8eda915a3bfda673bd" translate="yes" xml:space="preserve">
          <source>The following defines the usage of terminal-based &lt;code&gt;emacs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="345825a433cae3afd4ca7643a01203ee8503ec4c" translate="yes" xml:space="preserve">
          <source>The following elements can be written either at the &quot;toplevel&quot; of a document or within another &quot;toplevel&quot; element.</source>
          <target state="translated">Los siguientes elementos pueden escribirse ya sea en el &quot;nivel superior&quot; de un documento o dentro de otro elemento &quot;superior&quot;.</target>
        </trans-unit>
        <trans-unit id="5790b1d96d0b783ee001251802dd3d3773c38e07" translate="yes" xml:space="preserve">
          <source>The following escape sequences are recognised:</source>
          <target state="translated">Se reconocen las siguientes secuencias de escape:</target>
        </trans-unit>
        <trans-unit id="b2e62d45eb7d1c7cb2ac8b8faa743869642b4084" translate="yes" xml:space="preserve">
          <source>The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid. :</source>
          <target state="translated">El siguiente ejemplo calcula un promedio ponderado del elemento actual y su vecino izquierdo y derecho a lo largo de una cuadrícula 1-d.:</target>
        </trans-unit>
        <trans-unit id="07c71a4306d82cac91450f4de662495a1563cd2f" translate="yes" xml:space="preserve">
          <source>The following example computes the QR decomposition of a small section of a larger array, without creating any temporaries, and by calling the appropriate LAPACK function with the right leading dimension size and stride parameters.</source>
          <target state="translated">El siguiente ejemplo calcula la descomposición QR de una pequeña sección de un conjunto mayor,sin crear ningún temporal,y llamando a la función LAPACK apropiada con el tamaño de la dimensión principal correcta y los parámetros de zancada.</target>
        </trans-unit>
        <trans-unit id="01c45a39447b88a2e0d45df263308e82a86e4712" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the major features of modules. It is not meant to be run, but is shown for illustrative purposes:</source>
          <target state="translated">El siguiente ejemplo demuestra las principales características de los módulos.No está pensado para ser ejecutado,pero se muestra con fines ilustrativos:</target>
        </trans-unit>
        <trans-unit id="f3dad0aa9d2fe2847f41cefe7b11a1e7d6233556" translate="yes" xml:space="preserve">
          <source>The following example utilizes ccall to call a function in a common Fortran library (libBLAS) to computes a dot product. Notice that the argument mapping is a bit different here than above, as we need to map from Julia to Fortran. On every argument type, we specify &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;Ptr&lt;/code&gt;. This mangling convention may be specific to your fortran compiler and operating system, and is likely undocumented. However, wrapping each in a &lt;code&gt;Ref&lt;/code&gt; (or &lt;code&gt;Ptr&lt;/code&gt;, where equivalent) is a frequent requirement of Fortran compiler implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec34fbe859ef32bab5a71865f07de40a61bead9c" translate="yes" xml:space="preserve">
          <source>The following examples highlight execution in different tasks by returning the &lt;code&gt;objectid&lt;/code&gt; of the tasks in which the mapping function is executed.</source>
          <target state="translated">Los siguientes ejemplos resaltan la ejecuci&amp;oacute;n en diferentes tareas al devolver el &lt;code&gt;objectid&lt;/code&gt; de las tareas en las que se ejecuta la funci&amp;oacute;n de mapeo.</target>
        </trans-unit>
        <trans-unit id="874609aa4f87e9365e65a6b29283f60a85fb17ac" translate="yes" xml:space="preserve">
          <source>The following examples may help you interpret expressions marked as containing non-leaf types:</source>
          <target state="translated">Los siguientes ejemplos pueden ayudar a interpretar las expresiones marcadas como que contienen tipos sin hojas:</target>
        </trans-unit>
        <trans-unit id="cbdf8c8b616fe2394336d97bc9a1e9b4526f4626" translate="yes" xml:space="preserve">
          <source>The following examples show the different forms.</source>
          <target state="translated">Los siguientes ejemplos muestran las diferentes formas.</target>
        </trans-unit>
        <trans-unit id="e0233afcec03abf55b61a44d6697627a2028159d" translate="yes" xml:space="preserve">
          <source>The following functions are available for &lt;code&gt;BunchKaufman&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.issymmetric&quot;&gt;&lt;code&gt;issymmetric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.ishermitian&quot;&gt;&lt;code&gt;ishermitian&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Las siguientes funciones est&amp;aacute;n disponibles para los objetos &lt;code&gt;BunchKaufman&lt;/code&gt; : &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.issymmetric&quot;&gt; &lt;code&gt;issymmetric&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.ishermitian&quot;&gt; &lt;code&gt;ishermitian&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="624545d56fb5f27fa75152ac7cc2635666c3e206" translate="yes" xml:space="preserve">
          <source>The following functions are available for &lt;code&gt;Eigen&lt;/code&gt; objects: &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Las siguientes funciones est&amp;aacute;n disponibles para objetos &lt;code&gt;Eigen&lt;/code&gt; : &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; e &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f1aea27103439af78084bb11124346f279815f32" translate="yes" xml:space="preserve">
          <source>The following functions are available for the &lt;code&gt;QR&lt;/code&gt; objects: &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;\&lt;/code&gt;. When &lt;code&gt;A&lt;/code&gt; is rectangular, &lt;code&gt;\&lt;/code&gt; will return a least squares solution and if the solution is not unique, the one with smallest norm is returned. When &lt;code&gt;A&lt;/code&gt; is not full rank, factorization with (column) pivoting is required to obtain a minimum norm solution.</source>
          <target state="translated">Las siguientes funciones est&amp;aacute;n disponibles para los objetos &lt;code&gt;QR&lt;/code&gt; : &lt;code&gt;inv&lt;/code&gt; , &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;\&lt;/code&gt; . Cuando &lt;code&gt;A&lt;/code&gt; es rectangular, &lt;code&gt;\&lt;/code&gt; devolver&amp;aacute; una soluci&amp;oacute;n de m&amp;iacute;nimos cuadrados y si la soluci&amp;oacute;n no es &amp;uacute;nica, se devolver&amp;aacute; la que tenga la norma m&amp;aacute;s peque&amp;ntilde;a. Cuando &lt;code&gt;A&lt;/code&gt; no es de rango completo, se requiere la factorizaci&amp;oacute;n con pivote (columna) para obtener una soluci&amp;oacute;n de norma m&amp;iacute;nima.</target>
        </trans-unit>
        <trans-unit id="aabc44011e588107ac199e54e743b25f507c9ed0" translate="yes" xml:space="preserve">
          <source>The following functions are not exported:</source>
          <target state="translated">Las siguientes funciones no se exportan:</target>
        </trans-unit>
        <trans-unit id="688d351a0c5736fa7ecff6e47939996801847a5a" translate="yes" xml:space="preserve">
          <source>The following language constructs call &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">Las siguientes construcciones de lenguaje llaman a &lt;code&gt;convert&lt;/code&gt; ir :</target>
        </trans-unit>
        <trans-unit id="6c5e57131238ccfda9b38e0c3969a02ae25bed8d" translate="yes" xml:space="preserve">
          <source>The following methods and types in &lt;code&gt;Base.StackTraces&lt;/code&gt; are not exported and need to be called e.g. as &lt;code&gt;StackTraces.lookup(ptr)&lt;/code&gt;.</source>
          <target state="translated">Los siguientes m&amp;eacute;todos y tipos en &lt;code&gt;Base.StackTraces&lt;/code&gt; no se exportan y deben llamarse, por ejemplo, como &lt;code&gt;StackTraces.lookup(ptr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="427d5751feb1ea6470872d5f773b472a734eb30c" translate="yes" xml:space="preserve">
          <source>The following methods are described as &quot;unsafe&quot; because a bad pointer or type declaration can cause Julia to terminate abruptly.</source>
          <target state="translated">Los siguientes métodos se describen como &quot;inseguros&quot; porque un mal puntero o declaración de tipo puede hacer que Julia termine abruptamente.</target>
        </trans-unit>
        <trans-unit id="b0ebcfaf65e09f2421f1536d1962299cfa2d23fa" translate="yes" xml:space="preserve">
          <source>The following operators are supported for arrays:</source>
          <target state="translated">Los siguientes operadores son compatibles con las matrices:</target>
        </trans-unit>
        <trans-unit id="61cb6687852400c8b9d8a7c3529a66703d4cce18" translate="yes" xml:space="preserve">
          <source>The following properties are in common use:</source>
          <target state="translated">Las siguientes propiedades son de uso común:</target>
        </trans-unit>
        <trans-unit id="d1b72ce471ac18a5159131679678a4b35625017b" translate="yes" xml:space="preserve">
          <source>The following rules and examples pertain to local scopes. A newly introduced variable in a local scope cannot be referenced by a parent scope. For example, here the $z$ is not introduced into the top-level scope:</source>
          <target state="translated">Las siguientes reglas y ejemplos se refieren a los alcances locales.Una variable recién introducida en un ámbito local no puede ser referenciada por un ámbito superior.Por ejemplo,aquí los $z$ no se introducen en el ámbito de nivel superior:</target>
        </trans-unit>
        <trans-unit id="b337c7ef95094018464c8f26d41814785e93faec" translate="yes" xml:space="preserve">
          <source>The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to help familiarize you with the language and to help you choose among alternative designs.</source>
          <target state="translated">Las siguientes secciones explican algunos aspectos del estilo de codificación idiomática de Julia.Ninguna de estas reglas es absoluta;son sólo sugerencias para ayudar a familiarizarse con el lenguaje y para ayudar a elegir entre diseños alternativos.</target>
        </trans-unit>
        <trans-unit id="599c61734f3be9adb8efdea5a3e2879b8d0d65f5" translate="yes" xml:space="preserve">
          <source>The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix &lt;code&gt;S&lt;/code&gt;, or that the resulting sparse matrix has density &lt;code&gt;d&lt;/code&gt;, i.e. each matrix element has a probability &lt;code&gt;d&lt;/code&gt; of being non-zero.</source>
          <target state="translated">La siguiente tabla muestra una correspondencia entre los m&amp;eacute;todos integrados en matrices dispersas y sus m&amp;eacute;todos correspondientes en tipos de matrices densas. En general, los m&amp;eacute;todos que generan matrices dispersas difieren de sus contrapartes densas en que la matriz resultante sigue el mismo patr&amp;oacute;n de dispersi&amp;oacute;n que una matriz dispersa dada &lt;code&gt;S&lt;/code&gt; , o que la matriz dispersa resultante tiene densidad &lt;code&gt;d&lt;/code&gt; , es decir, cada elemento de la matriz tiene una probabilidad &lt;code&gt;d&lt;/code&gt; de ser distinto de cero.</target>
        </trans-unit>
        <trans-unit id="2850e916b8328a8067cb56753c2fae6f207d9a41" translate="yes" xml:space="preserve">
          <source>The following table lists Unicode characters that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL (and in various other editing environments). You can also get information on how to type a symbol by entering it in the REPL help, i.e. by typing &lt;code&gt;?&lt;/code&gt; and then entering the symbol in the REPL (e.g., by copy-paste from somewhere you saw the symbol).</source>
          <target state="translated">La siguiente tabla enumera los caracteres Unicode que se pueden ingresar a trav&amp;eacute;s de la terminaci&amp;oacute;n de tabulaci&amp;oacute;n de abreviaturas similares a LaTeX en Julia REPL (y en varios otros entornos de edici&amp;oacute;n). Tambi&amp;eacute;n puede obtener informaci&amp;oacute;n sobre c&amp;oacute;mo escribir un s&amp;iacute;mbolo ingres&amp;aacute;ndolo en la ayuda de REPL, es decir, escribiendo &lt;code&gt;?&lt;/code&gt; y luego ingresando el s&amp;iacute;mbolo en el REPL (por ejemplo, copiando y pegando desde alg&amp;uacute;n lugar donde vio el s&amp;iacute;mbolo).</target>
        </trans-unit>
        <trans-unit id="84caf0f2b4e520eb1362c7d90034a53ce384352e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the &lt;a href=&quot;#Standard-Functions-1&quot;&gt;Standard Functions&lt;/a&gt; section of the Linear Algebra documentation.</source>
          <target state="translated">La siguiente tabla resume los tipos de factorizaciones matriciales que se han implementado en Julia. Los detalles de sus m&amp;eacute;todos asociados se pueden encontrar en la secci&amp;oacute;n &lt;a href=&quot;#Standard-Functions-1&quot;&gt;Funciones est&amp;aacute;ndar&lt;/a&gt; de la documentaci&amp;oacute;n de &amp;Aacute;lgebra lineal.</target>
        </trans-unit>
        <trans-unit id="57acff1f14a6f50eb70fb52e043df3e1854283f1" translate="yes" xml:space="preserve">
          <source>The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the &lt;a href=&quot;#Standard-functions&quot;&gt;Standard functions&lt;/a&gt; section of the Linear Algebra documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e3ae439be1705d14dc31df2b803cc4528033bf" translate="yes" xml:space="preserve">
          <source>The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various optimized methods for them in LAPACK are available.</source>
          <target state="translated">En los siguientes cuadros se resumen los tipos de matrices especiales que se han aplicado en Julia,así como si se dispone de ganchos para diversos métodos optimizados para ellas en LAPACK.</target>
        </trans-unit>
        <trans-unit id="58787cfe45db809926391f964f8c2fe50eb9c66e" translate="yes" xml:space="preserve">
          <source>The following two-word sequences are reserved: &lt;code&gt;abstract type&lt;/code&gt;, &lt;code&gt;mutable struct&lt;/code&gt;, &lt;code&gt;primitive type&lt;/code&gt;. However, you can create variables with names: &lt;code&gt;abstract&lt;/code&gt;, &lt;code&gt;mutable&lt;/code&gt;, &lt;code&gt;primitive&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Las siguientes secuencias de dos palabras est&amp;aacute;n reservadas: &lt;code&gt;abstract type&lt;/code&gt; , &lt;code&gt;mutable struct&lt;/code&gt; , &lt;code&gt;primitive type&lt;/code&gt; . Sin embargo, puede crear variables con nombres: &lt;code&gt;abstract&lt;/code&gt; o , &lt;code&gt;mutable&lt;/code&gt; , &lt;code&gt;primitive&lt;/code&gt; y &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c16965f50c24120006902ac240b6d5249b8840ca" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.answer_color()&lt;/code&gt; (default: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt;) that output should have at the terminal.</source>
          <target state="translated">El formato &lt;code&gt;Base.answer_color()&lt;/code&gt; (predeterminado: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt; ) que debe tener la salida en el terminal.</target>
        </trans-unit>
        <trans-unit id="2a94f6ed982371cc454e13d3c41d22bd28f7000c" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.error_color()&lt;/code&gt; (default: light red, &lt;code&gt;&quot;\033[91m&quot;&lt;/code&gt;) that errors should have at the terminal.</source>
          <target state="translated">El formato &lt;code&gt;Base.error_color()&lt;/code&gt; (predeterminado: rojo claro, &lt;code&gt;&quot;\033[91m&quot;&lt;/code&gt; ) que deben tener los errores en el terminal.</target>
        </trans-unit>
        <trans-unit id="5bedb24b2b2a4f0d544b13331782037e6b751d7c" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.info_color()&lt;/code&gt; (default: cyan, &lt;code&gt;&quot;\033[36m&quot;&lt;/code&gt;) that info should have at the terminal.</source>
          <target state="translated">El formato &lt;code&gt;Base.info_color()&lt;/code&gt; (predeterminado: cian, &lt;code&gt;&quot;\033[36m&quot;&lt;/code&gt; ) que debe tener la informaci&amp;oacute;n en la terminal.</target>
        </trans-unit>
        <trans-unit id="9abdd1879aac44fbed37a23e8cd8c9521c6a3a7b" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.input_color()&lt;/code&gt; (default: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt;) that input should have at the terminal.</source>
          <target state="translated">El formato &lt;code&gt;Base.input_color()&lt;/code&gt; (predeterminado: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt; ) que la entrada debe tener en la terminal.</target>
        </trans-unit>
        <trans-unit id="5c3246893833440c6ee277a6f4469b2f678db3a7" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.stackframe_function_color()&lt;/code&gt; (default: bold, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt;) that function calls should have during a stack trace at the terminal.</source>
          <target state="translated">El formato &lt;code&gt;Base.stackframe_function_color()&lt;/code&gt; (predeterminado: negrita, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt; ) que deben tener las llamadas a funciones durante un seguimiento de pila en la terminal.</target>
        </trans-unit>
        <trans-unit id="276edac3df59db618aba660c48a61b72521725f5" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.stackframe_lineinfo_color()&lt;/code&gt; (default: bold, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt;) that line info should have during a stack trace at the terminal.</source>
          <target state="translated">El formato &lt;code&gt;Base.stackframe_lineinfo_color()&lt;/code&gt; (predeterminado: negrita, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt; ) que debe tener la informaci&amp;oacute;n de l&amp;iacute;nea durante un seguimiento de la pila en la terminal.</target>
        </trans-unit>
        <trans-unit id="5a3d58af274070ed561a7473fe7be9c81a95ede6" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.warn_color()&lt;/code&gt; (default: yellow, &lt;code&gt;&quot;\033[93m&quot;&lt;/code&gt;) that warnings should have at the terminal.</source>
          <target state="translated">El formato &lt;code&gt;Base.warn_color()&lt;/code&gt; (predeterminado: amarillo, &lt;code&gt;&quot;\033[93m&quot;&lt;/code&gt; ) que deben tener las advertencias en el terminal.</target>
        </trans-unit>
        <trans-unit id="e430bf906d90ec3cbe26e6641c11eeda24fe35ca" translate="yes" xml:space="preserve">
          <source>The former is a single character value of type &lt;code&gt;Char&lt;/code&gt;, while the latter is a string value that happens to contain only a single character. In Julia these are very different things.</source>
          <target state="translated">El primero es un valor de un solo car&amp;aacute;cter de tipo &lt;code&gt;Char&lt;/code&gt; , mientras que el &amp;uacute;ltimo es un valor de cadena que contiene solo un solo car&amp;aacute;cter. En Julia son cosas muy distintas.</target>
        </trans-unit>
        <trans-unit id="d152dae5600534a9646e1a87a36f09f36dd3ded5" translate="yes" xml:space="preserve">
          <source>The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; and the second due to the &lt;code&gt;fetch&lt;/code&gt; (or even a &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;fetch&lt;/code&gt;/&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; is also being executed serially resulting in an overall poorer performance.</source>
          <target state="translated">El primero da como resultado un &amp;uacute;nico viaje de ida y vuelta a la red para cada trabajador, mientras que el segundo da como resultado dos llamadas de red: primero por &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt; y el segundo debido a la &lt;code&gt;fetch&lt;/code&gt; (o incluso una &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; ). La &lt;code&gt;fetch&lt;/code&gt; / &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n se ejecuta en serie, lo que da como resultado un rendimiento general m&amp;aacute;s pobre.</target>
        </trans-unit>
        <trans-unit id="d93e33c90f8c053ee253be6b3d20b4b263f781d7" translate="yes" xml:space="preserve">
          <source>The fully expanded value of &lt;code&gt;LOAD_PATH&lt;/code&gt; that is searched for projects and packages can be seen by calling the &lt;code&gt;Base.load_path()&lt;/code&gt; function.</source>
          <target state="translated">El valor completamente expandido de &lt;code&gt;LOAD_PATH&lt;/code&gt; que se busca para proyectos y paquetes se puede ver llamando a la funci&amp;oacute;n &lt;code&gt;Base.load_path()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53cd7e3be35b834ce5e0e038f9eb6daebb41c365" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;count_heads&lt;/code&gt; simply adds together &lt;code&gt;n&lt;/code&gt; random bits. Here is how we can perform some trials on two machines, and add together the results:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;count_heads&lt;/code&gt; simplemente suma &lt;code&gt;n&lt;/code&gt; bits aleatorios. As&amp;iacute; es como podemos realizar algunas pruebas en dos m&amp;aacute;quinas y sumar los resultados:</target>
        </trans-unit>
        <trans-unit id="1a7009ac781780ee28678319854f5347c9495c13" translate="yes" xml:space="preserve">
          <source>The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.</source>
          <target state="translated">La llamada de función creció más allá del tamaño de la pila de llamadas.Esto suele suceder cuando una llamada se repite infinitamente.</target>
        </trans-unit>
        <trans-unit id="da6b2e5a2ff44122d7db169754c14ee6b172e967" translate="yes" xml:space="preserve">
          <source>The function in which &lt;code&gt;@boundscheck&lt;/code&gt; is written must be inlined into its caller in order for &lt;code&gt;@inbounds&lt;/code&gt; to have effect.</source>
          <target state="translated">La funci&amp;oacute;n en la que est&amp;aacute; escrito &lt;code&gt;@boundscheck&lt;/code&gt; debe estar insertada en su llamador para que &lt;code&gt;@inbounds&lt;/code&gt; tenga efecto.</target>
        </trans-unit>
        <trans-unit id="39d7cf55fabb709098be0379cf1a36954e7ad2fc" translate="yes" xml:space="preserve">
          <source>The function parameter &lt;code&gt;f&lt;/code&gt; should have following signature:</source>
          <target state="translated">El par&amp;aacute;metro de funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; debe tener la siguiente firma:</target>
        </trans-unit>
        <trans-unit id="c1a0f9cdfffaafbbc345f4ef6dcd681fce922423" translate="yes" xml:space="preserve">
          <source>The function reads the cookie from stdin if required, and listens on a free port (or if specified, the port in the &lt;code&gt;--bind-to&lt;/code&gt; command line option) and schedules tasks to process incoming TCP connections and requests. It also (optionally) closes stdin and redirects stderr to stdout.</source>
          <target state="translated">La funci&amp;oacute;n lee la cookie desde stdin si es necesario y escucha en un puerto libre (o si se especifica, el puerto en la opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;code&gt;--bind-to&lt;/code&gt; ) y programa tareas para procesar las conexiones y solicitudes TCP entrantes. Tambi&amp;eacute;n (opcionalmente) cierra stdin y redirige stderr a stdout.</target>
        </trans-unit>
        <trans-unit id="9bbfa1f4c4ac027f7439aa3d2df2d4291e74275a" translate="yes" xml:space="preserve">
          <source>The function's return type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b716ab0d4ac152e4a4f9c6b1390eb5136f17d5d2" translate="yes" xml:space="preserve">
          <source>The garbage collector does not guarantee any order of finalization. That is, if &lt;code&gt;a&lt;/code&gt; contained a reference to &lt;code&gt;b&lt;/code&gt; and both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are due for garbage collection, there is no guarantee that &lt;code&gt;b&lt;/code&gt; would be finalized after &lt;code&gt;a&lt;/code&gt;. If proper finalization of &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;b&lt;/code&gt; being valid, it must be handled in other ways.</source>
          <target state="translated">El recolector de basura no garantiza ning&amp;uacute;n orden de finalizaci&amp;oacute;n. Es decir, si &lt;code&gt;a&lt;/code&gt; contiene una referencia &lt;code&gt;b&lt;/code&gt; y tanto &lt;code&gt;a&lt;/code&gt; como &lt;code&gt;b&lt;/code&gt; deben ser recolectados de basura, no hay garant&amp;iacute;a de que &lt;code&gt;b&lt;/code&gt; se finalice despu&amp;eacute;s de &lt;code&gt;a&lt;/code&gt; . Si la finalizaci&amp;oacute;n adecuada de &lt;code&gt;a&lt;/code&gt; depende de que &lt;code&gt;b&lt;/code&gt; sea ​​v&amp;aacute;lida, debe manejarse de otras formas.</target>
        </trans-unit>
        <trans-unit id="2c5ffa9d8537b10e07bd1e1cd0016a03d6887376" translate="yes" xml:space="preserve">
          <source>The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the &lt;code&gt;jl_gc_wb&lt;/code&gt; (write barrier) function like so:</source>
          <target state="translated">El recolector de basura opera bajo el supuesto de que es consciente de cada objeto de la vieja generaci&amp;oacute;n que apunta a uno de la generaci&amp;oacute;n joven. Cada vez que se actualiza un puntero rompiendo esa suposici&amp;oacute;n, se debe se&amp;ntilde;alar al recopilador con la funci&amp;oacute;n &lt;code&gt;jl_gc_wb&lt;/code&gt; (barrera de escritura) de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="7f907da64c464f65fc72aafc195dfebc2e4f4da6" translate="yes" xml:space="preserve">
          <source>The general syntax for assigning values in an n-dimensional array &lt;code&gt;A&lt;/code&gt; is:</source>
          <target state="translated">La sintaxis general para asignar valores en una matriz &lt;code&gt;A&lt;/code&gt; n-dimensional es:</target>
        </trans-unit>
        <trans-unit id="7f7fec22031b950929a2be2bf28c88a4e32319b3" translate="yes" xml:space="preserve">
          <source>The general syntax for indexing into an n-dimensional array &lt;code&gt;A&lt;/code&gt; is:</source>
          <target state="translated">La sintaxis general para indexar en una matriz &lt;code&gt;A&lt;/code&gt; n-dimensional es:</target>
        </trans-unit>
        <trans-unit id="03b4ccfaa881cd16fd244ada75dc950f11a8dd7c" translate="yes" xml:space="preserve">
          <source>The general syntaxes for declaring a primitive type are:</source>
          <target state="translated">Las sintaxis generales para declarar un tipo primitivo son:</target>
        </trans-unit>
        <trans-unit id="f539d98e5f467e838a2ad828b788e7266b1e5a86" translate="yes" xml:space="preserve">
          <source>The generalized SVD is used in applications such as when one wants to compare how much belongs to &lt;code&gt;A&lt;/code&gt; vs. how much belongs to &lt;code&gt;B&lt;/code&gt;, as in human vs yeast genome, or signal vs noise, or between clusters vs within clusters. (See Edelman and Wang for discussion: https://arxiv.org/abs/1901.00485)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8b49d87c21864e9239600316a0864509f86bdd" translate="yes" xml:space="preserve">
          <source>The generalized eigenvalues are returned in &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;beta&lt;/code&gt;. The left Schur vectors are returned in &lt;code&gt;vsl&lt;/code&gt; and the right Schur vectors are returned in &lt;code&gt;vsr&lt;/code&gt;.</source>
          <target state="translated">Los valores propios generalizados se devuelven en &lt;code&gt;alpha&lt;/code&gt; y &lt;code&gt;beta&lt;/code&gt; . Los vectores de Schur izquierdos se devuelven en &lt;code&gt;vsl&lt;/code&gt; y los vectores de Schur derechos se devuelven en &lt;code&gt;vsr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b85eadd92e8e39874d6e912a6cbd8941d0875a4" translate="yes" xml:space="preserve">
          <source>The global constant &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt; is bound to the complex number &lt;em&gt;i&lt;/em&gt;, representing the principal square root of -1. (Using mathematicians' &lt;code&gt;i&lt;/code&gt; or engineers' &lt;code&gt;j&lt;/code&gt; for this global constant were rejected since they are such popular index variable names.) Since Julia allows numeric literals to be &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients&quot;&gt;juxtaposed with identifiers as coefficients&lt;/a&gt;, this binding suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0ec4e7835e3ddd782c0a7070e015136b4b04a9" translate="yes" xml:space="preserve">
          <source>The global constant &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt; is bound to the complex number &lt;em&gt;i&lt;/em&gt;, representing the principal square root of -1. (Using mathematicians' &lt;code&gt;i&lt;/code&gt; or engineers' &lt;code&gt;j&lt;/code&gt; for this global constant were rejected since they are such popular index variable names.) Since Julia allows numeric literals to be &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;juxtaposed with identifiers as coefficients&lt;/a&gt;, this binding suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:</source>
          <target state="translated">La constante global &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt; &lt;code&gt;im&lt;/code&gt; &lt;/a&gt; est&amp;aacute; ligada al n&amp;uacute;mero complejo &lt;em&gt;i&lt;/em&gt; , que representa la ra&amp;iacute;z cuadrada principal de -1. (El uso de los matem&amp;aacute;ticos ' &lt;code&gt;i&lt;/code&gt; o los ingenieros' &lt;code&gt;j&lt;/code&gt; para esta constante global fue rechazado ya que son nombres de variables de &amp;iacute;ndice tan populares.) Dado que Julia permite que los literales num&amp;eacute;ricos se &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;yuxtapongan con identificadores como coeficientes&lt;/a&gt; , esta vinculaci&amp;oacute;n es suficiente para proporcionar una sintaxis conveniente para n&amp;uacute;meros complejos, similar a la notaci&amp;oacute;n matem&amp;aacute;tica tradicional:</target>
        </trans-unit>
        <trans-unit id="ef1d21913b7da2cd50221a9ea53be6e2ac79e4fa" translate="yes" xml:space="preserve">
          <source>The global logger may be set with &lt;a href=&quot;#Base.CoreLogging.global_logger&quot;&gt;&lt;code&gt;global_logger&lt;/code&gt;&lt;/a&gt;, and task-local loggers controlled using &lt;a href=&quot;#Base.CoreLogging.with_logger&quot;&gt;&lt;code&gt;with_logger&lt;/code&gt;&lt;/a&gt;. Newly spawned tasks inherit the logger of the parent task.</source>
          <target state="translated">El registrador global se puede configurar con &lt;a href=&quot;#Base.CoreLogging.global_logger&quot;&gt; &lt;code&gt;global_logger&lt;/code&gt; &lt;/a&gt; y los registradores locales de tareas controlados mediante &lt;a href=&quot;#Base.CoreLogging.with_logger&quot;&gt; &lt;code&gt;with_logger&lt;/code&gt; &lt;/a&gt; . Las tareas reci&amp;eacute;n generadas heredan el registrador de la tarea principal.</target>
        </trans-unit>
        <trans-unit id="fec591827136cb7a3fdc941604debe52d6ebea89" translate="yes" xml:space="preserve">
          <source>The global logger may be set with &lt;a href=&quot;#Logging.global_logger&quot;&gt;&lt;code&gt;global_logger&lt;/code&gt;&lt;/a&gt;, and task-local loggers controlled using &lt;a href=&quot;#Logging.with_logger&quot;&gt;&lt;code&gt;with_logger&lt;/code&gt;&lt;/a&gt;. Newly spawned tasks inherit the logger of the parent task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f673e90f9a09b859b5b51800816fab3de4b761" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;Base.DATAROOTDIR&lt;/code&gt; determines a relative path from &lt;code&gt;Sys.BINDIR&lt;/code&gt; to the data directory associated with Julia. Then the path</source>
          <target state="translated">La variable global &lt;code&gt;Base.DATAROOTDIR&lt;/code&gt; determina una ruta relativa desde &lt;code&gt;Sys.BINDIR&lt;/code&gt; al directorio de datos asociado con Julia. Entonces el camino</target>
        </trans-unit>
        <trans-unit id="e3bc80be4d521baacc06dd9873b328760a93de88" translate="yes" xml:space="preserve">
          <source>The golden ratio.</source>
          <target state="translated">La proporción dorada.</target>
        </trans-unit>
        <trans-unit id="354c17f25309f78f252b602097180cb50161163d" translate="yes" xml:space="preserve">
          <source>The group id of the file owner</source>
          <target state="translated">La identificación de grupo del propietario del archivo</target>
        </trans-unit>
        <trans-unit id="9e739954ff8de8447d1ab16a3adde7a80c985194" translate="yes" xml:space="preserve">
          <source>The hexadecimal integer literal expression &lt;code&gt;0xff&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;0&lt;/code&gt; multiplied by the variable &lt;code&gt;xff&lt;/code&gt;.</source>
          <target state="translated">La expresi&amp;oacute;n literal de entero hexadecimal &lt;code&gt;0xff&lt;/code&gt; podr&amp;iacute;a interpretarse como el literal num&amp;eacute;rico &lt;code&gt;0&lt;/code&gt; multiplicado por la variable &lt;code&gt;xff&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49109aa658d7c92b2a2e148756ac4fc9b1efb6c1" translate="yes" xml:space="preserve">
          <source>The highest finite value representable by the given floating-point DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">El valor finito m&amp;aacute;s alto representable por el DataType &lt;code&gt;T&lt;/code&gt; de punto flotante dado .</target>
        </trans-unit>
        <trans-unit id="1c54bd6057f9e745e71a4f119d94151d139d45e8" translate="yes" xml:space="preserve">
          <source>The highest value representable by the given (real) numeric &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">El valor m&amp;aacute;s alto representable por el &lt;code&gt;DataType&lt;/code&gt; num&amp;eacute;rico (real) dado .</target>
        </trans-unit>
        <trans-unit id="3d03859ad784bc750f8658c68023988ea70e276c" translate="yes" xml:space="preserve">
          <source>The host machine must have the requisite SIMD registers. For example, the code above will not work on hosts without AVX support.</source>
          <target state="translated">La máquina anfitriona debe tener los registros SIMD necesarios.Por ejemplo,el código anterior no funcionará en los hosts sin soporte AVX.</target>
        </trans-unit>
        <trans-unit id="69486992100b48c68c6ad0bb1508ce13148c9067" translate="yes" xml:space="preserve">
          <source>The hour of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La hora de un &lt;code&gt;Time&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ae14cb6dca4ab146e83e6f66251f24254e3bb17" translate="yes" xml:space="preserve">
          <source>The hour of day of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La hora del d&amp;iacute;a de un &lt;code&gt;DateTime&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b1bfeaaafc9c1b963fac8395380b6b23cf36c72" translate="yes" xml:space="preserve">
          <source>The hour part of a DateTime as a &lt;code&gt;Hour&lt;/code&gt;.</source>
          <target state="translated">La parte de la hora de un DateTime como una &lt;code&gt;Hour&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3215c43ad10d3da4db391c4e4892aec7413196da" translate="yes" xml:space="preserve">
          <source>The identity function. Returns its argument.</source>
          <target state="translated">La función de identidad.Devuelve su argumento.</target>
        </trans-unit>
        <trans-unit id="c738dd3a82cae47bce1402d7e9ed9b1a08ec88db" translate="yes" xml:space="preserve">
          <source>The imaginary unit &lt;code&gt;sqrt(-1)&lt;/code&gt; is represented in Julia as &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;i&lt;/code&gt; or &lt;code&gt;j&lt;/code&gt; as in MATLAB.</source>
          <target state="translated">La unidad imaginaria &lt;code&gt;sqrt(-1)&lt;/code&gt; se representa en Julia como &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt; &lt;code&gt;im&lt;/code&gt; &lt;/a&gt; , no &lt;code&gt;i&lt;/code&gt; o &lt;code&gt;j&lt;/code&gt; como en MATLAB.</target>
        </trans-unit>
        <trans-unit id="30bb48cc6e4e4350066fc756423b5585bb034986" translate="yes" xml:space="preserve">
          <source>The imaginary unit &lt;code&gt;sqrt(-1)&lt;/code&gt; is represented in Julia as &lt;code&gt;im&lt;/code&gt;, not &lt;code&gt;j&lt;/code&gt; as in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7823efd88570f05c6cdcdeba7b9c6d877d28d4c3" translate="yes" xml:space="preserve">
          <source>The imaginary unit.</source>
          <target state="translated">La unidad imaginaria.</target>
        </trans-unit>
        <trans-unit id="d2f3b37cc4a76dd392140d18be234dc4fa787173" translate="yes" xml:space="preserve">
          <source>The implementation of this behavior is a &quot;world age counter&quot;. This monotonically increasing value tracks each method definition operation. This allows describing &quot;the set of method definitions visible to a given runtime environment&quot; as a single number, or &quot;world age&quot;. It also allows comparing the methods available in two worlds just by comparing their ordinal value. In the example above, we see that the &quot;current world&quot; (in which the method &lt;code&gt;newfun&lt;/code&gt; exists), is one greater than the task-local &quot;runtime world&quot; that was fixed when the execution of &lt;code&gt;tryeval&lt;/code&gt; started.</source>
          <target state="translated">La implementaci&amp;oacute;n de este comportamiento es un &quot;contador de edad mundial&quot;. Este valor que aumenta mon&amp;oacute;tonamente rastrea cada operaci&amp;oacute;n de definici&amp;oacute;n de m&amp;eacute;todo. Esto permite describir &quot;el conjunto de definiciones de m&amp;eacute;todos visibles para un entorno de ejecuci&amp;oacute;n dado&quot; como un n&amp;uacute;mero &amp;uacute;nico, o &quot;era mundial&quot;. Tambi&amp;eacute;n permite comparar los m&amp;eacute;todos disponibles en dos mundos simplemente comparando su valor ordinal. En el ejemplo anterior, vemos que el &quot;mundo actual&quot; (en el que existe el m&amp;eacute;todo &lt;code&gt;newfun&lt;/code&gt; ), es mayor que el &quot;mundo en tiempo de ejecuci&amp;oacute;n&quot; de la tarea local que se corrigi&amp;oacute; cuando comenz&amp;oacute; la ejecuci&amp;oacute;n de &lt;code&gt;tryeval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b253e7f28529381ae2517e2dd4df05c0e78e871f" translate="yes" xml:space="preserve">
          <source>The incremental precompiled module file are created and used automatically when using &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;using&lt;/code&gt; to load a module. This will cause it to be automatically compiled the first time it is imported. Alternatively, you can manually call &lt;a href=&quot;../../base/base/index#Base.compilecache&quot;&gt;&lt;code&gt;Base.compilecache(modulename)&lt;/code&gt;&lt;/a&gt;. The resulting cache files will be stored in &lt;code&gt;DEPOT_PATH[1]/compiled/&lt;/code&gt;. Subsequently, the module is automatically recompiled upon &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it includes, or explicit dependencies declared by &lt;a href=&quot;../../base/base/index#Base.include_dependency&quot;&gt;&lt;code&gt;include_dependency(path)&lt;/code&gt;&lt;/a&gt; in the module file(s).</source>
          <target state="translated">El archivo de m&amp;oacute;dulo incremental precompilado se crea y usa autom&amp;aacute;ticamente cuando se usa la &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n o se &lt;code&gt;using&lt;/code&gt; para cargar un m&amp;oacute;dulo. Esto har&amp;aacute; que se compile autom&amp;aacute;ticamente la primera vez que se importe. Alternativamente, puede llamar manualmente a &lt;a href=&quot;../../base/base/index#Base.compilecache&quot;&gt; &lt;code&gt;Base.compilecache(modulename)&lt;/code&gt; &lt;/a&gt; . Los archivos de cach&amp;eacute; resultantes se almacenar&amp;aacute;n en &lt;code&gt;DEPOT_PATH[1]/compiled/&lt;/code&gt; . Posteriormente, el m&amp;oacute;dulo se vuelve a compilar autom&amp;aacute;ticamente al &lt;code&gt;using&lt;/code&gt; o &lt;code&gt;import&lt;/code&gt; arlo cada vez que cambia alguna de sus dependencias; las dependencias son los m&amp;oacute;dulos que importa, la compilaci&amp;oacute;n de Julia, los archivos que incluye o las dependencias expl&amp;iacute;citas declaradas por &lt;a href=&quot;../../base/base/index#Base.include_dependency&quot;&gt; &lt;code&gt;include_dependency(path)&lt;/code&gt; &lt;/a&gt; en los archivos del m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="13dd8189d32c7c1290b037751919f6e30e7f64f8" translate="yes" xml:space="preserve">
          <source>The individual components of the decomposition &lt;code&gt;F&lt;/code&gt; can be retrieved via property accessors:</source>
          <target state="translated">Los componentes individuales de la descomposici&amp;oacute;n &lt;code&gt;F&lt;/code&gt; se pueden recuperar mediante los descriptores de acceso de propiedad:</target>
        </trans-unit>
        <trans-unit id="41c086468dc0b6a3a361a760590aea5addc822ff" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F::LDLt&lt;/code&gt; can be accessed via &lt;code&gt;getproperty&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d9b54de6a322e63bc3f875f6d62e056cb73285" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F::LU&lt;/code&gt; can be accessed via &lt;a href=&quot;../../base/base/index#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8bb274f2ee9cfc9c33d3c699116094ae0bac43" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F&lt;/code&gt; can be accessed via &lt;a href=&quot;../../base/base/index#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0913135fd9f357f77350a326cce1c8ed6fa49d" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F&lt;/code&gt; can be accessed via &lt;code&gt;getproperty&lt;/code&gt;:</source>
          <target state="translated">Se puede acceder a los componentes individuales de la factorizaci&amp;oacute;n &lt;code&gt;F&lt;/code&gt; a trav&amp;eacute;s de &lt;code&gt;getproperty&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6e01ca13a398bafdf18f4d4f60195a783a431cf" translate="yes" xml:space="preserve">
          <source>The infix form is exactly equivalent to the function application form &amp;ndash; in fact the former is parsed to produce the function call internally. This also means that you can assign and pass around operators such as &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;*&lt;/code&gt; just like you would with other function values:</source>
          <target state="translated">El formulario infijo es exactamente equivalente al formulario de aplicaci&amp;oacute;n de la funci&amp;oacute;n; de hecho, el primero se analiza para producir la llamada a la funci&amp;oacute;n internamente. Esto tambi&amp;eacute;n significa que puede asignar y pasar operadores como &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;*&lt;/code&gt; tal como lo har&amp;iacute;a con otros valores de funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="ab93d805a4e1efd3cacbdba9a517e0dc2379a9e4" translate="yes" xml:space="preserve">
          <source>The infix operation &lt;code&gt;a ⊻ b&lt;/code&gt; is a synonym for &lt;code&gt;xor(a,b)&lt;/code&gt;, and &lt;code&gt;⊻&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\xor&lt;/code&gt; or &lt;code&gt;\veebar&lt;/code&gt; in the Julia REPL.</source>
          <target state="translated">La operaci&amp;oacute;n infija &lt;code&gt;a ⊻ b&lt;/code&gt; es un sin&amp;oacute;nimo de &lt;code&gt;xor(a,b)&lt;/code&gt; , y &lt;code&gt;⊻&lt;/code&gt; se puede escribir completando tabuladores &lt;code&gt;\xor&lt;/code&gt; o &lt;code&gt;\veebar&lt;/code&gt; en el REPL de Julia.</target>
        </trans-unit>
        <trans-unit id="e1b31695e555eb78c96b1ce43ed5d4b769be43f4" translate="yes" xml:space="preserve">
          <source>The initial Julia process, also called the &lt;code&gt;master&lt;/code&gt;, is special and has an &lt;code&gt;id&lt;/code&gt; of 1.</source>
          <target state="translated">El proceso inicial de Julia, tambi&amp;eacute;n llamado &lt;code&gt;master&lt;/code&gt; , es especial y tiene una &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n de 1.</target>
        </trans-unit>
        <trans-unit id="46aabc78dd4e507670425bdb3bf204611d3ffb13" translate="yes" xml:space="preserve">
          <source>The inode number of the file</source>
          <target state="translated">El número inode del archivo</target>
        </trans-unit>
        <trans-unit id="204c42952f2670f515bfe08f06a0ba3dd55c909a" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;n&lt;/code&gt; is passed by value, and so the function's input signature is simply declared as &lt;code&gt;(Csize_t,)&lt;/code&gt; without any &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;Ptr&lt;/code&gt; necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt;, since Fortran variables are passed by pointers.) Furthermore, &lt;code&gt;n&lt;/code&gt; can be any type that is convertible to a &lt;code&gt;Csize_t&lt;/code&gt; integer; the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; implicitly calls &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La entrada &lt;code&gt;n&lt;/code&gt; se pasa por valor, por lo que la firma de entrada de la funci&amp;oacute;n simplemente se declara como &lt;code&gt;(Csize_t,)&lt;/code&gt; sin necesidad de &lt;code&gt;Ref&lt;/code&gt; o &lt;code&gt;Ptr&lt;/code&gt; . (Si el contenedor estaba llamando a una funci&amp;oacute;n de Fortran, la firma de entrada de la funci&amp;oacute;n correspondiente deber&amp;iacute;a ser &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt; , ya que las variables de Fortran se pasan mediante punteros). Adem&amp;aacute;s, &lt;code&gt;n&lt;/code&gt; puede ser cualquier tipo que sea convertible a un entero &lt;code&gt;Csize_t&lt;/code&gt; ; el &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; llama impl&amp;iacute;citamente a &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="533ae8282fbee75fbb95332329b16aa4f88660eb" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;n&lt;/code&gt; is passed by value, and so the function's input signature is simply declared as &lt;code&gt;(Csize_t,)&lt;/code&gt; without any &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;Ptr&lt;/code&gt; necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature would instead be &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt;, since Fortran variables are passed by pointers.) Furthermore, &lt;code&gt;n&lt;/code&gt; can be any type that is convertible to a &lt;code&gt;Csize_t&lt;/code&gt; integer; the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; implicitly calls &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b235e73123abb02c8610a64480c17659bc5e36" translate="yes" xml:space="preserve">
          <source>The input matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; will not contain their eigenvalues after &lt;code&gt;eigvals!&lt;/code&gt; is called. They are used as workspaces.</source>
          <target state="translated">Las matrices de entrada &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; no contendr&amp;aacute;n sus valores propios despu&amp;eacute;s de los valores &lt;code&gt;eigvals!&lt;/code&gt; se llama. Se utilizan como espacios de trabajo.</target>
        </trans-unit>
        <trans-unit id="a25e9d14fa9f0f89dab37c152c425a3aebebbd0f" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;A&lt;/code&gt; will not contain its eigenvalues after &lt;code&gt;eigvals!&lt;/code&gt; is called on it - &lt;code&gt;A&lt;/code&gt; is used as a workspace.</source>
          <target state="translated">&amp;iexcl;La matriz de entrada &lt;code&gt;A&lt;/code&gt; no contendr&amp;aacute; sus valores propios despu&amp;eacute;s de los valores &lt;code&gt;eigvals!&lt;/code&gt; se llama en &amp;eacute;l: &lt;code&gt;A&lt;/code&gt; se utiliza como espacio de trabajo.</target>
        </trans-unit>
        <trans-unit id="1417019c8a8204f046e43b52db1e1b8dfe779fc9" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; is not transposed or conjugated.</source>
          <target state="translated">La matriz de entrada &lt;code&gt;X&lt;/code&gt; no se transpone ni se conjuga.</target>
        </trans-unit>
        <trans-unit id="696317e85c44155ed1679065a21cab9ea0d94c6f" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; will be conjugated and transposed.</source>
          <target state="translated">La matriz de entrada &lt;code&gt;X&lt;/code&gt; se conjugar&amp;aacute; y transpondr&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="edc49f341fce73dbc1b810339993fe819e7483f6" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; will be transposed.</source>
          <target state="translated">La matriz de entrada &lt;code&gt;X&lt;/code&gt; se transpondr&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="ce8cf57c3583cc5f6f01c812980b6d9e8e041658" translate="yes" xml:space="preserve">
          <source>The intuition behind this behavior is that &lt;code&gt;x&lt;/code&gt; is evaluated once for each &lt;code&gt;$&lt;/code&gt;: one &lt;code&gt;$&lt;/code&gt; works similarly to &lt;code&gt;eval(:x)&lt;/code&gt;, giving &lt;code&gt;x&lt;/code&gt;'s value, while two &lt;code&gt;$&lt;/code&gt;s do the equivalent of &lt;code&gt;eval(eval(:x))&lt;/code&gt;.</source>
          <target state="translated">La intuici&amp;oacute;n detr&amp;aacute;s de este comportamiento es que &lt;code&gt;x&lt;/code&gt; se eval&amp;uacute;a una vez para cada &lt;code&gt;$&lt;/code&gt; : un &lt;code&gt;$&lt;/code&gt; funciona de manera similar a &lt;code&gt;eval(:x)&lt;/code&gt; , dando el valor de &lt;code&gt;x&lt;/code&gt; , mientras que dos &lt;code&gt;$&lt;/code&gt; s hacen el equivalente de &lt;code&gt;eval(eval(:x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9951fb03011eb6ccac99ddca5a1c8a2596a1921f" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt;&lt;code&gt;sparsevec&lt;/code&gt;&lt;/a&gt; functions is &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, which retrieves the inputs used to create the sparse array. &lt;code&gt;findall(!iszero, x)&lt;/code&gt; returns the cartesian indices of non-zero entries in &lt;code&gt;x&lt;/code&gt; (including stored entries equal to zero).</source>
          <target state="translated">La inversa de las funciones &lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt; &lt;code&gt;sparsevec&lt;/code&gt; &lt;/a&gt; es &lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; &lt;/a&gt; , que recupera las entradas utilizadas para crear la matriz dispersa. &lt;code&gt;findall(!iszero, x)&lt;/code&gt; devuelve los &amp;iacute;ndices cartesianos de entradas distintas de cero en &lt;code&gt;x&lt;/code&gt; (incluidas las entradas almacenadas iguales a cero).</target>
        </trans-unit>
        <trans-unit id="08e030af941b44ba6a6057a4b8409ccf9a09fa65" translate="yes" xml:space="preserve">
          <source>The item or field is not defined for the given object.</source>
          <target state="translated">El elemento o campo no está definido para el objeto dado.</target>
        </trans-unit>
        <trans-unit id="b34eda5561d7a2242bd83cb6f099eb397c0b5c82" translate="yes" xml:space="preserve">
          <source>The iteration space is split among the threads, after which each thread writes its thread ID to its assigned locations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5978b1760bac737678645da104214e401ee6745d" translate="yes" xml:space="preserve">
          <source>The iteration space is split amongst the threads, after which each thread writes its thread ID to its assigned locations:</source>
          <target state="translated">El espacio de iteración se divide entre los hilos,después de lo cual cada hilo escribe su ID de hilo en sus lugares asignados:</target>
        </trans-unit>
        <trans-unit id="aa67cafc379af040f95c65d3767fc728770e3507" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;debuginfo&lt;/code&gt; controls the amount of code metadata present in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27814682e2f12bb813126e15aaa61e9b9ecadb0b" translate="yes" xml:space="preserve">
          <source>The keyword argument &lt;code&gt;topology&lt;/code&gt; passed to &lt;code&gt;addprocs&lt;/code&gt; is used to specify how the workers must be connected to each other:</source>
          <target state="translated">La &lt;code&gt;topology&lt;/code&gt; argumentos de palabra clave pasada a &lt;code&gt;addprocs&lt;/code&gt; se usa para especificar c&amp;oacute;mo los trabajadores deben conectarse entre s&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="071e1626e259689d138d5d354cd990a797f9cc76" translate="yes" xml:space="preserve">
          <source>The keyword argument is:</source>
          <target state="translated">El argumento de la palabra clave es:</target>
        </trans-unit>
        <trans-unit id="a0bf59d5d88128d67e3917cc9fc88ca7d247fb14" translate="yes" xml:space="preserve">
          <source>The keyword arguments &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;beta&lt;/code&gt; correspond to the same parameters in Hyndman and Fan, setting them to different values allows to calculate quantiles with any of the methods 4-9 defined in this paper:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53040371261a8a003dc97b8ee4567faef82b0f5" translate="yes" xml:space="preserve">
          <source>The keyword arguments are:</source>
          <target state="translated">Los argumentos de la palabra clave son:</target>
        </trans-unit>
        <trans-unit id="aff2628de569031caf118a1cfbb476e502ae8a02" translate="yes" xml:space="preserve">
          <source>The keyword arguments can be any combination of:</source>
          <target state="translated">Los argumentos de las palabras clave pueden ser cualquier combinación de:</target>
        </trans-unit>
        <trans-unit id="88a5016b4ada3cfa1d337884f9c60b1547e662dc" translate="yes" xml:space="preserve">
          <source>The keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Los argumentos de la palabra clave determinan cu&amp;aacute;l estado de lectura y / o escritura debe monitorearse; al menos uno de ellos debe establecerse en &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0461b4257dea448624f31f52377f5d07347ab62c" translate="yes" xml:space="preserve">
          <source>The keyword arguments supported here are the same as those in the 2-argument &lt;code&gt;isapprox&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c36d11485ade8e4d84f52006bfe2371bd7a3a31" translate="yes" xml:space="preserve">
          <source>The keyword debuginfo controls the amount of code metadata present in the output.</source>
          <target state="translated">La palabra clave debuginfo controla la cantidad de metadatos del código presentes en la salida.</target>
        </trans-unit>
        <trans-unit id="1c08fd56fd5a7ec1b4c4d5ce6e7cd9fc470d3bc9" translate="yes" xml:space="preserve">
          <source>The largest &lt;code&gt;a^n&lt;/code&gt; not greater than &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a non-negative integer. &lt;code&gt;a&lt;/code&gt; must be greater than 1, and &lt;code&gt;x&lt;/code&gt; must not be less than 1.</source>
          <target state="translated">El mayor &lt;code&gt;a^n&lt;/code&gt; no mayor que &lt;code&gt;x&lt;/code&gt; , donde &lt;code&gt;n&lt;/code&gt; es un n&amp;uacute;mero entero no negativo. &lt;code&gt;a&lt;/code&gt; debe ser mayor que 1 y &lt;code&gt;x&lt;/code&gt; no debe ser menor que 1.</target>
        </trans-unit>
        <trans-unit id="1950191e788c00e6e81f70c06794860257be97cd" translate="yes" xml:space="preserve">
          <source>The largest consecutive integer representable in the given floating-point type &lt;code&gt;T&lt;/code&gt; that also does not exceed the maximum integer representable by the integer type &lt;code&gt;S&lt;/code&gt;. Equivalently, it is the minimum of &lt;code&gt;maxintfloat(T)&lt;/code&gt; and &lt;a href=&quot;#Base.typemax&quot;&gt;&lt;code&gt;typemax(S)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El m&amp;aacute;s grande representable n&amp;uacute;mero entero consecutivo en el tipo de punto flotante dado &lt;code&gt;T&lt;/code&gt; que tambi&amp;eacute;n no exceda el m&amp;aacute;ximo n&amp;uacute;mero entero representable por el tipo de n&amp;uacute;mero entero &lt;code&gt;S&lt;/code&gt; . De manera equivalente, es el m&amp;iacute;nimo de &lt;code&gt;maxintfloat(T)&lt;/code&gt; y &lt;a href=&quot;#Base.typemax&quot;&gt; &lt;code&gt;typemax(S)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecdd0c5829d6c2ebd17e2173ff4d8725a651c73f" translate="yes" xml:space="preserve">
          <source>The largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type &lt;code&gt;T&lt;/code&gt; (which defaults to &lt;code&gt;Float64&lt;/code&gt;).</source>
          <target state="translated">El n&amp;uacute;mero de coma flotante con valor entero consecutivo m&amp;aacute;s grande que se representa exactamente en el tipo de coma flotante &lt;code&gt;T&lt;/code&gt; dado (que por defecto es &lt;code&gt;Float64&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="45d85758b569bacb3008f9cd5ec57f8b5348a342" translate="yes" xml:space="preserve">
          <source>The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call &lt;code&gt;free&lt;/code&gt; on the data pointer when the array is no longer referenced.</source>
          <target state="translated">El &amp;uacute;ltimo argumento es un booleano que indica si Julia deber&amp;iacute;a tomar posesi&amp;oacute;n de los datos. Si este argumento es distinto de cero, el GC llamar&amp;aacute; a &lt;code&gt;free&lt;/code&gt; en el puntero de datos cuando ya no se haga referencia a la matriz.</target>
        </trans-unit>
        <trans-unit id="1c54e90c8086ffbb492a0993d80791c5e4dea811" translate="yes" xml:space="preserve">
          <source>The last argument is the expression during which the object(s) will be preserved. The previous arguments are the objects to preserve.</source>
          <target state="translated">El último argumento es la expresión durante la cual se preservará el objeto o los objetos.Los argumentos anteriores son los objetos a preservar.</target>
        </trans-unit>
        <trans-unit id="ea0fbbe9568bcd71edf3e46185498b21db11849e" translate="yes" xml:space="preserve">
          <source>The last definition of &lt;code&gt;addone&lt;/code&gt; handles any type supporting &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; (which returns 1 in the same type as &lt;code&gt;x&lt;/code&gt;, which avoids unwanted type promotion) and the &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; function with those arguments. The key thing to realize is that there is &lt;em&gt;no performance penalty&lt;/em&gt; to defining &lt;em&gt;only&lt;/em&gt; the general &lt;code&gt;addone(x) = x + oneunit(x)&lt;/code&gt;, because Julia will automatically compile specialized versions as needed. For example, the first time you call &lt;code&gt;addone(12)&lt;/code&gt;, Julia will automatically compile a specialized &lt;code&gt;addone&lt;/code&gt; function for &lt;code&gt;x::Int&lt;/code&gt; arguments, with the call to &lt;code&gt;oneunit&lt;/code&gt; replaced by its inlined value &lt;code&gt;1&lt;/code&gt;. Therefore, the first three definitions of &lt;code&gt;addone&lt;/code&gt; above are completely redundant with the fourth definition.</source>
          <target state="translated">La &amp;uacute;ltima definici&amp;oacute;n de &lt;code&gt;addone&lt;/code&gt; maneja cualquier tipo que &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; (que devuelve 1 en el mismo tipo que &lt;code&gt;x&lt;/code&gt; , lo que evita la promoci&amp;oacute;n de tipos no deseados) y la funci&amp;oacute;n &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; con esos argumentos. La clave a tener en cuenta es que no hay &lt;em&gt;una penalizaci&amp;oacute;n de rendimiento&lt;/em&gt; para definir &lt;em&gt;solo&lt;/em&gt; el &lt;code&gt;addone(x) = x + oneunit(x)&lt;/code&gt; general (x) = x + una unidad (x) , porque Julia compilar&amp;aacute; autom&amp;aacute;ticamente versiones especializadas seg&amp;uacute;n sea necesario. Por ejemplo, la primera vez que llame a &lt;code&gt;addone(12)&lt;/code&gt; , Julia compilar&amp;aacute; autom&amp;aacute;ticamente una funci&amp;oacute;n &lt;code&gt;addone&lt;/code&gt; especializada para argumentos &lt;code&gt;x::Int&lt;/code&gt; , con la llamada a &lt;code&gt;oneunit&lt;/code&gt; reemplazado por su valor en l&amp;iacute;nea &lt;code&gt;1&lt;/code&gt; . Por lo tanto, las tres primeras definiciones de &lt;code&gt;addone&lt;/code&gt; anteriores son completamente redundantes con la cuarta definici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ce1654d58ffca436a4c577b1711a64e839d84f92" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; can also look for a character literal.</source>
          <target state="translated">El &amp;uacute;ltimo ejemplo muestra que &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n puede buscar un car&amp;aacute;cter literal.</target>
        </trans-unit>
        <trans-unit id="c71585d1662e0c9426691e517fa7355c40e4926e" translate="yes" xml:space="preserve">
          <source>The last index, used in &lt;code&gt;X[end]&lt;/code&gt;</source>
          <target state="translated">El &amp;uacute;ltimo &amp;iacute;ndice, usado en &lt;code&gt;X[end]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e99097d64e5f2e1b2a717dd030549921903ffab" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type &lt;a href=&quot;#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; can be the special type &lt;code&gt;Vararg&lt;/code&gt;, which denotes any number of trailing elements. The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg&lt;/code&gt; tuple types are used to represent the arguments accepted by varargs methods (see the section on &lt;a href=&quot;../../manual/functions/index#Varargs-Functions&quot;&gt;Varargs Functions&lt;/a&gt; in the manual.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a1c4b01d2974399d332fe3cfffd4d1b569afd3" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type &lt;a href=&quot;#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; can be the special type &lt;code&gt;Vararg&lt;/code&gt;, which denotes any number of trailing elements. The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg&lt;/code&gt; tuple types are used to represent the arguments accepted by varargs methods (see the section on &lt;a href=&quot;../../manual/functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt; in the manual.)</source>
          <target state="translated">El &amp;uacute;ltimo par&amp;aacute;metro de un tipo de tupla &lt;a href=&quot;#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; puede ser el tipo especial &lt;code&gt;Vararg&lt;/code&gt; , que denota cualquier n&amp;uacute;mero de elementos finales. El tipo &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponde a exactamente &lt;code&gt;N&lt;/code&gt; elementos de tipo &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;Vararg{T}&lt;/code&gt; corresponde a cero o m&amp;aacute;s elementos de tipo &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;Vararg&lt;/code&gt; tipos de tupla de Vararg se utilizan para representar los argumentos aceptados por los m&amp;eacute;todos de varargs (consulte la secci&amp;oacute;n sobre &lt;a href=&quot;../../manual/functions/index#Varargs-Functions-1&quot;&gt;Funciones de Varargs&lt;/a&gt; en el manual).</target>
        </trans-unit>
        <trans-unit id="acef1648e92638f5fc5abaed16365a6d53367ba2" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type can be the special type &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;, which denotes any number of trailing elements:</source>
          <target state="translated">El &amp;uacute;ltimo par&amp;aacute;metro de un tipo de tupla puede ser el tipo especial &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt; , que denota cualquier n&amp;uacute;mero de elementos finales:</target>
        </trans-unit>
        <trans-unit id="1d6eefa466648c5ff477244c5653b68c2b829837" translate="yes" xml:space="preserve">
          <source>The last point is potentially surprising and thus worth noting:</source>
          <target state="translated">El último punto es potencialmente sorprendente y,por tanto,digno de mención:</target>
        </trans-unit>
        <trans-unit id="e7ffcc1d6667c70bd8fd7c442814f44c7c9628ab" translate="yes" xml:space="preserve">
          <source>The last rule applies for immutable objects even if the variable binding would change, e.g.:</source>
          <target state="translated">La última regla se aplica a los objetos inmutables,incluso si la unión variable cambiara,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ac541895cad74a09061e0e8e7752d4412b01c909" translate="yes" xml:space="preserve">
          <source>The launching, management and networking of Julia processes into a logical cluster is done via cluster managers. A &lt;code&gt;ClusterManager&lt;/code&gt; is responsible for</source>
          <target state="translated">El lanzamiento, la gesti&amp;oacute;n y la conexi&amp;oacute;n en red de los procesos de Julia en un cl&amp;uacute;ster l&amp;oacute;gico se realiza a trav&amp;eacute;s de administradores de cl&amp;uacute;steres. Un &lt;code&gt;ClusterManager&lt;/code&gt; es responsable de</target>
        </trans-unit>
        <trans-unit id="88412ce5eb2e0660d566bcac5d3d266756d5e5a6" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;s&lt;/code&gt; must be even, and the returned array has half of the length of &lt;code&gt;s&lt;/code&gt;. See also &lt;a href=&quot;#Base.hex2bytes!&quot;&gt;&lt;code&gt;hex2bytes!&lt;/code&gt;&lt;/a&gt; for an in-place version, and &lt;a href=&quot;#Base.bytes2hex&quot;&gt;&lt;code&gt;bytes2hex&lt;/code&gt;&lt;/a&gt; for the inverse.</source>
          <target state="translated">La longitud de &lt;code&gt;s&lt;/code&gt; debe ser par y la matriz devuelta tiene la mitad de la longitud de &lt;code&gt;s&lt;/code&gt; . Consulte tambi&amp;eacute;n &lt;a href=&quot;#Base.hex2bytes!&quot;&gt; &lt;code&gt;hex2bytes!&lt;/code&gt; &lt;/a&gt;para una versi&amp;oacute;n local y &lt;a href=&quot;#Base.bytes2hex&quot;&gt; &lt;code&gt;bytes2hex&lt;/code&gt; &lt;/a&gt; para la inversa.</target>
        </trans-unit>
        <trans-unit id="82277dc04b6a3c445e6b9754a249fdcb23f3c7cf" translate="yes" xml:space="preserve">
          <source>The line number in the file containing the execution context.</source>
          <target state="translated">El número de línea en el archivo que contiene el contexto de ejecución.</target>
        </trans-unit>
        <trans-unit id="8e34d0276593663d51db2e1008617c96b00222ff" translate="yes" xml:space="preserve">
          <source>The location &lt;code&gt;i_1, i_2, i_3, ..., i_{n+1}&lt;/code&gt; contains the value at &lt;code&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;/code&gt;. All dimensions indexed with scalars are dropped. For example, if &lt;code&gt;J&lt;/code&gt; is an array of indices, then the result of &lt;code&gt;A[2, J, 3]&lt;/code&gt; is an array with size &lt;code&gt;size(J)&lt;/code&gt;. Its &lt;code&gt;j&lt;/code&gt;th element is populated by &lt;code&gt;A[2, J[j], 3]&lt;/code&gt;.</source>
          <target state="translated">La ubicaci&amp;oacute;n &lt;code&gt;i_1, i_2, i_3, ..., i_{n+1}&lt;/code&gt; contiene el valor en &lt;code&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;/code&gt; . Todas las dimensiones indexadas con escalares se eliminan. Por ejemplo, si &lt;code&gt;J&lt;/code&gt; es una matriz de &amp;iacute;ndices, entonces el resultado de &lt;code&gt;A[2, J, 3]&lt;/code&gt; es una matriz con tama&amp;ntilde;o de &lt;code&gt;size(J)&lt;/code&gt; . Su &lt;code&gt;j&lt;/code&gt; - &amp;eacute;simo elemento est&amp;aacute; poblado por &lt;code&gt;A[2, J[j], 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ba9cf6bb4f8397cc28a79b830f4f985b9ab3a34" translate="yes" xml:space="preserve">
          <source>The location information can be accessed by referencing &lt;code&gt;__source__.line&lt;/code&gt; and &lt;code&gt;__source__.file&lt;/code&gt;:</source>
          <target state="translated">Se puede acceder a la informaci&amp;oacute;n de ubicaci&amp;oacute;n haciendo referencia a &lt;code&gt;__source__.line&lt;/code&gt; y &lt;code&gt;__source__.file&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3cb51b112926a1dd81d50332e9952ca8853bb8d8" translate="yes" xml:space="preserve">
          <source>The location of both the &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; keywords within the scope block is irrelevant. The following is equivalent to the last example (although stylistically worse):</source>
          <target state="translated">La ubicaci&amp;oacute;n de las palabras clave &lt;code&gt;local&lt;/code&gt; es y &lt;code&gt;global&lt;/code&gt; es dentro del bloque de alcance es irrelevante. Lo siguiente es equivalente al &amp;uacute;ltimo ejemplo (aunque estil&amp;iacute;sticamente peor):</target>
        </trans-unit>
        <trans-unit id="98682ff20b7c08341d3c5e15b38c14b9a4d16f28" translate="yes" xml:space="preserve">
          <source>The log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.</source>
          <target state="translated">El nivel de registro proporciona una clave contra la cual se pueden filtrar los posibles registros de registro,antes de que se realice cualquier otro trabajo para construir la estructura de datos del registro en sí.</target>
        </trans-unit>
        <trans-unit id="fe0609505a9527026d24d710008d1bfe473fd7b3" translate="yes" xml:space="preserve">
          <source>The logical Julia program structure (Packages and Modules) is independent of the file strucutre (&lt;code&gt;include&lt;/code&gt; for additional files), whereas the Python code structure is defined by directories (Packages) and files (Modules).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318d32e896560b8d7266b2f324ddc4a3093ac0b9" translate="yes" xml:space="preserve">
          <source>The loop body must be straight-line code. Therefore, &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt; is currently needed for all array accesses. The compiler can sometimes turn short &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;?:&lt;/code&gt; expressions into straight-line code if it is safe to evaluate all operands unconditionally. Consider using the &lt;a href=&quot;#Core.ifelse&quot;&gt;&lt;code&gt;ifelse&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;?:&lt;/code&gt; in the loop if it is safe to do so.</source>
          <target state="translated">El cuerpo del bucle debe ser un c&amp;oacute;digo de l&amp;iacute;nea recta. Por lo tanto, &lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt; es actualmente necesario para todos los accesos a la matriz. El compilador a veces puede volverse corto &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; , y &lt;code&gt;?:&lt;/code&gt; expresiones en c&amp;oacute;digo de l&amp;iacute;nea recta si es seguro evaluar todos los operandos incondicionalmente. Considere usar la funci&amp;oacute;n &lt;a href=&quot;#Core.ifelse&quot;&gt; &lt;code&gt;ifelse&lt;/code&gt; en&lt;/a&gt; lugar de &lt;code&gt;?:&lt;/code&gt; En el ciclo si es seguro hacerlo.</target>
        </trans-unit>
        <trans-unit id="e1520d8e0dbae93326950f00e9cb69f3cae60938" translate="yes" xml:space="preserve">
          <source>The loop must be an innermost loop</source>
          <target state="translated">El bucle debe ser un bucle más interno</target>
        </trans-unit>
        <trans-unit id="1417d30bb5a87b95ed3077cbfd4cd113b702f8de" translate="yes" xml:space="preserve">
          <source>The lowest value representable by the given (real) numeric DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">El valor m&amp;aacute;s bajo representable por el DataType &lt;code&gt;T&lt;/code&gt; num&amp;eacute;rico (real) dado .</target>
        </trans-unit>
        <trans-unit id="73472042c68fe0e8852a29376bec0fce0bf44289" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; generates the C-compatible function pointer for a call to a Julia function. Arguments to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; are as follows:</source>
          <target state="translated">La macro &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt; genera el puntero de funci&amp;oacute;n compatible con C para una llamada a una funci&amp;oacute;n de Julia. Los argumentos de la funci&amp;oacute;n &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt; son los siguientes:</target>
        </trans-unit>
        <trans-unit id="240541bcb8e3f73fd00189d26b350e3696cca6f4" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; generates the C-compatible function pointer for a call to a Julia function. The arguments to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90d2d040a67a205cdeab40f74d8c8876f85fbd9" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; (or its function variant &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_warntype&quot;&gt;&lt;code&gt;code_warntype&lt;/code&gt;&lt;/a&gt;) can sometimes be helpful in diagnosing type-related problems. Here's an example:</source>
          <target state="translated">La macro &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; (o su variante de funci&amp;oacute;n &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_warntype&quot;&gt; &lt;code&gt;code_warntype&lt;/code&gt; &lt;/a&gt; ) a veces puede ser &amp;uacute;til para diagnosticar problemas relacionados con el tipo. He aqu&amp;iacute; un ejemplo:</target>
        </trans-unit>
        <trans-unit id="9e7d84ccb0a328a62c08d6f8b7389ef525b8bb84" translate="yes" xml:space="preserve">
          <source>The macro may be chained with &lt;code&gt;@test&lt;/code&gt; to also test the returned value:</source>
          <target state="translated">La macro se puede encadenar con &lt;code&gt;@test&lt;/code&gt; para probar tambi&amp;eacute;n el valor devuelto:</target>
        </trans-unit>
        <trans-unit id="ee8a907ab8fbfe293b4dae0afdde54a8eeab9dd2" translate="yes" xml:space="preserve">
          <source>The main purpose of this constructor is intuitive conversion from cartesian to linear indexing:</source>
          <target state="translated">El principal propósito de este constructor es la conversión intuitiva de la indexación cartesiana a la lineal:</target>
        </trans-unit>
        <trans-unit id="525b6c6d88eda51b84031a3e53a3435af961ebe7" translate="yes" xml:space="preserve">
          <source>The master process does not listen on any port. It only connects out to the workers.</source>
          <target state="translated">El proceso maestro no escucha en ningún puerto.Sólo se conecta con los trabajadores.</target>
        </trans-unit>
        <trans-unit id="2ed15f9d452fe7aa2e8f8976ab10c5922bcca0ff" translate="yes" xml:space="preserve">
          <source>The master process parses this information and sets up TCP/IP connections to each worker.</source>
          <target state="translated">El proceso maestro analiza esta información y establece conexiones TCP/IP para cada trabajador.</target>
        </trans-unit>
        <trans-unit id="c61856ffa89efc2e6c1d6b663bec6b092cbe224f" translate="yes" xml:space="preserve">
          <source>The meaning of prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via &lt;code&gt;mutable struct&lt;/code&gt;). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, &lt;code&gt;&amp;amp;&lt;/code&gt; may be used with any expression, such as &lt;code&gt;&amp;amp;0&lt;/code&gt; or &lt;code&gt;&amp;amp;f(x)&lt;/code&gt;.</source>
          <target state="translated">El significado del prefijo &lt;code&gt;&amp;amp;&lt;/code&gt; no es exactamente el mismo que en C. En particular, cualquier cambio en las variables referenciadas no ser&amp;aacute; visible en Julia a menos que el tipo sea mutable (declarado a trav&amp;eacute;s de una &lt;code&gt;mutable struct&lt;/code&gt; ). Sin embargo, incluso para estructuras inmutables, no causar&amp;aacute; ning&amp;uacute;n da&amp;ntilde;o a las funciones llamadas intentar tales modificaciones (es decir, escribir a trav&amp;eacute;s de los punteros pasados). Adem&amp;aacute;s, &lt;code&gt;&amp;amp;&lt;/code&gt; puede usarse con cualquier expresi&amp;oacute;n, como &lt;code&gt;&amp;amp;0&lt;/code&gt; o &lt;code&gt;&amp;amp;f(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdb2209b7357825841deb8a7b0ab3a885d17542" translate="yes" xml:space="preserve">
          <source>The meaning of this form is that &lt;code&gt;F(x,y,...)&lt;/code&gt; is evaluated with the variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, etc. taking on each value in their given list of values. Values can be specified as any iterable object, but will commonly be ranges like &lt;code&gt;1:n&lt;/code&gt; or &lt;code&gt;2:(n-1)&lt;/code&gt;, or explicit arrays of values like &lt;code&gt;[1.2, 3.4, 5.7]&lt;/code&gt;. The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable ranges &lt;code&gt;rx&lt;/code&gt;, &lt;code&gt;ry&lt;/code&gt;, etc. and each &lt;code&gt;F(x,y,...)&lt;/code&gt; evaluation returns a scalar.</source>
          <target state="translated">El significado de esta forma es que &lt;code&gt;F(x,y,...)&lt;/code&gt; se eval&amp;uacute;a con las variables &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , etc. tomando cada valor en su lista de valores dada. Los valores pueden ser especificados como cualquier objeto iterable, pero ser&amp;aacute; com&amp;uacute;nmente rangos como &lt;code&gt;1:n&lt;/code&gt; o &lt;code&gt;2:(n-1)&lt;/code&gt; , o matrices expl&amp;iacute;citas de valores como &lt;code&gt;[1.2, 3.4, 5.7]&lt;/code&gt; . El resultado es una matriz densa Nd con dimensiones que son la concatenaci&amp;oacute;n de las dimensiones de los rangos de variables &lt;code&gt;rx&lt;/code&gt; , &lt;code&gt;ry&lt;/code&gt; , etc. y cada evaluaci&amp;oacute;n &lt;code&gt;F(x,y,...)&lt;/code&gt; devuelve un escalar.</target>
        </trans-unit>
        <trans-unit id="094836238d056b1580750e9abbf5cfe48e515f79" translate="yes" xml:space="preserve">
          <source>The mechanism by which Julia picks default sorting algorithms is implemented via the &lt;code&gt;Base.Sort.defalg&lt;/code&gt; function. It allows a particular algorithm to be registered as the default in all sorting functions for specific arrays. For example, here are the two default methods from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/sort.jl&quot;&gt;&lt;code&gt;sort.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">El mecanismo por el cual Julia elige los algoritmos de clasificaci&amp;oacute;n predeterminados se implementa a trav&amp;eacute;s de la funci&amp;oacute;n &lt;code&gt;Base.Sort.defalg&lt;/code&gt; . Permite que un algoritmo particular se registre como predeterminado en todas las funciones de clasificaci&amp;oacute;n para matrices espec&amp;iacute;ficas. Por ejemplo, estos son los dos m&amp;eacute;todos predeterminados de &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/sort.jl&quot;&gt; &lt;code&gt;sort.jl&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="43db34e5821153c9a137e29694256181086c27e9" translate="yes" xml:space="preserve">
          <source>The mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are merged as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have &lt;code&gt;stack = [env₁, env₂, &amp;hellip;]&lt;/code&gt; then we have:</source>
          <target state="translated">El mecanismo para combinar las estructuras de datos de ra&amp;iacute;ces, gr&amp;aacute;ficos y rutas de los componentes de una pila de entorno es simple: se fusionan como diccionarios, favoreciendo las entradas anteriores sobre las posteriores en el caso de colisiones de claves. En otras palabras, si tenemos &lt;code&gt;stack = [env₁, env₂, &amp;hellip;]&lt;/code&gt; entonces tenemos:</target>
        </trans-unit>
        <trans-unit id="ec55008649a0dc54bad05f3e8bc19d30ce40563f" translate="yes" xml:space="preserve">
          <source>The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia's non-standard literals implemented using it, but also the command literal syntax (&lt;code&gt;`echo &quot;Hello, $person&quot;`&lt;/code&gt;) is implemented with the following innocuous-looking macro:</source>
          <target state="translated">El mecanismo para cadenas literales definidas por el usuario es profunda, profundamente poderoso. No solo se implementan los literales no est&amp;aacute;ndar de Julia us&amp;aacute;ndolo, sino que tambi&amp;eacute;n la sintaxis literal de comando ( &lt;code&gt;`echo &quot;Hello, $person&quot;`&lt;/code&gt; ) se implementa con la siguiente macro de apariencia inocua:</target>
        </trans-unit>
        <trans-unit id="bcd798f681426c31836c9fda7a95d8d4ad32f495" translate="yes" xml:space="preserve">
          <source>The memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.</source>
          <target state="translated">La estimación del consumo de memoria es un límite inferior aproximado del tamaño de la estructura interna del objeto.</target>
        </trans-unit>
        <trans-unit id="131ca4486e37b369d3e30c30d5b64041c99a698f" translate="yes" xml:space="preserve">
          <source>The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)</source>
          <target state="translated">El comportamiento de compartir la memoria de un conjunto remodelado es ignorado por la precompilación (cada vista obtiene su propia copia)</target>
        </trans-unit>
        <trans-unit id="298da21a7dd2cc02f54513ff13a66eb673f4dedf" translate="yes" xml:space="preserve">
          <source>The message log level is checked against a global minimum level (set via &lt;a href=&quot;#Base.CoreLogging.disable_logging&quot;&gt;&lt;code&gt;disable_logging&lt;/code&gt;&lt;/a&gt;). This is a crude but extremely cheap global setting.</source>
          <target state="translated">El nivel de registro de mensajes se compara con un nivel m&amp;iacute;nimo global (establecido a trav&amp;eacute;s de &lt;a href=&quot;#Base.CoreLogging.disable_logging&quot;&gt; &lt;code&gt;disable_logging&lt;/code&gt; &lt;/a&gt; ). Este es un escenario global crudo pero extremadamente barato.</target>
        </trans-unit>
        <trans-unit id="75a3b4a8bcb25896eadb4968a1815458fd7550b7" translate="yes" xml:space="preserve">
          <source>The message log level is checked against a global minimum level (set via &lt;a href=&quot;#Logging.disable_logging&quot;&gt;&lt;code&gt;disable_logging&lt;/code&gt;&lt;/a&gt;). This is a crude but extremely cheap global setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee1b8c607641ce31a518860743fee60270b010d" translate="yes" xml:space="preserve">
          <source>The message-processing loop waits on an &lt;code&gt;IO&lt;/code&gt; object (for example, a &lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt;&lt;code&gt;TCPSocket&lt;/code&gt;&lt;/a&gt; in the default implementation), reads an entire message, processes it and waits for the next one.</source>
          <target state="translated">El ciclo de procesamiento de mensajes espera en un objeto &lt;code&gt;IO&lt;/code&gt; (por ejemplo, un &lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt; &lt;code&gt;TCPSocket&lt;/code&gt; &lt;/a&gt; en la implementaci&amp;oacute;n predeterminada), lee un mensaje completo, lo procesa y espera el siguiente.</target>
        </trans-unit>
        <trans-unit id="34b07feb0bdcab65a9fbeace753dff1c13bab9a7" translate="yes" xml:space="preserve">
          <source>The method defined above adds parentheses around the call to &lt;code&gt;show&lt;/code&gt; when the precedence of the calling operator is higher than or equal to the precedence of multiplication. This check allows expressions which parse correctly without the parentheses (such as &lt;code&gt;:($a + 2)&lt;/code&gt; and &lt;code&gt;:($a == 2)&lt;/code&gt;) to omit them when printing:</source>
          <target state="translated">El m&amp;eacute;todo definido anteriormente agrega par&amp;eacute;ntesis alrededor de la llamada para &lt;code&gt;show&lt;/code&gt; cu&amp;aacute;ndo la precedencia del operador que llama es mayor o igual que la precedencia de la multiplicaci&amp;oacute;n. Esta verificaci&amp;oacute;n permite que las expresiones que se analizan correctamente sin los par&amp;eacute;ntesis (como &lt;code&gt;:($a + 2)&lt;/code&gt; y &lt;code&gt;:($a == 2)&lt;/code&gt; ) las omitan al imprimir:</target>
        </trans-unit>
        <trans-unit id="480991bedb511928dce09fcfa14be4d26a369c2c" translate="yes" xml:space="preserve">
          <source>The method which accepts a predicate function requires Julia 1.2 or later.</source>
          <target state="translated">El método que acepta una función predicada requiere Julia 1.2 o posterior.</target>
        </trans-unit>
        <trans-unit id="f97574c149c35a5f9c0479909c6ba575706d9f14" translate="yes" xml:space="preserve">
          <source>The method which accepts a type requires Julia 1.5 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f940b926f7e3b612433e90295b463c51a97504f9" translate="yes" xml:space="preserve">
          <source>The methods in &lt;code&gt;Profile&lt;/code&gt; are not exported and need to be called e.g. as &lt;code&gt;Profile.print()&lt;/code&gt;.</source>
          <target state="translated">Los m&amp;eacute;todos en &lt;code&gt;Profile&lt;/code&gt; no se exportan y deben llamarse, por ejemplo, como &lt;code&gt;Profile.print()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a65046dfbce016e3be9d63dceb54432e4f789ee8" translate="yes" xml:space="preserve">
          <source>The microsecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El microsegundo de un &lt;code&gt;Time&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9daf874100ff7e0440c12dfc313262d02c86576" translate="yes" xml:space="preserve">
          <source>The microsecond part of a Time as a &lt;code&gt;Microsecond&lt;/code&gt;.</source>
          <target state="translated">La parte de un microsegundo de tiempo como un &lt;code&gt;Microsecond&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="600f058835f17e7a50a06fc528fa2b5032e36ca7" translate="yes" xml:space="preserve">
          <source>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt;. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator should be used explicitly (see &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation&quot;&gt;Short-Circuit Evaluation&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0211eebcec0e70acc996cc19c6867555ed469b5e" translate="yes" xml:space="preserve">
          <source>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt;. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator should be used explicitly (see &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt;).</source>
          <target state="translated">La expresi&amp;oacute;n del medio solo se eval&amp;uacute;a una vez, en lugar de dos veces, como lo har&amp;iacute;a si la expresi&amp;oacute;n se escribiera como &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt; . Sin embargo, el orden de las evaluaciones en una comparaci&amp;oacute;n encadenada no est&amp;aacute; definido. Se recomienda encarecidamente no utilizar expresiones con efectos secundarios (como la impresi&amp;oacute;n) en comparaciones encadenadas. Si se requieren efectos secundarios, el operador &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; de cortocircuito debe usarse expl&amp;iacute;citamente (consulte &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Evaluaci&amp;oacute;n de cortocircuito&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0dd44e8ebcb71bf9c89ef76d2d2682687dc6d684" translate="yes" xml:space="preserve">
          <source>The millisecond of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El milisegundo de un &lt;code&gt;DateTime&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a912f50c335b4d49dd33d6b3bdff08954f636271" translate="yes" xml:space="preserve">
          <source>The millisecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El milisegundo de un &lt;code&gt;Time&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b6a7eeee369dc2111377df37522ca806e23ee00" translate="yes" xml:space="preserve">
          <source>The millisecond part of a DateTime as a &lt;code&gt;Millisecond&lt;/code&gt;.</source>
          <target state="translated">La parte de milisegundos de un DateTime como &lt;code&gt;Millisecond&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0efc4b9b581f6e3f5cda1b69fb5ed353c8f838e4" translate="yes" xml:space="preserve">
          <source>The minimum and maximum representable values of primitive numeric types such as integers are given by the &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">Los valores representables m&amp;iacute;nimos y m&amp;aacute;ximos de tipos num&amp;eacute;ricos primitivos, como enteros, vienen dados por las funciones &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="85c14b13e4a83e3f641ac750e22da88ea684c364" translate="yes" xml:space="preserve">
          <source>The minute of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El minuto de un &lt;code&gt;DateTime&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1f5f0a330c1e54ad4dd4510d655f5340eec1c4" translate="yes" xml:space="preserve">
          <source>The minute of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El minuto de un &lt;code&gt;Time&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c946111c81e7adfe6af7b762fccd905ec8f88a87" translate="yes" xml:space="preserve">
          <source>The minute part of a DateTime as a &lt;code&gt;Minute&lt;/code&gt;.</source>
          <target state="translated">La parte de minutos de un DateTime como &lt;code&gt;Minute&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="847c706add1091574c034eb4a9e1b16f126a1aa6" translate="yes" xml:space="preserve">
          <source>The month of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El mes de &lt;code&gt;Date&lt;/code&gt; o &lt;code&gt;DateTime&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ffed8c4cf30ae11b37e19dbd7e317d781c6a99d" translate="yes" xml:space="preserve">
          <source>The most basic Julia workflows involve using a text editor in conjunction with the &lt;code&gt;julia&lt;/code&gt; command line. A common pattern includes the following elements:</source>
          <target state="translated">Los flujos de trabajo de Julia m&amp;aacute;s b&amp;aacute;sicos implican el uso de un editor de texto junto con la l&amp;iacute;nea de comandos de &lt;code&gt;julia&lt;/code&gt; . Un patr&amp;oacute;n com&amp;uacute;n incluye los siguientes elementos:</target>
        </trans-unit>
        <trans-unit id="d8d0db7f857485bf8537d6760d93ea9e3026a18d" translate="yes" xml:space="preserve">
          <source>The most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.</source>
          <target state="translated">El tipo de tipo más comúnmente usado en Julia es una estructura,especificada como un nombre y un conjunto de campos.</target>
        </trans-unit>
        <trans-unit id="bd6910dc7e6ab3eb744adf6e8b4dbbd2635bda90" translate="yes" xml:space="preserve">
          <source>The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this &lt;a href=&quot;http://danluu.com/integer-overflow/&quot;&gt;blog post&lt;/a&gt;, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.</source>
          <target state="translated">La alternativa m&amp;aacute;s razonable para que la aritm&amp;eacute;tica de enteros se desborde silenciosamente es hacer aritm&amp;eacute;tica verificada en todas partes, lo que genera errores cuando sumas, restas y multiplicas desbordan, produciendo valores que no son correctos. En esta &lt;a href=&quot;http://danluu.com/integer-overflow/&quot;&gt;publicaci&amp;oacute;n de blog&lt;/a&gt; , Dan Luu analiza esto y descubre que, en lugar del costo trivial que este enfoque deber&amp;iacute;a tener en teor&amp;iacute;a, termina teniendo un costo sustancial debido a que los compiladores (LLVM y GCC) no optimizan elegantemente las verificaciones de desbordamiento adicionales. Si esto mejora en el futuro, podr&amp;iacute;amos considerar la posibilidad de utilizar la aritm&amp;eacute;tica de enteros comprobados en Julia, pero por ahora, tenemos que vivir con la posibilidad de desbordamiento.</target>
        </trans-unit>
        <trans-unit id="ec065458cc7c9342c0c2e44c9f424cdd0c1a7826" translate="yes" xml:space="preserve">
          <source>The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this &lt;a href=&quot;https://danluu.com/integer-overflow/&quot;&gt;blog post&lt;/a&gt;, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c96614bea2c2a0370b72e64ab597c56a3607929" translate="yes" xml:space="preserve">
          <source>The most significant departures of Julia from typical dynamic languages are:</source>
          <target state="translated">Las salidas más significativas de Julia de los típicos lenguajes dinámicos son:</target>
        </trans-unit>
        <trans-unit id="227e81ea680d9761105bfdd7a757c011a63d4676" translate="yes" xml:space="preserve">
          <source>The most useful log pattern is a simple tuple of the form &lt;code&gt;(level,message)&lt;/code&gt;. A different number of tuple elements may be used to match other log metadata, corresponding to the arguments to passed to &lt;code&gt;AbstractLogger&lt;/code&gt; via the &lt;code&gt;handle_message&lt;/code&gt; function: &lt;code&gt;(level,message,module,group,id,file,line)&lt;/code&gt;. Elements which are present will be matched pairwise with the log record fields using &lt;code&gt;==&lt;/code&gt; by default, with the special cases that &lt;code&gt;Symbol&lt;/code&gt;s may be used for the standard log levels, and &lt;code&gt;Regex&lt;/code&gt;s in the pattern will match string or Symbol fields using &lt;code&gt;occursin&lt;/code&gt;.</source>
          <target state="translated">El patr&amp;oacute;n de registro m&amp;aacute;s &amp;uacute;til es una tupla simple del formulario &lt;code&gt;(level,message)&lt;/code&gt; . Se puede usar un n&amp;uacute;mero diferente de elementos de tupla para hacer coincidir otros metadatos de registro, correspondientes a los argumentos que se pasan a &lt;code&gt;AbstractLogger&lt;/code&gt; a trav&amp;eacute;s de la funci&amp;oacute;n &lt;code&gt;handle_message&lt;/code&gt; : &lt;code&gt;(level,message,module,group,id,file,line)&lt;/code&gt; . Los elementos que est&amp;aacute;n presentes se emparejar&amp;aacute;n por pares con los campos de registro de registro utilizando &lt;code&gt;==&lt;/code&gt; de forma predeterminada, con los casos especiales en que los &lt;code&gt;Symbol&lt;/code&gt; pueden usarse para los niveles de registro est&amp;aacute;ndar, y las &lt;code&gt;Regex&lt;/code&gt; en el patr&amp;oacute;n coincidir&amp;aacute;n con los campos de cadena o s&amp;iacute;mbolo que usan &lt;code&gt;occursin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b7050ead4b7f2406a51989e3a96dcd274b5c4dc" translate="yes" xml:space="preserve">
          <source>The name of &lt;code&gt;tag&lt;/code&gt; (e.g. &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt;).</source>
          <target state="translated">El nombre de la &lt;code&gt;tag&lt;/code&gt; (por ejemplo, &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aac1a5f61cbf21e0f76584158e2b1aa448b0700a" translate="yes" xml:space="preserve">
          <source>The name of the function containing the execution context.</source>
          <target state="translated">El nombre de la función que contiene el contexto de ejecución.</target>
        </trans-unit>
        <trans-unit id="0b15e5d3b4e9ddd6442998593016569d415621b0" translate="yes" xml:space="preserve">
          <source>The nanosecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El nanosegundo de un &lt;code&gt;Time&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aad1073892a176543a30631fd9ae9393da61cbfc" translate="yes" xml:space="preserve">
          <source>The nanosecond part of a Time as a &lt;code&gt;Nanosecond&lt;/code&gt;.</source>
          <target state="translated">La parte de nanosegundos de un tiempo como &lt;code&gt;Nanosecond&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82e0de7b0a951b098e85d827d86686abc302c514" translate="yes" xml:space="preserve">
          <source>The nature of keyword arguments makes it possible to specify the same argument more than once. For example, in the call &lt;code&gt;plot(x, y; options..., width=2)&lt;/code&gt; it is possible that the &lt;code&gt;options&lt;/code&gt; structure also contains a value for &lt;code&gt;width&lt;/code&gt;. In such a case the rightmost occurrence takes precedence; in this example, &lt;code&gt;width&lt;/code&gt; is certain to have the value &lt;code&gt;2&lt;/code&gt;. However, explicitly specifying the same keyword argument multiple times, for example &lt;code&gt;plot(x, y, width=2, width=3)&lt;/code&gt;, is not allowed and results in a syntax error.</source>
          <target state="translated">La naturaleza de los argumentos de palabras clave hace posible especificar el mismo argumento m&amp;aacute;s de una vez. Por ejemplo, en el &lt;code&gt;plot(x, y; options..., width=2)&lt;/code&gt; llamadas (x, y; opciones ..., ancho = 2) es posible que la estructura de &lt;code&gt;options&lt;/code&gt; tambi&amp;eacute;n contenga un valor para el &lt;code&gt;width&lt;/code&gt; . En tal caso, la aparici&amp;oacute;n m&amp;aacute;s a la derecha tiene prioridad; en este ejemplo, el &lt;code&gt;width&lt;/code&gt; seguramente tendr&amp;aacute; el valor &lt;code&gt;2&lt;/code&gt; . Sin embargo, especificar expl&amp;iacute;citamente el mismo argumento de palabra clave varias veces, por ejemplo, &lt;code&gt;plot(x, y, width=2, width=3)&lt;/code&gt; , no est&amp;aacute; permitido y da como resultado un error de sintaxis.</target>
        </trans-unit>
        <trans-unit id="314d66ff5662511b17e76bf3864e0515f7414401" translate="yes" xml:space="preserve">
          <source>The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a &lt;code&gt;:&lt;/code&gt;, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array &lt;code&gt;A&lt;/code&gt;. The total number of elements must not change.</source>
          <target state="translated">Las nuevas dimensiones se pueden especificar como una lista de argumentos o como una tupla de forma. Como m&amp;aacute;ximo, una dimensi&amp;oacute;n puede especificarse con &lt;code&gt;:&lt;/code&gt; , en cuyo caso su longitud se calcula de manera que su producto con todas las dimensiones especificadas sea igual a la longitud de la matriz &lt;code&gt;A&lt;/code&gt; original . El n&amp;uacute;mero total de elementos no debe cambiar.</target>
        </trans-unit>
        <trans-unit id="c7c774e234a53110d1af9fd61a5cda8cbeee8a27" translate="yes" xml:space="preserve">
          <source>The next clear cut situation we'll consider is when there is already a local variable named &lt;code&gt;x&lt;/code&gt;, in which case &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; always assigns to this existing local &lt;code&gt;x&lt;/code&gt;. The function &lt;code&gt;sum_to&lt;/code&gt; computes the sum of the numbers from one up to &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec82b325e399ba219250018d4cd45bb47824912" translate="yes" xml:space="preserve">
          <source>The next example composes three functions and maps the result over an array of strings:</source>
          <target state="translated">El siguiente ejemplo compone tres funciones y mapea el resultado sobre un conjunto de cuerdas:</target>
        </trans-unit>
        <trans-unit id="0141922960db98bd617ee28c2bf6139f8261ae58" translate="yes" xml:space="preserve">
          <source>The next step is to &lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Computer_languages&quot;&gt;parse&lt;/a&gt; each string into an object called an expression, represented by the Julia type &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">El siguiente paso es &lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Computer_languages&quot;&gt;analizar&lt;/a&gt; cada cadena en un objeto llamado expresi&amp;oacute;n, representada por el tipo de Julia &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="571a7acf064deadfa35e0bae63b5faada78832c9" translate="yes" xml:space="preserve">
          <source>The next step is to set up the project to find the Julia include files and the libraries. It's important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn't correspond to the Julia installation before proceeding.</source>
          <target state="translated">El siguiente paso es establecer el proyecto para encontrar los archivos de Julia include y las bibliotecas.Es importante saber si la instalación de Julia es de 32 o 64 bits.Elimine cualquier configuración de la plataforma que no corresponda a la instalación de Julia antes de proceder.</target>
        </trans-unit>
        <trans-unit id="87d90798d58eeb7d4e5d75a87f02bc64256ab91b" translate="yes" xml:space="preserve">
          <source>The next two higher-order methods, &lt;a href=&quot;#Dates.tonext-Tuple%7BTimeType,Int64%7D&quot;&gt;&lt;code&gt;tonext&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Dates.toprev-Tuple%7BTimeType,Int64%7D&quot;&gt;&lt;code&gt;toprev&lt;/code&gt;&lt;/a&gt;, generalize working with temporal expressions by taking a &lt;code&gt;DateFunction&lt;/code&gt; as first argument, along with a starting &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;DateFunction&lt;/code&gt; is just a function, usually anonymous, that takes a single &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; as input and returns a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;true&lt;/code&gt; indicating a satisfied adjustment criterion. For example:</source>
          <target state="translated">Los siguientes dos m&amp;eacute;todos de orden superior, &lt;a href=&quot;#Dates.tonext-Tuple%7BTimeType,Int64%7D&quot;&gt; &lt;code&gt;tonext&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#Dates.toprev-Tuple%7BTimeType,Int64%7D&quot;&gt; &lt;code&gt;toprev&lt;/code&gt; &lt;/a&gt; , generalizan el trabajo con expresiones temporales tomando un &lt;code&gt;DateFunction&lt;/code&gt; como primer argumento, junto con un &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; inicial . Una &lt;code&gt;DateFunction&lt;/code&gt; es solo una funci&amp;oacute;n, generalmente an&amp;oacute;nima, que toma un solo &lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt; como entrada y devuelve un &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;true&lt;/code&gt; , lo que indica un criterio de ajuste satisfecho. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="bfdcd43295ca16b8983e8ac5f09ed7f5b30bbe1e" translate="yes" xml:space="preserve">
          <source>The next two steps (selecting the output array and implementation) are dependent upon determining a single answer for a given set of arguments. Broadcast must take all the varied types of its arguments and collapse them down to just one output array and one implementation. Broadcast calls this single answer a &quot;style.&quot; Every broadcastable object each has its own preferred style, and a promotion-like system is used to combine these styles into a single answer &amp;mdash; the &quot;destination style&quot;.</source>
          <target state="translated">Los siguientes dos pasos (seleccionar la matriz de salida y la implementaci&amp;oacute;n) dependen de la determinaci&amp;oacute;n de una &amp;uacute;nica respuesta para un conjunto de argumentos dado. Broadcast debe tomar todos los tipos variados de sus argumentos y reducirlos a una sola matriz de salida y una implementaci&amp;oacute;n. Broadcast llama a esta respuesta &amp;uacute;nica un &quot;estilo&quot;. Cada objeto retransmisible tiene su propio estilo preferido, y se utiliza un sistema similar a una promoci&amp;oacute;n para combinar estos estilos en una &amp;uacute;nica respuesta: el &quot;estilo de destino&quot;.</target>
        </trans-unit>
        <trans-unit id="aa11e7d901418eb60c69c43212182dad6fd572f8" translate="yes" xml:space="preserve">
          <source>The no-equilibration, no-transpose simplification of &lt;code&gt;gesvx!&lt;/code&gt;.</source>
          <target state="translated">&amp;iexcl;La simplificaci&amp;oacute;n sin equilibrio y sin transposici&amp;oacute;n de &lt;code&gt;gesvx!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3be6317f46ece197572e4701784f6328c75ca21" translate="yes" xml:space="preserve">
          <source>The node where the value is stored keeps track of which of the workers have a reference to it. Every time a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; or a (unfetched) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is serialized to a worker, the node pointed to by the reference is notified. And every time a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; or a (unfetched) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is garbage collected locally, the node owning the value is again notified. This is implemented in an internal cluster aware serializer. Remote references are only valid in the context of a running cluster. Serializing and deserializing references to and from regular &lt;code&gt;IO&lt;/code&gt; objects is not supported.</source>
          <target state="translated">El nodo donde se almacena el valor realiza un seguimiento de cu&amp;aacute;l de los trabajadores tiene una referencia a &amp;eacute;l. Cada vez que un &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; o un &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; (no obtenido) se serializa a un trabajador, se notifica al nodo al que apunta la referencia. Y cada vez que se recolectan basura localmente un &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; o un &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; (no obtenido) , se notifica nuevamente al nodo que posee el valor. Esto se implementa en un serializador interno con reconocimiento de cl&amp;uacute;steres. Las referencias remotas solo son v&amp;aacute;lidas en el contexto de un cl&amp;uacute;ster en ejecuci&amp;oacute;n. No se admite la serializaci&amp;oacute;n y deserializaci&amp;oacute;n de referencias ay desde objetos &lt;code&gt;IO&lt;/code&gt; regulares .</target>
        </trans-unit>
        <trans-unit id="1ee269a033086fa0f88e3b8bd43c4d1005189ba4" translate="yes" xml:space="preserve">
          <source>The node which owns the value frees it once all references to it are cleared.</source>
          <target state="translated">El nodo que posee el valor lo libera una vez que todas las referencias a él son eliminadas.</target>
        </trans-unit>
        <trans-unit id="f7755c5c54345d39219c99d946bb10594613370c" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; can be used to express the Julia analogue of a &lt;em&gt;covariant&lt;/em&gt; type, while &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; the analogue of a &lt;em&gt;contravariant&lt;/em&gt; type, but technically these represent &lt;em&gt;sets&lt;/em&gt; of types (see &lt;a href=&quot;#UnionAll-Types&quot;&gt;UnionAll Types&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9581a565bb9e56cce70d93ca5c19c14a7d3c0d" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; can be used to express the Julia analogue of a &lt;em&gt;covariant&lt;/em&gt; type, while &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; the analogue of a &lt;em&gt;contravariant&lt;/em&gt; type, but technically these represent &lt;em&gt;sets&lt;/em&gt; of types (see &lt;a href=&quot;#UnionAll-Types-1&quot;&gt;UnionAll Types&lt;/a&gt;).</source>
          <target state="translated">La notaci&amp;oacute;n &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; se puede usar para expresar el an&amp;aacute;logo de Julia de un tipo &lt;em&gt;covariante&lt;/em&gt; , mientras que &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; el an&amp;aacute;logo de un tipo &lt;em&gt;contravariante&lt;/em&gt; , pero t&amp;eacute;cnicamente estos representan &lt;em&gt;conjuntos&lt;/em&gt; de tipos (ver &lt;a href=&quot;#UnionAll-Types-1&quot;&gt;UnionAll Types&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d8a556b93d1842772dc7f76de931e723dfee64b" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;T(x)&lt;/code&gt; or &lt;code&gt;convert(T,x)&lt;/code&gt; converts &lt;code&gt;x&lt;/code&gt; to a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">La notaci&amp;oacute;n &lt;code&gt;T(x)&lt;/code&gt; o &lt;code&gt;convert(T,x)&lt;/code&gt; convertidos &lt;code&gt;x&lt;/code&gt; a un valor de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe139a73bee792b672a69d44b859332e9c6820f5" translate="yes" xml:space="preserve">
          <source>The notifications are done via sending of &quot;tracking&quot; messages&amp;ndash;an &quot;add reference&quot; message when a reference is serialized to a different process and a &quot;delete reference&quot; message when a reference is locally garbage collected.</source>
          <target state="translated">Las notificaciones se realizan mediante el env&amp;iacute;o de mensajes de &quot;seguimiento&quot;, un mensaje de &quot;agregar referencia&quot; cuando una referencia se serializa a un proceso diferente y un mensaje de &quot;eliminar referencia&quot; cuando una referencia se recolecta localmente como basura.</target>
        </trans-unit>
        <trans-unit id="2cbf1f552e1a2901fc74809693aa1d1ec7161dbc" translate="yes" xml:space="preserve">
          <source>The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a &quot;UT second&quot;, as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Time&quot;&gt;UT&lt;/a&gt; or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.</source>
          <target state="translated">La noci&amp;oacute;n del segundo UT es en realidad bastante fundamental. B&amp;aacute;sicamente, existen dos nociones diferentes de tiempo generalmente aceptadas, una basada en la rotaci&amp;oacute;n f&amp;iacute;sica de la tierra (una rotaci&amp;oacute;n completa = 1 d&amp;iacute;a), la otra basada en el segundo SI (un valor fijo y constante). &amp;iexcl;Son radicalmente diferentes! Piense en ello, un &quot;segundo UT&quot;, como se define en relaci&amp;oacute;n con la rotaci&amp;oacute;n de la Tierra, puede tener una duraci&amp;oacute;n absoluta diferente seg&amp;uacute;n el d&amp;iacute;a. De todos modos, el hecho de que &lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; se basan en segundos UT es una suposici&amp;oacute;n simplista pero honesta, de modo que se pueden evitar cosas como los segundos intercalares y toda su complejidad. Esta base de tiempo se llama formalmente &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Time&quot;&gt;UT&lt;/a&gt;o UT1. Basar los tipos en el segundo UT b&amp;aacute;sicamente significa que cada minuto tiene 60 segundos y cada d&amp;iacute;a tiene 24 horas y conduce a c&amp;aacute;lculos m&amp;aacute;s naturales cuando se trabaja con fechas de calendario.</target>
        </trans-unit>
        <trans-unit id="abccc41a26dc7addb4c68d102fecb6865b6fa56f" translate="yes" xml:space="preserve">
          <source>The number after the name indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The &lt;a href=&quot;../numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; declaration shows how a primitive type can be optionally declared to be a subtype of some supertype.</source>
          <target state="translated">El n&amp;uacute;mero despu&amp;eacute;s del nombre indica cu&amp;aacute;ntos bits de almacenamiento requiere el tipo. Actualmente, solo se admiten tama&amp;ntilde;os que son m&amp;uacute;ltiplos de 8 bits. La declaraci&amp;oacute;n &lt;a href=&quot;../numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; muestra c&amp;oacute;mo un tipo primitivo puede declararse opcionalmente como un subtipo de alg&amp;uacute;n supertipo.</target>
        </trans-unit>
        <trans-unit id="5ce8d9c28b728282659fe445b5ac4e7293389f79" translate="yes" xml:space="preserve">
          <source>The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having &lt;code&gt;Any&lt;/code&gt; as its immediate supertype. The declaration of &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; above therefore means that a boolean value takes eight bits to store, and has &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported and you are likely to experience LLVM bugs with sizes other than those used above. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375b6efd3979207393378302c9f41c7a21121f28" translate="yes" xml:space="preserve">
          <source>The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having &lt;code&gt;Any&lt;/code&gt; as its immediate supertype. The declaration of &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; above therefore means that a boolean value takes eight bits to store, and has &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.</source>
          <target state="translated">El n&amp;uacute;mero de bits indica cu&amp;aacute;nto almacenamiento requiere el tipo y el nombre le da un nombre al nuevo tipo. Opcionalmente, un tipo primitivo puede declararse como un subtipo de alg&amp;uacute;n supertipo. Si se omite un supertipo, el tipo tiene por defecto &lt;code&gt;Any&lt;/code&gt; como supertipo inmediato. La declaraci&amp;oacute;n de &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; anterior por lo tanto significa que un valor booleano toma ocho bits para almacenar y tiene &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; como su supertipo inmediato. Actualmente, solo se admiten tama&amp;ntilde;os que son m&amp;uacute;ltiplos de 8 bits. Por lo tanto, los valores booleanos, aunque realmente necesitan un solo bit, no se pueden declarar como menores de ocho bits.</target>
        </trans-unit>
        <trans-unit id="e47d85b6b66b2f56b7aa9e07418e7bd219677af8" translate="yes" xml:space="preserve">
          <source>The number of characters in string &lt;code&gt;s&lt;/code&gt; from indices &lt;code&gt;i&lt;/code&gt; through &lt;code&gt;j&lt;/code&gt;. This is computed as the number of code unit indices from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt; which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; arguments it computes the number of indices between &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; inclusive that are valid indices in the string &lt;code&gt;s&lt;/code&gt;. In addition to in-bounds values, &lt;code&gt;i&lt;/code&gt; may take the out-of-bounds value &lt;code&gt;ncodeunits(s) + 1&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; may take the out-of-bounds value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de caracteres en la cadena &lt;code&gt;s&lt;/code&gt; desde los &amp;iacute;ndices &lt;code&gt;i&lt;/code&gt; hasta &lt;code&gt;j&lt;/code&gt; . Esto se calcula como el n&amp;uacute;mero de &amp;iacute;ndices de unidad de c&amp;oacute;digo de &lt;code&gt;i&lt;/code&gt; a &lt;code&gt;j&lt;/code&gt; que son &amp;iacute;ndices de caracteres v&amp;aacute;lidos. Con un solo argumento de cadena, esto calcula el n&amp;uacute;mero de caracteres en toda la cadena. Con &lt;code&gt;i&lt;/code&gt; y &lt;code&gt;j&lt;/code&gt; argumentos, calcula el n&amp;uacute;mero de &amp;iacute;ndices entre &lt;code&gt;i&lt;/code&gt; y &lt;code&gt;j&lt;/code&gt; inclusive que son &amp;iacute;ndices v&amp;aacute;lidos en la cadena &lt;code&gt;s&lt;/code&gt; . Adem&amp;aacute;s de los valores de l&amp;iacute;mites, &lt;code&gt;i&lt;/code&gt; puede tomar la fuera de l&amp;iacute;mites valor &lt;code&gt;ncodeunits(s) + 1&lt;/code&gt; y &lt;code&gt;j&lt;/code&gt; puede tomar el valor fuera de l&amp;iacute;mites &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="716e2de76c8a5d41901615633885a66308369487" translate="yes" xml:space="preserve">
          <source>The number of execution threads is controlled either by using the &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; command line argument or by using the &lt;a href=&quot;../environment-variables/index#JULIA_NUM_THREADS&quot;&gt;&lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt;&lt;/a&gt; environment variable. When both are specified, then &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; takes precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad86f1d6f640919b745cf8a5f2bdcf26fd5ffb5" translate="yes" xml:space="preserve">
          <source>The number of hard links to the file</source>
          <target state="translated">El número de enlaces duros al archivo</target>
        </trans-unit>
        <trans-unit id="24a208f4a834f5901bdf25637d96fa3b819cf46a" translate="yes" xml:space="preserve">
          <source>The number of items in each dimension, if known</source>
          <target state="translated">El número de elementos en cada dimensión,si se conoce</target>
        </trans-unit>
        <trans-unit id="eba5aa4a440d944ee0ac4bd42c3f98d0088c8d6f" translate="yes" xml:space="preserve">
          <source>The number of items, if known</source>
          <target state="translated">El número de artículos,si se conoce</target>
        </trans-unit>
        <trans-unit id="fd0b7f33e8f96892366bb012a5417e87ca9ea66f" translate="yes" xml:space="preserve">
          <source>The number of logical CPU cores available in the system, i.e. the number of threads that the CPU can run concurrently. Note that this is not necessarily the number of CPU cores, for example, in the presence of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-threading&quot;&gt;hyper-threading&lt;/a&gt;.</source>
          <target state="translated">La cantidad de n&amp;uacute;cleos de CPU l&amp;oacute;gicos disponibles en el sistema, es decir, la cantidad de subprocesos que la CPU puede ejecutar simult&amp;aacute;neamente. Tenga en cuenta que este no es necesariamente el n&amp;uacute;mero de n&amp;uacute;cleos de CPU, por ejemplo, en presencia de &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-threading&quot;&gt;hiperprocesos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e345fe9c2de9253c74f924ce4e5ac488569c4e0e" translate="yes" xml:space="preserve">
          <source>The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; in the worker process's environment. Relevant only when using TCP/IP as transport.</source>
          <target state="translated">El n&amp;uacute;mero de segundos que espera un trabajador reci&amp;eacute;n lanzado para el establecimiento de la conexi&amp;oacute;n desde el maestro se puede especificar mediante la variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; en el entorno del proceso de trabajo. Relevante solo cuando se usa TCP / IP como transporte.</target>
        </trans-unit>
        <trans-unit id="f364903fb4c2618f3b395fcdcccd998ed24fc310" translate="yes" xml:space="preserve">
          <source>The number of sequential code characters indicate the width of the code. A format of &lt;code&gt;yyyy-mm&lt;/code&gt; specifies that the code &lt;code&gt;y&lt;/code&gt; should have a width of four while &lt;code&gt;m&lt;/code&gt; a width of two. Codes that yield numeric digits have an associated mode: fixed-width or minimum-width. The fixed-width mode left-pads the value with zeros when it is shorter than the specified width and truncates the value when longer. Minimum-width mode works the same as fixed-width except that it does not truncate values longer than the width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401c50950c464431455634fa5427d8b16913972d" translate="yes" xml:space="preserve">
          <source>The number of such blocks allocated</source>
          <target state="translated">El número de estos bloques asignados</target>
        </trans-unit>
        <trans-unit id="e8e81fb72f02f0f0604e2587ad1458b114eaf4e4" translate="yes" xml:space="preserve">
          <source>The number of threads Julia starts up with is controlled by an environment variable called &lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt;. Now, let's start up Julia with 4 threads:</source>
          <target state="translated">La cantidad de subprocesos que inicia Julia est&amp;aacute; controlada por una variable de entorno llamada &lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt; . Ahora, comencemos a Julia con 4 hilos:</target>
        </trans-unit>
        <trans-unit id="b54c4650ad40754cdcfd0146457d2a4950f0fa52" translate="yes" xml:space="preserve">
          <source>The number of threads specified with &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; is propagated to worker processes that are spawned using the &lt;code&gt;-p&lt;/code&gt;/&lt;code&gt;--procs&lt;/code&gt; or &lt;code&gt;--machine-file&lt;/code&gt; command line options. For example, &lt;code&gt;julia -p2 -t2&lt;/code&gt; spawns 1 main process with 2 worker processes, and all three processes have 2 threads enabled. For more fine grained control over worker threads use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; and pass &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; as &lt;code&gt;exeflags&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85834b4873990e0b8a9335e254e4dd1dde6aed2" translate="yes" xml:space="preserve">
          <source>The number of times a generated function is generated &lt;em&gt;might&lt;/em&gt; be only once, but it &lt;em&gt;might&lt;/em&gt; also be more often, or appear to not happen at all. As a consequence, you should &lt;em&gt;never&lt;/em&gt; write a generated function with side effects - when, and how often, the side effects occur is undefined. (This is true for macros too - and just like for macros, the use of &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; in a generated function is a sign that you're doing something the wrong way.) However, unlike macros, the runtime system cannot correctly handle a call to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, so it is disallowed.</source>
          <target state="translated">El n&amp;uacute;mero de veces que se genera una funci&amp;oacute;n generada &lt;em&gt;puede&lt;/em&gt; ser solo una vez, pero tambi&amp;eacute;n &lt;em&gt;puede&lt;/em&gt; ser m&amp;aacute;s frecuente o parecer que no ocurre en absoluto. Como consecuencia, &lt;em&gt;nunca&lt;/em&gt; debe escribir una funci&amp;oacute;n generada con efectos secundarios; cu&amp;aacute;ndo y con qu&amp;eacute; frecuencia ocurren los efectos secundarios no est&amp;aacute; definido. (Esto tambi&amp;eacute;n es cierto para las macros, y al igual que para las macros, el uso de &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; en una funci&amp;oacute;n generada es una se&amp;ntilde;al de que est&amp;aacute;s haciendo algo de manera incorrecta). Sin embargo, a diferencia de las macros, el sistema de tiempo de ejecuci&amp;oacute;n no puede manejar correctamente una llamada a &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; , por lo que no est&amp;aacute; permitido.</target>
        </trans-unit>
        <trans-unit id="0ae813381c0022ace29605243aaae816db8d2b62" translate="yes" xml:space="preserve">
          <source>The object has three fields:</source>
          <target state="translated">El objeto tiene tres campos:</target>
        </trans-unit>
        <trans-unit id="f26db4e1766d8278e77cd687e2593b52ae02c589" translate="yes" xml:space="preserve">
          <source>The object has two fields:</source>
          <target state="translated">El objeto tiene dos campos:</target>
        </trans-unit>
        <trans-unit id="4d6829e15fd876880334e8233e7664c2c9a74a93" translate="yes" xml:space="preserve">
          <source>The object iterated over in a &lt;code&gt;@simd for&lt;/code&gt; loop should be a one-dimensional range. By using &lt;code&gt;@simd&lt;/code&gt;, you are asserting several properties of the loop:</source>
          <target state="translated">El objeto iterado en un bucle &lt;code&gt;@simd for&lt;/code&gt; debe ser un rango unidimensional. Al usar &lt;code&gt;@simd&lt;/code&gt; , est&amp;aacute; afirmando varias propiedades del bucle:</target>
        </trans-unit>
        <trans-unit id="ea26212270cffda304c1ae7e1979fbd52cf41822" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;Sampler&lt;/code&gt; is then used to generate the random values. When implementing the random generation interface for a value &lt;code&gt;X&lt;/code&gt; that can be sampled from, the implementor should define the method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a81b0cbf6e9a0a37ccae194bb527cb1e3d2158" translate="yes" xml:space="preserve">
          <source>The objects called do not have matching dimensionality. Optional argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">Los objetos llamados no tienen la misma dimensionalidad. El argumento opcional &lt;code&gt;msg&lt;/code&gt; es una cadena de error descriptiva.</target>
        </trans-unit>
        <trans-unit id="c67a85d00391dfa4e34905a89b16c12f29c02b01" translate="yes" xml:space="preserve">
          <source>The one-line sentence should use the imperative form (&quot;Do this&quot;, &quot;Return that&quot;) instead of the third person (do not write &quot;Returns the length...&quot;) when documenting functions. It should end with a period. If the meaning of a function cannot be summarized easily, splitting it into separate composable parts could be beneficial (this should not be taken as an absolute requirement for every single case though).</source>
          <target state="translated">La frase de una línea debe utilizar la forma imperativa (&quot;Haz esto&quot;,&quot;Devuelve aquello&quot;)en lugar de la tercera persona (no escribas &quot;Devuelve la longitud...&quot;)al documentar funciones.Debe terminar con un punto.Si el significado de una función no puede resumirse fácilmente,podría ser beneficioso dividirla en partes componibles separadas (aunque esto no debe tomarse como un requisito absoluto para cada caso concreto).</target>
        </trans-unit>
        <trans-unit id="b6ddf67182af91ce5f2d607a93387a34e5a2b0e5" translate="yes" xml:space="preserve">
          <source>The only exception to the use of &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use &lt;code&gt;0000-01-03T00:00:00&lt;/code&gt; (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.</source>
          <target state="translated">La &amp;uacute;nica excepci&amp;oacute;n al uso de &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; como &amp;eacute;poca de redondeo es cuando se redondea a semanas. El redondeo a la semana m&amp;aacute;s cercana siempre devolver&amp;aacute; un lunes (el primer d&amp;iacute;a de la semana seg&amp;uacute;n lo especificado por ISO 8601). Por este motivo, utilizamos &lt;code&gt;0000-01-03T00:00:00&lt;/code&gt; (el primer d&amp;iacute;a de la primera semana del a&amp;ntilde;o 0000, seg&amp;uacute;n lo define la norma ISO 8601) como base al redondear a varias semanas.</target>
        </trans-unit>
        <trans-unit id="9363f36d4f2b17a0031fe8893a1c08b698e154a6" translate="yes" xml:space="preserve">
          <source>The only explicitly disallowed names for variables are the names of built-in statements:</source>
          <target state="translated">Los únicos nombres explícitamente rechazados para las variables son los nombres de las declaraciones incorporadas:</target>
        </trans-unit>
        <trans-unit id="b9cae3e1b35cbcfdc4d7bd5b2d0c389c2d667286" translate="yes" xml:space="preserve">
          <source>The only explicitly disallowed names for variables are the names of the built-in &lt;a href=&quot;../../base/base/index#Keywords&quot;&gt;Keywords&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a96430cabd292322cdf6d0ab2a28460461ca0e" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;=&lt;/code&gt; always returns the right-hand side, therefore:</source>
          <target state="translated">El operador &lt;code&gt;=&lt;/code&gt; siempre devuelve el lado derecho, por lo tanto:</target>
        </trans-unit>
        <trans-unit id="61c61a08879a6bdf3c24805cb6233ff2beffb8f1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; are non-associative. &lt;code&gt;a + b + c&lt;/code&gt; is parsed as &lt;code&gt;+(a, b, c)&lt;/code&gt; not &lt;code&gt;+(+(a, b), c)&lt;/code&gt;. However, the fallback methods for &lt;code&gt;+(a, b, c, d...)&lt;/code&gt; and &lt;code&gt;*(a, b, c, d...)&lt;/code&gt; both default to left-associative evaluation.</source>
          <target state="translated">Los operadores &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;*&lt;/code&gt; no son asociativos. &lt;code&gt;a + b + c&lt;/code&gt; se analiza como &lt;code&gt;+(a, b, c)&lt;/code&gt; no &lt;code&gt;+(+(a, b), c)&lt;/code&gt; . Sin embargo, los m&amp;eacute;todos alternativos para &lt;code&gt;+(a, b, c, d...)&lt;/code&gt; y &lt;code&gt;*(a, b, c, d...)&lt;/code&gt; ambos predeterminados para la evaluaci&amp;oacute;n asociativa por la izquierda.</target>
        </trans-unit>
        <trans-unit id="107f84ddc83f3132ac9e7c776c3ad804db96f800" translate="yes" xml:space="preserve">
          <source>The optimal choice of absolute (&lt;code&gt;atol&lt;/code&gt;) and relative tolerance (&lt;code&gt;rtol&lt;/code&gt;) varies both with the value of &lt;code&gt;M&lt;/code&gt; and the intended application of the pseudoinverse. The default relative tolerance is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">La elecci&amp;oacute;n &amp;oacute;ptima de tolerancia absoluta ( &lt;code&gt;atol&lt;/code&gt; ) y relativa ( &lt;code&gt;rtol&lt;/code&gt; ) var&amp;iacute;a tanto con el valor de &lt;code&gt;M&lt;/code&gt; como con la aplicaci&amp;oacute;n prevista del pseudoinverso. La tolerancia relativa predeterminado es &lt;code&gt;n*ϵ&lt;/code&gt; , donde &lt;code&gt;n&lt;/code&gt; es el tama&amp;ntilde;o de la dimensi&amp;oacute;n m&amp;aacute;s peque&amp;ntilde;a de &lt;code&gt;M&lt;/code&gt; , y &lt;code&gt;ϵ&lt;/code&gt; es los &lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; del tipo de elemento de &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2df9f292c890ebf432c888dc85d326e28ff79fa" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;chars&lt;/code&gt; argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</source>
          <target state="translated">El argumento opcional &lt;code&gt;chars&lt;/code&gt; especifica qu&amp;eacute; caracteres eliminar: puede ser un solo car&amp;aacute;cter, un vector o un conjunto de caracteres.</target>
        </trans-unit>
        <trans-unit id="58713c9681927cdb79ff5aaa798bc3500eccfa8e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;chars&lt;/code&gt; argument specifies which characters to remove: it can be a single character, vector or set of characters.</source>
          <target state="translated">El argumento opcional &lt;code&gt;chars&lt;/code&gt; especifica qu&amp;eacute; caracteres eliminar: puede ser un solo car&amp;aacute;cter, vector o conjunto de caracteres.</target>
        </trans-unit>
        <trans-unit id="7d04d2d866b93a37d08384445eed5a33ef5a6c88" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;esc&lt;/code&gt; argument specifies any additional characters that should also be escaped by a prepending backslash (&lt;code&gt;&quot;&lt;/code&gt; is also escaped by default in the first form).</source>
          <target state="translated">El argumento opcional &lt;code&gt;esc&lt;/code&gt; especifica cualquier car&amp;aacute;cter adicional que tambi&amp;eacute;n debe escaparse con una barra invertida al comienzo ( &lt;code&gt;&quot;&lt;/code&gt; tambi&amp;eacute;n se escapa de forma predeterminada en el primer formulario).</target>
        </trans-unit>
        <trans-unit id="194efabb3b5dd2732e2e6600190698fedd3b0069" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;procs&lt;/code&gt; allows specifying a subset of all processes to have execute the expression.</source>
          <target state="translated">El argumento opcional &lt;code&gt;procs&lt;/code&gt; permite especificar un subconjunto de todos los procesos para ejecutar la expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="880714bb7ddfa7f3f83801253a212b4edc50e2e9" translate="yes" xml:space="preserve">
          <source>The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.</source>
          <target state="translated">La cadena de declaraciones opcionales contiene declaraciones de funciones externas que son necesarias para que llvm pueda compilar la cadena IR.Se pueden pasar varias declaraciones separándolas con saltos de línea.</target>
        </trans-unit>
        <trans-unit id="93222f7e28d28cf59587027443a25e2c729448bc" translate="yes" xml:space="preserve">
          <source>The optional first argument &lt;code&gt;mapexpr&lt;/code&gt; can be used to transform the included code before it is evaluated: for each parsed expression &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;code&lt;/code&gt;, the &lt;code&gt;include_string&lt;/code&gt; function actually evaluates &lt;code&gt;mapexpr(expr)&lt;/code&gt;. If it is omitted, &lt;code&gt;mapexpr&lt;/code&gt; defaults to &lt;a href=&quot;#Base.identity&quot;&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03b28806b3d651a4fd6d7abdbe690fb63800e14" translate="yes" xml:space="preserve">
          <source>The optional first argument &lt;code&gt;mapexpr&lt;/code&gt; can be used to transform the included code before it is evaluated: for each parsed expression &lt;code&gt;expr&lt;/code&gt; in &lt;code&gt;path&lt;/code&gt;, the &lt;code&gt;include&lt;/code&gt; function actually evaluates &lt;code&gt;mapexpr(expr)&lt;/code&gt;. If it is omitted, &lt;code&gt;mapexpr&lt;/code&gt; defaults to &lt;a href=&quot;#Base.identity&quot;&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d319e50b1de0ad66b05495c666753f05c93c4fb2" translate="yes" xml:space="preserve">
          <source>The optional flags argument is a bitwise-or of zero or more of &lt;code&gt;RTLD_LOCAL&lt;/code&gt;, &lt;code&gt;RTLD_GLOBAL&lt;/code&gt;, &lt;code&gt;RTLD_LAZY&lt;/code&gt;, &lt;code&gt;RTLD_NOW&lt;/code&gt;, &lt;code&gt;RTLD_NODELETE&lt;/code&gt;, &lt;code&gt;RTLD_NOLOAD&lt;/code&gt;, &lt;code&gt;RTLD_DEEPBIND&lt;/code&gt;, and &lt;code&gt;RTLD_FIRST&lt;/code&gt;. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default &lt;code&gt;dlopen&lt;/code&gt; flags are &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; while on other platforms the defaults are &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL&lt;/code&gt;. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.</source>
          <target state="translated">El argumento de banderas opcionales es un bit a bit o de cero o m&amp;aacute;s de &lt;code&gt;RTLD_LOCAL&lt;/code&gt; , &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; , &lt;code&gt;RTLD_LAZY&lt;/code&gt; , &lt;code&gt;RTLD_NOW&lt;/code&gt; , &lt;code&gt;RTLD_NODELETE&lt;/code&gt; , &lt;code&gt;RTLD_NOLOAD&lt;/code&gt; , &lt;code&gt;RTLD_DEEPBIND&lt;/code&gt; y &lt;code&gt;RTLD_FIRST&lt;/code&gt; . Estos se convierten a los indicadores correspondientes del comando dlopen POSIX (y / o GNU libc y / o MacOS), si es posible, o se ignoran si la funcionalidad especificada no est&amp;aacute; disponible en la plataforma actual. Las banderas predeterminadas son espec&amp;iacute;ficas de la plataforma. En MacOS, los &lt;code&gt;dlopen&lt;/code&gt; predeterminados de dlopen son &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; mientras que en otras plataformas los valores predeterminados son &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL&lt;/code&gt; . Un uso importante de estos indicadores es especificar un comportamiento no predeterminado para cuando el cargador din&amp;aacute;mico de bibliotecas vincula las referencias de la biblioteca a los s&amp;iacute;mbolos exportados y si las referencias vinculadas se colocan en un proceso de alcance local o global. Por ejemplo, &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; permite que los s&amp;iacute;mbolos de la biblioteca est&amp;eacute;n disponibles para su uso en otras bibliotecas compartidas, abordando situaciones en las que existen dependencias entre bibliotecas compartidas.</target>
        </trans-unit>
        <trans-unit id="6852910866895c99e590be9b40672a6aa6893cd3" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;f&lt;/code&gt;. The optional &lt;code&gt;sizehint&lt;/code&gt; is a suggested size (in bytes) to allocate for the buffer used to write the string.</source>
          <target state="translated">El &lt;code&gt;context&lt;/code&gt; o de argumento de palabra clave opcional se puede establecer en &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; par de valor o un objeto &lt;code&gt;IO&lt;/code&gt; o &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; cuyos atributos se utilizan para el flujo de E / S pasado a &lt;code&gt;f&lt;/code&gt; . El opcional &lt;code&gt;sizehint&lt;/code&gt; es un tama&amp;ntilde;o sugerido (en bytes) asignar a la memoria intermedia se utiliza para escribir la cadena.</target>
        </trans-unit>
        <trans-unit id="dcac34ba486f2b65b96a033b6cb20a0748bc3d60" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;context&lt;/code&gt; o de argumento de palabra clave opcional se puede establecer en &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; par de valor o un objeto &lt;code&gt;IO&lt;/code&gt; o &lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; cuyos atributos se utilizan para &lt;code&gt;show&lt;/code&gt; flujo de E / S pasado .</target>
        </trans-unit>
        <trans-unit id="f5605ad644c7f46c7d640d10514c1e111f9c1381" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;context&lt;/code&gt; o de argumento de palabra clave opcional se puede establecer en &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; par de valor o un objeto &lt;code&gt;IO&lt;/code&gt; o &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; cuyos atributos se utilizan para &lt;code&gt;show&lt;/code&gt; flujo de E / S pasado .</target>
        </trans-unit>
        <trans-unit id="b019c5488e0a6b54b72c3dc4970022b5261bd3cf" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;writefunc&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;context&lt;/code&gt; o de argumento de palabra clave opcional se puede establecer en &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; par o un objeto &lt;code&gt;IO&lt;/code&gt; o &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; cuyos atributos se utilizan para el flujo de E / S pasado a &lt;code&gt;writefunc&lt;/code&gt; o &lt;code&gt;write&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79723906c1f968e609f55475d1035da056cea38f" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;context&lt;/code&gt; o de argumento de palabra clave opcional se puede establecer en un objeto &lt;code&gt;IO&lt;/code&gt; o &lt;a href=&quot;../io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; cuyos atributos se utilizan para que se &lt;code&gt;show&lt;/code&gt; flujo de E / S pasado .</target>
        </trans-unit>
        <trans-unit id="1d024d8ad27a045cd403adcafbb8a97939e2259d" translate="yes" xml:space="preserve">
          <source>The optional keyword arguments are:</source>
          <target state="translated">Los argumentos de las palabras clave opcionales son:</target>
        </trans-unit>
        <trans-unit id="7277b33c208d262f473b8b03d8c039301737232a" translate="yes" xml:space="preserve">
          <source>The optional list of &lt;code&gt;key=value&lt;/code&gt; pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record. If only a &lt;code&gt;value&lt;/code&gt; expression is supplied, a key representing the expression will be generated using &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;x=x&lt;/code&gt;, and &lt;code&gt;foo(10)&lt;/code&gt; becomes &lt;code&gt;Symbol(&quot;foo(10)&quot;)=foo(10)&lt;/code&gt;. For splatting a list of key value pairs, use the normal splatting syntax, &lt;code&gt;@info &quot;blah&quot; kws...&lt;/code&gt;.</source>
          <target state="translated">La lista opcional de pares &lt;code&gt;key=value&lt;/code&gt; admite metadatos arbitrarios definidos por el usuario que se pasar&amp;aacute;n al backend de registro como parte del registro de registro. Si s&amp;oacute;lo una &lt;code&gt;value&lt;/code&gt; se suministra expresi&amp;oacute;n, una clave que representa la expresi&amp;oacute;n se genera utilizando &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; . Por ejemplo, &lt;code&gt;x&lt;/code&gt; se convierte en &lt;code&gt;x=x&lt;/code&gt; , y &lt;code&gt;foo(10)&lt;/code&gt; convierte en &lt;code&gt;Symbol(&quot;foo(10)&quot;)=foo(10)&lt;/code&gt; . Para splatting una lista de pares de valores clave, utilice la sintaxis splatting normal, &lt;code&gt;@info &quot;blah&quot; kws...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01ff66cb9afdd1acbcec4725d95eb63b3a880ae3" translate="yes" xml:space="preserve">
          <source>The optional second argument restricts the search to a particular module or function (the default is all top-level modules).</source>
          <target state="translated">El segundo argumento opcional restringe la búsqueda a un módulo o función en particular (por defecto son todos los módulos de nivel superior).</target>
        </trans-unit>
        <trans-unit id="d7be768e27f40f1d8f5725cc3b53d8120d8d7888" translate="yes" xml:space="preserve">
          <source>The order of the output here is non-deterministic because the two &lt;code&gt;echo&lt;/code&gt; processes are started nearly simultaneously, and race to make the first write to the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; descriptor they share with each other and the &lt;code&gt;julia&lt;/code&gt; parent process. Julia lets you pipe the output from both of these processes to another program:</source>
          <target state="translated">El orden de la salida aqu&amp;iacute; no es determinista porque los dos procesos de &lt;code&gt;echo&lt;/code&gt; se inician casi simult&amp;aacute;neamente y compiten para hacer la primera escritura en el descriptor de salida &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; que comparten entre s&amp;iacute; y en el proceso padre de &lt;code&gt;julia&lt;/code&gt; . Julia le permite canalizar la salida de ambos procesos a otro programa:</target>
        </trans-unit>
        <trans-unit id="7e6b1ba87ceb124ce09bfd4687b3d3e543a9688a" translate="yes" xml:space="preserve">
          <source>The ordinary way to index into an &lt;code&gt;N&lt;/code&gt;-dimensional array is to use exactly &lt;code&gt;N&lt;/code&gt; indices; each index selects the position(s) in its particular dimension. For example, in the three-dimensional array &lt;code&gt;A = rand(4, 3, 2)&lt;/code&gt;, &lt;code&gt;A[2, 3, 1]&lt;/code&gt; will select the number in the second row of the third column in the first &quot;page&quot; of the array. This is often referred to as &lt;em&gt;cartesian indexing&lt;/em&gt;.</source>
          <target state="translated">La forma habitual de indexar en una matriz &lt;code&gt;N&lt;/code&gt; - dimensional es utilizar exactamente &lt;code&gt;N&lt;/code&gt; &amp;iacute;ndices; cada &amp;iacute;ndice selecciona la (s) posici&amp;oacute;n (es) en su dimensi&amp;oacute;n particular. Por ejemplo, en la matriz tridimensional &lt;code&gt;A = rand(4, 3, 2)&lt;/code&gt; , &lt;code&gt;A[2, 3, 1]&lt;/code&gt; seleccionar&amp;aacute; el n&amp;uacute;mero en la segunda fila de la tercera columna en la primera &quot;p&amp;aacute;gina&quot; de la matriz. Esto a menudo se denomina &lt;em&gt;indexaci&amp;oacute;n cartesiana&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="337d87d83fb3b26581b3bec9243dd5ba69ee3d14" translate="yes" xml:space="preserve">
          <source>The overflow protection may impose a perceptible performance penalty.</source>
          <target state="translated">La protección contra el desbordamiento puede imponer una penalización de rendimiento perceptible.</target>
        </trans-unit>
        <trans-unit id="9a42e1576587fc87b690dd06577854cd76250509" translate="yes" xml:space="preserve">
          <source>The parameters of a &lt;a href=&quot;../types/index#Parametric-Types&quot;&gt;parametric type&lt;/a&gt; can hold either types or bits values, and the type itself chooses how it makes use of these parameters. For example, &lt;code&gt;Array{Float64, 2}&lt;/code&gt; is parameterized by the type &lt;code&gt;Float64&lt;/code&gt; to express its element type and the integer value &lt;code&gt;2&lt;/code&gt; to express its number of dimensions. When defining your own parametric type, you can use subtype constraints to declare that a certain parameter must be a subtype (&lt;code&gt;&amp;lt;:&lt;/code&gt;) of some abstract type or a previous type parameter. There is not, however, a dedicated syntax to declare that a parameter must be a &lt;em&gt;value&lt;/em&gt; of a given type &amp;mdash; that is, you cannot directly declare that a dimensionality-like parameter &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Int&lt;/code&gt; within the &lt;code&gt;struct&lt;/code&gt; definition, for example. Similarly, you cannot do computations (including simple things like addition or subtraction) on type parameters. Instead, these sorts of constraints and relationships may be expressed through additional type parameters that are computed and enforced within the type's &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;constructors&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d86a00557c452d14c3435e0e6cf89aff65b0c2" translate="yes" xml:space="preserve">
          <source>The parameters to a function call do not match a valid signature. Argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">Los par&amp;aacute;metros de una llamada de funci&amp;oacute;n no coinciden con una firma v&amp;aacute;lida. El &lt;code&gt;msg&lt;/code&gt; argumento es una cadena de error descriptiva.</target>
        </trans-unit>
        <trans-unit id="b40e124fc4416cc6b2725b908dd2c2071926bcac" translate="yes" xml:space="preserve">
          <source>The parser yields &lt;code&gt;QuoteNode&lt;/code&gt;s for simple quoted items like symbols:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd165da81710969d9eacb18af008ac2650e61e9" translate="yes" xml:space="preserve">
          <source>The path to the file containing the execution context.</source>
          <target state="translated">La ruta del archivo que contiene el contexto de ejecución.</target>
        </trans-unit>
        <trans-unit id="cd91887e0e75258a20a4164a826e358b38427c66" translate="yes" xml:space="preserve">
          <source>The paths map assigns to each package UUID-name pair, the location of that package's entry-point source file. After the identity of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; has been resolved to a UUID via roots or graph (depending on whether it is loaded from the main project or a dependency), Julia determines what file to load to acquire &lt;code&gt;X&lt;/code&gt; by looking up &lt;code&gt;paths[uuid,:X]&lt;/code&gt; in the environment. Including this file should define a module named &lt;code&gt;X&lt;/code&gt;. Once this package is loaded, any subsequent import resolving to the same &lt;code&gt;uuid&lt;/code&gt; will create a new binding to the already-loaded package module.</source>
          <target state="translated">El mapa de rutas asigna a cada par de nombre UUID de paquete, la ubicaci&amp;oacute;n del archivo de origen del punto de entrada de ese paquete. Despu&amp;eacute;s de que la identidad de &lt;code&gt;X&lt;/code&gt; en la &lt;code&gt;import X&lt;/code&gt; se haya resuelto a un UUID a trav&amp;eacute;s de ra&amp;iacute;ces o gr&amp;aacute;fico (dependiendo de si se carga desde el proyecto principal o una dependencia), Julia determina qu&amp;eacute; archivo cargar para adquirir &lt;code&gt;X&lt;/code&gt; buscando &lt;code&gt;paths[uuid,:X]&lt;/code&gt; en el medio ambiente. La inclusi&amp;oacute;n de este archivo debe definir un m&amp;oacute;dulo denominado &lt;code&gt;X&lt;/code&gt; . Una vez que se carga este paquete, cualquier importaci&amp;oacute;n posterior que se resuelva en el mismo &lt;code&gt;uuid&lt;/code&gt; crear&amp;aacute; un nuevo enlace al m&amp;oacute;dulo del paquete ya cargado.</target>
        </trans-unit>
        <trans-unit id="b2b8c82c38ec794200c611dc44cc4f20a1bd32a9" translate="yes" xml:space="preserve">
          <source>The pipe operator can also be used with broadcasting, as &lt;code&gt;.|&amp;gt;&lt;/code&gt;, to provide a useful combination of the chaining/piping and dot vectorization syntax (described next).</source>
          <target state="translated">El operador de tuber&amp;iacute;a tambi&amp;eacute;n se puede usar con la transmisi&amp;oacute;n, como &lt;code&gt;.|&amp;gt;&lt;/code&gt; , Para proporcionar una combinaci&amp;oacute;n &amp;uacute;til de la sintaxis de encadenamiento / tuber&amp;iacute;a y vectorizaci&amp;oacute;n de puntos (que se describe a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="597af63e387a0238ac0d63febd38bda10ccc2c0b" translate="yes" xml:space="preserve">
          <source>The power of the &lt;code&gt;try/catch&lt;/code&gt; construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions. There are situations where no error has occurred, but the ability to unwind the stack and pass a value to a higher level is desirable. Julia provides the &lt;a href=&quot;../../base/base/index#Base.rethrow&quot;&gt;&lt;code&gt;rethrow&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt;&lt;code&gt;Base.catch_stack&lt;/code&gt;&lt;/a&gt; functions for more advanced error handling.</source>
          <target state="translated">El poder de la construcci&amp;oacute;n &lt;code&gt;try/catch&lt;/code&gt; radica en la capacidad de desenrollar un c&amp;aacute;lculo profundamente anidado inmediatamente a un nivel mucho m&amp;aacute;s alto en la pila de funciones de llamada. Hay situaciones en las que no se ha producido ning&amp;uacute;n error, pero es deseable la capacidad de desenrollar la pila y pasar un valor a un nivel superior. Julia proporciona al &lt;a href=&quot;../../base/base/index#Base.rethrow&quot;&gt; &lt;code&gt;rethrow&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt; &lt;code&gt;Base.catch_stack&lt;/code&gt; &lt;/a&gt; funciones para el manejo de errores m&amp;aacute;s avanzado.</target>
        </trans-unit>
        <trans-unit id="8f828dfaf86a71af5078c4fd81a7efaae2debb74" translate="yes" xml:space="preserve">
          <source>The power of the &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions.</source>
          <target state="translated">El poder de la construcci&amp;oacute;n &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; radica en la capacidad de desenrollar un c&amp;aacute;lculo profundamente anidado inmediatamente a un nivel mucho m&amp;aacute;s alto en la pila de funciones de llamada.</target>
        </trans-unit>
        <trans-unit id="8c0dcb26b25cdb065ec42a8e6b69fc74bd648292" translate="yes" xml:space="preserve">
          <source>The precedence of numeric literal coefficients is slightly lower than that of unary operators such as negation. So &lt;code&gt;-2x&lt;/code&gt; is parsed as &lt;code&gt;(-2) * x&lt;/code&gt; and &lt;code&gt;&amp;radic;2x&lt;/code&gt; is parsed as &lt;code&gt;(&amp;radic;2) * x&lt;/code&gt;. However, numeric literal coefficients parse similarly to unary operators when combined with exponentiation. For example &lt;code&gt;2^3x&lt;/code&gt; is parsed as &lt;code&gt;2^(3x)&lt;/code&gt;, and &lt;code&gt;2x^3&lt;/code&gt; is parsed as &lt;code&gt;2*(x^3)&lt;/code&gt;.</source>
          <target state="translated">La precedencia de los coeficientes literales num&amp;eacute;ricos es ligeramente menor que la de los operadores unarios como la negaci&amp;oacute;n. Entonces, &lt;code&gt;-2x&lt;/code&gt; se analiza como &lt;code&gt;(-2) * x&lt;/code&gt; y &lt;code&gt;&amp;radic;2x&lt;/code&gt; se analiza como &lt;code&gt;(&amp;radic;2) * x&lt;/code&gt; . Sin embargo, los coeficientes literales num&amp;eacute;ricos se analizan de manera similar a los operadores unarios cuando se combinan con exponenciaci&amp;oacute;n. Por ejemplo, &lt;code&gt;2^3x&lt;/code&gt; se analiza como &lt;code&gt;2^(3x)&lt;/code&gt; y &lt;code&gt;2x^3&lt;/code&gt; se analiza como &lt;code&gt;2*(x^3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8950edc0252b4e5921bc89b4f858ec39c03063d6" translate="yes" xml:space="preserve">
          <source>The precedence of numeric literal coefficients used for implicit multiplication is higher than other binary operators such as multiplication (&lt;code&gt;*&lt;/code&gt;), and division (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;//&lt;/code&gt;). This means, for example, that &lt;code&gt;1 / 2im&lt;/code&gt; equals &lt;code&gt;-0.5im&lt;/code&gt; and &lt;code&gt;6 // 2(2 + 1)&lt;/code&gt; equals &lt;code&gt;1 // 1&lt;/code&gt;.</source>
          <target state="translated">La precedencia de los coeficientes literales num&amp;eacute;ricos utilizados para la multiplicaci&amp;oacute;n impl&amp;iacute;cita es mayor que la de otros operadores binarios como la multiplicaci&amp;oacute;n ( &lt;code&gt;*&lt;/code&gt; ) y la divisi&amp;oacute;n ( &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;\&lt;/code&gt; y &lt;code&gt;//&lt;/code&gt; ). Esto significa, por ejemplo, que &lt;code&gt;1 / 2im&lt;/code&gt; es igual a &lt;code&gt;-0.5im&lt;/code&gt; y &lt;code&gt;6 // 2(2 + 1)&lt;/code&gt; es igual a &lt;code&gt;1 // 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6252a13083e6a8d33233a629a05884040274a8ff" translate="yes" xml:space="preserve">
          <source>The precedence rules are defined by binary &lt;code&gt;BroadcastStyle&lt;/code&gt; calls:</source>
          <target state="translated">Las reglas de precedencia se definen mediante llamadas binarias &lt;code&gt;BroadcastStyle&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56837dd60f637c33dd3845553e8ea84690fc189a" translate="yes" xml:space="preserve">
          <source>The preferred style is to use instances by default, and only add methods involving &lt;code&gt;Type{MyType}&lt;/code&gt; later if they become necessary to solve some problem.</source>
          <target state="translated">El estilo preferido es usar instancias por defecto, y solo agregar m&amp;eacute;todos que involucren &lt;code&gt;Type{MyType}&lt;/code&gt; m&amp;aacute;s adelante si son necesarios para resolver alg&amp;uacute;n problema.</target>
        </trans-unit>
        <trans-unit id="279b514949e6ab10ca4a0b3d36a0afc9aa5e5bfd" translate="yes" xml:space="preserve">
          <source>The prefix operator &lt;code&gt;∛&lt;/code&gt; is equivalent to &lt;code&gt;cbrt&lt;/code&gt;.</source>
          <target state="translated">El operador de prefijo &lt;code&gt;∛&lt;/code&gt; es equivalente a &lt;code&gt;cbrt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93ebef4458176844838b02e2b993df5f493f0829" translate="yes" xml:space="preserve">
          <source>The primary function used to obtain a stack trace is &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">La funci&amp;oacute;n primaria utilizada para obtener un seguimiento de la pila es &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e24543b8a6898ccaa9bbcf1e800fb858e73daf75" translate="yes" xml:space="preserve">
          <source>The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, which applies a function to each value of an array and returns a new array containing the resulting values:</source>
          <target state="translated">El uso principal de las funciones an&amp;oacute;nimas es pasarlas a funciones que toman otras funciones como argumentos. Un ejemplo cl&amp;aacute;sico es &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; , que aplica una funci&amp;oacute;n a cada valor de una matriz y devuelve una nueva matriz que contiene los valores resultantes:</target>
        </trans-unit>
        <trans-unit id="fc2c54892fd31e8ed27deff8fd6635a872466a56" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;Priv&lt;/code&gt; depends on the &lt;code&gt;Pub&lt;/code&gt; and &lt;code&gt;Zebra&lt;/code&gt; packages.</source>
          <target state="translated">El &lt;code&gt;Priv&lt;/code&gt; privado depende de los paquetes &lt;code&gt;Pub&lt;/code&gt; y &lt;code&gt;Zebra&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f74ae0037646d4d3ed052aa7f6f3acf520af197" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;Priv&lt;/code&gt; package is &quot;&lt;a href=&quot;https://stackoverflow.com/a/35109534&quot;&gt;vendored&lt;/a&gt;&quot; inside the &lt;code&gt;App&lt;/code&gt; repository.</source>
          <target state="translated">El paquete &lt;code&gt;Priv&lt;/code&gt; privado se &quot; &lt;a href=&quot;https://stackoverflow.com/a/35109534&quot;&gt;vende&lt;/a&gt; &quot; dentro del repositorio de &lt;code&gt;App&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="661f073fc5da6760e6d7e4ab5f75f9c8ff27e153" translate="yes" xml:space="preserve">
          <source>The problem is that now any other module that uses &lt;code&gt;Base.*&lt;/code&gt; will also see this definition. Since &lt;code&gt;Symbol&lt;/code&gt; is defined in Base and is used by other modules, this can change the behavior of unrelated code unexpectedly. There are several alternatives here, including using a different function name, or wrapping the &lt;code&gt;Symbol&lt;/code&gt;s in another type that you define.</source>
          <target state="translated">El problema es que ahora cualquier otro m&amp;oacute;dulo que use &lt;code&gt;Base.*&lt;/code&gt; Tambi&amp;eacute;n ver&amp;aacute; esta definici&amp;oacute;n. Dado que &lt;code&gt;Symbol&lt;/code&gt; se define en Base y es utilizado por otros m&amp;oacute;dulos, esto puede cambiar el comportamiento de c&amp;oacute;digo no relacionado inesperadamente. Hay varias alternativas aqu&amp;iacute;, incluido el uso de un nombre de funci&amp;oacute;n diferente o envolver los &lt;code&gt;Symbol&lt;/code&gt; en otro tipo que defina.</target>
        </trans-unit>
        <trans-unit id="285d72365829e919fd96051079cd8653575f8845" translate="yes" xml:space="preserve">
          <source>The problem is that users of this type can write &lt;code&gt;x[i]&lt;/code&gt; without realizing that the operation is unsafe, and then be susceptible to memory bugs.</source>
          <target state="translated">El problema es que los usuarios de este tipo pueden escribir &lt;code&gt;x[i]&lt;/code&gt; sin darse cuenta de que la operaci&amp;oacute;n no es segura, y luego ser susceptibles a errores de memoria.</target>
        </trans-unit>
        <trans-unit id="645c5293b137aedcba8417381b97d9b765e077f5" translate="yes" xml:space="preserve">
          <source>The problem is that we want &lt;code&gt;S&lt;/code&gt; to be a larger type than &lt;code&gt;T&lt;/code&gt;, so that we can sum many elements with less information loss. For example, when &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, we would like &lt;code&gt;S&lt;/code&gt; to be &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. Therefore we want to avoid an interface that allows the user to construct instances of the type &lt;code&gt;SummedArray{Int32,Int32}&lt;/code&gt;. One way to do this is to provide a constructor only for &lt;code&gt;SummedArray&lt;/code&gt;, but inside the &lt;code&gt;struct&lt;/code&gt; definition block to suppress generation of default constructors:</source>
          <target state="translated">El problema es que queremos que &lt;code&gt;S&lt;/code&gt; sea ​​un tipo m&amp;aacute;s grande que &lt;code&gt;T&lt;/code&gt; , de modo que podamos sumar muchos elementos con menos p&amp;eacute;rdida de informaci&amp;oacute;n. Por ejemplo, cuando &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; , nos gustar&amp;iacute;a que &lt;code&gt;S&lt;/code&gt; fuera &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; . Por lo tanto, queremos evitar una interfaz que permita al usuario construir instancias del tipo &lt;code&gt;SummedArray{Int32,Int32}&lt;/code&gt; . Una forma de hacer esto es proporcionar un constructor solo para &lt;code&gt;SummedArray&lt;/code&gt; , pero dentro del bloque de definici&amp;oacute;n de &lt;code&gt;struct&lt;/code&gt; para suprimir la generaci&amp;oacute;n de constructores predeterminados:</target>
        </trans-unit>
        <trans-unit id="fa9c416e3dd0eb96ee39260398af255d4af83ab0" translate="yes" xml:space="preserve">
          <source>The process id, &lt;code&gt;pid&lt;/code&gt;, associated with a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; identifies the process where the backing store, i.e., the backing &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; exists.</source>
          <target state="translated">El ID de proceso, &lt;code&gt;pid&lt;/code&gt; , asociado con un &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; identifica el proceso en el que existe la tienda de respaldo, es decir, el &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; respaldo .</target>
        </trans-unit>
        <trans-unit id="e5711338a1a6b237dd10b96c18908bc64ecaf369" translate="yes" xml:space="preserve">
          <source>The process was stopped by a terminal interrupt (CTRL+C).</source>
          <target state="translated">El proceso fue detenido por una interrupción terminal (CTRL+C).</target>
        </trans-unit>
        <trans-unit id="333bddf0932a24c46f8668b521deb6c3a862550f" translate="yes" xml:space="preserve">
          <source>The program name and the individual arguments in a command can be accessed and iterated over as if the command were an array of strings:</source>
          <target state="translated">Se puede acceder al nombre del programa y a los argumentos individuales de un comando y se puede iterar sobre ellos como si el comando fuera un conjunto de cuerdas:</target>
        </trans-unit>
        <trans-unit id="50007e3abed58b9e198eabc930fa126c0f7f28e5" translate="yes" xml:space="preserve">
          <source>The promotion mechanism ensures that combinations of operands of different types just work:</source>
          <target state="translated">El mecanismo de promoción asegura que las combinaciones de operandos de diferentes tipos sólo funcionen:</target>
        </trans-unit>
        <trans-unit id="970007866f1b490fa6101a3c913eb7623d70c629" translate="yes" xml:space="preserve">
          <source>The protection mode of the file</source>
          <target state="translated">El modo de protección del archivo</target>
        </trans-unit>
        <trans-unit id="717c22bfef5d2282d64a55d9c60b43bea19c9cf1" translate="yes" xml:space="preserve">
          <source>The public &lt;code&gt;Priv&lt;/code&gt; and &lt;code&gt;Zebra&lt;/code&gt; packages are in the system depot, where packages installed and managed by the system administrator live. These are available to all users on the system.</source>
          <target state="translated">Los paquetes p&amp;uacute;blicos de &lt;code&gt;Priv&lt;/code&gt; y &lt;code&gt;Zebra&lt;/code&gt; est&amp;aacute;n en el dep&amp;oacute;sito del sistema, donde residen los paquetes instalados y administrados por el administrador del sistema. Est&amp;aacute;n disponibles para todos los usuarios del sistema.</target>
        </trans-unit>
        <trans-unit id="1a1630b90939dc1ab04b673570b84792ee8ae787" translate="yes" xml:space="preserve">
          <source>The public &lt;code&gt;Priv&lt;/code&gt; has no dependencies.</source>
          <target state="translated">El &lt;code&gt;Priv&lt;/code&gt; p&amp;uacute;blico no tiene dependencias.</target>
        </trans-unit>
        <trans-unit id="3a76e9ce5367492b5b8cf13bb66130558721cade" translate="yes" xml:space="preserve">
          <source>The quotient and remainder from Euclidean division. Equivalent to &lt;code&gt;(div(x,y), rem(x,y))&lt;/code&gt; or &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt;.</source>
          <target state="translated">El cociente y el resto de la divisi&amp;oacute;n euclidiana. Equivalente a &lt;code&gt;(div(x,y), rem(x,y))&lt;/code&gt; o &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f9488bd5101beaf4e5a34c2556e267d19b64d59" translate="yes" xml:space="preserve">
          <source>The quotient and remainder from Euclidean division. Equivalent to &lt;code&gt;(div(x,y,r), rem(x,y,r))&lt;/code&gt;. Equivalently, with the default value of &lt;code&gt;r&lt;/code&gt;, this call is equivalent to &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c852eff7359c80d607981a449403f86f7a08aae5" translate="yes" xml:space="preserve">
          <source>The quotient from Euclidean division. Computes &lt;code&gt;x/y&lt;/code&gt;, truncated to an integer.</source>
          <target state="translated">El cociente de la divisi&amp;oacute;n euclidiana. Calcula &lt;code&gt;x/y&lt;/code&gt; , truncado a un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="b4ff83a45750ab4a00521d3b0c9044c246c68431" translate="yes" xml:space="preserve">
          <source>The rationale for this behavior is that &lt;code&gt;eps&lt;/code&gt; bounds the floating point rounding error. Under the default &lt;code&gt;RoundNearest&lt;/code&gt; rounding mode, if $y$ is a real number and $x$ is the nearest floating point number to $y$, then</source>
          <target state="translated">El fundamento de este comportamiento es que &lt;code&gt;eps&lt;/code&gt; limita el error de redondeo de punto flotante. En el modo de redondeo predeterminado &lt;code&gt;RoundNearest&lt;/code&gt; , si $ y $ es un n&amp;uacute;mero real y $ x $ es el n&amp;uacute;mero de punto flotante m&amp;aacute;s cercano a $ y $, entonces</target>
        </trans-unit>
        <trans-unit id="fb9190d6f027ae9e2de06d7e334ba64d5fd44e85" translate="yes" xml:space="preserve">
          <source>The reason this is important enough to have been given separate syntax is that you don't want to accidentally extend a function that you didn't know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use &lt;code&gt;import&lt;/code&gt;, then you'll replace the other module's implementation of &lt;code&gt;bar(s::AbstractString)&lt;/code&gt; with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar).</source>
          <target state="translated">La raz&amp;oacute;n por la que esto es lo suficientemente importante como para que se le haya dado una sintaxis separada es que no desea extender accidentalmente una funci&amp;oacute;n que no sab&amp;iacute;a que exist&amp;iacute;a, porque eso f&amp;aacute;cilmente podr&amp;iacute;a causar un error. Es m&amp;aacute;s probable que esto suceda con un m&amp;eacute;todo que toma un tipo com&amp;uacute;n como una cadena o un entero, porque tanto usted como el otro m&amp;oacute;dulo podr&amp;iacute;an definir un m&amp;eacute;todo para manejar un tipo tan com&amp;uacute;n. Si usa la &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n , reemplazar&amp;aacute; la implementaci&amp;oacute;n de &lt;code&gt;bar(s::AbstractString)&lt;/code&gt; del otro m&amp;oacute;dulo (s :: AbstractString) con su nueva implementaci&amp;oacute;n, que f&amp;aacute;cilmente podr&amp;iacute;a hacer algo completamente diferente (y romper todos / muchos usos futuros de las otras funciones en el m&amp;oacute;dulo Foo que depende de la barra de llamadas).</target>
        </trans-unit>
        <trans-unit id="234a82c9299a864e20ceee7dc728fbbfc62b4ff9" translate="yes" xml:space="preserve">
          <source>The reason to allow modifying local variables of parent scopes in nested functions is to allow constructing &lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_%28computer_programming%29&quot;&gt;&lt;code&gt;closures&lt;/code&gt;&lt;/a&gt; which have private state, for instance the &lt;code&gt;state&lt;/code&gt; variable in the following example:</source>
          <target state="translated">La raz&amp;oacute;n para permitir la modificaci&amp;oacute;n de variables locales de &amp;aacute;mbitos padre en funciones anidadas es permitir la construcci&amp;oacute;n de &lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_%28computer_programming%29&quot;&gt; &lt;code&gt;closures&lt;/code&gt; &lt;/a&gt; que tienen un estado privado, por ejemplo, la variable de &lt;code&gt;state&lt;/code&gt; en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="d42e24ea3d0e2aa6d81b7dd3b153611807fc05f4" translate="yes" xml:space="preserve">
          <source>The reasoning is that &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; must be &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, regardless of the value of &lt;code&gt;b&lt;/code&gt;, and likewise, the value of &lt;code&gt;a || b&lt;/code&gt; must be true if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, regardless of the value of &lt;code&gt;b&lt;/code&gt;. Both &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; associate to the right, but &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; has higher precedence than &lt;code&gt;||&lt;/code&gt; does. It's easy to experiment with this behavior:</source>
          <target state="translated">El razonamiento es que &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; debe ser &lt;code&gt;false&lt;/code&gt; si &lt;code&gt;a&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , independientemente del valor de &lt;code&gt;b&lt;/code&gt; , e igualmente, el valor de &lt;code&gt;a || b&lt;/code&gt; debe ser verdadero si &lt;code&gt;a&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , independientemente del valor de &lt;code&gt;b&lt;/code&gt; . Ambos &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; asociar a la derecha, pero &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; tiene mayor precedencia que &lt;code&gt;||&lt;/code&gt; hace. Es f&amp;aacute;cil experimentar con este comportamiento:</target>
        </trans-unit>
        <trans-unit id="95dede2db6b492fc138679b4d2d27fe223e4ffc1" translate="yes" xml:space="preserve">
          <source>The recommended use case is sampling from values with precomputed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b91e5f0c03fa313fd5905d982928a4cd89df69e" translate="yes" xml:space="preserve">
          <source>The recommended use case is sampling from values without precomputed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179e487486d1af4b87de97016bef8d4656b4ec67" translate="yes" xml:space="preserve">
          <source>The recommended ways to iterate over a whole array are</source>
          <target state="translated">Las formas recomendadas para iterar sobre todo un conjunto son</target>
        </trans-unit>
        <trans-unit id="d82c055defbd84ff03cc2e56fef7d08819740213" translate="yes" xml:space="preserve">
          <source>The reduction of &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;y&lt;/code&gt;, or equivalently, the remainder of &lt;code&gt;x&lt;/code&gt; after floored division by &lt;code&gt;y&lt;/code&gt;, i.e. &lt;code&gt;x - y*fld(x,y)&lt;/code&gt; if computed without intermediate rounding.</source>
          <target state="translated">La reducci&amp;oacute;n de &lt;code&gt;x&lt;/code&gt; m&amp;oacute;dulo &lt;code&gt;y&lt;/code&gt; , o equivalentemente, el resto de &lt;code&gt;x&lt;/code&gt; despu&amp;eacute;s de la divisi&amp;oacute;n en el suelo por &lt;code&gt;y&lt;/code&gt; , es decir, &lt;code&gt;x - y*fld(x,y)&lt;/code&gt; si se calcula sin redondeo intermedio.</target>
        </trans-unit>
        <trans-unit id="c7a083bb1a1b10ec23125171dedac6f03596ea4e" translate="yes" xml:space="preserve">
          <source>The relation defined by &lt;code&gt;isless&lt;/code&gt; is transitive, i.e., &lt;code&gt;isless(x, y) &amp;amp;&amp;amp; isless(y, z)&lt;/code&gt; implies &lt;code&gt;isless(x, z)&lt;/code&gt;.</source>
          <target state="translated">La relaci&amp;oacute;n definida por &lt;code&gt;isless&lt;/code&gt; es transitiva, es decir, &lt;code&gt;isless(x, y) &amp;amp;&amp;amp; isless(y, z)&lt;/code&gt; implica &lt;code&gt;isless(x, z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae50d1ec149a5bb325ee3ed684413be8beb00545" translate="yes" xml:space="preserve">
          <source>The relationship between &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is</source>
          <target state="translated">La relaci&amp;oacute;n entre &lt;code&gt;F&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="357ff91ebaa3be4c787ab446d6ed56a0b9394db7" translate="yes" xml:space="preserve">
          <source>The remaining parameters are evaluated at compile time, when the containing method is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f134ecdeee3cfa777ccd458bfed97ec72082e75e" translate="yes" xml:space="preserve">
          <source>The remote cache is maintained for the lifetime of the returned &lt;code&gt;CachingPool&lt;/code&gt; object. To clear the cache earlier, use &lt;code&gt;clear!(pool)&lt;/code&gt;.</source>
          <target state="translated">La cach&amp;eacute; remota se mantiene durante la vida &amp;uacute;til del objeto &lt;code&gt;CachingPool&lt;/code&gt; devuelto . Para borrar el cach&amp;eacute; antes, use &lt;code&gt;clear!(pool)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df901bb294129f7627dac22ff5e80e400643c39f" translate="yes" xml:space="preserve">
          <source>The required keyword argument &lt;code&gt;var&lt;/code&gt; was not assigned in a function call.</source>
          <target state="translated">El argumento de palabra clave requerido &lt;code&gt;var&lt;/code&gt; no se asign&amp;oacute; en una llamada de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a9f7acaee551d1164b11cacdb547b0da33902de6" translate="yes" xml:space="preserve">
          <source>The result is a pointer giving the address of the value. The value can be manipulated through this pointer using &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt;&lt;code&gt;unsafe_load&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El resultado es un puntero que da la direcci&amp;oacute;n del valor. El valor se puede manipular a trav&amp;eacute;s de este puntero usando &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt; &lt;code&gt;unsafe_load&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="03cc3e3ef7a55f891b2fdc37e1dca5251bee7ee1" translate="yes" xml:space="preserve">
          <source>The result is of type &lt;code&gt;Bool&lt;/code&gt;, except when one of the operands is &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;, in which case &lt;code&gt;missing&lt;/code&gt; is returned (&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;). For collections, &lt;code&gt;missing&lt;/code&gt; is returned if at least one of the operands contains a &lt;code&gt;missing&lt;/code&gt; value and all non-missing values are equal. Use &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; to always get a &lt;code&gt;Bool&lt;/code&gt; result.</source>
          <target state="translated">El resultado es de tipo &lt;code&gt;Bool&lt;/code&gt; , excepto cuando &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; uno de los operandos , en cuyo caso se devuelve &lt;code&gt;missing&lt;/code&gt; ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;l&amp;oacute;gica de tres valores&lt;/a&gt; ). Para las colecciones, se devuelve &lt;code&gt;missing&lt;/code&gt; si al menos uno de los operandos contiene un valor &lt;code&gt;missing&lt;/code&gt; y todos los valores no perdidos son iguales. Utilice &lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; para obtener siempre un resultado &lt;code&gt;Bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c007650ed1d2ab98bda9d8f6e9d2a6696a562053" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;n&lt;/code&gt; iterative applications of &lt;code&gt;nextfloat&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; applications of &lt;code&gt;prevfloat&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;n&lt;/code&gt; aplicaciones iterativas de &lt;code&gt;nextfloat&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; si &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; , o &lt;code&gt;-n&lt;/code&gt; aplicaciones de &lt;code&gt;prevfloat&lt;/code&gt; si &lt;code&gt;n &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94b46c3b276e64ea98bedcc1b3f79ab9ebee8c1f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;n&lt;/code&gt; iterative applications of &lt;code&gt;prevfloat&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; applications of &lt;code&gt;nextfloat&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;n&lt;/code&gt; aplicaciones iterativas de &lt;code&gt;prevfloat&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; si &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; , o &lt;code&gt;-n&lt;/code&gt; aplicaciones de &lt;code&gt;nextfloat&lt;/code&gt; si &lt;code&gt;n &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b9604e81f6338ca5014cd5645d78240588116b2" translate="yes" xml:space="preserve">
          <source>The result of an expression is too large for the specified type and will cause a wraparound.</source>
          <target state="translated">El resultado de una expresión es demasiado grande para el tipo especificado y causará una envoltura.</target>
        </trans-unit>
        <trans-unit id="5e37838dee3788d25d7398516d199b796b585b2f" translate="yes" xml:space="preserve">
          <source>The result of indexing an &lt;code&gt;AbstractArray&lt;/code&gt; can itself be an array (for instance when indexing by an &lt;code&gt;AbstractRange&lt;/code&gt;). The &lt;code&gt;AbstractArray&lt;/code&gt; fallback methods use &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; to allocate an &lt;code&gt;Array&lt;/code&gt; of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:</source>
          <target state="translated">El resultado de indexar un &lt;code&gt;AbstractArray&lt;/code&gt; puede ser en s&amp;iacute; mismo una matriz (por ejemplo, cuando se indexa mediante un &lt;code&gt;AbstractRange&lt;/code&gt; ). Los m&amp;eacute;todos de reserva de &lt;code&gt;AbstractArray&lt;/code&gt; se utilizan de forma &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt; para asignar una &lt;code&gt;Array&lt;/code&gt; del tama&amp;ntilde;o y tipo de elemento adecuados, que se completa con el m&amp;eacute;todo de indexaci&amp;oacute;n b&amp;aacute;sico descrito anteriormente. Sin embargo, al implementar un contenedor de matriz, a menudo desea que el resultado tambi&amp;eacute;n se ajuste:</target>
        </trans-unit>
        <trans-unit id="9dddd93bc0d8f1d83b952a56d60f4d4d4dde4922" translate="yes" xml:space="preserve">
          <source>The result will have the same sign as &lt;code&gt;y&lt;/code&gt;, and magnitude less than &lt;code&gt;abs(y)&lt;/code&gt; (with some exceptions, see note below).</source>
          <target state="translated">El resultado tendr&amp;aacute; el mismo signo que &lt;code&gt;y&lt;/code&gt; , y una magnitud menor que &lt;code&gt;abs(y)&lt;/code&gt; (con algunas excepciones, consulte la nota a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="2e42d4dacc7dd604beaf0aa38148dabcfc4501d7" translate="yes" xml:space="preserve">
          <source>The resulting array type depends on the types of the computed elements just like &lt;a href=&quot;#man-array-literals&quot;&gt;array literals&lt;/a&gt; do. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f568e8a5a2b842636c272653d157a8edcd885b90" translate="yes" xml:space="preserve">
          <source>The resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</source>
          <target state="translated">El tipo de matriz resultante depende de los tipos de los elementos computados.Para controlar el tipo explícitamente,se puede preparar un tipo para la comprensión.Por ejemplo,podríamos haber pedido el resultado en una sola precisión al escribir:</target>
        </trans-unit>
        <trans-unit id="ccd36a28a2ffb3965813bdc3900b2e91091344fd" translate="yes" xml:space="preserve">
          <source>The resulting container type is established by the following rules:</source>
          <target state="translated">El tipo de contenedor resultante se establece mediante las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="1fe1a92416b8011a58e509306cdd809a4d7403bb" translate="yes" xml:space="preserve">
          <source>The results are identical, and Julia's interpolation behavior mimics the shell's with some improvements due to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities. When trying to port shell commands to Julia, try cut and pasting first. Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation without doing any damage.</source>
          <target state="translated">Los resultados son idénticos,y el comportamiento de interpolación de Julia imita el del caparazón con algunas mejoras debido al hecho de que Julia soporta objetos iterables de primera clase mientras que la mayoría de los caparazones usan cuerdas divididas en espacios para esto,lo que introduce ambigüedades.Cuando intente portar comandos de shell a Julia,intente cortar y pegar primero.Como Julia te muestra los comandos antes de ejecutarlos,puedes fácilmente y con seguridad examinar su interpretación sin hacer ningún daño.</target>
        </trans-unit>
        <trans-unit id="38f3a90d878f6adff0fab13415fb19f7e29771de" translate="yes" xml:space="preserve">
          <source>The return array's &lt;code&gt;eltype&lt;/code&gt; is &lt;code&gt;Int&lt;/code&gt; for signed integers of less than system word size and &lt;code&gt;UInt&lt;/code&gt; for unsigned integers of less than system word size. To preserve &lt;code&gt;eltype&lt;/code&gt; of arrays with small signed or unsigned integer &lt;code&gt;accumulate(+, A)&lt;/code&gt; should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9c7956c24febdcf914d416fae3a917b2f39e3e" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;Int&lt;/code&gt; for signed integers of less than system word size, and &lt;code&gt;UInt&lt;/code&gt; for unsigned integers of less than system word size. For all other arguments, a common return type is found to which all arguments are promoted.</source>
          <target state="translated">El tipo de retorno es &lt;code&gt;Int&lt;/code&gt; para enteros con signo menores que el tama&amp;ntilde;o de la palabra del sistema, y &lt;code&gt;UInt&lt;/code&gt; para enteros sin signo menores que el tama&amp;ntilde;o de la palabra del sistema. Para todos los dem&amp;aacute;s argumentos, se encuentra un tipo de retorno com&amp;uacute;n al que se promueven todos los argumentos.</target>
        </trans-unit>
        <trans-unit id="060ee76adfcb8c1b93eeb957a42add7f77612d3a" translate="yes" xml:space="preserve">
          <source>The return type of this macro was changed from &lt;code&gt;Tuple&lt;/code&gt; to &lt;code&gt;NamedTuple&lt;/code&gt; in Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bdd15fbc5eeeea487e741f6815e78f1d57eeca2" translate="yes" xml:space="preserve">
          <source>The return value is a range of indices where the matching sequence is found, such that &lt;code&gt;s[findnext(x, s, i)] == x&lt;/code&gt;:</source>
          <target state="translated">El valor de retorno es un rango de &amp;iacute;ndices donde se encuentra la secuencia coincidente, tal que &lt;code&gt;s[findnext(x, s, i)] == x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="296596adaa4e2ffb872d464b197ffa89509d78f4" translate="yes" xml:space="preserve">
          <source>The return value is a range of indices where the matching sequence is found, such that &lt;code&gt;s[findprev(x, s, i)] == x&lt;/code&gt;:</source>
          <target state="translated">El valor de retorno es un rango de &amp;iacute;ndices donde se encuentra la secuencia coincidente, tal que &lt;code&gt;s[findprev(x, s, i)] == x&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="edd94ab3af8421f151d037f6b1c8c8e9c195e125" translate="yes" xml:space="preserve">
          <source>The return value is the &lt;code&gt;k&lt;/code&gt;th element of &lt;code&gt;ix&lt;/code&gt; if &lt;code&gt;k&lt;/code&gt; is an integer, or view into &lt;code&gt;ix&lt;/code&gt; if &lt;code&gt;k&lt;/code&gt; is a range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4a1e6fb47e3491c23ed68634d665b86e2b1224" translate="yes" xml:space="preserve">
          <source>The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.</source>
          <target state="translated">El valor de retorno será un nuevo objeto inicializado para contener una copia del contenido de la memoria de referencia.La memoria referenciada puede ser liberada o liberada con seguridad.</target>
        </trans-unit>
        <trans-unit id="995e85d8c74168d9b1cb80ff9be361035188ad05" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop variable takes on all the produced values. The loop is terminated when the channel is closed.</source>
          <target state="translated">El &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; devuelto se puede utilizar como un objeto iterable en un bucle &lt;code&gt;for&lt;/code&gt; , en cuyo caso la variable de bucle toma todos los valores producidos. El bucle finaliza cuando se cierra el canal.</target>
        </trans-unit>
        <trans-unit id="4905fa2086f7e7025e1f1fb3e602f0309c36c38d" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(==)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">La funci&amp;oacute;n devuelta es de tipo &lt;code&gt;Base.Fix2{typeof(==)}&lt;/code&gt; , que se puede utilizar para implementar m&amp;eacute;todos especializados.</target>
        </trans-unit>
        <trans-unit id="d2b0ef788e8302311f9e8c57e74d525a3630605d" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(contains)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da6c7b3762160369fb507be946e5100e21bab812" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(endswith)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76989de74c6183b202bef17365490bd9a3d31c70" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(isequal)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">La funci&amp;oacute;n devuelta es de tipo &lt;code&gt;Base.Fix2{typeof(isequal)}&lt;/code&gt; , que se puede utilizar para implementar m&amp;eacute;todos especializados.</target>
        </trans-unit>
        <trans-unit id="6a5882fae0e5fa7580063c72c386192604725113" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(startswith)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5913ac9f9933573cc3f45ba086fb826464beb36" translate="yes" xml:space="preserve">
          <source>The returned object &lt;code&gt;F&lt;/code&gt; stores the factorization in a packed format:</source>
          <target state="translated">El objeto devuelto &lt;code&gt;F&lt;/code&gt; almacena la factorizaci&amp;oacute;n en un formato empaquetado:</target>
        </trans-unit>
        <trans-unit id="5b6b30b85a24f3b9aaa6b8733a6c0289157aac3b" translate="yes" xml:space="preserve">
          <source>The returned tuple must only contain either &lt;code&gt;Int&lt;/code&gt;s or &lt;code&gt;AbstractArray&lt;/code&gt;s of scalar indices that are supported by array &lt;code&gt;A&lt;/code&gt;. It will error upon encountering a novel index type that it does not know how to process.</source>
          <target state="translated">La tupla devuelta s&amp;oacute;lo debe contener &lt;code&gt;Int&lt;/code&gt; s o &lt;code&gt;AbstractArray&lt;/code&gt; s de &amp;iacute;ndices escalares que son soportados por matriz &lt;code&gt;A&lt;/code&gt; . Se producir&amp;aacute; un error al encontrar un tipo de &amp;iacute;ndice novedoso que no sabe c&amp;oacute;mo procesar.</target>
        </trans-unit>
        <trans-unit id="d9c1e00640a368c30e904f9290ae3dcb10bd1ec3" translate="yes" xml:space="preserve">
          <source>The returned value is an object with boolean fields &lt;code&gt;changed&lt;/code&gt;, &lt;code&gt;renamed&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the result of watching the file.</source>
          <target state="translated">El valor devuelto es un objeto con campos booleanos &lt;code&gt;changed&lt;/code&gt; , &lt;code&gt;renamed&lt;/code&gt; y con tiempo de &lt;code&gt;timedout&lt;/code&gt; , lo que da el resultado de ver el archivo.</target>
        </trans-unit>
        <trans-unit id="0aae9d904638273f671fc4e418a0190f5b8a389f" translate="yes" xml:space="preserve">
          <source>The returned value is an object with boolean fields &lt;code&gt;readable&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the result of the polling.</source>
          <target state="translated">El valor devuelto es un objeto con campos booleanos &lt;code&gt;readable&lt;/code&gt; , &lt;code&gt;writable&lt;/code&gt; y con tiempo de &lt;code&gt;timedout&lt;/code&gt; , lo que da el resultado del sondeo.</target>
        </trans-unit>
        <trans-unit id="49b2889cf141c81986b5559befd286291492017c" translate="yes" xml:space="preserve">
          <source>The returned value is an pair where the first field is the name of the changed file (if available) and the second field is an object with boolean fields &lt;code&gt;changed&lt;/code&gt;, &lt;code&gt;renamed&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the event.</source>
          <target state="translated">El valor devuelto es un par donde el primer campo es el nombre del archivo cambiado (si est&amp;aacute; disponible) y el segundo campo es un objeto con campos booleanos &lt;code&gt;changed&lt;/code&gt; , &lt;code&gt;renamed&lt;/code&gt; y &lt;code&gt;timedout&lt;/code&gt; , dando el evento.</target>
        </trans-unit>
        <trans-unit id="8636f9ac58bcf28e3d16135d951b8ff3e218cbd7" translate="yes" xml:space="preserve">
          <source>The reverse operation (writing data to a &lt;code&gt;Ptr{T}&lt;/code&gt;), can be performed using &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!(ptr, value, [index])&lt;/code&gt;&lt;/a&gt;. Currently, this is only supported for primitive types or other pointer-free (&lt;code&gt;isbits&lt;/code&gt;) immutable struct types.</source>
          <target state="translated">La operaci&amp;oacute;n inversa (escribir datos en un &lt;code&gt;Ptr{T}&lt;/code&gt; ), se puede realizar usando &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!(ptr, value, [index])&lt;/code&gt; &lt;/a&gt; . Actualmente, esto solo es compatible con tipos primitivos u otros tipos de estructuras inmutables sin puntero ( &lt;code&gt;isbits&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b7d58ee9a7a86e6aad0f59e6f9ed658c820e2192" translate="yes" xml:space="preserve">
          <source>The roots, graph and paths maps of a project environment are defined as follows:</source>
          <target state="translated">Los mapas de raíces,gráficos y trayectorias de un entorno de proyecto se definen de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="8db1c63f81410ece76ca99d9ff0064394f7701c3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">Lo mismo que &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; , pero ahorra espacio al sobrescribir la entrada &lt;code&gt;A&lt;/code&gt; , en lugar de crear una copia. Se &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt; excepci&amp;oacute;n InexactError si la factorizaci&amp;oacute;n produce un n&amp;uacute;mero no representable por el tipo de elemento de &lt;code&gt;A&lt;/code&gt; , por ejemplo, para tipos enteros.</target>
        </trans-unit>
        <trans-unit id="7ac8db3a8fce7e45f1c23cbd8542a5bd84c64ad8" translate="yes" xml:space="preserve">
          <source>The same best practices also work for container types:</source>
          <target state="translated">Las mismas prácticas óptimas funcionan también para los tipos de contenedores:</target>
        </trans-unit>
        <trans-unit id="7644c0d871ce59114cf83dbd0542336b1d1077e8" translate="yes" xml:space="preserve">
          <source>The same thing can be done using recursion:</source>
          <target state="translated">Lo mismo se puede hacer usando la recursión:</target>
        </trans-unit>
        <trans-unit id="ce434c40b5667e45d99db93d9917e22507c58bf8" translate="yes" xml:space="preserve">
          <source>The schedule used by &lt;code&gt;@spawn&lt;/code&gt; is nondeterministic and should not be relied on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499f37304cc2bf38bfc1e123fdaa79c60bea1de4" translate="yes" xml:space="preserve">
          <source>The script &lt;code&gt;julia-config.jl&lt;/code&gt; was created to aid in determining what build parameters are required by a program that uses embedded Julia. This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution. This script is located in the Julia shared data directory.</source>
          <target state="translated">El script &lt;code&gt;julia-config.jl&lt;/code&gt; fue creado para ayudar a determinar qu&amp;eacute; par&amp;aacute;metros de construcci&amp;oacute;n son requeridos por un programa que usa Julia incrustada. Esta secuencia de comandos utiliza los par&amp;aacute;metros de compilaci&amp;oacute;n y la configuraci&amp;oacute;n del sistema de la distribuci&amp;oacute;n particular de Julia por la que se invoca para exportar los indicadores del compilador necesarios para que un programa de incrustaci&amp;oacute;n interact&amp;uacute;e con esa distribuci&amp;oacute;n. Este script se encuentra en el directorio de datos compartidos de Julia.</target>
        </trans-unit>
        <trans-unit id="6f8fe32c72b2738c988d9f8c4881f931f1ba36f2" translate="yes" xml:space="preserve">
          <source>The second argument &lt;code&gt;p&lt;/code&gt; is not necessarily a part of the interface for &lt;code&gt;norm&lt;/code&gt;, i.e. a custom type may only implement &lt;code&gt;norm(A)&lt;/code&gt; without second argument.</source>
          <target state="translated">El segundo argumento &lt;code&gt;p&lt;/code&gt; no es necesariamente parte de la interfaz para la &lt;code&gt;norm&lt;/code&gt; a , es decir, un tipo personalizado solo puede implementar la &lt;code&gt;norm(A)&lt;/code&gt; sin un segundo argumento.</target>
        </trans-unit>
        <trans-unit id="b22778842445d7f70d31b000bce7d6cc33096518" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: &lt;code&gt;stdcall&lt;/code&gt;, &lt;code&gt;cdecl&lt;/code&gt;, &lt;code&gt;fastcall&lt;/code&gt;, and &lt;code&gt;thiscall&lt;/code&gt; (no-op on 64-bit Windows). For example (from &lt;code&gt;base/libc.jl&lt;/code&gt;) we see the same &lt;code&gt;gethostname&lt;/code&gt;&lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; as above, but with the correct signature for Windows:</source>
          <target state="translated">El segundo argumento de &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; puede ser opcionalmente un especificador de convenci&amp;oacute;n de llamada (inmediatamente antes del tipo de retorno). Sin ning&amp;uacute;n especificador, se utiliza la convenci&amp;oacute;n de llamada C predeterminada de la plataforma. Otras convenciones admitidas son: &lt;code&gt;stdcall&lt;/code&gt; , &lt;code&gt;cdecl&lt;/code&gt; , &lt;code&gt;fastcall&lt;/code&gt; y &lt;code&gt;thiscall&lt;/code&gt; (no operativa en Windows de 64 bits). Por ejemplo (de &lt;code&gt;base/libc.jl&lt;/code&gt; ) vemos el mismo &lt;code&gt;gethostname&lt;/code&gt; &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; que el anterior, pero con la firma correcta para Windows:</target>
        </trans-unit>
        <trans-unit id="73459aa685b4a3b889d50fc5fe7e0470f348a1b0" translate="yes" xml:space="preserve">
          <source>The second fact is why execution of the loop changes the global value of &lt;code&gt;s&lt;/code&gt; and the first fact is why &lt;code&gt;t&lt;/code&gt; is still undefined after the loop executes. Now, let's try evaluating this same code as though it were in a file instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae8f7c6c5ae9107bf9df78309eaedb266fcdbc6" translate="yes" xml:space="preserve">
          <source>The second form is also often better style and can lead to more code reuse.</source>
          <target state="translated">La segunda forma también suele tener un mejor estilo y puede llevar a una mayor reutilización del código.</target>
        </trans-unit>
        <trans-unit id="f5a1001e237b6ff86cbef193ea1ae22360accd73" translate="yes" xml:space="preserve">
          <source>The second of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El segundo de un &lt;code&gt;DateTime&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d31d476948ba89a2e9e64c6b33fad2cd0a026a5" translate="yes" xml:space="preserve">
          <source>The second of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El segundo de &lt;code&gt;Time&lt;/code&gt; como &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="325c1f846c581874b3b9e8bdbf898464d53c77a6" translate="yes" xml:space="preserve">
          <source>The second part of a DateTime as a &lt;code&gt;Second&lt;/code&gt;.</source>
          <target state="translated">La segunda parte de un DateTime como &lt;code&gt;Second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a3329a718673195a0538b1050837014e0187920" translate="yes" xml:space="preserve">
          <source>The second statement in the test program evaluates a Julia statement using a call to &lt;code&gt;jl_eval_string&lt;/code&gt;.</source>
          <target state="translated">La segunda declaraci&amp;oacute;n del programa de prueba eval&amp;uacute;a una declaraci&amp;oacute;n de Julia mediante una llamada a &lt;code&gt;jl_eval_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc4451185981f40556584c6f362b372cf0d2413" translate="yes" xml:space="preserve">
          <source>The second syntactic purpose of the &lt;code&gt;:&lt;/code&gt; character is to create expression objects without using the explicit &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; constructor. This is referred to as &lt;em&gt;quoting&lt;/em&gt;. The &lt;code&gt;:&lt;/code&gt; character, followed by paired parentheses around a single statement of Julia code, produces an &lt;code&gt;Expr&lt;/code&gt; object based on the enclosed code. Here is example of the short form used to quote an arithmetic expression:</source>
          <target state="translated">El segundo prop&amp;oacute;sito sint&amp;aacute;ctico del car&amp;aacute;cter &lt;code&gt;:&lt;/code&gt; es crear objetos de expresi&amp;oacute;n sin utilizar el constructor &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; expl&amp;iacute;cito . Esto se conoce como &lt;em&gt;cotizaci&amp;oacute;n&lt;/em&gt; . El car&amp;aacute;cter &lt;code&gt;:&lt;/code&gt; , seguido de par&amp;eacute;ntesis emparejados alrededor de una sola declaraci&amp;oacute;n de c&amp;oacute;digo de Julia, produce un objeto &lt;code&gt;Expr&lt;/code&gt; basado en el c&amp;oacute;digo adjunto. A continuaci&amp;oacute;n, se muestra un ejemplo de la forma abreviada utilizada para citar una expresi&amp;oacute;n aritm&amp;eacute;tica:</target>
        </trans-unit>
        <trans-unit id="915184092841becb822c9871efbbca52119b3359" translate="yes" xml:space="preserve">
          <source>The second version will convert &lt;code&gt;x&lt;/code&gt; to an appropriate type, instead of always the same type.</source>
          <target state="translated">La segunda versi&amp;oacute;n convertir&amp;aacute; &lt;code&gt;x&lt;/code&gt; a un tipo apropiado, en lugar de siempre al mismo tipo.</target>
        </trans-unit>
        <trans-unit id="21005babd7e775084c5d9f5bf289076cc05e5e92" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt; discussed the execution of multiple functions in a co-operative manner. &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s can be quite useful to pass data between running tasks, particularly those involving I/O operations.</source>
          <target state="translated">La secci&amp;oacute;n sobre &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; en &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt; discuti&amp;oacute; la ejecuci&amp;oacute;n de m&amp;uacute;ltiples funciones de manera cooperativa. &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; pueden ser muy &amp;uacute;tiles para pasar datos entre tareas en ejecuci&amp;oacute;n, particularmente aquellas que involucran operaciones de E / S.</target>
        </trans-unit>
        <trans-unit id="d29f893f8cb7d336019acffa7a05d1fd7e30e1bd" translate="yes" xml:space="preserve">
          <source>The semicolon is used to separate required arguments (of which there must be at least one) from variadic arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8192d7c492df82ef09042dd5374aa1f14711d23" translate="yes" xml:space="preserve">
          <source>The shared array is valid as long as a reference to the &lt;code&gt;SharedArray&lt;/code&gt; object exists on the node which created the mapping.</source>
          <target state="translated">La matriz compartida es v&amp;aacute;lida siempre que exista una referencia al objeto &lt;code&gt;SharedArray&lt;/code&gt; en el nodo que cre&amp;oacute; la asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5dc8475813b4cdc5d96eb3c4625fbd7b58d50c66" translate="yes" xml:space="preserve">
          <source>The shortest complete expression after the &lt;code&gt;$&lt;/code&gt; is taken as the expression whose value is to be interpolated into the string. Thus, you can interpolate any expression into a string using parentheses:</source>
          <target state="translated">La expresi&amp;oacute;n completa m&amp;aacute;s corta despu&amp;eacute;s de &lt;code&gt;$&lt;/code&gt; se toma como la expresi&amp;oacute;n cuyo valor se interpolar&amp;aacute; en la cadena. Por lo tanto, puede interpolar cualquier expresi&amp;oacute;n en una cadena usando par&amp;eacute;ntesis:</target>
        </trans-unit>
        <trans-unit id="3d9f8e8412af884c31e022248ea444c48500d8b3" translate="yes" xml:space="preserve">
          <source>The simplest way to create a sparse array is to use a function equivalent to the &lt;a href=&quot;../../base/arrays/index#Base.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; function that Julia provides for working with dense arrays. To produce a sparse array instead, you can use the same name with an &lt;code&gt;sp&lt;/code&gt; prefix:</source>
          <target state="translated">La forma m&amp;aacute;s sencilla de crear una matriz dispersa es utilizar una funci&amp;oacute;n equivalente a la funci&amp;oacute;n de &lt;a href=&quot;../../base/arrays/index#Base.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt; que proporciona Julia para trabajar con matrices densas. Para producir una matriz dispersa en su lugar, puede usar el mismo nombre con un prefijo &lt;code&gt;sp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="16be4bebce7cbb536220116c00b6f9d05ca83f19" translate="yes" xml:space="preserve">
          <source>The single argument &lt;code&gt;endswith(suffix)&lt;/code&gt; requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01b5055495d08a0cdfb3ee522579f3c77a12e9b" translate="yes" xml:space="preserve">
          <source>The single argument &lt;code&gt;startswith(prefix)&lt;/code&gt; requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c1b2cacc149914d1f87944b2e673b55e75f540" translate="yes" xml:space="preserve">
          <source>The singleton instance of &lt;code&gt;Colon&lt;/code&gt; is also a function used to construct ranges; see &lt;a href=&quot;../math/index#Base.::&quot;&gt;&lt;code&gt;:&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La instancia singleton de &lt;code&gt;Colon&lt;/code&gt; tambi&amp;eacute;n es una funci&amp;oacute;n que se usa para construir rangos; ver &lt;a href=&quot;../math/index#Base.::&quot;&gt; &lt;code&gt;:&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="69dbdef625126b35b49d3d64442b9b0a176ab7d3" translate="yes" xml:space="preserve">
          <source>The singleton instance of type &lt;a href=&quot;#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt; representing a missing value.</source>
          <target state="translated">La instancia de singleton de tipo &lt;a href=&quot;#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; que&lt;/a&gt; representa un valor perdido.</target>
        </trans-unit>
        <trans-unit id="d89078042c9eb6d352a7eb66e0b88b0400546bfa" translate="yes" xml:space="preserve">
          <source>The singleton instance of type &lt;a href=&quot;../base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt;, used by convention when there is no value to return (as in a C &lt;code&gt;void&lt;/code&gt; function) or when a variable or field holds no value.</source>
          <target state="translated">La instancia singleton de tipo &lt;a href=&quot;../base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; , usada por convenci&amp;oacute;n cuando no hay valor para devolver (como en una funci&amp;oacute;n &lt;code&gt;void&lt;/code&gt; de C ) o cuando una variable o campo no tiene valor.</target>
        </trans-unit>
        <trans-unit id="98c477c6e9d21cf836746a2bcff1d62c547964d7" translate="yes" xml:space="preserve">
          <source>The size (in bytes) of the file</source>
          <target state="translated">El tamaño (en bytes)del archivo</target>
        </trans-unit>
        <trans-unit id="b66123090eeef1135c4d4375118f6396f24e2b0e" translate="yes" xml:space="preserve">
          <source>The slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter &lt;code&gt;T&lt;/code&gt; is not used in the definition of the type itself &amp;ndash; it is just an abstract tag, essentially defining an entire family of types with identical structure, differentiated only by their type parameter. Thus, &lt;code&gt;Ptr{Float64}&lt;/code&gt; and &lt;code&gt;Ptr{Int64}&lt;/code&gt; are distinct types, even though they have identical representations. And of course, all specific pointer types are subtypes of the umbrella &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; type:</source>
          <target state="translated">La caracter&amp;iacute;stica un poco extra&amp;ntilde;a de estas declaraciones en comparaci&amp;oacute;n con los tipos compuestos param&amp;eacute;tricos t&amp;iacute;picos es que el par&amp;aacute;metro de tipo &lt;code&gt;T&lt;/code&gt; no se usa en la definici&amp;oacute;n del tipo en s&amp;iacute;; es solo una etiqueta abstracta, que esencialmente define una familia completa de tipos con estructura id&amp;eacute;ntica, diferenciados &amp;uacute;nicamente por su par&amp;aacute;metro de tipo. Por lo tanto, &lt;code&gt;Ptr{Float64}&lt;/code&gt; y &lt;code&gt;Ptr{Int64}&lt;/code&gt; son tipos distintos, aunque tienen representaciones id&amp;eacute;nticas. Y, por supuesto, todos los tipos de punteros espec&amp;iacute;ficos son subtipos del tipo paraguas &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b70321f704716a765747450fd9a29400a288057e" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;a^n&lt;/code&gt; not less than &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a non-negative integer. &lt;code&gt;a&lt;/code&gt; must be greater than 1, and &lt;code&gt;x&lt;/code&gt; must be greater than 0.</source>
          <target state="translated">El m&amp;aacute;s peque&amp;ntilde;o &lt;code&gt;a^n&lt;/code&gt; no menor que &lt;code&gt;x&lt;/code&gt; , donde &lt;code&gt;n&lt;/code&gt; es un n&amp;uacute;mero entero no negativo. &lt;code&gt;a&lt;/code&gt; debe ser mayor que 1 y &lt;code&gt;x&lt;/code&gt; debe ser mayor que 0.</target>
        </trans-unit>
        <trans-unit id="8e217f5379986c6dbb724913b9402b2744112320" translate="yes" xml:space="preserve">
          <source>The smallest in absolute value non-subnormal value representable by the given floating-point DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">El valor no subnormal m&amp;aacute;s peque&amp;ntilde;o en valor absoluto representable por el DataType &lt;code&gt;T&lt;/code&gt; de punto flotante dado .</target>
        </trans-unit>
        <trans-unit id="25349e0ef0dc3df135e9bbaceeafe9aedb6a8cb7" translate="yes" xml:space="preserve">
          <source>The so-called &quot;ternary operator&quot;, &lt;code&gt;?:&lt;/code&gt;, is closely related to the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the only operator in most languages taking three operands:</source>
          <target state="translated">El llamado &quot;operador ternario&quot;, &lt;code&gt;?:&lt;/code&gt; , Est&amp;aacute; estrechamente relacionado con la sintaxis &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; , pero se utiliza cuando se requiere una elecci&amp;oacute;n condicional entre valores de expresi&amp;oacute;n &amp;uacute;nica, en contraposici&amp;oacute;n a la ejecuci&amp;oacute;n condicional de bloques de c&amp;oacute;digo m&amp;aacute;s largos. Recibe su nombre de ser el &amp;uacute;nico operador en la mayor&amp;iacute;a de los lenguajes que toma tres operandos:</target>
        </trans-unit>
        <trans-unit id="466b5c814e2cc3e14c74b0b3d7f3038223cc5afa" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;CartesianIndex{N}&lt;/code&gt; object represents a scalar index that behaves like an &lt;code&gt;N&lt;/code&gt;-tuple of integers spanning multiple dimensions. For example:</source>
          <target state="translated">El objeto especial &lt;code&gt;CartesianIndex{N}&lt;/code&gt; representa un &amp;iacute;ndice escalar que se comporta como una &lt;code&gt;N&lt;/code&gt; -tupla de enteros que abarcan m&amp;uacute;ltiples dimensiones. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="762a1096309b147153ae61442ac8f98b5b44d380" translate="yes" xml:space="preserve">
          <source>The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, &lt;code&gt;@distributed&lt;/code&gt; performs local reductions on each worker with a final reduction on the calling process.</source>
          <target state="translated">El rango especificado se particiona y se ejecuta localmente en todos los trabajadores. En caso de que se especifique una funci&amp;oacute;n reductora opcional, &lt;code&gt;@distributed&lt;/code&gt; realiza reducciones locales en cada trabajador con una reducci&amp;oacute;n final en el proceso de llamada.</target>
        </trans-unit>
        <trans-unit id="af76c7aa8adb68998b2eccf29c56d714b4910790" translate="yes" xml:space="preserve">
          <source>The stack of current exceptions can be accessed using the experimental &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt;&lt;code&gt;Base.catch_stack&lt;/code&gt;&lt;/a&gt; function. For example,</source>
          <target state="translated">Se puede acceder a la pila de excepciones actuales mediante la funci&amp;oacute;n experimental &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt; &lt;code&gt;Base.catch_stack&lt;/code&gt; &lt;/a&gt; . Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="b314da4796576e2f7b71a666741e2ef66714401f" translate="yes" xml:space="preserve">
          <source>The standard way to obtain a value of a certain type &lt;code&gt;T&lt;/code&gt; is to call the type's constructor, &lt;code&gt;T(x)&lt;/code&gt;. However, there are cases where it's convenient to convert a value from one type to another without the programmer asking for it explicitly. One example is assigning a value into an array: if &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Vector{Float64}&lt;/code&gt;, the expression &lt;code&gt;A[1] = 2&lt;/code&gt; should work by automatically converting the &lt;code&gt;2&lt;/code&gt; from &lt;code&gt;Int&lt;/code&gt; to &lt;code&gt;Float64&lt;/code&gt;, and storing the result in the array. This is done via the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">La forma est&amp;aacute;ndar de obtener un valor de cierto tipo &lt;code&gt;T&lt;/code&gt; es llamar al constructor del tipo, &lt;code&gt;T(x)&lt;/code&gt; . Sin embargo, hay casos en los que es conveniente convertir un valor de un tipo a otro sin que el programador lo solicite expl&amp;iacute;citamente. Un ejemplo es asignar un valor a una matriz: si &lt;code&gt;A&lt;/code&gt; es un &lt;code&gt;Vector{Float64}&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;A[1] = 2&lt;/code&gt; deber&amp;iacute;a funcionar convirtiendo autom&amp;aacute;ticamente el &lt;code&gt;2&lt;/code&gt; de &lt;code&gt;Int&lt;/code&gt; a &lt;code&gt;Float64&lt;/code&gt; y almacenando el resultado en la matriz. Esto se realiza mediante la funci&amp;oacute;n de &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09c9759ec2f73e324d46f0dc859670daa106989a" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;using BigLib: thing1, thing2&lt;/code&gt; brings just the identifiers &lt;code&gt;thing1&lt;/code&gt; and &lt;code&gt;thing2&lt;/code&gt; into scope from module &lt;code&gt;BigLib&lt;/code&gt;. If these names refer to functions, adding methods to them will not be allowed (you may only &quot;use&quot; them, not extend them).</source>
          <target state="translated">La declaraci&amp;oacute;n que &lt;code&gt;using BigLib: thing1, thing2&lt;/code&gt; trae solo los identificadores &lt;code&gt;thing1&lt;/code&gt; y &lt;code&gt;thing2&lt;/code&gt; al alcance del m&amp;oacute;dulo &lt;code&gt;BigLib&lt;/code&gt; . Si estos nombres se refieren a funciones, no se permitir&amp;aacute; agregarles m&amp;eacute;todos (solo puede &quot;usarlos&quot;, no extenderlos).</target>
        </trans-unit>
        <trans-unit id="495d86d0b4d05239c00e12e65404916397e09df9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;using Lib&lt;/code&gt; means that a module called &lt;code&gt;Lib&lt;/code&gt; will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by &lt;code&gt;Lib&lt;/code&gt; and import it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in &lt;code&gt;Lib&lt;/code&gt;.</source>
          <target state="translated">La declaraci&amp;oacute;n que &lt;code&gt;using Lib&lt;/code&gt; significa que un m&amp;oacute;dulo llamado &lt;code&gt;Lib&lt;/code&gt; estar&amp;aacute; disponible para resolver nombres seg&amp;uacute;n sea necesario. Cuando se encuentra una variable global que no tiene definici&amp;oacute;n en el m&amp;oacute;dulo actual, el sistema la buscar&amp;aacute; entre las variables exportadas por &lt;code&gt;Lib&lt;/code&gt; y la importar&amp;aacute; si se encuentra all&amp;iacute;. Esto significa que todos los usos de ese global dentro del m&amp;oacute;dulo actual se resolver&amp;aacute;n seg&amp;uacute;n la definici&amp;oacute;n de esa variable en &lt;code&gt;Lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="960d66936ab81ca5d156bae42ba7e8c239f12236" translate="yes" xml:space="preserve">
          <source>The statistical &lt;em&gt;distribution&lt;/em&gt; from which random samples are drawn &lt;em&gt;is&lt;/em&gt; guaranteed to be the same across any minor Julia releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9b401957be6cef37d6e4c9d1a4d83b1e534a70" translate="yes" xml:space="preserve">
          <source>The stride of the second dimension is the spacing between elements in the same row, skipping as many elements as there are in a single column (&lt;code&gt;5&lt;/code&gt;). Similarly, jumping between the two &quot;pages&quot; (in the third dimension) requires skipping &lt;code&gt;5*7 == 35&lt;/code&gt; elements. The &lt;a href=&quot;../../base/arrays/index#Base.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; of this array is the tuple of these three numbers together:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69251ee5ae969dde76ae7aecf53b32517ef054f" translate="yes" xml:space="preserve">
          <source>The stride should be unit stride.</source>
          <target state="translated">La zancada debe ser una zancada unitaria.</target>
        </trans-unit>
        <trans-unit id="551daadc8e34eb38e96adac58c5a71e00e21218c" translate="yes" xml:space="preserve">
          <source>The string literal could also be used directly before the function name, if desired &lt;code&gt;&quot;libglib-2.0&quot;.g_uri_escape_string(...&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f6cb2eda0183a3a023b5793fbbc533b8630c5f" translate="yes" xml:space="preserve">
          <source>The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;abstract syntax trees&lt;/a&gt;. In contrast, preprocessor &quot;macro&quot; systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; capabilities are available to explore the internals of a program and its types just like any other data.</source>
          <target state="translated">El legado m&amp;aacute;s fuerte de Lisp en el lenguaje de Julia es su soporte de metaprogramaci&amp;oacute;n. Como Lisp, Julia representa su propio c&amp;oacute;digo como una estructura de datos del propio lenguaje. Dado que el c&amp;oacute;digo est&amp;aacute; representado por objetos que se pueden crear y manipular desde dentro del lenguaje, es posible que un programa transforme y genere su propio c&amp;oacute;digo. Esto permite la generaci&amp;oacute;n de c&amp;oacute;digo sofisticado sin pasos de construcci&amp;oacute;n adicionales, y tambi&amp;eacute;n permite verdaderas macros de estilo Lisp que operan al nivel de &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;&amp;aacute;rboles de sintaxis abstractos&lt;/a&gt; . En contraste, los sistemas &quot;macro&quot; de preprocesador, como los de C y C ++, realizan la manipulaci&amp;oacute;n y sustituci&amp;oacute;n textuales antes de que se produzca cualquier an&amp;aacute;lisis o interpretaci&amp;oacute;n real. Dado que todos los tipos de datos y el c&amp;oacute;digo de Julia est&amp;aacute;n representados por estructuras de datos de Julia, la &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflexi&amp;oacute;n de&lt;/a&gt; gran alcance las capacidades est&amp;aacute;n disponibles para explorar las partes internas de un programa y sus tipos como cualquier otro dato.</target>
        </trans-unit>
        <trans-unit id="5e569356ccc37557b3dd3a4c9eb2b13531bfa9b1" translate="yes" xml:space="preserve">
          <source>The subdiagonal part contains the reflectors $v_i$ stored in a packed format such that &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt;.</source>
          <target state="translated">La parte subdiagonal contiene los reflectores $ v_i $ almacenados en un formato empaquetado tal que &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c6aba56e3888ce8991d8adbbc0407169b7c0c0" translate="yes" xml:space="preserve">
          <source>The subdiagonal part contains the reflectors $v_i$ stored in a packed format where $v_i$ is the $i$th column of the matrix &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt;.</source>
          <target state="translated">La parte subdiagonal contiene los reflectores $ v_i $ almacenados en un formato empaquetado donde $ v_i $ es la $ i $ &amp;eacute;sima columna de la matriz &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2a34ecc15f647be67c38e382f5d48daa6d45c2" translate="yes" xml:space="preserve">
          <source>The subscripted &lt;code&gt;rootsᵢ&lt;/code&gt;, &lt;code&gt;graphᵢ&lt;/code&gt; and &lt;code&gt;pathsᵢ&lt;/code&gt; variables correspond to the subscripted environments, &lt;code&gt;envᵢ&lt;/code&gt;, contained in &lt;code&gt;stack&lt;/code&gt;. The &lt;code&gt;reverse&lt;/code&gt; is present because &lt;code&gt;merge&lt;/code&gt; favors the last argument rather than first when there are collisions between keys in its argument dictionaries. There are a couple of noteworthy features of this design:</source>
          <target state="translated">Las &lt;code&gt;rootsᵢ&lt;/code&gt; , &lt;code&gt;graphᵢ&lt;/code&gt; y &lt;code&gt;pathsᵢ&lt;/code&gt; con sub&amp;iacute;ndice corresponden a los entornos con sub&amp;iacute;ndice, &lt;code&gt;envᵢ&lt;/code&gt; , contenidos en la &lt;code&gt;stack&lt;/code&gt; . Lo &lt;code&gt;reverse&lt;/code&gt; est&amp;aacute; presente porque la &lt;code&gt;merge&lt;/code&gt; favorece el &amp;uacute;ltimo argumento en lugar del primero cuando hay colisiones entre claves en sus diccionarios de argumentos. Hay un par de caracter&amp;iacute;sticas notables de este dise&amp;ntilde;o:</target>
        </trans-unit>
        <trans-unit id="996fc71a38fd366e817f73bce0377ef4ace5919b" translate="yes" xml:space="preserve">
          <source>The subtypes of &lt;code&gt;AbstractArray&lt;/code&gt; typically implement two methods to achieve this: A method to convert the input array to a subtype of a specific &lt;code&gt;AbstractArray{T, N}&lt;/code&gt; abstract type; and a method to make a new uninitialized array with a specific element type. Sample implementations of these can be found in Julia Base. Here is a basic example usage of them, guaranteeing that &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; are of the same type:</source>
          <target state="translated">Los subtipos de &lt;code&gt;AbstractArray&lt;/code&gt; generalmente implementan dos m&amp;eacute;todos para lograr esto: Un m&amp;eacute;todo para convertir la matriz de entrada en un subtipo de un tipo &lt;code&gt;AbstractArray{T, N}&lt;/code&gt; espec&amp;iacute;fico ; y un m&amp;eacute;todo para crear una nueva matriz no inicializada con un tipo de elemento espec&amp;iacute;fico. Se pueden encontrar implementaciones de muestra de estos en Julia Base. Aqu&amp;iacute; hay un ejemplo b&amp;aacute;sico de uso de ellos, lo que garantiza que la &lt;code&gt;input&lt;/code&gt; y la &lt;code&gt;output&lt;/code&gt; sean del mismo tipo:</target>
        </trans-unit>
        <trans-unit id="63699aa33be9f33f21d62b86441a8ff8e274be42" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;M.x = y&lt;/code&gt; does not work to assign a global in another module; global assignment is always module-local.</source>
          <target state="translated">La sintaxis &lt;code&gt;M.x = y&lt;/code&gt; no funciona para asignar un global en otro m&amp;oacute;dulo; La asignaci&amp;oacute;n global es siempre local del m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="8aef45ce051e500a72b345ef2f22cdbfc5692cd9" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;[A, B, C, ...]&lt;/code&gt; constructs a 1-d array (i.e., a vector) of its arguments. If all arguments have a common &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;promotion type&lt;/a&gt; then they get converted to that type using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La sintaxis &lt;code&gt;[A, B, C, ...]&lt;/code&gt; construye una matriz 1-d (es decir, un vector) de sus argumentos. Si todos los argumentos tienen un &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;tipo de promoci&amp;oacute;n&lt;/a&gt; com&amp;uacute;n , se convierten a ese tipo mediante &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; ir&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e625bef095d2c8eb72ebaeebbec92f580bcf9df3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;a.b = c&lt;/code&gt; calls &lt;code&gt;setproperty!(a, :b, c)&lt;/code&gt;.</source>
          <target state="translated">La sintaxis &lt;code&gt;a.b = c&lt;/code&gt; llama a &lt;code&gt;setproperty!(a, :b, c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb9de73fee4d35f05a94de3650ba9db8d2743f66" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;a.b&lt;/code&gt; calls &lt;code&gt;getproperty(a, :b)&lt;/code&gt;.</source>
          <target state="translated">La sintaxis &lt;code&gt;a.b&lt;/code&gt; llama a &lt;code&gt;getproperty(a, :b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00608410463d33a3565dc12e2221379a6b79beb5" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;catch e&lt;/code&gt; (where &lt;code&gt;e&lt;/code&gt; is any variable) assigns the thrown exception object to the given variable within the &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="translated">La sintaxis &lt;code&gt;catch e&lt;/code&gt; (donde &lt;code&gt;e&lt;/code&gt; es cualquier variable) asigna el objeto de excepci&amp;oacute;n lanzado a la variable dada dentro del bloque &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaa3305d41b8587b8f7d7509cefad00e6333ecec" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;var&quot;#example#&quot;&lt;/code&gt; refers to a variable named &lt;code&gt;Symbol(&quot;#example#&quot;)&lt;/code&gt;, even though &lt;code&gt;#example#&lt;/code&gt; is not a valid Julia identifier name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbb021dba0d683eea0a7e9eec6250ba19720138f" translate="yes" xml:space="preserve">
          <source>The syntax for images is similar to the link syntax mentioned above. Prepending a &lt;code&gt;!&lt;/code&gt; character to a link will display an image from the specified URL rather than a link to it.</source>
          <target state="translated">La sintaxis de las im&amp;aacute;genes es similar a la sintaxis del enlace mencionada anteriormente. Anteponiendo un &lt;code&gt;!&lt;/code&gt; car&amp;aacute;cter a un enlace mostrar&amp;aacute; una imagen de la URL especificada en lugar de un enlace a ella.</target>
        </trans-unit>
        <trans-unit id="4706abb51ce58ba5921e55c75731359f252d532a" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;remotecall&lt;/code&gt; is not especially convenient. The macro &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; makes things easier. It operates on an expression rather than a function, and picks where to do the operation for you:</source>
          <target state="translated">La sintaxis de &lt;code&gt;remotecall&lt;/code&gt; no es especialmente conveniente. La macro &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; facilita las cosas. Opera en una expresi&amp;oacute;n en lugar de una funci&amp;oacute;n y elige d&amp;oacute;nde realizar la operaci&amp;oacute;n por usted:</target>
        </trans-unit>
        <trans-unit id="e63059505e9b54a2aa7f6f114401eafe55571016" translate="yes" xml:space="preserve">
          <source>The syntaxes &lt;code&gt;A[end]&lt;/code&gt; and &lt;code&gt;A[end, end]&lt;/code&gt; lower to &lt;code&gt;A[lastindex(A)]&lt;/code&gt; and &lt;code&gt;A[lastindex(A, 1), lastindex(A, 2)]&lt;/code&gt;, respectively.</source>
          <target state="translated">Las sintaxis &lt;code&gt;A[end]&lt;/code&gt; y &lt;code&gt;A[end, end]&lt;/code&gt; bajan a &lt;code&gt;A[lastindex(A)]&lt;/code&gt; y &lt;code&gt;A[lastindex(A, 1), lastindex(A, 2)]&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="76ff0041a09cb9e2761ca760c9e89d92dece6223" translate="yes" xml:space="preserve">
          <source>The system also generates some standard information for each event:</source>
          <target state="translated">El sistema también genera cierta información estándar para cada evento:</target>
        </trans-unit>
        <trans-unit id="1291d08b43c51644b75972a68949c78194cf4ab6" translate="yes" xml:space="preserve">
          <source>The system provides several advantages over peppering your source code with calls to &lt;code&gt;println()&lt;/code&gt;. First, it allows you to control the visibility and presentation of messages without editing the source code. For example, in contrast to the &lt;code&gt;@warn&lt;/code&gt; above</source>
          <target state="translated">El sistema ofrece varias ventajas sobre la &lt;code&gt;println()&lt;/code&gt; de salpicado de c&amp;oacute;digo fuente con llamadas a println () . Primero, le permite controlar la visibilidad y presentaci&amp;oacute;n de los mensajes sin editar el c&amp;oacute;digo fuente. Por ejemplo, en contraste con &lt;code&gt;@warn&lt;/code&gt; arriba</target>
        </trans-unit>
        <trans-unit id="35ef5183de88aa885d43235fbe1c95c14449a9c3" translate="yes" xml:space="preserve">
          <source>The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:</source>
          <target state="translated">La tecla de tabulación también puede usarse para sustituir los símbolos matemáticos de LaTeX por sus equivalentes en Unicode,y obtener una lista de coincidencias de LaTeX también:</target>
        </trans-unit>
        <trans-unit id="eeaa0530b289803476c7e7f2356ac443d47f8ecd" translate="yes" xml:space="preserve">
          <source>The ternary operator &lt;code&gt;x &amp;gt; 0 ? 1 : -1&lt;/code&gt; in Julia corresponds to conditional expression in Python &lt;code&gt;1 if x &amp;gt; 0 else -1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4dddfd04ca6f7504094f4bf51ec3f336d04266" translate="yes" xml:space="preserve">
          <source>The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the &lt;a href=&quot;#Footnotes&quot;&gt;Footnotes&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bb24eed2bccbd623888cb79506fd88f02fa796" translate="yes" xml:space="preserve">
          <source>The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the &lt;a href=&quot;#Footnotes-1&quot;&gt;Footnotes&lt;/a&gt; section below.</source>
          <target state="translated">El texto asociado con una nota al pie se puede escribir en cualquier lugar dentro de la misma p&amp;aacute;gina que la referencia de la nota al pie. La sintaxis utilizada para definir el texto de la nota al pie se analiza en la secci&amp;oacute;n &lt;a href=&quot;#Footnotes-1&quot;&gt;Notas&lt;/a&gt; al pie a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="89803a19d844f78ae00674dace9498726fc7f334" translate="yes" xml:space="preserve">
          <source>The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each available in a single composite environment. These composite environments are called &lt;em&gt;environment stacks&lt;/em&gt;. The Julia &lt;code&gt;LOAD_PATH&lt;/code&gt; global defines an environment stack&amp;mdash;the environment in which the Julia process operates. If you want your Julia process to have access only to the packages in one project or package directory, make it the only entry in &lt;code&gt;LOAD_PATH&lt;/code&gt;. It is often quite useful, however, to have access to some of your favorite tools&amp;mdash;standard libraries, profilers, debuggers, personal utilities, etc.&amp;mdash;even if they are not dependencies of the project you're working on. By adding an environment containing these tools to the load path, you immediately have access to them in top-level code without needing to add them to your project.</source>
          <target state="translated">El tercer y &amp;uacute;ltimo tipo de entorno es aquel que combina otros entornos superponiendo varios de ellos, haciendo que los paquetes de cada uno est&amp;eacute;n disponibles en un &amp;uacute;nico entorno compuesto. Estos entornos compuestos se denominan &lt;em&gt;pilas de entornos&lt;/em&gt; . Julia &lt;code&gt;LOAD_PATH&lt;/code&gt; global define una pila de entornos: el entorno en el que opera el proceso de Julia. Si desea que su proceso de Julia tenga acceso solo a los paquetes en un proyecto o directorio de paquetes, &lt;code&gt;LOAD_PATH&lt;/code&gt; en la &amp;uacute;nica entrada en LOAD_PATH. Sin embargo, a menudo es bastante &amp;uacute;til tener acceso a algunas de sus herramientas favoritas (bibliotecas est&amp;aacute;ndar, perfiladores, depuradores, utilidades personales, etc.) incluso si no son dependencias del proyecto en el que est&amp;aacute; trabajando. Al agregar un entorno que contiene estas herramientas a la ruta de carga, inmediatamente tiene acceso a ellas en el c&amp;oacute;digo de nivel superior sin necesidad de agregarlas a su proyecto.</target>
        </trans-unit>
        <trans-unit id="60aabe2463f937334820dc78a19b796fb10a2bf1" translate="yes" xml:space="preserve">
          <source>The third dimension is interesting because its order is reversed! Thus to get from the first &quot;page&quot; to the second one it must go &lt;em&gt;backwards&lt;/em&gt; in memory, and so its stride in this dimension is negative!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5e0709035da59f79f484697f8e3df4d573f5fc" translate="yes" xml:space="preserve">
          <source>The three kinds of types (abstract, primitive, composite) discussed in the previous sections are actually all closely related. They share the same key properties:</source>
          <target state="translated">Los tres tipos (abstracto,primitivo,compuesto)discutidos en las secciones anteriores están en realidad todos estrechamente relacionados.Comparten las mismas propiedades clave:</target>
        </trans-unit>
        <trans-unit id="96a22cbc00a4020163f8bf8451c0cb52f4fe8ed1" translate="yes" xml:space="preserve">
          <source>The three-valued logic described above for logical operators is also used by logical functions applied to arrays. Thus, array equality tests using the &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; operator return &lt;code&gt;missing&lt;/code&gt; whenever the result cannot be determined without knowing the actual value of the &lt;code&gt;missing&lt;/code&gt; entry. In practice, this means that &lt;code&gt;missing&lt;/code&gt; is returned if all non-missing values of the compared arrays are equal, but one or both arrays contain missing values (possibly at different positions)</source>
          <target state="translated">La l&amp;oacute;gica de tres valores descrita anteriormente para los operadores l&amp;oacute;gicos tambi&amp;eacute;n es utilizada por funciones l&amp;oacute;gicas aplicadas a matrices. Por lo tanto, las pruebas de igualdad de matrices que utilizan el operador &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; devuelven &lt;code&gt;missing&lt;/code&gt; cuando el resultado no se puede determinar sin conocer el valor real de la entrada que &lt;code&gt;missing&lt;/code&gt; . En la pr&amp;aacute;ctica, esto significa que se devuelve &lt;code&gt;missing&lt;/code&gt; si todos los valores no perdidos de las matrices comparadas son iguales, pero una o ambas matrices contienen valores perdidos (posiblemente en diferentes posiciones)</target>
        </trans-unit>
        <trans-unit id="705f306c2133309c48bfd3bbe51630bace32d834" translate="yes" xml:space="preserve">
          <source>The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F::Cholesky&lt;/code&gt; via &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb56cdc3790ef15101c199a297fa409d4481928d" translate="yes" xml:space="preserve">
          <source>The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F::CholeskyPivoted&lt;/code&gt; via &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb480c16cbf47fe55bf38e90f5861a483a884fb" translate="yes" xml:space="preserve">
          <source>The tuple must be the same size as the SIMD type. For example, a tuple representing an &lt;code&gt;__m128&lt;/code&gt; on x86 must have a size of 16 bytes.</source>
          <target state="translated">La tupla debe tener el mismo tama&amp;ntilde;o que el tipo SIMD. Por ejemplo, una tupla que represente un &lt;code&gt;__m128&lt;/code&gt; en x86 debe tener un tama&amp;ntilde;o de 16 bytes.</target>
        </trans-unit>
        <trans-unit id="d71d89013d2d694c3c90bff3726394654345117f" translate="yes" xml:space="preserve">
          <source>The two expressions constructed above &amp;ndash; by parsing and by direct construction &amp;ndash; are equivalent:</source>
          <target state="translated">Las dos expresiones construidas anteriormente, mediante an&amp;aacute;lisis sint&amp;aacute;ctico y construcci&amp;oacute;n directa, son equivalentes:</target>
        </trans-unit>
        <trans-unit id="3b3360fde4989c6fe95a691dce2016abf50d9177" translate="yes" xml:space="preserve">
          <source>The two uses of the &lt;code&gt;...&lt;/code&gt; operator: slurping and splatting</source>
          <target state="translated">Los dos usos del &lt;code&gt;...&lt;/code&gt; operador: sorber y salpicar</target>
        </trans-unit>
        <trans-unit id="b96a5c8aeea4ce2a16e47711028fe9eaf98f3763" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Point{Float64}&lt;/code&gt; is a point whose coordinates are 64-bit floating-point values, while the type &lt;code&gt;Point{AbstractString}&lt;/code&gt; is a &quot;point&quot; whose &quot;coordinates&quot; are string objects (see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Strings&lt;/a&gt;).</source>
          <target state="translated">El tipo &lt;code&gt;Point{Float64}&lt;/code&gt; es un punto cuyas coordenadas son valores de punto flotante de 64 bits, mientras que el tipo &lt;code&gt;Point{AbstractString}&lt;/code&gt; es un &quot;punto&quot; cuyas &quot;coordenadas&quot; son objetos de cadena (ver &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Cadenas&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d40d9987e4be3343cc1ff7a67bcd2a4182159aca" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Point{Float64}&lt;/code&gt; is a point whose coordinates are 64-bit floating-point values, while the type &lt;code&gt;Point{AbstractString}&lt;/code&gt; is a &quot;point&quot; whose &quot;coordinates&quot; are string objects (see &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/ast/#Strings&quot;&gt;Strings&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7369108ecd55df4b36265309c9d17ce4d10c19" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;NTuple{N,T}&lt;/code&gt; is a convenient alias for &lt;code&gt;Tuple{Vararg{T,N}}&lt;/code&gt;, i.e. a tuple type containing exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponde a exactamente &lt;code&gt;N&lt;/code&gt; elementos de tipo &lt;code&gt;T&lt;/code&gt; . &lt;code&gt;NTuple{N,T}&lt;/code&gt; es un alias conveniente para &lt;code&gt;Tuple{Vararg{T,N}}&lt;/code&gt; , es decir, un tipo tupla que contiene exactamente &lt;code&gt;N&lt;/code&gt; elementos de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bedae316814d6156803443fcc9c13d8c64877a4" translate="yes" xml:space="preserve">
          <source>The type annotation partially recovers lost performance due to capturing because the parser can associate a concrete type to the object in the box. Going further, if the captured variable does not need to be boxed at all (because it will not be reassigned after the closure is created), this can be indicated with &lt;code&gt;let&lt;/code&gt; blocks as follows.</source>
          <target state="translated">La anotaci&amp;oacute;n de tipo recupera parcialmente el rendimiento perdido debido a la captura porque el analizador puede asociar un tipo concreto al objeto en el cuadro. Yendo m&amp;aacute;s all&amp;aacute;, si la variable capturada no necesita estar encuadrada en absoluto (porque no se reasignar&amp;aacute; despu&amp;eacute;s de que se cree el cierre), esto se puede indicar con bloques &lt;code&gt;let&lt;/code&gt; de la siguiente manera.</target>
        </trans-unit>
        <trans-unit id="6fbcbd4db01a84d712a7283dfeb43aba8b033041" translate="yes" xml:space="preserve">
          <source>The type application syntax &lt;code&gt;A{B,C}&lt;/code&gt; requires &lt;code&gt;A&lt;/code&gt; to be a &lt;code&gt;UnionAll&lt;/code&gt; type, and first substitutes &lt;code&gt;B&lt;/code&gt; for the outermost type variable in &lt;code&gt;A&lt;/code&gt;. The result is expected to be another &lt;code&gt;UnionAll&lt;/code&gt; type, into which &lt;code&gt;C&lt;/code&gt; is then substituted. So &lt;code&gt;A{B,C}&lt;/code&gt; is equivalent to &lt;code&gt;A{B}{C}&lt;/code&gt;. This explains why it is possible to partially instantiate a type, as in &lt;code&gt;Array{Float64}&lt;/code&gt;: the first parameter value has been fixed, but the second still ranges over all possible values. Using explicit &lt;code&gt;where&lt;/code&gt; syntax, any subset of parameters can be fixed. For example, the type of all 1-dimensional arrays can be written as &lt;code&gt;Array{T,1} where T&lt;/code&gt;.</source>
          <target state="translated">La sintaxis de aplicaci&amp;oacute;n de tipo &lt;code&gt;A{B,C}&lt;/code&gt; requiere &lt;code&gt;A&lt;/code&gt; ser un &lt;code&gt;UnionAll&lt;/code&gt; tipo, y primeros sustitutos &lt;code&gt;B&lt;/code&gt; para la variable de tipo m&amp;aacute;s exterior en &lt;code&gt;A&lt;/code&gt; . Se espera que el resultado sea otro tipo &lt;code&gt;UnionAll&lt;/code&gt; , en el que luego se sustituye &lt;code&gt;C&lt;/code&gt; . Entonces &lt;code&gt;A{B,C}&lt;/code&gt; es equivalente a &lt;code&gt;A{B}{C}&lt;/code&gt; . Esto explica por qu&amp;eacute; es posible instanciar parcialmente un tipo, como en &lt;code&gt;Array{Float64}&lt;/code&gt; : el primer valor de par&amp;aacute;metro ha sido fijo, pero el segundo a&amp;uacute;n abarca todos los valores posibles. Usando expl&amp;iacute;cito &lt;code&gt;where&lt;/code&gt; sintaxis, cualquier subconjunto de par&amp;aacute;metros puede ser fijo. Por ejemplo, el tipo de todas las matrices de 1-dimensionales se puede escribir como &lt;code&gt;Array{T,1} where T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffb66b4dabff5050a74ff3cadfb7762c384071e4" translate="yes" xml:space="preserve">
          <source>The type arguments to &lt;code&gt;ccall&lt;/code&gt; and &lt;code&gt;@cfunction&lt;/code&gt; are evaluated statically, when the method containing the usage is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.</source>
          <target state="translated">Los argumentos de tipo para &lt;code&gt;ccall&lt;/code&gt; y &lt;code&gt;@cfunction&lt;/code&gt; se eval&amp;uacute;an est&amp;aacute;ticamente, cuando se define el m&amp;eacute;todo que contiene el uso. Por lo tanto, deben tomar la forma de una tupla literal, no una variable, y no pueden hacer referencia a variables locales.</target>
        </trans-unit>
        <trans-unit id="1a668fb8c29cba9ffa772e3e0ec9a1a70c5fa795" translate="yes" xml:space="preserve">
          <source>The type is an &lt;code&gt;Array{T,N}&lt;/code&gt; with a bits-type element of &lt;code&gt;T&lt;/code&gt; and dimension &lt;code&gt;N&lt;/code&gt; that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).</source>
          <target state="translated">El tipo es una &lt;code&gt;Array{T,N}&lt;/code&gt; con un elemento de tipo bits de &lt;code&gt;T&lt;/code&gt; y dimensi&amp;oacute;n &lt;code&gt;N&lt;/code&gt; que determina c&amp;oacute;mo se interpretan los bytes de la matriz. Tenga en cuenta que el archivo debe almacenarse en formato binario y no es posible realizar conversiones de formato (esta es una limitaci&amp;oacute;n de los sistemas operativos, no de Julia).</target>
        </trans-unit>
        <trans-unit id="e499662e725cd499be9193549f691bff7a5c084f" translate="yes" xml:space="preserve">
          <source>The type of exception thrown when an error occurs in DNS lookup. The &lt;code&gt;host&lt;/code&gt; field indicates the host URL string. The &lt;code&gt;code&lt;/code&gt; field indicates the error code based on libuv.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5dd90cb0f8495d6d15c26b83250961e3145b2f" translate="yes" xml:space="preserve">
          <source>The type of field &lt;code&gt;a&lt;/code&gt; can be readily determined from the type of &lt;code&gt;m&lt;/code&gt;, but not from the type of &lt;code&gt;t&lt;/code&gt;. Indeed, in &lt;code&gt;t&lt;/code&gt; it's possible to change the type of the field &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">El tipo de campo &lt;code&gt;a&lt;/code&gt; se puede determinar f&amp;aacute;cilmente a partir del tipo de &lt;code&gt;m&lt;/code&gt; , pero no a partir del tipo de &lt;code&gt;t&lt;/code&gt; . De hecho, en &lt;code&gt;t&lt;/code&gt; es posible cambiar el tipo de campo &lt;code&gt;a&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="282394fd5d6e1d690607a98e995ab7809b63cd8e" translate="yes" xml:space="preserve">
          <source>The type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). &lt;code&gt;Symbol&lt;/code&gt;s can be entered using the &lt;code&gt;:&lt;/code&gt; quote operator:</source>
          <target state="translated">El tipo de objeto utilizado para representar identificadores en c&amp;oacute;digo julia analizado (AST). Tambi&amp;eacute;n se utiliza a menudo como nombre o etiqueta para identificar una entidad (por ejemplo, como clave de diccionario). &lt;code&gt;Symbol&lt;/code&gt; s se puede introducir mediante el &lt;code&gt;:&lt;/code&gt; operador comilla:</target>
        </trans-unit>
        <trans-unit id="82012051565c5ddd98325c85c6b81ed88d932dea" translate="yes" xml:space="preserve">
          <source>The type of the admonition can be any word made up of only lowercase Latin characters (a-z), but some types produce special styling, namely (in order of decreasing severity): &lt;code&gt;danger&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;note&lt;/code&gt;, and &lt;code&gt;tip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d435d74348a381158dd6b8006d6bf402fcef60" translate="yes" xml:space="preserve">
          <source>The type of the admonition can be any word, but some types produce special styling, namely (in order of decreasing severity): &lt;code&gt;danger&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;/&lt;code&gt;note&lt;/code&gt;, and &lt;code&gt;tip&lt;/code&gt;.</source>
          <target state="translated">El tipo de advertencia puede ser cualquier palabra, pero algunos tipos producen un estilo especial, a saber (en orden de gravedad decreciente): &lt;code&gt;danger&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , &lt;code&gt;info&lt;/code&gt; rmaci&amp;oacute;n / &lt;code&gt;note&lt;/code&gt; y &lt;code&gt;tip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4848f4198d788d8fa0ad8db3a3e5d610c5797c10" translate="yes" xml:space="preserve">
          <source>The type of the first argument of this method is a &lt;a href=&quot;../types/index#man-singleton-types&quot;&gt;singleton type&lt;/a&gt;, &lt;code&gt;Type{MyType}&lt;/code&gt;, the only instance of which is &lt;code&gt;MyType&lt;/code&gt;. Thus, this method is only invoked when the first argument is the type value &lt;code&gt;MyType&lt;/code&gt;. Notice the syntax used for the first argument: the argument name is omitted prior to the &lt;code&gt;::&lt;/code&gt; symbol, and only the type is given. This is the syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced by name. In this example, since the type is a singleton, we already know its value without referring to an argument name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95cde77f6d397a5966075de74e297cbf03487660" translate="yes" xml:space="preserve">
          <source>The type of the first argument of this method is a &lt;a href=&quot;../types/index#man-singleton-types-1&quot;&gt;singleton type&lt;/a&gt;, &lt;code&gt;Type{MyType}&lt;/code&gt;, the only instance of which is &lt;code&gt;MyType&lt;/code&gt;. Thus, this method is only invoked when the first argument is the type value &lt;code&gt;MyType&lt;/code&gt;. Notice the syntax used for the first argument: the argument name is omitted prior to the &lt;code&gt;::&lt;/code&gt; symbol, and only the type is given. This is the syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced by name. In this example, since the type is a singleton, we already know its value without referring to an argument name.</source>
          <target state="translated">El tipo del primer argumento de este m&amp;eacute;todo es un &lt;a href=&quot;../types/index#man-singleton-types-1&quot;&gt;tipo singleton&lt;/a&gt; , &lt;code&gt;Type{MyType}&lt;/code&gt; , cuya &amp;uacute;nica instancia es &lt;code&gt;MyType&lt;/code&gt; . Por lo tanto, este m&amp;eacute;todo solo se invoca cuando el primer argumento es el valor de tipo &lt;code&gt;MyType&lt;/code&gt; . Observe la sintaxis utilizada para el primer argumento: el nombre del argumento se omite antes del s&amp;iacute;mbolo &lt;code&gt;::&lt;/code&gt; y solo se proporciona el tipo. Esta es la sintaxis en Julia para un argumento de funci&amp;oacute;n cuyo tipo se especifica pero cuyo valor no necesita ser referenciado por su nombre. En este ejemplo, dado que el tipo es un singleton, ya conocemos su valor sin hacer referencia a un nombre de argumento.</target>
        </trans-unit>
        <trans-unit id="3cdf4225b7d8119f12b6f1e72fd124d403b4e26b" translate="yes" xml:space="preserve">
          <source>The type of the first entry of the tuple returned by &lt;code&gt;iterate()&lt;/code&gt;</source>
          <target state="translated">El tipo de la primera entrada de la tupla devuelta por &lt;code&gt;iterate()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa022df5697534e05992976fa7f76aa1feeee08" translate="yes" xml:space="preserve">
          <source>The types &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; all have identical representations: they are eight-bit chunks of memory. Since Julia's type system is nominative, however, they are not interchangeable despite having identical structure. A fundamental difference between them is that they have different supertypes: &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;'s direct supertype is &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;'s is &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;'s is &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt;. All other differences between &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; are matters of behavior &amp;ndash; the way functions are defined to act when given objects of these types as arguments. This is why a nominative type system is necessary: if structure determined type, which in turn dictates behavior, then it would be impossible to make &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; behave any differently than &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Los tipos &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; tienen representaciones id&amp;eacute;nticas: son trozos de memoria de ocho bits. Dado que el sistema de tipos de Julia es nominativo, sin embargo, no son intercambiables a pesar de tener una estructura id&amp;eacute;ntica. Una diferencia fundamental entre ellos es que tienen diferentes supertipos: el &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; directo de Bool es &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; , el de &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; est&amp;aacute; &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt; y el de &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; es &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt; . Todas las dem&amp;aacute;s diferencias entre &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;son cuestiones de comportamiento: la forma en que se definen las funciones para actuar cuando se les dan objetos de estos tipos como argumentos. Por eso es necesario un sistema de tipos nominativos: si la estructura determina el tipo, que a su vez dicta el comportamiento, ser&amp;iacute;a imposible hacer que &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; se&lt;/a&gt; comporte de manera diferente a &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0109db562376dbf272015811ad8745f34d0c123" translate="yes" xml:space="preserve">
          <source>The types of keyword arguments can be made explicit as follows:</source>
          <target state="translated">Los tipos de argumentos de las palabras clave pueden hacerse explícitos de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="677137168efdb765c37514f4c028e99760d5566b" translate="yes" xml:space="preserve">
          <source>The typical Julia workflow for prototyping also uses continuous manipulation of the image, implemented with the &lt;a href=&quot;https://github.com/timholy/Revise.jl&quot;&gt;Revise.jl&lt;/a&gt; package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150a26f4f49fe87245564e04ceb960fcfbaf40b2" translate="yes" xml:space="preserve">
          <source>The unary operators &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; require explicit parentheses around their argument to disambiguate them from the operator &lt;code&gt;++&lt;/code&gt;, etc. Other compositions of unary operators are parsed with right-associativity, e. g., &lt;code&gt;&amp;radic;&amp;radic;-a&lt;/code&gt; as &lt;code&gt;&amp;radic;(&amp;radic;(-a))&lt;/code&gt;.</source>
          <target state="translated">Los operadores unarios &lt;code&gt;+&lt;/code&gt; y &lt;code&gt;-&lt;/code&gt; requieren par&amp;eacute;ntesis expl&amp;iacute;citos alrededor de su argumento para &lt;code&gt;&amp;radic;&amp;radic;-a&lt;/code&gt; del operador &lt;code&gt;++&lt;/code&gt; , etc. Otras composiciones de operadores unarios se analizan con asociatividad por la derecha, por ejemplo, &amp;radic;&amp;radic;-a como &lt;code&gt;&amp;radic;(&amp;radic;(-a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6715363fde6cdd7a1a24ce6e74d2c35a82ab804" translate="yes" xml:space="preserve">
          <source>The underscore &lt;code&gt;_&lt;/code&gt; can be used as digit separator:</source>
          <target state="translated">El gui&amp;oacute;n bajo &lt;code&gt;_&lt;/code&gt; se puede utilizar como separador de d&amp;iacute;gitos:</target>
        </trans-unit>
        <trans-unit id="5dc9c5b98b8ad88332e71a97e793e826e1cab445" translate="yes" xml:space="preserve">
          <source>The uniform scaling operator</source>
          <target state="translated">El operador de escalada uniforme</target>
        </trans-unit>
        <trans-unit id="37b7ee86ac667d6f86c0ad3037e31cb90445aa51" translate="yes" xml:space="preserve">
          <source>The updating versions of all the binary arithmetic and bitwise operators are:</source>
          <target state="translated">Las versiones de actualización de todos los operadores de aritmética binaria y de bits son:</target>
        </trans-unit>
        <trans-unit id="1cf2be628194a336d3bbb72bed6445464a756995" translate="yes" xml:space="preserve">
          <source>The upper triangular part contains the elements of $R$, that is &lt;code&gt;R = triu(F.factors)&lt;/code&gt; for a &lt;code&gt;QR&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">La parte triangular superior contiene los elementos de $ R $, que es &lt;code&gt;R = triu(F.factors)&lt;/code&gt; para un &lt;code&gt;QR&lt;/code&gt; objeto &lt;code&gt;F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b49169c7561890a28f7d592fadc2b06ce72bef8" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;$&lt;/code&gt; for expression interpolation is intentionally reminiscent of &lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;string interpolation&lt;/a&gt; and &lt;a href=&quot;../running-external-programs/index#command-interpolation&quot;&gt;command interpolation&lt;/a&gt;. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="227320fa312076c32b3808304d06cb30fbcb2399" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;$&lt;/code&gt; for expression interpolation is intentionally reminiscent of &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; and &lt;a href=&quot;../running-external-programs/index#command-interpolation-1&quot;&gt;command interpolation&lt;/a&gt;. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.</source>
          <target state="translated">El uso de &lt;code&gt;$&lt;/code&gt; para la interpolaci&amp;oacute;n de expresiones recuerda intencionalmente a la &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;interpolaci&amp;oacute;n&lt;/a&gt; de cadenas y la &lt;a href=&quot;../running-external-programs/index#command-interpolation-1&quot;&gt;interpolaci&amp;oacute;n de comandos&lt;/a&gt; . La interpolaci&amp;oacute;n de expresiones permite la construcci&amp;oacute;n program&amp;aacute;tica conveniente y legible de expresiones complejas de Julia.</target>
        </trans-unit>
        <trans-unit id="414780375a6643e2453e6d8634fae95c5ade2420" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;#return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt; keyword is exactly the same as in other languages, but is often optional. A function without an explicit &lt;code&gt;return&lt;/code&gt; statement will return the last expression in the function body.</source>
          <target state="translated">El uso de la palabra clave &lt;a href=&quot;#return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; es exactamente el mismo que en otros idiomas, pero a menudo es opcional. Una funci&amp;oacute;n sin una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; expl&amp;iacute;cita devolver&amp;aacute; la &amp;uacute;ltima expresi&amp;oacute;n en el cuerpo de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a2d597104e09bc0cd5d3b4e8b871fd483fedc685" translate="yes" xml:space="preserve">
          <source>The user id of the owner of the file</source>
          <target state="translated">La identificación de usuario del propietario del archivo</target>
        </trans-unit>
        <trans-unit id="6c6699f50d2afb2e82521e06f95a5e242ef5260f" translate="yes" xml:space="preserve">
          <source>The usual representation of a &lt;code&gt;quote&lt;/code&gt; form in an AST is an &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; with head &lt;code&gt;:quote&lt;/code&gt;:</source>
          <target state="translated">La representaci&amp;oacute;n habitual de un formulario de &lt;code&gt;quote&lt;/code&gt; en un AST es un &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; con encabezado &lt;code&gt;:quote&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="35f0445ac7033162f95af7dffff6b9386fa1de30" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a&lt;/code&gt; is used to construct the expression &lt;code&gt;ex&lt;/code&gt; which applies the &lt;code&gt;+&lt;/code&gt; function to the value 1 and the variable &lt;code&gt;b&lt;/code&gt;. Note the important distinction between the way &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are used:</source>
          <target state="translated">El valor de &lt;code&gt;a&lt;/code&gt; se usa para construir la expresi&amp;oacute;n &lt;code&gt;ex&lt;/code&gt; que aplica la funci&amp;oacute;n &lt;code&gt;+&lt;/code&gt; al valor 1 y la variable &lt;code&gt;b&lt;/code&gt; . Tenga en cuenta la importante distinci&amp;oacute;n entre la forma en que &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; se utilizan:</target>
        </trans-unit>
        <trans-unit id="62de8f816c4cc9e366c76d8b6179874f1c02891f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is only valid immediately after a &lt;code&gt;ccall&lt;/code&gt; to a C library routine that sets it. Specifically, you cannot call &lt;code&gt;errno&lt;/code&gt; at the next prompt in a REPL, because lots of code is executed between prompts.</source>
          <target state="translated">El valor de &lt;code&gt;errno&lt;/code&gt; solo es v&amp;aacute;lido inmediatamente despu&amp;eacute;s de una &lt;code&gt;ccall&lt;/code&gt; a una rutina de la biblioteca C que lo establece. Espec&amp;iacute;ficamente, no puede llamar a &lt;code&gt;errno&lt;/code&gt; en el siguiente indicador de un REPL, porque se ejecuta una gran cantidad de c&amp;oacute;digo entre los mensajes.</target>
        </trans-unit>
        <trans-unit id="aa580957fe65ae6ff4c7a945625a32e87a3c4957" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;variable&lt;/em&gt;&lt;code&gt;a&lt;/code&gt; at expression construction time is used as an immediate value in the expression. Thus, the value of &lt;code&gt;a&lt;/code&gt; when the expression is evaluated no longer matters: the value in the expression is already &lt;code&gt;1&lt;/code&gt;, independent of whatever the value of &lt;code&gt;a&lt;/code&gt; might be.</source>
          <target state="translated">El valor de la &lt;em&gt;variable &lt;/em&gt; &lt;code&gt;a&lt;/code&gt; en el momento de la construcci&amp;oacute;n de la expresi&amp;oacute;n se utiliza como valor inmediato en la expresi&amp;oacute;n. Por lo tanto, el valor de &lt;code&gt;a&lt;/code&gt; cuando se eval&amp;uacute;a la expresi&amp;oacute;n ya no importa: el valor de la expresi&amp;oacute;n ya es &lt;code&gt;1&lt;/code&gt; , independientemente de lo que sea el valor de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62fc47d335f1e7570e2269aaa97a12567b02a166" translate="yes" xml:space="preserve">
          <source>The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, &lt;code&gt;f&lt;/code&gt;, from the previous section this is the value of the expression &lt;code&gt;x + y&lt;/code&gt;. As an alternative, as in many other languages, the &lt;code&gt;return&lt;/code&gt; keyword causes a function to return immediately, providing an expression whose value is returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9712274625a8ada140a13908f35f8b798b923a70" translate="yes" xml:space="preserve">
          <source>The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, &lt;code&gt;f&lt;/code&gt;, from the previous section this is the value of the expression &lt;code&gt;x + y&lt;/code&gt;. As in C and most other imperative or functional languages, the &lt;code&gt;return&lt;/code&gt; keyword causes a function to return immediately, providing an expression whose value is returned:</source>
          <target state="translated">El valor devuelto por una funci&amp;oacute;n es el valor de la &amp;uacute;ltima expresi&amp;oacute;n evaluada, que, por defecto, es la &amp;uacute;ltima expresi&amp;oacute;n en el cuerpo de la definici&amp;oacute;n de funci&amp;oacute;n. En la funci&amp;oacute;n de ejemplo, &lt;code&gt;f&lt;/code&gt; , de la secci&amp;oacute;n anterior, este es el valor de la expresi&amp;oacute;n &lt;code&gt;x + y&lt;/code&gt; . Como en C y la mayor&amp;iacute;a de los otros lenguajes imperativos o funcionales, la palabra clave &lt;code&gt;return&lt;/code&gt; hace que una funci&amp;oacute;n regrese inmediatamente, proporcionando una expresi&amp;oacute;n cuyo valor se devuelve:</target>
        </trans-unit>
        <trans-unit id="c36bf156fd24214b4253de2ab2fb9c5aaef1f580" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field &lt;code&gt;a&lt;/code&gt;, the fact that the memory representation of a &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; differs from a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.</source>
          <target state="translated">Los valores de &lt;code&gt;b&lt;/code&gt; y &lt;code&gt;c&lt;/code&gt; tienen el mismo tipo, sin embargo, su representaci&amp;oacute;n subyacente de los datos en la memoria es muy diferente. Incluso si almacen&amp;oacute; solo valores num&amp;eacute;ricos en el campo &lt;code&gt;a&lt;/code&gt; , el hecho de que la representaci&amp;oacute;n en memoria de un &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; difiera de un &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n significa que la CPU necesita manejarlos usando dos tipos diferentes de instrucciones. Dado que la informaci&amp;oacute;n requerida no est&amp;aacute; disponible en el tipo, tales decisiones deben tomarse en tiempo de ejecuci&amp;oacute;n. Esto ralentiza el rendimiento.</target>
        </trans-unit>
        <trans-unit id="9433ae585b495873d9d9e9fc1681dd7a34a786cf" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; are always of the given argument type. (The above expression uses several features that have yet to be introduced, including &lt;a href=&quot;../control-flow/index#man-loops&quot;&gt;for loops&lt;/a&gt;, &lt;a href=&quot;../strings/index#man-strings&quot;&gt;Strings&lt;/a&gt;, and &lt;a href=&quot;../strings/index#string-interpolation&quot;&gt;Interpolation&lt;/a&gt;, but should be easy enough to understand for users with some existing programming experience.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8485dbcd7c0bda629f4ab2a94790ee6bae11f052" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; are always of the given argument type. (The above expression uses several features that have yet to be introduced, including &lt;a href=&quot;../control-flow/index#man-loops-1&quot;&gt;for loops&lt;/a&gt;, &lt;a href=&quot;../strings/index#man-strings-1&quot;&gt;Strings&lt;/a&gt;, and &lt;a href=&quot;../metaprogramming/index#Interpolation-1&quot;&gt;Interpolation&lt;/a&gt;, but should be easy enough to understand for users with some existing programming experience.)</source>
          <target state="translated">Los valores devueltos por &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt; son siempre del tipo de argumento dado. (La expresi&amp;oacute;n anterior usa varias caracter&amp;iacute;sticas que a&amp;uacute;n no se han introducido, incluidos &lt;a href=&quot;../control-flow/index#man-loops-1&quot;&gt;bucles for&lt;/a&gt; , &lt;a href=&quot;../strings/index#man-strings-1&quot;&gt;cadenas&lt;/a&gt; e &lt;a href=&quot;../metaprogramming/index#Interpolation-1&quot;&gt;interpolaci&amp;oacute;n&lt;/a&gt; , pero deber&amp;iacute;a ser lo suficientemente f&amp;aacute;cil de entender para los usuarios con cierta experiencia en programaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="10056f49c16766ab5a7d038814128061f1bc2774" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;relation&lt;/code&gt; is declared inside the &lt;code&gt;if&lt;/code&gt; block, but used outside. However, when depending on this behavior, make sure all possible code paths define a value for the variable. The following change to the above function results in a runtime error</source>
          <target state="translated">La &lt;code&gt;relation&lt;/code&gt; variable se declara dentro del bloque &lt;code&gt;if&lt;/code&gt; , pero se usa fuera. Sin embargo, cuando dependa de este comportamiento, aseg&amp;uacute;rese de que todas las rutas de c&amp;oacute;digo posibles definan un valor para la variable. El siguiente cambio en la funci&amp;oacute;n anterior da como resultado un error de tiempo de ejecuci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="67a867d229f7011e541a374fedf8ebf1c9e53637" translate="yes" xml:space="preserve">
          <source>The variable bound defaults to &lt;a href=&quot;#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; if it is omitted:</source>
          <target state="translated">La variable enlazada tiene como valor predeterminado &lt;a href=&quot;#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; si se omite:</target>
        </trans-unit>
        <trans-unit id="e448ca292ee1dbe02f872083148deaa835508c61" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are bound to the first two argument values as usual, and the variable &lt;code&gt;x&lt;/code&gt; is bound to an iterable collection of the zero or more values passed to &lt;code&gt;bar&lt;/code&gt; after its first two arguments:</source>
          <target state="translated">Las variables &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; est&amp;aacute;n unidos a los dos primeros valores de los argumentos, como de costumbre, y la variable &lt;code&gt;x&lt;/code&gt; se une a una colecci&amp;oacute;n iterable de las cero o m&amp;aacute;s valores pasados a &lt;code&gt;bar&lt;/code&gt; despu&amp;eacute;s de sus primeros dos argumentos:</target>
        </trans-unit>
        <trans-unit id="4a9e1ff901c13ad87d154ae8aa5cd1e9d49a1456" translate="yes" xml:space="preserve">
          <source>The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be used for any applicable arguments to a function.</source>
          <target state="translated">La inmensa mayoría de las funciones no aceptará todos los tipos de argumentos enumerados anteriormente;los números denotan simplemente la precedencia que debe utilizarse para cualquier argumento aplicable a una función.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
