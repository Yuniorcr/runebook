<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="9cf1660ad8de659f871c4cde9fc066e87eb4f30f" translate="yes" xml:space="preserve">
          <source>For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its &quot;values&quot;.</source>
          <target state="translated">Para un iterador o colección que tiene claves y valores,devuelve un iterador sobre los valores.Esta función simplemente devuelve su argumento por defecto,ya que los elementos de un iterador general se consideran normalmente sus &quot;valores&quot;.</target>
        </trans-unit>
        <trans-unit id="95a50cf1c996d77537f503b2b0ab2ae143d3ab0c" translate="yes" xml:space="preserve">
          <source>For an out-of-place version, see &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;. For algorithmic information, see &lt;code&gt;fkeep!&lt;/code&gt;.</source>
          <target state="translated">Para obtener una versi&amp;oacute;n fuera de lugar, consulte &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; &lt;/a&gt; . Para obtener informaci&amp;oacute;n algor&amp;iacute;tmica, consulte &lt;code&gt;fkeep!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9698467f9f9a26107005e5cc7d8c52ec73e6fba" translate="yes" xml:space="preserve">
          <source>For an overview of why functions like &lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt;&lt;code&gt;hypot&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt;&lt;code&gt;expm1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; are necessary and useful, see John D. Cook's excellent pair of blog posts on the subject: &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1, log1p, erfc&lt;/a&gt;, and &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot&lt;/a&gt;.</source>
          <target state="translated">Para una visi&amp;oacute;n general de qu&amp;eacute; funciones como &lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt; &lt;code&gt;hypot&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt; &lt;code&gt;expm1&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; son necesarias y &amp;uacute;tiles, v&amp;eacute;ase el excelente par de entradas de blog de John D. Cook sobre el tema: &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1, log1p, ERFC&lt;/a&gt; y &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d80c08b4c206c014a1c8f4dd0759aa7c625fa2a" translate="yes" xml:space="preserve">
          <source>For any iterable container &lt;code&gt;A&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;norm&lt;/code&gt; is defined), compute the &lt;code&gt;p&lt;/code&gt;-norm (defaulting to &lt;code&gt;p=2&lt;/code&gt;) as if &lt;code&gt;A&lt;/code&gt; were a vector of the corresponding length.</source>
          <target state="translated">Para cualquier contenedor iterable &lt;code&gt;A&lt;/code&gt; (incluyendo matrices de cualquier dimensi&amp;oacute;n) de n&amp;uacute;meros (o cualquier tipo de elemento para el cual se define la &lt;code&gt;norm&lt;/code&gt; a ), calcule la &lt;code&gt;p&lt;/code&gt; -norm (por defecto ap &lt;code&gt;p=2&lt;/code&gt; ) como si &lt;code&gt;A&lt;/code&gt; fuera un vector de la longitud correspondiente.</target>
        </trans-unit>
        <trans-unit id="a3a03065c6c3f77db333198b92d9783df8912cc7" translate="yes" xml:space="preserve">
          <source>For any iterable containers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;dot&lt;/code&gt; is defined), compute the dot product (or inner product or scalar product), i.e. the sum of &lt;code&gt;dot(x[i],y[i])&lt;/code&gt;, as if they were vectors.</source>
          <target state="translated">Para cualquier contenedores iterables &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; (incluyendo matrices de cualquier dimensi&amp;oacute;n) de n&amp;uacute;meros (o cualquier tipo de elemento para el que &lt;code&gt;dot&lt;/code&gt; se define), calcular el producto escalar (o producto interior o producto escalar), es decir la suma de &lt;code&gt;dot(x[i],y[i])&lt;/code&gt; , como si fueran vectores.</target>
        </trans-unit>
        <trans-unit id="9861c33db5cb32a638bd7ed95113f331a3454eb4" translate="yes" xml:space="preserve">
          <source>For any keywords that are not specified, the current settings from &lt;code&gt;cmd&lt;/code&gt; are used. Normally, to create a &lt;code&gt;Cmd&lt;/code&gt; object in the first place, one uses backticks, e.g.</source>
          <target state="translated">Para cualquier palabra clave que no est&amp;eacute; especificada, se usa la configuraci&amp;oacute;n actual de &lt;code&gt;cmd&lt;/code&gt; . Normalmente, para crear un objeto &lt;code&gt;Cmd&lt;/code&gt; en primer lugar, se usan comillas invertidas, por ejemplo</target>
        </trans-unit>
        <trans-unit id="85d14ad6a0f26364153773489f0db13bfaafa53f" translate="yes" xml:space="preserve">
          <source>For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to &lt;code&gt;length(A)&lt;/code&gt;. However, for &lt;code&gt;AbstractVector&lt;/code&gt;s linear indices are &lt;code&gt;axes(A, 1)&lt;/code&gt;, and therefore do not start at 1 for vectors with unconventional indexing.</source>
          <target state="translated">Para matrices con indexaci&amp;oacute;n convencional (los &amp;iacute;ndices comienzan en 1), o cualquier matriz multidimensional, los &amp;iacute;ndices lineales van desde 1 hasta la &lt;code&gt;length(A)&lt;/code&gt; . Sin embargo, para &lt;code&gt;AbstractVector&lt;/code&gt; s, los &amp;iacute;ndices lineales son &lt;code&gt;axes(A, 1)&lt;/code&gt; y, por lo tanto, no comienzan en 1 para vectores con indexaci&amp;oacute;n no convencional.</target>
        </trans-unit>
        <trans-unit id="81f6c2e801b1d9455cd3aa8ac3e88e840497dca8" translate="yes" xml:space="preserve">
          <source>For arrays, returns a string of size and type info, e.g. &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt;.</source>
          <target state="translated">Para matrices, devuelve una cadena de informaci&amp;oacute;n de tama&amp;ntilde;o y tipo, por ejemplo, &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06562c8550b5e93a013f75fd29118d4c0694a02a" translate="yes" xml:space="preserve">
          <source>For arrays, this function requires at least Julia 1.2.</source>
          <target state="translated">Para las matrices,esta función requiere al menos Julia 1.2.</target>
        </trans-unit>
        <trans-unit id="d3e36f74f84aea73dce8e8117a1733e018408eb9" translate="yes" xml:space="preserve">
          <source>For bits types this means that the bit pattern of a value once set will never change and that value is the identity of a bits type.</source>
          <target state="translated">Para los tipos de bits esto significa que el patrón de bits de un valor una vez establecido nunca cambiará y ese valor es la identidad de un tipo de bits.</target>
        </trans-unit>
        <trans-unit id="7aee08c8ffda1f859a18b6cbf5bd4f3be6da6c3e" translate="yes" xml:space="preserve">
          <source>For cartesian to linear index conversion, see &lt;a href=&quot;#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para la conversi&amp;oacute;n de &amp;iacute;ndice cartesiano a lineal, consulte &lt;a href=&quot;#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8b30defdf847f67d42803fa30f31344e75b07b3" translate="yes" xml:space="preserve">
          <source>For code points less than &lt;code&gt;\u80&lt;/code&gt;, it happens that the UTF-8 encoding of each code point is just the single byte produced by the corresponding &lt;code&gt;\x&lt;/code&gt; escape, so the distinction can safely be ignored. For the escapes &lt;code&gt;\x80&lt;/code&gt; through &lt;code&gt;\xff&lt;/code&gt; as compared to &lt;code&gt;\u80&lt;/code&gt; through &lt;code&gt;\uff&lt;/code&gt;, however, there is a major difference: the former escapes all encode single bytes, which &amp;ndash; unless followed by very specific continuation bytes &amp;ndash; do not form valid UTF-8 data, whereas the latter escapes all represent Unicode code points with two-byte encodings.</source>
          <target state="translated">Para los puntos de c&amp;oacute;digo inferiores a &lt;code&gt;\u80&lt;/code&gt; , sucede que la codificaci&amp;oacute;n UTF-8 de cada punto de c&amp;oacute;digo es solo el byte &amp;uacute;nico producido por el escape &lt;code&gt;\x&lt;/code&gt; correspondiente , por lo que la distinci&amp;oacute;n se puede ignorar con seguridad. Sin embargo, para los escapes &lt;code&gt;\x80&lt;/code&gt; a &lt;code&gt;\xff&lt;/code&gt; en comparaci&amp;oacute;n con &lt;code&gt;\u80&lt;/code&gt; a &lt;code&gt;\uff&lt;/code&gt; , hay una diferencia importante: el primero escapa todos los bytes de codificaci&amp;oacute;n individuales, que, a menos que est&amp;eacute;n seguidos por bytes de continuaci&amp;oacute;n muy espec&amp;iacute;ficos, no forman un UTF-8 v&amp;aacute;lido datos, mientras que los &amp;uacute;ltimos escapes todos representan puntos de c&amp;oacute;digo Unicode con codificaciones de dos bytes.</target>
        </trans-unit>
        <trans-unit id="7990f7d8e420dec5f948426ee0deb5045c50fdaa" translate="yes" xml:space="preserve">
          <source>For composite types, this means that the identity of the values of its fields will never change. When the fields are bits types, that means their bits will never change, for fields whose values are mutable types like arrays, that means the fields will always refer to the same mutable value even though that mutable value's content may itself be modified.</source>
          <target state="translated">Para los tipos compuestos,esto significa que la identidad de los valores de sus campos nunca cambiará.Cuando los campos son tipos de bits,eso significa que sus bits nunca cambiarán,para los campos cuyos valores son tipos mutables como los arrays,eso significa que los campos siempre se referirán al mismo valor mutable aunque el contenido de ese valor mutable pueda ser modificado.</target>
        </trans-unit>
        <trans-unit id="03316709b23be1fe05fb3b1026fde6353f45ac08" translate="yes" xml:space="preserve">
          <source>For consistency across Julia, the call site should always pass a &lt;code&gt;Val&lt;/code&gt;&lt;em&gt;instance&lt;/em&gt; rather than using a &lt;em&gt;type&lt;/em&gt;, i.e., use &lt;code&gt;foo(Val(:bar))&lt;/code&gt; rather than &lt;code&gt;foo(Val{:bar})&lt;/code&gt;.</source>
          <target state="translated">Para mantener la coherencia en Julia, el sitio de la llamada siempre debe pasar una &lt;em&gt;instancia de &lt;/em&gt; &lt;code&gt;Val&lt;/code&gt; en lugar de usar un &lt;em&gt;tipo&lt;/em&gt; , es decir, usar &lt;code&gt;foo(Val(:bar))&lt;/code&gt; lugar de &lt;code&gt;foo(Val{:bar})&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d9ce2fe390265769939ee6ced6c2028220d4701" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Por conveniencia, &lt;code&gt;p&lt;/code&gt; puede ser un tipo en lugar de un valor: &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; es un atajo para &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89f749ab9e4eefe9228d7474faa98982038d612a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Por conveniencia, &lt;code&gt;p&lt;/code&gt; puede ser un tipo en lugar de un valor: &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; es un atajo para &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba5445c2e02b549b16ba3decf8b6cd4aeb77578a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Por conveniencia, &lt;code&gt;p&lt;/code&gt; puede ser un tipo en lugar de un valor: &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; es un atajo para &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="628a74984a13bf54fa3097a1ff489c44e499c284" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Por conveniencia, la &lt;code&gt;precision&lt;/code&gt; puede ser un tipo en lugar de un valor: &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; es un atajo para &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f856c7ece595cf56ae5fb16a5157cda0b0b39e" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Por conveniencia, la &lt;code&gt;precision&lt;/code&gt; puede ser un tipo en lugar de un valor: &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; es un atajo para &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="752ad3a1bbf71154ca789079220fccfae5f42c78" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">Por conveniencia, la &lt;code&gt;precision&lt;/code&gt; puede ser un tipo en lugar de un valor: &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; es un atajo para &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="337e0be4946ed3262678abe0f2e935f04104f98b" translate="yes" xml:space="preserve">
          <source>For direct C++ interfacing, see the &lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt; package. For tools to create C++ bindings, see the &lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt; package.</source>
          <target state="translated">Para la interfaz directa de C ++, consulte el paquete &lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt; . Para obtener herramientas para crear enlaces de C ++, consulte el paquete &lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e618742c8a5d9129a1258dfbf5438a2e4a87773" translate="yes" xml:space="preserve">
          <source>For each pair &lt;code&gt;old=&amp;gt;new&lt;/code&gt; in &lt;code&gt;old_new&lt;/code&gt;, replace all occurrences of &lt;code&gt;old&lt;/code&gt; in collection &lt;code&gt;A&lt;/code&gt; by &lt;code&gt;new&lt;/code&gt;. Equality is determined using &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;count&lt;/code&gt; is specified, then replace at most &lt;code&gt;count&lt;/code&gt; occurrences in total. See also &lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para cada par &lt;code&gt;old=&amp;gt;new&lt;/code&gt; en &lt;code&gt;old_new&lt;/code&gt; , reemplace todas las apariciones de &lt;code&gt;old&lt;/code&gt; en la colecci&amp;oacute;n &lt;code&gt;A&lt;/code&gt; por &lt;code&gt;new&lt;/code&gt; . La igualdad se determina utilizando &lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt; . Si se especifica el &lt;code&gt;count&lt;/code&gt; , reemplace como m&amp;aacute;ximo las ocurrencias de &lt;code&gt;count&lt;/code&gt; en total. Consulte tambi&amp;eacute;n &lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd384e9075d866940b3029eb6057da7ada0b04b" translate="yes" xml:space="preserve">
          <source>For ease of understanding, the examples throughout this chapter show full data structures for roots, graph and paths. However, Julia's package loading code does not explicitly create these. Instead, it lazily computes only as much of each structure as it needs to load a given package.</source>
          <target state="translated">Para facilitar la comprensión,los ejemplos de este capítulo muestran estructuras de datos completas para las raíces,el gráfico y los caminos.Sin embargo,el código de carga de paquetes de Julia no las crea explícitamente.En su lugar,calcula perezosamente sólo la cantidad de cada estructura que necesita para cargar un paquete dado.</target>
        </trans-unit>
        <trans-unit id="04e18da25adbbde93578f1eb2fa5f41635ed03eb" translate="yes" xml:space="preserve">
          <source>For empty collections, providing &lt;code&gt;init&lt;/code&gt; will be necessary, except for some special cases (e.g. when &lt;code&gt;op&lt;/code&gt; is one of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) when Julia can determine the neutral element of &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">Para colecciones vac&amp;iacute;as, ser&amp;aacute; necesario proporcionar &lt;code&gt;init&lt;/code&gt; , excepto en algunos casos especiales (por ejemplo, cuando &lt;code&gt;op&lt;/code&gt; es uno de &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;max&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; ) cuando Julia puede determinar el elemento neutral de &lt;code&gt;op&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7a1238b1ac319ac9db6a4c619c8de57eb47bad" translate="yes" xml:space="preserve">
          <source>For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;collected writings&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;William Kahan&lt;/a&gt;, commonly known as the &quot;Father of Floating-Point&quot;. Of particular interest may be &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;An Interview with the Old Man of Floating-Point&lt;/a&gt;.</source>
          <target state="translated">Para una documentaci&amp;oacute;n a&amp;uacute;n m&amp;aacute;s extensa de la historia, la justificaci&amp;oacute;n y los problemas con los n&amp;uacute;meros de punto flotante, as&amp;iacute; como una discusi&amp;oacute;n de muchos otros temas en computaci&amp;oacute;n num&amp;eacute;rica, consulte los &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;escritos recopilados&lt;/a&gt; de &lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;William Kahan&lt;/a&gt; , com&amp;uacute;nmente conocido como el &quot;Padre de los n&amp;uacute;meros flotantes&quot;. Punto&quot;. De particular inter&amp;eacute;s puede ser &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;Una entrevista con el anciano de Floating-Point&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b77b25aae44912586606895a221d1e45b8c25f37" translate="yes" xml:space="preserve">
          <source>For every incoming logical connection with a worker, &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the &lt;code&gt;IO&lt;/code&gt; objects.</source>
          <target state="translated">Para cada conexi&amp;oacute;n l&amp;oacute;gica entrante con un trabajador, se debe &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; . Esto lanza una nueva tarea que maneja la lectura y escritura de mensajes desde / hacia el trabajador representado por los objetos &lt;code&gt;IO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b85b3e1a00e44270cd850d12b0754ab94e579430" translate="yes" xml:space="preserve">
          <source>For every worker launched, the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method must add a &lt;code&gt;WorkerConfig&lt;/code&gt; object (with appropriate fields initialized) to &lt;code&gt;launched&lt;/code&gt;</source>
          <target state="translated">Por cada trabajador lanzado, el m&amp;eacute;todo de &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt; debe agregar un objeto &lt;code&gt;WorkerConfig&lt;/code&gt; (con los campos apropiados inicializados) al &lt;code&gt;launched&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17c1669fdd5a30442a1d111e532e0e0ca62fed47" translate="yes" xml:space="preserve">
          <source>For example in order to fix &lt;code&gt;findfirst&lt;/code&gt; example above one needs to have a separate copy of &lt;code&gt;rx&lt;/code&gt; variable for each thread:</source>
          <target state="translated">Por ejemplo, para corregir el ejemplo de &lt;code&gt;findfirst&lt;/code&gt; anterior, es necesario tener una copia separada de la variable &lt;code&gt;rx&lt;/code&gt; para cada hilo:</target>
        </trans-unit>
        <trans-unit id="08186eb20e073535d04d3ee1bc374db09694e868" translate="yes" xml:space="preserve">
          <source>For example in the following docstring a variable &lt;code&gt;a&lt;/code&gt; is defined and the expected result, as printed in a Julia REPL, appears afterwards:</source>
          <target state="translated">Por ejemplo, en la siguiente cadena de documentos se define una variable &lt;code&gt;a&lt;/code&gt; y el resultado esperado, como se imprime en un REPL de Julia, aparece despu&amp;eacute;s:</target>
        </trans-unit>
        <trans-unit id="b50ac335cd803909aabb34c2ac8aa635fe70764b" translate="yes" xml:space="preserve">
          <source>For example you should write</source>
          <target state="translated">Por ejemplo,deberías escribir</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="d30d6b6735d4ff4914afad9079e3d2da944acfc0" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; will evaluate &lt;code&gt;Sys.iswindows()&lt;/code&gt; and insert either &lt;code&gt;foo&lt;/code&gt; or &lt;code&gt;bar&lt;/code&gt; into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a &lt;code&gt;ccall&lt;/code&gt; to a non-existent function. &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; and &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; are also valid syntax.</source>
          <target state="translated">Por ejemplo, &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; evaluar&amp;aacute; &lt;code&gt;Sys.iswindows()&lt;/code&gt; e insertar&amp;aacute; &lt;code&gt;foo&lt;/code&gt; o &lt;code&gt;bar&lt;/code&gt; en la expresi&amp;oacute;n. Esto es &amp;uacute;til en los casos en que una construcci&amp;oacute;n no ser&amp;iacute;a v&amp;aacute;lida en otras plataformas, como una &lt;code&gt;ccall&lt;/code&gt; a una funci&amp;oacute;n inexistente. &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; y &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; tambi&amp;eacute;n son sintaxis v&amp;aacute;lidas.</target>
        </trans-unit>
        <trans-unit id="ebd8456aa0b38dfe42ed79277e4c1654dd3d60d1" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10 on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; , devolver&amp;aacute; una referencia a un canal de tipo &lt;code&gt;Int&lt;/code&gt; y tama&amp;ntilde;o 10 en &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96ff3ffca8d84a68fdc5320415ea0dc59a9a8872" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10. The channel exists on worker &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; , devolver&amp;aacute; una referencia a un canal de tipo &lt;code&gt;Int&lt;/code&gt; y tama&amp;ntilde;o 10. El canal existe en el &lt;code&gt;pid&lt;/code&gt; del trabajador .</target>
        </trans-unit>
        <trans-unit id="4891a83f30d6618f43c5e0d97b64d34ca2b73c56" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; returns an uninitialized &lt;code&gt;Array{Int,2}&lt;/code&gt; since ranges are neither mutable nor support 2 dimensions:</source>
          <target state="translated">Por ejemplo, &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; devuelve un &lt;code&gt;Array{Int,2}&lt;/code&gt; no inicializado ya que los rangos no son mutables ni admiten 2 dimensiones:</target>
        </trans-unit>
        <trans-unit id="9440a60be9ec094e973482fb911a180f54e935ef" translate="yes" xml:space="preserve">
          <source>For example, Beowulf clusters are supported via a custom cluster manager implemented in the package &lt;code&gt;ClusterManagers.jl&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, los cl&amp;uacute;steres de Beowulf se admiten a trav&amp;eacute;s de un administrador de cl&amp;uacute;steres personalizado implementado en el paquete &lt;code&gt;ClusterManagers.jl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c68e3216a6f7acab7967abd7cf08e2c4de403780" translate="yes" xml:space="preserve">
          <source>For example, NFKC corresponds to the options &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, NFKC corresponde a las opciones &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4599895ae8d119fa4cbac0f0c56af45c7eba0c70" translate="yes" xml:space="preserve">
          <source>For example, a Linux installation with a Julia executable located at &lt;code&gt;/bin/julia&lt;/code&gt;, a &lt;code&gt;DATAROOTDIR&lt;/code&gt; of &lt;code&gt;../share&lt;/code&gt;, and a &lt;code&gt;SYSCONFDIR&lt;/code&gt; of &lt;code&gt;../etc&lt;/code&gt; will have &lt;code&gt;JULIA_BINDIR&lt;/code&gt; set to &lt;code&gt;/bin&lt;/code&gt;, a source-file search path of</source>
          <target state="translated">Por ejemplo, una instalaci&amp;oacute;n de Linux con un ejecutable de Julia ubicado en &lt;code&gt;/bin/julia&lt;/code&gt; , un &lt;code&gt;DATAROOTDIR&lt;/code&gt; de &lt;code&gt;../share&lt;/code&gt; y un &lt;code&gt;SYSCONFDIR&lt;/code&gt; de &lt;code&gt;../etc&lt;/code&gt; tendr&amp;aacute; &lt;code&gt;JULIA_BINDIR&lt;/code&gt; configurado en &lt;code&gt;/bin&lt;/code&gt; , una ruta de b&amp;uacute;squeda de archivo fuente de</target>
        </trans-unit>
        <trans-unit id="cb227b31f00d820f5d9d05405c8ad07604ce912a" translate="yes" xml:space="preserve">
          <source>For example, a recursive factorial routine could be defined like this:</source>
          <target state="translated">Por ejemplo,una rutina factorial recursiva podría definirse así:</target>
        </trans-unit>
        <trans-unit id="a3ee27750c0b683e5c90895147928cfd59e22a42" translate="yes" xml:space="preserve">
          <source>For example, consider a function &lt;code&gt;plot&lt;/code&gt; that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like &lt;code&gt;plot(x, y, width=2)&lt;/code&gt;, where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.</source>
          <target state="translated">Por ejemplo, considere una &lt;code&gt;plot&lt;/code&gt; funci&amp;oacute;n que traza una l&amp;iacute;nea. Esta funci&amp;oacute;n puede tener muchas opciones para controlar el estilo de l&amp;iacute;nea, el ancho, el color, etc. Si acepta argumentos de palabras clave, una posible llamada podr&amp;iacute;a verse como &lt;code&gt;plot(x, y, width=2)&lt;/code&gt; , donde hemos elegido especificar solo el ancho de l&amp;iacute;nea. Tenga en cuenta que esto tiene dos prop&amp;oacute;sitos. La llamada es m&amp;aacute;s f&amp;aacute;cil de leer, ya que podemos etiquetar un argumento con su significado. Tambi&amp;eacute;n es posible pasar cualquier subconjunto de una gran cantidad de argumentos, en cualquier orden.</target>
        </trans-unit>
        <trans-unit id="02796f85acf393569f8f018e6f896c1698a7ba0c" translate="yes" xml:space="preserve">
          <source>For example, consider the following definitions of a function &lt;code&gt;addone&lt;/code&gt; that returns one plus its argument:</source>
          <target state="translated">Por ejemplo, considere las siguientes definiciones de una funci&amp;oacute;n &lt;code&gt;addone&lt;/code&gt; que devuelve uno m&amp;aacute;s su argumento:</target>
        </trans-unit>
        <trans-unit id="8379ff1b045b6b8381b0fc1dcbd698daf2ddf0cf" translate="yes" xml:space="preserve">
          <source>For example, here is how we can guarantee that an opened file is closed:</source>
          <target state="translated">Por ejemplo,así es como podemos garantizar que un archivo abierto se cierre:</target>
        </trans-unit>
        <trans-unit id="49582067d66dec7b465ad077603d8140735bdbe0" translate="yes" xml:space="preserve">
          <source>For example, if you define a &lt;code&gt;MyImage&lt;/code&gt; type and know how to write it to a PNG file, you could define a function &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; to allow your images to be displayed on any PNG-capable &lt;code&gt;AbstractDisplay&lt;/code&gt; (such as IJulia). As usual, be sure to &lt;code&gt;import Base.show&lt;/code&gt; in order to add new methods to the built-in Julia function &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, si define un tipo &lt;code&gt;MyImage&lt;/code&gt; y sabe c&amp;oacute;mo escribirlo en un archivo PNG, puede definir una funci&amp;oacute;n &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; para permitir su im&amp;aacute;genes que se mostrar&amp;aacute;n en cualquier &lt;code&gt;AbstractDisplay&lt;/code&gt; compatible con PNG (como IJulia). Como de costumbre, aseg&amp;uacute;rese de &lt;code&gt;import Base.show&lt;/code&gt; para agregar nuevos m&amp;eacute;todos a la funci&amp;oacute;n integrada de Julia &lt;code&gt;show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2da1e2276f1c5c558883dab8cb5596d1bc2a1628" translate="yes" xml:space="preserve">
          <source>For example, say we define a type that stores a vector along with an accurate representation of its sum:</source>
          <target state="translated">Por ejemplo,digamos que definimos un tipo que almacena un vector junto con una representación precisa de su suma:</target>
        </trans-unit>
        <trans-unit id="e2cfd2a7e3ca6e4481d092c3fbc0442d5a4ab757" translate="yes" xml:space="preserve">
          <source>For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:</source>
          <target state="translated">Por ejemplo,supongamos que se quiere declarar un tipo que contiene un par de números reales,con la restricción de que el primer número no sea mayor que el segundo.Uno podría declararlo así:</target>
        </trans-unit>
        <trans-unit id="79225a639e81658b4de8b5567b3dea63ac5abb4f" translate="yes" xml:space="preserve">
          <source>For example, suppose we want to check our new function &lt;code&gt;foo(x)&lt;/code&gt; works as expected:</source>
          <target state="translated">Por ejemplo, supongamos que queremos comprobar que nuestra nueva funci&amp;oacute;n &lt;code&gt;foo(x)&lt;/code&gt; funciona como se esperaba:</target>
        </trans-unit>
        <trans-unit id="7eda6e477d1dd1d46e2cafc4f54477c6b2bb0e6a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; functions can be composed like this:</source>
          <target state="translated">Por ejemplo, las funciones &lt;code&gt;sqrt&lt;/code&gt; y &lt;code&gt;+&lt;/code&gt; se pueden componer as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="5ae23a1c15837ee5f1ee5c9f54f1ec5adaf7300a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; function throws a &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; if applied to a negative real value:</source>
          <target state="translated">Por ejemplo, la funci&amp;oacute;n &lt;code&gt;sqrt&lt;/code&gt; arroja un &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt; si se aplica a un valor real negativo:</target>
        </trans-unit>
        <trans-unit id="41fbcb24e42e9f837587084b7759fc106d92d27c" translate="yes" xml:space="preserve">
          <source>For example, the following code</source>
          <target state="translated">Por ejemplo,el siguiente código</target>
        </trans-unit>
        <trans-unit id="df53f88b87089b5c188eb151fc2371ed97e5a8bd" translate="yes" xml:space="preserve">
          <source>For example, the following code will not work as intended:</source>
          <target state="translated">Por ejemplo,el siguiente código no funcionará como se pretende:</target>
        </trans-unit>
        <trans-unit id="dd2a7ac9bf39edcb33138e7083aee6d2163bed39" translate="yes" xml:space="preserve">
          <source>For example, the following definition supports the negation of ranges:</source>
          <target state="translated">Por ejemplo,la siguiente definición apoya la negación de rangos:</target>
        </trans-unit>
        <trans-unit id="ebd9e6f4328ccf3da34436709427cc4b4eaab0c0" translate="yes" xml:space="preserve">
          <source>For example, the following regex has all three flags turned on:</source>
          <target state="translated">Por ejemplo,el siguiente regex tiene las tres banderas encendidas:</target>
        </trans-unit>
        <trans-unit id="f984e5cb891417962d09962040b3dc32bb1ac27e" translate="yes" xml:space="preserve">
          <source>For example, the following would cause the &lt;code&gt;for&lt;/code&gt; loop to wait for more data:</source>
          <target state="translated">Por ejemplo, la siguiente har&amp;iacute;a que el &lt;code&gt;for&lt;/code&gt; bucle de espera de m&amp;aacute;s datos:</target>
        </trans-unit>
        <trans-unit id="f4ca40c2a3ba9787690378fb5f2aab689eee1052" translate="yes" xml:space="preserve">
          <source>For example, to read a simple byte array, we could do:</source>
          <target state="translated">Por ejemplo,para leer una simple matriz de bytes,podríamos hacer:</target>
        </trans-unit>
        <trans-unit id="8878c21d4c3068d1cd94e841b14239269912a492" translate="yes" xml:space="preserve">
          <source>For example, trying to dispatch on the element-type of an array will often run into ambiguous situations. Instead, commonly code will dispatch first on the container type, then recurse down to a more specific method based on eltype. In most cases, the algorithms lend themselves conveniently to this hierarchical approach, while in other cases, this rigor must be resolved manually. This dispatching branching can be observed, for example, in the logic to sum two matrices:</source>
          <target state="translated">Por ejemplo,al tratar de despachar en el tipo de elemento de un conjunto,a menudo se encontrarán situaciones ambiguas.En cambio,comúnmente el código se despachará primero en el tipo de contenedor,y luego se recurrirá a un método más específico basado en el tipo de elemento.En la mayoría de los casos,los algoritmos se prestan convenientemente a este enfoque jerárquico,mientras que en otros casos,este rigor debe resolverse manualmente.Esta ramificación de despacho puede observarse,por ejemplo,en la lógica de suma de dos matrices:</target>
        </trans-unit>
        <trans-unit id="b2c13e0b4d2254aa0c6b075c4f699f03e1e4085d" translate="yes" xml:space="preserve">
          <source>For example, two vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of the same length can be written as two columns of tab-delimited text to &lt;code&gt;f&lt;/code&gt; by either &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; or by &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, dos vectores &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; de la misma longitud se puede escribir como dos columnas de texto delimitado por tabuladores a &lt;code&gt;f&lt;/code&gt; por cualquiera &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; o por &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20b7a39286391fad09a5ff705ae3bda829227952" translate="yes" xml:space="preserve">
          <source>For example, when reading all of the output from a command, call &lt;code&gt;read(out, String)&lt;/code&gt;, not &lt;code&gt;wait(process)&lt;/code&gt;, since the former will actively consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel's buffers while waiting for a reader to be connected.</source>
          <target state="translated">Por ejemplo, al leer toda la salida de un comando, llame a &lt;code&gt;read(out, String)&lt;/code&gt; , no a &lt;code&gt;wait(process)&lt;/code&gt; , ya que el primero consumir&amp;aacute; activamente todos los datos escritos por el proceso, mientras que el segundo intentar&amp;aacute; almacenar el datos en los b&amp;uacute;feres del kernel mientras espera que se conecte un lector.</target>
        </trans-unit>
        <trans-unit id="5029745bd6486130a24ba078811879e64132c558" translate="yes" xml:space="preserve">
          <source>For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:</source>
          <target state="translated">Por ejemplo,se puede definir un tipo que almacena los coeficientes de un polinomio,pero que se comporta como una función que evalúa el polinomio:</target>
        </trans-unit>
        <trans-unit id="67f058df3da112643c2b0a1dfa02199be4e0057b" translate="yes" xml:space="preserve">
          <source>For example, you might look up the function via &lt;code&gt;dlsym&lt;/code&gt;, then cache it in a shared reference for that session. For example:</source>
          <target state="translated">Por ejemplo, puede buscar la funci&amp;oacute;n a trav&amp;eacute;s de &lt;code&gt;dlsym&lt;/code&gt; y luego almacenarla en una referencia compartida para esa sesi&amp;oacute;n. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="77957bacdf57512b4372bd5a4e3fd7ed75c7e36e" translate="yes" xml:space="preserve">
          <source>For expert drivers and additional information, see &lt;code&gt;permute!&lt;/code&gt;.</source>
          <target state="translated">Para obtener conductores expertos e informaci&amp;oacute;n adicional, consulte &lt;code&gt;permute!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="023517bc66d9d3e180b498d61c21e401d08d2db9" translate="yes" xml:space="preserve">
          <source>For file dependencies, a change is determined by examining whether the modification time (mtime) of each file loaded by &lt;code&gt;include&lt;/code&gt; or added explicitly by &lt;code&gt;include_dependency&lt;/code&gt; is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can't copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in &lt;code&gt;require&lt;/code&gt; matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the current process and won't recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache.</source>
          <target state="translated">Para las dependencias de archivos, un cambio se determina examinando si el tiempo de modificaci&amp;oacute;n (mtime) de cada archivo cargado por &lt;code&gt;include&lt;/code&gt; o agregado expl&amp;iacute;citamente por &lt;code&gt;include_dependency&lt;/code&gt; no cambia, o es igual al tiempo de modificaci&amp;oacute;n truncado al segundo m&amp;aacute;s cercano (para acomodar sistemas que no pueden copiar mtime con una precisi&amp;oacute;n inferior a un segundo). Tambi&amp;eacute;n tiene en cuenta si la ruta al archivo elegido por la l&amp;oacute;gica de b&amp;uacute;squeda en &lt;code&gt;require&lt;/code&gt; coincide con la ruta que hab&amp;iacute;a creado el archivo de precompilaci&amp;oacute;n. Tambi&amp;eacute;n tiene en cuenta el conjunto de dependencias ya cargadas en el proceso actual y no recompilar&amp;aacute; esos m&amp;oacute;dulos, incluso si sus archivos cambian o desaparecen, para evitar crear incompatibilidades entre el sistema en ejecuci&amp;oacute;n y la cach&amp;eacute; de precompilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="66dd55e20f602bb211d9c7813d2f9f0ed6928fe9" translate="yes" xml:space="preserve">
          <source>For fixed-size integer types less than 128 bits, &lt;code&gt;widen&lt;/code&gt; will return a type with twice the number of bits.</source>
          <target state="translated">Para tipos de enteros de tama&amp;ntilde;o fijo de menos de 128 bits, &lt;code&gt;widen&lt;/code&gt; devolver&amp;aacute; un tipo con el doble de bits.</target>
        </trans-unit>
        <trans-unit id="517d5d95b2398e36f4828f9d104f02ccf187deee" translate="yes" xml:space="preserve">
          <source>For functions &lt;code&gt;f(x)&lt;/code&gt;, &lt;code&gt;f(x) = x&lt;/code&gt; defines a new function constant &lt;code&gt;f&lt;/code&gt;, or adds a new method to &lt;code&gt;f&lt;/code&gt; if &lt;code&gt;f&lt;/code&gt; is already defined; this usage is equivalent to &lt;code&gt;function f(x); x; end&lt;/code&gt;.</source>
          <target state="translated">Para las funciones &lt;code&gt;f(x)&lt;/code&gt; , &lt;code&gt;f(x) = x&lt;/code&gt; define una nueva funci&amp;oacute;n constante &lt;code&gt;f&lt;/code&gt; , o agrega un nuevo m&amp;eacute;todo &lt;code&gt;f&lt;/code&gt; si &lt;code&gt;f&lt;/code&gt; ya est&amp;aacute; definida; este uso es equivalente a la &lt;code&gt;function f(x); x; end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a6abe0e3a65b8ed9f51c340da311967dd300c9c" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw add&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la instrucci&amp;oacute;n de &lt;code&gt;atomicrmw add&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="a0322dcf17161d23047710cc59f3f8e235c18a53" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw and&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte las instrucciones &lt;code&gt;atomicrmw and&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="e5b561d9fc0067e467e9e9fcee46e3023283cf28" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw max&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la instrucci&amp;oacute;n &lt;code&gt;atomicrmw max&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="eab5683b8c3c9bc6117f8a69b4da87aa9632a8fb" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw min&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la instrucci&amp;oacute;n &lt;code&gt;atomicrmw min&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="7b7e08b7890af600321c511f13a806cd3559bcfa" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw nand&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la instrucci&amp;oacute;n &lt;code&gt;atomicrmw nand&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="7b8dd1c376a179e2ba56074f5563e776f17ef9ec" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw or&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la instrucci&amp;oacute;n &lt;code&gt;atomicrmw or&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="48c1004b7dffe90355657654366824768f35001b" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw sub&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la &lt;code&gt;atomicrmw sub&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="192e95dde72a6e68d2db267b6ee138cf37555d73" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xchg&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la instrucci&amp;oacute;n &lt;code&gt;atomicrmw xchg&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="5e4b67df501ae8428fb22d5e33af878bfbea1ef9" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xor&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la instrucci&amp;oacute;n &lt;code&gt;atomicrmw xor&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="7ee314d2ce6ee192109b08f74bbfd48cbb0e5cbc" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;cmpxchg&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte la instrucci&amp;oacute;n &lt;code&gt;cmpxchg&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="a7755edb4519e4536a6271c13a954434e48a3388" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;fence&lt;/code&gt; instruction.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles, consulte las instrucciones de &lt;code&gt;fence&lt;/code&gt; de LLVM .</target>
        </trans-unit>
        <trans-unit id="592e1ef0cc917b2ef533393d9872f216dc5c373c" translate="yes" xml:space="preserve">
          <source>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt;. By the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;, these floating-point values are the results of certain arithmetic operations:</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo se ordenan estos valores de coma flotante no finitos entre s&amp;iacute; y otros flotantes, consulte &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Comparaciones num&amp;eacute;ricas&lt;/a&gt; . Seg&amp;uacute;n el &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;est&amp;aacute;ndar IEEE 754&lt;/a&gt; , estos valores de punto flotante son el resultado de ciertas operaciones aritm&amp;eacute;ticas:</target>
        </trans-unit>
        <trans-unit id="f6a5e306e2388b19948e17b05f28ec9cf0f8d86c" translate="yes" xml:space="preserve">
          <source>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The &lt;code&gt;permute&lt;/code&gt;, &lt;code&gt;scale&lt;/code&gt;, and &lt;code&gt;sortby&lt;/code&gt; keywords are the same as for &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para matrices no sim&amp;eacute;tricas generales, es posible especificar c&amp;oacute;mo se equilibra la matriz antes del c&amp;aacute;lculo del valor propio. Las palabras clave &lt;code&gt;permute&lt;/code&gt; , &lt;code&gt;scale&lt;/code&gt; y &lt;code&gt;sortby&lt;/code&gt; son las mismas que para &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2a3464000c64f9602c239ac8ef54cb51f0375c94" translate="yes" xml:space="preserve">
          <source>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option &lt;code&gt;permute=true&lt;/code&gt; permutes the matrix to become closer to upper triangular, and &lt;code&gt;scale=true&lt;/code&gt; scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is &lt;code&gt;true&lt;/code&gt; for both options.</source>
          <target state="translated">Para matrices no sim&amp;eacute;tricas generales, es posible especificar c&amp;oacute;mo se equilibra la matriz antes del c&amp;aacute;lculo del vector propio. La opci&amp;oacute;n &lt;code&gt;permute=true&lt;/code&gt; permuta la matriz para que se acerque m&amp;aacute;s al triangular superior, y &lt;code&gt;scale=true&lt;/code&gt; escala la matriz por sus elementos diagonales para hacer que las filas y columnas sean m&amp;aacute;s iguales en norma. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; para ambas opciones.</target>
        </trans-unit>
        <trans-unit id="97272f75bb7bf420f1c0e8253e48bdca2d0549a3" translate="yes" xml:space="preserve">
          <source>For general square matrices, &lt;code&gt;A = A*B&lt;/code&gt; cannot be implemented without temporary storage: &lt;code&gt;A[1,1]&lt;/code&gt; gets computed and stored on the left hand side before you're done using it on the right hand side.</source>
          <target state="translated">Para matrices cuadradas generales, &lt;code&gt;A = A*B&lt;/code&gt; no se puede implementar sin almacenamiento temporal: &lt;code&gt;A[1,1]&lt;/code&gt; se calcula y almacena en el lado izquierdo antes de que termine de usarlo en el lado derecho.</target>
        </trans-unit>
        <trans-unit id="935a8c2e4f251a5770a2bb608ecff08833dd9c32" translate="yes" xml:space="preserve">
          <source>For global variables, only the bindings are captured in a closure, not the data. &lt;code&gt;let&lt;/code&gt; blocks can be used to capture global data.</source>
          <target state="translated">Para las variables globales, solo las vinculaciones se capturan en un cierre, no los datos. &lt;code&gt;let&lt;/code&gt; bloques se puedan utilizar para capturar datos globales.</target>
        </trans-unit>
        <trans-unit id="e5b2b73939c9dca143b01d277fa950512fdcf9e4" translate="yes" xml:space="preserve">
          <source>For implementing primitive operations, such as addition, we use the &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt; function to compute the desired output type. (As before, we saw this at work in the &lt;code&gt;promote&lt;/code&gt; call in the call to &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">Para implementar operaciones primitivas, como la suma, usamos la funci&amp;oacute;n &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt; para calcular el tipo de salida deseado. (Como antes, vimos esto en funcionamiento en la llamada de &lt;code&gt;promote&lt;/code&gt; en la llamada a &lt;code&gt;+&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9bbc05f37cbd2b5498a3ab3a593a156112a8c55d" translate="yes" xml:space="preserve">
          <source>For instance, consider this C routine that uses AVX intrinsics:</source>
          <target state="translated">Por ejemplo,considere esta rutina C que usa AVX intrínseco:</target>
        </trans-unit>
        <trans-unit id="58f3adf26ef93227d12186ad90763f386c1243e3" translate="yes" xml:space="preserve">
          <source>For inverting dense ill-conditioned matrices in a least-squares sense, &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; is recommended.</source>
          <target state="translated">Para invertir matrices densas mal acondicionadas en un sentido de m&amp;iacute;nimos cuadrados, se &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3476b291492f6f31f8c69709d348f023db79ecb7" translate="yes" xml:space="preserve">
          <source>For many problems, it is not necessary to think about tasks directly. However, they can be used to wait for multiple events at the same time, which provides for &lt;em&gt;dynamic scheduling&lt;/em&gt;. In dynamic scheduling, a program decides what to compute or where to compute it based on when other jobs finish. This is needed for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they finish their current tasks.</source>
          <target state="translated">Para muchos problemas, no es necesario pensar directamente en las tareas. Sin embargo, se pueden utilizar para esperar varios eventos al mismo tiempo, lo que proporciona &lt;em&gt;una programaci&amp;oacute;n din&amp;aacute;mica&lt;/em&gt; . En la programaci&amp;oacute;n din&amp;aacute;mica, un programa decide qu&amp;eacute; calcular o d&amp;oacute;nde calcularlo bas&amp;aacute;ndose en cu&amp;aacute;ndo terminan otros trabajos. Esto es necesario para cargas de trabajo impredecibles o desequilibradas, en las que queremos asignar m&amp;aacute;s trabajo a los procesos solo cuando finalizan sus tareas actuales.</target>
        </trans-unit>
        <trans-unit id="7f0ae2a2524af9d24fc01426df34e4e2c47f07b3" translate="yes" xml:space="preserve">
          <source>For many types, forming new objects by binding their field values together is all that is ever needed to create instances. However, in some cases more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;Recursive data structures&lt;/a&gt;, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it's just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia's system for object construction addresses all of these cases and more.</source>
          <target state="translated">Para muchos tipos, la formaci&amp;oacute;n de nuevos objetos vinculando sus valores de campo es todo lo que se necesita para crear instancias. Sin embargo, en algunos casos se requiere m&amp;aacute;s funcionalidad al crear objetos compuestos. A veces, los invariantes deben aplicarse, ya sea verificando argumentos o transform&amp;aacute;ndolos. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;Las estructuras de datos recursivas&lt;/a&gt; , especialmente aquellas que pueden ser autorreferenciales, a menudo no se pueden construir limpiamente sin ser creadas primero en un estado incompleto y luego alteradas program&amp;aacute;ticamente para completarlas, como un paso separado de la creaci&amp;oacute;n de objetos. A veces, es conveniente poder construir objetos con menos o diferentes tipos de par&amp;aacute;metros de los que tienen los campos. El sistema de Julia para la construcci&amp;oacute;n de objetos aborda todos estos casos y m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="c3ab9fc4f4873966145fee9c6ac1a9124f310742" translate="yes" xml:space="preserve">
          <source>For matrices &lt;code&gt;M&lt;/code&gt; with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is the largest singular value of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Para matrices &lt;code&gt;M&lt;/code&gt; con elementos de punto flotante, es conveniente para calcular la pseudoinverse invirtiendo s&amp;oacute;lo valores singulares mayores que &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; donde &lt;code&gt;&amp;sigma;₁&lt;/code&gt; es el valor singular m&amp;aacute;s grande de &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac6da235d612ded03083200d47fe1ab7d98c9b79" translate="yes" xml:space="preserve">
          <source>For more complex functions on matrices, it may be necessary to compute the expected return type for a more complex sequence of operations. This is often performed by the following steps:</source>
          <target state="translated">En el caso de funciones más complejas en matrices,puede ser necesario calcular el tipo de retorno esperado para una secuencia de operaciones más compleja.Esto se realiza a menudo mediante los siguientes pasos:</target>
        </trans-unit>
        <trans-unit id="4017330d0c6b8db2f9072cd10c06aafbef3ef320" translate="yes" xml:space="preserve">
          <source>For more details on how to pass callbacks to C libraries, see this &lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles sobre c&amp;oacute;mo pasar devoluciones de llamada a las bibliotecas de C, consulte esta &lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;publicaci&amp;oacute;n de blog&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4e7422368e9880e43d73e7cf711179bdaf3a6a3" translate="yes" xml:space="preserve">
          <source>For more details regarding code loading, see the manual sections on &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;parallel computing&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s detalles sobre la carga de c&amp;oacute;digo, consulte las secciones del manual sobre &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;m&amp;oacute;dulos&lt;/a&gt; y &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;computaci&amp;oacute;n en paralelo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="825f5736599d7832ed10460cda99264a6faea4e6" translate="yes" xml:space="preserve">
          <source>For more information about stylistic conventions, see the &lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las convenciones estil&amp;iacute;sticas, consulte la &lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;Gu&amp;iacute;a de estilo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29a5a734cc9600ff863c3e949c6ca0cd3d61e836" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM Language Reference&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte la &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;Referencia del lenguaje LLVM&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e94367c7326944c925932ccd75ddf09b0dc2a2ca" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;#footnote-issue8859&quot;&gt;[issue8859]&lt;/a&gt;, &lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt;, &lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt;, &lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]&lt;/a&gt;.</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;a href=&quot;#footnote-issue8859&quot;&gt;[problema8859]&lt;/a&gt; , &lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt; , &lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt; , &lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78c9da6d7f9a8088ccb6c5228fbbc41a8fd90ece" translate="yes" xml:space="preserve">
          <source>For more serious benchmarking, consider the &lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt; package which among other things evaluates the function multiple times in order to reduce noise.</source>
          <target state="translated">Para una evaluaci&amp;oacute;n comparativa m&amp;aacute;s seria, considere el paquete &lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt; que, entre otras cosas, eval&amp;uacute;a la funci&amp;oacute;n varias veces para reducir el ruido.</target>
        </trans-unit>
        <trans-unit id="88557b99f2da7edd1312dcf73383bf3fd839d0cf" translate="yes" xml:space="preserve">
          <source>For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.</source>
          <target state="translated">Para la mayoría de los tipos definidos por el usuario,es mejor práctica exigir a los programadores que suministren explícitamente los tipos esperados a las funciones de constructor,pero a veces,especialmente para los problemas numéricos,puede ser conveniente hacer la promoción automáticamente.</target>
        </trans-unit>
        <trans-unit id="ceb4f91d41747de4680e86cde1985bd3bfc38e4e" translate="yes" xml:space="preserve">
          <source>For multiple collection arguments, apply &lt;code&gt;f&lt;/code&gt; elementwise.</source>
          <target state="translated">Para m&amp;uacute;ltiples argumentos de colecci&amp;oacute;n, aplique &lt;code&gt;f&lt;/code&gt; elemento a nivel.</target>
        </trans-unit>
        <trans-unit id="ea75a21c84d373ef04e66eb8c0a6a1bc5cc64258" translate="yes" xml:space="preserve">
          <source>For newcomers to multi-threading and parallel computing it can be useful to first appreciate the different levels of parallelism offered by Julia. We can divide them in three main categories :</source>
          <target state="translated">Para los recién llegados a la computación multi-hilo y paralela puede ser útil apreciar primero los diferentes niveles de paralelismo ofrecidos por Julia.Podemos dividirlos en tres categorías principales:</target>
        </trans-unit>
        <trans-unit id="ac8a874fecbfe223b7adee365914ddd8f5f53622" translate="yes" xml:space="preserve">
          <source>For non-numeric values, and for fewer or more than two arguments, the function &lt;code&gt;f&lt;/code&gt; remains undefined, and applying it will still result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Para valores no num&amp;eacute;ricos, y para menos o m&amp;aacute;s de dos argumentos, la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; permanece indefinida y su aplicaci&amp;oacute;n a&amp;uacute;n resultar&amp;aacute; en un &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="235d743e9d754b970eea4778b2f329bcad575d20" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$.</source>
          <target state="translated">Para los números,devuelva $\\N-izquierda(|x||p |derecha)^{{1/p}$.</target>
        </trans-unit>
        <trans-unit id="00b6eae180d5b268722ff406a9cc534055692e79" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$. This is equivalent to &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para n&amp;uacute;meros, devuelve $ \ left (| x | ^ p \ right) ^ {1 / p} $. Esto es equivalente a la &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; a&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f585a8f761ded66238973d0a20da01f3603d93" translate="yes" xml:space="preserve">
          <source>For one argument, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (1, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi/2, \pi/2]$.</source>
          <target state="translated">Para un argumento, este es el &amp;aacute;ngulo en radianes entre el eje &lt;em&gt;x&lt;/em&gt; positivo y el punto (1, &lt;em&gt;y&lt;/em&gt; ), que devuelve un valor en el intervalo $ [- \ pi / 2, \ pi / 2] $.</target>
        </trans-unit>
        <trans-unit id="cbe3a2c9ed0456d9a3ed109f08314c90a9a6e71e" translate="yes" xml:space="preserve">
          <source>For other types, &lt;code&gt;isequal&lt;/code&gt; defaults to calling &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, so if you want to define equality for your own types then you only need to add a &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; method. If you define your own equality function, you should probably define a corresponding &lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; method to ensure that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x) == hash(y)&lt;/code&gt;.</source>
          <target state="translated">Para otros tipos, &lt;code&gt;isequal&lt;/code&gt; tiene como valor predeterminado llamar a &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; , por lo que si desea definir la igualdad para sus propios tipos, solo necesita agregar un m&amp;eacute;todo &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; . Si define su propia funci&amp;oacute;n de igualdad, probablemente deber&amp;iacute;a definir un m&amp;eacute;todo &lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt; correspondiente para asegurarse de que &lt;code&gt;isequal(x,y)&lt;/code&gt; implique &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c2f4b9050307c80e2b4e5b109845a6af03029a8" translate="yes" xml:space="preserve">
          <source>For real or complex floating-point values, if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is not specified, &lt;code&gt;rtol&lt;/code&gt; defaults to the square root of &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the type of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is supplied, &lt;code&gt;rtol&lt;/code&gt; defaults to zero.</source>
          <target state="translated">Para los valores de punto flotante reales o complejos, si un &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; no se especifica, &lt;code&gt;rtol&lt;/code&gt; por defecto a la ra&amp;iacute;z cuadrada de &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt; del tipo de &lt;code&gt;x&lt;/code&gt; o &lt;code&gt;y&lt;/code&gt; , lo que es m&amp;aacute;s grande (menos precisos). Esto corresponde a requerir la igualdad de aproximadamente la mitad de los d&amp;iacute;gitos significativos. De lo contrario, por ejemplo, para argumentos enteros o si se proporciona un &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; , &lt;code&gt;rtol&lt;/code&gt; toma el valor predeterminado de cero.</target>
        </trans-unit>
        <trans-unit id="d58b65ff0e6e435abbaf14887e067d0c31d3520b" translate="yes" xml:space="preserve">
          <source>For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn't need to generate any code to resolve the type at run-time. This results in shorter and faster code.</source>
          <target state="translated">Por razones de longitud,los resultados no se muestran aquí,pero puede intentarlo usted mismo.Debido a que el tipo está completamente especificado en el primer caso,el compilador no necesita generar ningún código para resolver el tipo en tiempo de ejecución.Esto resulta en un código más corto y más rápido.</target>
        </trans-unit>
        <trans-unit id="6fc874bd7cd4d5b9abffad50a8cc5e9ee8fcd173" translate="yes" xml:space="preserve">
          <source>For rectangular &lt;code&gt;A&lt;/code&gt; the result is the minimum-norm least squares solution computed by a pivoted QR factorization of &lt;code&gt;A&lt;/code&gt; and a rank estimate of &lt;code&gt;A&lt;/code&gt; based on the R factor.</source>
          <target state="translated">Para el rectangular &lt;code&gt;A&lt;/code&gt; , el resultado es la soluci&amp;oacute;n de m&amp;iacute;nimos cuadrados de norma m&amp;iacute;nima calculada mediante una factorizaci&amp;oacute;n QR pivotante de &lt;code&gt;A&lt;/code&gt; y una estimaci&amp;oacute;n de rango de &lt;code&gt;A&lt;/code&gt; basada en el factor R.</target>
        </trans-unit>
        <trans-unit id="912d3fe9f2697c548ca0705aab244457023707b1" translate="yes" xml:space="preserve">
          <source>For simple functions, it is often clearer to mention the role of the arguments directly in the description of the function's purpose. An argument list would only repeat information already provided elsewhere. However, providing an argument list can be a good idea for complex functions with many arguments (in particular keyword arguments). In that case, insert it after the general description of the function, under an &lt;code&gt;# Arguments&lt;/code&gt; header, with one &lt;code&gt;-&lt;/code&gt; bullet for each argument. The list should mention the types and default values (if any) of the arguments:</source>
          <target state="translated">Para funciones simples, a menudo es m&amp;aacute;s claro mencionar el papel de los argumentos directamente en la descripci&amp;oacute;n del prop&amp;oacute;sito de la funci&amp;oacute;n. Una lista de argumentos solo repetir&amp;iacute;a informaci&amp;oacute;n ya proporcionada en otro lugar. Sin embargo, proporcionar una lista de argumentos puede ser una buena idea para funciones complejas con muchos argumentos (en particular, argumentos de palabras clave). En ese caso, la inserta despu&amp;eacute;s de la descripci&amp;oacute;n general de la funci&amp;oacute;n, en virtud de un &lt;code&gt;# Arguments&lt;/code&gt; cabecera, con uno &lt;code&gt;-&lt;/code&gt; de bala para cada argumento. La lista debe mencionar los tipos y valores predeterminados (si los hay) de los argumentos:</target>
        </trans-unit>
        <trans-unit id="1ea7196a777e8e9b741754a756a982ecdc4df126" translate="yes" xml:space="preserve">
          <source>For simple index types, it defers to the unexported &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; to process each index &lt;code&gt;i&lt;/code&gt;. While this internal function is not intended to be called directly, &lt;code&gt;Base.to_index&lt;/code&gt; may be extended by custom array or index types to provide custom indexing behaviors.</source>
          <target state="translated">Para tipos de &amp;iacute;ndices simples, difiere del &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; para procesar cada &amp;iacute;ndice &lt;code&gt;i&lt;/code&gt; . Si bien esta funci&amp;oacute;n interna no est&amp;aacute; destinada a llamarse directamente, &lt;code&gt;Base.to_index&lt;/code&gt; puede ampliarse mediante tipos de &amp;iacute;ndices o matrices personalizados para proporcionar comportamientos de indexaci&amp;oacute;n personalizados.</target>
        </trans-unit>
        <trans-unit id="53b19a276cd1b474618ba84687e1e90b947ee82e" translate="yes" xml:space="preserve">
          <source>For situations where a value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; exists only sometimes, the &lt;code&gt;Union{T, Nothing}&lt;/code&gt; type can be used for function arguments, object fields and array element types as the equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; in other languages. If the value itself can be &lt;code&gt;nothing&lt;/code&gt; (notably, when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;), the &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; type is more appropriate since &lt;code&gt;x == nothing&lt;/code&gt; then indicates the absence of a value, and &lt;code&gt;x == Some(nothing)&lt;/code&gt; indicates the presence of a value equal to &lt;code&gt;nothing&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.something&quot;&gt;&lt;code&gt;something&lt;/code&gt;&lt;/a&gt; function allows unwrapping &lt;code&gt;Some&lt;/code&gt; objects and using a default value instead of &lt;code&gt;nothing&lt;/code&gt; arguments. Note that the compiler is able to generate efficient code when working with &lt;code&gt;Union{T, Nothing}&lt;/code&gt; arguments or fields.</source>
          <target state="translated">Para situaciones en las que un valor &lt;code&gt;x&lt;/code&gt; de tipo &lt;code&gt;T&lt;/code&gt; existe solo a veces, el tipo &lt;code&gt;Union{T, Nothing}&lt;/code&gt; se puede usar para argumentos de funci&amp;oacute;n, campos de objeto y tipos de elementos de matriz como el equivalente de &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; , &lt;code&gt;Option&lt;/code&gt; o &lt;code&gt;Maybe&lt;/code&gt; &lt;/a&gt; en otros lenguajes. Si el valor en s&amp;iacute; no puede ser &lt;code&gt;nothing&lt;/code&gt; (en particular, cuando &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Any&lt;/code&gt; ), el tipo &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; es m&amp;aacute;s apropiado ya que &lt;code&gt;x == nothing&lt;/code&gt; indica la ausencia de un valor, y &lt;code&gt;x == Some(nothing)&lt;/code&gt; indica la presencia de un valor igual a &lt;code&gt;nothing&lt;/code&gt; . El &lt;a href=&quot;../../base/base/index#Base.something&quot;&gt; &lt;code&gt;something&lt;/code&gt; &lt;/a&gt;La funci&amp;oacute;n permite desenvolver &lt;code&gt;Some&lt;/code&gt; objetos y usar un valor predeterminado en lugar de argumentos &lt;code&gt;nothing&lt;/code&gt; . Tenga en cuenta que el compilador puede generar c&amp;oacute;digo eficiente cuando trabaja con argumentos o campos &lt;code&gt;Union{T, Nothing}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a7de4a7810165537aadc6250e15a8a55f9a88d" translate="yes" xml:space="preserve">
          <source>For some types which &quot;wrap&quot; other values, the constructor may wrap its argument inside a new object even if it is already of the requested type. For example &lt;code&gt;Some(x)&lt;/code&gt; wraps &lt;code&gt;x&lt;/code&gt; to indicate that a value is present (in a context where the result might be a &lt;code&gt;Some&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt;). However, &lt;code&gt;x&lt;/code&gt; itself might be the object &lt;code&gt;Some(y)&lt;/code&gt;, in which case the result is &lt;code&gt;Some(Some(y))&lt;/code&gt;, with two levels of wrapping. &lt;code&gt;convert(Some, x)&lt;/code&gt;, on the other hand, would just return &lt;code&gt;x&lt;/code&gt; since it is already a &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="translated">Para algunos tipos que &quot;envuelven&quot; otros valores, el constructor puede envolver su argumento dentro de un nuevo objeto incluso si ya es del tipo solicitado. Por ejemplo, &lt;code&gt;Some(x)&lt;/code&gt; envuelve &lt;code&gt;x&lt;/code&gt; para indicar que un valor est&amp;aacute; presente (en un contexto en el que el resultado podr&amp;iacute;a ser &lt;code&gt;Some&lt;/code&gt; o &lt;code&gt;nothing&lt;/code&gt; ). Sin embargo, la propia &lt;code&gt;x&lt;/code&gt; podr&amp;iacute;a ser el objeto &lt;code&gt;Some(y)&lt;/code&gt; , en cuyo caso el resultado es &lt;code&gt;Some(Some(y))&lt;/code&gt; , con dos niveles de envoltura. &lt;code&gt;convert(Some, x)&lt;/code&gt; , por otro lado, simplemente devolver&amp;iacute;a &lt;code&gt;x&lt;/code&gt; ya que ya es &lt;code&gt;Some&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47046f98397f6383243a7899dc2654cd12e6fb38" translate="yes" xml:space="preserve">
          <source>For some types, the machinery to &quot;fuse&quot; operations across nested levels of broadcasting is not available or could be done more efficiently incrementally. In such cases, you may need or want to evaluate &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; as if it had been written &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt;, where the inner operation is evaluated before tackling the outer operation. This sort of eager operation is directly supported by a bit of indirection; instead of directly constructing &lt;code&gt;Broadcasted&lt;/code&gt; objects, Julia lowers the fused expression &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; to &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt;. Now, by default, &lt;code&gt;broadcasted&lt;/code&gt; just calls the &lt;code&gt;Broadcasted&lt;/code&gt; constructor to create the lazy representation of the fused expression tree, but you can choose to override it for a particular combination of function and arguments.</source>
          <target state="translated">Para algunos tipos, la maquinaria para &quot;fusionar&quot; las operaciones a trav&amp;eacute;s de niveles anidados de radiodifusi&amp;oacute;n no est&amp;aacute; disponible o podr&amp;iacute;a hacerse de forma m&amp;aacute;s eficiente de forma incremental. En tales casos, es posible que necesite o desee evaluar &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; como si se hubiera escrito &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt; , donde se eval&amp;uacute;a la operaci&amp;oacute;n interna antes de abordar la operaci&amp;oacute;n exterior. Este tipo de operaci&amp;oacute;n &amp;aacute;vida se apoya directamente en un poco de indirecci&amp;oacute;n; en lugar de construir directamente objetos &lt;code&gt;Broadcasted&lt;/code&gt; , Julia reduce la expresi&amp;oacute;n fusionada &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; a &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt; . Ahora, de forma predeterminada, &lt;code&gt;broadcasted&lt;/code&gt; solo llama al &lt;code&gt;Broadcasted&lt;/code&gt; constructor para crear la representaci&amp;oacute;n diferida del &amp;aacute;rbol de expresi&amp;oacute;n fusionado, pero puede optar por anularlo para una combinaci&amp;oacute;n particular de funci&amp;oacute;n y argumentos.</target>
        </trans-unit>
        <trans-unit id="08e1dce6d1b843106b2d04dbdc79c4bf75d54149" translate="yes" xml:space="preserve">
          <source>For specializing broadcast on custom types, see</source>
          <target state="translated">Para la emisión especializada en tipos personalizados,véase</target>
        </trans-unit>
        <trans-unit id="063287ad264bebc20a42dfa1890ff52805f2bb2c" translate="yes" xml:space="preserve">
          <source>For string arguments (&lt;code&gt;char*&lt;/code&gt;) the Julia type should be &lt;code&gt;Cstring&lt;/code&gt; (if NUL- terminated data is expected) or either &lt;code&gt;Ptr{Cchar}&lt;/code&gt; or &lt;code&gt;Ptr{UInt8}&lt;/code&gt; otherwise (these two pointer types have the same effect), as described above, not &lt;code&gt;String&lt;/code&gt;. Similarly, for array arguments (&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt;), the Julia type should again be &lt;code&gt;Ptr{T}&lt;/code&gt;, not &lt;code&gt;Vector{T}&lt;/code&gt;.</source>
          <target state="translated">Para argumentos de cadena ( &lt;code&gt;char*&lt;/code&gt; ), el tipo de Julia debe ser &lt;code&gt;Cstring&lt;/code&gt; (si se esperan datos terminados en NUL) o &lt;code&gt;Ptr{Cchar}&lt;/code&gt; o &lt;code&gt;Ptr{UInt8}&lt;/code&gt; contrario (estos dos tipos de puntero tienen el mismo efecto), como se describe arriba, no &lt;code&gt;String&lt;/code&gt; . De manera similar, para argumentos de matriz ( &lt;code&gt;T[]&lt;/code&gt; o &lt;code&gt;T*&lt;/code&gt; ), el tipo de Julia deber&amp;iacute;a ser nuevamente &lt;code&gt;Ptr{T}&lt;/code&gt; , no &lt;code&gt;Vector{T}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b3d0b51e2ef5e244357843af21db4dc2c7dfc01" translate="yes" xml:space="preserve">
          <source>For symmetric or Hermitian &lt;code&gt;A&lt;/code&gt;, an eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, otherwise the scaling and squaring algorithm (see &lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt;) is chosen.</source>
          <target state="translated">Para sim&amp;eacute;trica o hermitiana &lt;code&gt;A&lt;/code&gt; , un eigendecomposition ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; se utiliza), de lo contrario el escalado y el algoritmo de cuadratura (ver &lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt; ) se elige.</target>
        </trans-unit>
        <trans-unit id="f6c4a6da96174312b12bb84f60f8bf72388ffeca" translate="yes" xml:space="preserve">
          <source>For text I/O, use the &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; methods, depending on your needs (see the documentation for these two methods for a detailed discussion of the difference between them):</source>
          <target state="translated">Para la E / S de texto, utilice los m&amp;eacute;todos de &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; o &lt;code&gt;show&lt;/code&gt; , seg&amp;uacute;n sus necesidades (consulte la documentaci&amp;oacute;n de estos dos m&amp;eacute;todos para obtener una descripci&amp;oacute;n detallada de la diferencia entre ellos):</target>
        </trans-unit>
        <trans-unit id="205743ce47116c17ca0d1d16d7b760bea8f341c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;Squares&lt;/code&gt; iterable above, we can easily compute the &lt;code&gt;i&lt;/code&gt;th element of the sequence by squaring it. We can expose this as an indexing expression &lt;code&gt;S[i]&lt;/code&gt;. To opt into this behavior, &lt;code&gt;Squares&lt;/code&gt; simply needs to define &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Para los &lt;code&gt;Squares&lt;/code&gt; iterables anteriores, podemos calcular f&amp;aacute;cilmente el &lt;code&gt;i&lt;/code&gt; - &amp;eacute;simo elemento de la secuencia elev&amp;aacute;ndolo al cuadrado. Podemos exponer esto como una expresi&amp;oacute;n de indexaci&amp;oacute;n &lt;code&gt;S[i]&lt;/code&gt; . Para optar por este comportamiento, &lt;code&gt;Squares&lt;/code&gt; simplemente necesita definir &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b61259c05b4f470d8af9ec6b5659050e33e9f420" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return the total number of that day of the week in &lt;code&gt;dt&lt;/code&gt;'s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; in the adjuster function.</source>
          <target state="translated">Para el d&amp;iacute;a de la semana de &lt;code&gt;dt&lt;/code&gt; , devuelva el n&amp;uacute;mero total de ese d&amp;iacute;a de la semana en el mes de &lt;code&gt;dt&lt;/code&gt; . Devuelve 4 o 5. &amp;Uacute;til en expresiones temporales para especificar el &amp;uacute;ltimo d&amp;iacute;a de una semana en un mes al incluir &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; en la funci&amp;oacute;n de ajuste.</target>
        </trans-unit>
        <trans-unit id="fe652373fcfd70aa4cf5d9a9c42f569d7f7beb45" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return which number it is in &lt;code&gt;dt&lt;/code&gt;'s month. So if the day of the week of &lt;code&gt;dt&lt;/code&gt; is Monday, then &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; In the range 1:5.</source>
          <target state="translated">Para el d&amp;iacute;a de la semana de &lt;code&gt;dt&lt;/code&gt; , devuelva el n&amp;uacute;mero en el mes de &lt;code&gt;dt&lt;/code&gt; . Entonces, si el d&amp;iacute;a de la semana de &lt;code&gt;dt&lt;/code&gt; es el lunes, entonces &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; En el rango 1: 5.</target>
        </trans-unit>
        <trans-unit id="652922b94585bcd03eb665e42d71bab0709ffc65" translate="yes" xml:space="preserve">
          <source>For the default constructor, exactly one argument must be supplied for each field:</source>
          <target state="translated">Para el constructor por defecto,se debe suministrar exactamente un argumento para cada campo:</target>
        </trans-unit>
        <trans-unit id="56d79b9ca82aa7547916a2539b58ed4630995e94" translate="yes" xml:space="preserve">
          <source>For the remaining keyword arguments, see the documentation of &lt;a href=&quot;#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para los argumentos de palabras clave restantes, consulte la documentaci&amp;oacute;n de &lt;a href=&quot;#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b23a97c3c42b32c810ec362860430dab0f399881" translate="yes" xml:space="preserve">
          <source>For the same reason, contrary to logical operators presented above, the short-circuiting boolean operators &lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;||&lt;/code&gt; do not allow for &lt;code&gt;missing&lt;/code&gt; values in situations where the value of the operand determines whether the next operand is evaluated or not. For example</source>
          <target state="translated">Por la misma raz&amp;oacute;n, contrariamente a los operadores l&amp;oacute;gicos presentados anteriormente, los operadores booleanos de cortocircuito &lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;||&lt;/code&gt; no permita valores &lt;code&gt;missing&lt;/code&gt; en situaciones en las que el valor del operando determina si el siguiente operando se eval&amp;uacute;a o no. Por ejemplo</target>
        </trans-unit>
        <trans-unit id="f6f2cb638bdf85d316fe3667be12ad3cf8fd1cb2" translate="yes" xml:space="preserve">
          <source>For the very common pattern usage pattern of</source>
          <target state="translated">Para el muy común patrón de uso de</target>
        </trans-unit>
        <trans-unit id="abe66bccf2edc923b8619fe03afd5d016c3843ac" translate="yes" xml:space="preserve">
          <source>For these reasons, it's recommended that you try using the built-in sampling profiler before considering any alternatives.</source>
          <target state="translated">Por estas razones,se recomienda que intente utilizar el perfilador de muestreo incorporado antes de considerar cualquier alternativa.</target>
        </trans-unit>
        <trans-unit id="61eee68fc84c521e01e74ee4b3cb32a8a20b7707" translate="yes" xml:space="preserve">
          <source>For translating a C argument list to Julia:</source>
          <target state="translated">Por traducir una lista de argumentos C a Julia:</target>
        </trans-unit>
        <trans-unit id="0c8fe98556d87eebbe139565ad2035f5a8376ab0" translate="yes" xml:space="preserve">
          <source>For translating a C return type to Julia:</source>
          <target state="translated">Por traducir un tipo de retorno C a Julia:</target>
        </trans-unit>
        <trans-unit id="f089947163c1743d34e858e0290c83835145a36d" translate="yes" xml:space="preserve">
          <source>For two arguments, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi, \pi]$. This corresponds to a standard &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Para dos argumentos, este es el &amp;aacute;ngulo en radianes entre el eje &lt;em&gt;x&lt;/em&gt; positivo y el punto ( &lt;em&gt;x&lt;/em&gt; , &lt;em&gt;y&lt;/em&gt; ), que devuelve un valor en el intervalo $ [- \ pi, \ pi] $. Esto corresponde a una funci&amp;oacute;n est&amp;aacute;ndar de &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8784f2a51d06748e116c26d584683c6da35029e2" translate="yes" xml:space="preserve">
          <source>For unbuffered channels returns &lt;code&gt;true&lt;/code&gt; if there are tasks waiting on a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&amp;iexcl;Para canales sin b&amp;uacute;fer, devuelve &lt;code&gt;true&lt;/code&gt; si hay tareas esperando una &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="dcf07feef0790c851bc6f0a6f8cbac38791a64b9" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">Para canales sin b&amp;uacute;fer, bloquee hasta &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;se realiza mediante una tarea diferente.</target>
        </trans-unit>
        <trans-unit id="84b0a200921412bb65f21b5bb7c59da76c4bbed1" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt;&lt;code&gt;take!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">Para canales sin b&amp;uacute;fer, &amp;iexcl;bloquee hasta una &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt; &lt;code&gt;take!&lt;/code&gt; &lt;/a&gt;se realiza mediante una tarea diferente.</target>
        </trans-unit>
        <trans-unit id="b5d88c03e115fa0e1f0ae726ca69a5946e7b8f3d" translate="yes" xml:space="preserve">
          <source>For variable &lt;code&gt;a&lt;/code&gt; and expression &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a = b&lt;/code&gt; makes &lt;code&gt;a&lt;/code&gt; refer to the value of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Para la variable &lt;code&gt;a&lt;/code&gt; y la expresi&amp;oacute;n &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a = b&lt;/code&gt; hace que &lt;code&gt;a&lt;/code&gt; se refiera al valor de &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a2988c23bad5d1f4419c0c3331b505d6761bfd4" translate="yes" xml:space="preserve">
          <source>For when a capture doesn't match, instead of a substring, &lt;code&gt;m.captures&lt;/code&gt; contains &lt;code&gt;nothing&lt;/code&gt; in that position, and &lt;code&gt;m.offsets&lt;/code&gt; has a zero offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid). Here is a pair of somewhat contrived examples:</source>
          <target state="translated">Para cuando una captura no coincide, en lugar de una subcadena, &lt;code&gt;m.captures&lt;/code&gt; &lt;code&gt;nothing&lt;/code&gt; contiene nada en esa posici&amp;oacute;n, y &lt;code&gt;m.offsets&lt;/code&gt; tiene un desplazamiento cero (recuerde que los &amp;iacute;ndices en Julia est&amp;aacute;n basados ​​en 1, por lo que un desplazamiento cero en una cadena es inv&amp;aacute;lido). Aqu&amp;iacute; hay un par de ejemplos algo ingeniosos:</target>
        </trans-unit>
        <trans-unit id="cdc4b17a13e956b864dfd62e85ad672e28429820" translate="yes" xml:space="preserve">
          <source>Force a GC run</source>
          <target state="translated">Forzar una corrida de GC</target>
        </trans-unit>
        <trans-unit id="5eb175b9460612a847c5831f8d611666f7e129b1" translate="yes" xml:space="preserve">
          <source>Forces</source>
          <target state="translated">Forces</target>
        </trans-unit>
        <trans-unit id="08bb485a70c09a4b008d8b79ee39bee0f080480a" translate="yes" xml:space="preserve">
          <source>Forces synchronization between the in-memory version of a memory-mapped &lt;code&gt;Array&lt;/code&gt; or &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; and the on-disk version.</source>
          <target state="translated">Fuerza la sincronizaci&amp;oacute;n entre la versi&amp;oacute;n en memoria de un &lt;code&gt;Array&lt;/code&gt; o &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt; asignado en memoria y la versi&amp;oacute;n en disco.</target>
        </trans-unit>
        <trans-unit id="a4b44623e8c8994cfd237bbb5a20500862bde2d9" translate="yes" xml:space="preserve">
          <source>Fork And Knife</source>
          <target state="translated">Tenedor y cuchillo</target>
        </trans-unit>
        <trans-unit id="cac22bd0e8a69bd849b7be8d79bbdfbf8b44d9d5" translate="yes" xml:space="preserve">
          <source>Forking</source>
          <target state="translated">Forking</target>
        </trans-unit>
        <trans-unit id="050d7641601e8d3bdebb15e95cb05f81983e6de8" translate="yes" xml:space="preserve">
          <source>Format the &lt;code&gt;tok&lt;/code&gt; token from &lt;code&gt;dt&lt;/code&gt; and write it to &lt;code&gt;io&lt;/code&gt;. The formatting can be based on &lt;code&gt;locale&lt;/code&gt;.</source>
          <target state="translated">Formatee el token &lt;code&gt;tok&lt;/code&gt; desde &lt;code&gt;dt&lt;/code&gt; y escr&amp;iacute;balo en &lt;code&gt;io&lt;/code&gt; . El formato puede basarse en la &lt;code&gt;locale&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5449b0de438e10172cfa72d13dabc8ee40d61810" translate="yes" xml:space="preserve">
          <source>Fortran compilers &lt;em&gt;may&lt;/em&gt; also add other hidden arguments for pointers, assumed-shape (&lt;code&gt;:&lt;/code&gt;) and assumed-size (&lt;code&gt;*&lt;/code&gt;) arrays. Such behaviour can be avoided by using &lt;code&gt;ISO_C_BINDING&lt;/code&gt; and including &lt;code&gt;bind(c)&lt;/code&gt; in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only &lt;code&gt;character(len=1)&lt;/code&gt; will be permitted to pass strings).</source>
          <target state="translated">Compiladores de Fortran &lt;em&gt;pueden&lt;/em&gt; a&amp;ntilde;adir tambi&amp;eacute;n otros argumentos ocultos para los punteros, asumido en forma de ( &lt;code&gt;:&lt;/code&gt; ) y de tama&amp;ntilde;o asumido ( &lt;code&gt;*&lt;/code&gt; ) matrices. Dicho comportamiento se puede evitar utilizando &lt;code&gt;ISO_C_BINDING&lt;/code&gt; e incluyendo &lt;code&gt;bind(c)&lt;/code&gt; en la definici&amp;oacute;n de la subrutina, que se recomienda encarecidamente para el c&amp;oacute;digo interoperable. En este caso, no habr&amp;aacute; argumentos ocultos, a costa de algunas caracter&amp;iacute;sticas del lenguaje (por ejemplo, solo se permitir&amp;aacute; que los &lt;code&gt;character(len=1)&lt;/code&gt; pasen cadenas).</target>
        </trans-unit>
        <trans-unit id="a0484116def6ba2539f3b9f9921bd8b4ba22a4aa" translate="yes" xml:space="preserve">
          <source>Fortran name</source>
          <target state="translated">El nombre de Fortran</target>
        </trans-unit>
        <trans-unit id="16c35d1374b93a7d00d34b68d3e6ad6a2c21c760" translate="yes" xml:space="preserve">
          <source>Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; to flip coins on two processes. First, write the following function in &lt;code&gt;count_heads.jl&lt;/code&gt;:</source>
          <target state="translated">Afortunadamente, muchos c&amp;aacute;lculos paralelos &amp;uacute;tiles no requieren movimiento de datos. Un ejemplo com&amp;uacute;n es una simulaci&amp;oacute;n de Monte Carlo, donde m&amp;uacute;ltiples procesos pueden manejar ensayos de simulaci&amp;oacute;n independientes simult&amp;aacute;neamente. Podemos usar &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; para lanzar monedas en dos procesos. Primero, escriba la siguiente funci&amp;oacute;n en &lt;code&gt;count_heads.jl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5dd1ed1b5512a22fba4de952e82beaad9990da5b" translate="yes" xml:space="preserve">
          <source>Forward delete one character (when buffer has text)</source>
          <target state="translated">Reenviar borrar un carácter (cuando la memoria intermedia tiene texto)</target>
        </trans-unit>
        <trans-unit id="d2bd5de8c2484ca6755e34f338af3268021c0a12" translate="yes" xml:space="preserve">
          <source>Forward delete the next word</source>
          <target state="translated">Adelante,borre la siguiente palabra</target>
        </trans-unit>
        <trans-unit id="a187c3285151f39c70caaf5e477c6e87663d3ef4" translate="yes" xml:space="preserve">
          <source>Fountain</source>
          <target state="translated">Fountain</target>
        </trans-unit>
        <trans-unit id="4ab98d03a72763b8222b6d8722ded7966bf98d76" translate="yes" xml:space="preserve">
          <source>Four Leaf Clover</source>
          <target state="translated">Trébol de cuatro hojas</target>
        </trans-unit>
        <trans-unit id="2b13f83d35f7fc73ce97c8b26bfe724907153aae" translate="yes" xml:space="preserve">
          <source>Four-Per-Em Space</source>
          <target state="translated">El espacio de cuatro por minuto</target>
        </trans-unit>
        <trans-unit id="73c09759c4507af6948adebc3787e93351d4acda" translate="yes" xml:space="preserve">
          <source>Fourth Root</source>
          <target state="translated">Cuarta Raíz</target>
        </trans-unit>
        <trans-unit id="c54d686ebd31bf6296f3ac8e3de5cdba7b0fe495" translate="yes" xml:space="preserve">
          <source>Fraction Numerator One</source>
          <target state="translated">Numerador de Fracción Uno</target>
        </trans-unit>
        <trans-unit id="9f62f41c6fc2c6a6ef7e8630ebef06bc253ed2e9" translate="yes" xml:space="preserve">
          <source>Fractions</source>
          <target state="translated">Fractions</target>
        </trans-unit>
        <trans-unit id="1a4eb1bfc4ceb4284f084ca37c8edbaed934f05c" translate="yes" xml:space="preserve">
          <source>Free and open source (&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;MIT licensed&lt;/a&gt;)</source>
          <target state="translated">Libre y de c&amp;oacute;digo abierto (con &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;licencia MIT&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d150e0aaee05d4d7cee80412f889a1b8c7404089" translate="yes" xml:space="preserve">
          <source>French Fries</source>
          <target state="translated">Papas fritas</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">Preguntas frecuentes</target>
        </trans-unit>
        <trans-unit id="2e42fd5fd57e2eddb93e306ecceb863efd070156" translate="yes" xml:space="preserve">
          <source>Fried Shrimp</source>
          <target state="translated">Camarones fritos</target>
        </trans-unit>
        <trans-unit id="d25d30098e10e7246e59352c44263a5bb1531117" translate="yes" xml:space="preserve">
          <source>Frog Face</source>
          <target state="translated">Cara de rana</target>
        </trans-unit>
        <trans-unit id="ec026c33022b335b80bd8f0e64407b39229b2c88" translate="yes" xml:space="preserve">
          <source>From the caller's perspective, this is identical to a regular function; in fact, you don't have to know whether you're calling a regular or generated function. Let's see how &lt;code&gt;foo&lt;/code&gt; behaves:</source>
          <target state="translated">Desde la perspectiva de la persona que llama, esto es id&amp;eacute;ntico a una funci&amp;oacute;n normal; de hecho, no tiene que saber si est&amp;aacute; llamando a una funci&amp;oacute;n normal o generada. Veamos c&amp;oacute;mo se comporta &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ca77e2b5e973595e2f2f608f9805266ed582b1b8" translate="yes" xml:space="preserve">
          <source>From these definitions, one obtains the following behavior:</source>
          <target state="translated">A partir de estas definiciones,se obtiene el siguiente comportamiento:</target>
        </trans-unit>
        <trans-unit id="b422184537e8dbfbffe465f2c662481e754378a9" translate="yes" xml:space="preserve">
          <source>Front-Facing Baby Chick</source>
          <target state="translated">Bebé de cara al frente</target>
        </trans-unit>
        <trans-unit id="6d0c809a561642fe04a663534c34c6a988c1f63d" translate="yes" xml:space="preserve">
          <source>Frown</source>
          <target state="translated">Frown</target>
        </trans-unit>
        <trans-unit id="fb52dd543cda4930bef0a7aed25ec2307f4f2ed5" translate="yes" xml:space="preserve">
          <source>Frowning Face With Open Mouth</source>
          <target state="translated">Cara fruncida con la boca abierta</target>
        </trans-unit>
        <trans-unit id="3b8ae9bdd856b92028c18db46fbc39d04889c711" translate="yes" xml:space="preserve">
          <source>Fuel Pump</source>
          <target state="translated">Bomba de combustible</target>
        </trans-unit>
        <trans-unit id="1dc013b6064daee6213fd09ae3d5ea49df1bdb94" translate="yes" xml:space="preserve">
          <source>Full Block</source>
          <target state="translated">Bloqueo completo</target>
        </trans-unit>
        <trans-unit id="91e2750218473c3715d4640558a3e864dd2b4c5e" translate="yes" xml:space="preserve">
          <source>Full Moon Symbol</source>
          <target state="translated">Símbolo de la Luna Llena</target>
        </trans-unit>
        <trans-unit id="32a64f880ba20480782d9f08062e23749801ebec" translate="yes" xml:space="preserve">
          <source>Full Moon With Face</source>
          <target state="translated">Luna llena con cara</target>
        </trans-unit>
        <trans-unit id="11342457efd18f569b992724d11b3a2d8832ce4b" translate="yes" xml:space="preserve">
          <source>Full Outer Join</source>
          <target state="translated">Completa la unión exterior...</target>
        </trans-unit>
        <trans-unit id="db63acc70bb8aace65207096c8aa56a922c0d72f" translate="yes" xml:space="preserve">
          <source>Fully implemented by:</source>
          <target state="translated">Completamente implementado por:</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="95054001cf3f6f293128fbac88deaae7d22cc115" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;abmult&lt;/code&gt; returns a function &lt;code&gt;f&lt;/code&gt; that multiplies its argument by the absolute value of &lt;code&gt;r&lt;/code&gt;. The inner function assigned to &lt;code&gt;f&lt;/code&gt; is called a &quot;closure&quot;. Inner functions are also used by the language for &lt;code&gt;do&lt;/code&gt;-blocks and for generator expressions.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;abmult&lt;/code&gt; devuelve una funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; que multiplica su argumento por el valor absoluto de &lt;code&gt;r&lt;/code&gt; . La funci&amp;oacute;n interna asignada &lt;code&gt;f&lt;/code&gt; se llama &quot;cierre&quot;. Las funciones internas tambi&amp;eacute;n son utilizadas por el lenguaje para &lt;code&gt;do&lt;/code&gt; -blocks y para expresiones generadoras.</target>
        </trans-unit>
        <trans-unit id="7697b6877e6664e26745e5f66999b4cfefbd165c" translate="yes" xml:space="preserve">
          <source>Function body starting with &lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt;</source>
          <target state="translated">El cuerpo de la funci&amp;oacute;n comienza con &lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa0b7e8266dfec8d33dbc09471974455072b6005" translate="yes" xml:space="preserve">
          <source>Function chaining (sometimes called &quot;piping&quot; or &quot;using a pipe&quot; to send data to a subsequent function) is when you apply a function to the previous function's output:</source>
          <target state="translated">El encadenamiento de funciones (a veces llamado &quot;piping&quot; o &quot;usar un tubo&quot; para enviar datos a una función posterior)es cuando se aplica una función a la salida de la función anterior:</target>
        </trans-unit>
        <trans-unit id="f28a100a083f8e25a3bc12e6db11fea904564f3f" translate="yes" xml:space="preserve">
          <source>Function composition and piping</source>
          <target state="translated">Composición de la función y tuberías</target>
        </trans-unit>
        <trans-unit id="faa5a28142e8b8d79608d822a7ee2fc012117fa0" translate="yes" xml:space="preserve">
          <source>Function composition is when you combine functions together and apply the resulting composition to arguments. You use the function composition operator (&lt;code&gt;∘&lt;/code&gt;) to compose the functions, so &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; is the same as &lt;code&gt;f(g(args...))&lt;/code&gt;.</source>
          <target state="translated">La composici&amp;oacute;n de funciones es cuando combina funciones y aplica la composici&amp;oacute;n resultante a los argumentos. Usas el operador de composici&amp;oacute;n de funciones ( &lt;code&gt;∘&lt;/code&gt; ) para componer las funciones, entonces &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; es lo mismo que &lt;code&gt;f(g(args...))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be8cbdb67375da79abe2b0143f8eebcc7cb99416" translate="yes" xml:space="preserve">
          <source>Function parameters can also be used to constrain the number of arguments that may be supplied to a &quot;varargs&quot; function (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;). The notation &lt;code&gt;Vararg{T,N}&lt;/code&gt; is used to indicate such a constraint. For example:</source>
          <target state="translated">Los par&amp;aacute;metros de funci&amp;oacute;n tambi&amp;eacute;n se pueden usar para restringir el n&amp;uacute;mero de argumentos que se pueden suministrar a una funci&amp;oacute;n &quot;varargs&quot; ( &lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Funciones Varargs&lt;/a&gt; ). La notaci&amp;oacute;n &lt;code&gt;Vararg{T,N}&lt;/code&gt; se usa para indicar tal restricci&amp;oacute;n. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c748f42ec833ed8f7d97105f385770153e5f3a88" translate="yes" xml:space="preserve">
          <source>Function sets &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecs and &lt;code&gt;mirror&lt;/code&gt; flag for remote reference.</source>
          <target state="translated">Conjuntos de funciones &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refs / * refspecs y indicador de &lt;code&gt;mirror&lt;/code&gt; para referencia remota.</target>
        </trans-unit>
        <trans-unit id="ea4be7f77276f932f73d95ac11b41c01bca27493" translate="yes" xml:space="preserve">
          <source>Function-like objects</source>
          <target state="translated">Objetos de función</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="eddb44c7165ef5eabc1df07ca23331299f12c1fa" translate="yes" xml:space="preserve">
          <source>Functionality for base-64 encoded strings and IO.</source>
          <target state="translated">Funcionalidad para cuerdas codificadas en base 64 y IO.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="53a4e15f59ddb4061325c79602aaccdf7b922b54" translate="yes" xml:space="preserve">
          <source>Functions &amp;amp; Methods</source>
          <target state="translated">Funciones y m&amp;eacute;todos</target>
        </trans-unit>
        <trans-unit id="c13326dfc431675363c3f3a461ddb4d2e5748e9f" translate="yes" xml:space="preserve">
          <source>Functions &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt;&lt;code&gt;workers&lt;/code&gt;&lt;/a&gt;, and others are available as a programmatic means of adding, removing and querying the processes in a cluster.</source>
          <target state="translated">Las funciones &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt; &lt;code&gt;workers&lt;/code&gt; &lt;/a&gt; y otras est&amp;aacute;n disponibles como un medio program&amp;aacute;tico para agregar, eliminar y consultar los procesos en un cl&amp;uacute;ster.</target>
        </trans-unit>
        <trans-unit id="0ff075e5c1729ce32f2f5738fecab65d263b0838" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; also follow the rules of three-valued logic, returning &lt;code&gt;missing&lt;/code&gt; when the result cannot be determined</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; y cada &lt;code&gt;any&lt;/code&gt; funciones tambi&amp;eacute;n siguen las reglas de la l&amp;oacute;gica de tres valores, y vuelven a &lt;code&gt;missing&lt;/code&gt; cuando no se puede determinar el resultado</target>
        </trans-unit>
        <trans-unit id="a7372df3a40ed071a29722d4bc6498e66d76a5da" translate="yes" xml:space="preserve">
          <source>Functions and Methods</source>
          <target state="translated">Funciones y métodos</target>
        </trans-unit>
        <trans-unit id="7bb375b3fcf2e8e9d0dbcd433eb2746123db60e5" translate="yes" xml:space="preserve">
          <source>Functions are defined with the &lt;code&gt;function&lt;/code&gt; keyword:</source>
          <target state="translated">Las funciones se definen con la palabra clave de &lt;code&gt;function&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="55e8c66bfd9e6c0e9dfa04cb544f8bb30a80231b" translate="yes" xml:space="preserve">
          <source>Functions in Julia are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;first-class objects&lt;/a&gt;: they can be assigned to variables, and called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:</source>
          <target state="translated">Las funciones en Julia son &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;objetos de primera clase&lt;/a&gt; : pueden asignarse a variables y llamarse utilizando la sintaxis de llamada de funci&amp;oacute;n est&amp;aacute;ndar de la variable a la que han sido asignadas. Se pueden usar como argumentos y se pueden devolver como valores. Tambi&amp;eacute;n se pueden crear de forma an&amp;oacute;nima, sin que se les d&amp;eacute; un nombre, utilizando cualquiera de estas sintaxis:</target>
        </trans-unit>
        <trans-unit id="c04e52a6c310e2a4baade48d1f42fd88819eec1a" translate="yes" xml:space="preserve">
          <source>Functions in Julia can be combined by composing or piping (chaining) them together.</source>
          <target state="translated">Las funciones en Julia pueden combinarse componiéndolas o encadenándolas.</target>
        </trans-unit>
        <trans-unit id="ceeb1ec49508dede84853cbb0f013b3decdfa56c" translate="yes" xml:space="preserve">
          <source>Functions in Julia may have multiple implementations, known as methods. While it's good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by &lt;code&gt;function bar end&lt;/code&gt;). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:</source>
          <target state="translated">Las funciones en Julia pueden tener m&amp;uacute;ltiples implementaciones, conocidas como m&amp;eacute;todos. Si bien es una buena pr&amp;aacute;ctica que las funciones gen&amp;eacute;ricas tengan un solo prop&amp;oacute;sito, Julia permite que los m&amp;eacute;todos se documenten individualmente si es necesario. En general, solo se debe documentar el m&amp;eacute;todo m&amp;aacute;s gen&amp;eacute;rico, o incluso la funci&amp;oacute;n en s&amp;iacute; (es decir, el objeto creado sin ning&amp;uacute;n m&amp;eacute;todo por el &lt;code&gt;function bar end&lt;/code&gt; ). Los m&amp;eacute;todos espec&amp;iacute;ficos solo deben documentarse si su comportamiento difiere de los m&amp;aacute;s gen&amp;eacute;ricos. En cualquier caso, no deben repetir la informaci&amp;oacute;n proporcionada en otro lugar. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="820b3bd7ddec6937c4e242be1bbe2ab057c0ac78" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression or the &lt;code&gt;return&lt;/code&gt; keyword instead of listing the names of variables to return in the function definition (see &lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;The return Keyword&lt;/a&gt; for details).</source>
          <target state="translated">Las funciones en Julia devuelven valores de su &amp;uacute;ltima expresi&amp;oacute;n o la palabra clave de &lt;code&gt;return&lt;/code&gt; lugar de enumerar los nombres de las variables para devolver en la definici&amp;oacute;n de la funci&amp;oacute;n (consulte &lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;La palabra clave de retorno&lt;/a&gt; para obtener m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="a59fb02f015778c14d39ec5b1bcf732d30a76ac1" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression(s) or the &lt;code&gt;return&lt;/code&gt; keyword. Multiple values can be returned from functions and assigned as tuples, e.g. &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; or &lt;code&gt;a, b = myfunction()&lt;/code&gt;, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt;.</source>
          <target state="translated">Las funciones en Julia devuelven valores de sus &amp;uacute;ltimas expresiones o de la palabra clave &lt;code&gt;return&lt;/code&gt; . Se pueden devolver m&amp;uacute;ltiples valores de las funciones y asignarlos como tuplas, por ejemplo &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; o &lt;code&gt;a, b = myfunction()&lt;/code&gt; , en lugar de tener que pasar punteros a valores como se tendr&amp;iacute;a que hacer en C / C ++ ( es decir, &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a55840c344c2be9d92831007662fa28bbfaafd80" translate="yes" xml:space="preserve">
          <source>Functions like &lt;code&gt;strange_twos&lt;/code&gt; occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.</source>
          <target state="translated">Funciones como &lt;code&gt;strange_twos&lt;/code&gt; ocurren cuando se trata de datos de tipo incierto, por ejemplo, datos cargados desde un archivo de entrada que puede contener enteros, flotantes, cadenas u otra cosa.</target>
        </trans-unit>
        <trans-unit id="7b33eb7808d1f3eaa212ba1f622374dd77c823c6" translate="yes" xml:space="preserve">
          <source>Functions on &lt;code&gt;Expr&lt;/code&gt;essions</source>
          <target state="translated">Funciones en &lt;code&gt;Expr&lt;/code&gt; ESIONES</target>
        </trans-unit>
        <trans-unit id="8b8603c397ef929230aa5c590ebf0c5ec135d545" translate="yes" xml:space="preserve">
          <source>Functions pertaining to probability distributions are provided by the &lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;Distributions package&lt;/a&gt;.</source>
          <target state="translated">Las funciones pertenecientes a las distribuciones de probabilidad las proporciona el &lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;paquete Distributions&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07740f0b9c92a3b6637549532f0dfc491685de70" translate="yes" xml:space="preserve">
          <source>Functions that write to their arguments have names that end in &lt;code&gt;!&lt;/code&gt;. These are sometimes called &quot;mutating&quot; or &quot;in-place&quot; functions because they are intended to produce changes in their arguments after the function is called, not just return a value.</source>
          <target state="translated">Las funciones que escriben en sus argumentos tienen nombres que terminan en &lt;code&gt;!&lt;/code&gt; . Estas a veces se denominan funciones &quot;mutantes&quot; o &quot;in situ&quot; porque est&amp;aacute;n destinadas a producir cambios en sus argumentos despu&amp;eacute;s de que se llama a la funci&amp;oacute;n, no solo a devolver un valor.</target>
        </trans-unit>
        <trans-unit id="9cba6354edf31323e29d861220b894beb53b62d4" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments are defined using a semicolon in the signature:</source>
          <target state="translated">Las funciones con argumentos de palabras clave se definen usando un punto y coma en la firma:</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">Más lecturas</target>
        </trans-unit>
        <trans-unit id="0132f20ae5d3a74b84246e40987da84635bfd3d0" translate="yes" xml:space="preserve">
          <source>Furthermore, &quot;dotted&quot; updating operators like &lt;code&gt;a .+= b&lt;/code&gt; (or &lt;code&gt;@. a += b&lt;/code&gt;) are parsed as &lt;code&gt;a .= a .+ b&lt;/code&gt;, where &lt;code&gt;.=&lt;/code&gt; is a fused &lt;em&gt;in-place&lt;/em&gt; assignment operation (see the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax documentation&lt;/a&gt;).</source>
          <target state="translated">Adem&amp;aacute;s, los operadores de actualizaci&amp;oacute;n &quot;punteados&quot; como &lt;code&gt;a .+= b&lt;/code&gt; (o &lt;code&gt;@. a += b&lt;/code&gt; ) se analizan como &lt;code&gt;a .= a .+ b&lt;/code&gt; A. + B , donde &lt;code&gt;.=&lt;/code&gt; Es una operaci&amp;oacute;n de asignaci&amp;oacute;n &lt;em&gt;in situ&lt;/em&gt; fusionada (consulte la &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;documentaci&amp;oacute;n de sintaxis de puntos&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d0dab03985e67ddbff313bf737b40f319ace224" translate="yes" xml:space="preserve">
          <source>Furthermore, the iterable object splatted into a function call need not be a tuple:</source>
          <target state="translated">Además,el objeto iterable salpicado en una llamada de función no tiene por qué ser una tupla:</target>
        </trans-unit>
        <trans-unit id="0e833ac5a09d0da4e04120e7544830f8a65151fd" translate="yes" xml:space="preserve">
          <source>G. W. Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. &lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;doi:10.1137/0905030&lt;/a&gt;</source>
          <target state="translated">GW Stewart, &quot;Degeneraci&amp;oacute;n de rango&quot;, SIAM Journal on Scientific and Statistical Computing, 5 (2), 1984, 403-413. &lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;doi: 10.1137 / 0905030&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="153d4c166a2f860e5ac33c697533af00d178259a" translate="yes" xml:space="preserve">
          <source>GC.@preserve</source>
          <target state="translated">GC.@preserve</target>
        </trans-unit>
        <trans-unit id="3897445415fe5ec5c17d947d2f396ecb73cfab7e" translate="yes" xml:space="preserve">
          <source>GC.enable()</source>
          <target state="translated">GC.enable()</target>
        </trans-unit>
        <trans-unit id="f7f51a07b89aa04e176b4dce9ba6e667279a4cac" translate="yes" xml:space="preserve">
          <source>GC.gc()</source>
          <target state="translated">GC.gc()</target>
        </trans-unit>
        <trans-unit id="dd04fdce0b5db2163f133667347720589a61611d" translate="yes" xml:space="preserve">
          <source>GMP.BigInt</source>
          <target state="translated">GMP.BigInt</target>
        </trans-unit>
        <trans-unit id="ec181f943ce9eb84bc41a51f14f715a4b73d4e15" translate="yes" xml:space="preserve">
          <source>GMP.BigInt()</source>
          <target state="translated">GMP.BigInt()</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="f3b1d13cf7d8da8c19344c722b6886a02e91434d" translate="yes" xml:space="preserve">
          <source>Game Die</source>
          <target state="translated">Juego de dados</target>
        </trans-unit>
        <trans-unit id="23e043a9ee4de0e7b0c73093401aa0bca44ab49b" translate="yes" xml:space="preserve">
          <source>Garbage Collection Safety</source>
          <target state="translated">Seguridad en la recogida de basura</target>
        </trans-unit>
        <trans-unit id="d6d5b4be825ce665265510009390d4b69a148c2b" translate="yes" xml:space="preserve">
          <source>Garbage-collection handle for the return value from &lt;code&gt;@cfunction&lt;/code&gt; when the first argument is annotated with '$'. Like all &lt;code&gt;cfunction&lt;/code&gt; handles, it should be passed to &lt;code&gt;ccall&lt;/code&gt; as a &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, and will be converted automatically at the call site to the appropriate type.</source>
          <target state="translated">Identificador de recolecci&amp;oacute;n de basura para el valor de retorno de &lt;code&gt;@cfunction&lt;/code&gt; cuando el primer argumento est&amp;aacute; anotado con '$'. Como todos los identificadores de &lt;code&gt;cfunction&lt;/code&gt; , debe pasarse a &lt;code&gt;ccall&lt;/code&gt; como un &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; y se convertir&amp;aacute; autom&amp;aacute;ticamente en el sitio de la llamada al tipo apropiado.</target>
        </trans-unit>
        <trans-unit id="dbb8c00bae5bbda144f1736a9cba2314230cbae3" translate="yes" xml:space="preserve">
          <source>Gem Stone</source>
          <target state="translated">Piedra de gema</target>
        </trans-unit>
        <trans-unit id="ddba2c9277cd909b2d4fac91a3cc754a462c7a90" translate="yes" xml:space="preserve">
          <source>Gemini</source>
          <target state="translated">Gemini</target>
        </trans-unit>
        <trans-unit id="9203a7a738516ae214b4ae47d8b7fd816429f200" translate="yes" xml:space="preserve">
          <source>General Collections</source>
          <target state="translated">Colecciones generales</target>
        </trans-unit>
        <trans-unit id="b87cf666cc00e115fb18674c6deb84af8b517c7f" translate="yes" xml:space="preserve">
          <source>General I/O</source>
          <target state="translated">I/O general</target>
        </trans-unit>
        <trans-unit id="4979599c738b7850931480557307563f3cf52a2f" translate="yes" xml:space="preserve">
          <source>General Number Functions and Constants</source>
          <target state="translated">Funciones y constantes de los números generales</target>
        </trans-unit>
        <trans-unit id="6b7059d9b81b1f245d958405a414e29373725e72" translate="yes" xml:space="preserve">
          <source>General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">Escape general de secuencias de escape tradicionales de C y Unicode. El primer formulario devuelve la cadena de escape, el segundo imprime el resultado en &lt;code&gt;io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e9dfb96c25a921933f55dcf7822775fb8e071eb" translate="yes" xml:space="preserve">
          <source>General exceptions can be raised using the functions:</source>
          <target state="translated">Las excepciones generales pueden plantearse utilizando las funciones:</target>
        </trans-unit>
        <trans-unit id="aa8e53d9ebff9d0979fd39b344364382458a81b6" translate="yes" xml:space="preserve">
          <source>General non-square</source>
          <target state="translated">General no cuadrado</target>
        </trans-unit>
        <trans-unit id="07891976324532c807b79ec56fda0fc0b9da6708" translate="yes" xml:space="preserve">
          <source>General square</source>
          <target state="translated">Plaza general</target>
        </trans-unit>
        <trans-unit id="1d3f6af2e9c4d5b2ed46f9e07478d485ceb20715" translate="yes" xml:space="preserve">
          <source>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">Eliminaci&amp;oacute;n general de las secuencias de escape tradicionales de C y Unicode. El primer formulario devuelve la cadena de escape, el segundo imprime el resultado en &lt;code&gt;io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0285ea21d10ed4a7913ad2a66cb346f95bc9d78" translate="yes" xml:space="preserve">
          <source>Generalized SVD</source>
          <target state="translated">SVD generalizado</target>
        </trans-unit>
        <trans-unit id="4d85331d4948d0ae34d7f8f8e070efd57ba16e64" translate="yes" xml:space="preserve">
          <source>Generalized linear models are provided by the &lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM package&lt;/a&gt;.</source>
          <target state="translated">El &lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;paquete GLM&lt;/a&gt; proporciona modelos lineales generalizados .</target>
        </trans-unit>
        <trans-unit id="5ad14a691ce38a290bae999d447b8c703f49ef6b" translate="yes" xml:space="preserve">
          <source>Generally, new types should implement &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt; instead of this function, and rely on the fallback definition &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">Generalmente, los nuevos tipos deben implementar &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; en&lt;/a&gt; lugar de esta funci&amp;oacute;n y depender de la definici&amp;oacute;n de reserva &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f33a08ad09d1f8b477ee12ea78ff5b8bbea276a6" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;BitArray&lt;/code&gt; of random boolean values.</source>
          <target state="translated">Genere un &lt;code&gt;BitArray&lt;/code&gt; de valores booleanos aleatorios.</target>
        </trans-unit>
        <trans-unit id="fd53bfe967151037d3aab623a3c39dc68a9e6a07" translate="yes" xml:space="preserve">
          <source>Generate a C-callable function pointer from the Julia function &lt;code&gt;callable&lt;/code&gt; for the given type signature. To pass the return value to a &lt;code&gt;ccall&lt;/code&gt;, use the argument type &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; in the signature.</source>
          <target state="translated">Genere un puntero de funci&amp;oacute;n &lt;code&gt;callable&lt;/code&gt; en C a partir de la funci&amp;oacute;n de Julia invocable para la firma de tipo dada. Para pasar el valor de retorno a un &lt;code&gt;ccall&lt;/code&gt; , use el tipo de argumento &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; en la firma.</target>
        </trans-unit>
        <trans-unit id="41e2ff826d751563b9e50313fe308bc12b868933" translate="yes" xml:space="preserve">
          <source>Generate a normally-distributed random number of type &lt;code&gt;T&lt;/code&gt; with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default), and their &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution.</source>
          <target state="translated">Genere un n&amp;uacute;mero aleatorio distribuido normalmente de tipo &lt;code&gt;T&lt;/code&gt; con media 0 y desviaci&amp;oacute;n est&amp;aacute;ndar 1. Opcionalmente, genere una matriz de n&amp;uacute;meros aleatorios distribuidos normalmente. El m&amp;oacute;dulo &lt;code&gt;Base&lt;/code&gt; actualmente proporciona una implementaci&amp;oacute;n para los tipos &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; (el predeterminado), y sus contrapartes &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; . Cuando el argumento de tipo es complejo, los valores se extraen de la distribuci&amp;oacute;n normal compleja circularmente sim&amp;eacute;trica.</target>
        </trans-unit>
        <trans-unit id="d735a31a4d0a7d19a36da47899d779f788bda4b7" translate="yes" xml:space="preserve">
          <source>Generate a random number of type &lt;code&gt;T&lt;/code&gt; according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default).</source>
          <target state="translated">Genere un n&amp;uacute;mero aleatorio de tipo &lt;code&gt;T&lt;/code&gt; de acuerdo con la distribuci&amp;oacute;n exponencial con escala 1. Opcionalmente, genere una matriz de dichos n&amp;uacute;meros aleatorios. El m&amp;oacute;dulo &lt;code&gt;Base&lt;/code&gt; actualmente proporciona una implementaci&amp;oacute;n para los tipos &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; (el predeterminado).</target>
        </trans-unit>
        <trans-unit id="0fd80a1d3f890e93d6b1dc16c37a28152669461b" translate="yes" xml:space="preserve">
          <source>Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed.</source>
          <target state="translated">Generar una ruta de archivo temporal.Esta función sólo devuelve una ruta;no se crea ningún archivo.Es probable que la ruta sea única,pero esto no se puede garantizar.</target>
        </trans-unit>
        <trans-unit id="3e42af03cf7e4fa9b19d5375dcdec38dc109c9bc" translate="yes" xml:space="preserve">
          <source>Generated functions</source>
          <target state="translated">Funciones generadas</target>
        </trans-unit>
        <trans-unit id="40080cfd55d586fc4f5401be4bb1834fea88976c" translate="yes" xml:space="preserve">
          <source>Generated functions can achieve high efficiency at run time, but come with a compile time cost: a new function body must be generated for every combination of concrete argument types. Typically, Julia is able to compile &quot;generic&quot; versions of functions that will work for any arguments, but with generated functions this is impossible. This means that programs making heavy use of generated functions might be impossible to statically compile.</source>
          <target state="translated">Las funciones generadas pueden alcanzar una gran eficiencia en tiempo de ejecución,pero tienen un costo en tiempo de compilación:se debe generar un nuevo cuerpo de funciones para cada combinación de tipos de argumentos concretos.Normalmente,Julia es capaz de compilar versiones &quot;genéricas&quot; de funciones que funcionarán para cualquier argumento,pero con las funciones generadas esto es imposible.Esto significa que los programas que hacen un uso intensivo de las funciones generadas podrían ser imposibles de compilar estáticamente.</target>
        </trans-unit>
        <trans-unit id="503406d41ab4e8215a281c0d73cf5e1840925953" translate="yes" xml:space="preserve">
          <source>Generated functions must not &lt;em&gt;mutate&lt;/em&gt; or &lt;em&gt;observe&lt;/em&gt; any non-constant global state (including, for example, IO, locks, non-local dictionaries, or using &lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt;&lt;code&gt;hasmethod&lt;/code&gt;&lt;/a&gt;). This means they can only read global constants, and cannot have any side effects. In other words, they must be completely pure. Due to an implementation limitation, this also means that they currently cannot define a closure or generator.</source>
          <target state="translated">Las funciones generadas no deben &lt;em&gt;mutar&lt;/em&gt; ni &lt;em&gt;observar&lt;/em&gt; ning&amp;uacute;n estado global no constante (incluidos, por ejemplo, IO, bloqueos, diccionarios no locales o el uso de &lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt; &lt;code&gt;hasmethod&lt;/code&gt; &lt;/a&gt; ). Esto significa que solo pueden leer constantes globales y no pueden tener efectos secundarios. En otras palabras, deben ser completamente puros. Debido a una limitaci&amp;oacute;n de implementaci&amp;oacute;n, esto tambi&amp;eacute;n significa que actualmente no pueden definir un cierre o generador.</target>
        </trans-unit>
        <trans-unit id="3ef0ab87b9316844c35d99faef219c9c7322d80c" translate="yes" xml:space="preserve">
          <source>Generated values can be filtered using the &lt;code&gt;if&lt;/code&gt; keyword:</source>
          <target state="translated">Los valores generados se pueden filtrar usando la palabra clave &lt;code&gt;if&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="43a3b60a1f43668fa7df03ea6999eb9005534d03" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;A&lt;/code&gt; and removes stored numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;rowval&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Genera una copia de &lt;code&gt;A&lt;/code&gt; y elimina los ceros num&amp;eacute;ricos almacenados de esa copia, recortando opcionalmente el espacio sobrante de las matrices &lt;code&gt;rowval&lt;/code&gt; y &lt;code&gt;nzval&lt;/code&gt; del resultado cuando &lt;code&gt;trim&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa8200a561dd1fd6d9a2571a09a8c0833fd591d2" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;x&lt;/code&gt; and removes numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;nzind&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Genera una copia de &lt;code&gt;x&lt;/code&gt; y elimina los ceros num&amp;eacute;ricos de esa copia, recortando opcionalmente el espacio sobrante de las matrices &lt;code&gt;nzind&lt;/code&gt; y &lt;code&gt;nzval&lt;/code&gt; del resultado cuando &lt;code&gt;trim&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d35e347a9e9f11c97762e02cb3817fdf6492b95" translate="yes" xml:space="preserve">
          <source>Generates a gensym symbol for a variable. For example, &lt;code&gt;@gensym x y&lt;/code&gt; is transformed into &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt;.</source>
          <target state="translated">Genera un s&amp;iacute;mbolo de gensym para una variable. Por ejemplo, &lt;code&gt;@gensym x y&lt;/code&gt; se transforma en &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82624d1ced08378811cc12e5b9bb3247c76bde71" translate="yes" xml:space="preserve">
          <source>Generates a symbol which will not conflict with other variable names.</source>
          <target state="translated">Genera un símbolo que no entrará en conflicto con otros nombres de variables.</target>
        </trans-unit>
        <trans-unit id="6493dacd8d9340030628eff5048e31c32e36106f" translate="yes" xml:space="preserve">
          <source>Generates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.</source>
          <target state="translated">Genera una versión 1 (basada en el tiempo)de un identificador único universal (UUID),como se especifica en el RFC 4122.Tenga en cuenta que el ID de Nodo se genera de forma aleatoria (no identifica al anfitrión)según la sección 4.5 del RFC.</target>
        </trans-unit>
        <trans-unit id="5c0ffbf6fa6cd08065c3fd1e20d39e7262ac9916" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">Genera una versión 4 (aleatoria o pseudoaleatoria)de un identificador único universal (UUID),como se especifica en el RFC 4122.</target>
        </trans-unit>
        <trans-unit id="6864e40d6120ff94e92379a41401cda33ec26eb1" translate="yes" xml:space="preserve">
          <source>Generates a version 5 (namespace and domain-based) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">Genera una versión 5 (basada en el espacio de nombres y en el dominio)de un identificador único universal (UUID),como se especifica en la RFC 4122.</target>
        </trans-unit>
        <trans-unit id="31ad5eda3014502203f1f1c9f4f8ad8b0addc8bb" translate="yes" xml:space="preserve">
          <source>Generating random values of custom types</source>
          <target state="translated">Generando valores aleatorios de tipos personalizados</target>
        </trans-unit>
        <trans-unit id="ea6d79a7c35cdb9d37f8d907393ca6d0663b71e9" translate="yes" xml:space="preserve">
          <source>Generating values for an &lt;code&gt;AbstractFloat&lt;/code&gt; type</source>
          <target state="translated">Generando valores para un tipo &lt;code&gt;AbstractFloat&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79059f17dfecc212b29a403a6fe768eae1bb1610" translate="yes" xml:space="preserve">
          <source>Generating values from a collection</source>
          <target state="translated">Generar valores a partir de una colección</target>
        </trans-unit>
        <trans-unit id="5f32399dda528ab0f4979390ae10b103edb83e67" translate="yes" xml:space="preserve">
          <source>Generating values from a type</source>
          <target state="translated">Generando valores de un tipo</target>
        </trans-unit>
        <trans-unit id="217dffa188c85186f3dde4d07c906c09c058f848" translate="yes" xml:space="preserve">
          <source>Generator Expressions</source>
          <target state="translated">Expresiones del generador</target>
        </trans-unit>
        <trans-unit id="111436dce43eef86f4f13a06226e540548b10b69" translate="yes" xml:space="preserve">
          <source>Generators (creation and seeding)</source>
          <target state="translated">Generadores (creación y siembra)</target>
        </trans-unit>
        <trans-unit id="ab25cfdc66be945181ae90276749fb192703ddc0" translate="yes" xml:space="preserve">
          <source>Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function. For example, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; captures the three variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; from the enclosing scope. Captured variables can present performance challenges; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">Los generadores se implementan mediante funciones internas. Al igual que las funciones internas que se utilizan en otras partes del lenguaje, las variables del &amp;aacute;mbito adjunto se pueden &quot;capturar&quot; en la funci&amp;oacute;n interna. Por ejemplo, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; captura las tres variables &lt;code&gt;p&lt;/code&gt; , &lt;code&gt;q&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; del alcance de encerramiento. Las variables capturadas pueden presentar desaf&amp;iacute;os de desempe&amp;ntilde;o; consulte los &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;consejos de rendimiento&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83082f46072d254fd933bf6e78414552f2b12960" translate="yes" xml:space="preserve">
          <source>Generic Functions</source>
          <target state="translated">Funciones genéricas</target>
        </trans-unit>
        <trans-unit id="2654c4b9018fcc37437c59923d4ac1eabf19c850" translate="yes" xml:space="preserve">
          <source>Generic equality operator. Falls back to &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, &lt;code&gt;==&lt;/code&gt; is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.</source>
          <target state="translated">Operador de igualdad gen&amp;eacute;rico. Vuelve a &lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt; . Debe implementarse para todos los tipos con una noci&amp;oacute;n de igualdad, basada en el valor abstracto que representa una instancia. Por ejemplo, todos los tipos num&amp;eacute;ricos se comparan por valor num&amp;eacute;rico, ignorando el tipo. Las cadenas se comparan como secuencias de caracteres, ignorando la codificaci&amp;oacute;n. Para las colecciones, &lt;code&gt;==&lt;/code&gt; generalmente se llama de forma recursiva en todos los contenidos, aunque tambi&amp;eacute;n se pueden tener en cuenta otras propiedades (como la forma de las matrices).</target>
        </trans-unit>
        <trans-unit id="a247769c311d71434e7dbab7ffa2c58b32221569" translate="yes" xml:space="preserve">
          <source>Generic error type. The error message, in the &lt;code&gt;.msg&lt;/code&gt; field, may provide more specific details.</source>
          <target state="translated">Tipo de error gen&amp;eacute;rico. El mensaje de error, en el campo &lt;code&gt;.msg&lt;/code&gt; , puede proporcionar detalles m&amp;aacute;s espec&amp;iacute;ficos.</target>
        </trans-unit>
        <trans-unit id="0a2cbe8ef5a6182effacad0728af04d3466e9419" translate="yes" xml:space="preserve">
          <source>Generically sized uniform scaling operator defined as a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Gen&amp;eacute;ricamente tama&amp;ntilde;o operador de escala uniforme define como un momento escalares del operador identidad, &lt;code&gt;&amp;lambda;*I&lt;/code&gt; . V&amp;eacute;ase tambi&amp;eacute;n &lt;a href=&quot;#LinearAlgebra.I&quot;&gt; &lt;code&gt;I&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7021447d5c6f5d07882ea34fcf74ffd494b65a7" translate="yes" xml:space="preserve">
          <source>Geometric Proportion</source>
          <target state="translated">Proporción geométrica</target>
        </trans-unit>
        <trans-unit id="e505f741dc44890868c87aa48f3d8916c6fb0128" translate="yes" xml:space="preserve">
          <source>Geometrically Equal To</source>
          <target state="translated">Geométricamente igual a</target>
        </trans-unit>
        <trans-unit id="f64b845181c47fc7995221a47eaadce47af6bcc8" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To</source>
          <target state="translated">Geométricamente equivalente a</target>
        </trans-unit>
        <trans-unit id="30404c5812bd3cd0bc1e26c11cfbb33861e4d141" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Geométricamente equivalente a+Combinando la superposición de sólidos largos/superposición de barras largas no espaciadas</target>
        </trans-unit>
        <trans-unit id="ea2ac5cf7c4e856204e6a41aeaaa0b3dd4ef2ab5" translate="yes" xml:space="preserve">
          <source>Get Julia's process ID.</source>
          <target state="translated">Consigue la identificación del proceso de Julia.</target>
        </trans-unit>
        <trans-unit id="76117157c574ac5727a236f6277b1450a47c5f21" translate="yes" xml:space="preserve">
          <source>Get a backtrace object for the current program point.</source>
          <target state="translated">Consigue un objeto de rastreo para el punto actual del programa.</target>
        </trans-unit>
        <trans-unit id="6245e1b22dd874707de430f7178865b9a33deacf" translate="yes" xml:space="preserve">
          <source>Get a hash value for &lt;code&gt;x&lt;/code&gt; based on object identity. &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; if &lt;code&gt;x === y&lt;/code&gt;.</source>
          <target state="translated">Obtenga un valor hash para &lt;code&gt;x&lt;/code&gt; basado en la identidad del objeto. &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; si &lt;code&gt;x === y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="594cb8bf35cce2c570e740ff46837e8b661e81ff" translate="yes" xml:space="preserve">
          <source>Get a list of all reference names in the &lt;code&gt;repo&lt;/code&gt; repository.</source>
          <target state="translated">Obtenga una lista de todos los nombres de referencia en el &lt;code&gt;repo&lt;/code&gt; sitorio de repositorio.</target>
        </trans-unit>
        <trans-unit id="edea7d0cabb9a933daebe03151b03bacc57f2132" translate="yes" xml:space="preserve">
          <source>Get a list of all tags in the git repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">Obtener una lista de todas las etiquetas en el repositorio git &lt;code&gt;repo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c83b8077da01523efd9ec95df9552f34eef56509" translate="yes" xml:space="preserve">
          <source>Get a module's enclosing &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;Main&lt;/code&gt; is its own parent.</source>
          <target state="translated">Obtenga el m&amp;oacute;dulo adjunto de un &lt;code&gt;Module&lt;/code&gt; . &lt;code&gt;Main&lt;/code&gt; es su propio padre.</target>
        </trans-unit>
        <trans-unit id="91aa8a1066c0cf259f10453272965a98317015dc" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the first &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Obtenga una cadena que consta de los primeros &lt;code&gt;n&lt;/code&gt; caracteres de &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a14f2cfc2cb6c1c852e03fd6e4a706f0a47df06c" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the last &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Obtenga una cadena que consta de los &amp;uacute;ltimos &lt;code&gt;n&lt;/code&gt; caracteres de &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3372d98da97932978011accfa92cc350dd85fc43" translate="yes" xml:space="preserve">
          <source>Get a tuple or a vector of the properties (&lt;code&gt;x.property&lt;/code&gt;) of an object &lt;code&gt;x&lt;/code&gt;. This is typically the same as &lt;a href=&quot;#Base.fieldnames&quot;&gt;&lt;code&gt;fieldnames(typeof(x))&lt;/code&gt;&lt;/a&gt;, but types that overload &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt; should generally overload &lt;code&gt;propertynames&lt;/code&gt; as well to get the properties of an instance of the type.</source>
          <target state="translated">Obtenga una tupla o un vector de las propiedades ( &lt;code&gt;x.property&lt;/code&gt; ) de un objeto &lt;code&gt;x&lt;/code&gt; . Suele ser lo mismo que los &lt;a href=&quot;#Base.fieldnames&quot;&gt; &lt;code&gt;fieldnames(typeof(x))&lt;/code&gt; &lt;/a&gt; , pero los tipos que sobrecargan &lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; &lt;/a&gt; deber&amp;iacute;an sobrecargar tambi&amp;eacute;n los nombres de &lt;code&gt;propertynames&lt;/code&gt; para obtener las propiedades de una instancia del tipo.</target>
        </trans-unit>
        <trans-unit id="42f453edc0370fb274422ead5407c2776b31db1f" translate="yes" xml:space="preserve">
          <source>Get a tuple with the names of the fields of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">Obtenga una tupla con los nombres de los campos de un &lt;code&gt;DataType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d530106390fd810b016b6212bad35ad44f20a8f4" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine of the specified type. Throws if no addresses of the specified type are available.</source>
          <target state="translated">Obtener una dirección IP de la máquina local del tipo especificado.Se lanza si no hay direcciones del tipo especificado disponibles.</target>
        </trans-unit>
        <trans-unit id="7cad9add4d27400ccccd1e83a0b5fe65f627675d" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine, preferring IPv4 over IPv6. Throws if no addresses are available.</source>
          <target state="translated">Consigue una dirección IP de la máquina local,prefiriendo IPv4 sobre IPv6.Lanza si no hay direcciones disponibles.</target>
        </trans-unit>
        <trans-unit id="d1b1f967961007a8e3404abb4f0fb2c9b3d00448" translate="yes" xml:space="preserve">
          <source>Get an array of the names exported by a &lt;code&gt;Module&lt;/code&gt;, excluding deprecated names. If &lt;code&gt;all&lt;/code&gt; is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If &lt;code&gt;imported&lt;/code&gt; is true, then names explicitly imported from other modules are also included.</source>
          <target state="translated">Obtenga una matriz de los nombres exportados por un &lt;code&gt;Module&lt;/code&gt; , excluidos los nombres obsoletos. Si &lt;code&gt;all&lt;/code&gt; es verdadero, la lista tambi&amp;eacute;n incluye nombres no exportados definidos en el m&amp;oacute;dulo, nombres obsoletos y nombres generados por el compilador. Si &lt;code&gt;imported&lt;/code&gt; es verdadero, tambi&amp;eacute;n se incluyen los nombres importados expl&amp;iacute;citamente de otros m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="171cab21a362e3fe558e803f2cb2a0d2a8e62a11" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Module&lt;/code&gt; of the toplevel eval, which is the &lt;code&gt;Module&lt;/code&gt; code is currently being read from.</source>
          <target state="translated">Obtenga el &lt;code&gt;Module&lt;/code&gt; de la evaluaci&amp;oacute;n de nivel superior, que es el c&amp;oacute;digo del &lt;code&gt;Module&lt;/code&gt; que se est&amp;aacute; leyendo actualmente.</target>
        </trans-unit>
        <trans-unit id="7881586bad23ccbb959e0086fba3cebe29d398b8" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;fetch&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to fetch from.</source>
          <target state="translated">Obtenga las refspecs de &lt;em&gt;recuperaci&amp;oacute;n&lt;/em&gt; para el &lt;code&gt;rmt&lt;/code&gt; especificado . Estas especificaciones de referencia contienen informaci&amp;oacute;n sobre qu&amp;eacute; rama (s) buscar.</target>
        </trans-unit>
        <trans-unit id="f2abefd55e48cb868afd9b2bbc8365ad10b4fa4f" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;push&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to push to.</source>
          <target state="translated">Obtenga las refspecs &lt;em&gt;push&lt;/em&gt; para el &lt;code&gt;rmt&lt;/code&gt; especificado . Estas especificaciones de referencia contienen informaci&amp;oacute;n sobre a qu&amp;eacute; rama (s) enviar.</target>
        </trans-unit>
        <trans-unit id="0ec8068370cc3ffbb8329c71ce1fa5a1af831971" translate="yes" xml:space="preserve">
          <source>Get the ID number of the current thread of execution. The master thread has ID &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Obtenga el n&amp;uacute;mero de identificaci&amp;oacute;n del hilo de ejecuci&amp;oacute;n actual. El hilo maestro tiene ID &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="899b97d6f0cff7934c3aa84ef79f50d77403aeb3" translate="yes" xml:space="preserve">
          <source>Get the IP address and port of the remote endpoint that the given socket is connected to. Valid only for connected TCP sockets.</source>
          <target state="translated">Obtener la dirección IP y el puerto del punto final remoto al que está conectado el enchufe dado.Válido sólo para los sockets TCP conectados.</target>
        </trans-unit>
        <trans-unit id="b30337efd6e1ddf333502df0ba154f1bbe883302" translate="yes" xml:space="preserve">
          <source>Get the IP address and port that the given socket is bound to.</source>
          <target state="translated">Obtener la dirección IP y el puerto al que está vinculado el enchufe dado.</target>
        </trans-unit>
        <trans-unit id="ae34bdec6f00934e072471fe83b1ec1bb0253d9e" translate="yes" xml:space="preserve">
          <source>Get the IP addresses of the local machine of the specified type.</source>
          <target state="translated">Obtener las direcciones IP de la máquina local del tipo especificado.</target>
        </trans-unit>
        <trans-unit id="80e3f3bd81b00cd5fdff2163bfb439bea6bf2f6a" translate="yes" xml:space="preserve">
          <source>Get the IPv4 addresses of the local machine.</source>
          <target state="translated">Consigue las direcciones IPv4 de la máquina local.</target>
        </trans-unit>
        <trans-unit id="fc0c58665e06f4bcac50a3a051a380e40687f694" translate="yes" xml:space="preserve">
          <source>Get the additive identity element for the type of &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt; can also specify the type itself).</source>
          <target state="translated">Obtenga el elemento de identidad aditivo para el tipo de &lt;code&gt;x&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; tambi&amp;eacute;n puede especificar el tipo en s&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="13d05d3446c1b045371ca3c580a406fe6efa3a85" translate="yes" xml:space="preserve">
          <source>Get the backtrace of the current exception, for use within &lt;code&gt;catch&lt;/code&gt; blocks.</source>
          <target state="translated">Obtenga el seguimiento de la excepci&amp;oacute;n actual, para usarlo dentro de &lt;code&gt;catch&lt;/code&gt; bloques de captura .</target>
        </trans-unit>
        <trans-unit id="d0b515694c2e31069f75a4341701ebdddc0dbcfa" translate="yes" xml:space="preserve">
          <source>Get the child process ID, if it still exists.</source>
          <target state="translated">Consigue la identificación del proceso del niño,si todavía existe.</target>
        </trans-unit>
        <trans-unit id="b7046c13174456af8138867bb2456e8e9106c14f" translate="yes" xml:space="preserve">
          <source>Get the concrete type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Obtenga el tipo concreto de &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47ebb15e57ce473b474a7f913ff4aa9d19236677" translate="yes" xml:space="preserve">
          <source>Get the current floating point rounding mode for type &lt;code&gt;T&lt;/code&gt;, controlling the rounding of basic arithmetic functions (&lt;a href=&quot;../math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;a href=&quot;../math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;sqrt&lt;/code&gt;) and type conversion.</source>
          <target state="translated">Obtener el modo actual de punto flotante de redondeo para el tipo &lt;code&gt;T&lt;/code&gt; , que controla el redondeo de las funciones aritm&amp;eacute;ticas b&amp;aacute;sicas ( &lt;a href=&quot;../math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;a href=&quot;../math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt; y la &lt;code&gt;sqrt&lt;/code&gt; ) y la conversi&amp;oacute;n de tipos.</target>
        </trans-unit>
        <trans-unit id="054e0f64d6af85ef39cd5689d518feb6140528b2" translate="yes" xml:space="preserve">
          <source>Get the current position of a stream.</source>
          <target state="translated">Obtener la posición actual de un arroyo.</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">Consigue el directorio de trabajo actual.</target>
        </trans-unit>
        <trans-unit id="b150736a9f570c696c7e152a5f442d80d1bfe707" translate="yes" xml:space="preserve">
          <source>Get the currently running &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Obtenga la &lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; que se est&amp;aacute; ejecutando actualmente .</target>
        </trans-unit>
        <trans-unit id="307991aa1f7f375be076c27a6b5e16a8e43f1f24" translate="yes" xml:space="preserve">
          <source>Get the directory part of a path. Trailing characters ('/' or '\') in the path are counted as part of the path.</source>
          <target state="translated">Obtener la parte del directorio de una ruta.Los caracteres de arrastre ('/' o '\')en la ruta se cuentan como parte de la ruta.</target>
        </trans-unit>
        <trans-unit id="15803f5611fdfd7a4570ea4b6299230e231b89c3" translate="yes" xml:space="preserve">
          <source>Get the exponent of a normalized floating-point number.</source>
          <target state="translated">Consigue el exponente de un número de punto flotante normalizado.</target>
        </trans-unit>
        <trans-unit id="428d1e51e8fd8658370395752d8d28b03956207a" translate="yes" xml:space="preserve">
          <source>Get the fetch URL of a remote git repository.</source>
          <target state="translated">Obtener la URL de un repositorio remoto de git.</target>
        </trans-unit>
        <trans-unit id="6395adf311f39b7041b3bc31800f3ac3ac69f04a" translate="yes" xml:space="preserve">
          <source>Get the file name part of a path.</source>
          <target state="translated">Consigue que el nombre del archivo forme parte de una ruta.</target>
        </trans-unit>
        <trans-unit id="45d031a98e3d7988439346e5f12753ad44f6564c" translate="yes" xml:space="preserve">
          <source>Get the first element of an iterable collection. Return the start point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">Obt&amp;eacute;n el primer elemento de una colecci&amp;oacute;n iterable. Devuelve el punto de inicio de un &lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt; incluso si est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="803a6a556ee1107f53d846bba76956752d4f95be" translate="yes" xml:space="preserve">
          <source>Get the fully-qualified name of a module as a tuple of symbols. For example,</source>
          <target state="translated">Obtener el nombre completo de un módulo como una tupla de símbolos.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="9fe2dd6fafde9402b9bebe656d7e76ff3412ff6a" translate="yes" xml:space="preserve">
          <source>Get the git object to which &lt;code&gt;te&lt;/code&gt; refers and return it as its actual type (the type &lt;a href=&quot;#LibGit2.entrytype&quot;&gt;&lt;code&gt;entrytype&lt;/code&gt;&lt;/a&gt; would show), for instance a &lt;code&gt;GitBlob&lt;/code&gt; or &lt;code&gt;GitTag&lt;/code&gt;.</source>
          <target state="translated">Obtenga el objeto git al que se refiere &lt;code&gt;te&lt;/code&gt; y devu&amp;eacute;lvalo como su tipo real ( se mostrar&amp;iacute;a el tipo de &lt;a href=&quot;#LibGit2.entrytype&quot;&gt; &lt;code&gt;entrytype&lt;/code&gt; &lt;/a&gt; tipo ), por ejemplo, un &lt;code&gt;GitBlob&lt;/code&gt; o &lt;code&gt;GitTag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="353f9fc88dc058135091370ad6a5d9c59fcfda6e" translate="yes" xml:space="preserve">
          <source>Get the id of the current process.</source>
          <target state="translated">Consigue la identificación del proceso actual.</target>
        </trans-unit>
        <trans-unit id="4e1a5fc780c8cf7e7bc238f6885dd2ba9bd5e31b" translate="yes" xml:space="preserve">
          <source>Get the key type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Obtenga el tipo de clave de un tipo de diccionario. Se comporta de manera similar a &lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7db9e0d4b309f243e7497e360f841540e11cc1fa" translate="yes" xml:space="preserve">
          <source>Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling &lt;a href=&quot;#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to get the last index. Return the end point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">Obtenga el &amp;uacute;ltimo elemento de una colecci&amp;oacute;n ordenada, si se puede calcular en O (1) tiempo. Esto se logra llamando a &lt;a href=&quot;#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt; para obtener el &amp;uacute;ltimo &amp;iacute;ndice. Devuelve el punto final de un &lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt; incluso si est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="acd04aae132c80a71e1f513a908b2702371aa23c" translate="yes" xml:space="preserve">
          <source>Get the local machine's host name.</source>
          <target state="translated">Consigue el nombre de la máquina local.</target>
        </trans-unit>
        <trans-unit id="7880b6703d5b76a9fbb2e0506acfbba24be95f11" translate="yes" xml:space="preserve">
          <source>Get the memory address of a Julia object as a &lt;code&gt;Ptr&lt;/code&gt;. The existence of the resulting &lt;code&gt;Ptr&lt;/code&gt; will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the &lt;code&gt;Ptr&lt;/code&gt; will be used.</source>
          <target state="translated">Obtenga la direcci&amp;oacute;n de memoria de un objeto Julia como &lt;code&gt;Ptr&lt;/code&gt; . La existencia del &lt;code&gt;Ptr&lt;/code&gt; resultante no proteger&amp;aacute; al objeto de la recolecci&amp;oacute;n de basura, por lo que debe asegurarse de que el objeto permanezca referenciado durante todo el tiempo que se utilizar&amp;aacute; el &lt;code&gt;Ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="563766b2618b2d015ed0e9c3d29a5e7becea72bb" translate="yes" xml:space="preserve">
          <source>Get the name of a (potentially &lt;code&gt;UnionAll&lt;/code&gt;-wrapped) &lt;code&gt;DataType&lt;/code&gt; (without its parent module) as a symbol.</source>
          <target state="translated">Obtenga el nombre de un &lt;code&gt;DataType&lt;/code&gt; (potencialmente &lt;code&gt;UnionAll&lt;/code&gt; UnionAll) (sin su m&amp;oacute;dulo principal) como s&amp;iacute;mbolo.</target>
        </trans-unit>
        <trans-unit id="52de91388eb956065955884b6eac39cce6e61088" translate="yes" xml:space="preserve">
          <source>Get the name of a &lt;code&gt;Module&lt;/code&gt; as a &lt;a href=&quot;#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Obtenga el nombre de un &lt;code&gt;Module&lt;/code&gt; como &lt;a href=&quot;#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8a8ebbac78211cc23fd2af9d0c3c21bb5d703fa" translate="yes" xml:space="preserve">
          <source>Get the name of a generic &lt;code&gt;Function&lt;/code&gt; as a symbol, or &lt;code&gt;:anonymous&lt;/code&gt;.</source>
          <target state="translated">Obtenga el nombre de una &lt;code&gt;Function&lt;/code&gt; gen&amp;eacute;rica como s&amp;iacute;mbolo, o &lt;code&gt;:anonymous&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5308e8edde6c7f90f89dc8b80d1be8f9e4aed1b" translate="yes" xml:space="preserve">
          <source>Get the name of a remote repository, for instance &lt;code&gt;&quot;origin&quot;&lt;/code&gt;. If the remote is anonymous (see &lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt;&lt;code&gt;GitRemoteAnon&lt;/code&gt;&lt;/a&gt;) the name will be an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">Obtenga el nombre de un repositorio remoto, por ejemplo, &lt;code&gt;&quot;origin&quot;&lt;/code&gt; . Si el control remoto es an&amp;oacute;nimo (ver &lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt; &lt;code&gt;GitRemoteAnon&lt;/code&gt; &lt;/a&gt; ), el nombre ser&amp;aacute; una cadena vac&amp;iacute;a &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9cf8794c830b5b5477bd4dd5127e438a0a336f9" translate="yes" xml:space="preserve">
          <source>Get the name of field &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">Obtenga el nombre del campo &lt;code&gt;i&lt;/code&gt; de un &lt;code&gt;DataType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f05b4e05331b196f379ecdeee8aa391e63dd1631" translate="yes" xml:space="preserve">
          <source>Get the native address of an array or string, optionally at a given location &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">Obtenga la direcci&amp;oacute;n nativa de una matriz o cadena, opcionalmente en un &lt;code&gt;index&lt;/code&gt; ubicaci&amp;oacute;n determinado .</target>
        </trans-unit>
        <trans-unit id="67e6a2296c5e9b9545d8ce6e5fe670e01fcb2193" translate="yes" xml:space="preserve">
          <source>Get the number of available processes.</source>
          <target state="translated">Obtener el número de procesos disponibles.</target>
        </trans-unit>
        <trans-unit id="6c54bfd12378fd187e6fdf88c8f9a891fd352b8a" translate="yes" xml:space="preserve">
          <source>Get the number of available worker processes. This is one less than &lt;a href=&quot;#Distributed.nprocs&quot;&gt;&lt;code&gt;nprocs()&lt;/code&gt;&lt;/a&gt;. Equal to &lt;code&gt;nprocs()&lt;/code&gt; if &lt;code&gt;nprocs() == 1&lt;/code&gt;.</source>
          <target state="translated">Obtenga la cantidad de procesos de trabajo disponibles. Este es uno menos que &lt;a href=&quot;#Distributed.nprocs&quot;&gt; &lt;code&gt;nprocs()&lt;/code&gt; &lt;/a&gt; . Igual a &lt;code&gt;nprocs()&lt;/code&gt; si &lt;code&gt;nprocs() == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d316efb69571072b7b698b64013b0df989b23e2" translate="yes" xml:space="preserve">
          <source>Get the number of fields in the given object.</source>
          <target state="translated">Obtener el número de campos en el objeto dado.</target>
        </trans-unit>
        <trans-unit id="a93c91e8128e4c3c8ef281740f30c00304272fd2" translate="yes" xml:space="preserve">
          <source>Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.</source>
          <target state="translated">Obtener el número de campos que tendría una instancia del tipo dado.Se lanza un error si el tipo es demasiado abstracto para determinar esto.</target>
        </trans-unit>
        <trans-unit id="d3677eab3b97fd3c65939b3bc5a15f59d44d4af9" translate="yes" xml:space="preserve">
          <source>Get the number of threads available to the Julia process. This is the inclusive upper bound on &lt;code&gt;threadid()&lt;/code&gt;.</source>
          <target state="translated">Obtenga la cantidad de subprocesos disponibles para el proceso de Julia. Este es el l&amp;iacute;mite superior inclusivo en &lt;code&gt;threadid()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b55f78480b3149c80bfc50e1a7d85e6fa50c73b" translate="yes" xml:space="preserve">
          <source>Get the permissions of the owner of the file as a bitfield of</source>
          <target state="translated">Obtener los permisos del propietario del archivo como un bitfield de</target>
        </trans-unit>
        <trans-unit id="c5f291709146a9a504c67d3dc2b280d4f865a715" translate="yes" xml:space="preserve">
          <source>Get the precision (in bits) currently used for &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; arithmetic.</source>
          <target state="translated">Obtenga la precisi&amp;oacute;n (en bits) que se usa actualmente para la aritm&amp;eacute;tica de &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ec48750990030ca792131bcde102c3d937ba66e" translate="yes" xml:space="preserve">
          <source>Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.</source>
          <target state="translated">Obtener la precisión de un número de punto flotante,como se define por el número efectivo de bits en la mantisa.</target>
        </trans-unit>
        <trans-unit id="13a1d9961dcbce8522f507a9d605791c91380396" translate="yes" xml:space="preserve">
          <source>Get the process title. On some systems, will always return an empty string.</source>
          <target state="translated">Consigue el título del proceso.En algunos sistemas,siempre devolverá una cadena vacía.</target>
        </trans-unit>
        <trans-unit id="8d97afd1ec5aab5d2f47ff664bcaf7b5f14afb9a" translate="yes" xml:space="preserve">
          <source>Get the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of &lt;code&gt;(exception,backtrace)&lt;/code&gt; pairs, or a Vector of exceptions if &lt;code&gt;include_bt&lt;/code&gt; is false.</source>
          <target state="translated">Obtenga la pila de excepciones que se manejan actualmente. Para los bloques catch anidados, puede haber m&amp;aacute;s de una excepci&amp;oacute;n actual, en cuyo caso la excepci&amp;oacute;n lanzada m&amp;aacute;s recientemente es la &amp;uacute;ltima en la pila. La pila se devuelve como un Vector de pares &lt;code&gt;(exception,backtrace)&lt;/code&gt; o un Vector de excepciones si &lt;code&gt;include_bt&lt;/code&gt; es falso.</target>
        </trans-unit>
        <trans-unit id="857485ff0b5ba0b2460dd06bb700b67ed684fb9b" translate="yes" xml:space="preserve">
          <source>Get the stage number of &lt;code&gt;ie&lt;/code&gt;. The stage number &lt;code&gt;0&lt;/code&gt; represents the current state of the working tree, but other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on an &lt;code&gt;IndexEntry&lt;/code&gt; describe which side(s) of the conflict the current state of the file belongs to. Stage &lt;code&gt;0&lt;/code&gt; is the state before the attempted merge, stage &lt;code&gt;1&lt;/code&gt; is the changes which have been made locally, stages &lt;code&gt;2&lt;/code&gt; and larger are for changes from other branches (for instance, in the case of a multi-branch &quot;octopus&quot; merge, stages &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;4&lt;/code&gt; might be used).</source>
          <target state="translated">Obtenga el n&amp;uacute;mero de etapa de &lt;code&gt;ie&lt;/code&gt; . El n&amp;uacute;mero de etapa &lt;code&gt;0&lt;/code&gt; representa el estado actual del &amp;aacute;rbol de trabajo, pero se pueden usar otros n&amp;uacute;meros en el caso de un conflicto de fusi&amp;oacute;n. En tal caso, los distintos n&amp;uacute;meros de etapa en un &lt;code&gt;IndexEntry&lt;/code&gt; describen a qu&amp;eacute; lado (s) del conflicto pertenece el estado actual del archivo. La etapa &lt;code&gt;0&lt;/code&gt; es el estado anterior al intento de fusi&amp;oacute;n, la etapa &lt;code&gt;1&lt;/code&gt; son los cambios que se han realizado localmente, las etapas &lt;code&gt;2&lt;/code&gt; y mayores son para cambios de otras ramas (por ejemplo, en el caso de una fusi&amp;oacute;n de &quot;pulpo&quot; de varias ramas, las etapas &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; y &lt;code&gt;4&lt;/code&gt; pueden usarse).</target>
        </trans-unit>
        <trans-unit id="129f24b071e084dab9af722a0959ecf2337e059d" translate="yes" xml:space="preserve">
          <source>Get the step size of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Obtenga el tama&amp;ntilde;o de paso de un objeto &lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8858aa789b8a95e917ca5b8edf3cb4cfb4672953" translate="yes" xml:space="preserve">
          <source>Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.</source>
          <target state="translated">Obtener el tiempo del sistema en segundos desde la época,con una resolución bastante alta (típicamente,microsegundos).</target>
        </trans-unit>
        <trans-unit id="95239b12c16c016f41ece1f43f66824450caaa42" translate="yes" xml:space="preserve">
          <source>Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.</source>
          <target state="translated">Consigue el tiempo en nanosegundos.El tiempo correspondiente a 0 no está definido,y se extiende cada 5,8 años.</target>
        </trans-unit>
        <trans-unit id="b24f1d764ec96114bfff224327fcd8d0d0abdd31" translate="yes" xml:space="preserve">
          <source>Get the total free memory in RAM in kilobytes.</source>
          <target state="translated">Obtener la memoria libre total en la RAM en kilobytes.</target>
        </trans-unit>
        <trans-unit id="d5e4ce0e0a7ea7ef86f926adb946a71d925d5beb" translate="yes" xml:space="preserve">
          <source>Get the total memory in RAM (including that which is currently used) in kilobytes.</source>
          <target state="translated">Obtener la memoria total en RAM (incluyendo la que se utiliza actualmente)en kilobytes.</target>
        </trans-unit>
        <trans-unit id="e98e2a89d68b00f3fd77d6a63a6d2c70dc724cf3" translate="yes" xml:space="preserve">
          <source>Get the value of the C library's &lt;code&gt;errno&lt;/code&gt;. If an argument is specified, it is used to set the value of &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">Obtener el valor de la biblioteca de C &lt;code&gt;errno&lt;/code&gt; . Si se especifica un argumento, se utiliza para establecer el valor de &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2268d21fbee620aaff052e88aa0c0825d399931" translate="yes" xml:space="preserve">
          <source>Get the value type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Obtiene el tipo de valor de un tipo de diccionario. Se comporta de manera similar a &lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8ca9fec9f5e29ac3cbc1f3abc652c135b52ec1" translate="yes" xml:space="preserve">
          <source>Get the vector of processes mapping the shared array.</source>
          <target state="translated">Obtener el vector de procesos mapeando la matriz compartida.</target>
        </trans-unit>
        <trans-unit id="db2afe93edd474fc522d8c7d75cb7a001e5b61fe" translate="yes" xml:space="preserve">
          <source>Gets all of the IP addresses of the &lt;code&gt;host&lt;/code&gt;. Uses the operating system's underlying &lt;code&gt;getaddrinfo&lt;/code&gt; implementation, which may do a DNS lookup.</source>
          <target state="translated">Obtiene todas las direcciones IP del &lt;code&gt;host&lt;/code&gt; . Utiliza la implementaci&amp;oacute;n &lt;code&gt;getaddrinfo&lt;/code&gt; subyacente del sistema operativo , que puede realizar una b&amp;uacute;squeda de DNS.</target>
        </trans-unit>
        <trans-unit id="a284592991f22190fd532a8317fc543ce797cfe4" translate="yes" xml:space="preserve">
          <source>Gets the first IP address of the &lt;code&gt;host&lt;/code&gt; of the specified &lt;code&gt;IPAddr&lt;/code&gt; type. Uses the operating system's underlying getaddrinfo implementation, which may do a DNS lookup.</source>
          <target state="translated">Obtiene la primera direcci&amp;oacute;n IP del &lt;code&gt;host&lt;/code&gt; del tipo &lt;code&gt;IPAddr&lt;/code&gt; especificado . Utiliza la implementaci&amp;oacute;n getaddrinfo subyacente del sistema operativo, que puede realizar una b&amp;uacute;squeda de DNS.</target>
        </trans-unit>
        <trans-unit id="a7f3acf6ca590093170d5ddc3c9107d6f1324074" translate="yes" xml:space="preserve">
          <source>Getting Around</source>
          <target state="translated">Cómo moverse...</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">Empezando</target>
        </trans-unit>
        <trans-unit id="04ccf152a8a13833ef0a70fb0a973a671f0ea746" translate="yes" xml:space="preserve">
          <source>Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as possible to runtime. For example, many macros simply wrap their arguments in a &lt;code&gt;QuoteNode&lt;/code&gt; or other similar &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;. Some examples of this include &lt;code&gt;@task body&lt;/code&gt; which simply returns &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt;, and &lt;code&gt;@eval expr&lt;/code&gt;, which simply returns &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt;.</source>
          <target state="translated">Hacer que las reglas de higiene sean correctas puede ser un desaf&amp;iacute;o formidable. Antes de usar una macro, es posible que desee considerar si un cierre de funci&amp;oacute;n ser&amp;iacute;a suficiente. Otra estrategia &amp;uacute;til es posponer la mayor cantidad de trabajo posible al tiempo de ejecuci&amp;oacute;n. Por ejemplo, muchas macros simplemente envuelven sus argumentos en un &lt;code&gt;QuoteNode&lt;/code&gt; u otro &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt; similar . Algunos ejemplos de esto incluyen &lt;code&gt;@task body&lt;/code&gt; que simplemente devuelve &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt; y &lt;code&gt;@eval expr&lt;/code&gt; , que simplemente devuelve &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf44c9857b696454c5ef1ca708da5e3ee8a0b24a" translate="yes" xml:space="preserve">
          <source>Ghost</source>
          <target state="translated">Ghost</target>
        </trans-unit>
        <trans-unit id="4a4c89342a61073746cb0be5c482a4f233f70856" translate="yes" xml:space="preserve">
          <source>Gimel Symbol / Third Transfinite Cardinal</source>
          <target state="translated">Símbolo de Gimel/Tercer Cardenal Transfinita</target>
        </trans-unit>
        <trans-unit id="29fb58174b748291968c938f5144e432d7a05bc1" translate="yes" xml:space="preserve">
          <source>Girl</source>
          <target state="translated">Girl</target>
        </trans-unit>
        <trans-unit id="585f3a3c7ecf6be9b08fcb5c41bd3f7b4064386b" translate="yes" xml:space="preserve">
          <source>Give a hint to the compiler that this function is worth inlining.</source>
          <target state="translated">Dale una pista al compilador de que esta función vale la pena enfatizarla.</target>
        </trans-unit>
        <trans-unit id="f9f77d5a362582fb87b0f06e19b1b57c8b1806c3" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a character.</source>
          <target state="translated">Diga el número de columnas necesarias para imprimir un personaje.</target>
        </trans-unit>
        <trans-unit id="d66cd5d2057c5b56255474647800cbbea7c7ec15" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a string.</source>
          <target state="translated">Diga el número de columnas necesarias para imprimir una cadena.</target>
        </trans-unit>
        <trans-unit id="990b49394e3cec090496333dd6dda71ca867283b" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;-like function &lt;code&gt;writefunc&lt;/code&gt;, which takes an I/O stream as its first argument, &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; calls &lt;code&gt;writefunc&lt;/code&gt; to write &lt;code&gt;args...&lt;/code&gt; to a base64-encoded string, and returns the string. &lt;code&gt;base64encode(args...)&lt;/code&gt; is equivalent to &lt;code&gt;base64encode(write, args...)&lt;/code&gt;: it converts its arguments into bytes using the standard &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; functions and returns the base64-encoded string.</source>
          <target state="translated">Dada una funci&amp;oacute;n de &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; similar a &lt;code&gt;writefunc&lt;/code&gt; , que toma un flujo de E / S como primer argumento, &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; llama a &lt;code&gt;writefunc&lt;/code&gt; para escribir &lt;code&gt;args...&lt;/code&gt; en una cadena codificada en base64, y devuelve la cadena. &lt;code&gt;base64encode(args...)&lt;/code&gt; es equivalente a &lt;code&gt;base64encode(write, args...)&lt;/code&gt; : convierte sus argumentos en bytes usando las funciones de &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; est&amp;aacute;ndar y devuelve la cadena codificada en base64.</target>
        </trans-unit>
        <trans-unit id="f3d33bb8ba673cca2a309308e1c04181d32a390f" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;Ptr{T}&lt;/code&gt;, the contents of type &lt;code&gt;T&lt;/code&gt; can generally be copied from the referenced memory into a Julia object using &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt;. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;[]&lt;/code&gt; access syntax).</source>
          <target state="translated">Dado un &lt;code&gt;Ptr{T}&lt;/code&gt; , el contenido del tipo &lt;code&gt;T&lt;/code&gt; generalmente se puede copiar de la memoria referenciada a un objeto de Julia usando &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt; . El argumento de &amp;iacute;ndice es opcional (el valor predeterminado es 1) y sigue la convenci&amp;oacute;n de Julia de indexaci&amp;oacute;n basada en 1. &amp;iexcl;Esta funci&amp;oacute;n es intencionalmente similar al comportamiento de &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt; (por ejemplo, &lt;code&gt;[]&lt;/code&gt; acceso a la sintaxis).</target>
        </trans-unit>
        <trans-unit id="9276b00b5b100003171aa4d1b53dddc58e924e43" translate="yes" xml:space="preserve">
          <source>Given a collection type &lt;code&gt;S&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(::S)&lt;/code&gt; is defined, an object of type &lt;code&gt;eltype(S)&lt;/code&gt; will be produced. In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="translated">Dado un tipo de colecci&amp;oacute;n &lt;code&gt;S&lt;/code&gt; , actualmente se supone que si se define &lt;code&gt;rand(::S)&lt;/code&gt; , se producir&amp;aacute; un objeto de tipo &lt;code&gt;eltype(S)&lt;/code&gt; . Para definir la generaci&amp;oacute;n aleatoria a partir de objetos de tipo &lt;code&gt;S&lt;/code&gt; , se puede definir el siguiente m&amp;eacute;todo: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt; . Aqu&amp;iacute;, &lt;code&gt;sp&lt;/code&gt; simplemente envuelve un objeto de tipo &lt;code&gt;S&lt;/code&gt; , al que se puede acceder mediante &lt;code&gt;sp[]&lt;/code&gt; . Continuando con el ejemplo de &lt;code&gt;Die&lt;/code&gt; , ahora queremos definir &lt;code&gt;rand(d::Die)&lt;/code&gt; para producir un &lt;code&gt;Int&lt;/code&gt; correspondiente a uno de los lados de &lt;code&gt;d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c4f1730c953eabcee66d16110ac2417f817ee88b" translate="yes" xml:space="preserve">
          <source>Given a dictionary &lt;code&gt;D&lt;/code&gt;, the syntax &lt;code&gt;D[x]&lt;/code&gt; returns the value of key &lt;code&gt;x&lt;/code&gt; (if it exists) or throws an error, and &lt;code&gt;D[x] = y&lt;/code&gt; stores the key-value pair &lt;code&gt;x =&amp;gt; y&lt;/code&gt; in &lt;code&gt;D&lt;/code&gt; (replacing any existing value for the key &lt;code&gt;x&lt;/code&gt;). Multiple arguments to &lt;code&gt;D[...]&lt;/code&gt; are converted to tuples; for example, the syntax &lt;code&gt;D[x,y]&lt;/code&gt; is equivalent to &lt;code&gt;D[(x,y)]&lt;/code&gt;, i.e. it refers to the value keyed by the tuple &lt;code&gt;(x,y)&lt;/code&gt;.</source>
          <target state="translated">Dado un diccionario &lt;code&gt;D&lt;/code&gt; , la sintaxis &lt;code&gt;D[x]&lt;/code&gt; devuelve el valor de la clave &lt;code&gt;x&lt;/code&gt; (si existe) o arroja un error, y &lt;code&gt;D[x] = y&lt;/code&gt; almacena el par clave-valor &lt;code&gt;x =&amp;gt; y&lt;/code&gt; en &lt;code&gt;D&lt;/code&gt; (reemplazando cualquier valor para la clave &lt;code&gt;x&lt;/code&gt; ). M&amp;uacute;ltiples argumentos a &lt;code&gt;D[...]&lt;/code&gt; convierten en tuplas; por ejemplo, la sintaxis &lt;code&gt;D[x,y]&lt;/code&gt; es equivalente a &lt;code&gt;D[(x,y)]&lt;/code&gt; , es decir, se refiere al valor tecleado por la tupla &lt;code&gt;(x,y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6aeb65e7ccb967c9455ef2f486079851e21e2b6b" translate="yes" xml:space="preserve">
          <source>Given a pointer to an execution context (usually generated by a call to &lt;code&gt;backtrace&lt;/code&gt;), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.</source>
          <target state="translated">Dado un puntero a un contexto de ejecuci&amp;oacute;n (generalmente generado por una llamada a &lt;code&gt;backtrace&lt;/code&gt; ), busca informaci&amp;oacute;n de contexto de marco de pila. Devuelve una matriz de informaci&amp;oacute;n del marco para todas las funciones en l&amp;iacute;nea en ese punto, la funci&amp;oacute;n m&amp;aacute;s interna primero.</target>
        </trans-unit>
        <trans-unit id="fcada796f1c4aca1cfb31ae96c64d212e649ecf0" translate="yes" xml:space="preserve">
          <source>Given a predicate function &lt;code&gt;flt&lt;/code&gt; and an iterable object &lt;code&gt;itr&lt;/code&gt;, return an iterable object which upon iteration yields the elements &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;itr&lt;/code&gt; that satisfy &lt;code&gt;flt(x)&lt;/code&gt;. The order of the original iterator is preserved.</source>
          <target state="translated">Dada una funci&amp;oacute;n de predicado &lt;code&gt;flt&lt;/code&gt; y un objeto iterable &lt;code&gt;itr&lt;/code&gt; , devuelve un objeto iterable que al iterar produce los elementos &lt;code&gt;x&lt;/code&gt; de &lt;code&gt;itr&lt;/code&gt; que satisfacen &lt;code&gt;flt(x)&lt;/code&gt; . Se conserva el orden del iterador original.</target>
        </trans-unit>
        <trans-unit id="c16f746a1658b9d1859c84c436dc50bdb9fe0a85" translate="yes" xml:space="preserve">
          <source>Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace &lt;code&gt;data&lt;/code&gt; obtained from &lt;a href=&quot;#Profile.retrieve&quot;&gt;&lt;code&gt;retrieve&lt;/code&gt;&lt;/a&gt;; otherwise, the current internal profile buffer is used.</source>
          <target state="translated">Dada una ejecuci&amp;oacute;n de generaci&amp;oacute;n de perfiles anterior, determine qui&amp;eacute;n llam&amp;oacute; a una funci&amp;oacute;n en particular. Proporcionar el nombre del archivo (y, opcionalmente, el rango de n&amp;uacute;meros de l&amp;iacute;nea sobre los que se define la funci&amp;oacute;n) le permite eliminar la ambig&amp;uuml;edad de un m&amp;eacute;todo sobrecargado. El valor devuelto es un vector que contiene un recuento del n&amp;uacute;mero de llamadas e informaci&amp;oacute;n de l&amp;iacute;nea sobre la persona que llama. Opcionalmente, se pueden proporcionar &lt;code&gt;data&lt;/code&gt; seguimiento obtenidos a partir de la &lt;a href=&quot;#Profile.retrieve&quot;&gt; &lt;code&gt;retrieve&lt;/code&gt; &lt;/a&gt; ; de lo contrario, se utiliza el b&amp;uacute;fer de perfil interno actual.</target>
        </trans-unit>
        <trans-unit id="67104b7201b61b9623c8478911e24c6cfc8b97bc" translate="yes" xml:space="preserve">
          <source>Given a single iterable argument, constructs a &lt;a href=&quot;#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt; whose key-value pairs are taken from 2-tuples &lt;code&gt;(key,value)&lt;/code&gt; generated by the argument.</source>
          <target state="translated">Dado un &amp;uacute;nico argumento iterable, construye un &lt;a href=&quot;#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt; cuyos pares clave-valor se toman de 2 tuplas &lt;code&gt;(key,value)&lt;/code&gt; generadas por el argumento.</target>
        </trans-unit>
        <trans-unit id="a19217b165ec900e8bae935104c81bb7e032d599" translate="yes" xml:space="preserve">
          <source>Given a starting value, construct a range either by length or from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt;, optionally with a given step (defaults to 1, a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt;). One of &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; is required. If &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; are all specified, they must agree.</source>
          <target state="translated">Dado un valor inicial, construya un rango ya sea por longitud o desde el &lt;code&gt;start&lt;/code&gt; hasta el &lt;code&gt;stop&lt;/code&gt; , opcionalmente con un paso dado (el valor predeterminado es 1, un &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt; ). Se requiere uno de &lt;code&gt;length&lt;/code&gt; o &lt;code&gt;stop&lt;/code&gt; . Si se especifican la &lt;code&gt;length&lt;/code&gt; , la &lt;code&gt;stop&lt;/code&gt; y el &lt;code&gt;step&lt;/code&gt; , deben coincidir.</target>
        </trans-unit>
        <trans-unit id="e6bf5e1364f77d196c7b9a51bb62bde8f133bcde" translate="yes" xml:space="preserve">
          <source>Given a string or array &lt;code&gt;s&lt;/code&gt; of ASCII codes for a sequence of hexadecimal digits, returns a &lt;code&gt;Vector{UInt8}&lt;/code&gt; of bytes corresponding to the binary representation: each successive pair of hexadecimal digits in &lt;code&gt;s&lt;/code&gt; gives the value of one byte in the return vector.</source>
          <target state="translated">Dada una cadena o matriz &lt;code&gt;s&lt;/code&gt; de c&amp;oacute;digos ASCII para una secuencia de d&amp;iacute;gitos hexadecimales, devuelve un &lt;code&gt;Vector{UInt8}&lt;/code&gt; de bytes correspondientes a la representaci&amp;oacute;n binaria: cada par sucesivo de d&amp;iacute;gitos hexadecimales en &lt;code&gt;s&lt;/code&gt; da el valor de un byte en el vector de retorno.</target>
        </trans-unit>
        <trans-unit id="8d6a85425c1e72a27deafaba610d488a3457e0f2" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(T)&lt;/code&gt; is defined, an object of type &lt;code&gt;T&lt;/code&gt; will be produced. In order to define random generation of values of type &lt;code&gt;T&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; (this should return what &lt;code&gt;rand(rng, T)&lt;/code&gt; is expected to return).</source>
          <target state="translated">Dado un tipo &lt;code&gt;T&lt;/code&gt; , actualmente se supone que si se define &lt;code&gt;rand(T)&lt;/code&gt; , se producir&amp;aacute; un objeto de tipo &lt;code&gt;T&lt;/code&gt; .Para definir la generaci&amp;oacute;n aleatoria de valores de tipo &lt;code&gt;T&lt;/code&gt; , se puede definir el siguiente m&amp;eacute;todo: &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; (esto deber&amp;iacute;a devolver lo que se espera que devuelva &lt;code&gt;rand(rng, T)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="60e4af8cc8de60ffb69850d252bdcd98ee3d2bfa" translate="yes" xml:space="preserve">
          <source>Given an AbstractArray &lt;code&gt;A&lt;/code&gt;, create a view &lt;code&gt;B&lt;/code&gt; such that the dimensions appear to be permuted. Similar to &lt;code&gt;permutedims&lt;/code&gt;, except that no copying occurs (&lt;code&gt;B&lt;/code&gt; shares storage with &lt;code&gt;A&lt;/code&gt;).</source>
          <target state="translated">Dado un AbstractArray &lt;code&gt;A&lt;/code&gt; , cree una vista &lt;code&gt;B&lt;/code&gt; de manera que las dimensiones parezcan permutadas. Similar a &lt;code&gt;permutedims&lt;/code&gt; , excepto que no se realiza ninguna copia ( &lt;code&gt;B&lt;/code&gt; comparte el almacenamiento con &lt;code&gt;A&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2273302d369651afdbde86cc33fa4cfcb401046e" translate="yes" xml:space="preserve">
          <source>Given an expression object, one can cause Julia to evaluate (execute) it at global scope using &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Dado un objeto de expresi&amp;oacute;n, uno puede hacer que Julia lo eval&amp;uacute;e (ejecute) en el &amp;aacute;mbito global usando &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6bcc48e1bcaa064479ac3ce6a9aad0b807686849" translate="yes" xml:space="preserve">
          <source>Given an index &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;reverse(v)&lt;/code&gt;, return the corresponding index in &lt;code&gt;v&lt;/code&gt; so that &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt;. (This can be nontrivial in cases where &lt;code&gt;v&lt;/code&gt; contains non-ASCII characters.)</source>
          <target state="translated">Dado un &amp;iacute;ndice &lt;code&gt;i&lt;/code&gt; en &lt;code&gt;reverse(v)&lt;/code&gt; , devuelva el &amp;iacute;ndice correspondiente en &lt;code&gt;v&lt;/code&gt; de modo que &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt; . (Esto puede no ser trivial en los casos en que &lt;code&gt;v&lt;/code&gt; contiene caracteres que no son ASCII).</target>
        </trans-unit>
        <trans-unit id="214692258e5d3f03bf0e19a0c7bce6fe690232a0" translate="yes" xml:space="preserve">
          <source>Given an iterator &lt;code&gt;itr&lt;/code&gt;, then &lt;code&gt;reverse(itr)&lt;/code&gt; is an iterator over the same collection but in the reverse order.</source>
          <target state="translated">Dado un &lt;code&gt;itr&lt;/code&gt; de iterador , &lt;code&gt;reverse(itr)&lt;/code&gt; es un iterador sobre la misma colecci&amp;oacute;n pero en orden inverso.</target>
        </trans-unit>
        <trans-unit id="089e5e83e8607aed09695c30f3dd1c60f5798574" translate="yes" xml:space="preserve">
          <source>Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.</source>
          <target state="translated">Dado un iterador que produce iteradores,devuelve un iterador que produce los elementos de esos iteradores.Dicho de otra manera,los elementos del argumento iterador están concatenados.</target>
        </trans-unit>
        <trans-unit id="3c9b417cfac83aea8a69f80d6bc8cf9a41f8a58a" translate="yes" xml:space="preserve">
          <source>Given such a declaration, for each choice of &lt;code&gt;T&lt;/code&gt;, we have &lt;code&gt;Point{T}&lt;/code&gt; as a subtype of &lt;code&gt;Pointy{T}&lt;/code&gt;:</source>
          <target state="translated">Dada tal declaraci&amp;oacute;n, para cada elecci&amp;oacute;n de &lt;code&gt;T&lt;/code&gt; , tenemos el &lt;code&gt;Point{T}&lt;/code&gt; como un subtipo de &lt;code&gt;Pointy{T}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d716647091cd161029df5d10c16015ae51186d66" translate="yes" xml:space="preserve">
          <source>Given the git configuration file containing:</source>
          <target state="translated">Dado el archivo de configuración de git que contiene:</target>
        </trans-unit>
        <trans-unit id="915ac53cd4c78783b139cec5dd22b4b42ed2b99a" translate="yes" xml:space="preserve">
          <source>Given the statement &lt;code&gt;using Foo&lt;/code&gt;, the system consults an internal table of top-level modules to look for one named &lt;code&gt;Foo&lt;/code&gt;. If the module does not exist, the system attempts to &lt;code&gt;require(:Foo)&lt;/code&gt;, which typically results in loading code from an installed package.</source>
          <target state="translated">Dada la declaraci&amp;oacute;n que &lt;code&gt;using Foo&lt;/code&gt; , el sistema consulta una tabla interna de m&amp;oacute;dulos de nivel superior para buscar uno llamado &lt;code&gt;Foo&lt;/code&gt; . Si el m&amp;oacute;dulo no existe, el sistema intenta &lt;code&gt;require(:Foo)&lt;/code&gt; , lo que generalmente resulta en cargar c&amp;oacute;digo desde un paquete instalado.</target>
        </trans-unit>
        <trans-unit id="06fe662af1da02e3f2ea7cf7081d137d14c1ea88" translate="yes" xml:space="preserve">
          <source>Given the type of an iterator, return one of the following values:</source>
          <target state="translated">Dado el tipo de iterador,devuelva uno de los siguientes valores:</target>
        </trans-unit>
        <trans-unit id="712fa051470c666b0b3c1cf4e1eb3b5cdf800a89" translate="yes" xml:space="preserve">
          <source>Given this dependency &lt;code&gt;graph&lt;/code&gt;, when Julia sees &lt;code&gt;import Priv&lt;/code&gt; in the &lt;code&gt;Pub&lt;/code&gt; package&amp;mdash;which has UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt;&amp;mdash;it looks up:</source>
          <target state="translated">Dado este &lt;code&gt;graph&lt;/code&gt; dependencia , cuando Julia ve &lt;code&gt;import Priv&lt;/code&gt; en el paquete &lt;code&gt;Pub&lt;/code&gt; , que tiene UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt; , busca:</target>
        </trans-unit>
        <trans-unit id="617b3c70bd8eb4654d1000dde442b1913a3d57c6" translate="yes" xml:space="preserve">
          <source>Given this roots map, in &lt;code&gt;App&lt;/code&gt;'s code the statement &lt;code&gt;import Priv&lt;/code&gt; will cause Julia to look up &lt;code&gt;roots[:Priv]&lt;/code&gt;, which yields &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;, the UUID of the &lt;code&gt;Priv&lt;/code&gt; package that is to be loaded in that context. This UUID identifies which &lt;code&gt;Priv&lt;/code&gt; package to load and use when the main application evaluates &lt;code&gt;import Priv&lt;/code&gt;.</source>
          <target state="translated">Dado este mapa de ra&amp;iacute;ces, en el c&amp;oacute;digo de la &lt;code&gt;App&lt;/code&gt; , la instrucci&amp;oacute;n &lt;code&gt;import Priv&lt;/code&gt; har&amp;aacute; que Julia busque las &lt;code&gt;roots[:Priv]&lt;/code&gt; , lo que da &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; resultado ba13f791-ae1d-465a-978b-69c3ad90f72b , el UUID del paquete &lt;code&gt;Priv&lt;/code&gt; que se va a cargar en ese contexto. Este UUID identifica qu&amp;eacute; paquete &lt;code&gt;Priv&lt;/code&gt; cargar y usar cuando la aplicaci&amp;oacute;n principal eval&amp;uacute;a &lt;code&gt;import Priv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b509e583621052cb07bc486839dfdb1f16ed86dc" translate="yes" xml:space="preserve">
          <source>Global Scope</source>
          <target state="translated">Alcance global</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">Variables globales</target>
        </trans-unit>
        <trans-unit id="40501a9e5007169fb629c5387c4f8fb6e999c42d" translate="yes" xml:space="preserve">
          <source>Global constants are declared as constants on remote nodes too.</source>
          <target state="translated">Las constantes globales son declaradas como constantes en nodos remotos también.</target>
        </trans-unit>
        <trans-unit id="389f13ca82ff7a2453bc65e6b170fb5bce0e7be4" translate="yes" xml:space="preserve">
          <source>Global counters (for example, for attempting to uniquely identify objects). Consider the following code snippet:</source>
          <target state="translated">Contadores globales (por ejemplo,para intentar identificar objetos de forma única).Considere el siguiente fragmento de código:</target>
        </trans-unit>
        <trans-unit id="9f22cff33a2ca414f07ad83aad20cf6de8acaeaf" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard error stream.</source>
          <target state="translated">Variable global que se refiere al flujo de error estándar.</target>
        </trans-unit>
        <trans-unit id="9aa21a682323865a22d83920da0f441d6c030675" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard input stream.</source>
          <target state="translated">Variable global que se refiere al flujo de entrada estándar.</target>
        </trans-unit>
        <trans-unit id="51d6faf5f0e0e6c01ea9efaf0aad4dbd11c26673" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard out stream.</source>
          <target state="translated">Variable global que se refiere a la corriente de salida estándar.</target>
        </trans-unit>
        <trans-unit id="70ae8e14e7d7a8122e7468fd602556f9b4388301" translate="yes" xml:space="preserve">
          <source>Global variables</source>
          <target state="translated">Variables globales</target>
        </trans-unit>
        <trans-unit id="7d6e1e2bd4cbe556d039d09149551410bf54cb41" translate="yes" xml:space="preserve">
          <source>Global variables exported by native libraries can be accessed by name using the &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; function. The arguments to &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; are a symbol specification identical to that used by &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, and a type describing the value stored in the variable:</source>
          <target state="translated">Se puede acceder a las variables globales exportadas por bibliotecas nativas por su nombre utilizando la funci&amp;oacute;n &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt; . Los argumentos de &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt; son una especificaci&amp;oacute;n de s&amp;iacute;mbolo id&amp;eacute;ntica a la utilizada por &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; , y un tipo que describe el valor almacenado en la variable:</target>
        </trans-unit>
        <trans-unit id="d02d943210f33ec6146b40f17e3a1be495a87492" translate="yes" xml:space="preserve">
          <source>Globals are re-sent to a destination worker only in the context of a remote call, and then only if its value has changed. Also, the cluster does not synchronize global bindings across nodes. For example:</source>
          <target state="translated">Los globos se reenvían a un trabajador de destino sólo en el contexto de una llamada remota,y sólo si su valor ha cambiado.Además,el grupo no sincroniza las uniones globales entre nodos.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="fb02a2aa39a487184ec2e48cce6d9541aa570f94" translate="yes" xml:space="preserve">
          <source>Globals under modules other than &lt;code&gt;Main&lt;/code&gt; are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under &lt;code&gt;Main&lt;/code&gt;) may cause an &lt;code&gt;UndefVarError&lt;/code&gt; to be thrown later.</source>
          <target state="translated">&lt;code&gt;Main&lt;/code&gt; valores globales en m&amp;oacute;dulos distintos de Main no se serializan por valor al nodo remoto. Solo se env&amp;iacute;a una referencia. Las funciones que crean enlaces globales (excepto en &lt;code&gt;Main&lt;/code&gt; ) pueden hacer que un &lt;code&gt;UndefVarError&lt;/code&gt; se lance m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="acd336be94f1ee162a48e523127d9e5b06609fb8" translate="yes" xml:space="preserve">
          <source>Globe With Meridians</source>
          <target state="translated">El globo con los meridianos</target>
        </trans-unit>
        <trans-unit id="bf6d33bf807dc90549a0d0bac64e3cc4b4bb46ed" translate="yes" xml:space="preserve">
          <source>Glowing Star</source>
          <target state="translated">Estrella Brillante</target>
        </trans-unit>
        <trans-unit id="0e3f5fc25846b7ffc7fbf7ea4a19522f60c6c683" translate="yes" xml:space="preserve">
          <source>Goat</source>
          <target state="translated">Goat</target>
        </trans-unit>
        <trans-unit id="dab8916b317afa94c1e7d2eb18cfc9628289063b" translate="yes" xml:space="preserve">
          <source>Good performance, approaching that of statically-compiled languages like C</source>
          <target state="translated">Buen desempeño,acercándose al de los lenguajes compilados estáticamente como el C</target>
        </trans-unit>
        <trans-unit id="85116c6b5a5273ba053319524800267c175695d4" translate="yes" xml:space="preserve">
          <source>Graduation Cap</source>
          <target state="translated">Gorra de graduación</target>
        </trans-unit>
        <trans-unit id="0de47448267ba383673ef343ee1313af6fa63b74" translate="yes" xml:space="preserve">
          <source>Grapes</source>
          <target state="translated">Grapes</target>
        </trans-unit>
        <trans-unit id="2ef67b67ccfcf902b5da0d871f7bce811117ba2c" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Double-Line Equal Above Less-Than</source>
          <target state="translated">Mayor que la línea doble por encima de la línea doble igual por encima de la línea inferior</target>
        </trans-unit>
        <trans-unit id="5bf36d0687ba161c1ddd5ae9a710ac6b84c65e73" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Less-Than Above Double-Line Equal</source>
          <target state="translated">Mayor-que-Menos-que-Sobre-la-doble-línea-igual</target>
        </trans-unit>
        <trans-unit id="cda9caba673dd1973f8c7d113746b0e633f4f938" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Above Less-Than</source>
          <target state="translated">Más grande que arriba Más similar que arriba Menos que</target>
        </trans-unit>
        <trans-unit id="3a03ecfc7255d8cacd17931a2c17d195720afbd9" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Or Equal</source>
          <target state="translated">Mayor que el anterior similar o igual</target>
        </trans-unit>
        <trans-unit id="eed03df20a091917ea38ceacb7e9c2b67e0f9bb2" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Slanted Equal Above Less-Than Above Slanted Equal</source>
          <target state="translated">Mayor que la igualada por encima de la igualada por encima de la igualada por encima de la igualada por encima de la igualada por encima de la igualada</target>
        </trans-unit>
        <trans-unit id="ec6a31bc7051547d44e2c612da8aa15b61e41be6" translate="yes" xml:space="preserve">
          <source>Greater-Than And Not Approximate</source>
          <target state="translated">Mayor que y no aproximado</target>
        </trans-unit>
        <trans-unit id="852f9d0047fa29fbc8fb2cb24463f569deef89ef" translate="yes" xml:space="preserve">
          <source>Greater-Than And Single-Line Not Equal To</source>
          <target state="translated">Mayor-que-y-línea-única no es igual a</target>
        </trans-unit>
        <trans-unit id="52afc7afef44a974f7bc9b05b1e17bf964f408a0" translate="yes" xml:space="preserve">
          <source>Greater-Than Beside Less-Than</source>
          <target state="translated">Más que al lado de menos que</target>
        </trans-unit>
        <trans-unit id="8002394d4a4c3c62e2b6ebf6a841410b987f3fe3" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To</source>
          <target state="translated">Mayor que pero no igual a/mayor que pero no igual a</target>
        </trans-unit>
        <trans-unit id="9f51323c1f1f2bd6fed8b0133087b13833db9603" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">Mayor que pero no igual a/mayor que pero no igual a+selector de variaciones 1</target>
        </trans-unit>
        <trans-unit id="a9e5efe496a2b31f56957d4e597885897f8e0eb9" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equivalent To / Greater Than But Not Equivalent To</source>
          <target state="translated">Mayor que pero no equivalente a/Mayor que pero no equivalente a</target>
        </trans-unit>
        <trans-unit id="98eff7a1e60f594f0f81d4c3e83cbf5209423bb1" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve</source>
          <target state="translated">Más grande que cerrado por una curva</target>
        </trans-unit>
        <trans-unit id="099b37f93e6b34dbfa7c526c5fa3f13b59c30374" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">Más grande que cerrado por la curva por encima de la igualdad inclinada</target>
        </trans-unit>
        <trans-unit id="bb2d6f56b2861cf6b4d17b1cfddecb19b41dd882" translate="yes" xml:space="preserve">
          <source>Greater-Than Equal To Or Less-Than / Greater Than Equal To Or Less Than</source>
          <target state="translated">Mayor que igual o menor que/mayor que igual o menor que</target>
        </trans-unit>
        <trans-unit id="1f9f324edcdf276db2fba93d474c1d37dd1409bf" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Approximate</source>
          <target state="translated">Mayor que o aproximado</target>
        </trans-unit>
        <trans-unit id="816b73122f7826a76fc5a27a59be585ac1c20c8e" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equal To / Greater Than Or Equal To</source>
          <target state="translated">Mayor que o igual a/mayor que o igual a</target>
        </trans-unit>
        <trans-unit id="22f6cd5ba77c22771ae0dcb6dec580b58470b15f" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equivalent To / Greater Than Or Equivalent To</source>
          <target state="translated">Mayor que o equivalente a/mayor que o equivalente a</target>
        </trans-unit>
        <trans-unit id="da7070ff7fe0d357657567e892ae9e792dd0711c" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Less-Than / Greater Than Or Less Than</source>
          <target state="translated">Mayor que o menor que/mayor que o menor que</target>
        </trans-unit>
        <trans-unit id="fc2308a37940cf5145837f4b055616cdf8ed8663" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To</source>
          <target state="translated">Mayor que o inclinado igual a</target>
        </trans-unit>
        <trans-unit id="fc0db4bdca25b60daf5c07123869e9c3373f86d1" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Mayor que o inclinado igual a+Combinando la superposición de sólidos largos/superposición de barras largas no espaciadas</target>
        </trans-unit>
        <trans-unit id="3d2877fe16bd8c1aff6ca20742e54d7c40adcfb5" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">Más grande que o inclinado igual a con el punto de arriba</target>
        </trans-unit>
        <trans-unit id="5b85b82c5dfec29b3e76371a3c759b7b564d0dcc" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above Left</source>
          <target state="translated">Más grande que o inclinado igual a con el punto de arriba a la izquierda</target>
        </trans-unit>
        <trans-unit id="324053698d665835c3c8543b9475493cada464ce" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">Más grande que o inclinada igual a con punto en el interior</target>
        </trans-unit>
        <trans-unit id="eaf2aeee67af979dcb4bf973f1c28801c9b3c428" translate="yes" xml:space="preserve">
          <source>Greater-Than Over Equal To / Greater Than Over Equal To</source>
          <target state="translated">Mayor que sobre igual a/mayor que sobre igual a</target>
        </trans-unit>
        <trans-unit id="88e04ffb7bbd7b8b561e5e62dab6aaf4e8ec7d4c" translate="yes" xml:space="preserve">
          <source>Greater-Than Overlapping Less-Than</source>
          <target state="translated">Más grande que la superposición Menos que</target>
        </trans-unit>
        <trans-unit id="7eb5603be44b831a023cfdcd22f839b5f6f5bded" translate="yes" xml:space="preserve">
          <source>Greater-Than With Circle Inside</source>
          <target state="translated">Más grande que con un círculo en el interior</target>
        </trans-unit>
        <trans-unit id="f158072571829726fe84a7ad0ce7a50ef1ab0879" translate="yes" xml:space="preserve">
          <source>Greater-Than With Dot / Greater Than With Dot</source>
          <target state="translated">Mayor que con el punto/Mayor que con el punto</target>
        </trans-unit>
        <trans-unit id="209f35de5184bc36aa0d1b903151a9fc65c6ba61" translate="yes" xml:space="preserve">
          <source>Greater-Than With Question Mark Above</source>
          <target state="translated">Mayor que con el signo de interrogación de arriba</target>
        </trans-unit>
        <trans-unit id="1bd3d8bbe04802c889994d907ddead65a92d7cca" translate="yes" xml:space="preserve">
          <source>Greater-than comparison operator. Falls back to &lt;code&gt;y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">Operador de comparaci&amp;oacute;n mayor que. Vuelve a &lt;code&gt;y &amp;lt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9b75dd8da9fbc05fe433d4046e50ff253af5b8" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equals comparison operator. Falls back to &lt;code&gt;y &amp;lt;= x&lt;/code&gt;.</source>
          <target state="translated">Operador de comparaci&amp;oacute;n mayor o igual que. Vuelve a &lt;code&gt;y &amp;lt;= x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c889dfd5914acacbd51c9ee1f6424d7475f18ba9" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero).</source>
          <target state="translated">Com&amp;uacute;n mayor divisor (positivo) (o cero si &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; son ambos cero).</target>
        </trans-unit>
        <trans-unit id="3c137f18236c59d67effecc9926b91bc4e6c388c" translate="yes" xml:space="preserve">
          <source>Greek Beta Symbol / Greek Small Letter Curled Beta</source>
          <target state="translated">Símbolo griego Beta/Letra pequeña griega Beta rizada</target>
        </trans-unit>
        <trans-unit id="c90a544a84e41b0027e35535de12e9412929c3b9" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Alpha</source>
          <target state="translated">Letra mayúscula griega Alfa</target>
        </trans-unit>
        <trans-unit id="034c000ae09a7efb7dcd09b84c993f24a59b651a" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Beta</source>
          <target state="translated">Letra mayúscula griega Beta</target>
        </trans-unit>
        <trans-unit id="d91481b132bdcebe4f898c637891a19c7e0d2807" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Chi</source>
          <target state="translated">Letra mayúscula griega Chi</target>
        </trans-unit>
        <trans-unit id="3e715476cf54a47fc160c1f17257b6e0b611dcf0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Delta</source>
          <target state="translated">Letra mayúscula griega Delta</target>
        </trans-unit>
        <trans-unit id="e7b36e8f2dc5d428f4c0fbae5314c79d701290b8" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Epsilon</source>
          <target state="translated">Letra mayúscula griega Epsilon</target>
        </trans-unit>
        <trans-unit id="9632923c81e91309b0197e9f6256e5ddc583b3f1" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Eta</source>
          <target state="translated">Letra mayúscula griega ETA</target>
        </trans-unit>
        <trans-unit id="b63912e4ec51d609e069730c367de176e6e9799e" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Gamma</source>
          <target state="translated">Letra mayúscula griega Gamma</target>
        </trans-unit>
        <trans-unit id="003ecb167b62284b9bb24641dd3e450774ffb206" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Iota</source>
          <target state="translated">Letra mayúscula griega Iota</target>
        </trans-unit>
        <trans-unit id="97e0c3c41b2cd617ba1f3aefc97784af90e81883" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Kappa</source>
          <target state="translated">Letra mayúscula griega Kappa</target>
        </trans-unit>
        <trans-unit id="8766675df925b8c25168f5080a3ffb3054a6bbf7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Lamda / Greek Capital Letter Lambda</source>
          <target state="translated">Letra mayúscula griega Lamda/Letra mayúscula griega Lambda</target>
        </trans-unit>
        <trans-unit id="93f0db4c50dab02a7cf643e0e6463e461b78350b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Mu</source>
          <target state="translated">Letra mayúscula griega Mu</target>
        </trans-unit>
        <trans-unit id="c5ff86b57695b2194281052f49d3a518561ee43b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Nu</source>
          <target state="translated">Letra mayúscula griega Nu</target>
        </trans-unit>
        <trans-unit id="8d3af0cfd66c1c551b9d25df70d96ca3b3e41655" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omega</source>
          <target state="translated">Letra mayúscula griega Omega</target>
        </trans-unit>
        <trans-unit id="60cb22c8a7263835043a1bf3e2390a30ccb009da" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omicron</source>
          <target state="translated">Letra mayúscula griega Omicron</target>
        </trans-unit>
        <trans-unit id="9ef46dcc225d47def0f7ae271f6bce8a9447782c" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Phi</source>
          <target state="translated">Letra mayúscula griega Phi</target>
        </trans-unit>
        <trans-unit id="bdfd940817a68024f4561b28e37abe5c6aa8ae33" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Pi</source>
          <target state="translated">Letra mayúscula griega Pi</target>
        </trans-unit>
        <trans-unit id="9eb135fdc0eb8f41676f0233eced63bfb63b8d29" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Psi</source>
          <target state="translated">Letra mayúscula griega Psi</target>
        </trans-unit>
        <trans-unit id="42581daba465402bb427e86f725e50cbf13c5589" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Rho</source>
          <target state="translated">Letra mayúscula griega Rho</target>
        </trans-unit>
        <trans-unit id="9ba5f4b3b8d0114e4ebb66c0c247b421553311c0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Sigma</source>
          <target state="translated">Letra mayúscula griega Sigma</target>
        </trans-unit>
        <trans-unit id="ce15c49fc86bc080b59dcc6c6f912a5f65fcea89" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Tau</source>
          <target state="translated">Letra mayúscula griega Tau</target>
        </trans-unit>
        <trans-unit id="c53695a8df7adbb8087dbbf3f92d38bad6c54a97" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Theta</source>
          <target state="translated">Letra mayúscula griega Theta</target>
        </trans-unit>
        <trans-unit id="e5671b238dc9a21dfba521fd40bfb114bae616b4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Upsilon</source>
          <target state="translated">Letra mayúscula griega Upsilon</target>
        </trans-unit>
        <trans-unit id="7ee18055cc5ff646350aabb8125c5079d084ebc7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Xi</source>
          <target state="translated">Letra mayúscula griega Xi</target>
        </trans-unit>
        <trans-unit id="ff11a198311aac30e2248ebcb8edaa9900afa1c4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Zeta</source>
          <target state="translated">Letra mayúscula griega Zeta</target>
        </trans-unit>
        <trans-unit id="75f6796d9ad54779470705290e7c7602d7a845bd" translate="yes" xml:space="preserve">
          <source>Greek Capital Theta Symbol</source>
          <target state="translated">Símbolo de la capital griega Theta</target>
        </trans-unit>
        <trans-unit id="533978fb12373ffa98e45e16bb2525fdaa4ff4dc" translate="yes" xml:space="preserve">
          <source>Greek Kappa Symbol / Greek Small Letter Script Kappa</source>
          <target state="translated">Símbolo Griego Kappa/Guión Griego de Letras Pequeñas Kappa</target>
        </trans-unit>
        <trans-unit id="098ec4a81c9f38263e62700b20a2a6894858fb2e" translate="yes" xml:space="preserve">
          <source>Greek Letter Archaic Koppa</source>
          <target state="translated">Carta griega Arcaica Koppa</target>
        </trans-unit>
        <trans-unit id="c2ec8b8cfe62422b5013f3acdd510642f682d268" translate="yes" xml:space="preserve">
          <source>Greek Letter Digamma / Greek Capital Letter Digamma</source>
          <target state="translated">Letra griega Digamma/Letra mayúscula griega Digamma</target>
        </trans-unit>
        <trans-unit id="ced5a29435b2a381da90865a6dc27f1b51bd0151" translate="yes" xml:space="preserve">
          <source>Greek Letter Koppa / Greek Capital Letter Koppa</source>
          <target state="translated">Letra griega Koppa/Letra mayúscula griega Koppa</target>
        </trans-unit>
        <trans-unit id="b1fd4e84b1e13403c9fa5cc0de48f63d1cf94bc6" translate="yes" xml:space="preserve">
          <source>Greek Letter Sampi / Greek Capital Letter Sampi</source>
          <target state="translated">Letra griega Sampi/Letra mayúscula griega Sampi</target>
        </trans-unit>
        <trans-unit id="6736119dd29a2f705206a98b22de530d1dcccd83" translate="yes" xml:space="preserve">
          <source>Greek Letter Stigma / Greek Capital Letter Stigma</source>
          <target state="translated">Estigma de letras griegas/Estigma de letras mayúsculas griegas</target>
        </trans-unit>
        <trans-unit id="ea7aa3ec425217aedfab9d34ef40b0b566351176" translate="yes" xml:space="preserve">
          <source>Greek Lunate Epsilon Symbol</source>
          <target state="translated">Símbolo griego lunar de Épsilon</target>
        </trans-unit>
        <trans-unit id="dfaadea9364a20060c114ea92b3c24b30e9e1221" translate="yes" xml:space="preserve">
          <source>Greek Phi Symbol / Greek Small Letter Script Phi</source>
          <target state="translated">Símbolo griego Phi/Guión griego de letras pequeñas Phi</target>
        </trans-unit>
        <trans-unit id="0ae051b71680a4d39d72cb02f855a3c712e5bd2c" translate="yes" xml:space="preserve">
          <source>Greek Pi Symbol / Greek Small Letter Omega Pi</source>
          <target state="translated">Símbolo griego Pi/Letra pequeña griega Omega Pi</target>
        </trans-unit>
        <trans-unit id="f50bb1d13ed32ec906d7d6aaaaee29e7aa027d22" translate="yes" xml:space="preserve">
          <source>Greek Reversed Lunate Epsilon Symbol</source>
          <target state="translated">Símbolo griego de Épsilon lunar invertido</target>
        </trans-unit>
        <trans-unit id="ac07b5056a85d49adcf70f2b544a74ea6ecf6dce" translate="yes" xml:space="preserve">
          <source>Greek Rho Symbol / Greek Small Letter Tailed Rho</source>
          <target state="translated">Símbolo griego Rho/Letra pequeña griega Rho con cola</target>
        </trans-unit>
        <trans-unit id="448dc00d610b9b19fb08a7c7e6eb0a55f13d0a5d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Alpha</source>
          <target state="translated">Letra pequeña griega Alfa</target>
        </trans-unit>
        <trans-unit id="71d9bba39729f37db08ecc6cfd07622c292a3bcb" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Archaic Koppa</source>
          <target state="translated">Letra pequeña griega Koppa Arcaica</target>
        </trans-unit>
        <trans-unit id="c2455c0fc133c1c49b746a40bf7fe8a2f613a4de" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Beta</source>
          <target state="translated">Letra pequeña griega Beta</target>
        </trans-unit>
        <trans-unit id="5f8706d38c341d4055ab40dfb27748f213e0fc49" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Chi</source>
          <target state="translated">Letra pequeña griega Chi</target>
        </trans-unit>
        <trans-unit id="4dcd438cdc63b711ea794ef765006ad5a6535bd8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Delta</source>
          <target state="translated">Letra pequeña griega Delta</target>
        </trans-unit>
        <trans-unit id="970eba5f1fd0ce763d594cfcc46caddd4212150e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Digamma</source>
          <target state="translated">Letra pequeña griega Digamma</target>
        </trans-unit>
        <trans-unit id="37cc4f8ed3f230c47dc11c83e4de12cf526a1b20" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Epsilon</source>
          <target state="translated">Letra pequeña griega Epsilon</target>
        </trans-unit>
        <trans-unit id="7ccbcb67c9381630a226a3b3c4b28371605f0d5a" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Eta</source>
          <target state="translated">Letra pequeña griega Eta</target>
        </trans-unit>
        <trans-unit id="c074819760ca3f5bfb2e80f9147ad5e5b56ba096" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Final Sigma</source>
          <target state="translated">Letra pequeña griega Sigma final</target>
        </trans-unit>
        <trans-unit id="46c3a6f8bc0a7d2d96bb1cd2543a7109d5b60cf2" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Gamma</source>
          <target state="translated">Letra pequeña griega Gamma</target>
        </trans-unit>
        <trans-unit id="4643eab845743a762892a109cabf22bfe96da620" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Iota</source>
          <target state="translated">Letra pequeña griega Iota</target>
        </trans-unit>
        <trans-unit id="3e9ea92015aac67d0b73db674b1ba4dee8fe5484" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Kappa</source>
          <target state="translated">Letra pequeña griega Kappa</target>
        </trans-unit>
        <trans-unit id="c67601530cb0f970279b136a8b536cfe4717bcd6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Koppa</source>
          <target state="translated">Letra pequeña griega Koppa</target>
        </trans-unit>
        <trans-unit id="8c54eb8dc3ac289b41335f3dc67e6533bf270a57" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Lamda / Greek Small Letter Lambda</source>
          <target state="translated">Letra minúscula griega Lamda/Letra minúscula griega Lambda</target>
        </trans-unit>
        <trans-unit id="7149178e5cd2592e10a36e0a107bc1c794d4f411" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Mu</source>
          <target state="translated">Letra pequeña griega Mu</target>
        </trans-unit>
        <trans-unit id="e9b48a4ac754761a9dfd350adeabe5d343e5cb8f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Nu</source>
          <target state="translated">Letra pequeña griega Nu</target>
        </trans-unit>
        <trans-unit id="be2da964640e6e3a6c6130c2c98b0cae86bc9a01" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omega</source>
          <target state="translated">Letra pequeña griega Omega</target>
        </trans-unit>
        <trans-unit id="039c14215303437a5f755bf47c77fbf3d49255e3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omicron</source>
          <target state="translated">Letra pequeña griega Omicron</target>
        </trans-unit>
        <trans-unit id="b844f337c63e69f41e1119e2ae91153b90ab2b4d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Phi</source>
          <target state="translated">Letra pequeña griega Phi</target>
        </trans-unit>
        <trans-unit id="95d050ef9ff90d9125fe852cf7d1543f2ce7e841" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Pi</source>
          <target state="translated">Letra pequeña griega Pi</target>
        </trans-unit>
        <trans-unit id="55e311ff6199f4bde7e5d73ace711e07be007a2f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Psi</source>
          <target state="translated">Letra minúscula griega Psi</target>
        </trans-unit>
        <trans-unit id="5af5bfd009ec9591a9cb29dfcc2932dec54d6ca8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Rho</source>
          <target state="translated">Letra pequeña griega Rho</target>
        </trans-unit>
        <trans-unit id="85d8bb7b244cafeb1ab811a9df619d45d2234ea6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sampi</source>
          <target state="translated">Letra pequeña griega Sampi</target>
        </trans-unit>
        <trans-unit id="3ec2ed80a66bc81ead34ee55592a6ea7debfff4e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sigma</source>
          <target state="translated">Letra pequeña griega Sigma</target>
        </trans-unit>
        <trans-unit id="cc430dcce9d526f42ad9a59b54895c602c6380d3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Stigma</source>
          <target state="translated">El estigma de las letras pequeñas griegas</target>
        </trans-unit>
        <trans-unit id="7c2c0c82fe6e748bf9ed49a1f4249b9e89ebb0b8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Tau</source>
          <target state="translated">Letra pequeña griega Tau</target>
        </trans-unit>
        <trans-unit id="b13a88433f3cb99d5c62955aca5de95fbd232103" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Theta</source>
          <target state="translated">Letra pequeña griega Theta</target>
        </trans-unit>
        <trans-unit id="cad5938bde69f48a48d99f9b129d82f0acd5468b" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Upsilon</source>
          <target state="translated">Letra pequeña griega Upsilon</target>
        </trans-unit>
        <trans-unit id="0761f90b7168a502798811085d1367b5eca5af17" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Xi</source>
          <target state="translated">Letra pequeña griega Xi</target>
        </trans-unit>
        <trans-unit id="40428b11afaf575da445431ab7ceb811220b9167" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Zeta</source>
          <target state="translated">Letra pequeña griega Zeta</target>
        </trans-unit>
        <trans-unit id="e32107e3b0620ecf09ddae3fe8f4666208d97040" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Beta</source>
          <target state="translated">Griego Subscript Small Letter Beta</target>
        </trans-unit>
        <trans-unit id="90a01f237c5981615d18499c4360233abc532e89" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Chi</source>
          <target state="translated">Letra minúscula del alfabeto griego Chi</target>
        </trans-unit>
        <trans-unit id="e6642d28d8aeb11d500775a8447736e31c6678cc" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Gamma</source>
          <target state="translated">Griego Subscript Small Letter Gamma</target>
        </trans-unit>
        <trans-unit id="8b5afd737dfb2072bb758ab79fe8cc816442c922" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Phi</source>
          <target state="translated">Letra minúscula del alfabeto griego Phi</target>
        </trans-unit>
        <trans-unit id="655a658031f914446d83820f4d7947b16f05e79e" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Rho</source>
          <target state="translated">Letra minúscula del alfabeto griego Rho</target>
        </trans-unit>
        <trans-unit id="be9f5ea4e76fd688fd62b7dd791af4a7ebcdb5c7" translate="yes" xml:space="preserve">
          <source>Greek Theta Symbol / Greek Small Letter Script Theta</source>
          <target state="translated">Símbolo griego Theta/Letra minúscula griega Escritura Theta</target>
        </trans-unit>
        <trans-unit id="0dc9b81e7212e0baffe967cdd9d850d4352c89f1" translate="yes" xml:space="preserve">
          <source>Green Apple</source>
          <target state="translated">Manzana verde</target>
        </trans-unit>
        <trans-unit id="6c0c3305620db430350f7c25edbf10ced1e1274b" translate="yes" xml:space="preserve">
          <source>Green Book</source>
          <target state="translated">El Libro Verde</target>
        </trans-unit>
        <trans-unit id="6c50119d5c6855e408d9ec2a52bd79546e4c4107" translate="yes" xml:space="preserve">
          <source>Green Heart</source>
          <target state="translated">Corazón Verde</target>
        </trans-unit>
        <trans-unit id="91feac528389c2b95c6eef06c801f2624c19116d" translate="yes" xml:space="preserve">
          <source>Grimacing Face</source>
          <target state="translated">Cara de mueca</target>
        </trans-unit>
        <trans-unit id="3f363dede90226435cbc0dd5d44650f61adbd5cf" translate="yes" xml:space="preserve">
          <source>Grinning Cat Face With Smiling Eyes</source>
          <target state="translated">Cara de gato sonriente con ojos sonrientes</target>
        </trans-unit>
        <trans-unit id="c001d488999b87437147a6834a4b4dff1427af59" translate="yes" xml:space="preserve">
          <source>Grinning Face</source>
          <target state="translated">Cara sonriente</target>
        </trans-unit>
        <trans-unit id="5f9c06d040ed5ced638db3bf446959a48d2a6ba5" translate="yes" xml:space="preserve">
          <source>Grinning Face With Smiling Eyes</source>
          <target state="translated">Cara sonriente con ojos sonrientes</target>
        </trans-unit>
        <trans-unit id="7005b30f708630da7d596e53a5163b84350bd829" translate="yes" xml:space="preserve">
          <source>Grisu.print_shortest()</source>
          <target state="translated">Grisu.print_shortest()</target>
        </trans-unit>
        <trans-unit id="d511874702f7c7ad5ec3b4943a9badded191c85c" translate="yes" xml:space="preserve">
          <source>Growing Heart</source>
          <target state="translated">Corazón en crecimiento</target>
        </trans-unit>
        <trans-unit id="0fa148c7a4ec811ec41fa2cc8e9473dfc48a9226" translate="yes" xml:space="preserve">
          <source>Guardsman</source>
          <target state="translated">Guardsman</target>
        </trans-unit>
        <trans-unit id="94af6c4088103e96d349b87fe76774686b86faa5" translate="yes" xml:space="preserve">
          <source>Guitar</source>
          <target state="translated">Guitar</target>
        </trans-unit>
        <trans-unit id="f089f13a04cfc6546c94da2f6580d6c4eed769fc" translate="yes" xml:space="preserve">
          <source>HE</source>
          <target state="translated">HE</target>
        </trans-unit>
        <trans-unit id="9018ffc109466fc760171905d2397039bc111ebf" translate="yes" xml:space="preserve">
          <source>Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race condition. An example of what would happen if we didn't avoid the race:</source>
          <target state="translated">Si hubiéramos tratado de hacer la adición sin la etiqueta atómica,podríamos haber obtenido la respuesta equivocada debido a una condición de raza.Un ejemplo de lo que pasaría si no evitáramos la carrera:</target>
        </trans-unit>
        <trans-unit id="de960a40df3284e207ad1c9fee37b3f036f0b2a2" translate="yes" xml:space="preserve">
          <source>Hair Space</source>
          <target state="translated">Hair Space</target>
        </trans-unit>
        <trans-unit id="2c7a078f496901b9f8903cc399fa79c1c3ab6b95" translate="yes" xml:space="preserve">
          <source>Haircut</source>
          <target state="translated">Haircut</target>
        </trans-unit>
        <trans-unit id="4a11632b50147a0502c9dc634f5c6e0c06ffab6b" translate="yes" xml:space="preserve">
          <source>Half-precision floating-point numbers are also supported (&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;), but they are implemented in software and use &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; for calculations.</source>
          <target state="translated">Tambi&amp;eacute;n se admiten n&amp;uacute;meros de coma flotante de media precisi&amp;oacute;n ( &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; ), pero est&amp;aacute;n implementados en software y utilizan &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; para los c&amp;aacute;lculos.</target>
        </trans-unit>
        <trans-unit id="94c92dceffd55b3ed538a942cce80806cce37fe1" translate="yes" xml:space="preserve">
          <source>Hamburger</source>
          <target state="translated">Hamburger</target>
        </trans-unit>
        <trans-unit id="ab7b8ea47eadf93146c012e72a5ea673322853aa" translate="yes" xml:space="preserve">
          <source>Hammer</source>
          <target state="translated">Hammer</target>
        </trans-unit>
        <trans-unit id="3bff32cf99bd14d58869cbb0d7d31e1bec45d891" translate="yes" xml:space="preserve">
          <source>Hamster Face</source>
          <target state="translated">Cara de hámster</target>
        </trans-unit>
        <trans-unit id="3d3f4dc94e3e321e028a018fa9cae5ff030ce957" translate="yes" xml:space="preserve">
          <source>Handbag</source>
          <target state="translated">Handbag</target>
        </trans-unit>
        <trans-unit id="fffe7d81b4e3e0d9952aa6caa3fd530df68b775c" translate="yes" xml:space="preserve">
          <source>Handle a log event</source>
          <target state="translated">Manejar un evento de registro</target>
        </trans-unit>
        <trans-unit id="e30eba0eb24c7a8fac8f9c3ba83240b293b51b33" translate="yes" xml:space="preserve">
          <source>Handle excess argument diversity in the caller</source>
          <target state="translated">Manejar el exceso de diversidad de argumentos en el llamador</target>
        </trans-unit>
        <trans-unit id="10a3cb0df00f1fa97a3cb63486616c5cf79959d9" translate="yes" xml:space="preserve">
          <source>Handling Operating System Variation</source>
          <target state="translated">Manejo de la variación del sistema operativo</target>
        </trans-unit>
        <trans-unit id="67509204a791b926a290df40bb29deed545a4fe9" translate="yes" xml:space="preserve">
          <source>Happy Person Raising One Hand</source>
          <target state="translated">Persona feliz levantando una mano</target>
        </trans-unit>
        <trans-unit id="31f205e87d98bf7472c8354a4586dfc7173d7021" translate="yes" xml:space="preserve">
          <source>Hatching Chick</source>
          <target state="translated">Polluelo de incubación</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="6ef295c2897db61289ad0eb0b8171326ec851011" translate="yes" xml:space="preserve">
          <source>Headphone</source>
          <target state="translated">Headphone</target>
        </trans-unit>
        <trans-unit id="83fbe44a9f704c02d2d76ee1fa5c115010ff9d8c" translate="yes" xml:space="preserve">
          <source>Hear-No-Evil Monkey</source>
          <target state="translated">Hear-No-Evil Monkey</target>
        </trans-unit>
        <trans-unit id="2edafb06cf3a183a503a1615f5b8c4da86990553" translate="yes" xml:space="preserve">
          <source>Heart Decoration</source>
          <target state="translated">Decoración del corazón</target>
        </trans-unit>
        <trans-unit id="53648eedc9bfa102fd53ca957c856f7e0d9a2a2f" translate="yes" xml:space="preserve">
          <source>Heart With Arrow</source>
          <target state="translated">Corazón con flecha</target>
        </trans-unit>
        <trans-unit id="5461f091ddf4a776ade53602bfcdef544a0feb57" translate="yes" xml:space="preserve">
          <source>Heart With Ribbon</source>
          <target state="translated">Corazón con cinta</target>
        </trans-unit>
        <trans-unit id="fde3248d8454a04a4138dae1e5a31ab1432bdb78" translate="yes" xml:space="preserve">
          <source>Heavy Black Heart</source>
          <target state="translated">Corazón Negro Pesado</target>
        </trans-unit>
        <trans-unit id="662b2b0a5e62dab41b3f6deba4867bbd60a35b8f" translate="yes" xml:space="preserve">
          <source>Heavy Check Mark</source>
          <target state="translated">Marca de verificación pesada</target>
        </trans-unit>
        <trans-unit id="9ae6c1b9f7bdda7ce9eec6a4c6ee5efca7c871a5" translate="yes" xml:space="preserve">
          <source>Heavy Division Sign</source>
          <target state="translated">Signo de División Pesada</target>
        </trans-unit>
        <trans-unit id="7706e6c735cc207b9267e0979a8dbeb69e5229a0" translate="yes" xml:space="preserve">
          <source>Heavy Dollar Sign</source>
          <target state="translated">Signo de Dólar Pesado</target>
        </trans-unit>
        <trans-unit id="93e9c9786874a2de0cddf3ee5e7766e4ea031dca" translate="yes" xml:space="preserve">
          <source>Heavy Exclamation Mark Symbol</source>
          <target state="translated">Símbolo de signo de exclamación pesada</target>
        </trans-unit>
        <trans-unit id="78800e7776274c794a8d095ff4c2c73221dbbbae" translate="yes" xml:space="preserve">
          <source>Heavy Large Circle</source>
          <target state="translated">Círculo grande y pesado</target>
        </trans-unit>
        <trans-unit id="980c6d0d2733f3166210e842cefb858e063c0d91" translate="yes" xml:space="preserve">
          <source>Heavy Minus Sign</source>
          <target state="translated">Signo de menos pesado</target>
        </trans-unit>
        <trans-unit id="778bd00186fa7e144e55b7635e11bf1326888ddd" translate="yes" xml:space="preserve">
          <source>Heavy Multiplication X</source>
          <target state="translated">Multiplicación pesada X</target>
        </trans-unit>
        <trans-unit id="f686b15ee80bdb7a610f665e9bb567ee7025d65c" translate="yes" xml:space="preserve">
          <source>Heavy Plus Sign</source>
          <target state="translated">Signo más pesado</target>
        </trans-unit>
        <trans-unit id="75c1e5a632008728c5938fd7cc30c147bf32b6b5" translate="yes" xml:space="preserve">
          <source>Heavy Teardrop-Spoked Asterisk</source>
          <target state="translated">Asterisco con lagrimas pesadas</target>
        </trans-unit>
        <trans-unit id="fda201fd52a223f4da8ab6d74bf72a21faeaf60b" translate="yes" xml:space="preserve">
          <source>Helicopter</source>
          <target state="translated">Helicopter</target>
        </trans-unit>
        <trans-unit id="ae573d0f71ca2ef898057a3a11aeabc86f4048c4" translate="yes" xml:space="preserve">
          <source>Help mode</source>
          <target state="translated">Modo de ayuda</target>
        </trans-unit>
        <trans-unit id="5941c1bf985d2850f77798f46b591f5bf1a7198a" translate="yes" xml:space="preserve">
          <source>Help mode can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">Se puede salir del modo de ayuda pulsando la tecla de retroceso al principio de la línea.</target>
        </trans-unit>
        <trans-unit id="8882ebfc5a29fddc8a80eb230261926f56fd8d5e" translate="yes" xml:space="preserve">
          <source>Herb</source>
          <target state="translated">Herb</target>
        </trans-unit>
        <trans-unit id="bb934b9ceeaa4e54809a9838dfa1ed2cabf6522e" translate="yes" xml:space="preserve">
          <source>Here &quot;inline&quot; refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.</source>
          <target state="translated">Aquí &quot;en línea&quot; se refiere a los elementos que pueden encontrarse dentro de bloques de texto,es decir,párrafos.Entre ellos figuran los siguientes elementos.</target>
        </trans-unit>
        <trans-unit id="0aaf5b43ce3bf447f656063f8ac61c46b777eefc" translate="yes" xml:space="preserve">
          <source>Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; takes the data to write as its second argument, while &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; takes the type of the data to be read as the second argument.</source>
          <target state="translated">Aqu&amp;iacute; se presion&amp;oacute; Enter nuevamente para que Julia pudiera leer la nueva l&amp;iacute;nea. Ahora, como puede ver en este ejemplo, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; toma los datos a escribir como segundo argumento, mientras que &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; toma el tipo de datos a leer como segundo argumento.</target>
        </trans-unit>
        <trans-unit id="77b8367f53858f5da92aefb29bb20f4abb25843a" translate="yes" xml:space="preserve">
          <source>Here are some examples to demonstrate which type of arrays are strided and which are not:</source>
          <target state="translated">Aquí hay algunos ejemplos para demostrar qué tipo de matrices se mueven y cuáles no:</target>
        </trans-unit>
        <trans-unit id="3b3a2127d824649ba6d32ad8be94f9ae3c5dba0e" translate="yes" xml:space="preserve">
          <source>Here are some examples with bitwise operators:</source>
          <target state="translated">Aquí hay algunos ejemplos con operadores poco inteligentes:</target>
        </trans-unit>
        <trans-unit id="c2d9b5adfe6cd0f32ce45f61d872c609d6e0a4ff" translate="yes" xml:space="preserve">
          <source>Here are some simple examples using arithmetic operators:</source>
          <target state="translated">Aquí hay algunos ejemplos simples usando operadores aritméticos:</target>
        </trans-unit>
        <trans-unit id="f5ba1cb3713902ae4550268fb70da7530b34b57c" translate="yes" xml:space="preserve">
          <source>Here are some simple examples:</source>
          <target state="translated">Aquí hay algunos ejemplos simples:</target>
        </trans-unit>
        <trans-unit id="d3d30b41b93723417b3a0eda16323a2baedc0a7c" translate="yes" xml:space="preserve">
          <source>Here are some tips for working with Julia efficiently.</source>
          <target state="translated">Aquí hay algunos consejos para trabajar con Julia de manera eficiente.</target>
        </trans-unit>
        <trans-unit id="4b9dc1697c31ccdd9965aa0170dd226712f2cb14" translate="yes" xml:space="preserve">
          <source>Here each iteration applies &lt;code&gt;f&lt;/code&gt; to a randomly-chosen sample from a vector &lt;code&gt;a&lt;/code&gt; shared by all processes.</source>
          <target state="translated">Aqu&amp;iacute;, cada iteraci&amp;oacute;n aplica &lt;code&gt;f&lt;/code&gt; a una muestra elegida al azar de un vector &lt;code&gt;a&lt;/code&gt; compartido por todos los procesos.</target>
        </trans-unit>
        <trans-unit id="a76feb46cab9b567bf7483afc7491ed744f3c054" translate="yes" xml:space="preserve">
          <source>Here is a corresponding roots structure, represented as a dictionary:</source>
          <target state="translated">Aquí hay una estructura de raíces correspondiente,representada como un diccionario:</target>
        </trans-unit>
        <trans-unit id="86a5b746f6fe4ea8f489a225c69f586c3ee94b4f" translate="yes" xml:space="preserve">
          <source>Here is a more complex example, still using Markdown:</source>
          <target state="translated">Aquí hay un ejemplo más complejo,todavía usando Markdown:</target>
        </trans-unit>
        <trans-unit id="32a32a63972b7e15e6bc1e1399ca59536eaf91cf" translate="yes" xml:space="preserve">
          <source>Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest &lt;code&gt;P(2)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; type? In some cases (specifically, when &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt;) the answer is clear:</source>
          <target state="translated">Aqu&amp;iacute; hay un caso relacionado en el que el comportamiento esperado no es necesariamente obvio: &amp;iquest;Qu&amp;eacute; sucede cuando redondeamos al &lt;code&gt;P(2)&lt;/code&gt; m&amp;aacute;s cercano , donde &lt;code&gt;P&lt;/code&gt; es un tipo de &lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; ? En algunos casos (espec&amp;iacute;ficamente, cuando &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt; ) la respuesta es clara:</target>
        </trans-unit>
        <trans-unit id="cbc1a6d954403affcd824e28b3f149fcba6203f0" translate="yes" xml:space="preserve">
          <source>Here is a representation of a possible paths map for our example &lt;code&gt;App&lt;/code&gt; project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:</source>
          <target state="translated">Aqu&amp;iacute; hay una representaci&amp;oacute;n de un mapa de rutas posibles para nuestro entorno de proyecto de &lt;code&gt;App&lt;/code&gt; ejemplo , como se proporciona en el manifiesto dado anteriormente para el gr&amp;aacute;fico de dependencia, despu&amp;eacute;s de buscar en el sistema de archivos local:</target>
        </trans-unit>
        <trans-unit id="62b973b3d8599e23c2d9da9c0813b08faed1d7f5" translate="yes" xml:space="preserve">
          <source>Here is a second example wrapping the corresponding destructor:</source>
          <target state="translated">Aquí hay un segundo ejemplo que envuelve el destructor correspondiente:</target>
        </trans-unit>
        <trans-unit id="383164a53efb4be492fb1a747035c59b715f139a" translate="yes" xml:space="preserve">
          <source>Here is a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo simple de un contenedor C que devuelve un tipo &lt;code&gt;Ptr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fd4023e74c6b03e666e958ff6141359ac199b811" translate="yes" xml:space="preserve">
          <source>Here is a simplified definition of Julia's &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt;&lt;code&gt;@assert&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">Aqu&amp;iacute; hay una definici&amp;oacute;n simplificada de la macro &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt; &lt;code&gt;@assert&lt;/code&gt; &lt;/a&gt; de Julia :</target>
        </trans-unit>
        <trans-unit id="e40b5507bd00f53ac4347d820f9aea2085f1e997" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname:</source>
          <target state="translated">Aquí hay un ejemplo un poco más complejo que descubre el nombre de la máquina local:</target>
        </trans-unit>
        <trans-unit id="c20460c3bed82c94ed3787e3dfe27ae7c3b31699" translate="yes" xml:space="preserve">
          <source>Here is a third example passing Julia arrays:</source>
          <target state="translated">Aquí hay un tercer ejemplo que pasa por las matrices de Julia:</target>
        </trans-unit>
        <trans-unit id="d610a40401dd7269ef98b9bc1fb559f31c643ca5" translate="yes" xml:space="preserve">
          <source>Here is an even more complex multi-stage producer-consumer example:</source>
          <target state="translated">He aquí un ejemplo aún más complejo de productor-consumidor en múltiples etapas:</target>
        </trans-unit>
        <trans-unit id="166759fbb289c37473d7a6b4b102bc98c71ab976" translate="yes" xml:space="preserve">
          <source>Here is an example of a &quot;compound function&quot; that should really be written as multiple definitions:</source>
          <target state="translated">He aquí un ejemplo de una &quot;función compuesta&quot; que realmente debería escribirse como definiciones múltiples:</target>
        </trans-unit>
        <trans-unit id="dff5c26dbc80f0776c11c28a5633445af4d9d175" translate="yes" xml:space="preserve">
          <source>Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:</source>
          <target state="translated">Aquí hay un ejemplo con los tres tipos de marcas.Este programa primero calcula la diferencia finita de una matriz unidimensional,y luego evalúa la norma L2 del resultado:</target>
        </trans-unit>
        <trans-unit id="f97cb2973176feb8f941a5117a88dd7fad7d8ec1" translate="yes" xml:space="preserve">
          <source>Here is an example with both &lt;code&gt;@inbounds&lt;/code&gt; and &lt;code&gt;@simd&lt;/code&gt; markup (we here use &lt;code&gt;@noinline&lt;/code&gt; to prevent the optimizer from trying to be too clever and defeat our benchmark):</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo con el marcado &lt;code&gt;@inbounds&lt;/code&gt; y &lt;code&gt;@simd&lt;/code&gt; (aqu&amp;iacute; usamos &lt;code&gt;@noinline&lt;/code&gt; para evitar que el optimizador intente ser demasiado inteligente y derrote nuestro punto de referencia):</target>
        </trans-unit>
        <trans-unit id="87f18e8d7ee1b76e68d3166f552e8d656c81958f" translate="yes" xml:space="preserve">
          <source>Here is an extraordinarily simple macro:</source>
          <target state="translated">Aquí hay una macro extraordinariamente simple:</target>
        </trans-unit>
        <trans-unit id="7afc02096736fcb4c01a0c6afaea2e90973eb75e" translate="yes" xml:space="preserve">
          <source>Here is the correct code template for returning the element-type &lt;code&gt;T&lt;/code&gt; of any arbitrary subtype of &lt;code&gt;AbstractArray&lt;/code&gt;:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la plantilla de c&amp;oacute;digo correcta para devolver el tipo de elemento &lt;code&gt;T&lt;/code&gt; de cualquier subtipo arbitrario de &lt;code&gt;AbstractArray&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5f4fdb43158ce32a870e863c53f180f3aa098a57" translate="yes" xml:space="preserve">
          <source>Here is the corresponding graph structure, represented as a dictionary:</source>
          <target state="translated">Aquí está la correspondiente estructura gráfica,representada como un diccionario:</target>
        </trans-unit>
        <trans-unit id="f9b6eba975c84af5ac0af3798604d9ad36108359" translate="yes" xml:space="preserve">
          <source>Here module &lt;code&gt;Parent&lt;/code&gt; contains a submodule &lt;code&gt;Utils&lt;/code&gt;, and code in &lt;code&gt;Parent&lt;/code&gt; wants the contents of &lt;code&gt;Utils&lt;/code&gt; to be visible. This is done by starting the &lt;code&gt;using&lt;/code&gt; path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example &lt;code&gt;using ..Utils&lt;/code&gt; would look for &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt;'s enclosing module rather than in &lt;code&gt;Parent&lt;/code&gt; itself.</source>
          <target state="translated">Aqu&amp;iacute; el m&amp;oacute;dulo &lt;code&gt;Parent&lt;/code&gt; contiene un subm&amp;oacute;dulo &lt;code&gt;Utils&lt;/code&gt; , y el c&amp;oacute;digo en &lt;code&gt;Parent&lt;/code&gt; quiere que el contenido de &lt;code&gt;Utils&lt;/code&gt; sea ​​visible. Esto se hace comenzando la ruta de &lt;code&gt;using&lt;/code&gt; con un punto. Al agregar m&amp;aacute;s per&amp;iacute;odos iniciales, se mueven niveles adicionales en la jerarqu&amp;iacute;a del m&amp;oacute;dulo. Por ejemplo &lt;code&gt;using ..Utils&lt;/code&gt; buscar&amp;iacute;a &lt;code&gt;Utils&lt;/code&gt; en &lt;code&gt;Parent&lt;/code&gt; 's m&amp;oacute;dulo de encerrar en lugar de en &lt;code&gt;Parent&lt;/code&gt; s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="cf5b1250aa2128de01974785ca5a0cd9b855ebd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;1:5&lt;/code&gt; is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The &lt;code&gt;for&lt;/code&gt; loop iterates through these values, assigning each one in turn to the variable &lt;code&gt;i&lt;/code&gt;. One rather important distinction between the previous &lt;code&gt;while&lt;/code&gt; loop form and the &lt;code&gt;for&lt;/code&gt; loop form is the scope during which the variable is visible. If the variable &lt;code&gt;i&lt;/code&gt; has not been introduced in another scope, in the &lt;code&gt;for&lt;/code&gt; loop form, it is visible only inside of the &lt;code&gt;for&lt;/code&gt; loop, and not outside/afterwards. You'll either need a new interactive session instance or a different variable name to test this:</source>
          <target state="translated">Aqu&amp;iacute; el &lt;code&gt;1:5&lt;/code&gt; es un objeto de rango, que representa la secuencia de n&amp;uacute;meros 1, 2, 3, 4, 5. El bucle &lt;code&gt;for&lt;/code&gt; itera a trav&amp;eacute;s de estos valores, asignando cada uno a la variable &lt;code&gt;i&lt;/code&gt; . Una distinci&amp;oacute;n bastante importante entre la forma de bucle &lt;code&gt;while&lt;/code&gt; anterior y la forma de bucle &lt;code&gt;for&lt;/code&gt; es el alcance durante el cual la variable es visible. Si la variable &lt;code&gt;i&lt;/code&gt; no se ha introducido en otro &amp;aacute;mbito, en la forma de bucle &lt;code&gt;for&lt;/code&gt; , solo es visible dentro del bucle &lt;code&gt;for&lt;/code&gt; , y no fuera / despu&amp;eacute;s. Necesitar&amp;aacute; una nueva instancia de sesi&amp;oacute;n interactiva o un nombre de variable diferente para probar esto:</target>
        </trans-unit>
        <trans-unit id="052893fe9e50a40443ea78d54cd3b33cb280eb4e" translate="yes" xml:space="preserve">
          <source>Here the call &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; could be handled by either the &lt;code&gt;g(Float64, Any)&lt;/code&gt; or the &lt;code&gt;g(Any, Float64)&lt;/code&gt; method, and neither is more specific than the other. In such cases, Julia raises a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:</source>
          <target state="translated">Aqu&amp;iacute;, la llamada &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; podr&amp;iacute;a manejarse con el &lt;code&gt;g(Float64, Any)&lt;/code&gt; o &lt;code&gt;g(Any, Float64)&lt;/code&gt; , y ninguno es m&amp;aacute;s espec&amp;iacute;fico que el otro. En tales casos, Julia genera un &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; en&lt;/a&gt; lugar de elegir arbitrariamente un m&amp;eacute;todo. Puede evitar las ambig&amp;uuml;edades del m&amp;eacute;todo especificando un m&amp;eacute;todo apropiado para el caso de intersecci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="373c14d6a8445cd3c00b580baccefb5fd3f3d12c" translate="yes" xml:space="preserve">
          <source>Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.</source>
          <target state="translated">Aquí se imprime el primer número después de un retraso de dos segundos,luego los siguientes números se imprimen rápidamente.</target>
        </trans-unit>
        <trans-unit id="f3418902a4f242b518d4d5f42412b650db9149b7" translate="yes" xml:space="preserve">
          <source>Here the user expression &lt;code&gt;ex&lt;/code&gt; is a call to &lt;code&gt;time&lt;/code&gt;, but not the same &lt;code&gt;time&lt;/code&gt; function that the macro uses. It clearly refers to &lt;code&gt;MyModule.time&lt;/code&gt;. Therefore we must arrange for the code in &lt;code&gt;ex&lt;/code&gt; to be resolved in the macro call environment. This is done by &quot;escaping&quot; the expression with &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt;&lt;code&gt;esc&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Aqu&amp;iacute;, la expresi&amp;oacute;n de usuario &lt;code&gt;ex&lt;/code&gt; es una llamada al &lt;code&gt;time&lt;/code&gt; , pero no es la misma funci&amp;oacute;n de &lt;code&gt;time&lt;/code&gt; que usa la macro. Claramente se refiere a &lt;code&gt;MyModule.time&lt;/code&gt; . Por lo tanto, debemos hacer arreglos para que el c&amp;oacute;digo en &lt;code&gt;ex&lt;/code&gt; se resuelva en el entorno de llamada de macro. Esto se hace &quot;escapando&quot; de la expresi&amp;oacute;n con &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt; &lt;code&gt;esc&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="319de09db8b0ceed706c2722ad8c4f12c486b513" translate="yes" xml:space="preserve">
          <source>Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called &lt;em&gt;outer&lt;/em&gt; constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.</source>
          <target state="translated">Aqu&amp;iacute;, el m&amp;eacute;todo constructor de argumento cero llama al m&amp;eacute;todo constructor de argumento &amp;uacute;nico, que a su vez llama al m&amp;eacute;todo constructor de dos argumentos proporcionado autom&amp;aacute;ticamente. Por razones que se aclarar&amp;aacute;n en breve, los m&amp;eacute;todos constructores adicionales declarados como m&amp;eacute;todos normales como este se denominan m&amp;eacute;todos constructores &lt;em&gt;externos&lt;/em&gt; . Los m&amp;eacute;todos de constructor externos solo pueden crear una nueva instancia llamando a otro m&amp;eacute;todo de constructor, como los predeterminados proporcionados autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="754489125a9dd659e2690c5c486d5c6350ca9a2b" translate="yes" xml:space="preserve">
          <source>Here we create and store two closures that return variable &lt;code&gt;i&lt;/code&gt;. However, it is always the same variable &lt;code&gt;i&lt;/code&gt;, so the two closures behave identically. We can use &lt;code&gt;let&lt;/code&gt; to create a new binding for &lt;code&gt;i&lt;/code&gt;:</source>
          <target state="translated">Aqu&amp;iacute; creamos y almacenamos dos cierres que devuelven la variable &lt;code&gt;i&lt;/code&gt; . Sin embargo, siempre es la misma variable &lt;code&gt;i&lt;/code&gt; , por lo que los dos cierres se comportan de manera id&amp;eacute;ntica. Podemos usar &lt;code&gt;let&lt;/code&gt; para crear un nuevo enlace para &lt;code&gt;i&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f311d723a18a177fef2791eca3f472638877d565" translate="yes" xml:space="preserve">
          <source>Here we created a function &lt;code&gt;change_array!&lt;/code&gt;, that assigns &lt;code&gt;5&lt;/code&gt; to the first element of the passed array (bound to &lt;code&gt;x&lt;/code&gt; at the call site, and bound to &lt;code&gt;A&lt;/code&gt; within the function). Notice that, after the function call, &lt;code&gt;x&lt;/code&gt; is still bound to the same array, but the content of that array changed: the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; were distinct bindings referring to the same mutable &lt;code&gt;Array&lt;/code&gt; object.</source>
          <target state="translated">Aqu&amp;iacute; creamos una funci&amp;oacute;n &lt;code&gt;change_array!&lt;/code&gt; , que asigna &lt;code&gt;5&lt;/code&gt; al primer elemento de la matriz pasada (vinculado &lt;code&gt;x&lt;/code&gt; en el sitio de llamada y vinculado a &lt;code&gt;A&lt;/code&gt; dentro de la funci&amp;oacute;n). Observe que, despu&amp;eacute;s de la llamada a la funci&amp;oacute;n, &lt;code&gt;x&lt;/code&gt; todav&amp;iacute;a est&amp;aacute; vinculado a la misma matriz, pero el contenido de esa matriz cambi&amp;oacute;: las variables &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; eran vinculaciones distintas que se refer&amp;iacute;an al mismo objeto de &lt;code&gt;Array&lt;/code&gt; mutable .</target>
        </trans-unit>
        <trans-unit id="97836fe829ccf3f620529d58616382e12cd6d98d" translate="yes" xml:space="preserve">
          <source>Here we have created a type &lt;code&gt;BitVector&lt;/code&gt; which has no parameters, but where the element-type is still fully specified, with &lt;code&gt;T&lt;/code&gt; equal to &lt;code&gt;Bool&lt;/code&gt;!</source>
          <target state="translated">Aqu&amp;iacute; hemos creado un tipo &lt;code&gt;BitVector&lt;/code&gt; que no tiene par&amp;aacute;metros, pero donde el tipo de elemento todav&amp;iacute;a est&amp;aacute; completamente especificado, con &lt;code&gt;T&lt;/code&gt; igual a &lt;code&gt;Bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b9af6aad35623f9ee689638f54770ed7633fd26" translate="yes" xml:space="preserve">
          <source>Here's a brief example:</source>
          <target state="translated">Aquí hay un breve ejemplo:</target>
        </trans-unit>
        <trans-unit id="e0b11719421310c6cc4a896b044019316b57f70b" translate="yes" xml:space="preserve">
          <source>Here's a simple example of running an external program:</source>
          <target state="translated">Aquí hay un ejemplo simple de la ejecución de un programa externo:</target>
        </trans-unit>
        <trans-unit id="20a6acaa904201f8599df8ef13450aeef27c5681" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="translated">Aqu&amp;iacute;, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; primero abre el archivo para escribir y luego pasa el flujo de salida resultante a la funci&amp;oacute;n an&amp;oacute;nima que defini&amp;oacute; en el bloque &lt;code&gt;do ... end&lt;/code&gt; . Despu&amp;eacute;s de que su funci&amp;oacute;n salga, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; se asegurar&amp;aacute; de que la secuencia se cierre correctamente, independientemente de si su funci&amp;oacute;n sali&amp;oacute; normalmente o lanz&amp;oacute; una excepci&amp;oacute;n. (La construcci&amp;oacute;n &lt;code&gt;try/finally&lt;/code&gt; se describir&amp;aacute; en &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7a90ca3f6b58f2547fca94266c1813296e387071" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;(2, 3)&lt;/code&gt; es una &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5216371c7d0926d72d95ff987a3d80e32321d1dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;count&lt;/code&gt; finds the number of commits along the walk with a certain &lt;code&gt;GitHash&lt;/code&gt;. Since the &lt;code&gt;GitHash&lt;/code&gt; is unique to a commit, &lt;code&gt;cnt&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;count&lt;/code&gt; encuentra el n&amp;uacute;mero de confirmaciones a lo largo de la caminata con un determinado &lt;code&gt;GitHash&lt;/code&gt; . Dado que &lt;code&gt;GitHash&lt;/code&gt; es exclusivo de una confirmaci&amp;oacute;n, &lt;code&gt;cnt&lt;/code&gt; ser&amp;aacute; &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2161ca87d055525464e4a5b1fd21109ca2813404" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;map&lt;/code&gt; visits each commit using the &lt;code&gt;GitRevWalker&lt;/code&gt; and finds its &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, el &lt;code&gt;map&lt;/code&gt; a visita cada confirmaci&amp;oacute;n usando &lt;code&gt;GitRevWalker&lt;/code&gt; y encuentra su &lt;code&gt;GitHash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="290a784ce45faad752be9227fb340601f3f76ead" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;sp.data&lt;/code&gt; refers to the second parameter in the call to the &lt;code&gt;SamplerSimple&lt;/code&gt; constructor (in this case equal to &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt;), while the &lt;code&gt;Die&lt;/code&gt; object can be accessed via &lt;code&gt;sp[]&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;sp.data&lt;/code&gt; se refiere al segundo par&amp;aacute;metro en la llamada al constructor &lt;code&gt;SamplerSimple&lt;/code&gt; (en este caso igual a &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt; ), mientras que se puede acceder al objeto &lt;code&gt;Die&lt;/code&gt; a trav&amp;eacute;s de &lt;code&gt;sp[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6537ead3e178965ea266058307a50f1c2fbf640" translate="yes" xml:space="preserve">
          <source>Here, Julia was able to detect that &lt;code&gt;B&lt;/code&gt; is in fact symmetric, and used a more appropriate factorization. Often it's possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can &quot;tag&quot; matrices as having these properties. For instance:</source>
          <target state="translated">Aqu&amp;iacute;, Julia pudo detectar que &lt;code&gt;B&lt;/code&gt; es de hecho sim&amp;eacute;trico y utiliz&amp;oacute; una factorizaci&amp;oacute;n m&amp;aacute;s apropiada. A menudo es posible escribir c&amp;oacute;digo m&amp;aacute;s eficiente para una matriz que se sabe que tiene ciertas propiedades, por ejemplo, es sim&amp;eacute;trica o tridiagonal. Julia proporciona algunos tipos especiales para que pueda &quot;etiquetar&quot; matrices con estas propiedades. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c40867232cf6016f6f8e42d642627bb64b253d86" translate="yes" xml:space="preserve">
          <source>Here, the evaluation of an expression object causes a value to be assigned to the global variable &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, la evaluaci&amp;oacute;n de un objeto de expresi&amp;oacute;n hace que se asigne un valor a la variable global &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e6a3f428f565fb6b0000baaea7b4aa785dbcfc" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore can be used in the same (covariant) context of the input argument to a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. A pointer to memory allocated by Julia must be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. Therefore, the &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; declaration allows pointers managed by C or Julia to be used.</source>
          <target state="translated">Aqu&amp;iacute;, se declara que la entrada &lt;code&gt;p&lt;/code&gt; es de tipo &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; , lo que significa que la memoria a la que apunta &lt;code&gt;p&lt;/code&gt; puede ser administrada por Julia o por C. Un puntero a la memoria asignada por C debe ser del tipo &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; , pero es convertible usando &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; y por lo tanto se puede usar en el mismo contexto (covariante) del argumento de entrada a un &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; . Un puntero a la memoria asignada por Julia debe ser de tipo &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; , para garantizar que la direcci&amp;oacute;n de memoria apuntada sea v&amp;aacute;lida y que el recolector de basura de Julia gestione la porci&amp;oacute;n de memoria apuntada correctamente. Por lo tanto, la &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; La declaraci&amp;oacute;n permite usar punteros administrados por C o Julia.</target>
        </trans-unit>
        <trans-unit id="1ab09345f1dd2caf08c8b3f5ca36d5682164ea59" translate="yes" xml:space="preserve">
          <source>Here, the option &lt;code&gt;--math-mode=ieee&lt;/code&gt; disables the &lt;code&gt;@fastmath&lt;/code&gt; macro, so that we can compare results.</source>
          <target state="translated">Aqu&amp;iacute;, la opci&amp;oacute;n &lt;code&gt;--math-mode=ieee&lt;/code&gt; deshabilita la macro &lt;code&gt;@fastmath&lt;/code&gt; , para que podamos comparar los resultados.</target>
        </trans-unit>
        <trans-unit id="6cbc6c9a872faab52c966ca377e3e05b9b758b19" translate="yes" xml:space="preserve">
          <source>Here, the total produced by &lt;code&gt;sum&lt;/code&gt; is passed to the &lt;code&gt;sqrt&lt;/code&gt; function. The equivalent composition would be:</source>
          <target state="translated">Aqu&amp;iacute;, el total producido por &lt;code&gt;sum&lt;/code&gt; se pasa a la funci&amp;oacute;n &lt;code&gt;sqrt&lt;/code&gt; . La composici&amp;oacute;n equivalente ser&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="eab8445a2aa7f75fce1fbdd298d4317a2e164c25" translate="yes" xml:space="preserve">
          <source>Here, we happened to know that the first element of &lt;code&gt;a&lt;/code&gt; would be an &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.</source>
          <target state="translated">Aqu&amp;iacute;, sab&amp;iacute;amos que el primer elemento de &lt;code&gt;a&lt;/code&gt; ser&amp;iacute;a un &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; . Hacer una anotaci&amp;oacute;n como esta tiene el beneficio adicional de que generar&amp;aacute; un error en tiempo de ejecuci&amp;oacute;n si el valor no es del tipo esperado, lo que podr&amp;iacute;a detectar ciertos errores antes.</target>
        </trans-unit>
        <trans-unit id="3b5f47a75f954e4b2fddf51e62aa2e1f9d263c7c" translate="yes" xml:space="preserve">
          <source>Here, we want &lt;code&gt;t0&lt;/code&gt;, &lt;code&gt;t1&lt;/code&gt;, and &lt;code&gt;val&lt;/code&gt; to be private temporary variables, and we want &lt;code&gt;time&lt;/code&gt; to refer to the &lt;code&gt;time&lt;/code&gt; function in Julia Base, not to any &lt;code&gt;time&lt;/code&gt; variable the user might have (the same applies to &lt;code&gt;println&lt;/code&gt;). Imagine the problems that could occur if the user expression &lt;code&gt;ex&lt;/code&gt; also contained assignments to a variable called &lt;code&gt;t0&lt;/code&gt;, or defined its own &lt;code&gt;time&lt;/code&gt; variable. We might get errors, or mysteriously incorrect behavior.</source>
          <target state="translated">Aqu&amp;iacute;, queremos que &lt;code&gt;t0&lt;/code&gt; , &lt;code&gt;t1&lt;/code&gt; y &lt;code&gt;val&lt;/code&gt; sean variables temporales privadas, y queremos que &lt;code&gt;time&lt;/code&gt; se refiera a la funci&amp;oacute;n de &lt;code&gt;time&lt;/code&gt; en Julia Base, no a cualquier variable de &lt;code&gt;time&lt;/code&gt; que el usuario pueda tener (lo mismo se aplica a &lt;code&gt;println&lt;/code&gt; ). Imagine los problemas que podr&amp;iacute;an ocurrir si la expresi&amp;oacute;n de usuario &lt;code&gt;ex&lt;/code&gt; tambi&amp;eacute;n contuviera asignaciones a una variable llamada &lt;code&gt;t0&lt;/code&gt; , o definiera su propia variable de &lt;code&gt;time&lt;/code&gt; . Podr&amp;iacute;amos tener errores o un comportamiento misteriosamente incorrecto.</target>
        </trans-unit>
        <trans-unit id="94fb6a6428243b8c36b29add8e81342285442dea" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, hemos agregado una funci&amp;oacute;n de constructor personalizada para que pueda tomar argumentos de diferentes tipos &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; y promoverlos a un tipo com&amp;uacute;n (consulte &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructores&lt;/a&gt; y &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversi&amp;oacute;n y promoci&amp;oacute;n&lt;/a&gt; ). (Por supuesto, tambi&amp;eacute;n tendr&amp;iacute;amos que definir muchos otros m&amp;eacute;todos para que act&amp;uacute;e como un &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; , por ejemplo , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;one&lt;/code&gt; , &lt;code&gt;zero&lt;/code&gt; , reglas de promoci&amp;oacute;n, etc.) De forma predeterminada, las instancias de este tipo se muestran de forma bastante simple , con informaci&amp;oacute;n sobre el nombre del tipo y los valores del campo, como por ejemplo, &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8c4e9914a1889e98efb20fcf34b5a7f7c01253" translate="yes" xml:space="preserve">
          <source>Here, you've created the same problem all over again: the compiler can't guess what &lt;code&gt;n&lt;/code&gt; is, so it doesn't know the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;Val(n)&lt;/code&gt;. Attempting to use &lt;code&gt;Val&lt;/code&gt;, but doing so incorrectly, can easily make performance &lt;em&gt;worse&lt;/em&gt; in many situations. (Only in situations where you're effectively combining &lt;code&gt;Val&lt;/code&gt; with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)</source>
          <target state="translated">Aqu&amp;iacute;, ha creado el mismo problema de nuevo: el compilador no puede adivinar qu&amp;eacute; es &lt;code&gt;n&lt;/code&gt; , por lo que no conoce el &lt;em&gt;tipo&lt;/em&gt; de &lt;code&gt;Val(n)&lt;/code&gt; . El intento de utilizar &lt;code&gt;Val&lt;/code&gt; , pero si lo hace de forma incorrecta, puede hacer f&amp;aacute;cilmente un rendimiento &lt;em&gt;peor&lt;/em&gt; en muchas situaciones. (Solo en situaciones en las que est&amp;aacute; combinando &lt;code&gt;Val&lt;/code&gt; de manera efectiva con el truco de la barrera de funci&amp;oacute;n, para hacer que la funci&amp;oacute;n del kernel sea m&amp;aacute;s eficiente, se debe usar un c&amp;oacute;digo como el anterior).</target>
        </trans-unit>
        <trans-unit id="c7628673517938376c201f828128315e60314655" translate="yes" xml:space="preserve">
          <source>Hermitian Conjugate Matrix</source>
          <target state="translated">Matriz Conjugada Hermitiana</target>
        </trans-unit>
        <trans-unit id="7426047f57253430c62cd4ed4e8350b30626acf7" translate="yes" xml:space="preserve">
          <source>Hermitian matrix</source>
          <target state="translated">Matriz hermitiana</target>
        </trans-unit>
        <trans-unit id="10678e1b00011a887c8ed10343c313db680c592e" translate="yes" xml:space="preserve">
          <source>Hessenberg decomposition</source>
          <target state="translated">La descomposición de Hessenberg</target>
        </trans-unit>
        <trans-unit id="18dcd84b08d39e78997dcf4fc69cbfdf65766429" translate="yes" xml:space="preserve">
          <source>Hex bytes (&lt;code&gt;\x&lt;/code&gt; with 1-2 trailing hex digits)</source>
          <target state="translated">Bytes hexadecimales ( &lt;code&gt;\x&lt;/code&gt; con 1-2 d&amp;iacute;gitos hexadecimales finales)</target>
        </trans-unit>
        <trans-unit id="5829ae1ed6f556d7c22293c127a375905a4cde38" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point literals are also valid, but only as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, with &lt;code&gt;p&lt;/code&gt; preceding the base-2 exponent:</source>
          <target state="translated">Los literales hexadecimales de punto flotante tambi&amp;eacute;n son v&amp;aacute;lidos, pero solo como valores &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , con &lt;code&gt;p&lt;/code&gt; antes del exponente en base 2:</target>
        </trans-unit>
        <trans-unit id="566a781a74cd1186e4a86a913b9dfbcd8a9760f5" translate="yes" xml:space="preserve">
          <source>Hibiscus</source>
          <target state="translated">Hibiscus</target>
        </trans-unit>
        <trans-unit id="590d79aff0a27abac1599349b9f60e654406e4f9" translate="yes" xml:space="preserve">
          <source>High Brightness Symbol</source>
          <target state="translated">Símbolo de alto brillo</target>
        </trans-unit>
        <trans-unit id="5c42b554d600e8a00d6d46015f5546b8d19934a3" translate="yes" xml:space="preserve">
          <source>High Voltage Sign</source>
          <target state="translated">Señal de alto voltaje</target>
        </trans-unit>
        <trans-unit id="ab1b93cb46a149db7c34f14c047358adef0d1f47" translate="yes" xml:space="preserve">
          <source>High-Heeled Shoe</source>
          <target state="translated">Zapato de tacón alto</target>
        </trans-unit>
        <trans-unit id="22cda4a90e394a1d9c3ad940b9369d0797179dd6" translate="yes" xml:space="preserve">
          <source>High-Level Embedding</source>
          <target state="translated">Incrustación de alto nivel</target>
        </trans-unit>
        <trans-unit id="772ba23e35e2b9a933b76e30398f7eb414430f46" translate="yes" xml:space="preserve">
          <source>High-Level Embedding on Windows with Visual Studio</source>
          <target state="translated">Incrustación de alto nivel en Windows con Visual Studio</target>
        </trans-unit>
        <trans-unit id="9f567cb6bf549d8f1f72a7aad5d5c25bc17a082a" translate="yes" xml:space="preserve">
          <source>High-Speed Train</source>
          <target state="translated">Tren de alta velocidad</target>
        </trans-unit>
        <trans-unit id="00e1cd5d9c96d48229c7017e30357cb8a8d1334d" translate="yes" xml:space="preserve">
          <source>High-Speed Train With Bullet Nose</source>
          <target state="translated">Tren de alta velocidad con nariz de bala</target>
        </trans-unit>
        <trans-unit id="1b2be27c3b5a49f7125a227298d591cb7aea55af" translate="yes" xml:space="preserve">
          <source>High-level libraries like &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</source>
          <target state="translated">Bibliotecas de alto nivel como &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; y &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e0b3549b5782921269587cd589e55b82058b718" translate="yes" xml:space="preserve">
          <source>High-level vendor-specific abstractions like &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</source>
          <target state="translated">Abstracciones espec&amp;iacute;ficas de proveedores de alto nivel como &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; y &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cef2d62c8136407d7a5910b738c2a4954d1ff380" translate="yes" xml:space="preserve">
          <source>Hocho</source>
          <target state="translated">Hocho</target>
        </trans-unit>
        <trans-unit id="1183df425fd69adfff4afc7c4b9f794b3027f62e" translate="yes" xml:space="preserve">
          <source>Hold up: why macros?</source>
          <target state="translated">Espera:¿por qué macros?</target>
        </trans-unit>
        <trans-unit id="a19d1b5e13bc5eadd5512a5657629c48486fc2aa" translate="yes" xml:space="preserve">
          <source>Holds a reference to an object of type &lt;code&gt;T&lt;/code&gt;, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.</source>
          <target state="translated">Contiene una referencia a un objeto de tipo &lt;code&gt;T&lt;/code&gt; , lo que garantiza que solo se acceda de forma at&amp;oacute;mica, es decir, de forma segura para subprocesos.</target>
        </trans-unit>
        <trans-unit id="6d4b2c4793516d9999da8f3caabfcc7a3164599f" translate="yes" xml:space="preserve">
          <source>Home, &lt;code&gt;^A&lt;/code&gt;</source>
          <target state="translated">Inicio, &lt;code&gt;^A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85d163149ee6c8d4bb4972a8d9d62f2349badb11" translate="yes" xml:space="preserve">
          <source>Homothetic</source>
          <target state="translated">Homothetic</target>
        </trans-unit>
        <trans-unit id="642aac9525060b37b0f7470d6f6c49db706b03d9" translate="yes" xml:space="preserve">
          <source>Honey Pot</source>
          <target state="translated">Tarro de miel</target>
        </trans-unit>
        <trans-unit id="a643db335a306154edebc33a5e2763a380d1411b" translate="yes" xml:space="preserve">
          <source>Honeybee</source>
          <target state="translated">Honeybee</target>
        </trans-unit>
        <trans-unit id="79734fdcfe66d25a072a5769ba821cd7967d89f5" translate="yes" xml:space="preserve">
          <source>Hooking into the &lt;code&gt;Random&lt;/code&gt; API</source>
          <target state="translated">Conectarse a la API &lt;code&gt;Random&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a938072797969a150ccb7384d30e3585d81c5ec0" translate="yes" xml:space="preserve">
          <source>Horizontal Black Hexagon</source>
          <target state="translated">Hexágono negro horizontal</target>
        </trans-unit>
        <trans-unit id="9d0c97d942673d5e711ab71b642cc25b6f24a2b9" translate="yes" xml:space="preserve">
          <source>Horizontal Ellipsis</source>
          <target state="translated">Elipsis horizontal</target>
        </trans-unit>
        <trans-unit id="3627a44f223e474759956cf47448b20612b0d19a" translate="yes" xml:space="preserve">
          <source>Horizontal Traffic Light</source>
          <target state="translated">Semáforo horizontal</target>
        </trans-unit>
        <trans-unit id="b7e611daf03b332b5f4ec9209097868ee372b256" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</source>
          <target state="translated">Concatenación horizontal y vertical en una sola llamada.Esta función se llama sintaxis de matriz de bloque.El primer argumento especifica el número de argumentos a concatenar en cada fila de bloque.</target>
        </trans-unit>
        <trans-unit id="f26372d5f0aca43e155e7d006ab50ec72ec57fe2" translate="yes" xml:space="preserve">
          <source>Horizontal rules</source>
          <target state="translated">Reglas horizontales</target>
        </trans-unit>
        <trans-unit id="26dfe8116b93ced6cfca858f375d23f1489d3207" translate="yes" xml:space="preserve">
          <source>Horse</source>
          <target state="translated">Horse</target>
        </trans-unit>
        <trans-unit id="4a166dcec39a913a939b3a42f695d1c218fcaebb" translate="yes" xml:space="preserve">
          <source>Horse Face</source>
          <target state="translated">Cara de caballo</target>
        </trans-unit>
        <trans-unit id="8f21624d2501467ee4a054c705bd995e4b73ebab" translate="yes" xml:space="preserve">
          <source>Horse Racing</source>
          <target state="translated">Carreras de caballos</target>
        </trans-unit>
        <trans-unit id="dbb927867e102f755c1433b1f25539bafdd7268b" translate="yes" xml:space="preserve">
          <source>Hospital</source>
          <target state="translated">Hospital</target>
        </trans-unit>
        <trans-unit id="ef97c144078e1020e0c1fdf8b383ff06d12e8270" translate="yes" xml:space="preserve">
          <source>Hot Beverage</source>
          <target state="translated">Bebidas calientes</target>
        </trans-unit>
        <trans-unit id="cb506dd41a005a6fcc0d4c18104ce66e01d7afa8" translate="yes" xml:space="preserve">
          <source>Hot Springs</source>
          <target state="translated">Aguas termales</target>
        </trans-unit>
        <trans-unit id="9c4ba7d047eb56093b34e5dc3e51e5fcc74603f4" translate="yes" xml:space="preserve">
          <source>Hotel</source>
          <target state="translated">Hotel</target>
        </trans-unit>
        <trans-unit id="fcc1b57017e3ac9f33e4e51068baf64a23795adf" translate="yes" xml:space="preserve">
          <source>Hourglass</source>
          <target state="translated">Hourglass</target>
        </trans-unit>
        <trans-unit id="bf7a0304247679d7272f0a79f9d388f130597fd4" translate="yes" xml:space="preserve">
          <source>Hourglass With Flowing Sand</source>
          <target state="translated">Reloj de Arena con Arena Fluyente</target>
        </trans-unit>
        <trans-unit id="dc8745ba30beefa5d028f85ba9b11599a2ac8d7e" translate="yes" xml:space="preserve">
          <source>House</source>
          <target state="translated">House</target>
        </trans-unit>
        <trans-unit id="b6ac911209d87615e6f295e017b36c332cd3b878" translate="yes" xml:space="preserve">
          <source>House Building</source>
          <target state="translated">Construcción de la casa</target>
        </trans-unit>
        <trans-unit id="b07df507eb5fd0e4b6c36328d58c64ebcc7b5d32" translate="yes" xml:space="preserve">
          <source>House With Garden</source>
          <target state="translated">Casa con jardín</target>
        </trans-unit>
        <trans-unit id="eefa8d28bdac822ea112d7e5259409579ba61c80" translate="yes" xml:space="preserve">
          <source>How can I modify the declaration of a type in my session?</source>
          <target state="translated">¿Cómo puedo modificar la declaración de un tipo en mi sesión?</target>
        </trans-unit>
        <trans-unit id="515d85b9b31cb430ad4b0705dfed0fd34c859e1a" translate="yes" xml:space="preserve">
          <source>How did the file name get quoted? Julia knows that &lt;code&gt;file&lt;/code&gt; is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of &lt;code&gt;file&lt;/code&gt; is never interpreted by a shell, so there's no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo se cotiz&amp;oacute; el nombre del archivo? Julia sabe que el &lt;code&gt;file&lt;/code&gt; est&amp;aacute; destinado a ser interpolado como un solo argumento, por lo que cita la palabra por ti. En realidad, eso no es del todo exacto: el valor del &lt;code&gt;file&lt;/code&gt; nunca es interpretado por un shell, por lo que no hay necesidad de comillas reales; las citas se insertan solo para su presentaci&amp;oacute;n al usuario. Esto incluso funcionar&amp;aacute; si interpola un valor como parte de una palabra de shell:</target>
        </trans-unit>
        <trans-unit id="7554712c2d173a82ff8ff4725649f94b899a6cab" translate="yes" xml:space="preserve">
          <source>How do I catch CTRL-C in a script?</source>
          <target state="translated">¿Cómo atrapo CTRL-C en un guión?</target>
        </trans-unit>
        <trans-unit id="2a65d886539b09798da7278037976d95b79a6f2f" translate="yes" xml:space="preserve">
          <source>How do I check if the current file is being run as the main script?</source>
          <target state="translated">¿Cómo puedo comprobar si el archivo actual se está ejecutando como el guión principal?</target>
        </trans-unit>
        <trans-unit id="07f058f4bf96d455fe968f2d1e89bd25936e7928" translate="yes" xml:space="preserve">
          <source>How do I delete an object in memory?</source>
          <target state="translated">¿Cómo puedo borrar un objeto de la memoria?</target>
        </trans-unit>
        <trans-unit id="b215618760cff9b8483504445b91edb71bee5871" translate="yes" xml:space="preserve">
          <source>How do I pass options to &lt;code&gt;julia&lt;/code&gt; using &lt;code&gt;#!/usr/bin/env&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo le paso opciones a &lt;code&gt;julia&lt;/code&gt; usando &lt;code&gt;#!/usr/bin/env&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="eb9157ff1fb18352038c8a12eae2a15bbdb246dd" translate="yes" xml:space="preserve">
          <source>How does &quot;null&quot;, &quot;nothingness&quot; or &quot;missingness&quot; work in Julia?</source>
          <target state="translated">¿Cómo funciona &quot;nulo&quot;,&quot;nada&quot; o &quot;falta&quot; en Julia?</target>
        </trans-unit>
        <trans-unit id="fd885280d6cbd9f996932c72e9d360397c1bf016" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo se construye un objeto &lt;code&gt;Point&lt;/code&gt; ? Es posible definir constructores personalizados para tipos compuestos, que se discutir&amp;aacute;n en detalle en &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructores&lt;/a&gt; , pero en ausencia de declaraciones especiales de constructor, hay dos formas predeterminadas de crear nuevos objetos compuestos, una en la que los par&amp;aacute;metros de tipo se dan expl&amp;iacute;citamente y el otro en el que est&amp;aacute;n impl&amp;iacute;citos en los argumentos del constructor del objeto.</target>
        </trans-unit>
        <trans-unit id="06e308a7a0638232b6f09929d443c3620a3b020e" translate="yes" xml:space="preserve">
          <source>How these arguments are initialized depends on the &quot;outer&quot; function; here, &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; will sequentially set &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, calling the anonymous function on each, just as would happen in the syntax &lt;code&gt;map(func, [A, B, C])&lt;/code&gt;.</source>
          <target state="translated">La forma en que se inicializan estos argumentos depende de la funci&amp;oacute;n &quot;externa&quot;; aqu&amp;iacute;, &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; establecer&amp;aacute; secuencialmente &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; , llamando a la funci&amp;oacute;n an&amp;oacute;nima en cada uno, tal como suceder&amp;iacute;a en el &lt;code&gt;map(func, [A, B, C])&lt;/code&gt; sintaxis (func, [A, B, C]) .</target>
        </trans-unit>
        <trans-unit id="eaf97b67896b3cc13483847a79f98eac92d8c7ad" translate="yes" xml:space="preserve">
          <source>How you use this information is up to you. Obviously, it would be far and away best to fix &lt;code&gt;pos&lt;/code&gt; to be type-stable: if you did so, all of the variables in &lt;code&gt;f&lt;/code&gt; would be concrete, and its performance would be optimal. However, there are circumstances where this kind of &lt;em&gt;ephemeral&lt;/em&gt; type instability might not matter too much: for example, if &lt;code&gt;pos&lt;/code&gt; is never used in isolation, the fact that &lt;code&gt;f&lt;/code&gt;'s output is type-stable (for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the &quot;damage&quot; from type instability. Also, note that even Julia Base has functions that are type unstable. For example, the function &lt;code&gt;findfirst&lt;/code&gt; returns the index into an array where a key is found, or &lt;code&gt;nothing&lt;/code&gt; if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, &lt;code&gt;Union&lt;/code&gt;s containing either &lt;code&gt;missing&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; are color highlighted in yellow, instead of red.</source>
          <target state="translated">La forma en que utilice esta informaci&amp;oacute;n depende de usted. Obviamente, ser&amp;iacute;a mucho mejor arreglar &lt;code&gt;pos&lt;/code&gt; para que sea de tipo estable: si lo hiciera, todas las variables en &lt;code&gt;f&lt;/code&gt; ser&amp;iacute;an concretas y su rendimiento ser&amp;iacute;a &amp;oacute;ptimo. Sin embargo, hay circunstancias en las que este tipo de inestabilidad de tipo &lt;em&gt;ef&amp;iacute;mero&lt;/em&gt; podr&amp;iacute;a no importar demasiado: por ejemplo, si &lt;code&gt;pos&lt;/code&gt; nunca se usa de forma aislada, el hecho de que la salida de &lt;code&gt;f&lt;/code&gt; sea ​​estable en &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; (para Float64entradas) proteger&amp;aacute; el c&amp;oacute;digo posterior de los efectos de propagaci&amp;oacute;n de la inestabilidad de tipo. Esto es particularmente relevante en los casos en los que corregir la inestabilidad del tipo es dif&amp;iacute;cil o imposible. En tales casos, los consejos anteriores (por ejemplo, agregar anotaciones de tipo y / o dividir funciones) son sus mejores herramientas para contener el &quot;da&amp;ntilde;o&quot; de la inestabilidad de tipo. Adem&amp;aacute;s, tenga en cuenta que incluso Julia Base tiene funciones de tipo inestable. Por ejemplo, la funci&amp;oacute;n &lt;code&gt;findfirst&lt;/code&gt; devuelve el &amp;iacute;ndice a una matriz donde se encuentra una clave, o &lt;code&gt;nothing&lt;/code&gt; si no se encuentra, una inestabilidad de tipo clara. Para que sea m&amp;aacute;s f&amp;aacute;cil encontrar el tipo de inestabilidades que probablemente sean importantes, &lt;code&gt;Union&lt;/code&gt; s que contenga &lt;code&gt;missing&lt;/code&gt; o &lt;code&gt;nothing&lt;/code&gt; son de color resaltado en amarillo, en lugar de rojo.</target>
        </trans-unit>
        <trans-unit id="042ec23eb15357af1265112d56deb61892b131f1" translate="yes" xml:space="preserve">
          <source>However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:</source>
          <target state="translated">Sin embargo,hay que tener en cuenta que el despacho de macros se basa en los tipos de AST que se entregan a la macro,no en los tipos que la AST evalúa en tiempo de ejecución:</target>
        </trans-unit>
        <trans-unit id="ec8145ef611e8eb6adb7aa2875037ca9cf5cb809" translate="yes" xml:space="preserve">
          <source>However, all the information we need for the loop is embedded in the type information of the arguments. Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an &lt;em&gt;expression&lt;/em&gt; that calculates the index:</source>
          <target state="translated">Sin embargo, toda la informaci&amp;oacute;n que necesitamos para el ciclo est&amp;aacute; incrustada en la informaci&amp;oacute;n de tipo de los argumentos. Por lo tanto, podemos utilizar funciones generadas para mover la iteraci&amp;oacute;n al tiempo de compilaci&amp;oacute;n; en el lenguaje del compilador, usamos funciones generadas para desenrollar manualmente el ciclo. El cuerpo se vuelve casi id&amp;eacute;ntico, pero en lugar de calcular el &amp;iacute;ndice lineal, creamos una &lt;em&gt;expresi&amp;oacute;n&lt;/em&gt; que calcula el &amp;iacute;ndice:</target>
        </trans-unit>
        <trans-unit id="42e7ab564618248599a98b48397f91d9696cc5fd" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</source>
          <target state="translated">Sin embargo,hacer esto también será muy lento y perderá la memoria,por lo que normalmente debe evitarlo y en su lugar seguir leyendo.La siguiente sección trata sobre cómo utilizar las llamadas indirectas para lograr un efecto similar de manera eficiente.</target>
        </trans-unit>
        <trans-unit id="1f4c1ec1ac04c3b7530d92971ca6fe0a67c59d9d" translate="yes" xml:space="preserve">
          <source>However, for mutable objects the warning is printed as expected:</source>
          <target state="translated">Sin embargo,para los objetos mutables la advertencia se imprime como se esperaba:</target>
        </trans-unit>
        <trans-unit id="2b94a9c2374adeaf4e451f1d8f8dbbec3cf93bf0" translate="yes" xml:space="preserve">
          <source>However, future calls to &lt;code&gt;tryeval&lt;/code&gt; will continue to see the definition of &lt;code&gt;newfun&lt;/code&gt; as it was &lt;em&gt;at the previous statement at the REPL&lt;/em&gt;, and thus before that call to &lt;code&gt;tryeval&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, las futuras llamadas a &lt;code&gt;tryeval&lt;/code&gt; seguir&amp;aacute;n viendo la definici&amp;oacute;n de &lt;code&gt;newfun&lt;/code&gt; como estaba &lt;em&gt;en la declaraci&amp;oacute;n anterior en el REPL&lt;/em&gt; y, por lo tanto, antes de esa llamada a &lt;code&gt;tryeval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96a28d68e1fc2327784959f0995bfa65f1bc559d" translate="yes" xml:space="preserve">
          <source>However, if needed you can specialize on any or all of these arguments. The final argument &lt;code&gt;bc&lt;/code&gt; is a lazy representation of a (potentially fused) broadcast operation, a &lt;code&gt;Broadcasted&lt;/code&gt; object. For these purposes, the most important fields of the wrapper are &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, describing the function and argument list, respectively. Note that the argument list can &amp;mdash; and often does &amp;mdash; include other nested &lt;code&gt;Broadcasted&lt;/code&gt; wrappers.</source>
          <target state="translated">Sin embargo, si es necesario, puede especializarse en alguno o todos estos argumentos. El argumento final &lt;code&gt;bc&lt;/code&gt; es una representaci&amp;oacute;n perezosa de una operaci&amp;oacute;n de transmisi&amp;oacute;n (potencialmente fusionada), un objeto &lt;code&gt;Broadcasted&lt;/code&gt; . A estos efectos, los campos m&amp;aacute;s importantes de la envoltura son &lt;code&gt;f&lt;/code&gt; y &lt;code&gt;args&lt;/code&gt; , que describe la lista de funciones y argumentos, respectivamente. Tenga en cuenta que la lista de argumentos puede incluir, y a menudo lo hace, otras envolturas de &lt;code&gt;Broadcasted&lt;/code&gt; anidadas .</target>
        </trans-unit>
        <trans-unit id="a1a03264a4e905ebd619a9b03ec0d4363bf201f9" translate="yes" xml:space="preserve">
          <source>However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:</source>
          <target state="translated">Sin embargo,si intentas redefinir una constante incorporada o una función ya en uso,Julia te dará un error:</target>
        </trans-unit>
        <trans-unit id="b612aa5b83e1e5e4f183ec87a4a8051d812c4982" translate="yes" xml:space="preserve">
          <source>However, it is not hard to construct cases where this will fail:</source>
          <target state="translated">Sin embargo,no es difícil construir casos en los que esto fallará:</target>
        </trans-unit>
        <trans-unit id="f588e867dce1639bbbc3e181485bd13a34f96de5" translate="yes" xml:space="preserve">
          <source>However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done conveniently by adding the keyword &lt;code&gt;outer&lt;/code&gt;:</source>
          <target state="translated">Sin embargo, en ocasiones es &amp;uacute;til reutilizar una variable local existente como variable de iteraci&amp;oacute;n. Esto se puede hacer convenientemente agregando la palabra clave &lt;code&gt;outer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3fc16da92345edab485c9b8587412c5e7cbbb69" translate="yes" xml:space="preserve">
          <source>However, it's still possible, for instance, to send a &lt;code&gt;MyType&lt;/code&gt; to a process which has loaded &lt;code&gt;DummyModule&lt;/code&gt; even if it's not in scope:</source>
          <target state="translated">Sin embargo, todav&amp;iacute;a es posible, por ejemplo, enviar un &lt;code&gt;MyType&lt;/code&gt; a un proceso que ha cargado &lt;code&gt;DummyModule&lt;/code&gt; incluso si no est&amp;aacute; dentro del alcance:</target>
        </trans-unit>
        <trans-unit id="0206b7f024c599046b1522c22d104a0f2b4ea5b8" translate="yes" xml:space="preserve">
          <source>However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called &lt;code&gt;array3&lt;/code&gt; from a function like this:</source>
          <target state="translated">Sin embargo, hacer uso de estas t&amp;eacute;cnicas puede resultar sorprendentemente sutil. Por ejemplo, no ser&amp;iacute;a de ayuda si &lt;code&gt;array3&lt;/code&gt; a array3 desde una funci&amp;oacute;n como esta:</target>
        </trans-unit>
        <trans-unit id="1ad09b70c7675ac7974cd81421e0b196fa34837e" translate="yes" xml:space="preserve">
          <source>However, other similar calls still don't work:</source>
          <target state="translated">Sin embargo,otras llamadas similares todavía no funcionan:</target>
        </trans-unit>
        <trans-unit id="d6c01a830ee4c6c4b08c6d0fd04973c57ba502a5" translate="yes" xml:space="preserve">
          <source>However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use &lt;code&gt;llvmcall&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, dado que no se puede confiar en la vectorizaci&amp;oacute;n autom&amp;aacute;tica, el uso futuro ser&amp;aacute; principalmente a trav&amp;eacute;s de bibliotecas que usan &lt;code&gt;llvmcall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a9c9e751e43cb6eaac4e5372d46543dc59ec370" translate="yes" xml:space="preserve">
          <source>However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:</source>
          <target state="translated">Sin embargo,como esto es un poco engorroso,se ofrecen varios métodos de conveniencia.Por ejemplo,podríamos haber escrito lo anterior como:</target>
        </trans-unit>
        <trans-unit id="4963644e11f9a07fc917ac8319ecfbd548bbe63b" translate="yes" xml:space="preserve">
          <source>However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. The first is to use an absolute path, for example &lt;code&gt;using Base.Sort&lt;/code&gt;. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:</source>
          <target state="translated">Sin embargo, algunos m&amp;oacute;dulos contienen subm&amp;oacute;dulos, lo que significa que a veces es necesario acceder a un m&amp;oacute;dulo que no es de nivel superior. Hay dos maneras de hacer esto. La primera es usar una ruta absoluta, por ejemplo, &lt;code&gt;using Base.Sort&lt;/code&gt; . El segundo es usar una ruta relativa, lo que facilita la importaci&amp;oacute;n de subm&amp;oacute;dulos del m&amp;oacute;dulo actual o cualquiera de sus m&amp;oacute;dulos adjuntos:</target>
        </trans-unit>
        <trans-unit id="788054e244adc6c2716171e1c63990c4810a9000" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, a veces tiene sentido mantener la primera letra may&amp;uacute;scula, por ejemplo, si un argumento para una funci&amp;oacute;n es una letra may&amp;uacute;scula: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="734c2f5135f1e869aae040511570811afbc769c7" translate="yes" xml:space="preserve">
          <source>However, the outer &lt;code&gt;quote&lt;/code&gt; expression is able to interpolate values inside the &lt;code&gt;$&lt;/code&gt; in the inner quote. This is done with multiple &lt;code&gt;$&lt;/code&gt;s:</source>
          <target state="translated">Sin embargo, la expresi&amp;oacute;n de &lt;code&gt;quote&lt;/code&gt; externas puede interpolar valores dentro de &lt;code&gt;$&lt;/code&gt; en la comilla interna. Esto se hace con varios &lt;code&gt;$&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="a78965b80768b2188b4d959fddb093f72b6aa627" translate="yes" xml:space="preserve">
          <source>However, there are cases where you may need to declare different versions of the outer function for different element types or types of the &lt;code&gt;AbstractVector&lt;/code&gt; of the field &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;MySimpleContainer&lt;/code&gt;. You could do it like this:</source>
          <target state="translated">Sin embargo, hay casos en los que es posible que deba declarar diferentes versiones de la funci&amp;oacute;n externa para diferentes tipos de elementos o tipos de &lt;code&gt;AbstractVector&lt;/code&gt; del campo &lt;code&gt;a&lt;/code&gt; en &lt;code&gt;MySimpleContainer&lt;/code&gt; . Podr&amp;iacute;as hacerlo as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="3975391f531616484a0e31ee77d8e0e00f61fa9e" translate="yes" xml:space="preserve">
          <source>However, there are three key differences:</source>
          <target state="translated">Sin embargo,hay tres diferencias clave:</target>
        </trans-unit>
        <trans-unit id="f5c45c8616fbe8c99fd70a67651ffd25fb8f16b8" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;not&lt;/em&gt; recommended. Instead, use the more efficient &lt;code&gt;complex&lt;/code&gt; function to construct a complex value directly from its real and imaginary parts:</source>
          <target state="translated">Sin embargo, esto &lt;em&gt;no se&lt;/em&gt; recomienda. En su lugar, use la funci&amp;oacute;n &lt;code&gt;complex&lt;/code&gt; m&amp;aacute;s eficiente para construir un valor complejo directamente a partir de sus partes real e imaginaria:</target>
        </trans-unit>
        <trans-unit id="a2261e024bded1ce38fa0b00996da87c5f69ba9d" translate="yes" xml:space="preserve">
          <source>However, type promotion between the primitive types above and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; is not automatic and must be explicitly stated.</source>
          <target state="translated">Sin embargo, la promoci&amp;oacute;n de tipos entre los tipos primitivos anteriores y &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; no es autom&amp;aacute;tica y debe indicarse expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="a17c41ad2e8a1887210e57ce0ca80b0a2e7e175c" translate="yes" xml:space="preserve">
          <source>However, we don't do this for a good reason: wrapping the &lt;code&gt;expr&lt;/code&gt; in a new scope block (the anonymous function) also slightly changes the meaning of the expression (the scope of any variables in it), while we want &lt;code&gt;@time&lt;/code&gt; to be usable with minimum impact on the wrapped code.</source>
          <target state="translated">Sin embargo, no hacemos esto por una buena raz&amp;oacute;n: envolver la &lt;code&gt;expr&lt;/code&gt; en un nuevo bloque de alcance (la funci&amp;oacute;n an&amp;oacute;nima) tambi&amp;eacute;n cambia ligeramente el significado de la expresi&amp;oacute;n (el alcance de cualquier variable en ella), mientras que nosotros queremos &lt;code&gt;@time&lt;/code&gt; a ser utilizable con un impacto m&amp;iacute;nimo en el c&amp;oacute;digo envuelto.</target>
        </trans-unit>
        <trans-unit id="0b0f70feaa3a28d45e6f3a13fc1f48acf2f37d7c" translate="yes" xml:space="preserve">
          <source>However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type. For example, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; is valid, since &lt;code&gt;Ptr&lt;/code&gt; is always a word-size primitive type. But, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; is not valid, since the type layout of &lt;code&gt;T&lt;/code&gt; is not known statically.</source>
          <target state="translated">Sin embargo, aunque el dise&amp;ntilde;o de tipos debe conocerse est&amp;aacute;ticamente para calcular el C ABI previsto, los par&amp;aacute;metros est&amp;aacute;ticos de la funci&amp;oacute;n se consideran parte de este entorno est&amp;aacute;tico. Los par&amp;aacute;metros est&amp;aacute;ticos de la funci&amp;oacute;n se pueden usar como par&amp;aacute;metros de tipo en la firma de la llamada, siempre que no afecten el dise&amp;ntilde;o del tipo. Por ejemplo, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; es v&amp;aacute;lido, ya que &lt;code&gt;Ptr&lt;/code&gt; es siempre un tipo primitivo del tama&amp;ntilde;o de una palabra. Pero, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; no es v&amp;aacute;lido, ya que el dise&amp;ntilde;o de tipos de &lt;code&gt;T&lt;/code&gt; no se conoce est&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="50d668f1d842d230950802dd8f5eb4d3254c4568" translate="yes" xml:space="preserve">
          <source>Hundred Points Symbol</source>
          <target state="translated">Símbolo de los cien puntos</target>
        </trans-unit>
        <trans-unit id="fdd59db74c581af271b7941aa03e44ed5fe0b191" translate="yes" xml:space="preserve">
          <source>Hushed Face</source>
          <target state="translated">Cara callada</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="9dfda2b4e8d2ebd709351cb5956b33e0e4ffe363" translate="yes" xml:space="preserve">
          <source>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, &lt;em&gt;The American Statistician&lt;/em&gt;, Vol. 50, No. 4, pp. 361-365</source>
          <target state="translated">Hyndman, RJ y Fan, Y. (1996) &quot;Muestra cuantiles en paquetes estad&amp;iacute;sticos&quot;, &lt;em&gt;The American Statistician&lt;/em&gt; , vol. 50, n&amp;uacute;m. 4, p&amp;aacute;gs. 361-365</target>
        </trans-unit>
        <trans-unit id="cde96ad42b76d0bdd741afbb558f7a3b372bce7e" translate="yes" xml:space="preserve">
          <source>I (interval)</source>
          <target state="translated">I (intervalo)</target>
        </trans-unit>
        <trans-unit id="1f1b2f73366cab7e556f4c5764548bfeee9e55d4" translate="yes" xml:space="preserve">
          <source>I passed an argument &lt;code&gt;x&lt;/code&gt; to a function, modified it inside that function, but on the outside, the variable &lt;code&gt;x&lt;/code&gt; is still unchanged. Why?</source>
          <target state="translated">Pas&amp;eacute; un argumento &lt;code&gt;x&lt;/code&gt; a una funci&amp;oacute;n, lo modifiqu&amp;eacute; dentro de esa funci&amp;oacute;n, pero en el exterior, la variable &lt;code&gt;x&lt;/code&gt; sigue sin cambios. &amp;iquest;Por qu&amp;eacute;?</target>
        </trans-unit>
        <trans-unit id="f6d15c9cfe8c2c69adbb304be5e27663dff93f96" translate="yes" xml:space="preserve">
          <source>I.e. the value returned by &lt;code&gt;codeunit(s, i)&lt;/code&gt; is of the type returned by &lt;code&gt;codeunit(s)&lt;/code&gt;.</source>
          <target state="translated">Es decir, el valor devuelto por &lt;code&gt;codeunit(s, i)&lt;/code&gt; es del tipo devuelto por &lt;code&gt;codeunit(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cf18e3da9119216f8e328e30538193a84b6a06e" translate="yes" xml:space="preserve">
          <source>I/O and Network</source>
          <target state="translated">I/O y Red</target>
        </trans-unit>
        <trans-unit id="f202b270f0bf2c3423308846f107faa93c51a606" translate="yes" xml:space="preserve">
          <source>ID of the device that contains the file</source>
          <target state="translated">La identificación del dispositivo que contiene el archivo</target>
        </trans-unit>
        <trans-unit id="f9c4d94c8313e5f3e388b78d066d32450a104438" translate="yes" xml:space="preserve">
          <source>IO Output Contextual Properties</source>
          <target state="translated">Propiedades contextuales de salida de IO</target>
        </trans-unit>
        <trans-unit id="197f5eacc88f8f1df449bfc2c0077d2d00ba82c7" translate="yes" xml:space="preserve">
          <source>IO redirection can be accomplished by passing keyword arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; to the &lt;code&gt;pipeline&lt;/code&gt; function:</source>
          <target state="translated">La redirecci&amp;oacute;n de E / S se puede lograr pasando argumentos de palabras clave &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; y &lt;code&gt;stderr&lt;/code&gt; a la funci&amp;oacute;n de &lt;code&gt;pipeline&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="01d2fc4baf23050afed6538bf5b3afda200aec20" translate="yes" xml:space="preserve">
          <source>IOBuffer</source>
          <target state="translated">IOBuffer</target>
        </trans-unit>
        <trans-unit id="1e240958856813e40093848d027d47dc30e4009a" translate="yes" xml:space="preserve">
          <source>IOContext</source>
          <target state="translated">IOContext</target>
        </trans-unit>
        <trans-unit id="29093ff8b21b1b330d3e6699a2ad82a180dd947e" translate="yes" xml:space="preserve">
          <source>IOContext()</source>
          <target state="translated">IOContext()</target>
        </trans-unit>
        <trans-unit id="3afa239559b1455a86cd4aafab53cb6dd69792c0" translate="yes" xml:space="preserve">
          <source>IOStream</source>
          <target state="translated">IOStream</target>
        </trans-unit>
        <trans-unit id="8d31d2211f88e51d4dac04058ee63fd1f5837600" translate="yes" xml:space="preserve">
          <source>Ice Cream</source>
          <target state="translated">Helado</target>
        </trans-unit>
        <trans-unit id="2b3a1ae210dbbbf1609a9fd75685f6380218b075" translate="yes" xml:space="preserve">
          <source>IdDict</source>
          <target state="translated">IdDict</target>
        </trans-unit>
        <trans-unit id="898cecd14809e1e6d2d6a1ad03f40fe8f8898ff9" translate="yes" xml:space="preserve">
          <source>Identical To</source>
          <target state="translated">Idéntico a</target>
        </trans-unit>
        <trans-unit id="c539ce4823e892243cf1d72e5cda29852ab1bb48" translate="yes" xml:space="preserve">
          <source>Identical To And Slanted Parallel</source>
          <target state="translated">Idéntico y paralelo inclinado</target>
        </trans-unit>
        <trans-unit id="44763ae8a5457dbe6219995560f8ceac0b654107" translate="yes" xml:space="preserve">
          <source>Identical With Dot Above</source>
          <target state="translated">Idéntico al punto anterior</target>
        </trans-unit>
        <trans-unit id="49f0f00de3919e6aa513f490a486fcbae4d4df50" translate="yes" xml:space="preserve">
          <source>If $n$ is negative, then it is defined in terms of the identity</source>
          <target state="translated">Si $n$ es negativo,entonces se define en términos de la identidad</target>
        </trans-unit>
        <trans-unit id="4ed2889e692f7a726f27cb34a6abbc329da52fe8" translate="yes" xml:space="preserve">
          <source>If $n$ is non-negative, then it is the number of ways to choose &lt;code&gt;k&lt;/code&gt; out of &lt;code&gt;n&lt;/code&gt; items:</source>
          <target state="translated">Si $ n $ no es negativo, entonces es el n&amp;uacute;mero de formas de elegir &lt;code&gt;k&lt;/code&gt; de &lt;code&gt;n&lt;/code&gt; elementos:</target>
        </trans-unit>
        <trans-unit id="21a045b4d60526617fd3c07b9d46739e69a41cdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalue, compute the principal matrix logarithm of &lt;code&gt;A&lt;/code&gt;, i.e. the unique matrix $X$ such that $e^X = A$ and $-\pi &amp;lt; Im(\lambda) &amp;lt; \pi$ for all the eigenvalues $\lambda$ of $X$. If &lt;code&gt;A&lt;/code&gt; has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; no tiene un valor propio real negativo, calcule el logaritmo de la matriz principal de &lt;code&gt;A&lt;/code&gt; , es decir, la matriz &amp;uacute;nica $ X $ tal que $ e ^ X = A $ y $ - \ pi &amp;lt;Im (\ lambda) &amp;lt;\ pi $ para todos los valores propios $ \ lambda $ de $ X $. Si &lt;code&gt;A&lt;/code&gt; tiene valores propios no positivos, se devuelve una funci&amp;oacute;n matricial no principal siempre que sea posible.</target>
        </trans-unit>
        <trans-unit id="7259d98627a04b894a1123257649b9b0e506f9f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalues, compute the principal matrix square root of &lt;code&gt;A&lt;/code&gt;, that is the unique matrix $X$ with eigenvalues having positive real part such that $X^2 = A$. Otherwise, a nonprincipal square root is returned.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; no tiene valores propios reales negativos, calcule la ra&amp;iacute;z cuadrada de la matriz principal de &lt;code&gt;A&lt;/code&gt; , que es la matriz &amp;uacute;nica $ X $ con valores propios que tienen una parte real positiva tal que $ X ^ 2 = A $. De lo contrario, se devuelve una ra&amp;iacute;z cuadrada no principal.</target>
        </trans-unit>
        <trans-unit id="19b01775b8b82ce68d3f6a6f522f474a638dda03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the cosine. Otherwise, the cosine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su autodescomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular el coseno. De lo contrario, el coseno se determina llamando a &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acf6a44af56176e5053aa08ad7d4eea1a7727bea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su autodescomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular el coseno inverso. De lo contrario, el coseno inverso se determina mediante &lt;code&gt;log&lt;/code&gt; y &lt;code&gt;sqrt&lt;/code&gt; . Para conocer la teor&amp;iacute;a y las f&amp;oacute;rmulas logar&amp;iacute;tmicas utilizadas para calcular esta funci&amp;oacute;n, consulte &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbfce79aa807e6b2cb49ddfffb2847f191045922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su autodescomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular el seno inverso. De lo contrario, el seno inverso se determina mediante &lt;code&gt;log&lt;/code&gt; y &lt;code&gt;sqrt&lt;/code&gt; . Para conocer la teor&amp;iacute;a y las f&amp;oacute;rmulas logar&amp;iacute;tmicas utilizadas para calcular esta funci&amp;oacute;n, consulte &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2646487106f321c98004368d4fc3670f47b0a86e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su descomposici&amp;oacute;n propia ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular la tangente inversa. De lo contrario, la tangente inversa se determina mediante &lt;code&gt;log&lt;/code&gt; . Para conocer la teor&amp;iacute;a y las f&amp;oacute;rmulas logar&amp;iacute;tmicas utilizadas para calcular esta funci&amp;oacute;n, consulte &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="317ce8e704df5d75a6762d7ee94cb8590a0eeb84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the sine. Otherwise, the sine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su autodescomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular el seno. De lo contrario, el seno se determina llamando a &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f03ca25824d588274952404db5eb47ba9feeba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. Otherwise, the square root is determined by means of the Bj&amp;ouml;rck-Hammarling method &lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt;, which computes the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) and then the complex square root of the triangular factor.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su descomposici&amp;oacute;n propia ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se utiliza para calcular la ra&amp;iacute;z cuadrada. De lo contrario, la ra&amp;iacute;z cuadrada se determina mediante el m&amp;eacute;todo de Bj&amp;ouml;rck-Hammarling &lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt; , que calcula la forma compleja de Schur ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; ) y luego la ra&amp;iacute;z cuadrada compleja del factor triangular.</target>
        </trans-unit>
        <trans-unit id="da6d9fe794edc15bdf1db668291afd8d8cb893d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the tangent. Otherwise, the tangent is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su autodescomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular la tangente. De lo contrario, la tangente se determina llamando a &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e82ebcef54c304de01d1461f11b56325e46b2234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; and &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, se utiliza su autodecomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ), si &lt;code&gt;A&lt;/code&gt; es triangular se emplea una versi&amp;oacute;n mejorada del m&amp;eacute;todo inverso de escalado y cuadrado (ver &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; y &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt; ). Para matrices generales, se calcula la forma compleja de Schur ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; ) y se usa el algoritmo triangular en el factor triangular.</target>
        </trans-unit>
        <trans-unit id="31effe06eb8010b919cfa614d0573384a4c26bdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DataType&lt;/code&gt;&lt;code&gt;T&lt;/code&gt; does not have a specific size, an error is thrown.</source>
          <target state="translated">Si &lt;code&gt;DataType&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; no tiene un tama&amp;ntilde;o espec&amp;iacute;fico, se produce un error.</target>
        </trans-unit>
        <trans-unit id="70ac2f54db074364d37a4067713ee52ebafa3e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I_1&lt;/code&gt; is changed to a two-dimensional matrix, then &lt;code&gt;X&lt;/code&gt; becomes an &lt;code&gt;n+1&lt;/code&gt;-dimensional array of shape &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt;. The matrix adds a dimension.</source>
          <target state="translated">Si &lt;code&gt;I_1&lt;/code&gt; se cambia a una matriz bidimensional, entonces &lt;code&gt;X&lt;/code&gt; se convierte en una matriz &lt;code&gt;n+1&lt;/code&gt; - dimensional de forma &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt; . La matriz agrega una dimensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="20d018b41d67fa72dfd3dd7eab414a34042d26fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;, then the memory is assumed to contain a reference to a Julia object (a &lt;code&gt;jl_value_t*&lt;/code&gt;), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector. If the &lt;code&gt;Ptr&lt;/code&gt; itself is actually a &lt;code&gt;jl_value_t*&lt;/code&gt;, it can be converted back to a Julia object reference by &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt;&lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt;&lt;/a&gt;. (Julia values &lt;code&gt;v&lt;/code&gt; can be converted to &lt;code&gt;jl_value_t*&lt;/code&gt; pointers, as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, by calling &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt;&lt;code&gt;pointer_from_objref(v)&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Any&lt;/code&gt; , entonces se supone que la memoria contiene una referencia a un objeto de Julia (un &lt;code&gt;jl_value_t*&lt;/code&gt; ), el resultado ser&amp;aacute; una referencia a este objeto y el objeto no se copiar&amp;aacute;. Debe tener cuidado en este caso para asegurarse de que el objeto siempre est&amp;eacute; visible para el recolector de basura (los punteros no cuentan, pero la nueva referencia s&amp;iacute;) para asegurarse de que la memoria no se libere prematuramente. Tenga en cuenta que si el objeto no fue asignado originalmente por Julia, el recolector de basura de Julia nunca finalizar&amp;aacute; el nuevo objeto. Si el &lt;code&gt;Ptr&lt;/code&gt; en s&amp;iacute; es en realidad un &lt;code&gt;jl_value_t*&lt;/code&gt; , puede volver a convertirse en una referencia de objeto de Julia mediante &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt; &lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt; &lt;/a&gt; . (Julia valora &lt;code&gt;v&lt;/code&gt; se puede convertir en punteros &lt;code&gt;jl_value_t*&lt;/code&gt; , como &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; , llamando a &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt; &lt;code&gt;pointer_from_objref(v)&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="51788d4fcfdfd4d39c958952b0bc0324310a6a5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; type, then it will return the closest value to &lt;code&gt;x&lt;/code&gt; representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; tipo, entonces se devuelve el valor m&amp;aacute;s cercano a &lt;code&gt;x&lt;/code&gt; representable por &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedc994cd3fc0835ff4382a890fe92f16cb71d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a collection type and &lt;code&gt;x&lt;/code&gt; a collection, the result of &lt;code&gt;convert(T, x)&lt;/code&gt; may alias all or part of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de colecci&amp;oacute;n &lt;code&gt;x&lt;/code&gt; una colecci&amp;oacute;n, el resultado de &lt;code&gt;convert(T, x)&lt;/code&gt; puede alias todo o parte de &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca5b35227b72b028ed45253536f1af95a0b6efba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de punto flotante, el resultado es el valor representable m&amp;aacute;s cercano, que podr&amp;iacute;a ser infinito positivo o negativo.</target>
        </trans-unit>
        <trans-unit id="4201a0a82cce066dea7c824bdf90b57c195e9972" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a numeric type, the result is an array of that type, with any non-numeric elements as &lt;code&gt;NaN&lt;/code&gt; for floating-point types, or zero. Other useful values of &lt;code&gt;T&lt;/code&gt; include &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;AbstractString&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo num&amp;eacute;rico, el resultado es una matriz de ese tipo, con cualquier elemento no num&amp;eacute;rico como &lt;code&gt;NaN&lt;/code&gt; para tipos de punto flotante, o cero. Otros valores &amp;uacute;tiles de &lt;code&gt;T&lt;/code&gt; incluyen &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;AbstractString&lt;/code&gt; y &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69fee994b4c0ef137b6453b3ceac4a68a22fb0fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; type, an &lt;a href=&quot;#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;, for example if &lt;code&gt;x&lt;/code&gt; is not integer-valued, or is outside the range supported by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; tipo, una &lt;a href=&quot;#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt; se elevar&amp;aacute; si &lt;code&gt;x&lt;/code&gt; no es representable por &lt;code&gt;T&lt;/code&gt; , por ejemplo, si &lt;code&gt;x&lt;/code&gt; no es valorada n&amp;uacute;mero entero-, o est&amp;aacute; fuera del rango soportado por &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c36ac776e4be839ff56e17825105904e00568128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integer type, an &lt;code&gt;InexactError&lt;/code&gt; is raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo entero, un &lt;code&gt;InexactError&lt;/code&gt; se eleva si &lt;code&gt;x&lt;/code&gt; no es representable por &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7762b87399cdbea094b67bb56bb79bce4032130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and but does &lt;em&gt;not&lt;/em&gt; have a top-level UUID entry, &lt;code&gt;uuid&lt;/code&gt; is a dummy UUID generated by hashing the canonical (real) path to &lt;code&gt;X/Project.toml&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;X/Project.toml&lt;/code&gt; existe pero &lt;em&gt;no&lt;/em&gt; tiene una entrada UUID de nivel superior, &lt;code&gt;uuid&lt;/code&gt; es un UUID ficticio generado mediante el hash de la ruta can&amp;oacute;nica (real) a &lt;code&gt;X/Project.toml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57feda5962ebeb025a02c2fc5115db7f5ee74658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and has a &lt;code&gt;uuid&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; is that value.</source>
          <target state="translated">Si &lt;code&gt;X/Project.toml&lt;/code&gt; existe y tiene una entrada &lt;code&gt;uuid&lt;/code&gt; , entonces &lt;code&gt;uuid&lt;/code&gt; es ese valor.</target>
        </trans-unit>
        <trans-unit id="6feb00535e98202cbe0e255e2cd1a8e59544d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, at most one &lt;code&gt;read&lt;/code&gt; call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the &lt;code&gt;all&lt;/code&gt; option.</source>
          <target state="translated">Si &lt;code&gt;all&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; (el valor predeterminado), esta funci&amp;oacute;n bloquear&amp;aacute; el intento repetido de leer todos los bytes solicitados, hasta que se produzca un error o el final del archivo. Si &lt;code&gt;all&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , se realiza como m&amp;aacute;ximo una llamada de &lt;code&gt;read&lt;/code&gt; y la cantidad de datos devueltos depende del dispositivo. Tenga en cuenta que no todos los tipos de transmisi&amp;oacute;n admiten la opci&amp;oacute;n de &lt;code&gt;all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3a53d050caeb89134ca9bb80d1091ff36a0cf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a power of 2 or 10, &lt;a href=&quot;#Base.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; should be used, as these will typically be faster and more accurate. For example,</source>
          <target state="translated">Si &lt;code&gt;b&lt;/code&gt; es una potencia de 2 o 10, debe usarse &lt;a href=&quot;#Base.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#Base.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; , ya que normalmente ser&amp;aacute;n m&amp;aacute;s r&amp;aacute;pidos y precisos. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="89b9fac160344d84b2e97547e3cbb9b2dd975a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_size&lt;/code&gt; is specified, the collection is processed in batch mode. &lt;code&gt;f&lt;/code&gt; must then be a function that must accept a &lt;code&gt;Vector&lt;/code&gt; of argument tuples and must return a vector of results. The input vector will have a length of &lt;code&gt;batch_size&lt;/code&gt; or less.</source>
          <target state="translated">Si se especifica &lt;code&gt;batch_size&lt;/code&gt; , la colecci&amp;oacute;n se procesa en modo batch. &lt;code&gt;f&lt;/code&gt; debe ser una funci&amp;oacute;n que debe aceptar un &lt;code&gt;Vector&lt;/code&gt; de tuplas de argumentos y debe devolver un vector de resultados. El vector de entrada tendr&amp;aacute; una longitud de &lt;code&gt;batch_size&lt;/code&gt; o menos.</target>
        </trans-unit>
        <trans-unit id="f2467dc77e236fb9b24d515beabeb30ab9b34314" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dims&lt;/code&gt; is a tuple, the order of the dimensions in &lt;code&gt;dims&lt;/code&gt; is relevant and specifies the linear order of the slices. E.g., if &lt;code&gt;A&lt;/code&gt; is three dimensional and &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(1, 2)&lt;/code&gt;, the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(2, 1)&lt;/code&gt; instead, the same slices will be taken, but the result order will be row-major instead.</source>
          <target state="translated">Si &lt;code&gt;dims&lt;/code&gt; es una tupla, el orden de las dimensiones en &lt;code&gt;dims&lt;/code&gt; es relevante y especifica el orden lineal de los cortes. Por ejemplo, si &lt;code&gt;A&lt;/code&gt; es tridimensional y &lt;code&gt;dims&lt;/code&gt; es &lt;code&gt;(1, 2)&lt;/code&gt; , los ordenamientos de las dos primeras dimensiones se reorganizan de manera que se clasifiquen los cortes (de la tercera dimensi&amp;oacute;n restante). Si &lt;code&gt;dims&lt;/code&gt; es &lt;code&gt;(2, 1)&lt;/code&gt; lugar, se tomar&amp;aacute;n los mismos cortes, pero el orden de resultado ser&amp;aacute; el de fila mayor.</target>
        </trans-unit>
        <trans-unit id="74fad15bfd2101b3b16f9ea74a15c93af724d1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dlm&lt;/code&gt; is omitted, it defaults to &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se omite &lt;code&gt;dlm&lt;/code&gt; , el valor predeterminado es &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d7429e0d71b847a07568d302028712dbaf31f03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factorize&lt;/code&gt; is called on a Hermitian positive-definite matrix, for instance, then &lt;code&gt;factorize&lt;/code&gt; will return a Cholesky factorization.</source>
          <target state="translated">Si se llama a &lt;code&gt;factorize&lt;/code&gt; en una matriz hermitiana positiva definida, por ejemplo, entonces &lt;code&gt;factorize&lt;/code&gt; devolver&amp;aacute; una factorizaci&amp;oacute;n de Cholesky.</target>
        </trans-unit>
        <trans-unit id="b7c73e768a4a1fc2665ff51aa066980c89d3ec1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;follow_symlinks=false&lt;/code&gt;, and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be created as a symbolic link. If &lt;code&gt;follow_symlinks=true&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be a copy of the file or directory &lt;code&gt;src&lt;/code&gt; refers to. Return &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;follow_symlinks=false&lt;/code&gt; y &lt;code&gt;src&lt;/code&gt; es un enlace simb&amp;oacute;lico, &lt;code&gt;dst&lt;/code&gt; se crear&amp;aacute; como un enlace simb&amp;oacute;lico. Si &lt;code&gt;follow_symlinks=true&lt;/code&gt; y &lt;code&gt;src&lt;/code&gt; es un enlace simb&amp;oacute;lico, &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; una copia del archivo o directorio al que se refiere &lt;code&gt;src&lt;/code&gt; . Regrese &lt;code&gt;dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fefe7c70552bb288eba8725570e0711eb9913bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;full = false&lt;/code&gt; (default), a &quot;thin&quot; SVD is returned. For a $M \times N$ matrix &lt;code&gt;A&lt;/code&gt;, in the full factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times M&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times N&lt;/code&gt;, while in the thin factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times K&lt;/code&gt;, where &lt;code&gt;K = \min(M,N)&lt;/code&gt; is the number of singular values.</source>
          <target state="translated">Si &lt;code&gt;full = false&lt;/code&gt; (predeterminado), se devuelve un SVD &quot;delgado&quot;. Para una matriz &lt;code&gt;A&lt;/code&gt; de $ M \ veces N $ , en la factorizaci&amp;oacute;n completa &lt;code&gt;U&lt;/code&gt; es &lt;code&gt;M \times M&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es &lt;code&gt;N \times N&lt;/code&gt; , mientras que en la factorizaci&amp;oacute;n delgada &lt;code&gt;U&lt;/code&gt; es &lt;code&gt;M \times K&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es &lt;code&gt;N \times K&lt;/code&gt; , donde &lt;code&gt;K = \min(M,N)&lt;/code&gt; es el n&amp;uacute;mero de valores singulares.</target>
        </trans-unit>
        <trans-unit id="e7087620ad88bc806c680dac427ffd57a67879dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fussy_sqrt&lt;/code&gt; is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:</source>
          <target state="translated">Si se llama a &lt;code&gt;fussy_sqrt&lt;/code&gt; con un valor negativo de otra funci&amp;oacute;n, en lugar de intentar continuar la ejecuci&amp;oacute;n de la funci&amp;oacute;n que llama, regresa inmediatamente, mostrando el mensaje de error en la sesi&amp;oacute;n interactiva:</target>
        </trans-unit>
        <trans-unit id="c19e0b85728fe9481b7abf51cbb032dc0e45287a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, these &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to the method bodies yielded by expanding the generators.</source>
          <target state="translated">Si &lt;code&gt;generated&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , las instancias de &lt;code&gt;CodeInfo&lt;/code&gt; devueltas corresponder&amp;aacute;n a implementaciones de reserva. Se produce un error si no existe una implementaci&amp;oacute;n alternativa. Si &lt;code&gt;generated&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , estas instancias de &lt;code&gt;CodeInfo&lt;/code&gt; corresponder&amp;aacute;n a los cuerpos del m&amp;eacute;todo generados al expandir los generadores.</target>
        </trans-unit>
        <trans-unit id="3b5b7e505ab23a5d0aa601628f61af1433ebc0f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;header&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the first row of data will be read as header and the tuple &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; is returned instead of only &lt;code&gt;data_cells&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;header&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , la primera fila de datos se leer&amp;aacute; como encabezado y se &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; la tupla (data_cells, header_cells) en lugar de solo &lt;code&gt;data_cells&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c950181a2a1658a2e38c89bd49475efe3e66e317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding code unit &lt;code&gt;i&lt;/code&gt; is part of. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return &lt;code&gt;i&lt;/code&gt;; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to 0 or &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; return &lt;code&gt;i&lt;/code&gt;. In all other cases throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;i&lt;/code&gt; est&amp;aacute; dentro de los l&amp;iacute;mites en &lt;code&gt;s&lt;/code&gt; , devuelve el &amp;iacute;ndice del inicio del car&amp;aacute;cter de cuya unidad de c&amp;oacute;digo de codificaci&amp;oacute;n &lt;code&gt;i&lt;/code&gt; es parte. En otras palabras, si &lt;code&gt;i&lt;/code&gt; es el comienzo de un car&amp;aacute;cter, devuelve &lt;code&gt;i&lt;/code&gt; ; si &lt;code&gt;i&lt;/code&gt; no es el comienzo de un car&amp;aacute;cter, rebobina hasta el comienzo de un car&amp;aacute;cter y devuelve ese &amp;iacute;ndice. Si &lt;code&gt;i&lt;/code&gt; es igual a 0 o &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; devuelve &lt;code&gt;i&lt;/code&gt; . En todos los dem&amp;aacute;s casos, lanza &lt;code&gt;BoundsError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed8634de2b332fe1583659d48b66208896196beb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts after index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the next character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, move forward until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt; return &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is in bounds but greater or equal to &lt;code&gt;lastindex(str)&lt;/code&gt; return &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;i&lt;/code&gt; est&amp;aacute; dentro de los l&amp;iacute;mites en &lt;code&gt;s&lt;/code&gt; , devuelve el &amp;iacute;ndice del inicio del car&amp;aacute;cter cuya codificaci&amp;oacute;n comienza despu&amp;eacute;s del &amp;iacute;ndice &lt;code&gt;i&lt;/code&gt; . En otras palabras, si &lt;code&gt;i&lt;/code&gt; es el comienzo de un car&amp;aacute;cter, devuelve el comienzo del siguiente car&amp;aacute;cter; si &lt;code&gt;i&lt;/code&gt; no es el comienzo de un car&amp;aacute;cter, avanza hasta el comienzo de un car&amp;aacute;cter y devuelve ese &amp;iacute;ndice. Si &lt;code&gt;i&lt;/code&gt; es igual a &lt;code&gt;0&lt;/code&gt; , devuelve &lt;code&gt;1&lt;/code&gt; . Si &lt;code&gt;i&lt;/code&gt; est&amp;aacute; dentro de los l&amp;iacute;mites pero es mayor o igual que &lt;code&gt;lastindex(str)&lt;/code&gt; devuelve &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; . De lo contrario, lanza &lt;code&gt;BoundsError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bcc465fac95b41229c6fb79ecf0d3dab69e75e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts before index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the previous character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;1&lt;/code&gt; return &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; return &lt;code&gt;lastindex(str)&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;i&lt;/code&gt; est&amp;aacute; dentro de los l&amp;iacute;mites en &lt;code&gt;s&lt;/code&gt; , devuelve el &amp;iacute;ndice del inicio del car&amp;aacute;cter cuya codificaci&amp;oacute;n comienza antes del &amp;iacute;ndice &lt;code&gt;i&lt;/code&gt; . En otras palabras, si &lt;code&gt;i&lt;/code&gt; es el comienzo de un car&amp;aacute;cter, devuelve el comienzo del car&amp;aacute;cter anterior; si &lt;code&gt;i&lt;/code&gt; no es el comienzo de un car&amp;aacute;cter, rebobina hasta el comienzo de un car&amp;aacute;cter y devuelve ese &amp;iacute;ndice. Si &lt;code&gt;i&lt;/code&gt; es igual a &lt;code&gt;1&lt;/code&gt; , devuelve &lt;code&gt;0&lt;/code&gt; . Si &lt;code&gt;i&lt;/code&gt; es igual a &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; devuelve &lt;code&gt;lastindex(str)&lt;/code&gt; . De lo contrario, lanza &lt;code&gt;BoundsError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cfff02ba2ab7ab8f47553333086d7d3b017d4eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is not specified, &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; are used to connect.</source>
          <target state="translated">Si no se especifica &lt;code&gt;io&lt;/code&gt; , se utilizan el &lt;code&gt;host&lt;/code&gt; y el &lt;code&gt;port&lt;/code&gt; para conectarse.</target>
        </trans-unit>
        <trans-unit id="675d2f45d06133423691ac8939a36ff3793bfbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.</source>
          <target state="translated">Si se especifica &lt;code&gt;io&lt;/code&gt; , se utiliza para leer la informaci&amp;oacute;n de host / puerto. Un trabajador de Julia imprime su direcci&amp;oacute;n de enlace y su puerto al inicio. Esto permite que los trabajadores de Julia escuchen en cualquier puerto libre disponible en lugar de requerir que los puertos de los trabajadores se configuren manualmente.</target>
        </trans-unit>
        <trans-unit id="23c03ff245d9cf669803a913ec063d9d852e916b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;irange&lt;/code&gt; is not &lt;code&gt;1:n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the dimension of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">Si &lt;code&gt;irange&lt;/code&gt; no es &lt;code&gt;1:n&lt;/code&gt; , donde &lt;code&gt;n&lt;/code&gt; es la dimensi&amp;oacute;n de &lt;code&gt;A&lt;/code&gt; , entonces la factorizaci&amp;oacute;n devuelta ser&amp;aacute; una factorizaci&amp;oacute;n &lt;em&gt;truncada&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="33bb6515a9488e11cd97387cfe2fdf0354f00b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isless(x, y)&lt;/code&gt; is defined, then so is &lt;code&gt;isless(y, x)&lt;/code&gt; and &lt;code&gt;isequal(x, y)&lt;/code&gt;, and exactly one of those three yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;isless(x, y)&lt;/code&gt; , entonces &lt;code&gt;isless(y, x)&lt;/code&gt; e &lt;code&gt;isequal(x, y)&lt;/code&gt; , y exactamente uno de esos tres da como resultado &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27bcd4132639e391333ba702df2bbfcfeb96c942" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if &lt;code&gt;itr&lt;/code&gt; contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the median of non-missing values.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; contiene &lt;code&gt;NaN&lt;/code&gt; o valores &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , el resultado tambi&amp;eacute;n es &lt;code&gt;NaN&lt;/code&gt; o &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; tiene prioridad si &lt;code&gt;itr&lt;/code&gt; contiene ambos). Usar la &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n de omitir &lt;code&gt;missing&lt;/code&gt; entradas y calcular la mediana de los valores no perdidos.</target>
        </trans-unit>
        <trans-unit id="c3e083f5fc9364992337e03964ee084acea5fae6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the mean of non-missing values.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; contiene &lt;code&gt;NaN&lt;/code&gt; o valores &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , el resultado tambi&amp;eacute;n es &lt;code&gt;NaN&lt;/code&gt; o &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; tiene prioridad si la matriz contiene ambos). Usar la &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n de omitir &lt;code&gt;missing&lt;/code&gt; entradas y calcular la media de los valores no perdidos.</target>
        </trans-unit>
        <trans-unit id="6474b35658d7c26eeead842892ada1aea0d886f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; es un &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; se pueden proporcionar para calcular la desviaci&amp;oacute;n est&amp;aacute;ndar sobre las dimensiones, y &lt;code&gt;m&lt;/code&gt; pueden contener medios para cada dimensi&amp;oacute;n de la &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51822a7fae2f9177cdbe8acba291b2ecbdaf5a84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;means&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; es un &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; se pueden proporcionar para calcular la desviaci&amp;oacute;n est&amp;aacute;ndar sobre las dimensiones, y &lt;code&gt;means&lt;/code&gt; pueden contener medios para cada dimensi&amp;oacute;n de &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faf5ec759432f757b892cc486fe0509d46288036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; es un &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; se pueden proporcionar para calcular la varianza sobre las dimensiones, y &lt;code&gt;m&lt;/code&gt; pueden contener medios para cada dimensi&amp;oacute;n de &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37d953297aa88c0f3bc07a3115b3b34627aebd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;mean&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; es un &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; se pueden proporcionar para calcular la varianza sobre las dimensiones, y &lt;code&gt;mean&lt;/code&gt; puede contener medios para cada dimensi&amp;oacute;n de &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c5a74c045541a90c529fb0859ca2583588298de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range (a &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt;&lt;code&gt;LinRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Si se proporcionan la &lt;code&gt;length&lt;/code&gt; y la &lt;code&gt;stop&lt;/code&gt; y el &lt;code&gt;step&lt;/code&gt; no, el tama&amp;ntilde;o del paso se calcular&amp;aacute; autom&amp;aacute;ticamente de manera que haya elementos espaciados linealmente de &lt;code&gt;length&lt;/code&gt; en el rango (un &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt; &lt;code&gt;LinRange&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0677161ec30784ce49b4b8aeda531d688c559665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pids&lt;/code&gt; is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, &lt;code&gt;localindices&lt;/code&gt; and &lt;code&gt;indexpids&lt;/code&gt; will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.</source>
          <target state="translated">Si &lt;code&gt;pids&lt;/code&gt; se especifica pids , la matriz compartida se mapear&amp;aacute; en todos los procesos del host actual, incluido el maestro. Pero, los &lt;code&gt;localindices&lt;/code&gt; y los &lt;code&gt;indexpids&lt;/code&gt; solo se referir&amp;aacute;n a procesos de trabajo. Esto facilita el c&amp;oacute;digo de distribuci&amp;oacute;n del trabajo para usar trabajadores para el c&amp;aacute;lculo real con el proceso maestro actuando como un controlador.</target>
        </trans-unit>
        <trans-unit id="39265b02d633cf948cee760fccd02e8e4c595e22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;quotes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, columns enclosed within double-quote (&quot;) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote. Specifying &lt;code&gt;dims&lt;/code&gt; as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files. If &lt;code&gt;comments&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lines beginning with &lt;code&gt;comment_char&lt;/code&gt; and text following &lt;code&gt;comment_char&lt;/code&gt; in any line are ignored.</source>
          <target state="translated">Si las &lt;code&gt;quotes&lt;/code&gt; son &lt;code&gt;true&lt;/code&gt; , las columnas encerradas entre comillas dobles (&quot;) pueden contener nuevas l&amp;iacute;neas y delimitadores de columna. Los caracteres de comillas dobles dentro de un campo entre comillas deben escaparse con otra comilla doble. Especificar &lt;code&gt;dims&lt;/code&gt; como una tupla de lo esperado las filas y columnas (incluido el encabezado, si lo hay) pueden acelerar la lectura de archivos grandes. Si los &lt;code&gt;comments&lt;/code&gt; son &lt;code&gt;true&lt;/code&gt; , las l&amp;iacute;neas que comienzan con &lt;code&gt;comment_char&lt;/code&gt; y el texto que sigue a &lt;code&gt;comment_char&lt;/code&gt; en cualquier l&amp;iacute;nea se ignoran.</target>
        </trans-unit>
        <trans-unit id="072d5e68fa14ef444211e0638bdf60961c940d9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reuseaddr=true&lt;/code&gt;, multiple threads or processes can bind to the same address without error if they all set &lt;code&gt;reuseaddr=true&lt;/code&gt;, but only the last to bind will receive any traffic.</source>
          <target state="translated">Si &lt;code&gt;reuseaddr=true&lt;/code&gt; , varios subprocesos o procesos pueden vincularse a la misma direcci&amp;oacute;n sin error si todos establecen &lt;code&gt;reuseaddr=true&lt;/code&gt; , pero solo el &amp;uacute;ltimo en vincularse recibir&amp;aacute; tr&amp;aacute;fico.</target>
        </trans-unit>
        <trans-unit id="5dd9d0433c4fe181d962946c85904ec68a57d1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rook&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, rook pivoting is used. If &lt;code&gt;rook&lt;/code&gt; is false, rook pivoting is not used.</source>
          <target state="translated">Si la &lt;code&gt;rook&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , se usa el pivote de torre. Si la &lt;code&gt;rook&lt;/code&gt; es falsa, no se usa el pivote de torre.</target>
        </trans-unit>
        <trans-unit id="3686d47af71436aa8068aa094e6acfdb577abbc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipblanks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, blank lines in the input will be ignored.</source>
          <target state="translated">Si &lt;code&gt;skipblanks&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , se ignorar&amp;aacute;n las l&amp;iacute;neas en blanco en la entrada.</target>
        </trans-unit>
        <trans-unit id="a5a873983f34f90f6f3366d1e91c3b5438a1e6c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced (a &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt;&lt;code&gt;StepRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Si se proporcionan &lt;code&gt;step&lt;/code&gt; y &lt;code&gt;stop&lt;/code&gt; y no la &lt;code&gt;length&lt;/code&gt; , la longitud total del rango se calcular&amp;aacute; autom&amp;aacute;ticamente de manera que los elementos est&amp;eacute;n espaciados por &lt;code&gt;step&lt;/code&gt; (un &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt; &lt;code&gt;StepRange&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c1a52fdda97e9a9edb8d40a32fdbba7468a954c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is an abstract type, then the method that would be called by &lt;code&gt;invoke&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;types&lt;/code&gt; es un tipo abstracto, se devuelve el m&amp;eacute;todo que se llamar&amp;iacute;a mediante &lt;code&gt;invoke&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f58b04b4e4485017440ce0c5de7416ee07070fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, returns an array of methods whose types match.</source>
          <target state="translated">Si se especifica &lt;code&gt;types&lt;/code&gt; , devuelve una matriz de m&amp;eacute;todos cuyos tipos coinciden.</target>
        </trans-unit>
        <trans-unit id="b3892fb415986ed95819205d489e6d5bbab6470a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mmap&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the file specified by &lt;code&gt;source&lt;/code&gt; is memory mapped for potential speedups. Default is &lt;code&gt;true&lt;/code&gt; except on Windows. On Windows, you may want to specify &lt;code&gt;true&lt;/code&gt; if the file is large, and is only read once and not written to.</source>
          <target state="translated">Si &lt;code&gt;use_mmap&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el archivo especificado por la &lt;code&gt;source&lt;/code&gt; se mapea en memoria para posibles aceleraciones. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; excepto en Windows. En Windows, es posible que desee especificar &lt;code&gt;true&lt;/code&gt; si el archivo es grande y solo se lee una vez y no se escribe.</target>
        </trans-unit>
        <trans-unit id="5645668108ab9880ec8d6ff07db8800e64be268c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wait&lt;/code&gt; is false, the process runs asynchronously. You can later wait for it and check its exit status by calling &lt;code&gt;success&lt;/code&gt; on the returned process object.</source>
          <target state="translated">Si la &lt;code&gt;wait&lt;/code&gt; es falsa, el proceso se ejecuta de forma asincr&amp;oacute;nica. Luego puede esperarlo y verificar su estado de salida llamando a &lt;code&gt;success&lt;/code&gt; en el objeto de proceso devuelto.</target>
        </trans-unit>
        <trans-unit id="4328d82bb88eefa0e600962ab951d3053ce804f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a number, this is essentially the same as &lt;code&gt;one(x)/x&lt;/code&gt;, but for some types &lt;code&gt;inv(x)&lt;/code&gt; may be slightly more efficient.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un n&amp;uacute;mero, esto es esencialmente lo mismo que &lt;code&gt;one(x)/x&lt;/code&gt; , pero para algunos tipos &lt;code&gt;inv(x)&lt;/code&gt; puede ser un poco m&amp;aacute;s eficiente.</target>
        </trans-unit>
        <trans-unit id="5d6e97018433ee560ec26ad905f78e6763128a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a type, return a &quot;larger&quot; type, defined so that arithmetic operations &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are guaranteed not to overflow nor lose precision for any combination of values that type &lt;code&gt;x&lt;/code&gt; can hold.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un tipo, devuelve un tipo &quot;m&amp;aacute;s grande&quot;, definido de modo que se garantice que las operaciones aritm&amp;eacute;ticas &lt;code&gt;+&lt;/code&gt; y &lt;code&gt;-&lt;/code&gt; no se desborden ni pierden precisi&amp;oacute;n para cualquier combinaci&amp;oacute;n de valores que el tipo &lt;code&gt;x&lt;/code&gt; pueda contener.</target>
        </trans-unit>
        <trans-unit id="88ba7ee31764ff507d81e94f6a3b385c0be71e42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a value, it is converted to &lt;code&gt;widen(typeof(x))&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un valor, se convierte a &lt;code&gt;widen(typeof(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a828e6b72bb380836af54de218be15aa9ebea9db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; will return an array filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una referencia de objeto, todos los elementos se referir&amp;aacute;n al mismo objeto. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; devolver&amp;aacute; una matriz llena con el resultado de evaluar &lt;code&gt;Foo()&lt;/code&gt; una vez.</target>
        </trans-unit>
        <trans-unit id="db317e66581e31b148fb1c68097906f9ec9dcecb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not an &lt;code&gt;AbstractArray&lt;/code&gt; but it supports &lt;code&gt;axes&lt;/code&gt;, indexing, and its type supports &lt;code&gt;ndims&lt;/code&gt;, then &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; may be implemented to just return itself. Further, if &lt;code&gt;x&lt;/code&gt; defines its own &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt;, then it must define its &lt;code&gt;broadcastable&lt;/code&gt; method to return itself for the custom style to have any effect.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; no es un &lt;code&gt;AbstractArray&lt;/code&gt; pero admite &lt;code&gt;axes&lt;/code&gt; , indexaci&amp;oacute;n y su tipo admite &lt;code&gt;ndims&lt;/code&gt; , entonces se puede implementar &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; para que se devuelva a s&amp;iacute; mismo. Adem&amp;aacute;s, si &lt;code&gt;x&lt;/code&gt; define su propio &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt; , entonces debe definir su m&amp;eacute;todo de &lt;code&gt;broadcastable&lt;/code&gt; para que se devuelva a s&amp;iacute; mismo para que el estilo personalizado tenga alg&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="ead093ec45b992f54a438f256340d7b0a0ef7df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; supports iteration, the returned value should have the same &lt;code&gt;axes&lt;/code&gt; and indexing behaviors as &lt;code&gt;collect(x)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; admite la iteraci&amp;oacute;n, el valor devuelto debe tener los mismos &lt;code&gt;axes&lt;/code&gt; y comportamientos de indexaci&amp;oacute;n que &lt;code&gt;collect(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9eb6d4efdb2a84932dc930c8197ad4f7fad62394" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt; literal (e.g. &lt;code&gt;2&lt;/code&gt; in &lt;code&gt;x^2&lt;/code&gt; or &lt;code&gt;-3&lt;/code&gt; in &lt;code&gt;x^-3&lt;/code&gt;), the Julia code &lt;code&gt;x^y&lt;/code&gt; is transformed by the compiler to &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt;, to enable compile-time specialization on the value of the exponent. (As a default fallback we have &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt;, where usually &lt;code&gt;^ == Base.^&lt;/code&gt; unless &lt;code&gt;^&lt;/code&gt; has been defined in the calling namespace.)</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es un literal &lt;code&gt;Int&lt;/code&gt; (por ejemplo, &lt;code&gt;2&lt;/code&gt; en &lt;code&gt;x^2&lt;/code&gt; o &lt;code&gt;-3&lt;/code&gt; en &lt;code&gt;x^-3&lt;/code&gt; ), el compilador transforma el c&amp;oacute;digo de Julia &lt;code&gt;x^y&lt;/code&gt; en &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt; , para habilitar la especializaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n en el valor del exponente. (Como alternativa predeterminada tenemos &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt; , donde normalmente &lt;code&gt;^ == Base.^&lt;/code&gt; menos que &lt;code&gt;^&lt;/code&gt; se haya definido en el espacio de nombres de la llamada).</target>
        </trans-unit>
        <trans-unit id="4030642b9b0fac77c474cfa27dc2012de7dca7c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;yes&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (&quot;denormals&quot;). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;yes==true&lt;/code&gt; but the hardware does not support zeroing of subnormal numbers.</source>
          <target state="translated">Si &lt;code&gt;yes&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , las operaciones de coma flotante subsiguientes siguen las reglas de la aritm&amp;eacute;tica IEEE sobre valores subnormales (&quot;desnormales&quot;). De lo contrario, las operaciones de coma flotante est&amp;aacute;n permitidas (pero no son obligatorias) para convertir las entradas o salidas subnormales a cero. Devuelve &lt;code&gt;true&lt;/code&gt; menos que &lt;code&gt;yes==true&lt;/code&gt; pero el hardware no admite la puesta a cero de n&amp;uacute;meros subnormales.</target>
        </trans-unit>
        <trans-unit id="4fe82c65bb97ee33e80659528026f81237a00185" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as &lt;code&gt;&amp;lt;-...&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">Si Julia eran un lenguaje que hace un uso m&amp;aacute;s liberal de los caracteres ASCII, el operador sorber podr&amp;iacute;a haber sido escrito como &lt;code&gt;&amp;lt;-...&lt;/code&gt; en lugar de &lt;code&gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c31aabb66505776aad35d90bd36db4dbf2d1b9d" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as &lt;code&gt;...-&amp;gt;&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">Si Julia eran un lenguaje que hace un uso m&amp;aacute;s liberal de los caracteres ASCII, el operador splatting podr&amp;iacute;a haber sido escrito como &lt;code&gt;...-&amp;gt;&lt;/code&gt; en lugar de &lt;code&gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60a92e91dcf7c91c0849e69c5ad346e21b345fcf" translate="yes" xml:space="preserve">
          <source>If [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vu&lt;/code&gt;] does not contain all eigenvalues of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">Si [ &lt;code&gt;vl&lt;/code&gt; , &lt;code&gt;vu&lt;/code&gt; ] no contiene todos los valores propios de &lt;code&gt;A&lt;/code&gt; , entonces la factorizaci&amp;oacute;n devuelta ser&amp;aacute; una factorizaci&amp;oacute;n &lt;em&gt;truncada&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="730dc1af168d94eefd1482151f83529bc44df580" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is empty, readers (on a &lt;code&gt;take!&lt;/code&gt; call) will block until data is available.</source>
          <target state="translated">Si un &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; est&amp;aacute; vac&amp;iacute;o, los lectores (en una llamada &lt;code&gt;take!&lt;/code&gt; ) Se bloquear&amp;aacute;n hasta que haya datos disponibles.</target>
        </trans-unit>
        <trans-unit id="84662f0c325b992dd59906d92d27342a4c4aeef8" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is full, writers (on a &lt;code&gt;put!&lt;/code&gt; call) will block until space becomes available.</source>
          <target state="translated">Si un &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; est&amp;aacute; lleno, los escritores (en una llamada &lt;code&gt;put!&lt;/code&gt; ) Se bloquear&amp;aacute;n hasta que haya espacio disponible.</target>
        </trans-unit>
        <trans-unit id="800a9b7d396fd78b7b6ed22445dc02985ff5d965" translate="yes" xml:space="preserve">
          <source>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of &lt;code&gt;VecElement&lt;/code&gt; that naturally maps to the SIMD type. Specifically:</source>
          <target state="translated">Si una rutina C / C ++ tiene un argumento o valor de retorno que es un tipo SIMD nativo, el tipo Julia correspondiente es una tupla homog&amp;eacute;nea de &lt;code&gt;VecElement&lt;/code&gt; que se asigna naturalmente al tipo SIMD. Espec&amp;iacute;ficamente:</target>
        </trans-unit>
        <trans-unit id="c33b9c9ad9c6bea2ac47b4bed7df57b3ce4b628b" translate="yes" xml:space="preserve">
          <source>If a Julia function returns an array, the return value of &lt;code&gt;jl_eval_string&lt;/code&gt; and &lt;code&gt;jl_call&lt;/code&gt; can be cast to a &lt;code&gt;jl_array_t*&lt;/code&gt;:</source>
          <target state="translated">Si una funci&amp;oacute;n de Julia devuelve una matriz, el valor de retorno de &lt;code&gt;jl_eval_string&lt;/code&gt; y &lt;code&gt;jl_call&lt;/code&gt; se puede convertir en un &lt;code&gt;jl_array_t*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da26aec502d267a61bc582bb3d104bf1101787e9" translate="yes" xml:space="preserve">
          <source>If a composite type is declared with &lt;code&gt;mutable struct&lt;/code&gt; instead of &lt;code&gt;struct&lt;/code&gt;, then instances of it can be modified:</source>
          <target state="translated">Si un tipo compuesto se declara con una &lt;code&gt;mutable struct&lt;/code&gt; lugar de una &lt;code&gt;struct&lt;/code&gt; , se pueden modificar instancias de &amp;eacute;l:</target>
        </trans-unit>
        <trans-unit id="4c7983e304a903c4c76a6412696125933d637b1a" translate="yes" xml:space="preserve">
          <source>If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.</source>
          <target state="translated">Si el nombre de una función requiere varias palabras,considere si podría representar más de un concepto y sería mejor dividirlo en partes.</target>
        </trans-unit>
        <trans-unit id="38936f146450cf1d3ca2236e47484dcaa49c5476" translate="yes" xml:space="preserve">
          <source>If a keyword argument is not assigned a default value in the method definition, then it is &lt;em&gt;required&lt;/em&gt;: an &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt;&lt;code&gt;UndefKeywordError&lt;/code&gt;&lt;/a&gt; exception will be thrown if the caller does not assign it a value:</source>
          <target state="translated">Si a un argumento de palabra clave no se le asigna un valor predeterminado en la definici&amp;oacute;n del m&amp;eacute;todo, entonces es &lt;em&gt;necesario&lt;/em&gt; : se &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt; &lt;code&gt;UndefKeywordError&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n UndefKeywordError si la persona que llama no le asigna un valor:</target>
        </trans-unit>
        <trans-unit id="605fe15674b1485baef4edc3c0b585f43273c96f" translate="yes" xml:space="preserve">
          <source>If a name is qualified (e.g. &lt;code&gt;Base.sin&lt;/code&gt;), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, &lt;code&gt;Base.+&lt;/code&gt; for example, you must use &lt;code&gt;Base.:+&lt;/code&gt; to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: &lt;code&gt;Base.:(==)&lt;/code&gt;.</source>
          <target state="translated">Si un nombre est&amp;aacute; calificado (por ejemplo, &lt;code&gt;Base.sin&lt;/code&gt; ), se puede acceder a &amp;eacute;l incluso si no se exporta. Esto suele ser &amp;uacute;til al depurar. Tambi&amp;eacute;n se le pueden agregar m&amp;eacute;todos utilizando el nombre calificado como el nombre de la funci&amp;oacute;n. Sin embargo, debido a las ambig&amp;uuml;edades sint&amp;aacute;cticas que surgen, si desea agregar m&amp;eacute;todos a una funci&amp;oacute;n en un m&amp;oacute;dulo diferente cuyo nombre contiene solo s&amp;iacute;mbolos, como un operador, &lt;code&gt;Base.+&lt;/code&gt; Por ejemplo, debe usar &lt;code&gt;Base.:+&lt;/code&gt; para referirse a &amp;eacute;l . Si el operador tiene m&amp;aacute;s de un car&amp;aacute;cter de longitud, debe rodearlo entre par&amp;eacute;ntesis, como: &lt;code&gt;Base.:(==)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906babc709733bae3d983752e96904e9364b6d02" translate="yes" xml:space="preserve">
          <source>If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the manner in which this rounding is done can be changed if required according to the rounding modes presented in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;.</source>
          <target state="translated">Si un n&amp;uacute;mero no tiene una representaci&amp;oacute;n exacta de punto flotante, debe redondearse a un valor representable apropiado. Sin embargo, la forma en que se realiza este redondeo se puede cambiar si es necesario de acuerdo con los modos de redondeo presentados en el &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;est&amp;aacute;ndar IEEE 754&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6c6ec423ec9e7ccad324608060715dc6c4297ac" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has a project file, then the graph entry for its UUID is the &lt;code&gt;[deps]&lt;/code&gt; map of the project file, which is considered to be empty if the section is absent.</source>
          <target state="translated">Si un subdirectorio de paquete tiene un archivo de proyecto, entonces la entrada del gr&amp;aacute;fico para su UUID es el mapa &lt;code&gt;[deps]&lt;/code&gt; del archivo de proyecto, que se considera vac&amp;iacute;o si la secci&amp;oacute;n est&amp;aacute; ausente.</target>
        </trans-unit>
        <trans-unit id="b858ef46784b4025474ecb1ef203d57b534b42bf" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.</source>
          <target state="translated">Si un subdirectorio de un paquete no tiene un archivo de proyecto,entonces se omite en el gráfico y las declaraciones de importación en su código se tratan como de nivel superior,al igual que el proyecto principal y REPL.</target>
        </trans-unit>
        <trans-unit id="2f45dbf01a0d76d1b423a11e7134b517f4cc2734" translate="yes" xml:space="preserve">
          <source>If a regular expression does match, the value returned by &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;RegexMatch&lt;/code&gt; object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:</source>
          <target state="translated">Si una expresi&amp;oacute;n regular coincide, el valor devuelto por la &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; es un objeto &lt;code&gt;RegexMatch&lt;/code&gt; . Estos objetos registran c&amp;oacute;mo coincide la expresi&amp;oacute;n, incluida la subcadena con la que coincide el patr&amp;oacute;n y las subcadenas capturadas, si las hay. Este ejemplo solo captura la parte de la subcadena que coincide, pero quiz&amp;aacute;s queramos capturar cualquier texto que no est&amp;eacute; en blanco despu&amp;eacute;s del car&amp;aacute;cter de comentario. Podr&amp;iacute;amos hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="5e6085fa6af3d4081b0dc16abe2813cbe1633ab2" translate="yes" xml:space="preserve">
          <source>If a second argument &lt;code&gt;val&lt;/code&gt; is provided, it will be passed to the task (via the return value of &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;) when it runs again. If &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the value is raised as an exception in the woken task.</source>
          <target state="translated">Si se proporciona un segundo argumento &lt;code&gt;val&lt;/code&gt; , se pasar&amp;aacute; a la tarea (a trav&amp;eacute;s del valor de retorno de &lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; ) cuando se vuelva a ejecutar. Si el &lt;code&gt;error&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el valor se eleva como una excepci&amp;oacute;n en la tarea activada.</target>
        </trans-unit>
        <trans-unit id="bad86ee27c201caed09e850508017b392f709911" translate="yes" xml:space="preserve">
          <source>If a test fails consistently it can be changed to use the &lt;code&gt;@test_broken&lt;/code&gt; macro. This will denote the test as &lt;code&gt;Broken&lt;/code&gt; if the test continues to fail and alerts the user via an &lt;code&gt;Error&lt;/code&gt; if the test succeeds.</source>
          <target state="translated">Si una prueba falla constantemente, se puede cambiar para usar la macro &lt;code&gt;@test_broken&lt;/code&gt; . Esto indicar&amp;aacute; que la prueba est&amp;aacute; &lt;code&gt;Broken&lt;/code&gt; si la prueba contin&amp;uacute;a fallando y alerta al usuario mediante un &lt;code&gt;Error&lt;/code&gt; si la prueba tiene &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="f4acf383897e60ec242acf14416a5081e1af3573" translate="yes" xml:space="preserve">
          <source>If a tuple of keyword argument names &lt;code&gt;kwnames&lt;/code&gt; is provided, this also checks whether the method of &lt;code&gt;f&lt;/code&gt; matching &lt;code&gt;t&lt;/code&gt; has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with &lt;code&gt;kwargs...&lt;/code&gt;, any names given in &lt;code&gt;kwnames&lt;/code&gt; are considered valid. Otherwise the provided names must be a subset of the method's keyword arguments.</source>
          <target state="translated">Si se proporciona una tupla de nombres de argumentos de palabras clave &lt;code&gt;kwnames&lt;/code&gt; , esto tambi&amp;eacute;n verifica si el m&amp;eacute;todo de &lt;code&gt;f&lt;/code&gt; que coincide con &lt;code&gt;t&lt;/code&gt; tiene los nombres de argumentos de palabras clave dados. Si el m&amp;eacute;todo de coincidencia acepta un n&amp;uacute;mero variable de argumentos de palabra clave, por ejemplo, con &lt;code&gt;kwargs...&lt;/code&gt; , cualquier nombre dado en &lt;code&gt;kwnames&lt;/code&gt; se considera v&amp;aacute;lido. De lo contrario, los nombres proporcionados deben ser un subconjunto de los argumentos de palabras clave del m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="3df6568badc4d30be904f3a616a563af8fd77a0a" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="translated">Si un tipo se define como un subtipo de &lt;code&gt;AbstractArray&lt;/code&gt; , hereda un conjunto muy grande de comportamientos enriquecidos que incluyen iteraci&amp;oacute;n e indexaci&amp;oacute;n multidimensional construida sobre el acceso de un solo elemento. Consulte la &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;p&amp;aacute;gina del manual de matrices&lt;/a&gt; y la &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;secci&amp;oacute;n Julia Base&lt;/a&gt; para obtener m&amp;aacute;s m&amp;eacute;todos compatibles.</target>
        </trans-unit>
        <trans-unit id="72a8103071abaea7ac2a617ea71042865eddd171" translate="yes" xml:space="preserve">
          <source>If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the &quot;values&quot; as subtypes.</source>
          <target state="translated">Si un tipo es efectivamente una enumeración,debe definirse como un tipo único (idealmente una estructura inmutable o primitiva),siendo los valores de la enumeración ejemplos de ello.Los constructores y los convertidores pueden comprobar si los valores son válidos.Se prefiere este diseño a hacer de la enumeración un tipo abstracto,con los &quot;valores&quot; como subtipos.</target>
        </trans-unit>
        <trans-unit id="22206d1a9cff4ea1aad87ee3f387a4a25003f12d" translate="yes" xml:space="preserve">
          <source>If a user is presented with a credential prompt they can abort the prompt by typing &lt;code&gt;^D&lt;/code&gt; (pressing the control key together with the &lt;code&gt;d&lt;/code&gt; key).</source>
          <target state="translated">Si a un usuario se le presenta una solicitud de credencial, puede cancelar la solicitud escribiendo &lt;code&gt;^D&lt;/code&gt; (presionando la tecla de control junto con la tecla &lt;code&gt;d&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ebb7b0aa6b2c808bffa6df77883dc4cf4f4f7ece" translate="yes" xml:space="preserve">
          <source>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</source>
          <target state="translated">Si no se especifica un grupo de trabajadores,se utilizan todos los trabajadores disponibles,es decir,el grupo de trabajadores por defecto.</target>
        </trans-unit>
        <trans-unit id="ec5bfd99caef655cee76ea6c587f7690d264c4bb" translate="yes" xml:space="preserve">
          <source>If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">Si todos los datos son numéricos,el resultado será una matriz numérica.Si algunos elementos no pueden analizarse como números,se obtiene una matriz heterogénea de números y cadenas.</target>
        </trans-unit>
        <trans-unit id="9ac5a121e4737af42e151921b98260446a6d1fe7" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are integers, then the value in location &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value of &lt;code&gt;X&lt;/code&gt;, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;ing to the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; if necessary.</source>
          <target state="translated">Si todos los &amp;iacute;ndices &lt;code&gt;I_k&lt;/code&gt; son enteros, entonces el valor en la ubicaci&amp;oacute;n &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; de &lt;code&gt;A&lt;/code&gt; se sobrescribe con el valor de &lt;code&gt;X&lt;/code&gt; , &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; al &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; de &lt;code&gt;A&lt;/code&gt; si es necesario.</target>
        </trans-unit>
        <trans-unit id="16c375c96eb496fe31b2274a71fede0f6283f232" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are vectors, for example, then the shape of &lt;code&gt;X&lt;/code&gt; would be &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt;, with location &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; of &lt;code&gt;X&lt;/code&gt; containing the value &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt;.</source>
          <target state="translated">Si todos los &amp;iacute;ndices &lt;code&gt;I_k&lt;/code&gt; son vectores, por ejemplo, entonces la forma de &lt;code&gt;X&lt;/code&gt; ser&amp;iacute;a &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt; , con ubicaci&amp;oacute;n &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; de &lt;code&gt;X&lt;/code&gt; que contiene el valor &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7329bd9dbc66827b90f349500e9813dc3f4dd6b" translate="yes" xml:space="preserve">
          <source>If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.</source>
          <target state="translated">Si todos los argumentos son escalares o matrices de dimensión cero,devuelve un escalar sin envolver.</target>
        </trans-unit>
        <trans-unit id="947c4d2702167c0b010760802f3c8902ac7ef2b7" translate="yes" xml:space="preserve">
          <source>If all the indices are scalars, then the result &lt;code&gt;X&lt;/code&gt; is a single element from the array &lt;code&gt;A&lt;/code&gt;. Otherwise, &lt;code&gt;X&lt;/code&gt; is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</source>
          <target state="translated">Si todos los &amp;iacute;ndices son escalares, entonces el resultado &lt;code&gt;X&lt;/code&gt; es un solo elemento de la matriz &lt;code&gt;A&lt;/code&gt; . De lo contrario, &lt;code&gt;X&lt;/code&gt; es una matriz con el mismo n&amp;uacute;mero de dimensiones que la suma de las dimensionalidades de todos los &amp;iacute;ndices.</target>
        </trans-unit>
        <trans-unit id="3044600e4ff9e45b323c2058f952d5b48a41642d" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="translated">Si todas estas comprobaciones pasan, el mensaje y los pares clave-valor se eval&amp;uacute;an por completo y se pasan al registrador actual mediante la funci&amp;oacute;n &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt; &lt;code&gt;Logging.handle_message&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;handle_message()&lt;/code&gt; puede realizar un filtrado adicional seg&amp;uacute;n sea necesario y mostrar el evento en la pantalla, guardarlo en un archivo, etc.</target>
        </trans-unit>
        <trans-unit id="bec4431d05d00195da3b5ef4209465d15c43707c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers.</source>
          <target state="translated">Si se especifica una funci&amp;oacute;n &lt;code&gt;init&lt;/code&gt; del tipo &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; , se llama a todos los trabajadores participantes.</target>
        </trans-unit>
        <trans-unit id="3b65b9c692ce6d8deffe1b518910973b66bdfe66" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function, of signature &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt;, is specified, it is called on all the participating workers. You can specify that each worker runs the &lt;code&gt;init&lt;/code&gt; function on a distinct portion of the array, thereby parallelizing initialization.</source>
          <target state="translated">Si se especifica una funci&amp;oacute;n &lt;code&gt;init&lt;/code&gt; , de firma &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; , se llama a todos los trabajadores participantes. Puede especificar que cada trabajador ejecute la funci&amp;oacute;n &lt;code&gt;init&lt;/code&gt; en una parte distinta de la matriz, paralelizando as&amp;iacute; la inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dcd6328c4dd12bc549abfb594d444224ffd4160c" translate="yes" xml:space="preserve">
          <source>If an array of eltype &lt;code&gt;Ptr{T}&lt;/code&gt; is passed as a &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; argument, &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; will attempt to first make a null-terminated copy of the array with each element replaced by its &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; version. This allows, for example, passing an &lt;code&gt;argv&lt;/code&gt; pointer array of type &lt;code&gt;Vector{String}&lt;/code&gt; to an argument of type &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt;.</source>
          <target state="translated">Si se pasa una matriz de eltype &lt;code&gt;Ptr{T}&lt;/code&gt; como un argumento &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; , &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; intentar&amp;aacute; hacer primero una copia terminada en nulo de la matriz con cada elemento reemplazado por su versi&amp;oacute;n &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; . Esto permite, por ejemplo, pasar una matriz de punteros &lt;code&gt;argv&lt;/code&gt; de tipo &lt;code&gt;Vector{String}&lt;/code&gt; a un argumento de tipo &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa768f627a40c9d0913fe21e857ab82ce9b4abc" translate="yes" xml:space="preserve">
          <source>If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a &lt;code&gt;GitError&lt;/code&gt;. This is roughly equivalent to the following command line statement:</source>
          <target state="translated">Si surge alg&amp;uacute;n conflicto que no pueda resolverse autom&amp;aacute;ticamente, la rebase abortar&amp;aacute;, dejando el repositorio y el &amp;aacute;rbol de trabajo en su estado original, y la funci&amp;oacute;n arrojar&amp;aacute; un &lt;code&gt;GitError&lt;/code&gt; . Esto es aproximadamente equivalente a la siguiente declaraci&amp;oacute;n de l&amp;iacute;nea de comando:</target>
        </trans-unit>
        <trans-unit id="d387af77f5db6a955f974f865de51228d37bd15f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting-1&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="translated">Si cualquier &amp;iacute;ndice &lt;code&gt;I_k&lt;/code&gt; selecciona m&amp;aacute;s de una ubicaci&amp;oacute;n, entonces el lado derecho &lt;code&gt;X&lt;/code&gt; debe ser una matriz con la misma forma que el resultado de indexar &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; o un vector con el mismo n&amp;uacute;mero de elementos . El valor en la ubicaci&amp;oacute;n &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; de &lt;code&gt;A&lt;/code&gt; se sobrescribe con el valor &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt; , convirti&amp;eacute;ndose si es necesario. El operador de asignaci&amp;oacute;n por elementos &lt;code&gt;.=&lt;/code&gt; Puede usarse para &lt;a href=&quot;#Broadcasting-1&quot;&gt;transmitir &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; a trav&amp;eacute;s de las ubicaciones seleccionadas:</target>
        </trans-unit>
        <trans-unit id="a2dae61ea17ea95a5a6582831ba526a24537cb67" translate="yes" xml:space="preserve">
          <source>If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to &lt;code&gt;new&lt;/code&gt;, returning the resulting object:</source>
          <target state="translated">Si se define alg&amp;uacute;n m&amp;eacute;todo de constructor interno, no se proporciona ning&amp;uacute;n m&amp;eacute;todo de constructor predeterminado: se presume que se ha proporcionado todos los constructores internos que necesita. El constructor predeterminado es equivalente a escribir su propio m&amp;eacute;todo de constructor interno que toma todos los campos del objeto como par&amp;aacute;metros (restringidos a ser del tipo correcto, si el campo correspondiente tiene un tipo), y los pasa a &lt;code&gt;new&lt;/code&gt; , devolviendo el objeto resultante:</target>
        </trans-unit>
        <trans-unit id="e9dbb4d7bac298e185fc7fe07e57c374bc123283" translate="yes" xml:space="preserve">
          <source>If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus &lt;code&gt;src/X.jl&lt;/code&gt;; otherwise, there is no path mapping for &lt;code&gt;uuid&lt;/code&gt;. When loading &lt;code&gt;X&lt;/code&gt;, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring &lt;code&gt;X&lt;/code&gt; as a dependency).</source>
          <target state="translated">Si cualquiera de estos resultados tiene &amp;eacute;xito, la ruta al punto de entrada del c&amp;oacute;digo fuente ser&amp;aacute; ese resultado, la ruta relativa desde ese resultado m&amp;aacute;s &lt;code&gt;src/X.jl&lt;/code&gt; ; de lo contrario, no hay mapeo de ruta para &lt;code&gt;uuid&lt;/code&gt; . Al cargar &lt;code&gt;X&lt;/code&gt; , si no se encuentra la ruta del c&amp;oacute;digo fuente, la b&amp;uacute;squeda fallar&amp;aacute; y se le pedir&amp;aacute; al usuario que instale la versi&amp;oacute;n apropiada del paquete o que tome otra acci&amp;oacute;n correctiva (por ejemplo, declarar &lt;code&gt;X&lt;/code&gt; como una dependencia).</target>
        </trans-unit>
        <trans-unit id="4ddf1789b0cb07d74b04fcfdb8b7aef3cf09d72f" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the standard deviation of non-missing values.</source>
          <target state="translated">Si la matriz contiene &lt;code&gt;NaN&lt;/code&gt; o valores &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , el resultado tambi&amp;eacute;n es &lt;code&gt;NaN&lt;/code&gt; o &lt;code&gt;missing&lt;/code&gt; (la &lt;code&gt;missing&lt;/code&gt; tiene prioridad si la matriz contiene ambos). Usar la &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n de omitir &lt;code&gt;missing&lt;/code&gt; entradas y calcular la desviaci&amp;oacute;n est&amp;aacute;ndar de los valores no perdidos.</target>
        </trans-unit>
        <trans-unit id="3a6293b5e98855a8ee42f2bca1bebc73fa339517" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the variance of non-missing values.</source>
          <target state="translated">Si la matriz contiene &lt;code&gt;NaN&lt;/code&gt; o valores &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , el resultado tambi&amp;eacute;n es &lt;code&gt;NaN&lt;/code&gt; o &lt;code&gt;missing&lt;/code&gt; (la &lt;code&gt;missing&lt;/code&gt; tiene prioridad si la matriz contiene ambos). Usar la &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n de omitir &lt;code&gt;missing&lt;/code&gt; entradas y calcular la varianza de los valores no perdidos.</target>
        </trans-unit>
        <trans-unit id="38e45e26639753f801787edbbd58523b34871d79" translate="yes" xml:space="preserve">
          <source>If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.</source>
          <target state="translated">Si al menos un argumento es una tupla y todos los demás son escalares o matrices de dimensión cero,devuelve una tupla.</target>
        </trans-unit>
        <trans-unit id="186a2528019c2b28f2ac036bd36737c001f4c334" translate="yes" xml:space="preserve">
          <source>If called with the optional &lt;code&gt;stream&lt;/code&gt; argument, then returns &lt;code&gt;stream&lt;/code&gt; itself.</source>
          <target state="translated">Si se llama con el argumento de &lt;code&gt;stream&lt;/code&gt; opcional , devuelve el &lt;code&gt;stream&lt;/code&gt; s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="c2dc6a2dba2346f86620a63b3cfed83cd90e27f4" translate="yes" xml:space="preserve">
          <source>If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):</source>
          <target state="translated">Si las variables capturadas se utilizan en una sección del código de rendimiento crítico,entonces los siguientes consejos ayudan a asegurar que su uso sea eficiente.En primer lugar,si se sabe que una variable capturada no cambia de tipo,entonces puede declararse explícitamente con una anotación de tipo (en la variable,no en el lado derecho):</target>
        </trans-unit>
        <trans-unit id="1a5d4d133718a06af974dc91ca305c022dd4e098" translate="yes" xml:space="preserve">
          <source>If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.</source>
          <target state="translated">Si se especifican los tipos de campo,los argumentos se convierten.En caso contrario,los tipos de los argumentos se utilizan directamente.</target>
        </trans-unit>
        <trans-unit id="8f773999b3dbcf00b06936dfadd297798081b077" translate="yes" xml:space="preserve">
          <source>If instead you want to specialize on the destination type &lt;code&gt;DestType&lt;/code&gt; without specializing on &lt;code&gt;DestStyle&lt;/code&gt;, then you should define a method with the following signature:</source>
          <target state="translated">Si, en cambio, desea especializarse en el tipo de destino &lt;code&gt;DestType&lt;/code&gt; sin especializarse en &lt;code&gt;DestStyle&lt;/code&gt; , entonces debe definir un m&amp;eacute;todo con la siguiente firma:</target>
        </trans-unit>
        <trans-unit id="861e841404a73546cfbc58b3413de786fc3740a2" translate="yes" xml:space="preserve">
          <source>If it does not have a project file, it can import any top-level package&amp;mdash;i.e. the same packages that can be loaded in &lt;code&gt;Main&lt;/code&gt; or the REPL.</source>
          <target state="translated">Si no tiene un archivo de proyecto, puede importar cualquier paquete de nivel superior, es decir, los mismos paquetes que se pueden cargar en &lt;code&gt;Main&lt;/code&gt; o REPL.</target>
        </trans-unit>
        <trans-unit id="4cdc37b95e5e03c0daf7e3854e30ae2e06ab2fbd" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry, compute a deterministic hash function of &lt;code&gt;uuid&lt;/code&gt; and &lt;code&gt;git-tree-sha1&lt;/code&gt;&amp;mdash;call it &lt;code&gt;slug&lt;/code&gt;&amp;mdash;and look for a directory named &lt;code&gt;packages/X/$slug&lt;/code&gt; in each directory in the Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; global array. Use the first such directory that exists.</source>
          <target state="translated">Si tiene una entrada &lt;code&gt;git-tree-sha1&lt;/code&gt; , calcule una funci&amp;oacute;n hash determinista de &lt;code&gt;uuid&lt;/code&gt; y &lt;code&gt;git-tree-sha1&lt;/code&gt; ( ll&amp;aacute;melo &lt;code&gt;slug&lt;/code&gt; ) y busque un directorio llamado &lt;code&gt;packages/X/$slug&lt;/code&gt; en cada directorio de la matriz global Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; . Utilice el primer directorio de este tipo que exista.</target>
        </trans-unit>
        <trans-unit id="cd1241924f2c661cd879945fa2b395e0b0c5bf1c" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;path&lt;/code&gt; entry, use that path (relative to the directory containing the manifest file).</source>
          <target state="translated">Si tiene una entrada de &lt;code&gt;path&lt;/code&gt; , use esa ruta (relativa al directorio que contiene el archivo de manifiesto).</target>
        </trans-unit>
        <trans-unit id="ecfbca60e91ee74286b0eaf619c2ce8c59e2470c" translate="yes" xml:space="preserve">
          <source>If it has a project file, it can only import those packages which are identified in the &lt;code&gt;[deps]&lt;/code&gt; section of the project file.</source>
          <target state="translated">Si tiene un archivo de proyecto, solo puede importar aquellos paquetes que est&amp;aacute;n identificados en la secci&amp;oacute;n &lt;code&gt;[deps]&lt;/code&gt; del archivo de proyecto.</target>
        </trans-unit>
        <trans-unit id="d73050aa6cb9e92d8510b86ef26b845581d55552" translate="yes" xml:space="preserve">
          <source>If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global &lt;code&gt;IdDict&lt;/code&gt; that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.</source>
          <target state="translated">Si se requiere mantener el puntero a una variable entre funciones (o bloques de alcance), entonces no es posible usar &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; . En este caso, es necesario crear y mantener una referencia a la variable en el &amp;aacute;mbito global de Julia. Una forma sencilla de lograr esto es utilizar un &lt;code&gt;IdDict&lt;/code&gt; global que contendr&amp;aacute; las referencias, evitando la desasignaci&amp;oacute;n por parte del GC. Sin embargo, este m&amp;eacute;todo solo funcionar&amp;aacute; correctamente con tipos mutables.</target>
        </trans-unit>
        <trans-unit id="473e682023e21d67484bab11333a56f6e24d4e3e" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt;, then counts for the number of calls to &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; and &lt;code&gt;maybe_collect()&lt;/code&gt; are printed.</source>
          <target state="translated">Si es el &lt;code&gt;n&lt;/code&gt; &amp;ordm; vez que &lt;code&gt;jl_gc_collect()&lt;/code&gt; se ha llamado, y &lt;code&gt;n&lt;/code&gt; pertenece a la secuencia aritm&amp;eacute;tica representado por &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt; , entonces no cuenta para el n&amp;uacute;mero de llamadas a &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; y &lt;code&gt;maybe_collect()&lt;/code&gt; se imprimen.</target>
        </trans-unit>
        <trans-unit id="130d982e40fa648e81bf69006602371d8efc3765" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">Si es el &lt;code&gt;n&lt;/code&gt; &amp;ordm; vez que &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; se ha llamado, y &lt;code&gt;n&lt;/code&gt; pertenece a la secuencia aritm&amp;eacute;tica representado por &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt; , a continuaci&amp;oacute;n, la recolecci&amp;oacute;n de basura es forzada.</target>
        </trans-unit>
        <trans-unit id="40d1d12e4aea313c12b9b3da68ad08e9a0d521e5" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;maybe_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">Si es el &lt;code&gt;n&lt;/code&gt; &amp;ordm; vez que &lt;code&gt;maybe_collect()&lt;/code&gt; se ha llamado, y &lt;code&gt;n&lt;/code&gt; pertenece a la secuencia aritm&amp;eacute;tica representado por &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt; , a continuaci&amp;oacute;n, la recolecci&amp;oacute;n de basura es forzada.</target>
        </trans-unit>
        <trans-unit id="74f9655f12c7f5e7ed84cb6e935e104ba2688d1a" translate="yes" xml:space="preserve">
          <source>If keyword &lt;code&gt;supertypes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, also return arguments with a parent type of &lt;code&gt;typ&lt;/code&gt;, excluding type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">Si los &lt;code&gt;supertypes&lt;/code&gt; palabras clave son &lt;code&gt;true&lt;/code&gt; , tambi&amp;eacute;n devuelve argumentos con un tipo principal de &lt;code&gt;typ&lt;/code&gt; , excluyendo el tipo &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc696527340f0e0e085e98638a1e2d12825b4024" translate="yes" xml:space="preserve">
          <source>If memory usage is your concern, you can always replace objects with ones that consume less memory. For example, if &lt;code&gt;A&lt;/code&gt; is a gigabyte-sized array that you no longer need, you can free the memory with &lt;code&gt;A = nothing&lt;/code&gt;. The memory will be released the next time the garbage collector runs; you can force this to happen with &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt;&lt;code&gt;gc()&lt;/code&gt;&lt;/a&gt;. Moreover, an attempt to use &lt;code&gt;A&lt;/code&gt; will likely result in an error, because most methods are not defined on type &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">Si el uso de la memoria es lo que le preocupa, siempre puede reemplazar los objetos por otros que consuman menos memoria. Por ejemplo, si &lt;code&gt;A&lt;/code&gt; es una matriz del tama&amp;ntilde;o de un gigabyte que ya no necesita, puede liberar la memoria con &lt;code&gt;A = nothing&lt;/code&gt; . La memoria se liberar&amp;aacute; la pr&amp;oacute;xima vez que se ejecute el recolector de basura; puede forzar que esto suceda con &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt; &lt;code&gt;gc()&lt;/code&gt; &lt;/a&gt; . Adem&amp;aacute;s, un intento de usar &lt;code&gt;A&lt;/code&gt; probablemente resultar&amp;aacute; en un error, porque la mayor&amp;iacute;a de los m&amp;eacute;todos no est&amp;aacute;n definidos en el tipo &lt;code&gt;Nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d311a5ead70c39f70d69a25fb13adf9b0a2959d" translate="yes" xml:space="preserve">
          <source>If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the &quot;cost&quot; of a given line&amp;ndash;or really, the cost of the sequence of function calls up to and including this line&amp;ndash;is proportional to how often it appears in the set of all backtraces.</source>
          <target state="translated">Si dedica gran parte de su tiempo de ejecuci&amp;oacute;n a ejecutar una l&amp;iacute;nea de c&amp;oacute;digo en particular, esta l&amp;iacute;nea se mostrar&amp;aacute; con frecuencia en el conjunto de todas las trazas. En otras palabras, el &quot;costo&quot; de una l&amp;iacute;nea determinada, o en realidad, el costo de la secuencia de llamadas a funciones hasta esta l&amp;iacute;nea inclusive, es proporcional a la frecuencia con la que aparece en el conjunto de todos los trazos retroactivos.</target>
        </trans-unit>
        <trans-unit id="99791a8f1a9660eaeaa9f5b9e831b943f3ed9006" translate="yes" xml:space="preserve">
          <source>If needed, the sorting algorithm can be chosen:</source>
          <target state="translated">Si es necesario,se puede elegir el algoritmo de clasificación:</target>
        </trans-unit>
        <trans-unit id="4223679e9c9b3c609f6bfb56a1e1db206adba7ec" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;type&lt;/code&gt; argument is specified, the default is &lt;code&gt;Vector{UInt8}&lt;/code&gt;.</source>
          <target state="translated">Si no se especifica ning&amp;uacute;n argumento de &lt;code&gt;type&lt;/code&gt; , el valor predeterminado es &lt;code&gt;Vector{UInt8}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfa8e1861fd13b4e706313c90dcab6ea83fe0c35" translate="yes" xml:space="preserve">
          <source>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to &lt;a href=&quot;#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si no se pasa ning&amp;uacute;n argumento, la tarea se bloquea durante un per&amp;iacute;odo indefinido. Una tarea solo se puede reiniciar mediante una llamada expl&amp;iacute;cita a &lt;a href=&quot;#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0a9f892d2c7e314c83b4254ca8ced8f31ecd25" translate="yes" xml:space="preserve">
          <source>If no custom testset type is given it defaults to creating a &lt;code&gt;DefaultTestSet&lt;/code&gt;. &lt;code&gt;DefaultTestSet&lt;/code&gt; records all the results and, if there are any &lt;code&gt;Fail&lt;/code&gt;s or &lt;code&gt;Error&lt;/code&gt;s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</source>
          <target state="translated">Si no se proporciona un tipo de conjunto de pruebas personalizado, el valor predeterminado es crear un &lt;code&gt;DefaultTestSet&lt;/code&gt; . &lt;code&gt;DefaultTestSet&lt;/code&gt; registra todos los resultados y, si hay alguna &lt;code&gt;Fail&lt;/code&gt; o &lt;code&gt;Error&lt;/code&gt; , lanza una excepci&amp;oacute;n al final del conjunto de prueba de nivel superior (no anidado), junto con un resumen de los resultados de la prueba.</target>
        </trans-unit>
        <trans-unit id="1e0f744d0d8245436d7c2b792319d69a40debe40" translate="yes" xml:space="preserve">
          <source>If possible, &lt;code&gt;one(x)&lt;/code&gt; returns a value of the same type as &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;one(T)&lt;/code&gt; returns a value of type &lt;code&gt;T&lt;/code&gt;. However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless. In that case, &lt;code&gt;one(x)&lt;/code&gt; should return an identity value of the same precision (and shape, for matrices) as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Si es posible, &lt;code&gt;one(x)&lt;/code&gt; devuelve un valor del mismo tipo que &lt;code&gt;x&lt;/code&gt; , y &lt;code&gt;one(T)&lt;/code&gt; devuelve un valor de tipo &lt;code&gt;T&lt;/code&gt; . Sin embargo, este puede no ser el caso para los tipos que representan cantidades dimensionales (por ejemplo, tiempo en d&amp;iacute;as), ya que la identidad multiplicativa debe ser adimensional. En ese caso, &lt;code&gt;one(x)&lt;/code&gt; deber&amp;iacute;a devolver un valor de identidad de la misma precisi&amp;oacute;n (y forma, para matrices) que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe767ad4883ee037996d5cf486b48b4286df5e71" translate="yes" xml:space="preserve">
          <source>If set to a string that starts with the case-insensitive substring &lt;code&gt;&quot;infinite&quot;&lt;/code&gt;, then spinning threads never sleep. Otherwise, &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; is interpreted as an unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.</source>
          <target state="translated">Si se establece en una cadena que comienza con la subcadena &lt;code&gt;&quot;infinite&quot;&lt;/code&gt; que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas , los hilos giratorios nunca duermen. De lo contrario, &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; se interpreta como un entero de 64 bits sin signo ( &lt;code&gt;uint64_t&lt;/code&gt; ) y da, en nanosegundos, la cantidad de tiempo despu&amp;eacute;s del cual los hilos giratorios deben dormir.</target>
        </trans-unit>
        <trans-unit id="20e80c59100f13ca7e73369cbf1cacf7e59c1aa3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then Julia's thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.</source>
          <target state="translated">Si se establece en cualquier valor adem&amp;aacute;s de &lt;code&gt;0&lt;/code&gt; , la pol&amp;iacute;tica de subprocesos de Julia es coherente con la ejecuci&amp;oacute;n en una m&amp;aacute;quina dedicada: el subproceso maestro est&amp;aacute; en el proceso 0 y los subprocesos est&amp;aacute;n afinidos. De lo contrario, Julia permite que el sistema operativo maneje la pol&amp;iacute;tica de subprocesos.</target>
        </trans-unit>
        <trans-unit id="f40c9b9b4bbc428bc99a8f3b50c7542418d6c605" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector never performs &quot;quick sweeps&quot; of memory.</source>
          <target state="translated">Si se establece en cualquier valor que no sea &lt;code&gt;0&lt;/code&gt; , el recolector de basura de Julia nunca realiza &quot;barridos r&amp;aacute;pidos&quot; de memoria.</target>
        </trans-unit>
        <trans-unit id="eb0219b86b58bf1246d63c4e45daa90f20eb81c3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there's a critical error.</source>
          <target state="translated">Si se establece en cualquier valor que no sea &lt;code&gt;0&lt;/code&gt; , el recolector de basura de Julia esperar&amp;aacute; a que se conecte un depurador en lugar de abortar cuando haya un error cr&amp;iacute;tico.</target>
        </trans-unit>
        <trans-unit id="1ba30fe7de8eb6c5eb6e36c3ca16b929b1d23810" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the compiler will create and register an event listener for just-in-time (JIT) profiling.</source>
          <target state="translated">Si se establece en cualquier valor que no sea &lt;code&gt;0&lt;/code&gt; , el compilador crear&amp;aacute; y registrar&amp;aacute; un detector de eventos para la generaci&amp;oacute;n de perfiles Just-In-Time (JIT).</target>
        </trans-unit>
        <trans-unit id="3b0cd4807865348218a8157872f2d19ba8cef0a0" translate="yes" xml:space="preserve">
          <source>If set, then Julia prints detailed information about the cache in the loading process of &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt;&lt;code&gt;Base.require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se establece, Julia imprime informaci&amp;oacute;n detallada sobre el cach&amp;eacute; en el proceso de carga de &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt; &lt;code&gt;Base.require&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31ed13caeaa2adf17adcff6b38e069bb43cc30cf" translate="yes" xml:space="preserve">
          <source>If set, these environment variables take strings that optionally start with the character &lt;code&gt;'r'&lt;/code&gt;, followed by a string interpolation of a colon-separated list of three signed 64-bit integers (&lt;code&gt;int64_t&lt;/code&gt;). This triple of integers &lt;code&gt;a:b:c&lt;/code&gt; represents the arithmetic sequence &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a + b&lt;/code&gt;, &lt;code&gt;a + 2*b&lt;/code&gt;, ... &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Si se establecen, estas variables de entorno toman cadenas que comienzan opcionalmente con el car&amp;aacute;cter &lt;code&gt;'r'&lt;/code&gt; , seguidas de una interpolaci&amp;oacute;n de cadenas de una lista separada por dos puntos de tres enteros de 64 bits con &lt;code&gt;int64_t&lt;/code&gt; ( int64_t ). Este triple de enteros &lt;code&gt;a:b:c&lt;/code&gt; representa la secuencia aritm&amp;eacute;tica &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;a + b&lt;/code&gt; , &lt;code&gt;a + 2*b&lt;/code&gt; , ... &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ec6755ec5d15a629cdab4809712a90cbd8c460" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will have the effect of prepending &lt;code&gt;/foo/bar&lt;/code&gt; to the default depot path. If &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;DEPOT_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">Si la variable de entorno &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; ya est&amp;aacute; configurada, su valor anterior se antepondr&amp;aacute; con &lt;code&gt;/foo/bar&lt;/code&gt; . Por otro lado, si no se establece &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; , entonces se establecer&amp;aacute; en &lt;code&gt;/foo/bar:&lt;/code&gt; lo que tendr&amp;aacute; el efecto de anteponer &lt;code&gt;/foo/bar&lt;/code&gt; a la ruta de dep&amp;oacute;sito predeterminada. Si &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; se establece en la cadena vac&amp;iacute;a, se expande a un &lt;code&gt;DEPOT_PATH&lt;/code&gt; vac&amp;iacute;oformaci&amp;oacute;n. En otras palabras, la cadena vac&amp;iacute;a se interpreta como una matriz de elementos cero, no como una matriz de un elemento de la cadena vac&amp;iacute;a. Este comportamiento se eligi&amp;oacute; para que fuera posible establecer una ruta de dep&amp;oacute;sito vac&amp;iacute;a a trav&amp;eacute;s de la variable de entorno. Si desea que la ruta de almac&amp;eacute;n por defecto, o bien desactivar la variable de entorno o si debe tener un valor, configurarlo para que la cadena &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="951a284bb764079dcd311388a60d7dc6fdec988b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DIR&lt;/code&gt; environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The &lt;code&gt;bin&lt;/code&gt; folder under JULIA_DIR should be on the system PATH.</source>
          <target state="translated">Si la variable de entorno &lt;code&gt;JULIA_DIR&lt;/code&gt; no se ha configurado, agr&amp;eacute;guela mediante el panel Sistema antes de iniciar Visual Studio. La carpeta &lt;code&gt;bin&lt;/code&gt; bajo JULIA_DIR debe estar en la RUTA del sistema.</target>
        </trans-unit>
        <trans-unit id="17b0935fee49a1bcd1eec16c0060a0a58dff07ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will expand to a &lt;code&gt;LOAD_PATH&lt;/code&gt; value of &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. If &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;LOAD_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">Si la variable de entorno &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; ya est&amp;aacute; configurada, su valor anterior se antepondr&amp;aacute; con &lt;code&gt;/foo/bar&lt;/code&gt; . Por otro lado, si no se establece &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; , entonces se establecer&amp;aacute; en &lt;code&gt;/foo/bar:&lt;/code&gt; que se expandir&amp;aacute; a un valor &lt;code&gt;LOAD_PATH&lt;/code&gt; de &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; . Si &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; se establece en la cadena vac&amp;iacute;a, se expande a un &lt;code&gt;LOAD_PATH&lt;/code&gt; vac&amp;iacute;oformaci&amp;oacute;n. En otras palabras, la cadena vac&amp;iacute;a se interpreta como una matriz de elementos cero, no como una matriz de un elemento de la cadena vac&amp;iacute;a. Este comportamiento se eligi&amp;oacute; para que fuera posible establecer una ruta de carga vac&amp;iacute;a a trav&amp;eacute;s de la variable de entorno. Si desea que la ruta de carga por defecto, o bien desactivar la variable de entorno o si debe tener un valor, configurarlo para que la cadena &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31f515fa1981bd1d01e28ffd032994e4003fc1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;digits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">Si se proporciona el argumento de la palabra clave &lt;code&gt;digits&lt;/code&gt; , se redondea al n&amp;uacute;mero especificado de d&amp;iacute;gitos despu&amp;eacute;s del lugar decimal (o antes si es negativo), en la base &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f504c38da450ab2719c1e9cd12d8dd34afd33e92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;optimize&lt;/code&gt; keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the &lt;code&gt;raw&lt;/code&gt; keyword to true. To dump the entire module that encapsulates the function (with declarations), set the &lt;code&gt;dump_module&lt;/code&gt; keyword to true. Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of source (default) or none, to specify the verbosity of code comments.</source>
          <target state="translated">Si la palabra clave &lt;code&gt;optimize&lt;/code&gt; est&amp;aacute; establecida, el c&amp;oacute;digo se mostrar&amp;aacute; antes de las optimizaciones LLVM. Todos los metadatos y llamadas dbg. * Se eliminan del c&amp;oacute;digo de bits impreso. Para el IR completo, establezca la palabra clave sin &lt;code&gt;raw&lt;/code&gt; en verdadero. Para volcar todo el m&amp;oacute;dulo que encapsula la funci&amp;oacute;n (con declaraciones), establezca la palabra clave &lt;code&gt;dump_module&lt;/code&gt; en true. El argumento &lt;code&gt;debuginfo&lt;/code&gt; de la palabra clave puede ser fuente (predeterminado) o ninguno, para especificar la verbosidad de los comentarios del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="383ecf21766e01ab864dfe9bc7ce841c588d3356" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sigdigits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of significant digits, in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">Si se proporciona el argumento de la palabra clave &lt;code&gt;sigdigits&lt;/code&gt; , se redondea al n&amp;uacute;mero especificado de d&amp;iacute;gitos significativos, en la base &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cee1b7494eb88d56f5f87336c27b832a3eac177f" translate="yes" xml:space="preserve">
          <source>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; for the method signature of the wrapper and similarly in the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is also acceptable.</source>
          <target state="translated">Si el contenedor de C nunca espera que el usuario pase punteros a la memoria administrada por Julia, entonces tambi&amp;eacute;n es aceptable usar &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; para la firma del m&amp;eacute;todo del contenedor y de manera similar en &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e69c1bb25c07d7be2be84b2aa57348cae51e4053" translate="yes" xml:space="preserve">
          <source>If the above example source is saved in the file &lt;code&gt;embed_example.c&lt;/code&gt;, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute &lt;code&gt;clang&lt;/code&gt; for &lt;code&gt;gcc&lt;/code&gt;.:</source>
          <target state="translated">Si la fuente de ejemplo anterior est&amp;aacute; guardada en el archivo &lt;code&gt;embed_example.c&lt;/code&gt; , entonces el siguiente comando lo compilar&amp;aacute; en un programa en ejecuci&amp;oacute;n en Linux y Windows (entorno MSYS2), o si est&amp;aacute; en OS / X, entonces sustituya &lt;code&gt;clang&lt;/code&gt; por &lt;code&gt;gcc&lt;/code&gt; .:</target>
        </trans-unit>
        <trans-unit id="9e156941127d94f84d815e5639eaa0e64bcbc457" translate="yes" xml:space="preserve">
          <source>If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching &lt;code&gt;uuid&lt;/code&gt; then:</source>
          <target state="translated">Si lo anterior no es el caso y el archivo del proyecto tiene un archivo de manifiesto correspondiente y el manifiesto contiene un &lt;code&gt;uuid&lt;/code&gt; coincidente de estrofa, entonces:</target>
        </trans-unit>
        <trans-unit id="9f8fd643e0107bc4fc2c8bed2be168d68373f53a" translate="yes" xml:space="preserve">
          <source>If the alias is documented and not the real definition then the docsystem (&lt;code&gt;?&lt;/code&gt; mode) will not return the docstring attached to the alias when the real definition is searched for.</source>
          <target state="translated">Si el alias est&amp;aacute; documentado y no la definici&amp;oacute;n real, entonces el docsystem ( modo &lt;code&gt;?&lt;/code&gt; ) No devolver&amp;aacute; la cadena de documentaci&amp;oacute;n adjunta al alias cuando se busque la definici&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="f3fd8dba5118a65c9f036f4528fd62b5f0cc2628" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;Future&lt;/code&gt; is owned by a different node, this call will block to wait for the answer. It is recommended to wait for &lt;code&gt;rr&lt;/code&gt; in a separate task instead or to use a local &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; as a proxy:</source>
          <target state="translated">Si el argumento &lt;code&gt;Future&lt;/code&gt; es propiedad de un nodo diferente, esta llamada se bloquear&amp;aacute; para esperar la respuesta. En su lugar, se recomienda esperar a &lt;code&gt;rr&lt;/code&gt; en una tarea separada o usar un &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; local como proxy:</target>
        </trans-unit>
        <trans-unit id="5145bb0b73803c7679be17ccbd9728f2cf20e73d" translate="yes" xml:space="preserve">
          <source>If the condition could not be evaluated because an exception was thrown, which occurs in this case because &lt;code&gt;length&lt;/code&gt; is not defined for symbols, an &lt;code&gt;Error&lt;/code&gt; object is returned and an exception is thrown:</source>
          <target state="translated">Si la condici&amp;oacute;n no se pudo evaluar porque se lanz&amp;oacute; una excepci&amp;oacute;n, lo que ocurre en este caso porque la &lt;code&gt;length&lt;/code&gt; no est&amp;aacute; definida para los s&amp;iacute;mbolos, se devuelve un objeto &lt;code&gt;Error&lt;/code&gt; y se lanza una excepci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e94faa3d332e304494043498c5a9abf524bed6e4" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is &lt;code&gt;true&lt;/code&gt;, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. Here it is in action:</source>
          <target state="translated">Si la expresi&amp;oacute;n de condici&amp;oacute;n &lt;code&gt;x &amp;lt; y&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces se eval&amp;uacute;a el bloque correspondiente; de lo contrario, se eval&amp;uacute;a la expresi&amp;oacute;n de condici&amp;oacute;n &lt;code&gt;x &amp;gt; y&lt;/code&gt; , y si es &lt;code&gt;true&lt;/code&gt; , se eval&amp;uacute;a el bloque correspondiente; si ninguna expresi&amp;oacute;n es verdadera, se eval&amp;uacute;a el bloque &lt;code&gt;else&lt;/code&gt; . Aqu&amp;iacute; est&amp;aacute; en acci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e00b24f52421478ecff61089fe0cac3ea509a829" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used.</source>
          <target state="translated">Si la expresi&amp;oacute;n de condici&amp;oacute;n &lt;code&gt;x &amp;lt; y&lt;/code&gt; es verdadera, entonces se eval&amp;uacute;a el bloque correspondiente; de lo contrario, se eval&amp;uacute;a la expresi&amp;oacute;n de condici&amp;oacute;n &lt;code&gt;x &amp;gt; y&lt;/code&gt; , y si es verdadera, se eval&amp;uacute;a el bloque correspondiente; si ninguna expresi&amp;oacute;n es verdadera, se eval&amp;uacute;a el bloque &lt;code&gt;else&lt;/code&gt; . Los bloques &lt;code&gt;elseif&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; son opcionales y se pueden utilizar tantos bloques &lt;code&gt;elseif&lt;/code&gt; como se desee.</target>
        </trans-unit>
        <trans-unit id="03e22d8ef38f6c3785531b2aa7d1787777d83c8c" translate="yes" xml:space="preserve">
          <source>If the condition is false, then a &lt;code&gt;Fail&lt;/code&gt; is returned and an exception is thrown:</source>
          <target state="translated">Si la condici&amp;oacute;n es falsa, se devuelve un &lt;code&gt;Fail&lt;/code&gt; y se lanza una excepci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="6b3bbdbb81ff4f33d7f44d969bf8034d1606bc1e" translate="yes" xml:space="preserve">
          <source>If the condition is true, a &lt;code&gt;Pass&lt;/code&gt; is returned:</source>
          <target state="translated">Si la condici&amp;oacute;n es verdadera, se devuelve un &lt;code&gt;Pass&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cc2105b7ae7cdead96d8521e45a1f5d3d101c4e9" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, the entire ternary operator expression evaluates to the string &lt;code&gt;&quot;less than&quot;&lt;/code&gt; and otherwise it evaluates to the string &lt;code&gt;&quot;not less than&quot;&lt;/code&gt;. The original three-way example requires chaining multiple uses of the ternary operator together:</source>
          <target state="translated">Si la expresi&amp;oacute;n &lt;code&gt;x &amp;lt; y&lt;/code&gt; es verdadera, toda la expresi&amp;oacute;n del operador ternario se eval&amp;uacute;a como la cadena &lt;code&gt;&quot;less than&quot;&lt;/code&gt; y, de lo contrario, se eval&amp;uacute;a como la cadena &lt;code&gt;&quot;not less than&quot;&lt;/code&gt; . El ejemplo original de tres v&amp;iacute;as requiere encadenar m&amp;uacute;ltiples usos del operador ternario juntos:</target>
        </trans-unit>
        <trans-unit id="c1992d697b66c6b6347599acbdb8e5fdb9a6621c" translate="yes" xml:space="preserve">
          <source>If the first argument is a single integer &lt;code&gt;n&lt;/code&gt;, then all block rows are assumed to have &lt;code&gt;n&lt;/code&gt; block columns.</source>
          <target state="translated">Si el primer argumento es un solo entero &lt;code&gt;n&lt;/code&gt; , entonces se supone que todas las filas de bloque tienen &lt;code&gt;n&lt;/code&gt; columnas de bloque.</target>
        </trans-unit>
        <trans-unit id="39c79a9397806971d24321842119edaddb016dad" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Si la entrada contiene valores &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , devuelva &lt;code&gt;missing&lt;/code&gt; si todos los valores no perdidos son &lt;code&gt;false&lt;/code&gt; (o de manera equivalente, si la entrada no contiene ning&amp;uacute;n valor &lt;code&gt;true&lt;/code&gt; ), siguiendo la &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;l&amp;oacute;gica de tres valores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5db00182f423a4757b1d59390942e088eaf24587" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Si la entrada contiene valores &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , devuelva &lt;code&gt;missing&lt;/code&gt; si todos los valores no perdidos son &lt;code&gt;true&lt;/code&gt; (o de manera equivalente, si la entrada no contiene valores &lt;code&gt;false&lt;/code&gt; ), siguiendo la &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;l&amp;oacute;gica de tres valores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8eeb9c03396e664e28a99fc47d48774045eb6d62" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Si la entrada contiene valores &lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , devuelva &lt;code&gt;missing&lt;/code&gt; si todos los valores no perdidos son &lt;code&gt;false&lt;/code&gt; (o de manera equivalente, si la entrada no contiene ning&amp;uacute;n valor &lt;code&gt;true&lt;/code&gt; ), siguiendo la &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;l&amp;oacute;gica de tres valores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2728419995e95b64eb82cdbd209797e56617a7a2" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Si la entrada contiene valores &lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , devuelva &lt;code&gt;missing&lt;/code&gt; si todos los valores no perdidos son &lt;code&gt;true&lt;/code&gt; (o de manera equivalente, si la entrada no contiene valores &lt;code&gt;false&lt;/code&gt; ), siguiendo la &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;l&amp;oacute;gica de tres valores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43376b031124803be76025ed520e15accd07f21d" translate="yes" xml:space="preserve">
          <source>If the julia program needs to access symbols from the main executable, it may be necessary to add &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; linker flag at compile time on Linux in addition to the ones generated by &lt;code&gt;julia-config.jl&lt;/code&gt; described below. This is not necessary when compiling a shared library.</source>
          <target state="translated">Si el programa julia necesita acceder a los s&amp;iacute;mbolos del ejecutable principal, puede ser necesario agregar &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; indicador del enlazador din&amp;aacute;mico de exportaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n en Linux, adem&amp;aacute;s de los generados por &lt;code&gt;julia-config.jl&lt;/code&gt; que se describen a continuaci&amp;oacute;n. Esto no es necesario al compilar una biblioteca compartida.</target>
        </trans-unit>
        <trans-unit id="a36bc8b8e7c85e66ed4f1f189a3aca52b1c00920" translate="yes" xml:space="preserve">
          <source>If the keyword argument &lt;code&gt;parallel&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;peakflops&lt;/code&gt; is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument &lt;code&gt;n&lt;/code&gt; still refers to the size of the problem that is solved on each processor.</source>
          <target state="translated">Si el argumento de la palabra clave &lt;code&gt;parallel&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;peakflops&lt;/code&gt; se ejecuta en paralelo en todos los procesadores de trabajo. Se devuelve la tasa de flop de toda la computadora paralela. Cuando se ejecuta en paralelo, solo se utiliza 1 hilo BLAS. El argumento &lt;code&gt;n&lt;/code&gt; todav&amp;iacute;a se refiere al tama&amp;ntilde;o del problema que se resuelve en cada procesador.</target>
        </trans-unit>
        <trans-unit id="8e60aaeb2ffed3f0c824ded63844d08244a81e67" translate="yes" xml:space="preserve">
          <source>If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.</source>
          <target state="translated">Si el último componente de un camino contiene un punto,divide el camino en todo lo que está antes del punto y todo lo que está incluido y después del punto.En caso contrario,devuelve una tupla del argumento sin modificar y la cadena vacía.</target>
        </trans-unit>
        <trans-unit id="474f41b19a8b8b1c73bfdf0eee429dd261cef652" translate="yes" xml:space="preserve">
          <source>If the library cannot be found, this method throws an error, unless the keyword argument &lt;code&gt;throw_error&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, in which case this method returns &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">Si no se puede encontrar la biblioteca, este m&amp;eacute;todo arroja un error, a menos que el argumento de palabra clave &lt;code&gt;throw_error&lt;/code&gt; est&amp;eacute; establecido en &lt;code&gt;false&lt;/code&gt; , en cuyo caso este m&amp;eacute;todo &lt;code&gt;nothing&lt;/code&gt; devuelve nada .</target>
        </trans-unit>
        <trans-unit id="87fd4485b83cceeff36ce0886165792add3d72c0" translate="yes" xml:space="preserve">
          <source>If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt;. The value of &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; on the master process specifies the number of seconds a newly launched worker waits for connection establishment.</source>
          <target state="translated">Si el proceso maestro no logra establecer una conexi&amp;oacute;n con un trabajador reci&amp;eacute;n iniciado en 60.0 segundos, el trabajador lo trata como una situaci&amp;oacute;n fatal y termina. Este tiempo de espera se puede controlar mediante la variable de entorno &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; . El valor de &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; en el proceso maestro especifica la cantidad de segundos que un trabajador reci&amp;eacute;n lanzado espera para establecer la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1862e9ef97d71a1468775f4ed8202c8fd632c055" translate="yes" xml:space="preserve">
          <source>If the memory is already owned by Julia, or is an &lt;code&gt;isbits&lt;/code&gt; type, and is known to be non-null:</source>
          <target state="translated">Si la memoria ya es propiedad de Julia, o es del tipo &lt;code&gt;isbits&lt;/code&gt; , y se sabe que no es nula:</target>
        </trans-unit>
        <trans-unit id="da0b487002a4f8f988224bf9329d865f41bc0778" translate="yes" xml:space="preserve">
          <source>If the memory is owned by C:</source>
          <target state="translated">Si la memoria es propiedad de C:</target>
        </trans-unit>
        <trans-unit id="f1a7911f936ea8810a1eaa7a8869f8e6799d2d65" translate="yes" xml:space="preserve">
          <source>If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:</source>
          <target state="translated">Si el numerador y el denominador de un racional tienen factores comunes,se reducen a los términos más bajos de manera que el denominador no sea negativo:</target>
        </trans-unit>
        <trans-unit id="0a769d477ab736aacb751c850c5686d3d0e58a61" translate="yes" xml:space="preserve">
          <source>If the optional vector of eigenvalues &lt;code&gt;eigvals&lt;/code&gt; is specified, &lt;code&gt;eigvecs&lt;/code&gt; returns the specific corresponding eigenvectors.</source>
          <target state="translated">Si se especifica el vector opcional de autovalores &lt;code&gt;eigvals&lt;/code&gt; , &lt;code&gt;eigvecs&lt;/code&gt; devuelve los autovectores correspondientes espec&amp;iacute;ficos.</target>
        </trans-unit>
        <trans-unit id="0f4dba4502da69dc32bb858b6da003d9801f45e4" translate="yes" xml:space="preserve">
          <source>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call &lt;code&gt;free(ptr)&lt;/code&gt; when the returned &lt;code&gt;Array&lt;/code&gt; object is finalized. If the &lt;code&gt;own&lt;/code&gt; parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</source>
          <target state="translated">Si el puntero de inter&amp;eacute;s es una matriz de datos simples (tipo primitivo o estructura inmutable), la funci&amp;oacute;n &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; puede ser m&amp;aacute;s &amp;uacute;til. El par&amp;aacute;metro final deber&amp;iacute;a ser verdadero si Julia deber&amp;iacute;a &quot;tomar posesi&amp;oacute;n&quot; del b&amp;uacute;fer subyacente y llamar a &lt;code&gt;free(ptr)&lt;/code&gt; cuando finalice el objeto &lt;code&gt;Array&lt;/code&gt; devuelto . Si el &lt;code&gt;own&lt;/code&gt; par&amp;aacute;metro se omite o es falso, la persona que llama debe asegurarse de que el b&amp;uacute;fer siga existiendo hasta que se complete todo el acceso.</target>
        </trans-unit>
        <trans-unit id="0a512e781dfe335955a62e8e7a271098861da5ec" translate="yes" xml:space="preserve">
          <source>If the project file in the directory matches &lt;code&gt;uuid&lt;/code&gt; and name &lt;code&gt;X&lt;/code&gt;, then either:</source>
          <target state="translated">Si el archivo del proyecto en el directorio coincide con &lt;code&gt;uuid&lt;/code&gt; y el nombre &lt;code&gt;X&lt;/code&gt; , entonces:</target>
        </trans-unit>
        <trans-unit id="bf4eb78a003bcabdcd8e4f19b55a5c4f0ed307f6" translate="yes" xml:space="preserve">
          <source>If the regular expression does not match the given string, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; &amp;ndash; a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</source>
          <target state="translated">Si la expresi&amp;oacute;n regular no coincide con la cadena dada, la &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; devuelve nada , un valor especial que no imprime nada en el indicador interactivo. Aparte de no imprimir, es un valor completamente normal y puede probarlo mediante programaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="ee4c72df00bad1d261a873768e4600ba229c34af" translate="yes" xml:space="preserve">
          <source>If the type were declared &lt;code&gt;mutable&lt;/code&gt;, you could reach in and directly change the field values to violate this invariant. Of course, messing around with an object's internals uninvited is bad practice. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's invariants.</source>
          <target state="translated">Si el tipo se declara &lt;code&gt;mutable&lt;/code&gt; , puede acceder y cambiar directamente los valores del campo para violar este invariante. Por supuesto, jugar con las partes internas de un objeto sin ser invitado es una mala pr&amp;aacute;ctica. Usted (u otra persona) tambi&amp;eacute;n puede proporcionar m&amp;eacute;todos constructores externos adicionales en cualquier momento posterior, pero una vez que se declara un tipo, no hay forma de agregar m&amp;aacute;s m&amp;eacute;todos constructores internos. Dado que los m&amp;eacute;todos de constructor externos solo pueden crear objetos llamando a otros m&amp;eacute;todos de constructor, en &amp;uacute;ltima instancia, se debe llamar a alg&amp;uacute;n constructor interno para crear un objeto. Esto garantiza que todos los objetos del tipo declarado deben existir mediante una llamada a uno de los m&amp;eacute;todos constructores internos proporcionados con el tipo, lo que proporciona cierto grado de aplicaci&amp;oacute;n de los invariantes de un tipo.</target>
        </trans-unit>
        <trans-unit id="01f0d92fa173f69330393a510ea1e6b5d8ca8533" translate="yes" xml:space="preserve">
          <source>If the value of the environment variable begins with the character &lt;code&gt;'r'&lt;/code&gt;, then the interval between garbage collection events is randomized.</source>
          <target state="translated">Si el valor de la variable de entorno comienza con el car&amp;aacute;cter &lt;code&gt;'r'&lt;/code&gt; , entonces el intervalo entre los eventos de recolecci&amp;oacute;n de basura es aleatorio.</target>
        </trans-unit>
        <trans-unit id="820aaeab0441978d6dfdcb42b5456e2d42286bc7" translate="yes" xml:space="preserve">
          <source>If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a &lt;code&gt;RefValue{Any}&lt;/code&gt; before it is pushed to &lt;code&gt;IdDict&lt;/code&gt;. In this approach, the container has to be created or filled in via C code using, for example, the function &lt;code&gt;jl_new_struct&lt;/code&gt;. If the container is created by &lt;code&gt;jl_call*&lt;/code&gt;, then you will need to reload the pointer to be used in C code.</source>
          <target state="translated">Si la variable es inmutable, entonces debe estar envuelta en un contenedor mutable equivalente o, preferiblemente, en un &lt;code&gt;RefValue{Any}&lt;/code&gt; antes de ser empujada a &lt;code&gt;IdDict&lt;/code&gt; . En este enfoque, el contenedor debe crearse o completarse mediante c&amp;oacute;digo C utilizando, por ejemplo, la funci&amp;oacute;n &lt;code&gt;jl_new_struct&lt;/code&gt; . Si el contenedor es creado por &lt;code&gt;jl_call*&lt;/code&gt; , entonces deber&amp;aacute; volver a cargar el puntero para usarlo en c&amp;oacute;digo C.</target>
        </trans-unit>
        <trans-unit id="fdaae9a23c5ac63bef99dbd5a31ebb51593f593b" translate="yes" xml:space="preserve">
          <source>If these default definitions are not wanted, modules can be defined using the keyword &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt; instead (note: &lt;code&gt;Core&lt;/code&gt; is still imported, as per above). In terms of &lt;code&gt;baremodule&lt;/code&gt;, a standard &lt;code&gt;module&lt;/code&gt; looks like this:</source>
          <target state="translated">Si no se desean estas definiciones predeterminadas, los m&amp;oacute;dulos se pueden definir utilizando la palabra clave &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; &lt;/a&gt; en su lugar (nota: &lt;code&gt;Core&lt;/code&gt; todav&amp;iacute;a se importa, como se indic&amp;oacute; anteriormente). En t&amp;eacute;rminos de &lt;code&gt;baremodule&lt;/code&gt; , un &lt;code&gt;module&lt;/code&gt; est&amp;aacute;ndar se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="c97bc8058490cb5b35c86c1a7b0a8b4a5dcbea0d" translate="yes" xml:space="preserve">
          <source>If this example were rewritten to use a &lt;code&gt;for&lt;/code&gt; keyword for each variable, then the output would be different: the second and fourth values would contain &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Si este ejemplo se reescrito para usar una &lt;code&gt;for&lt;/code&gt; palabra clave para cada variable, entonces la salida ser&amp;iacute;a diferente: el segundo y cuarto valores contendr&amp;iacute;an &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38daf5829da47e0525cef7ca98a723264df0b06d" translate="yes" xml:space="preserve">
          <source>If this file refers to a device, the ID of the device it refers to</source>
          <target state="translated">Si este archivo se refiere a un dispositivo,el ID del dispositivo al que se refiere</target>
        </trans-unit>
        <trans-unit id="0d9cafaaf4c7067eb590c8bf606a63edc65e8a80" translate="yes" xml:space="preserve">
          <source>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</source>
          <target state="translated">Si se trata de un bloqueo recursivo que ha sido adquirido antes,disminuya un contador interno y regrese inmediatamente.</target>
        </trans-unit>
        <trans-unit id="63b7f441c98451c302d3c2456a6e97efda6509d1" translate="yes" xml:space="preserve">
          <source>If this is all extremely confusing, try reading &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets&quot;&lt;/a&gt;. It's an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.</source>
          <target state="translated">Si todo esto es extremadamente confuso, intente leer &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;El m&amp;iacute;nimo absoluto que todo desarrollador de software debe conocer absoluta y positivamente sobre Unicode y conjuntos de caracteres&quot;&lt;/a&gt; . Es una excelente introducci&amp;oacute;n a Unicode y UTF-8, y puede ayudar a aliviar cierta confusi&amp;oacute;n sobre el tema.</target>
        </trans-unit>
        <trans-unit id="3b40c130d40171e44a3b89ef397dcc6ac5ad60b6" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;code&gt;rmprocs&lt;/code&gt; will wait until all requested &lt;code&gt;pids&lt;/code&gt; are removed.</source>
          <target state="translated">Si no se especifica, &lt;code&gt;rmprocs&lt;/code&gt; esperar&amp;aacute; hasta que se eliminen todos los &lt;code&gt;pids&lt;/code&gt; solicitados .</target>
        </trans-unit>
        <trans-unit id="7a6ee4e75683acdd450d6763b02459999f504699" translate="yes" xml:space="preserve">
          <source>If we also wanted to test the debug messages, these need to be enabled with the &lt;code&gt;min_level&lt;/code&gt; keyword:</source>
          <target state="translated">Si tambi&amp;eacute;n quisi&amp;eacute;ramos probar los mensajes de depuraci&amp;oacute;n, estos deben habilitarse con la palabra clave &lt;code&gt;min_level&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="61986d68f0f6799ea1176f1c31636a4efe0c3579" translate="yes" xml:space="preserve">
          <source>If we create &lt;code&gt;SharedArray&lt;/code&gt;s and time these functions, we get the following results (with &lt;code&gt;julia -p 4&lt;/code&gt;):</source>
          <target state="translated">Si creamos &lt;code&gt;SharedArray&lt;/code&gt; sy cronometramos estas funciones, obtenemos los siguientes resultados (con &lt;code&gt;julia -p 4&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="a1227c57ad13fa72c3a7892e71df86ffd4baf6f1" translate="yes" xml:space="preserve">
          <source>If we expect that evaluating an expression &lt;em&gt;should&lt;/em&gt; throw an exception, then we can use &lt;code&gt;@test_throws&lt;/code&gt; to check that this occurs:</source>
          <target state="translated">Si esperamos que la evaluaci&amp;oacute;n de una expresi&amp;oacute;n &lt;em&gt;debe&lt;/em&gt; lanzar una excepci&amp;oacute;n, entonces podemos utilizar &lt;code&gt;@test_throws&lt;/code&gt; para comprobar que esto ocurre:</target>
        </trans-unit>
        <trans-unit id="0245cafc71ed8d5f923ae289b03588ae96f1d3b5" translate="yes" xml:space="preserve">
          <source>If we instead pass &lt;code&gt;x&lt;/code&gt; as an argument to the function it no longer allocates memory (the allocation reported below is due to running the &lt;code&gt;@time&lt;/code&gt; macro in global scope) and is significantly faster after the first call:</source>
          <target state="translated">Si, en cambio, pasamos &lt;code&gt;x&lt;/code&gt; como argumento a la funci&amp;oacute;n, ya no asigna memoria (la asignaci&amp;oacute;n informada a continuaci&amp;oacute;n se debe a la ejecuci&amp;oacute;n de la macro &lt;code&gt;@time&lt;/code&gt; en el alcance global) y es significativamente m&amp;aacute;s r&amp;aacute;pida despu&amp;eacute;s de la primera llamada:</target>
        </trans-unit>
        <trans-unit id="ad5a88256f096da52ec6c3ef7cb82d3f97728f34" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="translated">Si queremos que se muestre en su lugar como &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt; , definir&amp;iacute;amos el siguiente m&amp;eacute;todo para imprimir el objeto en un objeto de salida dado &lt;code&gt;io&lt;/code&gt; (que representa un archivo, terminal, b&amp;uacute;fer, etc&amp;eacute;tera; consulte &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Redes y flujos&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="a3d5a08a0cd3e04540689d3b049bf572b10229ab" translate="yes" xml:space="preserve">
          <source>If you apply &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt; to other type objects (or non-type objects), a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised:</source>
          <target state="translated">Si aplica &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt; a otros objetos de tipo (u objetos que no son de tipo), se &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; un MethodError :</target>
        </trans-unit>
        <trans-unit id="a311e1352bca4f5ac56973ae4e9111089c7fd93d" translate="yes" xml:space="preserve">
          <source>If you are defining a method &quot;cascade&quot; that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:</source>
          <target state="translated">Si está definiendo un método &quot;en cascada&quot; que suministra valores por defecto,tenga cuidado de no dejar caer ningún argumento que corresponda a potenciales valores por defecto.Por ejemplo,suponga que está escribiendo un algoritmo de filtrado digital y tiene un método que maneja los bordes de la señal aplicando un relleno:</target>
        </trans-unit>
        <trans-unit id="1ec45be5f3cad18e0598bb550f7ab8781aa51939" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; definiendo un tipo de matriz que permite la indexaci&amp;oacute;n no tradicional (&amp;iacute;ndices que comienzan en algo distinto de 1), debe especializar los &lt;code&gt;axes&lt;/code&gt; . Tambi&amp;eacute;n debe especializarse &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; es&lt;/a&gt; para que el &lt;code&gt;dims&lt;/code&gt; argumento (normalmente un &lt;code&gt;Dims&lt;/code&gt; tama&amp;ntilde;o-tupla) puede aceptar &lt;code&gt;AbstractUnitRange&lt;/code&gt; objetos, quiz&amp;aacute; rango tipos &lt;code&gt;Ind&lt;/code&gt; de su propio dise&amp;ntilde;o. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Matrices con &amp;iacute;ndices personalizados&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e74f29b3463d83a18c14379e83918c00f3cf63aa" translate="yes" xml:space="preserve">
          <source>If you are ever stuck, you can ask &lt;code&gt;Pkg&lt;/code&gt; for help:</source>
          <target state="translated">Si alguna vez te quedas atascado, puedes pedir ayuda a &lt;code&gt;Pkg&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8735c4e810f6e4e3ffda27e1b3f1ab39f60104c6" translate="yes" xml:space="preserve">
          <source>If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into &lt;code&gt;libjulia&lt;/code&gt; with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.</source>
          <target state="translated">Si est&amp;aacute; utilizando la API de Julia C desde un lenguaje que admite excepciones (p. Ej., Python, C #, C ++), tiene sentido envolver cada llamada en &lt;code&gt;libjulia&lt;/code&gt; con una funci&amp;oacute;n que verifique si se lanz&amp;oacute; una excepci&amp;oacute;n y luego volver&amp;aacute; a generar la excepci&amp;oacute;n en el idioma anfitri&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9d33189460471265e09a2493a0c7846b4727b27d" translate="yes" xml:space="preserve">
          <source>If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:</source>
          <target state="translated">Si lo llamas en una sesión interactiva sin asignar el valor de retorno en ningún lugar,verás la tupla devuelta:</target>
        </trans-unit>
        <trans-unit id="757e93c7d7c03576f2e8bdb2961d5a609265324d" translate="yes" xml:space="preserve">
          <source>If you define both styles of indexing for your &lt;code&gt;AbstractArray&lt;/code&gt;, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; creates an iterator whose type depends on the setting of this trait.</source>
          <target state="translated">Si define ambos estilos de indexaci&amp;oacute;n para su &lt;code&gt;AbstractArray&lt;/code&gt; , este rasgo se puede utilizar para seleccionar el estilo de indexaci&amp;oacute;n m&amp;aacute;s eficaz. Algunos m&amp;eacute;todos verifican este rasgo en sus entradas y lo env&amp;iacute;an a diferentes algoritmos seg&amp;uacute;n el patr&amp;oacute;n de acceso m&amp;aacute;s eficiente. En particular, cada &lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; crea un iterador cuyo tipo depende de la configuraci&amp;oacute;n de este rasgo.</target>
        </trans-unit>
        <trans-unit id="0561f634340ef3ef5927debe41e5dcc4c8cce30a" translate="yes" xml:space="preserve">
          <source>If you examine the contents of &lt;code&gt;hello.txt&lt;/code&gt; at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the &lt;code&gt;IOStream&lt;/code&gt; must be closed before the write is actually flushed to disk:</source>
          <target state="translated">Si examina el contenido de &lt;code&gt;hello.txt&lt;/code&gt; en este punto, notar&amp;aacute; que est&amp;aacute; vac&amp;iacute;o; todav&amp;iacute;a no se ha escrito nada en el disco. Esto se debe a que &lt;code&gt;IOStream&lt;/code&gt; debe cerrarse antes de que la escritura se vac&amp;iacute;e realmente en el disco:</target>
        </trans-unit>
        <trans-unit id="4eaa143836add2b691eb62610bcaeb5c4d609829" translate="yes" xml:space="preserve">
          <source>If you have a type that uses a native pointer:</source>
          <target state="translated">Si tienes un tipo que usa un puntero nativo:</target>
        </trans-unit>
        <trans-unit id="aaf9e1541b4bdb0c52c8f375b573b49db90dd938" translate="yes" xml:space="preserve">
          <source>If you have code that you want executed whenever Julia is run, you can put it in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Si tiene un c&amp;oacute;digo que desea ejecutar siempre que se ejecute Julia, puede ponerlo en &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6993e56b8a3ed1437873eaf20d58be9dd8dc4fb" translate="yes" xml:space="preserve">
          <source>If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your &lt;code&gt;SparseMatrixCSC&lt;/code&gt; object contains unsorted row indices, one quick way to sort them is by doing a double transpose.</source>
          <target state="translated">Si tiene datos en formato CSC de una aplicaci&amp;oacute;n o biblioteca diferente y desea importarlos en Julia, aseg&amp;uacute;rese de usar la indexaci&amp;oacute;n basada en 1. Los &amp;iacute;ndices de fila de cada columna deben ordenarse. Si su objeto &lt;code&gt;SparseMatrixCSC&lt;/code&gt; contiene &amp;iacute;ndices de fila sin clasificar, una forma r&amp;aacute;pida de ordenarlos es haciendo una doble transposici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="be1012643129d3902e3bcc736a2f09368b135cc7" translate="yes" xml:space="preserve">
          <source>If you interpolate an array as part of a shell word, Julia emulates the shell's &lt;code&gt;{a,b,c}&lt;/code&gt; argument generation:</source>
          <target state="translated">Si interpola una matriz como parte de una palabra de shell, Julia emula la generaci&amp;oacute;n de argumentos &lt;code&gt;{a,b,c}&lt;/code&gt; del shell :</target>
        </trans-unit>
        <trans-unit id="66c0ea7806057d283c6cb2263bc03f2b5f51cca2" translate="yes" xml:space="preserve">
          <source>If you know that a module is &lt;em&gt;not&lt;/em&gt; safe to precompile your module (for example, for one of the reasons described below), you should put &lt;code&gt;__precompile__(false)&lt;/code&gt; in the module file (typically placed at the top). This will cause &lt;code&gt;Base.compilecache&lt;/code&gt; to throw an error, and will cause &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</source>
          <target state="translated">Si sabe que un m&amp;oacute;dulo &lt;em&gt;no&lt;/em&gt; es seguro para precompilar su m&amp;oacute;dulo (por ejemplo, por una de las razones que se describen a continuaci&amp;oacute;n), debe poner &lt;code&gt;__precompile__(false)&lt;/code&gt; en el archivo del m&amp;oacute;dulo (normalmente se coloca en la parte superior). Esto har&amp;aacute; que &lt;code&gt;Base.compilecache&lt;/code&gt; arroje un error y har&amp;aacute; que el &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; lo cargue directamente en el proceso actual y omita la precompilaci&amp;oacute;n y el almacenamiento en cach&amp;eacute;. Esto tambi&amp;eacute;n evita que el m&amp;oacute;dulo sea importado por cualquier otro m&amp;oacute;dulo precompilado.</target>
        </trans-unit>
        <trans-unit id="9119dc7e0716f5e2cbcc069fcd20399d5871b899" translate="yes" xml:space="preserve">
          <source>If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a &quot;name cascade&quot; where (for example) you dispatch on the first argument and then call an internal method:</source>
          <target state="translated">Si se necesita despachar con múltiples argumentos,y hay muchos inconvenientes con demasiadas combinaciones para que sea práctico definir todas las variantes posibles,entonces considere la posibilidad de introducir una &quot;cascada de nombres&quot; en la que (por ejemplo)se despacha con el primer argumento y luego se llama a un método interno:</target>
        </trans-unit>
        <trans-unit id="76f3bebbfec4cfb424affa402369c33eff6a7949" translate="yes" xml:space="preserve">
          <source>If you need to obtain valid indices for a string, you can use the &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt;&lt;code&gt;prevind&lt;/code&gt;&lt;/a&gt; functions to increment/decrement to the next/previous valid index, as mentioned above. You can also use the &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; function to iterate over the valid character indices:</source>
          <target state="translated">Si necesita obtener &amp;iacute;ndices v&amp;aacute;lidos para una cadena, puede usar las funciones &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt; &lt;code&gt;prevind&lt;/code&gt; &lt;/a&gt; para incrementar / disminuir al &amp;iacute;ndice v&amp;aacute;lido siguiente / anterior, como se mencion&amp;oacute; anteriormente. Tambi&amp;eacute;n puede utilizar la funci&amp;oacute;n &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; para iterar sobre los &amp;iacute;ndices de caracteres v&amp;aacute;lidos:</target>
        </trans-unit>
        <trans-unit id="801f3bd6c180fb1f8c8c459f54a17ac585429686" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;branch&lt;/code&gt;, this must be done in reference format, since the string will be turned into a &lt;code&gt;GitReference&lt;/code&gt;. For example, if you wanted to merge branch &lt;code&gt;branch_a&lt;/code&gt;, you would call &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt;.</source>
          <target state="translated">Si especifica una &lt;code&gt;branch&lt;/code&gt; , debe hacerlo en formato de referencia, ya que la cadena se convertir&amp;aacute; en una &lt;code&gt;GitReference&lt;/code&gt; . Por ejemplo, si desea fusionar la rama &lt;code&gt;branch_a&lt;/code&gt; , debe llamar a &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12b4daadf4d05ca4bd1781bb32cf57f260bb2750" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, &lt;code&gt;eachindex&lt;/code&gt; will return an iterable that spans the largest range along each dimension.</source>
          <target state="translated">Si proporciona m&amp;aacute;s de un argumento &lt;code&gt;AbstractArray&lt;/code&gt; , cada &lt;code&gt;eachindex&lt;/code&gt; crear&amp;aacute; un objeto iterable que es r&amp;aacute;pido para todos los argumentos (un &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt; si todas las entradas tienen indexaci&amp;oacute;n lineal r&amp;aacute;pida, un &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; en&lt;/a&gt; caso contrario). Si las matrices tienen diferentes tama&amp;ntilde;os y / o dimensionalidades, cada &lt;code&gt;eachindex&lt;/code&gt; devolver&amp;aacute; un iterable que abarca el rango m&amp;aacute;s grande a lo largo de cada dimensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0bf64552bec6648b4a2dbc60f5636537b6e39be4" translate="yes" xml:space="preserve">
          <source>If you want a quantity that is of the same type as &lt;code&gt;x&lt;/code&gt;, or of type &lt;code&gt;T&lt;/code&gt;, even if &lt;code&gt;x&lt;/code&gt; is dimensionful, use &lt;a href=&quot;#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Si desea una cantidad que sea del mismo tipo que &lt;code&gt;x&lt;/code&gt; , o del tipo &lt;code&gt;T&lt;/code&gt; , incluso si &lt;code&gt;x&lt;/code&gt; es dimensional, utilice una &lt;a href=&quot;#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="0d6bdd166c95ac54bc84be65e3c70b26b5a5d3fc" translate="yes" xml:space="preserve">
          <source>If you want to &lt;em&gt;avoid&lt;/em&gt; adding dots for selected function calls in &lt;code&gt;expr&lt;/code&gt;, splice those function calls in with &lt;code&gt;$&lt;/code&gt;. For example, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; is equivalent to &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (no dot for &lt;code&gt;sort&lt;/code&gt;).</source>
          <target state="translated">Si desea &lt;em&gt;evitar&lt;/em&gt; agregar puntos para las llamadas a funciones seleccionadas en &lt;code&gt;expr&lt;/code&gt; , empalme esas llamadas a funciones con &lt;code&gt;$&lt;/code&gt; . Por ejemplo, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; es equivalente a &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (sin punto para &lt;code&gt;sort&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="683a65524138ed99d613028444b793379d0ca4fd" translate="yes" xml:space="preserve">
          <source>If you want to extract a character from a string, you index into it:</source>
          <target state="translated">Si quieres extraer un personaje de una cadena,lo indexas:</target>
        </trans-unit>
        <trans-unit id="af6bdcdecfb445706192e5de8fd952192d9e2d0e" translate="yes" xml:space="preserve">
          <source>If you want to read the output of the external command, &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; can be used instead:</source>
          <target state="translated">Si desea leer la salida del comando externo, puede usar &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; en&lt;/a&gt; su lugar:</target>
        </trans-unit>
        <trans-unit id="66677df9764417ef6a9289f8e4f6bf8274c36caa" translate="yes" xml:space="preserve">
          <source>If you want to use logging as an audit trail you should disable this for your logger type.</source>
          <target state="translated">Si desea utilizar el registro como una pista de auditoría,debe desactivarlo para su tipo de registro.</target>
        </trans-unit>
        <trans-unit id="e7c7d63501e2b9d2d6b42831c4f6216f8a461efd" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, you can open it with the write (&lt;code&gt;&quot;w&quot;&lt;/code&gt;) flag:</source>
          <target state="translated">Si desea escribir en un archivo, puede abrirlo con la marca de escritura ( &lt;code&gt;&quot;w&quot;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="c3b03f51e5a4a15df40aa0cdfd2977b041193157" translate="yes" xml:space="preserve">
          <source>If you were to profile &lt;code&gt;dumbsum3&lt;/code&gt;, and a backtrace was taken while it was executing &lt;code&gt;dumbsum(1)&lt;/code&gt;, the backtrace would look like this:</source>
          <target state="translated">Si &lt;code&gt;dumbsum3&lt;/code&gt; perfilar dumbsum3 y se realiz&amp;oacute; un backtrace mientras se ejecutaba &lt;code&gt;dumbsum(1)&lt;/code&gt; , el backtrace se ver&amp;iacute;a as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="0bc4f596ffa41c5fb93ede00ad1673e3a89c26be" translate="yes" xml:space="preserve">
          <source>If you wish to specialize on a particular style &lt;code&gt;DestStyle&lt;/code&gt;, define a method for</source>
          <target state="translated">Si desea especializarse en un estilo &lt;code&gt;DestStyle&lt;/code&gt; en particular , defina un m&amp;eacute;todo para</target>
        </trans-unit>
        <trans-unit id="f81fa178f278896f499b8c79cc33cce8975b52ac" translate="yes" xml:space="preserve">
          <source>If you write a custom &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; type, you can specify that it has fast linear indexing using</source>
          <target state="translated">Si escribe un tipo &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; personalizado , puede especificar que tenga una indexaci&amp;oacute;n lineal r&amp;aacute;pida usando</target>
        </trans-unit>
        <trans-unit id="731e84cb8afd8370c60140146ac6c2a5c345b233" translate="yes" xml:space="preserve">
          <source>If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.</source>
          <target state="translated">Si se escribe un código genérico que maneja números,y que se puede esperar que se ejecute con muchos argumentos de tipo numérico diferentes,trate de utilizar literales de tipo numérico que afecten los argumentos lo menos posible a través de la promoción.</target>
        </trans-unit>
        <trans-unit id="dcea13c507e05364e2e2a422c4d4bb092770bc50" translate="yes" xml:space="preserve">
          <source>If your array type does have fixed dimensionality requirements, then you should subtype &lt;code&gt;AbstractArrayStyle&lt;/code&gt;. For example, the sparse array code has the following definitions:</source>
          <target state="translated">Si su tipo de matriz tiene requisitos de dimensionalidad fijos, entonces debe subtipificar &lt;code&gt;AbstractArrayStyle&lt;/code&gt; . Por ejemplo, el c&amp;oacute;digo de matriz dispersa tiene las siguientes definiciones:</target>
        </trans-unit>
        <trans-unit id="86e175e64e8da6c7e916078c1c6ea2b5a935db82" translate="yes" xml:space="preserve">
          <source>If your code has recursion, one potentially-confusing point is that a line in a &quot;child&quot; function can accumulate more counts than there are total backtraces. Consider the following function definitions:</source>
          <target state="translated">Si su código tiene recursividad,un punto potencialmente confuso es que una línea en una función &quot;infantil&quot; puede acumular más conteos que el total de retrocesos.Considere las siguientes definiciones de funciones:</target>
        </trans-unit>
        <trans-unit id="aa3f9be2eca1806a6c02bd56dca6f747bcc2726c" translate="yes" xml:space="preserve">
          <source>If your function returns an &lt;code&gt;Array&lt;/code&gt; or some other complex type, it may have to allocate memory. Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.</source>
          <target state="translated">Si su funci&amp;oacute;n devuelve una &lt;code&gt;Array&lt;/code&gt; o alg&amp;uacute;n otro tipo complejo, es posible que deba asignar memoria. Desafortunadamente, a menudo la asignaci&amp;oacute;n y su inverso, la recolecci&amp;oacute;n de basura, son cuellos de botella sustanciales.</target>
        </trans-unit>
        <trans-unit id="203770fc43c2ec3f449524fb36ddffdf662a89aa" translate="yes" xml:space="preserve">
          <source>If, on the other hand, Julia was loading the &lt;em&gt;other&lt;/em&gt;&lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt;&amp;mdash;it finds its stanza in the manifest, see that it does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;path&lt;/code&gt; entry, but that it does have a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry. It then computes the &lt;code&gt;slug&lt;/code&gt; for this UUID/SHA-1 pair, which is &lt;code&gt;HDkrT&lt;/code&gt; (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this &lt;code&gt;Priv&lt;/code&gt; package will be &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; in one of the package depots. Suppose the contents of &lt;code&gt;DEPOT_PATH&lt;/code&gt; is &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt;, then Julia will look at the following paths to see if they exist:</source>
          <target state="translated">Si, por otro lado, Julia estaba cargando el &lt;em&gt;otro&lt;/em&gt; paquete &lt;code&gt;Priv&lt;/code&gt; , el que tiene UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt; , encuentra su estrofa en el manifiesto, vea que &lt;em&gt;no&lt;/em&gt; tiene una entrada de &lt;code&gt;path&lt;/code&gt; , pero que tiene una entrada &lt;code&gt;git-tree-sha1&lt;/code&gt; . Luego calcula el &lt;code&gt;slug&lt;/code&gt; para este par UUID / SHA-1, que es &lt;code&gt;HDkrT&lt;/code&gt; (los detalles exactos de este c&amp;aacute;lculo no son importantes, pero es consistente y determinista). Esto significa que la ruta a este paquete &lt;code&gt;Priv&lt;/code&gt; ser&amp;aacute; &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; en uno de los dep&amp;oacute;sitos de paquetes. Suponga que el contenido de &lt;code&gt;DEPOT_PATH&lt;/code&gt; es &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt; , luego Julia buscar&amp;aacute; en las siguientes rutas para ver si existen:</target>
        </trans-unit>
        <trans-unit id="08884ba6d9fbd224895a7cbdeceeec1f4c59bf40" translate="yes" xml:space="preserve">
          <source>Image Of</source>
          <target state="translated">Imagen de</target>
        </trans-unit>
        <trans-unit id="6ea4ebbef3751656124627e822bd05d7b6569f88" translate="yes" xml:space="preserve">
          <source>Image Of Or Approximately Equal To</source>
          <target state="translated">Imagen de o aproximadamente igual a</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="a1dd283e60c10a07da0fde84cdded35b0d62bc7f" translate="yes" xml:space="preserve">
          <source>Immediately run finalizers registered for object &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Ejecute inmediatamente los finalizadores registrados para el objeto &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f8a84e660062cc9351aa99e4736b44741ec8c96" translate="yes" xml:space="preserve">
          <source>Immutable composite types with no fields are singletons; there can be only one instance of such types:</source>
          <target state="translated">Los tipos compuestos inmutables sin campos son monolitos;sólo puede haber una instancia de tales tipos:</target>
        </trans-unit>
        <trans-unit id="546c2aff0baec3bbc325a5abd6340afd6a503d6d" translate="yes" xml:space="preserve">
          <source>ImmutableDict</source>
          <target state="translated">ImmutableDict</target>
        </trans-unit>
        <trans-unit id="4d5fca35f85700fe41f680f762e716a68cf32a0c" translate="yes" xml:space="preserve">
          <source>ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key</source>
          <target state="translated">ImmutableDict es un diccionario implementado como una lista de enlaces inmutables,que es óptima para pequeños diccionarios que se construyen sobre muchas inserciones individuales Tenga en cuenta que no es posible eliminar un valor,aunque se puede anular y ocultar parcialmente insertando un nuevo valor con la misma clave</target>
        </trans-unit>
        <trans-unit id="5a205de46742b724da4bcd47864315bbfb29bffa" translate="yes" xml:space="preserve">
          <source>Imp</source>
          <target state="translated">Imp</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="91db407238f7692c5a1c288977c0c95bb564522e" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id &lt;code&gt;pid&lt;/code&gt;, specified by &lt;code&gt;config&lt;/code&gt; and return a pair of &lt;code&gt;IO&lt;/code&gt; objects. Messages from &lt;code&gt;pid&lt;/code&gt; to current process will be read off &lt;code&gt;instrm&lt;/code&gt;, while messages to be sent to &lt;code&gt;pid&lt;/code&gt; will be written to &lt;code&gt;outstrm&lt;/code&gt;. The custom transport implementation must ensure that messages are delivered and received completely and in order. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; sets up TCP/IP socket connections in-between workers.</source>
          <target state="translated">Implementado por administradores de cl&amp;uacute;steres mediante transportes personalizados. Debe establecer una conexi&amp;oacute;n l&amp;oacute;gica con el trabajador con id &lt;code&gt;pid&lt;/code&gt; , especificado por &lt;code&gt;config&lt;/code&gt; y devolver un par de objetos &lt;code&gt;IO&lt;/code&gt; . Los mensajes de &lt;code&gt;pid&lt;/code&gt; al proceso actual se leer&amp;aacute;n en &lt;code&gt;instrm&lt;/code&gt; , mientras que los mensajes que se env&amp;iacute;en a &lt;code&gt;pid&lt;/code&gt; se escribir&amp;aacute;n en &lt;code&gt;outstrm&lt;/code&gt; . La implementaci&amp;oacute;n del transporte personalizado debe garantizar que los mensajes se entreguen y reciban en su totalidad y en orden. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; configura conexiones de socket TCP / IP entre trabajadores.</target>
        </trans-unit>
        <trans-unit id="08979f61f84f8ad3b659b0b75ccddbf1892ea3a4" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. For every Julia worker launched by this function, it should append a &lt;code&gt;WorkerConfig&lt;/code&gt; entry to &lt;code&gt;launched&lt;/code&gt; and notify &lt;code&gt;launch_ntfy&lt;/code&gt;. The function MUST exit once all workers, requested by &lt;code&gt;manager&lt;/code&gt; have been launched. &lt;code&gt;params&lt;/code&gt; is a dictionary of all keyword arguments &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; was called with.</source>
          <target state="translated">Implementado por administradores de cl&amp;uacute;steres. Por cada trabajador Julia puesto en marcha por esta funci&amp;oacute;n, se debe anexar una &lt;code&gt;WorkerConfig&lt;/code&gt; entrada a &lt;code&gt;launched&lt;/code&gt; y notificar &lt;code&gt;launch_ntfy&lt;/code&gt; . La funci&amp;oacute;n DEBE salir una vez que se hayan iniciado todos los trabajadores solicitados por el &lt;code&gt;manager&lt;/code&gt; . &lt;code&gt;params&lt;/code&gt; es un diccionario de todos los argumentos de palabras clave &lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; se llam&amp;oacute; a addprocs .</target>
        </trans-unit>
        <trans-unit id="b5a68dbaa7e53b1fdc013e1b1b627c788dfd10b1" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, by &lt;a href=&quot;#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;. It should cause the remote worker specified by &lt;code&gt;pid&lt;/code&gt; to exit. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; executes a remote &lt;code&gt;exit()&lt;/code&gt; on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Implementado por administradores de cl&amp;uacute;steres. Se llama en el proceso maestro, por &lt;a href=&quot;#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt; . Deber&amp;iacute;a hacer que el trabajador remoto especificado por &lt;code&gt;pid&lt;/code&gt; salga. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; ejecuta una &lt;code&gt;exit()&lt;/code&gt; remota () en &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dba266234257c3d4b0aca4b478ddab2be6ca2905" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">Implementado por administradores de cl&amp;uacute;steres. Se llama en el proceso maestro, durante la vida de un trabajador, con los valores de &lt;code&gt;op&lt;/code&gt; eraci&amp;oacute;n apropiados :</target>
        </trans-unit>
        <trans-unit id="a6456a3318802fc28959139bf29a9bdf8b9e1954" translate="yes" xml:space="preserve">
          <source>Import Command</source>
          <target state="translated">Comando de importación</target>
        </trans-unit>
        <trans-unit id="a4489b5a6e6e45ce5f1172241f2ce59438e83997" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MyModule&lt;/code&gt; above we wanted to add a method to the standard &lt;code&gt;show&lt;/code&gt; function, so we had to write &lt;code&gt;import Base.show&lt;/code&gt;. Functions whose names are only visible via &lt;code&gt;using&lt;/code&gt; cannot be extended.</source>
          <target state="translated">En &lt;code&gt;MyModule&lt;/code&gt; anterior, quer&amp;iacute;amos agregar un m&amp;eacute;todo a la funci&amp;oacute;n &lt;code&gt;show&lt;/code&gt; est&amp;aacute;ndar , por lo que tuvimos que escribir &lt;code&gt;import Base.show&lt;/code&gt; . Las funciones cuyos nombres solo son visibles mediante el &lt;code&gt;using&lt;/code&gt; no se pueden ampliar.</target>
        </trans-unit>
        <trans-unit id="035c9cab15fd9dc0120582c57dc7ae1a95ac181b" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;very rare&lt;/em&gt; cases it might make sense for the constructor &lt;code&gt;T(x)&lt;/code&gt; to return an object not of type &lt;code&gt;T&lt;/code&gt;. This could happen if a wrapper type is its own inverse (e.g. &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt;), or to support an old calling syntax for backwards compatibility when a library is restructured. But &lt;code&gt;convert(T, x)&lt;/code&gt; should always return a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">En &lt;em&gt;muy raros&lt;/em&gt; casos puede que tenga sentido para el constructor &lt;code&gt;T(x)&lt;/code&gt; para devolver un objeto no de tipo &lt;code&gt;T&lt;/code&gt; . Esto podr&amp;iacute;a suceder si un tipo de contenedor es su propio inverso (por ejemplo, &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt; ), o para admitir una sintaxis de llamada antigua para compatibilidad con versiones anteriores cuando se reestructura una biblioteca. Pero &lt;code&gt;convert(T, x)&lt;/code&gt; siempre debe devolver un valor de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6ddd3549cd522fa313ced4025d3d58df8994646" translate="yes" xml:space="preserve">
          <source>In C++ or Java, for example, in a method call like &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt;, the object obj &quot;receives&quot; the method call and is implicitly passed to the method via the &lt;code&gt;this&lt;/code&gt; keyword, rather than as an explicit method argument. When the current &lt;code&gt;this&lt;/code&gt; object is the receiver of a method call, it can be omitted altogether, writing just &lt;code&gt;meth(arg1,arg2)&lt;/code&gt;, with &lt;code&gt;this&lt;/code&gt; implied as the receiving object.</source>
          <target state="translated">En C ++ o Java, por ejemplo, en una llamada a un m&amp;eacute;todo como &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt; , el objeto obj &quot;recibe&quot; la llamada al m&amp;eacute;todo y se pasa impl&amp;iacute;citamente al m&amp;eacute;todo a trav&amp;eacute;s de la palabra clave &lt;code&gt;this&lt;/code&gt; , en lugar de como un argumento de m&amp;eacute;todo expl&amp;iacute;cito. . Cuando el objeto actual &lt;code&gt;this&lt;/code&gt; es el receptor de una llamada a un m&amp;eacute;todo, se puede omitir por completo, escribiendo solo &lt;code&gt;meth(arg1,arg2)&lt;/code&gt; , con &lt;code&gt;this&lt;/code&gt; impl&amp;iacute;cito como el objeto receptor.</target>
        </trans-unit>
        <trans-unit id="0b44231782a66524e37b6a261f0e356297afae45" translate="yes" xml:space="preserve">
          <source>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is &quot;virtual&quot; (although it's more general than that since methods are dispatched on every argument type, not only &lt;code&gt;this&lt;/code&gt;, using the most-specific-declaration rule).</source>
          <target state="translated">En C ++, de forma predeterminada, tiene un env&amp;iacute;o est&amp;aacute;tico, es decir, necesita anotar una funci&amp;oacute;n como virtual, para tener un env&amp;iacute;o din&amp;aacute;mico. Por otro lado, en Julia cada m&amp;eacute;todo es &quot;virtual&quot; (aunque es m&amp;aacute;s general que eso, ya que los m&amp;eacute;todos se distribuyen en cada tipo de argumento, no solo en &lt;code&gt;this&lt;/code&gt; , usando la regla de declaraci&amp;oacute;n m&amp;aacute;s espec&amp;iacute;fica).</target>
        </trans-unit>
        <trans-unit id="a64f4137e1f00234d12e399e1c5435c90a8e6c63" translate="yes" xml:space="preserve">
          <source>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK library&lt;/a&gt;, which in turn is built on top of basic linear-algebra building-blocks known as the &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt;. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</source>
          <target state="translated">En Julia (como en gran parte de la computaci&amp;oacute;n cient&amp;iacute;fica), las operaciones densas de &amp;aacute;lgebra lineal se basan en la &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;biblioteca LAPACK&lt;/a&gt; , que a su vez se construye sobre los bloques de construcci&amp;oacute;n b&amp;aacute;sicos de &amp;aacute;lgebra lineal conocidos como &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt; . Hay implementaciones altamente optimizadas de BLAS disponibles para cada arquitectura de computadora y, a veces, en las rutinas de &amp;aacute;lgebra lineal de alto rendimiento es &amp;uacute;til llamar a las funciones BLAS directamente.</target>
        </trans-unit>
        <trans-unit id="247a76ccd2e14a487830d09d4cedad7b8f5df0c1" translate="yes" xml:space="preserve">
          <source>In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.</source>
          <target state="translated">En Julia 1.0 este método sólo soportaba una matriz de destino cuadrada.Julia 1.1.añadió soporte para una matriz rectangular.</target>
        </trans-unit>
        <trans-unit id="7eb90fb66dbd8787a2bcb4484cc97817d278a46b" translate="yes" xml:space="preserve">
          <source>In Julia 1.0, the default &lt;code&gt;--project=@.&lt;/code&gt; option did not search up from the root directory of a Git repository for the &lt;code&gt;Project.toml&lt;/code&gt; file. From Julia 1.1 forward, it does.</source>
          <target state="translated">En Julia 1.0, el valor predeterminado &lt;code&gt;--project=@.&lt;/code&gt; La opci&amp;oacute;n no busc&amp;oacute; desde el directorio ra&amp;iacute;z de un repositorio de Git para el archivo &lt;code&gt;Project.toml&lt;/code&gt; . Desde Julia 1.1 en adelante, lo hace.</target>
        </trans-unit>
        <trans-unit id="0050127afe87c7fac6e12932d051462ec8c65b3e" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randcycle&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">En Julia 1.1, &lt;code&gt;randcycle&lt;/code&gt; devuelve un vector &lt;code&gt;v&lt;/code&gt; con &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; mientras que en Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8b5eb0c54cc4aad9911d4c5d77bfea05f710df6" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randperm&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">En Julia 1.1, &lt;code&gt;randperm&lt;/code&gt; devuelve un vector &lt;code&gt;v&lt;/code&gt; con &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; mientras que en Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d630cc94b63c31ac28921da908c57f1454c54e15" translate="yes" xml:space="preserve">
          <source>In Julia &lt;code&gt;%&lt;/code&gt; is the remainder operator, whereas in Python it is the modulus.</source>
          <target state="translated">En Julia &lt;code&gt;%&lt;/code&gt; es el operador restante, mientras que en Python es el m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="cbc49b243ca968548d5e6046855ea243ea0a10fe" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type &lt;code&gt;T&lt;/code&gt; inside the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, as they are passed by value. For C code accepting pointers, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt;. In contrast, pointers returned by the C function called should be declared to be of output type &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr{T}&lt;/code&gt;&lt;/a&gt;, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type &lt;code&gt;Ptr{T}&lt;/code&gt; within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</source>
          <target state="translated">En las llamadas de envoltura de c&amp;oacute;digo de Julia a rutinas C externas, los datos ordinarios (no punteros) deben declararse como de tipo &lt;code&gt;T&lt;/code&gt; dentro de &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; , ya que se pasan por valor. Para el c&amp;oacute;digo C que acepta punteros, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt; generalmente debe usarse para los tipos de argumentos de entrada, permitiendo el uso de punteros a la memoria administrada por Julia o C a trav&amp;eacute;s de la llamada impl&amp;iacute;cita a &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; . Por el contrario, los punteros devueltos por la funci&amp;oacute;n C llamada deben declararse como del tipo de salida &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr{T}&lt;/code&gt; &lt;/a&gt; , lo que refleja que la memoria a la que se apunta es administrada &amp;uacute;nicamente por C. Los punteros contenidos en estructuras C deben representarse como campos de tipo &lt;code&gt;Ptr{T}&lt;/code&gt; dentro de los tipos de estructuras de Julia correspondientes dise&amp;ntilde;ados para imitar la estructura interna de las estructuras de C correspondientes.</target>
        </trans-unit>
        <trans-unit id="1fa4d6ec34fe20b0509960e834e463ea1a6b4cc7" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type &lt;code&gt;Ref{T}&lt;/code&gt;, as Fortran passes all variables by pointers to memory locations. The return type should either be &lt;code&gt;Cvoid&lt;/code&gt; for Fortran subroutines, or a &lt;code&gt;T&lt;/code&gt; for Fortran functions returning the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">En las llamadas de envoltura de c&amp;oacute;digo de Julia a rutinas externas de Fortran, todos los argumentos de entrada deben declararse como del tipo &lt;code&gt;Ref{T}&lt;/code&gt; , ya que Fortran pasa todas las variables mediante punteros a ubicaciones de memoria. El tipo de retorno debe ser o bien &lt;code&gt;Cvoid&lt;/code&gt; para subrutinas Fortran, o una &lt;code&gt;T&lt;/code&gt; para las funciones de Fortran regresan el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34f3cdb66f13e42ca43c63a9c817a8c4007728b9" translate="yes" xml:space="preserve">
          <source>In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</source>
          <target state="translated">En Julia cada módulo tiene su propio alcance global/espacio de nombres,mientras que en MATLAB sólo hay un alcance global.</target>
        </trans-unit>
        <trans-unit id="d9649a4e1eb5caa62495053957d722a3d4bba674" translate="yes" xml:space="preserve">
          <source>In Julia mode, the REPL supports something called &lt;em&gt;prompt pasting&lt;/em&gt;. This activates when pasting text that starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt; into the REPL. In that case, only expressions starting with &lt;code&gt;julia&amp;gt;&lt;/code&gt; are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt;. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.</source>
          <target state="translated">En el modo Julia, REPL admite algo llamado &lt;em&gt;pegado r&amp;aacute;pido&lt;/em&gt; . Esto se activa al pegar texto que comienza con &lt;code&gt;julia&amp;gt;&lt;/code&gt; en el REPL. En ese caso, solo se &lt;code&gt;julia&amp;gt;&lt;/code&gt; expresiones que comienzan con julia&amp;gt; , otras se eliminan. Esto hace que sea posible pegar un fragmento de c&amp;oacute;digo que se haya copiado de una sesi&amp;oacute;n REPL sin tener que borrar las indicaciones y los resultados. Esta funci&amp;oacute;n est&amp;aacute; habilitada de forma predeterminada, pero puede deshabilitarse o habilitarse a voluntad con &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt; . Si est&amp;aacute; habilitado, puede probarlo pegando el bloque de c&amp;oacute;digo sobre este p&amp;aacute;rrafo directamente en el REPL. Esta funci&amp;oacute;n no funciona en el s&amp;iacute;mbolo del sistema est&amp;aacute;ndar de Windows debido a su limitaci&amp;oacute;n para detectar cu&amp;aacute;ndo ocurre un pegado.</target>
        </trans-unit>
        <trans-unit id="57d6ea2617d808e81c678587852ffabe403f81cb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; are not assignment operators.</source>
          <target state="translated">En Julia, &lt;code&gt;&amp;lt;-&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; y &lt;code&gt;-&amp;gt;&lt;/code&gt; no son operadores de asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="601692d3aba8995fb01afb976c7c7f5a8aab46fc" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;...&lt;/code&gt; is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</source>
          <target state="translated">En Julia, &lt;code&gt;...&lt;/code&gt; no se usa para continuar l&amp;iacute;neas de c&amp;oacute;digo. En cambio, las expresiones incompletas contin&amp;uacute;an autom&amp;aacute;ticamente en la siguiente l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="5bdd69cd27046bb2e3189abcdf750e49518e8509" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;Ref&lt;/code&gt; objects are dereferenced (loaded or stored) with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">En Julia, los objetos &lt;code&gt;Ref&lt;/code&gt; se desreferencian (cargan o almacenan) con &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbe698f34efa48506b3a034b90fcbacaa3b44d79" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; produces &lt;code&gt;[1, 3]&lt;/code&gt;.</source>
          <target state="translated">En Julia, &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; produce &lt;code&gt;[1, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41c6478a96484907c7a62d3fc652aeb5cc697413" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; throws a &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt;&lt;code&gt;BoundsError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En Julia, &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; arroja un &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt; &lt;code&gt;BoundsError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0974da83f18cbcaffe16bb6459e3edda104c9151" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[x,y,z]&lt;/code&gt; will always construct a 3-element array containing &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">En Julia, &lt;code&gt;[x,y,z]&lt;/code&gt; siempre construir&amp;aacute; una matriz de 3 elementos que contenga &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d138a3241eb075445bbb09d48ceedbc03b1d34e" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;a:b&lt;/code&gt; and &lt;code&gt;a:b:c&lt;/code&gt; construct &lt;code&gt;AbstractRange&lt;/code&gt; objects. To construct a full vector like in MATLAB, use &lt;code&gt;collect(a:b)&lt;/code&gt;. Generally, there is no need to call &lt;code&gt;collect&lt;/code&gt; though. An &lt;code&gt;AbstractRange&lt;/code&gt; object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, or with iterators such as &lt;code&gt;enumerate&lt;/code&gt;, and &lt;code&gt;zip&lt;/code&gt;. The special objects can mostly be used as if they were normal arrays.</source>
          <target state="translated">En Julia, &lt;code&gt;a:b&lt;/code&gt; y &lt;code&gt;a:b:c&lt;/code&gt; construyen &lt;code&gt;AbstractRange&lt;/code&gt; objetos. Para construir un vector completo como en MATLAB, use &lt;code&gt;collect(a:b)&lt;/code&gt; . Generalmente, no es necesario llamar por &lt;code&gt;collect&lt;/code&gt; . Un objeto &lt;code&gt;AbstractRange&lt;/code&gt; actuar&amp;aacute; como una matriz normal en la mayor&amp;iacute;a de los casos, pero es m&amp;aacute;s eficiente porque calcula sus valores de forma perezosa. Este patr&amp;oacute;n de creaci&amp;oacute;n de objetos especializados en lugar de matrices completas se usa con frecuencia y tambi&amp;eacute;n se ve en funciones como &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; o con iteradores como &lt;code&gt;enumerate&lt;/code&gt; y &lt;code&gt;zip&lt;/code&gt; . Los objetos especiales se pueden utilizar principalmente como si fueran matrices normales.</target>
        </trans-unit>
        <trans-unit id="5622f51f1798995f4e2f17cefbf558acb8bdcceb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;return&lt;/code&gt; does not require parentheses.</source>
          <target state="translated">En Julia, la &lt;code&gt;return&lt;/code&gt; no requiere par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="c5612272a8f825cb7424d2a9deb9bd304a01ce42" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;x += y&lt;/code&gt; gets replaced during parsing by &lt;code&gt;x = x + y&lt;/code&gt;. For arrays, this has the consequence that, rather than storing the result in the same location in memory as &lt;code&gt;x&lt;/code&gt;, it allocates a new array to store the result.</source>
          <target state="translated">En Julia, &lt;code&gt;x += y&lt;/code&gt; se reemplaza durante el an&amp;aacute;lisis por &lt;code&gt;x = x + y&lt;/code&gt; . Para las matrices, esto tiene la consecuencia de que, en lugar de almacenar el resultado en la misma ubicaci&amp;oacute;n de la memoria que &lt;code&gt;x&lt;/code&gt; , asigna una nueva matriz para almacenar el resultado.</target>
        </trans-unit>
        <trans-unit id="58b1700c001aef7c6e8210d638550d343b095441" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="translated">En Julia,una función es un objeto que asigna una tupla de valores de argumento a un valor de retorno.Las funciones de Julia no son funciones matemáticas puras,en el sentido de que las funciones pueden alterarse y ser afectadas por el estado global del programa.La sintaxis básica para definir funciones en Julia es:</target>
        </trans-unit>
        <trans-unit id="4f9d45e10bb7e036a0e05a4d8d4376715db6b481" translate="yes" xml:space="preserve">
          <source>In Julia, a range like &lt;code&gt;a:b&lt;/code&gt; is not shorthand for a vector like in R, but is a specialized &lt;code&gt;AbstractRange&lt;/code&gt; object that is used for iteration without high memory overhead. To convert a range into a vector, use &lt;code&gt;collect(a:b)&lt;/code&gt;.</source>
          <target state="translated">En Julia, un rango como &lt;code&gt;a:b&lt;/code&gt; no es una abreviatura de un vector como en R, sino que es un objeto &lt;code&gt;AbstractRange&lt;/code&gt; especializado que se usa para la iteraci&amp;oacute;n sin una gran sobrecarga de memoria. Para convertir un rango en un vector, use &lt;code&gt;collect(a:b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40f5223023ecdb73df06f3b1a01d3f068c335d77" translate="yes" xml:space="preserve">
          <source>In Julia, all arguments to functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;passed by sharing&lt;/a&gt; (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a &lt;code&gt;!&lt;/code&gt; indicates that it will mutate or destroy the value of one or more of its arguments (compare, for example, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;). Callees must make explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non- mutating functions are implemented by calling a function of the same name with an added &lt;code&gt;!&lt;/code&gt; at the end on an explicit copy of the input, and returning that copy.</source>
          <target state="translated">En Julia, todos los argumentos de las funciones se &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;pasan compartiendo&lt;/a&gt; (es decir, mediante punteros). Algunos lenguajes de computaci&amp;oacute;n t&amp;eacute;cnica pasan las matrices por valor, y si bien esto evita la modificaci&amp;oacute;n accidental por parte de los destinatarios de un valor en el llamador, dificulta evitar la copia no deseada de matrices. Por convenci&amp;oacute;n, el nombre de una funci&amp;oacute;n que termina en &lt;code&gt;!&lt;/code&gt; indica que mutar&amp;aacute; o destruir&amp;aacute; el valor de uno o m&amp;aacute;s de sus argumentos (compare, por ejemplo, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt; ). Callees debe hacer copias expl&amp;iacute;citas para asegurarse de que no modifican entradas que no tienen la intenci&amp;oacute;n de cambiar. Muchas funciones no mutantes se implementan llamando a una funci&amp;oacute;n del mismo nombre con un a&amp;ntilde;adido &lt;code&gt;!&lt;/code&gt; al final en una copia expl&amp;iacute;cita de la entrada y devolviendo esa copia.</target>
        </trans-unit>
        <trans-unit id="9c3127614001f5fb915dc8fbc84746b3f3f27566" translate="yes" xml:space="preserve">
          <source>In Julia, an array &quot;slice&quot; expression like &lt;code&gt;array[1:5, :]&lt;/code&gt; creates a copy of that data (except on the left-hand side of an assignment, where &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; assigns in-place to that portion of &lt;code&gt;array&lt;/code&gt;). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.</source>
          <target state="translated">En Julia, una expresi&amp;oacute;n de &quot;corte&quot; de &lt;code&gt;array[1:5, :]&lt;/code&gt; como array [1: 5 ,: ] crea una copia de esos datos (excepto en el lado izquierdo de una asignaci&amp;oacute;n, donde &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; asigna en lugar de esa parte de la &lt;code&gt;array&lt;/code&gt; ). Si est&amp;aacute; realizando muchas operaciones en el segmento, esto puede ser bueno para el rendimiento porque es m&amp;aacute;s eficiente trabajar con una copia contigua m&amp;aacute;s peque&amp;ntilde;a de lo que ser&amp;iacute;a indexar en la matriz original. Por otro lado, si solo est&amp;aacute; realizando algunas operaciones simples en el segmento, el costo de las operaciones de asignaci&amp;oacute;n y copia puede ser sustancial.</target>
        </trans-unit>
        <trans-unit id="3012ec15c747cb5e8c8ab3cbb7a1be0e9f5c2879" translate="yes" xml:space="preserve">
          <source>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</source>
          <target state="translated">En Julia,exceder el máximo valor representable de un tipo dado resulta en un comportamiento envolvente:</target>
        </trans-unit>
        <trans-unit id="64ca87b8c062eb3ffaa0f39bec7e937ad18a966d" translate="yes" xml:space="preserve">
          <source>In Julia, if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are arrays, logical comparison operations like &lt;code&gt;A == B&lt;/code&gt; do not return an array of booleans. Instead, use &lt;code&gt;A .== B&lt;/code&gt;, and similarly for the other boolean operators like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">En Julia, si &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; son matrices, las operaciones de comparaci&amp;oacute;n l&amp;oacute;gica como &lt;code&gt;A == B&lt;/code&gt; no devuelven una matriz de valores booleanos. En su lugar, use &lt;code&gt;A .== B&lt;/code&gt; , y de manera similar para los otros operadores booleanos como &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d922f5b73911084e1798e1fbea58a0f20f71a33c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</source>
          <target state="translated">En Julia,la indexación de matrices,cuerdas,etc.se basa en 1 y no en 0.</target>
        </trans-unit>
        <trans-unit id="06df6596eaa7007459b69a3e35309023ab071dc0" translate="yes" xml:space="preserve">
          <source>In Julia, like Python but unlike R, strings can be created with triple quotes &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;. This syntax is convenient for constructing strings that contain line breaks.</source>
          <target state="translated">En Julia, como Python pero a diferencia de R, las cadenas se pueden crear con comillas triples &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; . Esta sintaxis es conveniente para construir cadenas que contienen saltos de l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="c8b7771804f2b70605beeefa21f23d88e1f845ae" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="translated">En Julia, los n&amp;uacute;meros literales sin un punto decimal (como &lt;code&gt;42&lt;/code&gt; ) crean n&amp;uacute;meros enteros en lugar de n&amp;uacute;meros de punto flotante. Como resultado, algunas operaciones pueden generar un error de dominio si esperan un flotante; por ejemplo, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; arroja un error de dominio, ya que el resultado no es un n&amp;uacute;mero entero (consulte &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;la entrada de preguntas frecuentes sobre errores de dominio&lt;/a&gt; para obtener m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="abe9d8d534555f871e47223b8068b11086c34b86" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create signed integers, of type &lt;code&gt;Int&lt;/code&gt;, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as &lt;code&gt;Int64&lt;/code&gt; (if &lt;code&gt;Int&lt;/code&gt; is &lt;code&gt;Int32&lt;/code&gt;), &lt;code&gt;Int128&lt;/code&gt;, or the arbitrarily large &lt;code&gt;BigInt&lt;/code&gt; type. There are no numeric literal suffixes, such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;LL&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;UL&lt;/code&gt;, &lt;code&gt;ULL&lt;/code&gt; to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with &lt;code&gt;0x&lt;/code&gt; like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the &lt;em&gt;length&lt;/em&gt; of the literal, including leading 0s. For example, &lt;code&gt;0x0&lt;/code&gt; and &lt;code&gt;0x00&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;0x000&lt;/code&gt; and &lt;code&gt;0x0000&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, then literals with 5 to 8 hex digits have type &lt;code&gt;UInt32&lt;/code&gt;, 9 to 16 hex digits type &lt;code&gt;UInt64&lt;/code&gt; and 17 to 32 hex digits type &lt;code&gt;UInt128&lt;/code&gt;. This needs to be taken into account when defining hexadecimal masks, for example &lt;code&gt;~0xf == 0xf0&lt;/code&gt; is very different from &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt;. 64 bit &lt;code&gt;Float64&lt;/code&gt; and 32 bit &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; bit literals are expressed as &lt;code&gt;1.0&lt;/code&gt; and &lt;code&gt;1.0f0&lt;/code&gt; respectively. Floating point literals are rounded (and not promoted to the &lt;code&gt;BigFloat&lt;/code&gt; type) if they can not be exactly represented. Floating point literals are closer in behavior to C/C++. Octal (prefixed with &lt;code&gt;0o&lt;/code&gt;) and binary (prefixed with &lt;code&gt;0b&lt;/code&gt;) literals are also treated as unsigned.</source>
          <target state="translated">En Julia, los n&amp;uacute;meros literales sin un punto decimal (como &lt;code&gt;42&lt;/code&gt; ) crean enteros con signo, de tipo &lt;code&gt;Int&lt;/code&gt; , pero los literales demasiado grandes para caber en el tama&amp;ntilde;o de la palabra de la m&amp;aacute;quina se promover&amp;aacute;n autom&amp;aacute;ticamente a un tipo de tama&amp;ntilde;o mayor, como &lt;code&gt;Int64&lt;/code&gt; (si &lt;code&gt;Int&lt;/code&gt; es &lt;code&gt;Int32&lt;/code&gt; ), &lt;code&gt;Int128&lt;/code&gt; o el tipo &lt;code&gt;BigInt&lt;/code&gt; arbitrariamente grande . No hay sufijos literales num&amp;eacute;ricos, como &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;LL&lt;/code&gt; , &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , &lt;code&gt;ULL&lt;/code&gt; para indicar sin firmar y / o firmado frente a sin firmar. Los literales decimales siempre est&amp;aacute;n firmados y los literales hexadecimales (que comienzan con &lt;code&gt;0x&lt;/code&gt; como C / C ++), no est&amp;aacute;n firmados. Los literales hexadecimales tambi&amp;eacute;n, a diferencia de C / C ++ / Java y a diferencia de los literales decimales en Julia, tienen un tipo basado en la &lt;em&gt;longitud&lt;/em&gt; del literal, incluidos los ceros iniciales. Por ejemplo, &lt;code&gt;0x0&lt;/code&gt; y &lt;code&gt;0x00&lt;/code&gt; tienen el tipo &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;0x000&lt;/code&gt; y &lt;code&gt;0x0000&lt;/code&gt; tienen el tipo &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; , luego los literales con 5 a 8 d&amp;iacute;gitos hexadecimales tienen el tipo &lt;code&gt;UInt32&lt;/code&gt; , 9 a 16 d&amp;iacute;gitos hexadecimales tipo &lt;code&gt;UInt64&lt;/code&gt; y 17 a 32 d&amp;iacute;gitos hexadecimales tipo &lt;code&gt;UInt128&lt;/code&gt; . Esto debe tenerse en cuenta al definir m&amp;aacute;scaras hexadecimales, por ejemplo, &lt;code&gt;~0xf == 0xf0&lt;/code&gt; es muy diferente de &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt; . 64 bits &lt;code&gt;Float64&lt;/code&gt; y &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; bit de 32 bits se expresan como &lt;code&gt;1.0&lt;/code&gt; y &lt;code&gt;1.0f0&lt;/code&gt; respectivamente. Los literales de coma flotante se redondean (y no se promueven al tipo &lt;code&gt;BigFloat&lt;/code&gt; ) si no se pueden representar con exactitud. Los literales de punto flotante tienen un comportamiento m&amp;aacute;s parecido al de C / C ++. Los literales octales (con el prefijo &lt;code&gt;0o&lt;/code&gt; ) y binarios (con el prefijo &lt;code&gt;0b&lt;/code&gt; ) tambi&amp;eacute;n se tratan como sin firmar.</target>
        </trans-unit>
        <trans-unit id="bdfe6baa0b2a1067c27d35abb55f2ee6ec449a3c" translate="yes" xml:space="preserve">
          <source>In Julia, missing values are represented by the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object rather than by &lt;code&gt;NA&lt;/code&gt;. Use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;ismissing.(x)&lt;/code&gt; for element-wise operation on vectors) instead of &lt;code&gt;is.na(x)&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function is generally used instead of &lt;code&gt;na.rm=TRUE&lt;/code&gt; (though in some particular cases functions take a &lt;code&gt;skipmissing&lt;/code&gt; argument).</source>
          <target state="translated">En Julia, los valores perdidos est&amp;aacute;n representados por el objeto &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; lugar de &lt;code&gt;NA&lt;/code&gt; . Utilice &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt; (o &lt;code&gt;ismissing.(x)&lt;/code&gt; para la operaci&amp;oacute;n de elementos en vectores) en lugar de &lt;code&gt;is.na(x)&lt;/code&gt; . La funci&amp;oacute;n de &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; se usa generalmente en lugar de &lt;code&gt;na.rm=TRUE&lt;/code&gt; (aunque en algunos casos particulares las funciones toman un argumento de &lt;code&gt;skipmissing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c2883abece45992fb07a9eafea704ad64c7847f2" translate="yes" xml:space="preserve">
          <source>In Julia, modulus is &lt;code&gt;mod(a, b)&lt;/code&gt;, not &lt;code&gt;a %% b&lt;/code&gt;. &lt;code&gt;%&lt;/code&gt; in Julia is the remainder operator.</source>
          <target state="translated">En Julia, el m&amp;oacute;dulo es &lt;code&gt;mod(a, b)&lt;/code&gt; , no &lt;code&gt;a %% b&lt;/code&gt; . &lt;code&gt;%&lt;/code&gt; en Julia es el operador restante.</target>
        </trans-unit>
        <trans-unit id="2e2622d04790dce54d4881a8ca271df72d322df7" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="translated">En Julia, la mayor&amp;iacute;a de los operadores son solo funciones con soporte para sintaxis especial. (Las excepciones son operadores con sem&amp;aacute;ntica de evaluaci&amp;oacute;n especial como &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; . Estos operadores no pueden ser funciones ya que la &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;evaluaci&amp;oacute;n de cortocircuito&lt;/a&gt; requiere que sus operandos no se eval&amp;uacute;en antes de la evaluaci&amp;oacute;n del operador). En consecuencia, tambi&amp;eacute;n puede aplicarlos usando listas de argumentos entre par&amp;eacute;ntesis , como lo har&amp;iacute;a con cualquier otra funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="cec708186271fab31b28911da66c39fb5ef32d0d" translate="yes" xml:space="preserve">
          <source>In Julia, multiple values are returned and assigned as tuples, e.g. &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; or &lt;code&gt;a, b = 1, 2&lt;/code&gt;. MATLAB's &lt;code&gt;nargout&lt;/code&gt;, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.</source>
          <target state="translated">En Julia, se devuelven m&amp;uacute;ltiples valores y se asignan como tuplas, p. Ej. &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; o &lt;code&gt;a, b = 1, 2&lt;/code&gt; . El &lt;code&gt;nargout&lt;/code&gt; de MATLAB , que a menudo se usa en MATLAB para realizar un trabajo opcional basado en el n&amp;uacute;mero de valores devueltos, no existe en Julia. En su lugar, los usuarios pueden utilizar argumentos opcionales y de palabras clave para lograr capacidades similares.</target>
        </trans-unit>
        <trans-unit id="4f6861a8c923af27ce752544647b06d9e6a0a07e" translate="yes" xml:space="preserve">
          <source>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</source>
          <target state="translated">En Julia,no todas las estructuras de datos soportan una indexación lógica.Además,la indexación lógica en Julia se apoya sólo con vectores de longitud igual al objeto que se indexa.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="451c3e5bbe0419b361a11d608a26c62bcc892288" translate="yes" xml:space="preserve">
          <source>In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:</source>
          <target state="translated">En Julia,se devuelve una tupla de valores para simular el retorno de múltiples valores.Sin embargo,las tuplas pueden ser creadas y desestructuradas sin necesidad de paréntesis,proporcionando así la ilusión de que se están devolviendo múltiples valores,en lugar de un único valor de tupla.Por ejemplo,la siguiente función devuelve un par de valores:</target>
        </trans-unit>
        <trans-unit id="d1f236e7a8645aa4ffbd134429aa159fdbc206da" translate="yes" xml:space="preserve">
          <source>In Julia, parentheses must be used to call a function with zero arguments, like in &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En Julia, se deben usar par&amp;eacute;ntesis para llamar a una funci&amp;oacute;n con cero argumentos, como en &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b62993ba8b73165f19053f9f6eaf87bfbe97454f" translate="yes" xml:space="preserve">
          <source>In Julia, reductions such as &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; are performed over every element of an array when called with a single argument, as in &lt;code&gt;sum(A)&lt;/code&gt;, even if &lt;code&gt;A&lt;/code&gt; has more than one dimension.</source>
          <target state="translated">En Julia, las reducciones como &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; se realizan sobre cada elemento de una matriz cuando se llama con un solo argumento, como en &lt;code&gt;sum(A)&lt;/code&gt; , incluso si &lt;code&gt;A&lt;/code&gt; tiene m&amp;aacute;s de una dimensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6b1973243505286be855fb241367233be8bd84fa" translate="yes" xml:space="preserve">
          <source>In Julia, sparse matrices are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;Compressed Sparse Column (CSC) format&lt;/a&gt;. Julia sparse matrices have the type &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Tv&lt;/code&gt; is the type of the stored values, and &lt;code&gt;Ti&lt;/code&gt; is the integer type for storing column pointers and row indices. The internal representation of &lt;code&gt;SparseMatrixCSC&lt;/code&gt; is as follows:</source>
          <target state="translated">En Julia, las matrices dispersas se almacenan en el &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;formato de columna dispersa comprimida (CSC)&lt;/a&gt; . Las matrices dispersas de Julia tienen el tipo &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt; &lt;/a&gt; , donde &lt;code&gt;Tv&lt;/code&gt; es el tipo de los valores almacenados y &lt;code&gt;Ti&lt;/code&gt; es el tipo entero para almacenar punteros de columna e &amp;iacute;ndices de fila. La representaci&amp;oacute;n interna de &lt;code&gt;SparseMatrixCSC&lt;/code&gt; es la siguiente:</target>
        </trans-unit>
        <trans-unit id="1e8bc1ec2e65356b67489d496d41c529e84e8334" translate="yes" xml:space="preserve">
          <source>In Julia, the binding of a variable &lt;code&gt;x&lt;/code&gt; cannot be changed by passing &lt;code&gt;x&lt;/code&gt; as an argument to a function. When calling &lt;code&gt;change_value!(x)&lt;/code&gt; in the above example, &lt;code&gt;y&lt;/code&gt; is a newly created variable, bound initially to the value of &lt;code&gt;x&lt;/code&gt;, i.e. &lt;code&gt;10&lt;/code&gt;; then &lt;code&gt;y&lt;/code&gt; is rebound to the constant &lt;code&gt;17&lt;/code&gt;, while the variable &lt;code&gt;x&lt;/code&gt; of the outer scope is left untouched.</source>
          <target state="translated">En Julia, la vinculaci&amp;oacute;n de una variable &lt;code&gt;x&lt;/code&gt; no se puede cambiar pasando &lt;code&gt;x&lt;/code&gt; como argumento a una funci&amp;oacute;n. Al llamar &lt;code&gt;change_value!(x)&lt;/code&gt; en el ejemplo anterior, &lt;code&gt;y&lt;/code&gt; es una variable reci&amp;eacute;n creada, vinculada inicialmente al valor de &lt;code&gt;x&lt;/code&gt; , es decir, &lt;code&gt;10&lt;/code&gt; ; luego &lt;code&gt;y&lt;/code&gt; se recupera a la constante &lt;code&gt;17&lt;/code&gt; , mientras que la variable &lt;code&gt;x&lt;/code&gt; del alcance externo se deja intacta.</target>
        </trans-unit>
        <trans-unit id="7ad2abcec621eb10f8cdb25e242afd4f9efd6dd1" translate="yes" xml:space="preserve">
          <source>In Julia, the elements of a collection can be passed as arguments to a function using the splat operator &lt;code&gt;...&lt;/code&gt;, as in &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt;.</source>
          <target state="translated">En Julia, los elementos de una colecci&amp;oacute;n se pueden pasar como argumentos a una funci&amp;oacute;n usando el operador splat &lt;code&gt;...&lt;/code&gt; , como en &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93d049ffcb952000d0f8ebc0a66e0ee55d575d87" translate="yes" xml:space="preserve">
          <source>In Julia, the operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) performs the bitwise XOR operation, i.e. &lt;code&gt;^&lt;/code&gt; in C/C++. Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</source>
          <target state="translated">En Julia, el operador &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; ) realiza la operaci&amp;oacute;n XOR bit a bit, es decir, &lt;code&gt;^&lt;/code&gt; en C / C ++. Adem&amp;aacute;s, los operadores bit a bit no tienen la misma precedencia que C / ++, por lo que pueden ser necesarios par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="8490fa684242627635a34751122775551824f7e6" translate="yes" xml:space="preserve">
          <source>In Julia, the operators &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) perform the bitwise operations equivalent to &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;xor&lt;/code&gt; respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of &lt;code&gt;A&lt;/code&gt; equal to 1 or 2 use &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt;).</source>
          <target state="translated">En Julia, los operadores &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;|&lt;/code&gt; , y &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; ) realizan las operaciones bit a bit equivalentes a &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , y &lt;code&gt;xor&lt;/code&gt; respectivamente en MATLAB, y tienen una precedencia similar a los operadores bit a bit de Python (a diferencia de C). Pueden operar en escalares o en elementos a trav&amp;eacute;s de arreglos y se pueden usar para combinar arreglos l&amp;oacute;gicos, pero tenga en cuenta la diferencia en el orden de las operaciones: es posible que se requieran par&amp;eacute;ntesis (por ejemplo, para seleccionar elementos de &lt;code&gt;A&lt;/code&gt; igual a 1 o 2 uso &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c924b695c23524838be4cdefba6d4ecf3f12bd7f" translate="yes" xml:space="preserve">
          <source>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</source>
          <target state="translated">En Julia,los valores no se copian cuando se asignan o pasan a una función.Si una función modifica una matriz,los cambios serán visibles en el llamador.Esto es muy diferente de R y permite que las nuevas funciones operen en grandes estructuras de datos de manera mucho más eficiente.</target>
        </trans-unit>
        <trans-unit id="4125f91a0372e71681729284bfb74b1b5f121b87" translate="yes" xml:space="preserve">
          <source>In Julia, varargs are specified using the splat operator &lt;code&gt;...&lt;/code&gt;, which always follows the name of a specific variable, unlike R, for which &lt;code&gt;...&lt;/code&gt; can occur in isolation.</source>
          <target state="translated">En Julia, los varargs se especifican usando el operador splat &lt;code&gt;...&lt;/code&gt; , que siempre sigue al nombre de una variable espec&amp;iacute;fica, a diferencia de R, para la cual &lt;code&gt;...&lt;/code&gt; puede ocurrir de forma aislada.</target>
        </trans-unit>
        <trans-unit id="61706e2cf7e3e0b63c2023adcea629882d9748dd" translate="yes" xml:space="preserve">
          <source>In Julia, vectors and matrices are concatenated using &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;rbind&lt;/code&gt; and &lt;code&gt;cbind&lt;/code&gt; like in R.</source>
          <target state="translated">En Julia, los vectores y las matrices se concatenan usando &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; &lt;/a&gt; , no &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;rbind&lt;/code&gt; y &lt;code&gt;cbind&lt;/code&gt; como en R.</target>
        </trans-unit>
        <trans-unit id="c15bdde6dec6d1761a5dc60f223d32d1ac186e83" translate="yes" xml:space="preserve">
          <source>In Julia, we can access the parts independently to make a copy of that string:</source>
          <target state="translated">En Julia,podemos acceder a las partes de forma independiente para hacer una copia de esa cadena:</target>
        </trans-unit>
        <trans-unit id="8bbe2d9f25b242e167641a97cc1e17c904778314" translate="yes" xml:space="preserve">
          <source>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</source>
          <target state="translated">En Julia,el espacio en blanco es significativo,a diferencia de C/C++,así que hay que tener cuidado al añadir/eliminar espacios en blanco de un programa de Julia.</target>
        </trans-unit>
        <trans-unit id="dfd2a6192ce5ab720952e7ded70bfe43e1c2837a" translate="yes" xml:space="preserve">
          <source>In Julia, you can't dispatch on a &lt;em&gt;value&lt;/em&gt; such as &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. However, you can dispatch on parametric types, and Julia allows you to include &quot;plain bits&quot; values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters. A common example is the dimensionality parameter in &lt;code&gt;Array{T,N}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type (e.g., &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;) but &lt;code&gt;N&lt;/code&gt; is just an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">En Julia, no se puede enviar con un &lt;em&gt;valor&lt;/em&gt; como &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; . Sin embargo, puede distribuir en tipos param&amp;eacute;tricos, y Julia le permite incluir valores de &quot;bits simples&quot; (tipos, s&amp;iacute;mbolos, enteros, n&amp;uacute;meros de coma flotante, tuplas, etc.) como par&amp;aacute;metros de tipo. Un ejemplo com&amp;uacute;n es el par&amp;aacute;metro de dimensionalidad en &lt;code&gt;Array{T,N}&lt;/code&gt; , donde &lt;code&gt;T&lt;/code&gt; es un tipo (por ejemplo, &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ) pero &lt;code&gt;N&lt;/code&gt; es solo un &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0987332b373dba2f6dccb678d104e0da95c47a9e" translate="yes" xml:space="preserve">
          <source>In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; or in the statement &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">En MATLAB, una forma idiom&amp;aacute;tica de eliminar valores no deseados es utilizar la indexaci&amp;oacute;n l&amp;oacute;gica, como en la expresi&amp;oacute;n &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; o en la declaraci&amp;oacute;n &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; para modificar &lt;code&gt;x&lt;/code&gt; en el lugar. En contraste, Julia proporciona el &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; funciones de orden superior . , lo que permite a los usuarios escribir &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; y &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; como alternativas a las transliteraciones correspondientes &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; y &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; . &amp;iexcl;Usando &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;reduce el uso de matrices temporales.</target>
        </trans-unit>
        <trans-unit id="6e02ea871ca138515cbf18e7481d0fb87b2d5244" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">En R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; es equivalente a &lt;code&gt;c(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="616e3b4685be805ef30bd44974ee4d2b22ae8fea" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">En R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; es equivalente &lt;code&gt;c(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0a60c169bc6c80688de200a5cb77dbd4fa3448" translate="yes" xml:space="preserve">
          <source>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; or in the statement &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">En R, una forma idiom&amp;aacute;tica de eliminar valores no deseados es usar la indexaci&amp;oacute;n l&amp;oacute;gica, como en la expresi&amp;oacute;n &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; o en la declaraci&amp;oacute;n &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; para modificar &lt;code&gt;x&lt;/code&gt; in situ. En contraste, Julia proporciona el &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; funciones de orden superior . , lo que permite a los usuarios escribir &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; y &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; como alternativas a las transliteraciones correspondientes &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; y &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; . &amp;iexcl;Usando &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;reduce el uso de matrices temporales.</target>
        </trans-unit>
        <trans-unit id="f6752ab2f8e0e7630531a6d7a1987e0bbb17b890" translate="yes" xml:space="preserve">
          <source>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</source>
          <target state="translated">En R,el rendimiento requiere vectorización.En Julia,ocurre casi lo contrario:el código de mejor rendimiento se logra a menudo utilizando bucles desviados.</target>
        </trans-unit>
        <trans-unit id="01878b8d1b390512d629c49ff65589c19ca63ad8" translate="yes" xml:space="preserve">
          <source>In a linear-algebra context, this means that even though operations like &lt;code&gt;vector + vector&lt;/code&gt; and &lt;code&gt;vector * scalar&lt;/code&gt; are defined, it can be advantageous to instead use &lt;code&gt;vector .+ vector&lt;/code&gt; and &lt;code&gt;vector .* scalar&lt;/code&gt; because the resulting loops can be fused with surrounding computations. For example, consider the two functions:</source>
          <target state="translated">En un contexto de &amp;aacute;lgebra lineal, esto significa que aunque se definen operaciones como &lt;code&gt;vector + vector&lt;/code&gt; y &lt;code&gt;vector * scalar&lt;/code&gt; , puede ser ventajoso usar &lt;code&gt;vector .+ vector&lt;/code&gt; y &lt;code&gt;vector .* scalar&lt;/code&gt; porque los bucles resultantes se pueden fusionar con c&amp;aacute;lculos circundantes . Por ejemplo, considere las dos funciones:</target>
        </trans-unit>
        <trans-unit id="9e1d6d725f550ad6f9da6bf98cc247f18f2108d6" translate="yes" xml:space="preserve">
          <source>In a local scope, all variables are inherited from its parent global scope block unless:</source>
          <target state="translated">En un ámbito local,todas las variables se heredan de su bloque padre de ámbito global a menos que:</target>
        </trans-unit>
        <trans-unit id="8fb94127a63695dc8bd7c2b91c9aa1704119e38b" translate="yes" xml:space="preserve">
          <source>In a module, declare that the file specified by &lt;code&gt;path&lt;/code&gt; (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</source>
          <target state="translated">En un m&amp;oacute;dulo, declare que el archivo especificado por la &lt;code&gt;path&lt;/code&gt; (relativa o absoluta) es una dependencia para la precompilaci&amp;oacute;n; es decir, ser&amp;aacute; necesario volver a compilar el m&amp;oacute;dulo si este archivo cambia.</target>
        </trans-unit>
        <trans-unit id="ba39320cdec145895823bcc997669a25a6af7855" translate="yes" xml:space="preserve">
          <source>In a sense, Julia falls into the &quot;no automatic promotion&quot; category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch &amp;ndash; something which Julia's dispatch and type systems are particularly well-suited to handle. &quot;Automatic&quot; promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</source>
          <target state="translated">En cierto sentido, Julia cae en la categor&amp;iacute;a &quot;sin promoci&amp;oacute;n autom&amp;aacute;tica&quot;: los operadores matem&amp;aacute;ticos son solo funciones con una sintaxis especial y los argumentos de las funciones nunca se convierten autom&amp;aacute;ticamente. Sin embargo, se puede observar que aplicar operaciones matem&amp;aacute;ticas a una amplia variedad de tipos de argumentos mixtos es solo un caso extremo de env&amp;iacute;o m&amp;uacute;ltiple polim&amp;oacute;rfico, algo para lo que los sistemas de env&amp;iacute;o y tipo de Julia son particularmente adecuados para manejar. La promoci&amp;oacute;n &quot;autom&amp;aacute;tica&quot; de operandos matem&amp;aacute;ticos simplemente surge como una aplicaci&amp;oacute;n especial: Julia viene con reglas predefinidas de distribuci&amp;oacute;n general para operadores matem&amp;aacute;ticos, invocadas cuando no existe una implementaci&amp;oacute;n espec&amp;iacute;fica para alguna combinaci&amp;oacute;n de tipos de operandos. Estas reglas generales primero promueven todos los operandos a un tipo com&amp;uacute;n utilizando reglas de promoci&amp;oacute;n definidas por el usuario,y luego invocar una implementaci&amp;oacute;n especializada del operador en cuesti&amp;oacute;n para los valores resultantes, ahora del mismo tipo. Los tipos definidos por el usuario pueden participar f&amp;aacute;cilmente en este sistema de promoci&amp;oacute;n definiendo m&amp;eacute;todos para la conversi&amp;oacute;n hacia y desde otros tipos, y proporcionando un pu&amp;ntilde;ado de reglas de promoci&amp;oacute;n que definen a qu&amp;eacute; tipos deben promocionar cuando se mezclan con otros tipos.</target>
        </trans-unit>
        <trans-unit id="18e44910a826a7be9fd86ad6a5c3ed3f73d517fa" translate="yes" xml:space="preserve">
          <source>In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with &lt;code&gt;using LinearAlgebra&lt;/code&gt;. Basic operations, such as &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;inv&lt;/code&gt; are all supported:</source>
          <target state="translated">Adem&amp;aacute;s de (y como parte de) su soporte para matrices multidimensionales, Julia proporciona implementaciones nativas de muchas operaciones de &amp;aacute;lgebra lineal comunes y &amp;uacute;tiles que se pueden cargar &lt;code&gt;using LinearAlgebra&lt;/code&gt; . Todas las operaciones b&amp;aacute;sicas, como &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt; &lt;code&gt;tr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; e &lt;code&gt;inv&lt;/code&gt; , son compatibles:</target>
        </trans-unit>
        <trans-unit id="f10487aa88c806dfd44fdee05bfc7281d910b478" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;, a few other basic functions are needed to use tasks effectively.</source>
          <target state="translated">Adem&amp;aacute;s de &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; , se necesitan algunas otras funciones b&amp;aacute;sicas para utilizar las tareas de forma eficaz.</target>
        </trans-unit>
        <trans-unit id="f2ab7ee40bd53e11319399c116d8d2cc2c48169d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;using Base&lt;/code&gt;, modules also automatically contain definitions of the &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt; functions, which evaluate expressions/files within the global scope of that module.</source>
          <target state="translated">Adem&amp;aacute;s de &lt;code&gt;using Base&lt;/code&gt; , los m&amp;oacute;dulos tambi&amp;eacute;n contienen autom&amp;aacute;ticamente definiciones de &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; e &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; funciones, que eval&amp;uacute;an expresiones / archivos dentro del alcance global de ese m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="10d21e803c8a9917ec9f0f6ebe5595e193060fc6" translate="yes" xml:space="preserve">
          <source>In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for &lt;code&gt;AbstractArrays&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de todos los m&amp;eacute;todos iterables e indexables de arriba, estos tipos tambi&amp;eacute;n pueden interactuar entre s&amp;iacute; y utilizar la mayor&amp;iacute;a de los m&amp;eacute;todos definidos en Julia Base para &lt;code&gt;AbstractArrays&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e406211c0c63c531f5fd9ccb75f3528a5be0658c" translate="yes" xml:space="preserve">
          <source>In addition to linear indexing, an &lt;code&gt;N&lt;/code&gt;-dimensional array may be indexed with fewer or more than &lt;code&gt;N&lt;/code&gt; indices in certain situations.</source>
          <target state="translated">Adem&amp;aacute;s de la indexaci&amp;oacute;n lineal, una matriz &lt;code&gt;N&lt;/code&gt; - dimensional puede indexarse ​​con menos o m&amp;aacute;s de &lt;code&gt;N&lt;/code&gt; &amp;iacute;ndices en determinadas situaciones.</target>
        </trans-unit>
        <trans-unit id="98e86e056613a088089dad092fe39f17f798108b" translate="yes" xml:space="preserve">
          <source>In addition to tasks Julia forwards natively supports multi-threading. Note that this section is experimental and the interfaces may change in the future.</source>
          <target state="translated">Además de las tareas que Julia realiza,apoya nativamente el multihilo.Tenga en cuenta que esta sección es experimental y las interfaces pueden cambiar en el futuro.</target>
        </trans-unit>
        <trans-unit id="ec666f0e17f38401053d73ee95bfc69ad9a82cc3" translate="yes" xml:space="preserve">
          <source>In addition to the given argument list, every macro is passed extra arguments named &lt;code&gt;__source__&lt;/code&gt; and &lt;code&gt;__module__&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de la lista de argumentos dada, a cada macro se le pasan argumentos adicionales llamados &lt;code&gt;__source__&lt;/code&gt; y &lt;code&gt;__module__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24215bb3919d42188faab69329d0bd6705349ee5" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="translated">Adem&amp;aacute;s, Julia proporciona muchas &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;factorizaciones&lt;/a&gt; que se pueden utilizar para acelerar problemas como la resoluci&amp;oacute;n lineal o la exponenciaci&amp;oacute;n de la matriz al prefactorizar una matriz en una forma m&amp;aacute;s adecuada (por motivos de rendimiento o memoria) al problema. Consulte la documentaci&amp;oacute;n sobre &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n. Como ejemplo:</target>
        </trans-unit>
        <trans-unit id="655d29ad2536f5920e2f78273e9aa1a0a062ab22" translate="yes" xml:space="preserve">
          <source>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</source>
          <target state="translated">En todos los casos la ambigüedad se resuelve a favor de la interpretación como literales numéricos:</target>
        </trans-unit>
        <trans-unit id="73ededace2cf23e632ef0400ebd52a78d322cb00" translate="yes" xml:space="preserve">
          <source>In all of the above modes, the executed lines get saved to a history file, which can be searched. To initiate an incremental search through the previous history, type &lt;code&gt;^R&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;r&lt;/code&gt; key. The prompt will change to &lt;code&gt;(reverse-i-search)`':&lt;/code&gt;, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type &lt;code&gt;^R&lt;/code&gt; again.</source>
          <target state="translated">En todos los modos anteriores, las l&amp;iacute;neas ejecutadas se guardan en un archivo hist&amp;oacute;rico, que se puede buscar. Para iniciar una b&amp;uacute;squeda incremental a trav&amp;eacute;s del historial anterior, escriba &lt;code&gt;^R&lt;/code&gt; - la tecla de control junto con la tecla &lt;code&gt;r&lt;/code&gt; . El mensaje cambiar&amp;aacute; a &lt;code&gt;(reverse-i-search)`':&lt;/code&gt; , y mientras escribe, la consulta de b&amp;uacute;squeda aparecer&amp;aacute; entre comillas. El resultado m&amp;aacute;s reciente que coincide con la consulta se actualizar&amp;aacute; din&amp;aacute;micamente a la derecha de los dos puntos a medida que se escriba m&amp;aacute;s. Para encontrar un resultado anterior utilizando la misma consulta, simplemente escriba &lt;code&gt;^R&lt;/code&gt; nuevamente.</target>
        </trans-unit>
        <trans-unit id="486b6c3b28f75c69ec1138bc26e8cd5e151040ee" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; ultimately operates on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object, which is in charge of queueing and restarting tasks. When a task calls &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;, the task is marked as non-runnable, added to the condition's queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on the condition, which causes tasks waiting for that condition to become runnable again.</source>
          <target state="translated">En todos estos casos, la &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; finalmente opera en un objeto &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; , que se encarga de poner en cola y reiniciar las tareas. Cuando las llamadas de una tarea &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; en una &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; , la tarea se marca como no ejecutable, se agrega a la cola de la condici&amp;oacute;n y cambia al programador. El programador elegir&amp;aacute; entonces otra tarea para ejecutar o bloquear&amp;aacute; la espera de eventos externos. Si todo va bien, eventualmente un controlador de eventos llamar&amp;aacute; a &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; sobre la condici&amp;oacute;n, lo que hace que las tareas que esperan esa condici&amp;oacute;n se vuelvan a ejecutar.</target>
        </trans-unit>
        <trans-unit id="a3a06ca6a5caa39934e953da1e9f4336d389c6e0" translate="yes" xml:space="preserve">
          <source>In all these cases, &lt;code&gt;x&lt;/code&gt; is bound to a tuple of the trailing values passed to &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">En todos estos casos, &lt;code&gt;x&lt;/code&gt; est&amp;aacute; vinculado a una tupla de los valores finales pasados ​​a &lt;code&gt;bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b99ce256d318c1c2f2354f48619a6804a821c4e0" translate="yes" xml:space="preserve">
          <source>In an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).</source>
          <target state="translated">En una topología de todo a todo (la predeterminada),todos los trabajadores se conectan entre sí a través de enchufes TCP simples.La política de seguridad de los nodos del clúster debe garantizar,por tanto,la libre conectividad entre los trabajadores para la efímera gama de puertos (varía según el sistema operativo).</target>
        </trans-unit>
        <trans-unit id="3c8cda3e1e2865b38c43f81658a24d808d5fe92a" translate="yes" xml:space="preserve">
          <source>In both Julia and MATLAB, the variable &lt;code&gt;ans&lt;/code&gt; is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, &lt;code&gt;ans&lt;/code&gt; is not set when Julia code is run in non-interactive mode.</source>
          <target state="translated">Tanto en Julia como en MATLAB, la variable &lt;code&gt;ans&lt;/code&gt; se establece en el valor de la &amp;uacute;ltima expresi&amp;oacute;n emitida en una sesi&amp;oacute;n interactiva. En Julia, a diferencia de MATLAB, &lt;code&gt;ans&lt;/code&gt; no se establece cuando el c&amp;oacute;digo de Julia se ejecuta en modo no interactivo.</target>
        </trans-unit>
        <trans-unit id="b8e4ada1bafffe80f21502163f1a66167c6265bb" translate="yes" xml:space="preserve">
          <source>In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:</source>
          <target state="translated">Tanto en el modo Julián como en el modo de ayuda de la REPL,se pueden introducir los primeros caracteres de una función o tipo y luego pulsar la tecla de tabulación para obtener una lista de todas las coincidencias:</target>
        </trans-unit>
        <trans-unit id="661336deabc49d6bd089fab9e0056b342efe5561" translate="yes" xml:space="preserve">
          <source>In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; on local instances of a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, or on unfetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Since calling &lt;code&gt;fetch&lt;/code&gt; on a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; also removes its reference from the remote store, this is not required on fetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Explicitly calling &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; results in an immediate message sent to the remote node to go ahead and remove its reference to the value.</source>
          <target state="translated">En el caso de referencias remotas, el tama&amp;ntilde;o del objeto de referencia local es bastante peque&amp;ntilde;o, mientras que el valor almacenado en el nodo remoto puede ser bastante grande. Dado que es posible que el objeto local no se recopile de inmediato, es una buena pr&amp;aacute;ctica llamar expl&amp;iacute;citamente a &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; en instancias locales de un &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; o en &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; s no recuperados . Dado que llamar a &lt;code&gt;fetch&lt;/code&gt; en un &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n elimina su referencia del almac&amp;eacute;n remoto, esto no es necesario en los &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; s recuperados . Llamar expl&amp;iacute;citamente a &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; da como resultado un mensaje inmediato enviado al nodo remoto para continuar y eliminar su referencia al valor.</target>
        </trans-unit>
        <trans-unit id="bf07799a9aab60dca9abdd6af2de0083f4fd55f9" translate="yes" xml:space="preserve">
          <source>In cases where &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; would need to take a Julia object and turn it into a &lt;code&gt;Ptr&lt;/code&gt;, this function should be used to define and perform that conversion.</source>
          <target state="translated">En los casos en los que &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; ir&lt;/a&gt; necesitar&amp;iacute;a tomar un objeto Julia y convertirlo en un &lt;code&gt;Ptr&lt;/code&gt; , esta funci&amp;oacute;n debe usarse para definir y realizar esa conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="62d2a9fdaaf73a0db81376306b368d8784225fa7" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;x&lt;/code&gt; cannot be safely converted to &lt;code&gt;T&lt;/code&gt;, unlike &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;cconvert&lt;/code&gt; may return an object of a type different from &lt;code&gt;T&lt;/code&gt;, which however is suitable for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; to handle. The result of this function should be kept valid (for the GC) until the result of &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; is not needed anymore. This can be used to allocate memory that will be accessed by the &lt;code&gt;ccall&lt;/code&gt;. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</source>
          <target state="translated">En los casos en que &lt;code&gt;x&lt;/code&gt; no se puede convertir de forma segura a &lt;code&gt;T&lt;/code&gt; , a diferencia de &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;cconvert&lt;/code&gt; puede devolver un objeto de un tipo diferente de &lt;code&gt;T&lt;/code&gt; , que sin embargo es adecuado para que &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; lo&lt;/a&gt; maneje. El resultado de esta funci&amp;oacute;n debe mantenerse v&amp;aacute;lido (para el GC) hasta que el resultado de &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; ya no sea necesario. Esto se puede utilizar para asignar memoria a la que acceder&amp;aacute; &lt;code&gt;ccall&lt;/code&gt; . Si es necesario asignar varios objetos, se puede usar una tupla de los objetos como valor de retorno.</target>
        </trans-unit>
        <trans-unit id="20a6a008693353a3bba07852d46b5ac7a61ffe13" translate="yes" xml:space="preserve">
          <source>In cases where you want to be able to mix multiple &lt;code&gt;AbstractArrayStyle&lt;/code&gt;s and keep track of dimensionality, your style needs to support a &lt;a href=&quot;../base/index#Base.Val&quot;&gt;&lt;code&gt;Val&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">En los casos en los que desee poder mezclar varios &lt;code&gt;AbstractArrayStyle&lt;/code&gt; sy realizar un seguimiento de la dimensionalidad, su estilo debe admitir un constructor &lt;a href=&quot;../base/index#Base.Val&quot;&gt; &lt;code&gt;Val&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="371183813ad83fb61979b332a5033cb1b76e325b" translate="yes" xml:space="preserve">
          <source>In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The &lt;code&gt;finally&lt;/code&gt; keyword provides a way to run some code when a given block of code exits, regardless of how it exits.</source>
          <target state="translated">En el c&amp;oacute;digo que realiza cambios de estado o utiliza recursos como archivos, normalmente hay un trabajo de limpieza (como cerrar archivos) que debe realizarse cuando el c&amp;oacute;digo est&amp;aacute; terminado. Las excepciones complican potencialmente esta tarea, ya que pueden hacer que un bloque de c&amp;oacute;digo salga antes de llegar a su final normal. La palabra clave &lt;code&gt;finally&lt;/code&gt; proporciona una forma de ejecutar c&amp;oacute;digo cuando un bloque de c&amp;oacute;digo determinado sale, independientemente de c&amp;oacute;mo salga.</target>
        </trans-unit>
        <trans-unit id="439d8b30359bbc8d6b7d18a09ea082d188e37311" translate="yes" xml:space="preserve">
          <source>In contrast to the use of the &lt;code&gt;...&lt;/code&gt; operator to denote slurping many different arguments into one argument when defining a function, the &lt;code&gt;...&lt;/code&gt; operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of &lt;code&gt;...&lt;/code&gt; is called splatting:</source>
          <target state="translated">En contraste con el uso del operador &lt;code&gt;...&lt;/code&gt; para denotar la incorporaci&amp;oacute;n de muchos argumentos diferentes en un argumento al definir una funci&amp;oacute;n, el operador &lt;code&gt;...&lt;/code&gt; tambi&amp;eacute;n se usa para hacer que un argumento de funci&amp;oacute;n &amp;uacute;nica se divida en muchos argumentos diferentes cuando se usa en el contexto de una llamada a funci&amp;oacute;n. Este uso de &lt;code&gt;...&lt;/code&gt; se llama salpicar:</target>
        </trans-unit>
        <trans-unit id="9c8f753b1f6a1a771efd3464599b303870131486" translate="yes" xml:space="preserve">
          <source>In contrast with &lt;code&gt;for i = 1:length(A)&lt;/code&gt;, iterating with &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; provides an efficient way to iterate over any array type.</source>
          <target state="translated">En contraste con &lt;code&gt;for i = 1:length(A)&lt;/code&gt; , la iteraci&amp;oacute;n con cada &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; proporciona una forma eficiente de iterar sobre cualquier tipo de matriz.</target>
        </trans-unit>
        <trans-unit id="7142e8f2e408ab35102cc379780cf0e33b4e8234" translate="yes" xml:space="preserve">
          <source>In contrast, once &lt;code&gt;m&lt;/code&gt; is constructed, the type of &lt;code&gt;m.a&lt;/code&gt; cannot change:</source>
          <target state="translated">Por el contrario, una vez que se construye &lt;code&gt;m&lt;/code&gt; , el tipo de &lt;code&gt;m.a&lt;/code&gt; no puede cambiar:</target>
        </trans-unit>
        <trans-unit id="0d5137a043d33963d37d01766416ca959609cfd8" translate="yes" xml:space="preserve">
          <source>In general you can place a &lt;code&gt;return&lt;/code&gt; statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with &lt;code&gt;do&lt;/code&gt; blocks. For example:</source>
          <target state="translated">En general, puede colocar una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; cualquier lugar dentro del cuerpo de una funci&amp;oacute;n, incluso dentro de los bucles o condicionales profundamente anidados, pero tenga cuidado con los bloques &lt;code&gt;do&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c2d6d0431d403e66982fc3bf0664898813b75b58" translate="yes" xml:space="preserve">
          <source>In general, a broadcast operation is represented by a lazy &lt;code&gt;Broadcasted&lt;/code&gt; container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested &lt;code&gt;Broadcasted&lt;/code&gt; containers, forming a large expression tree to be evaluated. A nested tree of &lt;code&gt;Broadcasted&lt;/code&gt; containers is directly constructed by the implicit dot syntax; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; is transiently represented by &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt;, for example. This is invisible to users as it is immediately realized through a call to &lt;code&gt;copy&lt;/code&gt;, but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the &lt;code&gt;Broadcasted&lt;/code&gt; object into it with a default &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; method. The built-in fallback &lt;code&gt;broadcast&lt;/code&gt; and &lt;code&gt;broadcast!&lt;/code&gt; methods similarly construct a transient &lt;code&gt;Broadcasted&lt;/code&gt; representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own &lt;code&gt;copyto!&lt;/code&gt; specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the &lt;code&gt;Broadcasted&lt;/code&gt; type, allowing for dispatch and specialization.</source>
          <target state="translated">En general, una operaci&amp;oacute;n de transmisi&amp;oacute;n est&amp;aacute; representada por un contenedor de &lt;code&gt;Broadcasted&lt;/code&gt; diferida que retiene la funci&amp;oacute;n que se aplicar&amp;aacute; junto con sus argumentos. Esos argumentos pueden ser en s&amp;iacute; mismos contenedores &lt;code&gt;Broadcasted&lt;/code&gt; m&amp;aacute;s anidados , formando un gran &amp;aacute;rbol de expresi&amp;oacute;n para ser evaluado. Un &amp;aacute;rbol anidado de contenedores &lt;code&gt;Broadcasted&lt;/code&gt; se construye directamente mediante la sintaxis de punto impl&amp;iacute;cita; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; est&amp;aacute; representado transitoriamente por &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt; , por ejemplo. Esto es invisible para los usuarios, ya que se realiza de inmediato a trav&amp;eacute;s de una llamada para &lt;code&gt;copy&lt;/code&gt; , pero es este contenedor el que proporciona la base para la extensibilidad de la difusi&amp;oacute;n para los autores de tipos personalizados. La maquinaria de transmisi&amp;oacute;n incorporada determinar&amp;aacute; el tipo y tama&amp;ntilde;o del resultado en funci&amp;oacute;n de los argumentos, lo asignar&amp;aacute; y finalmente copiar&amp;aacute; la realizaci&amp;oacute;n del objeto &lt;code&gt;Broadcasted&lt;/code&gt; en &amp;eacute;l con un &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; predeterminado . &amp;iexcl;La &lt;code&gt;broadcast&lt;/code&gt; y la &lt;code&gt;broadcast!&lt;/code&gt; respaldo incorporadas ! m&amp;eacute;todos de manera similar construir un transitorio &lt;code&gt;Broadcasted&lt;/code&gt; representaci&amp;oacute;n de la operaci&amp;oacute;n para que puedan seguir el mismo c&amp;oacute;digo base. Esto permite que las implementaciones de matrices personalizadas proporcionen su propia &lt;code&gt;copyto!&lt;/code&gt; especializaci&amp;oacute;n para personalizar y optimizar la transmisi&amp;oacute;n. Esto est&amp;aacute; nuevamente determinado por el estilo de transmisi&amp;oacute;n calculado. Esta es una parte tan importante de la operaci&amp;oacute;n que se almacena como el primer par&amp;aacute;metro de tipo del tipo &lt;code&gt;Broadcasted&lt;/code&gt; , lo que permite el env&amp;iacute;o y la especializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8d1babd281f2e672316bf23dea36c5ab29827a0a" translate="yes" xml:space="preserve">
          <source>In general, if you have &lt;code&gt;N&lt;/code&gt; samples collected at a line, you can expect an uncertainty on the order of &lt;code&gt;sqrt(N)&lt;/code&gt; (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia's garbage collector is written in C, such events can be detected using the &lt;code&gt;C=true&lt;/code&gt; output mode described below, or by using &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;.)</source>
          <target state="translated">En general, si tiene &lt;code&gt;N&lt;/code&gt; muestras recolectadas en una l&amp;iacute;nea, puede esperar una incertidumbre del orden de &lt;code&gt;sqrt(N)&lt;/code&gt; (salvo otras fuentes de ruido, como qu&amp;eacute; tan ocupada est&amp;aacute; la computadora con otras tareas). La principal excepci&amp;oacute;n a esta regla es la recolecci&amp;oacute;n de basura, que se ejecuta con poca frecuencia pero tiende a ser bastante costosa. (Dado que el recolector de basura de Julia est&amp;aacute; escrito en C, tales eventos se pueden detectar usando el modo de salida &lt;code&gt;C=true&lt;/code&gt; que se describe a continuaci&amp;oacute;n, o usando &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="efbd7c168e8e9417f99b66ae892e749285151330" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;for&lt;/code&gt; loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;&amp;isin;&lt;/code&gt; is typically used instead of &lt;code&gt;=&lt;/code&gt;, since it makes the code read more clearly:</source>
          <target state="translated">En general, la construcci&amp;oacute;n de bucle &lt;code&gt;for&lt;/code&gt; puede iterar sobre cualquier contenedor. En estos casos, la palabra clave alternativa (pero totalmente equivalente) &lt;code&gt;in&lt;/code&gt; o &lt;code&gt;&amp;isin;&lt;/code&gt; generalmente se usa en lugar de &lt;code&gt;=&lt;/code&gt; , ya que hace que el c&amp;oacute;digo se lea con mayor claridad:</target>
        </trans-unit>
        <trans-unit id="e63801e02d1bdf10fcfad068986ce15007cba3d8" translate="yes" xml:space="preserve">
          <source>In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell's. The only difference is that the interpolation is integrated and aware of Julia's notion of what is a single string value, and what is a container for multiple values. Let's try the above two examples in Julia:</source>
          <target state="translated">En general,la sintaxis del backtick de Julia está cuidadosamente diseñada para que puedas cortar y pegar comandos de shell como en los backticks y funcionarán:los comportamientos de escape,cita e interpolación son los mismos que los del shell.La única diferencia es que la interpolación está integrada y es consciente de la noción de Julia de lo que es un valor de una sola cadena,y de lo que es un contenedor para múltiples valores.Probemos los dos ejemplos anteriores en Julia:</target>
        </trans-unit>
        <trans-unit id="e9d0a19dc1691ca7e9543783f1a58a636105f54f" translate="yes" xml:space="preserve">
          <source>In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.</source>
          <target state="translated">En general,a diferencia de muchos otros lenguajes de computación técnica,Julia no espera que los programas se escriban en un estilo vectorizado para el rendimiento.El compilador de Julia utiliza la inferencia de tipos y genera código optimizado para la indexación de arreglos escalares,permitiendo que los programas se escriban en un estilo que sea conveniente y legible,sin sacrificar el rendimiento,y usando menos memoria a veces.</target>
        </trans-unit>
        <trans-unit id="0aca2d8ec448ee15667ecd2efa9a783d316a76f6" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">En general, no puede suponer que la salida de la &lt;code&gt;display&lt;/code&gt; va a &lt;code&gt;stdout&lt;/code&gt; (a diferencia de &lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print(x)&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; ). Por ejemplo, la &lt;code&gt;display(x)&lt;/code&gt; puede abrir una ventana separada con una imagen. &lt;code&gt;display(x)&lt;/code&gt; significa &quot;mostrar &lt;code&gt;x&lt;/code&gt; de la mejor manera posible para los dispositivos de salida actuales&quot;. Si desea una salida de texto similar a REPL que est&amp;eacute; garantizada para ir a &lt;code&gt;stdout&lt;/code&gt; , use &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt; &lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="421d35772a37767957f94e34c887a2a8d79cd54e" translate="yes" xml:space="preserve">
          <source>In interpreting the results, there are a few important details. Under the &lt;code&gt;user&lt;/code&gt; setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia's compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt;&lt;/a&gt; to reset all allocation counters. Finally, execute the desired commands and quit Julia to trigger the generation of the &lt;code&gt;.mem&lt;/code&gt; files.</source>
          <target state="translated">Al interpretar los resultados, hay algunos detalles importantes. Bajo la configuraci&amp;oacute;n de &lt;code&gt;user&lt;/code&gt; , la primera l&amp;iacute;nea de cualquier funci&amp;oacute;n llamada directamente desde REPL exhibir&amp;aacute; asignaci&amp;oacute;n debido a eventos que suceden en el c&amp;oacute;digo REPL mismo. M&amp;aacute;s significativamente, la compilaci&amp;oacute;n JIT tambi&amp;eacute;n se suma a los recuentos de asignaciones, porque gran parte del compilador de Julia est&amp;aacute; escrito en Julia (y la compilaci&amp;oacute;n generalmente requiere asignaci&amp;oacute;n de memoria). El procedimiento recomendado es forzar la compilaci&amp;oacute;n ejecutando todos los comandos que desea analizar, luego llame a &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt; &lt;/a&gt; para restablecer todos los contadores de asignaci&amp;oacute;n. Finalmente, ejecute los comandos deseados y salga de Julia para activar la generaci&amp;oacute;n de los archivos &lt;code&gt;.mem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76e2766644f11aec36d4590582770e2731974fc5" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="translated">En los lenguajes orientados a objetos convencionales, como C ++, Java, Python y Ruby, los tipos compuestos tambi&amp;eacute;n tienen funciones con nombre asociadas, y la combinaci&amp;oacute;n se denomina &quot;objeto&quot;. En lenguajes orientados a objetos m&amp;aacute;s puros, como Ruby o Smalltalk, todos los valores son objetos, sean compuestos o no. En lenguajes orientados a objetos menos puros, incluidos C ++ y Java, algunos valores, como n&amp;uacute;meros enteros y valores de punto flotante, no son objetos, mientras que las instancias de tipos compuestos definidos por el usuario son objetos verdaderos con m&amp;eacute;todos asociados. En Julia, todos los valores son objetos, pero las funciones no est&amp;aacute;n empaquetadas con los objetos sobre los que operan. Esto es necesario ya que Julia elige qu&amp;eacute; m&amp;eacute;todo de una funci&amp;oacute;n usar por env&amp;iacute;o m&amp;uacute;ltiple, lo que significa que los tipos de &lt;em&gt;todos&lt;/em&gt;de los argumentos de una funci&amp;oacute;n se tienen en cuenta al seleccionar un m&amp;eacute;todo, en lugar de solo el primero (consulte &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;M&amp;eacute;todos&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre m&amp;eacute;todos y env&amp;iacute;o). Por tanto, ser&amp;iacute;a inapropiado que las funciones &quot;pertenecieran&quot; s&amp;oacute;lo a su primer argumento. Organizar m&amp;eacute;todos en objetos funcionales en lugar de nombrar bolsas de m&amp;eacute;todos &quot;dentro&quot; de cada objeto termina siendo un aspecto muy beneficioso del dise&amp;ntilde;o del lenguaje.</target>
        </trans-unit>
        <trans-unit id="eae8b05ff1c12682f8c0f5b0dacd56bde327dcb6" translate="yes" xml:space="preserve">
          <source>In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix. This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with &lt;code&gt;!&lt;/code&gt; below (e.g. &lt;code&gt;mul!&lt;/code&gt;) according to the usual Julia convention.</source>
          <target state="translated">En muchos casos, existen versiones in situ de operaciones matriciales que le permiten proporcionar una matriz o vector de salida preasignado. Esto es &amp;uacute;til al optimizar c&amp;oacute;digo cr&amp;iacute;tico para evitar la sobrecarga de asignaciones repetidas. Estas operaciones in situ tienen el sufijo &lt;code&gt;!&lt;/code&gt; a continuaci&amp;oacute;n (por ejemplo, &lt;code&gt;mul!&lt;/code&gt; ) de acuerdo con la convenci&amp;oacute;n habitual de Julia.</target>
        </trans-unit>
        <trans-unit id="1ed441529eec7f43ad66971217220df4ecd80a6e" translate="yes" xml:space="preserve">
          <source>In many cases, Julia is able to automatically vectorize inner for loops without the use of &lt;code&gt;@simd&lt;/code&gt;. Using &lt;code&gt;@simd&lt;/code&gt; gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:</source>
          <target state="translated">En muchos casos, Julia puede vectorizar autom&amp;aacute;ticamente bucles for internos sin el uso de &lt;code&gt;@simd&lt;/code&gt; . El uso de &lt;code&gt;@simd&lt;/code&gt; le da al compilador un poco m&amp;aacute;s de libertad para hacerlo posible en m&amp;aacute;s situaciones. En cualquier caso, su bucle interno debe tener las siguientes propiedades para permitir la vectorizaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="36269174e578550d7d7f0601c4aea1c6ce0438f9" translate="yes" xml:space="preserve">
          <source>In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="translated">En muchos casos, los argumentos de funci&amp;oacute;n tienen valores predeterminados sensibles y, por lo tanto, es posible que no sea necesario pasarlos expl&amp;iacute;citamente en cada llamada. Por ejemplo, la funci&amp;oacute;n &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt; &lt;code&gt;Date(y, [m, d])&lt;/code&gt; &lt;/a&gt; del m&amp;oacute;dulo &lt;code&gt;Dates&lt;/code&gt; construye un tipo de &lt;code&gt;Date&lt;/code&gt; para un a&amp;ntilde;o &lt;code&gt;y&lt;/code&gt; , mes &lt;code&gt;m&lt;/code&gt; y d&amp;iacute;a &lt;code&gt;d&lt;/code&gt; dado . Sin embargo, &lt;code&gt;m&lt;/code&gt; y &lt;code&gt;d&lt;/code&gt; argumentos son opcionales y su valor predeterminado es &lt;code&gt;1&lt;/code&gt; . Este comportamiento se puede expresar de forma concisa como:</target>
        </trans-unit>
        <trans-unit id="1dd343721288798b24ab9ba3f9547e7ac41c164d" translate="yes" xml:space="preserve">
          <source>In many cases, it is redundant to provide the type of &lt;code&gt;Point&lt;/code&gt; object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply &lt;code&gt;Point&lt;/code&gt; itself as a constructor, provided that the implied value of the parameter type &lt;code&gt;T&lt;/code&gt; is unambiguous:</source>
          <target state="translated">En muchos casos, es redundante proporcionar el tipo de objeto &lt;code&gt;Point&lt;/code&gt; que se desea construir, ya que los tipos de argumentos para la llamada al constructor ya proporcionan impl&amp;iacute;citamente informaci&amp;oacute;n de tipo. Por esa raz&amp;oacute;n, tambi&amp;eacute;n puede aplicar el propio &lt;code&gt;Point&lt;/code&gt; como un constructor, siempre que el valor impl&amp;iacute;cito del tipo de par&amp;aacute;metro &lt;code&gt;T&lt;/code&gt; no sea ambiguo:</target>
        </trans-unit>
        <trans-unit id="269254287f284598e6e04a282963713d5ef0932c" translate="yes" xml:space="preserve">
          <source>In many cases, the resolution specified for rounding (e.g., &lt;code&gt;Dates.Second(30)&lt;/code&gt;) divides evenly into the next largest period (in this case, &lt;code&gt;Dates.Minute(1)&lt;/code&gt;). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to the nearest 10 hours?</source>
          <target state="translated">En muchos casos, la resoluci&amp;oacute;n especificada para el redondeo (p. Ej., &lt;code&gt;Dates.Second(30)&lt;/code&gt; ) se divide uniformemente en el siguiente per&amp;iacute;odo m&amp;aacute;s grande (en este caso, &lt;code&gt;Dates.Minute(1)&lt;/code&gt; ). Pero el comportamiento de redondeo en casos en los que esto no es cierto puede generar confusi&amp;oacute;n. &amp;iquest;Cu&amp;aacute;l es el resultado esperado de redondear un &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; a las 10 horas m&amp;aacute;s cercanas?</target>
        </trans-unit>
        <trans-unit id="619846970e9e167e4db1b981435711d687bd4ed9" translate="yes" xml:space="preserve">
          <source>In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is &lt;em&gt;not&lt;/em&gt; the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.</source>
          <target state="translated">En muchos lenguajes con declaraciones de tipo opcionales, agregar declaraciones es la forma principal de hacer que el c&amp;oacute;digo se ejecute m&amp;aacute;s r&amp;aacute;pido. Este &lt;em&gt;no&lt;/em&gt; es el caso de Julia. En Julia, el compilador generalmente conoce los tipos de todos los argumentos de funci&amp;oacute;n, variables locales y expresiones. Sin embargo, hay algunos casos espec&amp;iacute;ficos en los que las declaraciones son &amp;uacute;tiles.</target>
        </trans-unit>
        <trans-unit id="9450b748dbcdb8ba9fd42add95485312cab4012f" translate="yes" xml:space="preserve">
          <source>In mathematics, &lt;code&gt;+&lt;/code&gt; usually denotes a &lt;em&gt;commutative&lt;/em&gt; operation, where the order of the operands does not matter. An example of this is matrix addition, where &lt;code&gt;A + B == B + A&lt;/code&gt; for any matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; that have the same shape. In contrast, &lt;code&gt;*&lt;/code&gt; typically denotes a &lt;em&gt;noncommutative&lt;/em&gt; operation, where the order of the operands &lt;em&gt;does&lt;/em&gt; matter. An example of this is matrix multiplication, where in general &lt;code&gt;A * B != B * A&lt;/code&gt;. As with matrix multiplication, string concatenation is noncommutative: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt;. As such, &lt;code&gt;*&lt;/code&gt; is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.</source>
          <target state="translated">En matem&amp;aacute;ticas, &lt;code&gt;+&lt;/code&gt; generalmente denota una operaci&amp;oacute;n &lt;em&gt;conmutativa&lt;/em&gt; , donde el orden de los operandos no importa. Un ejemplo de esto es la suma de matrices, donde &lt;code&gt;A + B == B + A&lt;/code&gt; para las matrices &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; que tienen la misma forma. Por el contrario, &lt;code&gt;*&lt;/code&gt; normalmente denota una operaci&amp;oacute;n &lt;em&gt;no conmutativa&lt;/em&gt; , donde el orden de los operandos &lt;em&gt;s&amp;iacute;&lt;/em&gt; importa. Un ejemplo de esto es la multiplicaci&amp;oacute;n de matrices, donde, en general, &lt;code&gt;A * B != B * A&lt;/code&gt; . Al igual que con la multiplicaci&amp;oacute;n de matrices, la concatenaci&amp;oacute;n de cadenas no es conmutativa: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt; . Como tal, &lt;code&gt;*&lt;/code&gt; es una opci&amp;oacute;n m&amp;aacute;s natural para un operador de concatenaci&amp;oacute;n de cadenas infijas, consistente con el uso matem&amp;aacute;tico com&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="ab8bd1f7589c990d976c1051b69449b020a43727" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">En casos m&amp;aacute;s complejos, resolver las ambig&amp;uuml;edades del m&amp;eacute;todo implica cierto elemento de dise&amp;ntilde;o; este tema se explora m&amp;aacute;s &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;adelante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be4d8bd032078d1d618f689c7b9a8339132970a1" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;code&gt;abs&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, si &lt;code&gt;A&lt;/code&gt; es un subtipo &lt;code&gt;S&lt;/code&gt; de &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; con un tipo de elemento &lt;code&gt;T&lt;/code&gt; que admite &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; y &lt;code&gt;/&lt;/code&gt; , el tipo de retorno es &lt;code&gt;LU{T,S{T}}&lt;/code&gt; . Si se elige pivotar (predeterminado), el tipo de elemento tambi&amp;eacute;n debe admitir &lt;code&gt;abs&lt;/code&gt; y &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c01897c1c5dfe56ff403bf92da50402dc901b089" translate="yes" xml:space="preserve">
          <source>In order to access the data of x, we can use &lt;code&gt;jl_array_data&lt;/code&gt;:</source>
          <target state="translated">Para acceder a los datos de x, podemos usar &lt;code&gt;jl_array_data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c8c964572487783a93c9f805bd24c6191a24c97" translate="yes" xml:space="preserve">
          <source>In order to build this program you have to put the path to the Julia header into the include path and link against &lt;code&gt;libjulia&lt;/code&gt;. For instance, when Julia is installed to &lt;code&gt;$JULIA_DIR&lt;/code&gt;, one can compile the above test program &lt;code&gt;test.c&lt;/code&gt; with &lt;code&gt;gcc&lt;/code&gt; using:</source>
          <target state="translated">Para construir este programa, debe colocar la ruta al encabezado de Julia en la ruta de inclusi&amp;oacute;n y vincularla con &lt;code&gt;libjulia&lt;/code&gt; . Por ejemplo, cuando Julia est&amp;aacute; instalada en &lt;code&gt;$JULIA_DIR&lt;/code&gt; , se puede compilar el programa de prueba anterior &lt;code&gt;test.c&lt;/code&gt; con &lt;code&gt;gcc&lt;/code&gt; usando:</target>
        </trans-unit>
        <trans-unit id="f634f39fd97c0fd5eaef9dfae9571e089a9c4f67" translate="yes" xml:space="preserve">
          <source>In order to check whether &lt;code&gt;ret&lt;/code&gt; is of a specific Julia type, we can use the &lt;code&gt;jl_isa&lt;/code&gt;, &lt;code&gt;jl_typeis&lt;/code&gt;, or &lt;code&gt;jl_is_...&lt;/code&gt; functions. By typing &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; into the Julia shell we can see that the return type is &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;double&lt;/code&gt; in C). To convert the boxed Julia value into a C double the &lt;code&gt;jl_unbox_float64&lt;/code&gt; function is used in the above code snippet.</source>
          <target state="translated">Con el fin de comprobar si &lt;code&gt;ret&lt;/code&gt; es de un tipo espec&amp;iacute;fico de Julia, podemos utilizar los &lt;code&gt;jl_isa&lt;/code&gt; , &lt;code&gt;jl_typeis&lt;/code&gt; , o &lt;code&gt;jl_is_...&lt;/code&gt; funciones. Al escribir &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; en el shell de Julia, podemos ver que el tipo de retorno es &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;double&lt;/code&gt; en C). Para convertir el valor de Julia en caja en un doble de C , se usa la funci&amp;oacute;n &lt;code&gt;jl_unbox_float64&lt;/code&gt; en el fragmento de c&amp;oacute;digo anterior.</target>
        </trans-unit>
        <trans-unit id="c26dfd25e758364e0dcd1c617a188ec51d32baad" translate="yes" xml:space="preserve">
          <source>In order to compute trigonometric functions with degrees instead of radians, suffix the function with &lt;code&gt;d&lt;/code&gt;. For example, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt;&lt;code&gt;sind(x)&lt;/code&gt;&lt;/a&gt; computes the sine of &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is specified in degrees. The complete list of trigonometric functions with degree variants is:</source>
          <target state="translated">Para calcular funciones trigonom&amp;eacute;tricas con grados en lugar de radianes, agregue el sufijo &lt;code&gt;d&lt;/code&gt; a la funci&amp;oacute;n . Por ejemplo, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt; &lt;code&gt;sind(x)&lt;/code&gt; &lt;/a&gt; calcula el seno de &lt;code&gt;x&lt;/code&gt; donde &lt;code&gt;x&lt;/code&gt; se especifica en grados. La lista completa de funciones trigonom&amp;eacute;tricas con variantes de grado es:</target>
        </trans-unit>
        <trans-unit id="f65b6a7038eae90009481c5aaae33e0c39a02ac4" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;repr(io, mime, x)&lt;/code&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="translated">Para definir un nuevo backend de pantalla, primero se debe crear un subtipo &lt;code&gt;D&lt;/code&gt; de la clase abstracta &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; &lt;/a&gt; . Luego, para cada tipo MIME ( cadena &lt;code&gt;mime&lt;/code&gt; ) que se puede mostrar en &lt;code&gt;D&lt;/code&gt; , se debe definir una funci&amp;oacute;n de &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; que muestre &lt;code&gt;x&lt;/code&gt; como ese tipo MIME, normalmente llamando a &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(io, mime, x)&lt;/code&gt; &lt;/a&gt; o &lt;code&gt;repr(io, mime, x)&lt;/code&gt; . Se debe &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; un MethodError si &lt;code&gt;x&lt;/code&gt; no se puede mostrar como ese tipo MIME; esto es autom&amp;aacute;tico si uno llama &lt;code&gt;show&lt;/code&gt; o &lt;code&gt;repr&lt;/code&gt; . Finalmente, se debe definir una funci&amp;oacute;n de &lt;code&gt;display(d::D, x)&lt;/code&gt; que las consultas se pueden &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt; &lt;code&gt;showable(mime, x)&lt;/code&gt; &lt;/a&gt; para los tipos de &lt;code&gt;mime&lt;/code&gt; admitidos por &lt;code&gt;D&lt;/code&gt; y muestra el &quot;mejor&quot;; &lt;code&gt;MethodError&lt;/code&gt; debe lanzar un MethodError si no se encuentran tipos MIME compatibles para &lt;code&gt;x&lt;/code&gt; . De manera similar, algunos subtipos pueden desear anular la &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt; &lt;code&gt;redisplay(d::D, ...)&lt;/code&gt; &lt;/a&gt; . (Nuevamente, uno debe &lt;code&gt;import Base.display&lt;/code&gt; para agregar nuevos m&amp;eacute;todos para &lt;code&gt;display&lt;/code&gt; ). Los valores de retorno de estas funciones dependen de la implementaci&amp;oacute;n (ya que en algunos casos puede ser &amp;uacute;til devolver un &quot;identificador&quot; de pantalla de alg&amp;uacute;n tipo). Las funciones de pantalla para &lt;code&gt;D&lt;/code&gt; se pueden llamar directamente, pero tambi&amp;eacute;n se pueden invocar autom&amp;aacute;ticamente desde la &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; simplemente empujando una nueva pantalla en la pila de backend de pantalla con:</target>
        </trans-unit>
        <trans-unit id="e0fa42e97ec0c0f5639428f8bc25c0313c261f3b" translate="yes" xml:space="preserve">
          <source>In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.</source>
          <target state="translated">Para despachar una lista de argumentos paramétricos de varios niveles,a menudo es mejor separar cada nivel de despacho en funciones distintas.Esto puede sonar similar en el enfoque del despacho único,pero como veremos más adelante,es aún más flexible.</target>
        </trans-unit>
        <trans-unit id="c64f4c986b251a9a23920c12ed0e829f663e97f9" translate="yes" xml:space="preserve">
          <source>In order to implement such a &lt;code&gt;copy&lt;/code&gt; or &lt;code&gt;copyto!&lt;/code&gt;, method, of course, you must work with the &lt;code&gt;Broadcasted&lt;/code&gt; wrapper to compute each element. There are two main ways of doing so:</source>
          <target state="translated">&amp;iexcl;Para implementar tal &lt;code&gt;copy&lt;/code&gt; o &lt;code&gt;copyto!&lt;/code&gt; , m&amp;eacute;todo, por supuesto, debe trabajar con el contenedor &lt;code&gt;Broadcasted&lt;/code&gt; para calcular cada elemento. Hay dos formas principales de hacerlo:</target>
        </trans-unit>
        <trans-unit id="7c65ae2a5b36599056aee26d3163a0e9101f727b" translate="yes" xml:space="preserve">
          <source>In order to losslessly represent arbitrary byte streams stored in a &lt;code&gt;String&lt;/code&gt;, a &lt;code&gt;Char&lt;/code&gt; value may store information that cannot be converted to a Unicode codepoint &amp;mdash; converting such a &lt;code&gt;Char&lt;/code&gt; to &lt;code&gt;UInt32&lt;/code&gt; will throw an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid(c::Char)&lt;/code&gt;&lt;/a&gt; function can be used to query whether &lt;code&gt;c&lt;/code&gt; represents a valid Unicode character.</source>
          <target state="translated">Para representar sin p&amp;eacute;rdidas secuencias de bytes arbitrarias almacenadas en una &lt;code&gt;String&lt;/code&gt; , un valor de &lt;code&gt;Char&lt;/code&gt; puede almacenar informaci&amp;oacute;n que no se puede convertir a un punto de c&amp;oacute;digo Unicode; la conversi&amp;oacute;n de dicho &lt;code&gt;Char&lt;/code&gt; a &lt;code&gt;UInt32&lt;/code&gt; arrojar&amp;aacute; un error. La funci&amp;oacute;n &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid(c::Char)&lt;/code&gt; &lt;/a&gt; se puede utilizar para consultar si &lt;code&gt;c&lt;/code&gt; representa un car&amp;aacute;cter Unicode v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="fab91460cbe612949b4b9d95753296ca7abe3d3b" translate="yes" xml:space="preserve">
          <source>In order to pass this function to C, we obtain its address using the macro &lt;code&gt;@cfunction&lt;/code&gt;:</source>
          <target state="translated">Para pasar esta funci&amp;oacute;n a C, obtenemos su direcci&amp;oacute;n usando la macro &lt;code&gt;@cfunction&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cd5618b4a563dff2d7a927d5353ef78a361df290" translate="yes" xml:space="preserve">
          <source>In order to refer to &lt;code&gt;MyType&lt;/code&gt; across all processes, &lt;code&gt;DummyModule.jl&lt;/code&gt; needs to be loaded on every process. Calling &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; loads it only on a single process. To load it on every process, use the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt;&lt;code&gt;@everywhere&lt;/code&gt;&lt;/a&gt; macro (starting Julia with &lt;code&gt;julia -p 2&lt;/code&gt;):</source>
          <target state="translated">Para hacer referencia a &lt;code&gt;MyType&lt;/code&gt; en todos los procesos, &lt;code&gt;DummyModule.jl&lt;/code&gt; necesario cargar DummyModule.jl en cada proceso. Llamar a &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; carga solo en un &amp;uacute;nico proceso. Para cargarlo en cada proceso, use la macro &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt; &lt;code&gt;@everywhere&lt;/code&gt; &lt;/a&gt; (comenzando Julia con &lt;code&gt;julia -p 2&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="47f30e462ec98fcc58c9494bb836f85ec8257aff" translate="yes" xml:space="preserve">
          <source>In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values &amp;ndash;- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.</source>
          <target state="translated">Para soportar la mutaci&amp;oacute;n, tales objetos generalmente se asignan en el mont&amp;oacute;n y tienen direcciones de memoria estables. Un objeto mutable es como un peque&amp;ntilde;o contenedor que puede contener diferentes valores a lo largo del tiempo y, por lo tanto, solo se puede identificar de manera confiable con su direcci&amp;oacute;n. Por el contrario, una instancia de un tipo inmutable se asocia con valores de campo espec&amp;iacute;ficos - los valores de campo por s&amp;iacute; solos le dicen todo sobre el objeto. Al decidir si convertir un tipo en mutable, pregunte si dos instancias con los mismos valores de campo se considerar&amp;iacute;an id&amp;eacute;nticas o si podr&amp;iacute;an necesitar cambiar de forma independiente con el tiempo. Si se consideraran id&amp;eacute;nticos, el tipo probablemente deber&amp;iacute;a ser inmutable.</target>
        </trans-unit>
        <trans-unit id="2f2293a5b64eabd8ff88bd22ea606404b9b1e108" translate="yes" xml:space="preserve">
          <source>In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The &lt;code&gt;continue&lt;/code&gt; keyword accomplishes this:</source>
          <target state="translated">En otras circunstancias, es &amp;uacute;til poder detener una iteraci&amp;oacute;n y pasar a la siguiente inmediatamente. La palabra clave &lt;code&gt;continue&lt;/code&gt; logra esto:</target>
        </trans-unit>
        <trans-unit id="c004c636d1b0703eca9cda2590edfd6579e7129c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa(A,Type{B})&lt;/code&gt;&lt;/a&gt; is true if and only if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are the same object and that object is a type. Without the parameter, &lt;code&gt;Type&lt;/code&gt; is simply an abstract type which has all type objects as its instances, including, of course, singleton types:</source>
          <target state="translated">En otras palabras, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa(A,Type{B})&lt;/code&gt; &lt;/a&gt; es verdadero si y solo si &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; son el mismo objeto y ese objeto es un tipo. Sin el par&amp;aacute;metro, &lt;code&gt;Type&lt;/code&gt; es simplemente un tipo abstracto que tiene todos los objetos de tipo como sus instancias, incluidos, por supuesto, los tipos singleton:</target>
        </trans-unit>
        <trans-unit id="fb4e1a8fb772b24b6039451c201b81e5c718d91a" translate="yes" xml:space="preserve">
          <source>In other words, in the parlance of type theory, Julia's type parameters are &lt;em&gt;invariant&lt;/em&gt;, rather than being &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;covariant (or even contravariant)&lt;/a&gt;. This is for practical reasons: while any instance of &lt;code&gt;Point{Float64}&lt;/code&gt; may conceptually be like an instance of &lt;code&gt;Point{Real}&lt;/code&gt; as well, the two types have different representations in memory:</source>
          <target state="translated">En otras palabras, en el lenguaje de la teor&amp;iacute;a de tipos, los par&amp;aacute;metros de tipo de Julia son &lt;em&gt;invariantes&lt;/em&gt; , en lugar de ser &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;covariantes (o incluso contravariantes)&lt;/a&gt; . Esto es por razones pr&amp;aacute;cticas: mientras que cualquier instancia de &lt;code&gt;Point{Float64}&lt;/code&gt; puede ser conceptualmente como una instancia de &lt;code&gt;Point{Real}&lt;/code&gt; tambi&amp;eacute;n, los dos tipos tienen diferentes representaciones en la memoria:</target>
        </trans-unit>
        <trans-unit id="2489400c16a870eb77390027298b5bae2afac7fd" translate="yes" xml:space="preserve">
          <source>In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character rather than multiple invalid characters. This rule may be best explained with an example:</source>
          <target state="translated">En particular,esto significa que las secuencias de unidades de código demasiado largas y demasiado altas y sus prefijos se tratan como un único carácter inválido en lugar de múltiples caracteres inválidos.Esta regla puede explicarse mejor con un ejemplo:</target>
        </trans-unit>
        <trans-unit id="86e6d7b557572810776afd763390d8c87a4b9b3f" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="translated">En particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; es t&amp;iacute;picamente una versi&amp;oacute;n &quot;bonita impresa&quot; de &lt;code&gt;x&lt;/code&gt; dise&amp;ntilde;ada para el consumo humano. Consulte tambi&amp;eacute;n &lt;code&gt;repr(x)&lt;/code&gt; para devolver una cadena correspondiente a &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; que puede estar m&amp;aacute;s cerca de c&amp;oacute;mo se ingresar&amp;iacute;a el valor de &lt;code&gt;x&lt;/code&gt; en Julia.</target>
        </trans-unit>
        <trans-unit id="a352a9e712137ef0293428d01a95dc381f03f45f" translate="yes" xml:space="preserve">
          <source>In particular, if you define a &lt;code&gt;function __init__()&lt;/code&gt; in a module, then Julia will call &lt;code&gt;__init__()&lt;/code&gt; immediately &lt;em&gt;after&lt;/em&gt; the module is loaded (e.g., by &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, or &lt;code&gt;require&lt;/code&gt;) at runtime for the &lt;em&gt;first&lt;/em&gt; time (i.e., &lt;code&gt;__init__&lt;/code&gt; is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their &lt;code&gt;__init__&lt;/code&gt; functions called &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;__init__&lt;/code&gt; of the enclosing module.</source>
          <target state="translated">En particular, si define una &lt;code&gt;function __init__()&lt;/code&gt; en un m&amp;oacute;dulo, Julia llamar&amp;aacute; a &lt;code&gt;__init__()&lt;/code&gt; inmediatamente &lt;em&gt;despu&amp;eacute;s de&lt;/em&gt; que se cargue el m&amp;oacute;dulo (por ejemplo, por &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n , &lt;code&gt;using&lt;/code&gt; o &lt;code&gt;require&lt;/code&gt; ) en tiempo de ejecuci&amp;oacute;n por &lt;em&gt;primera&lt;/em&gt; vez (es decir, &lt;code&gt;__init__&lt;/code&gt; es solo se llama una vez, y solo despu&amp;eacute;s de que se hayan ejecutado todas las instrucciones del m&amp;oacute;dulo). Debido a que se llama despu&amp;eacute;s de que el m&amp;oacute;dulo est&amp;aacute; totalmente importada, los subm&amp;oacute;dulos u otros m&amp;oacute;dulos importados tienen sus &lt;code&gt;__init__&lt;/code&gt; funciones llamadas &lt;em&gt;antes de&lt;/em&gt; la &lt;code&gt;__init__&lt;/code&gt; del m&amp;oacute;dulo de cerramiento.</target>
        </trans-unit>
        <trans-unit id="7f00fe64f586624c25d908def02434ca5a5747cc" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;LibGit2.free&lt;/code&gt; should be called afterward on the &lt;code&gt;Ref&lt;/code&gt; object.</source>
          <target state="translated">En particular, tenga en cuenta que &lt;code&gt;LibGit2.free&lt;/code&gt; debe llamarse posteriormente en el objeto &lt;code&gt;Ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b992ee319e3397f73ab42aa368ea422a279c258" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;missing == missing&lt;/code&gt; returns &lt;code&gt;missing&lt;/code&gt;, so &lt;code&gt;==&lt;/code&gt; cannot be used to test whether a value is missing. To test whether &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;, use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En particular, tenga en cuenta que &lt;code&gt;missing == missing&lt;/code&gt; devuelve &lt;code&gt;missing&lt;/code&gt; , por lo que &lt;code&gt;==&lt;/code&gt; no se puede usar para probar si falta un valor. Para probar si &lt;code&gt;x&lt;/code&gt; est&amp;aacute; &lt;code&gt;missing&lt;/code&gt; , el uso &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10aa2526d9c8eb28f8fc8b12b251cb66391f9afe" translate="yes" xml:space="preserve">
          <source>In particular, this means that small enough immutable values like integers and floats are typically passed to functions in registers (or stack allocated).</source>
          <target state="translated">En particular,esto significa que valores suficientemente pequeños e inmutables,como números enteros y flotadores,suelen pasar a las funciones de los registros (o a la pila asignada).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
