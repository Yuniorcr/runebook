<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="5bf36d0687ba161c1ddd5ae9a710ac6b84c65e73" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Less-Than Above Double-Line Equal</source>
          <target state="translated">Mayor-que-Menos-que-Sobre-la-doble-línea-igual</target>
        </trans-unit>
        <trans-unit id="cda9caba673dd1973f8c7d113746b0e633f4f938" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Above Less-Than</source>
          <target state="translated">Más grande que arriba Más similar que arriba Menos que</target>
        </trans-unit>
        <trans-unit id="3a03ecfc7255d8cacd17931a2c17d195720afbd9" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Or Equal</source>
          <target state="translated">Mayor que el anterior similar o igual</target>
        </trans-unit>
        <trans-unit id="eed03df20a091917ea38ceacb7e9c2b67e0f9bb2" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Slanted Equal Above Less-Than Above Slanted Equal</source>
          <target state="translated">Mayor que la igualada por encima de la igualada por encima de la igualada por encima de la igualada por encima de la igualada por encima de la igualada</target>
        </trans-unit>
        <trans-unit id="ec6a31bc7051547d44e2c612da8aa15b61e41be6" translate="yes" xml:space="preserve">
          <source>Greater-Than And Not Approximate</source>
          <target state="translated">Mayor que y no aproximado</target>
        </trans-unit>
        <trans-unit id="852f9d0047fa29fbc8fb2cb24463f569deef89ef" translate="yes" xml:space="preserve">
          <source>Greater-Than And Single-Line Not Equal To</source>
          <target state="translated">Mayor-que-y-línea-única no es igual a</target>
        </trans-unit>
        <trans-unit id="52afc7afef44a974f7bc9b05b1e17bf964f408a0" translate="yes" xml:space="preserve">
          <source>Greater-Than Beside Less-Than</source>
          <target state="translated">Más que al lado de menos que</target>
        </trans-unit>
        <trans-unit id="8002394d4a4c3c62e2b6ebf6a841410b987f3fe3" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To</source>
          <target state="translated">Mayor que pero no igual a/mayor que pero no igual a</target>
        </trans-unit>
        <trans-unit id="9f51323c1f1f2bd6fed8b0133087b13833db9603" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">Mayor que pero no igual a/mayor que pero no igual a+selector de variaciones 1</target>
        </trans-unit>
        <trans-unit id="a9e5efe496a2b31f56957d4e597885897f8e0eb9" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equivalent To / Greater Than But Not Equivalent To</source>
          <target state="translated">Mayor que pero no equivalente a/Mayor que pero no equivalente a</target>
        </trans-unit>
        <trans-unit id="98eff7a1e60f594f0f81d4c3e83cbf5209423bb1" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve</source>
          <target state="translated">Más grande que cerrado por una curva</target>
        </trans-unit>
        <trans-unit id="099b37f93e6b34dbfa7c526c5fa3f13b59c30374" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">Más grande que cerrado por la curva por encima de la igualdad inclinada</target>
        </trans-unit>
        <trans-unit id="bb2d6f56b2861cf6b4d17b1cfddecb19b41dd882" translate="yes" xml:space="preserve">
          <source>Greater-Than Equal To Or Less-Than / Greater Than Equal To Or Less Than</source>
          <target state="translated">Mayor que igual o menor que/mayor que igual o menor que</target>
        </trans-unit>
        <trans-unit id="1f9f324edcdf276db2fba93d474c1d37dd1409bf" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Approximate</source>
          <target state="translated">Mayor que o aproximado</target>
        </trans-unit>
        <trans-unit id="816b73122f7826a76fc5a27a59be585ac1c20c8e" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equal To / Greater Than Or Equal To</source>
          <target state="translated">Mayor que o igual a/mayor que o igual a</target>
        </trans-unit>
        <trans-unit id="22f6cd5ba77c22771ae0dcb6dec580b58470b15f" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equivalent To / Greater Than Or Equivalent To</source>
          <target state="translated">Mayor que o equivalente a/mayor que o equivalente a</target>
        </trans-unit>
        <trans-unit id="da7070ff7fe0d357657567e892ae9e792dd0711c" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Less-Than / Greater Than Or Less Than</source>
          <target state="translated">Mayor que o menor que/mayor que o menor que</target>
        </trans-unit>
        <trans-unit id="fc2308a37940cf5145837f4b055616cdf8ed8663" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To</source>
          <target state="translated">Mayor que o inclinado igual a</target>
        </trans-unit>
        <trans-unit id="fc0db4bdca25b60daf5c07123869e9c3373f86d1" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">Mayor que o inclinado igual a+Combinando la superposición de sólidos largos/superposición de barras largas no espaciadas</target>
        </trans-unit>
        <trans-unit id="3d2877fe16bd8c1aff6ca20742e54d7c40adcfb5" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">Más grande que o inclinado igual a con el punto de arriba</target>
        </trans-unit>
        <trans-unit id="5b85b82c5dfec29b3e76371a3c759b7b564d0dcc" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above Left</source>
          <target state="translated">Más grande que o inclinado igual a con el punto de arriba a la izquierda</target>
        </trans-unit>
        <trans-unit id="324053698d665835c3c8543b9475493cada464ce" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">Más grande que o inclinada igual a con punto en el interior</target>
        </trans-unit>
        <trans-unit id="eaf2aeee67af979dcb4bf973f1c28801c9b3c428" translate="yes" xml:space="preserve">
          <source>Greater-Than Over Equal To / Greater Than Over Equal To</source>
          <target state="translated">Mayor que sobre igual a/mayor que sobre igual a</target>
        </trans-unit>
        <trans-unit id="88e04ffb7bbd7b8b561e5e62dab6aaf4e8ec7d4c" translate="yes" xml:space="preserve">
          <source>Greater-Than Overlapping Less-Than</source>
          <target state="translated">Más grande que la superposición Menos que</target>
        </trans-unit>
        <trans-unit id="7eb5603be44b831a023cfdcd22f839b5f6f5bded" translate="yes" xml:space="preserve">
          <source>Greater-Than With Circle Inside</source>
          <target state="translated">Más grande que con un círculo en el interior</target>
        </trans-unit>
        <trans-unit id="f158072571829726fe84a7ad0ce7a50ef1ab0879" translate="yes" xml:space="preserve">
          <source>Greater-Than With Dot / Greater Than With Dot</source>
          <target state="translated">Mayor que con el punto/Mayor que con el punto</target>
        </trans-unit>
        <trans-unit id="209f35de5184bc36aa0d1b903151a9fc65c6ba61" translate="yes" xml:space="preserve">
          <source>Greater-Than With Question Mark Above</source>
          <target state="translated">Mayor que con el signo de interrogación de arriba</target>
        </trans-unit>
        <trans-unit id="1bd3d8bbe04802c889994d907ddead65a92d7cca" translate="yes" xml:space="preserve">
          <source>Greater-than comparison operator. Falls back to &lt;code&gt;y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">Operador de comparaci&amp;oacute;n mayor que. Vuelve a &lt;code&gt;y &amp;lt; x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9b75dd8da9fbc05fe433d4046e50ff253af5b8" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equals comparison operator. Falls back to &lt;code&gt;y &amp;lt;= x&lt;/code&gt;.</source>
          <target state="translated">Operador de comparaci&amp;oacute;n mayor o igual que. Vuelve a &lt;code&gt;y &amp;lt;= x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c889dfd5914acacbd51c9ee1f6424d7475f18ba9" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero).</source>
          <target state="translated">Com&amp;uacute;n mayor divisor (positivo) (o cero si &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; son ambos cero).</target>
        </trans-unit>
        <trans-unit id="b3c118d12ee713605454a73fa83e73fd62da99f2" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero). The arguments may be integer and rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c137f18236c59d67effecc9926b91bc4e6c388c" translate="yes" xml:space="preserve">
          <source>Greek Beta Symbol / Greek Small Letter Curled Beta</source>
          <target state="translated">Símbolo griego Beta/Letra pequeña griega Beta rizada</target>
        </trans-unit>
        <trans-unit id="c90a544a84e41b0027e35535de12e9412929c3b9" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Alpha</source>
          <target state="translated">Letra mayúscula griega Alfa</target>
        </trans-unit>
        <trans-unit id="034c000ae09a7efb7dcd09b84c993f24a59b651a" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Beta</source>
          <target state="translated">Letra mayúscula griega Beta</target>
        </trans-unit>
        <trans-unit id="d91481b132bdcebe4f898c637891a19c7e0d2807" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Chi</source>
          <target state="translated">Letra mayúscula griega Chi</target>
        </trans-unit>
        <trans-unit id="3e715476cf54a47fc160c1f17257b6e0b611dcf0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Delta</source>
          <target state="translated">Letra mayúscula griega Delta</target>
        </trans-unit>
        <trans-unit id="e7b36e8f2dc5d428f4c0fbae5314c79d701290b8" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Epsilon</source>
          <target state="translated">Letra mayúscula griega Epsilon</target>
        </trans-unit>
        <trans-unit id="9632923c81e91309b0197e9f6256e5ddc583b3f1" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Eta</source>
          <target state="translated">Letra mayúscula griega ETA</target>
        </trans-unit>
        <trans-unit id="b63912e4ec51d609e069730c367de176e6e9799e" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Gamma</source>
          <target state="translated">Letra mayúscula griega Gamma</target>
        </trans-unit>
        <trans-unit id="003ecb167b62284b9bb24641dd3e450774ffb206" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Iota</source>
          <target state="translated">Letra mayúscula griega Iota</target>
        </trans-unit>
        <trans-unit id="97e0c3c41b2cd617ba1f3aefc97784af90e81883" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Kappa</source>
          <target state="translated">Letra mayúscula griega Kappa</target>
        </trans-unit>
        <trans-unit id="8766675df925b8c25168f5080a3ffb3054a6bbf7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Lamda / Greek Capital Letter Lambda</source>
          <target state="translated">Letra mayúscula griega Lamda/Letra mayúscula griega Lambda</target>
        </trans-unit>
        <trans-unit id="93f0db4c50dab02a7cf643e0e6463e461b78350b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Mu</source>
          <target state="translated">Letra mayúscula griega Mu</target>
        </trans-unit>
        <trans-unit id="c5ff86b57695b2194281052f49d3a518561ee43b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Nu</source>
          <target state="translated">Letra mayúscula griega Nu</target>
        </trans-unit>
        <trans-unit id="8d3af0cfd66c1c551b9d25df70d96ca3b3e41655" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omega</source>
          <target state="translated">Letra mayúscula griega Omega</target>
        </trans-unit>
        <trans-unit id="60cb22c8a7263835043a1bf3e2390a30ccb009da" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omicron</source>
          <target state="translated">Letra mayúscula griega Omicron</target>
        </trans-unit>
        <trans-unit id="9ef46dcc225d47def0f7ae271f6bce8a9447782c" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Phi</source>
          <target state="translated">Letra mayúscula griega Phi</target>
        </trans-unit>
        <trans-unit id="bdfd940817a68024f4561b28e37abe5c6aa8ae33" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Pi</source>
          <target state="translated">Letra mayúscula griega Pi</target>
        </trans-unit>
        <trans-unit id="9eb135fdc0eb8f41676f0233eced63bfb63b8d29" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Psi</source>
          <target state="translated">Letra mayúscula griega Psi</target>
        </trans-unit>
        <trans-unit id="42581daba465402bb427e86f725e50cbf13c5589" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Rho</source>
          <target state="translated">Letra mayúscula griega Rho</target>
        </trans-unit>
        <trans-unit id="9ba5f4b3b8d0114e4ebb66c0c247b421553311c0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Sigma</source>
          <target state="translated">Letra mayúscula griega Sigma</target>
        </trans-unit>
        <trans-unit id="ce15c49fc86bc080b59dcc6c6f912a5f65fcea89" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Tau</source>
          <target state="translated">Letra mayúscula griega Tau</target>
        </trans-unit>
        <trans-unit id="c53695a8df7adbb8087dbbf3f92d38bad6c54a97" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Theta</source>
          <target state="translated">Letra mayúscula griega Theta</target>
        </trans-unit>
        <trans-unit id="e5671b238dc9a21dfba521fd40bfb114bae616b4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Upsilon</source>
          <target state="translated">Letra mayúscula griega Upsilon</target>
        </trans-unit>
        <trans-unit id="7ee18055cc5ff646350aabb8125c5079d084ebc7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Xi</source>
          <target state="translated">Letra mayúscula griega Xi</target>
        </trans-unit>
        <trans-unit id="ff11a198311aac30e2248ebcb8edaa9900afa1c4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Zeta</source>
          <target state="translated">Letra mayúscula griega Zeta</target>
        </trans-unit>
        <trans-unit id="75f6796d9ad54779470705290e7c7602d7a845bd" translate="yes" xml:space="preserve">
          <source>Greek Capital Theta Symbol</source>
          <target state="translated">Símbolo de la capital griega Theta</target>
        </trans-unit>
        <trans-unit id="533978fb12373ffa98e45e16bb2525fdaa4ff4dc" translate="yes" xml:space="preserve">
          <source>Greek Kappa Symbol / Greek Small Letter Script Kappa</source>
          <target state="translated">Símbolo Griego Kappa/Guión Griego de Letras Pequeñas Kappa</target>
        </trans-unit>
        <trans-unit id="098ec4a81c9f38263e62700b20a2a6894858fb2e" translate="yes" xml:space="preserve">
          <source>Greek Letter Archaic Koppa</source>
          <target state="translated">Carta griega Arcaica Koppa</target>
        </trans-unit>
        <trans-unit id="c2ec8b8cfe62422b5013f3acdd510642f682d268" translate="yes" xml:space="preserve">
          <source>Greek Letter Digamma / Greek Capital Letter Digamma</source>
          <target state="translated">Letra griega Digamma/Letra mayúscula griega Digamma</target>
        </trans-unit>
        <trans-unit id="ced5a29435b2a381da90865a6dc27f1b51bd0151" translate="yes" xml:space="preserve">
          <source>Greek Letter Koppa / Greek Capital Letter Koppa</source>
          <target state="translated">Letra griega Koppa/Letra mayúscula griega Koppa</target>
        </trans-unit>
        <trans-unit id="b1fd4e84b1e13403c9fa5cc0de48f63d1cf94bc6" translate="yes" xml:space="preserve">
          <source>Greek Letter Sampi / Greek Capital Letter Sampi</source>
          <target state="translated">Letra griega Sampi/Letra mayúscula griega Sampi</target>
        </trans-unit>
        <trans-unit id="6736119dd29a2f705206a98b22de530d1dcccd83" translate="yes" xml:space="preserve">
          <source>Greek Letter Stigma / Greek Capital Letter Stigma</source>
          <target state="translated">Estigma de letras griegas/Estigma de letras mayúsculas griegas</target>
        </trans-unit>
        <trans-unit id="ea7aa3ec425217aedfab9d34ef40b0b566351176" translate="yes" xml:space="preserve">
          <source>Greek Lunate Epsilon Symbol</source>
          <target state="translated">Símbolo griego lunar de Épsilon</target>
        </trans-unit>
        <trans-unit id="dfaadea9364a20060c114ea92b3c24b30e9e1221" translate="yes" xml:space="preserve">
          <source>Greek Phi Symbol / Greek Small Letter Script Phi</source>
          <target state="translated">Símbolo griego Phi/Guión griego de letras pequeñas Phi</target>
        </trans-unit>
        <trans-unit id="0ae051b71680a4d39d72cb02f855a3c712e5bd2c" translate="yes" xml:space="preserve">
          <source>Greek Pi Symbol / Greek Small Letter Omega Pi</source>
          <target state="translated">Símbolo griego Pi/Letra pequeña griega Omega Pi</target>
        </trans-unit>
        <trans-unit id="f50bb1d13ed32ec906d7d6aaaaee29e7aa027d22" translate="yes" xml:space="preserve">
          <source>Greek Reversed Lunate Epsilon Symbol</source>
          <target state="translated">Símbolo griego de Épsilon lunar invertido</target>
        </trans-unit>
        <trans-unit id="ac07b5056a85d49adcf70f2b544a74ea6ecf6dce" translate="yes" xml:space="preserve">
          <source>Greek Rho Symbol / Greek Small Letter Tailed Rho</source>
          <target state="translated">Símbolo griego Rho/Letra pequeña griega Rho con cola</target>
        </trans-unit>
        <trans-unit id="448dc00d610b9b19fb08a7c7e6eb0a55f13d0a5d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Alpha</source>
          <target state="translated">Letra pequeña griega Alfa</target>
        </trans-unit>
        <trans-unit id="71d9bba39729f37db08ecc6cfd07622c292a3bcb" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Archaic Koppa</source>
          <target state="translated">Letra pequeña griega Koppa Arcaica</target>
        </trans-unit>
        <trans-unit id="c2455c0fc133c1c49b746a40bf7fe8a2f613a4de" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Beta</source>
          <target state="translated">Letra pequeña griega Beta</target>
        </trans-unit>
        <trans-unit id="5f8706d38c341d4055ab40dfb27748f213e0fc49" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Chi</source>
          <target state="translated">Letra pequeña griega Chi</target>
        </trans-unit>
        <trans-unit id="4dcd438cdc63b711ea794ef765006ad5a6535bd8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Delta</source>
          <target state="translated">Letra pequeña griega Delta</target>
        </trans-unit>
        <trans-unit id="970eba5f1fd0ce763d594cfcc46caddd4212150e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Digamma</source>
          <target state="translated">Letra pequeña griega Digamma</target>
        </trans-unit>
        <trans-unit id="37cc4f8ed3f230c47dc11c83e4de12cf526a1b20" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Epsilon</source>
          <target state="translated">Letra pequeña griega Epsilon</target>
        </trans-unit>
        <trans-unit id="7ccbcb67c9381630a226a3b3c4b28371605f0d5a" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Eta</source>
          <target state="translated">Letra pequeña griega Eta</target>
        </trans-unit>
        <trans-unit id="c074819760ca3f5bfb2e80f9147ad5e5b56ba096" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Final Sigma</source>
          <target state="translated">Letra pequeña griega Sigma final</target>
        </trans-unit>
        <trans-unit id="46c3a6f8bc0a7d2d96bb1cd2543a7109d5b60cf2" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Gamma</source>
          <target state="translated">Letra pequeña griega Gamma</target>
        </trans-unit>
        <trans-unit id="4643eab845743a762892a109cabf22bfe96da620" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Iota</source>
          <target state="translated">Letra pequeña griega Iota</target>
        </trans-unit>
        <trans-unit id="3e9ea92015aac67d0b73db674b1ba4dee8fe5484" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Kappa</source>
          <target state="translated">Letra pequeña griega Kappa</target>
        </trans-unit>
        <trans-unit id="c67601530cb0f970279b136a8b536cfe4717bcd6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Koppa</source>
          <target state="translated">Letra pequeña griega Koppa</target>
        </trans-unit>
        <trans-unit id="8c54eb8dc3ac289b41335f3dc67e6533bf270a57" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Lamda / Greek Small Letter Lambda</source>
          <target state="translated">Letra minúscula griega Lamda/Letra minúscula griega Lambda</target>
        </trans-unit>
        <trans-unit id="7149178e5cd2592e10a36e0a107bc1c794d4f411" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Mu</source>
          <target state="translated">Letra pequeña griega Mu</target>
        </trans-unit>
        <trans-unit id="e9b48a4ac754761a9dfd350adeabe5d343e5cb8f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Nu</source>
          <target state="translated">Letra pequeña griega Nu</target>
        </trans-unit>
        <trans-unit id="be2da964640e6e3a6c6130c2c98b0cae86bc9a01" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omega</source>
          <target state="translated">Letra pequeña griega Omega</target>
        </trans-unit>
        <trans-unit id="039c14215303437a5f755bf47c77fbf3d49255e3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omicron</source>
          <target state="translated">Letra pequeña griega Omicron</target>
        </trans-unit>
        <trans-unit id="b844f337c63e69f41e1119e2ae91153b90ab2b4d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Phi</source>
          <target state="translated">Letra pequeña griega Phi</target>
        </trans-unit>
        <trans-unit id="95d050ef9ff90d9125fe852cf7d1543f2ce7e841" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Pi</source>
          <target state="translated">Letra pequeña griega Pi</target>
        </trans-unit>
        <trans-unit id="55e311ff6199f4bde7e5d73ace711e07be007a2f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Psi</source>
          <target state="translated">Letra minúscula griega Psi</target>
        </trans-unit>
        <trans-unit id="5af5bfd009ec9591a9cb29dfcc2932dec54d6ca8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Rho</source>
          <target state="translated">Letra pequeña griega Rho</target>
        </trans-unit>
        <trans-unit id="85d8bb7b244cafeb1ab811a9df619d45d2234ea6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sampi</source>
          <target state="translated">Letra pequeña griega Sampi</target>
        </trans-unit>
        <trans-unit id="3ec2ed80a66bc81ead34ee55592a6ea7debfff4e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sigma</source>
          <target state="translated">Letra pequeña griega Sigma</target>
        </trans-unit>
        <trans-unit id="cc430dcce9d526f42ad9a59b54895c602c6380d3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Stigma</source>
          <target state="translated">El estigma de las letras pequeñas griegas</target>
        </trans-unit>
        <trans-unit id="7c2c0c82fe6e748bf9ed49a1f4249b9e89ebb0b8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Tau</source>
          <target state="translated">Letra pequeña griega Tau</target>
        </trans-unit>
        <trans-unit id="b13a88433f3cb99d5c62955aca5de95fbd232103" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Theta</source>
          <target state="translated">Letra pequeña griega Theta</target>
        </trans-unit>
        <trans-unit id="cad5938bde69f48a48d99f9b129d82f0acd5468b" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Upsilon</source>
          <target state="translated">Letra pequeña griega Upsilon</target>
        </trans-unit>
        <trans-unit id="0761f90b7168a502798811085d1367b5eca5af17" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Xi</source>
          <target state="translated">Letra pequeña griega Xi</target>
        </trans-unit>
        <trans-unit id="40428b11afaf575da445431ab7ceb811220b9167" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Zeta</source>
          <target state="translated">Letra pequeña griega Zeta</target>
        </trans-unit>
        <trans-unit id="e32107e3b0620ecf09ddae3fe8f4666208d97040" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Beta</source>
          <target state="translated">Griego Subscript Small Letter Beta</target>
        </trans-unit>
        <trans-unit id="90a01f237c5981615d18499c4360233abc532e89" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Chi</source>
          <target state="translated">Letra minúscula del alfabeto griego Chi</target>
        </trans-unit>
        <trans-unit id="e6642d28d8aeb11d500775a8447736e31c6678cc" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Gamma</source>
          <target state="translated">Griego Subscript Small Letter Gamma</target>
        </trans-unit>
        <trans-unit id="8b5afd737dfb2072bb758ab79fe8cc816442c922" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Phi</source>
          <target state="translated">Letra minúscula del alfabeto griego Phi</target>
        </trans-unit>
        <trans-unit id="655a658031f914446d83820f4d7947b16f05e79e" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Rho</source>
          <target state="translated">Letra minúscula del alfabeto griego Rho</target>
        </trans-unit>
        <trans-unit id="be9f5ea4e76fd688fd62b7dd791af4a7ebcdb5c7" translate="yes" xml:space="preserve">
          <source>Greek Theta Symbol / Greek Small Letter Script Theta</source>
          <target state="translated">Símbolo griego Theta/Letra minúscula griega Escritura Theta</target>
        </trans-unit>
        <trans-unit id="0dc9b81e7212e0baffe967cdd9d850d4352c89f1" translate="yes" xml:space="preserve">
          <source>Green Apple</source>
          <target state="translated">Manzana verde</target>
        </trans-unit>
        <trans-unit id="6c0c3305620db430350f7c25edbf10ced1e1274b" translate="yes" xml:space="preserve">
          <source>Green Book</source>
          <target state="translated">El Libro Verde</target>
        </trans-unit>
        <trans-unit id="6c50119d5c6855e408d9ec2a52bd79546e4c4107" translate="yes" xml:space="preserve">
          <source>Green Heart</source>
          <target state="translated">Corazón Verde</target>
        </trans-unit>
        <trans-unit id="91feac528389c2b95c6eef06c801f2624c19116d" translate="yes" xml:space="preserve">
          <source>Grimacing Face</source>
          <target state="translated">Cara de mueca</target>
        </trans-unit>
        <trans-unit id="3f363dede90226435cbc0dd5d44650f61adbd5cf" translate="yes" xml:space="preserve">
          <source>Grinning Cat Face With Smiling Eyes</source>
          <target state="translated">Cara de gato sonriente con ojos sonrientes</target>
        </trans-unit>
        <trans-unit id="c001d488999b87437147a6834a4b4dff1427af59" translate="yes" xml:space="preserve">
          <source>Grinning Face</source>
          <target state="translated">Cara sonriente</target>
        </trans-unit>
        <trans-unit id="5f9c06d040ed5ced638db3bf446959a48d2a6ba5" translate="yes" xml:space="preserve">
          <source>Grinning Face With Smiling Eyes</source>
          <target state="translated">Cara sonriente con ojos sonrientes</target>
        </trans-unit>
        <trans-unit id="7005b30f708630da7d596e53a5163b84350bd829" translate="yes" xml:space="preserve">
          <source>Grisu.print_shortest()</source>
          <target state="translated">Grisu.print_shortest()</target>
        </trans-unit>
        <trans-unit id="d511874702f7c7ad5ec3b4943a9badded191c85c" translate="yes" xml:space="preserve">
          <source>Growing Heart</source>
          <target state="translated">Corazón en crecimiento</target>
        </trans-unit>
        <trans-unit id="0fa148c7a4ec811ec41fa2cc8e9473dfc48a9226" translate="yes" xml:space="preserve">
          <source>Guardsman</source>
          <target state="translated">Guardsman</target>
        </trans-unit>
        <trans-unit id="94af6c4088103e96d349b87fe76774686b86faa5" translate="yes" xml:space="preserve">
          <source>Guitar</source>
          <target state="translated">Guitar</target>
        </trans-unit>
        <trans-unit id="f089f13a04cfc6546c94da2f6580d6c4eed769fc" translate="yes" xml:space="preserve">
          <source>HE</source>
          <target state="translated">HE</target>
        </trans-unit>
        <trans-unit id="9018ffc109466fc760171905d2397039bc111ebf" translate="yes" xml:space="preserve">
          <source>Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race condition. An example of what would happen if we didn't avoid the race:</source>
          <target state="translated">Si hubiéramos tratado de hacer la adición sin la etiqueta atómica,podríamos haber obtenido la respuesta equivocada debido a una condición de raza.Un ejemplo de lo que pasaría si no evitáramos la carrera:</target>
        </trans-unit>
        <trans-unit id="de960a40df3284e207ad1c9fee37b3f036f0b2a2" translate="yes" xml:space="preserve">
          <source>Hair Space</source>
          <target state="translated">Hair Space</target>
        </trans-unit>
        <trans-unit id="2c7a078f496901b9f8903cc399fa79c1c3ab6b95" translate="yes" xml:space="preserve">
          <source>Haircut</source>
          <target state="translated">Haircut</target>
        </trans-unit>
        <trans-unit id="4a11632b50147a0502c9dc634f5c6e0c06ffab6b" translate="yes" xml:space="preserve">
          <source>Half-precision floating-point numbers are also supported (&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;), but they are implemented in software and use &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; for calculations.</source>
          <target state="translated">Tambi&amp;eacute;n se admiten n&amp;uacute;meros de coma flotante de media precisi&amp;oacute;n ( &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt; ), pero est&amp;aacute;n implementados en software y utilizan &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; para los c&amp;aacute;lculos.</target>
        </trans-unit>
        <trans-unit id="94c92dceffd55b3ed538a942cce80806cce37fe1" translate="yes" xml:space="preserve">
          <source>Hamburger</source>
          <target state="translated">Hamburger</target>
        </trans-unit>
        <trans-unit id="ab7b8ea47eadf93146c012e72a5ea673322853aa" translate="yes" xml:space="preserve">
          <source>Hammer</source>
          <target state="translated">Hammer</target>
        </trans-unit>
        <trans-unit id="3bff32cf99bd14d58869cbb0d7d31e1bec45d891" translate="yes" xml:space="preserve">
          <source>Hamster Face</source>
          <target state="translated">Cara de hámster</target>
        </trans-unit>
        <trans-unit id="3d3f4dc94e3e321e028a018fa9cae5ff030ce957" translate="yes" xml:space="preserve">
          <source>Handbag</source>
          <target state="translated">Handbag</target>
        </trans-unit>
        <trans-unit id="fffe7d81b4e3e0d9952aa6caa3fd530df68b775c" translate="yes" xml:space="preserve">
          <source>Handle a log event</source>
          <target state="translated">Manejar un evento de registro</target>
        </trans-unit>
        <trans-unit id="e30eba0eb24c7a8fac8f9c3ba83240b293b51b33" translate="yes" xml:space="preserve">
          <source>Handle excess argument diversity in the caller</source>
          <target state="translated">Manejar el exceso de diversidad de argumentos en el llamador</target>
        </trans-unit>
        <trans-unit id="10a3cb0df00f1fa97a3cb63486616c5cf79959d9" translate="yes" xml:space="preserve">
          <source>Handling Operating System Variation</source>
          <target state="translated">Manejo de la variación del sistema operativo</target>
        </trans-unit>
        <trans-unit id="67509204a791b926a290df40bb29deed545a4fe9" translate="yes" xml:space="preserve">
          <source>Happy Person Raising One Hand</source>
          <target state="translated">Persona feliz levantando una mano</target>
        </trans-unit>
        <trans-unit id="31f205e87d98bf7472c8354a4586dfc7173d7021" translate="yes" xml:space="preserve">
          <source>Hatching Chick</source>
          <target state="translated">Polluelo de incubación</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="6ef295c2897db61289ad0eb0b8171326ec851011" translate="yes" xml:space="preserve">
          <source>Headphone</source>
          <target state="translated">Headphone</target>
        </trans-unit>
        <trans-unit id="83fbe44a9f704c02d2d76ee1fa5c115010ff9d8c" translate="yes" xml:space="preserve">
          <source>Hear-No-Evil Monkey</source>
          <target state="translated">Hear-No-Evil Monkey</target>
        </trans-unit>
        <trans-unit id="2edafb06cf3a183a503a1615f5b8c4da86990553" translate="yes" xml:space="preserve">
          <source>Heart Decoration</source>
          <target state="translated">Decoración del corazón</target>
        </trans-unit>
        <trans-unit id="53648eedc9bfa102fd53ca957c856f7e0d9a2a2f" translate="yes" xml:space="preserve">
          <source>Heart With Arrow</source>
          <target state="translated">Corazón con flecha</target>
        </trans-unit>
        <trans-unit id="5461f091ddf4a776ade53602bfcdef544a0feb57" translate="yes" xml:space="preserve">
          <source>Heart With Ribbon</source>
          <target state="translated">Corazón con cinta</target>
        </trans-unit>
        <trans-unit id="fde3248d8454a04a4138dae1e5a31ab1432bdb78" translate="yes" xml:space="preserve">
          <source>Heavy Black Heart</source>
          <target state="translated">Corazón Negro Pesado</target>
        </trans-unit>
        <trans-unit id="662b2b0a5e62dab41b3f6deba4867bbd60a35b8f" translate="yes" xml:space="preserve">
          <source>Heavy Check Mark</source>
          <target state="translated">Marca de verificación pesada</target>
        </trans-unit>
        <trans-unit id="9ae6c1b9f7bdda7ce9eec6a4c6ee5efca7c871a5" translate="yes" xml:space="preserve">
          <source>Heavy Division Sign</source>
          <target state="translated">Signo de División Pesada</target>
        </trans-unit>
        <trans-unit id="7706e6c735cc207b9267e0979a8dbeb69e5229a0" translate="yes" xml:space="preserve">
          <source>Heavy Dollar Sign</source>
          <target state="translated">Signo de Dólar Pesado</target>
        </trans-unit>
        <trans-unit id="93e9c9786874a2de0cddf3ee5e7766e4ea031dca" translate="yes" xml:space="preserve">
          <source>Heavy Exclamation Mark Symbol</source>
          <target state="translated">Símbolo de signo de exclamación pesada</target>
        </trans-unit>
        <trans-unit id="78800e7776274c794a8d095ff4c2c73221dbbbae" translate="yes" xml:space="preserve">
          <source>Heavy Large Circle</source>
          <target state="translated">Círculo grande y pesado</target>
        </trans-unit>
        <trans-unit id="980c6d0d2733f3166210e842cefb858e063c0d91" translate="yes" xml:space="preserve">
          <source>Heavy Minus Sign</source>
          <target state="translated">Signo de menos pesado</target>
        </trans-unit>
        <trans-unit id="778bd00186fa7e144e55b7635e11bf1326888ddd" translate="yes" xml:space="preserve">
          <source>Heavy Multiplication X</source>
          <target state="translated">Multiplicación pesada X</target>
        </trans-unit>
        <trans-unit id="f686b15ee80bdb7a610f665e9bb567ee7025d65c" translate="yes" xml:space="preserve">
          <source>Heavy Plus Sign</source>
          <target state="translated">Signo más pesado</target>
        </trans-unit>
        <trans-unit id="75c1e5a632008728c5938fd7cc30c147bf32b6b5" translate="yes" xml:space="preserve">
          <source>Heavy Teardrop-Spoked Asterisk</source>
          <target state="translated">Asterisco con lagrimas pesadas</target>
        </trans-unit>
        <trans-unit id="fda201fd52a223f4da8ab6d74bf72a21faeaf60b" translate="yes" xml:space="preserve">
          <source>Helicopter</source>
          <target state="translated">Helicopter</target>
        </trans-unit>
        <trans-unit id="ae573d0f71ca2ef898057a3a11aeabc86f4048c4" translate="yes" xml:space="preserve">
          <source>Help mode</source>
          <target state="translated">Modo de ayuda</target>
        </trans-unit>
        <trans-unit id="5941c1bf985d2850f77798f46b591f5bf1a7198a" translate="yes" xml:space="preserve">
          <source>Help mode can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">Se puede salir del modo de ayuda pulsando la tecla de retroceso al principio de la línea.</target>
        </trans-unit>
        <trans-unit id="8882ebfc5a29fddc8a80eb230261926f56fd8d5e" translate="yes" xml:space="preserve">
          <source>Herb</source>
          <target state="translated">Herb</target>
        </trans-unit>
        <trans-unit id="bb934b9ceeaa4e54809a9838dfa1ed2cabf6522e" translate="yes" xml:space="preserve">
          <source>Here &quot;inline&quot; refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.</source>
          <target state="translated">Aquí &quot;en línea&quot; se refiere a los elementos que pueden encontrarse dentro de bloques de texto,es decir,párrafos.Entre ellos figuran los siguientes elementos.</target>
        </trans-unit>
        <trans-unit id="0aaf5b43ce3bf447f656063f8ac61c46b777eefc" translate="yes" xml:space="preserve">
          <source>Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; takes the data to write as its second argument, while &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; takes the type of the data to be read as the second argument.</source>
          <target state="translated">Aqu&amp;iacute; se presion&amp;oacute; Enter nuevamente para que Julia pudiera leer la nueva l&amp;iacute;nea. Ahora, como puede ver en este ejemplo, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; toma los datos a escribir como segundo argumento, mientras que &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; toma el tipo de datos a leer como segundo argumento.</target>
        </trans-unit>
        <trans-unit id="77b8367f53858f5da92aefb29bb20f4abb25843a" translate="yes" xml:space="preserve">
          <source>Here are some examples to demonstrate which type of arrays are strided and which are not:</source>
          <target state="translated">Aquí hay algunos ejemplos para demostrar qué tipo de matrices se mueven y cuáles no:</target>
        </trans-unit>
        <trans-unit id="3b3a2127d824649ba6d32ad8be94f9ae3c5dba0e" translate="yes" xml:space="preserve">
          <source>Here are some examples with bitwise operators:</source>
          <target state="translated">Aquí hay algunos ejemplos con operadores poco inteligentes:</target>
        </trans-unit>
        <trans-unit id="c2d9b5adfe6cd0f32ce45f61d872c609d6e0a4ff" translate="yes" xml:space="preserve">
          <source>Here are some simple examples using arithmetic operators:</source>
          <target state="translated">Aquí hay algunos ejemplos simples usando operadores aritméticos:</target>
        </trans-unit>
        <trans-unit id="f5ba1cb3713902ae4550268fb70da7530b34b57c" translate="yes" xml:space="preserve">
          <source>Here are some simple examples:</source>
          <target state="translated">Aquí hay algunos ejemplos simples:</target>
        </trans-unit>
        <trans-unit id="d3d30b41b93723417b3a0eda16323a2baedc0a7c" translate="yes" xml:space="preserve">
          <source>Here are some tips for working with Julia efficiently.</source>
          <target state="translated">Aquí hay algunos consejos para trabajar con Julia de manera eficiente.</target>
        </trans-unit>
        <trans-unit id="4b9dc1697c31ccdd9965aa0170dd226712f2cb14" translate="yes" xml:space="preserve">
          <source>Here each iteration applies &lt;code&gt;f&lt;/code&gt; to a randomly-chosen sample from a vector &lt;code&gt;a&lt;/code&gt; shared by all processes.</source>
          <target state="translated">Aqu&amp;iacute;, cada iteraci&amp;oacute;n aplica &lt;code&gt;f&lt;/code&gt; a una muestra elegida al azar de un vector &lt;code&gt;a&lt;/code&gt; compartido por todos los procesos.</target>
        </trans-unit>
        <trans-unit id="a76feb46cab9b567bf7483afc7491ed744f3c054" translate="yes" xml:space="preserve">
          <source>Here is a corresponding roots structure, represented as a dictionary:</source>
          <target state="translated">Aquí hay una estructura de raíces correspondiente,representada como un diccionario:</target>
        </trans-unit>
        <trans-unit id="86a5b746f6fe4ea8f489a225c69f586c3ee94b4f" translate="yes" xml:space="preserve">
          <source>Here is a more complex example, still using Markdown:</source>
          <target state="translated">Aquí hay un ejemplo más complejo,todavía usando Markdown:</target>
        </trans-unit>
        <trans-unit id="32a32a63972b7e15e6bc1e1399ca59536eaf91cf" translate="yes" xml:space="preserve">
          <source>Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest &lt;code&gt;P(2)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; type? In some cases (specifically, when &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt;) the answer is clear:</source>
          <target state="translated">Aqu&amp;iacute; hay un caso relacionado en el que el comportamiento esperado no es necesariamente obvio: &amp;iquest;Qu&amp;eacute; sucede cuando redondeamos al &lt;code&gt;P(2)&lt;/code&gt; m&amp;aacute;s cercano , donde &lt;code&gt;P&lt;/code&gt; es un tipo de &lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt; ? En algunos casos (espec&amp;iacute;ficamente, cuando &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt; ) la respuesta es clara:</target>
        </trans-unit>
        <trans-unit id="cbc1a6d954403affcd824e28b3f149fcba6203f0" translate="yes" xml:space="preserve">
          <source>Here is a representation of a possible paths map for our example &lt;code&gt;App&lt;/code&gt; project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:</source>
          <target state="translated">Aqu&amp;iacute; hay una representaci&amp;oacute;n de un mapa de rutas posibles para nuestro entorno de proyecto de &lt;code&gt;App&lt;/code&gt; ejemplo , como se proporciona en el manifiesto dado anteriormente para el gr&amp;aacute;fico de dependencia, despu&amp;eacute;s de buscar en el sistema de archivos local:</target>
        </trans-unit>
        <trans-unit id="62b973b3d8599e23c2d9da9c0813b08faed1d7f5" translate="yes" xml:space="preserve">
          <source>Here is a second example wrapping the corresponding destructor:</source>
          <target state="translated">Aquí hay un segundo ejemplo que envuelve el destructor correspondiente:</target>
        </trans-unit>
        <trans-unit id="383164a53efb4be492fb1a747035c59b715f139a" translate="yes" xml:space="preserve">
          <source>Here is a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo simple de un contenedor C que devuelve un tipo &lt;code&gt;Ptr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fd4023e74c6b03e666e958ff6141359ac199b811" translate="yes" xml:space="preserve">
          <source>Here is a simplified definition of Julia's &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt;&lt;code&gt;@assert&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">Aqu&amp;iacute; hay una definici&amp;oacute;n simplificada de la macro &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt; &lt;code&gt;@assert&lt;/code&gt; &lt;/a&gt; de Julia :</target>
        </trans-unit>
        <trans-unit id="ac903f23df192b2cec33704052829cedd04df512" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname. In this example, the networking library code is assumed to be in a shared library named &quot;libc&quot;. In practice, this function is usually part of the C standard library, and so the &quot;libc&quot; portion should be omitted, but we wish to show here the usage of this syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40b5507bd00f53ac4347d820f9aea2085f1e997" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname:</source>
          <target state="translated">Aquí hay un ejemplo un poco más complejo que descubre el nombre de la máquina local:</target>
        </trans-unit>
        <trans-unit id="c20460c3bed82c94ed3787e3dfe27ae7c3b31699" translate="yes" xml:space="preserve">
          <source>Here is a third example passing Julia arrays:</source>
          <target state="translated">Aquí hay un tercer ejemplo que pasa por las matrices de Julia:</target>
        </trans-unit>
        <trans-unit id="d610a40401dd7269ef98b9bc1fb559f31c643ca5" translate="yes" xml:space="preserve">
          <source>Here is an even more complex multi-stage producer-consumer example:</source>
          <target state="translated">He aquí un ejemplo aún más complejo de productor-consumidor en múltiples etapas:</target>
        </trans-unit>
        <trans-unit id="166759fbb289c37473d7a6b4b102bc98c71ab976" translate="yes" xml:space="preserve">
          <source>Here is an example of a &quot;compound function&quot; that should really be written as multiple definitions:</source>
          <target state="translated">He aquí un ejemplo de una &quot;función compuesta&quot; que realmente debería escribirse como definiciones múltiples:</target>
        </trans-unit>
        <trans-unit id="dff5c26dbc80f0776c11c28a5633445af4d9d175" translate="yes" xml:space="preserve">
          <source>Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:</source>
          <target state="translated">Aquí hay un ejemplo con los tres tipos de marcas.Este programa primero calcula la diferencia finita de una matriz unidimensional,y luego evalúa la norma L2 del resultado:</target>
        </trans-unit>
        <trans-unit id="f97cb2973176feb8f941a5117a88dd7fad7d8ec1" translate="yes" xml:space="preserve">
          <source>Here is an example with both &lt;code&gt;@inbounds&lt;/code&gt; and &lt;code&gt;@simd&lt;/code&gt; markup (we here use &lt;code&gt;@noinline&lt;/code&gt; to prevent the optimizer from trying to be too clever and defeat our benchmark):</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo con el marcado &lt;code&gt;@inbounds&lt;/code&gt; y &lt;code&gt;@simd&lt;/code&gt; (aqu&amp;iacute; usamos &lt;code&gt;@noinline&lt;/code&gt; para evitar que el optimizador intente ser demasiado inteligente y derrote nuestro punto de referencia):</target>
        </trans-unit>
        <trans-unit id="87f18e8d7ee1b76e68d3166f552e8d656c81958f" translate="yes" xml:space="preserve">
          <source>Here is an extraordinarily simple macro:</source>
          <target state="translated">Aquí hay una macro extraordinariamente simple:</target>
        </trans-unit>
        <trans-unit id="7afc02096736fcb4c01a0c6afaea2e90973eb75e" translate="yes" xml:space="preserve">
          <source>Here is the correct code template for returning the element-type &lt;code&gt;T&lt;/code&gt; of any arbitrary subtype of &lt;code&gt;AbstractArray&lt;/code&gt;:</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; la plantilla de c&amp;oacute;digo correcta para devolver el tipo de elemento &lt;code&gt;T&lt;/code&gt; de cualquier subtipo arbitrario de &lt;code&gt;AbstractArray&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5f4fdb43158ce32a870e863c53f180f3aa098a57" translate="yes" xml:space="preserve">
          <source>Here is the corresponding graph structure, represented as a dictionary:</source>
          <target state="translated">Aquí está la correspondiente estructura gráfica,representada como un diccionario:</target>
        </trans-unit>
        <trans-unit id="f9b6eba975c84af5ac0af3798604d9ad36108359" translate="yes" xml:space="preserve">
          <source>Here module &lt;code&gt;Parent&lt;/code&gt; contains a submodule &lt;code&gt;Utils&lt;/code&gt;, and code in &lt;code&gt;Parent&lt;/code&gt; wants the contents of &lt;code&gt;Utils&lt;/code&gt; to be visible. This is done by starting the &lt;code&gt;using&lt;/code&gt; path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example &lt;code&gt;using ..Utils&lt;/code&gt; would look for &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt;'s enclosing module rather than in &lt;code&gt;Parent&lt;/code&gt; itself.</source>
          <target state="translated">Aqu&amp;iacute; el m&amp;oacute;dulo &lt;code&gt;Parent&lt;/code&gt; contiene un subm&amp;oacute;dulo &lt;code&gt;Utils&lt;/code&gt; , y el c&amp;oacute;digo en &lt;code&gt;Parent&lt;/code&gt; quiere que el contenido de &lt;code&gt;Utils&lt;/code&gt; sea ​​visible. Esto se hace comenzando la ruta de &lt;code&gt;using&lt;/code&gt; con un punto. Al agregar m&amp;aacute;s per&amp;iacute;odos iniciales, se mueven niveles adicionales en la jerarqu&amp;iacute;a del m&amp;oacute;dulo. Por ejemplo &lt;code&gt;using ..Utils&lt;/code&gt; buscar&amp;iacute;a &lt;code&gt;Utils&lt;/code&gt; en &lt;code&gt;Parent&lt;/code&gt; 's m&amp;oacute;dulo de encerrar en lugar de en &lt;code&gt;Parent&lt;/code&gt; s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="cf5b1250aa2128de01974785ca5a0cd9b855ebd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;1:5&lt;/code&gt; is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The &lt;code&gt;for&lt;/code&gt; loop iterates through these values, assigning each one in turn to the variable &lt;code&gt;i&lt;/code&gt;. One rather important distinction between the previous &lt;code&gt;while&lt;/code&gt; loop form and the &lt;code&gt;for&lt;/code&gt; loop form is the scope during which the variable is visible. If the variable &lt;code&gt;i&lt;/code&gt; has not been introduced in another scope, in the &lt;code&gt;for&lt;/code&gt; loop form, it is visible only inside of the &lt;code&gt;for&lt;/code&gt; loop, and not outside/afterwards. You'll either need a new interactive session instance or a different variable name to test this:</source>
          <target state="translated">Aqu&amp;iacute; el &lt;code&gt;1:5&lt;/code&gt; es un objeto de rango, que representa la secuencia de n&amp;uacute;meros 1, 2, 3, 4, 5. El bucle &lt;code&gt;for&lt;/code&gt; itera a trav&amp;eacute;s de estos valores, asignando cada uno a la variable &lt;code&gt;i&lt;/code&gt; . Una distinci&amp;oacute;n bastante importante entre la forma de bucle &lt;code&gt;while&lt;/code&gt; anterior y la forma de bucle &lt;code&gt;for&lt;/code&gt; es el alcance durante el cual la variable es visible. Si la variable &lt;code&gt;i&lt;/code&gt; no se ha introducido en otro &amp;aacute;mbito, en la forma de bucle &lt;code&gt;for&lt;/code&gt; , solo es visible dentro del bucle &lt;code&gt;for&lt;/code&gt; , y no fuera / despu&amp;eacute;s. Necesitar&amp;aacute; una nueva instancia de sesi&amp;oacute;n interactiva o un nombre de variable diferente para probar esto:</target>
        </trans-unit>
        <trans-unit id="052893fe9e50a40443ea78d54cd3b33cb280eb4e" translate="yes" xml:space="preserve">
          <source>Here the call &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; could be handled by either the &lt;code&gt;g(Float64, Any)&lt;/code&gt; or the &lt;code&gt;g(Any, Float64)&lt;/code&gt; method, and neither is more specific than the other. In such cases, Julia raises a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:</source>
          <target state="translated">Aqu&amp;iacute;, la llamada &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; podr&amp;iacute;a manejarse con el &lt;code&gt;g(Float64, Any)&lt;/code&gt; o &lt;code&gt;g(Any, Float64)&lt;/code&gt; , y ninguno es m&amp;aacute;s espec&amp;iacute;fico que el otro. En tales casos, Julia genera un &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; en&lt;/a&gt; lugar de elegir arbitrariamente un m&amp;eacute;todo. Puede evitar las ambig&amp;uuml;edades del m&amp;eacute;todo especificando un m&amp;eacute;todo apropiado para el caso de intersecci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="373c14d6a8445cd3c00b580baccefb5fd3f3d12c" translate="yes" xml:space="preserve">
          <source>Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.</source>
          <target state="translated">Aquí se imprime el primer número después de un retraso de dos segundos,luego los siguientes números se imprimen rápidamente.</target>
        </trans-unit>
        <trans-unit id="f3418902a4f242b518d4d5f42412b650db9149b7" translate="yes" xml:space="preserve">
          <source>Here the user expression &lt;code&gt;ex&lt;/code&gt; is a call to &lt;code&gt;time&lt;/code&gt;, but not the same &lt;code&gt;time&lt;/code&gt; function that the macro uses. It clearly refers to &lt;code&gt;MyModule.time&lt;/code&gt;. Therefore we must arrange for the code in &lt;code&gt;ex&lt;/code&gt; to be resolved in the macro call environment. This is done by &quot;escaping&quot; the expression with &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt;&lt;code&gt;esc&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Aqu&amp;iacute;, la expresi&amp;oacute;n de usuario &lt;code&gt;ex&lt;/code&gt; es una llamada al &lt;code&gt;time&lt;/code&gt; , pero no es la misma funci&amp;oacute;n de &lt;code&gt;time&lt;/code&gt; que usa la macro. Claramente se refiere a &lt;code&gt;MyModule.time&lt;/code&gt; . Por lo tanto, debemos hacer arreglos para que el c&amp;oacute;digo en &lt;code&gt;ex&lt;/code&gt; se resuelva en el entorno de llamada de macro. Esto se hace &quot;escapando&quot; de la expresi&amp;oacute;n con &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt; &lt;code&gt;esc&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="319de09db8b0ceed706c2722ad8c4f12c486b513" translate="yes" xml:space="preserve">
          <source>Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called &lt;em&gt;outer&lt;/em&gt; constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.</source>
          <target state="translated">Aqu&amp;iacute;, el m&amp;eacute;todo constructor de argumento cero llama al m&amp;eacute;todo constructor de argumento &amp;uacute;nico, que a su vez llama al m&amp;eacute;todo constructor de dos argumentos proporcionado autom&amp;aacute;ticamente. Por razones que se aclarar&amp;aacute;n en breve, los m&amp;eacute;todos constructores adicionales declarados como m&amp;eacute;todos normales como este se denominan m&amp;eacute;todos constructores &lt;em&gt;externos&lt;/em&gt; . Los m&amp;eacute;todos de constructor externos solo pueden crear una nueva instancia llamando a otro m&amp;eacute;todo de constructor, como los predeterminados proporcionados autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="754489125a9dd659e2690c5c486d5c6350ca9a2b" translate="yes" xml:space="preserve">
          <source>Here we create and store two closures that return variable &lt;code&gt;i&lt;/code&gt;. However, it is always the same variable &lt;code&gt;i&lt;/code&gt;, so the two closures behave identically. We can use &lt;code&gt;let&lt;/code&gt; to create a new binding for &lt;code&gt;i&lt;/code&gt;:</source>
          <target state="translated">Aqu&amp;iacute; creamos y almacenamos dos cierres que devuelven la variable &lt;code&gt;i&lt;/code&gt; . Sin embargo, siempre es la misma variable &lt;code&gt;i&lt;/code&gt; , por lo que los dos cierres se comportan de manera id&amp;eacute;ntica. Podemos usar &lt;code&gt;let&lt;/code&gt; para crear un nuevo enlace para &lt;code&gt;i&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f311d723a18a177fef2791eca3f472638877d565" translate="yes" xml:space="preserve">
          <source>Here we created a function &lt;code&gt;change_array!&lt;/code&gt;, that assigns &lt;code&gt;5&lt;/code&gt; to the first element of the passed array (bound to &lt;code&gt;x&lt;/code&gt; at the call site, and bound to &lt;code&gt;A&lt;/code&gt; within the function). Notice that, after the function call, &lt;code&gt;x&lt;/code&gt; is still bound to the same array, but the content of that array changed: the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; were distinct bindings referring to the same mutable &lt;code&gt;Array&lt;/code&gt; object.</source>
          <target state="translated">Aqu&amp;iacute; creamos una funci&amp;oacute;n &lt;code&gt;change_array!&lt;/code&gt; , que asigna &lt;code&gt;5&lt;/code&gt; al primer elemento de la matriz pasada (vinculado &lt;code&gt;x&lt;/code&gt; en el sitio de llamada y vinculado a &lt;code&gt;A&lt;/code&gt; dentro de la funci&amp;oacute;n). Observe que, despu&amp;eacute;s de la llamada a la funci&amp;oacute;n, &lt;code&gt;x&lt;/code&gt; todav&amp;iacute;a est&amp;aacute; vinculado a la misma matriz, pero el contenido de esa matriz cambi&amp;oacute;: las variables &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; eran vinculaciones distintas que se refer&amp;iacute;an al mismo objeto de &lt;code&gt;Array&lt;/code&gt; mutable .</target>
        </trans-unit>
        <trans-unit id="36a8f92884e992830034696fb443df46cbb7f016" translate="yes" xml:space="preserve">
          <source>Here we define a sampler for a collection. If no pre-computed data is required, it can be implemented with a &lt;code&gt;SamplerTrivial&lt;/code&gt; sampler, which is in fact the &lt;em&gt;default fallback for values&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97836fe829ccf3f620529d58616382e12cd6d98d" translate="yes" xml:space="preserve">
          <source>Here we have created a type &lt;code&gt;BitVector&lt;/code&gt; which has no parameters, but where the element-type is still fully specified, with &lt;code&gt;T&lt;/code&gt; equal to &lt;code&gt;Bool&lt;/code&gt;!</source>
          <target state="translated">Aqu&amp;iacute; hemos creado un tipo &lt;code&gt;BitVector&lt;/code&gt; que no tiene par&amp;aacute;metros, pero donde el tipo de elemento todav&amp;iacute;a est&amp;aacute; completamente especificado, con &lt;code&gt;T&lt;/code&gt; igual a &lt;code&gt;Bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5afb8d5acf60ecdcd4dfe5d3e5a47e7bac7660ac" translate="yes" xml:space="preserve">
          <source>Here we use &lt;a href=&quot;../../base/base/index#Base.include_string&quot;&gt;&lt;code&gt;include_string&lt;/code&gt;&lt;/a&gt;, to evaluate &lt;code&gt;code&lt;/code&gt; as though it were the contents of a file. We could also save &lt;code&gt;code&lt;/code&gt; to a file and then call &lt;code&gt;include&lt;/code&gt; on that file&amp;mdash;the result would be the same. As you can see, this behaves quite different from evaluating the same code in the REPL. Let's break down what's happening here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9af6aad35623f9ee689638f54770ed7633fd26" translate="yes" xml:space="preserve">
          <source>Here's a brief example:</source>
          <target state="translated">Aquí hay un breve ejemplo:</target>
        </trans-unit>
        <trans-unit id="e0b11719421310c6cc4a896b044019316b57f70b" translate="yes" xml:space="preserve">
          <source>Here's a simple example of running an external program:</source>
          <target state="translated">Aquí hay un ejemplo simple de la ejecución de un programa externo:</target>
        </trans-unit>
        <trans-unit id="1cdb1c514a8c4179306e34bfddd814358210098d" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a6acaa904201f8599df8ef13450aeef27c5681" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="translated">Aqu&amp;iacute;, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; primero abre el archivo para escribir y luego pasa el flujo de salida resultante a la funci&amp;oacute;n an&amp;oacute;nima que defini&amp;oacute; en el bloque &lt;code&gt;do ... end&lt;/code&gt; . Despu&amp;eacute;s de que su funci&amp;oacute;n salga, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; se asegurar&amp;aacute; de que la secuencia se cierre correctamente, independientemente de si su funci&amp;oacute;n sali&amp;oacute; normalmente o lanz&amp;oacute; una excepci&amp;oacute;n. (La construcci&amp;oacute;n &lt;code&gt;try/finally&lt;/code&gt; se describir&amp;aacute; en &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b6b3a9234aa3e202da30078d8340c4a596ef7790" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; and the first argument &amp;mdash; the element type &amp;mdash; is optional, defaulting to &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a90ca3f6b58f2547fca94266c1813296e387071" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;(2, 3)&lt;/code&gt; es una &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5216371c7d0926d72d95ff987a3d80e32321d1dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;count&lt;/code&gt; finds the number of commits along the walk with a certain &lt;code&gt;GitHash&lt;/code&gt;. Since the &lt;code&gt;GitHash&lt;/code&gt; is unique to a commit, &lt;code&gt;cnt&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;count&lt;/code&gt; encuentra el n&amp;uacute;mero de confirmaciones a lo largo de la caminata con un determinado &lt;code&gt;GitHash&lt;/code&gt; . Dado que &lt;code&gt;GitHash&lt;/code&gt; es exclusivo de una confirmaci&amp;oacute;n, &lt;code&gt;cnt&lt;/code&gt; ser&amp;aacute; &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2161ca87d055525464e4a5b1fd21109ca2813404" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;map&lt;/code&gt; visits each commit using the &lt;code&gt;GitRevWalker&lt;/code&gt; and finds its &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, el &lt;code&gt;map&lt;/code&gt; a visita cada confirmaci&amp;oacute;n usando &lt;code&gt;GitRevWalker&lt;/code&gt; y encuentra su &lt;code&gt;GitHash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="290a784ce45faad752be9227fb340601f3f76ead" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;sp.data&lt;/code&gt; refers to the second parameter in the call to the &lt;code&gt;SamplerSimple&lt;/code&gt; constructor (in this case equal to &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt;), while the &lt;code&gt;Die&lt;/code&gt; object can be accessed via &lt;code&gt;sp[]&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;sp.data&lt;/code&gt; se refiere al segundo par&amp;aacute;metro en la llamada al constructor &lt;code&gt;SamplerSimple&lt;/code&gt; (en este caso igual a &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt; ), mientras que se puede acceder al objeto &lt;code&gt;Die&lt;/code&gt; a trav&amp;eacute;s de &lt;code&gt;sp[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6537ead3e178965ea266058307a50f1c2fbf640" translate="yes" xml:space="preserve">
          <source>Here, Julia was able to detect that &lt;code&gt;B&lt;/code&gt; is in fact symmetric, and used a more appropriate factorization. Often it's possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can &quot;tag&quot; matrices as having these properties. For instance:</source>
          <target state="translated">Aqu&amp;iacute;, Julia pudo detectar que &lt;code&gt;B&lt;/code&gt; es de hecho sim&amp;eacute;trico y utiliz&amp;oacute; una factorizaci&amp;oacute;n m&amp;aacute;s apropiada. A menudo es posible escribir c&amp;oacute;digo m&amp;aacute;s eficiente para una matriz que se sabe que tiene ciertas propiedades, por ejemplo, es sim&amp;eacute;trica o tridiagonal. Julia proporciona algunos tipos especiales para que pueda &quot;etiquetar&quot; matrices con estas propiedades. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c40867232cf6016f6f8e42d642627bb64b253d86" translate="yes" xml:space="preserve">
          <source>Here, the evaluation of an expression object causes a value to be assigned to the global variable &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, la evaluaci&amp;oacute;n de un objeto de expresi&amp;oacute;n hace que se asigne un valor a la variable global &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6153340adbaa08a931cc654aec620e3452eb7b03" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e6a3f428f565fb6b0000baaea7b4aa785dbcfc" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore can be used in the same (covariant) context of the input argument to a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. A pointer to memory allocated by Julia must be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. Therefore, the &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; declaration allows pointers managed by C or Julia to be used.</source>
          <target state="translated">Aqu&amp;iacute;, se declara que la entrada &lt;code&gt;p&lt;/code&gt; es de tipo &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; , lo que significa que la memoria a la que apunta &lt;code&gt;p&lt;/code&gt; puede ser administrada por Julia o por C. Un puntero a la memoria asignada por C debe ser del tipo &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; , pero es convertible usando &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; y por lo tanto se puede usar en el mismo contexto (covariante) del argumento de entrada a un &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; . Un puntero a la memoria asignada por Julia debe ser de tipo &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; , para garantizar que la direcci&amp;oacute;n de memoria apuntada sea v&amp;aacute;lida y que el recolector de basura de Julia gestione la porci&amp;oacute;n de memoria apuntada correctamente. Por lo tanto, la &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; La declaraci&amp;oacute;n permite usar punteros administrados por C o Julia.</target>
        </trans-unit>
        <trans-unit id="1ab09345f1dd2caf08c8b3f5ca36d5682164ea59" translate="yes" xml:space="preserve">
          <source>Here, the option &lt;code&gt;--math-mode=ieee&lt;/code&gt; disables the &lt;code&gt;@fastmath&lt;/code&gt; macro, so that we can compare results.</source>
          <target state="translated">Aqu&amp;iacute;, la opci&amp;oacute;n &lt;code&gt;--math-mode=ieee&lt;/code&gt; deshabilita la macro &lt;code&gt;@fastmath&lt;/code&gt; , para que podamos comparar los resultados.</target>
        </trans-unit>
        <trans-unit id="6cbc6c9a872faab52c966ca377e3e05b9b758b19" translate="yes" xml:space="preserve">
          <source>Here, the total produced by &lt;code&gt;sum&lt;/code&gt; is passed to the &lt;code&gt;sqrt&lt;/code&gt; function. The equivalent composition would be:</source>
          <target state="translated">Aqu&amp;iacute;, el total producido por &lt;code&gt;sum&lt;/code&gt; se pasa a la funci&amp;oacute;n &lt;code&gt;sqrt&lt;/code&gt; . La composici&amp;oacute;n equivalente ser&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="4e8ac284e43281c0f4a614327786f479a4ecc8c6" translate="yes" xml:space="preserve">
          <source>Here, though, we'll use the text-based display that comes with the standard library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab8445a2aa7f75fce1fbdd298d4317a2e164c25" translate="yes" xml:space="preserve">
          <source>Here, we happened to know that the first element of &lt;code&gt;a&lt;/code&gt; would be an &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.</source>
          <target state="translated">Aqu&amp;iacute;, sab&amp;iacute;amos que el primer elemento de &lt;code&gt;a&lt;/code&gt; ser&amp;iacute;a un &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt; . Hacer una anotaci&amp;oacute;n como esta tiene el beneficio adicional de que generar&amp;aacute; un error en tiempo de ejecuci&amp;oacute;n si el valor no es del tipo esperado, lo que podr&amp;iacute;a detectar ciertos errores antes.</target>
        </trans-unit>
        <trans-unit id="3b5f47a75f954e4b2fddf51e62aa2e1f9d263c7c" translate="yes" xml:space="preserve">
          <source>Here, we want &lt;code&gt;t0&lt;/code&gt;, &lt;code&gt;t1&lt;/code&gt;, and &lt;code&gt;val&lt;/code&gt; to be private temporary variables, and we want &lt;code&gt;time&lt;/code&gt; to refer to the &lt;code&gt;time&lt;/code&gt; function in Julia Base, not to any &lt;code&gt;time&lt;/code&gt; variable the user might have (the same applies to &lt;code&gt;println&lt;/code&gt;). Imagine the problems that could occur if the user expression &lt;code&gt;ex&lt;/code&gt; also contained assignments to a variable called &lt;code&gt;t0&lt;/code&gt;, or defined its own &lt;code&gt;time&lt;/code&gt; variable. We might get errors, or mysteriously incorrect behavior.</source>
          <target state="translated">Aqu&amp;iacute;, queremos que &lt;code&gt;t0&lt;/code&gt; , &lt;code&gt;t1&lt;/code&gt; y &lt;code&gt;val&lt;/code&gt; sean variables temporales privadas, y queremos que &lt;code&gt;time&lt;/code&gt; se refiera a la funci&amp;oacute;n de &lt;code&gt;time&lt;/code&gt; en Julia Base, no a cualquier variable de &lt;code&gt;time&lt;/code&gt; que el usuario pueda tener (lo mismo se aplica a &lt;code&gt;println&lt;/code&gt; ). Imagine los problemas que podr&amp;iacute;an ocurrir si la expresi&amp;oacute;n de usuario &lt;code&gt;ex&lt;/code&gt; tambi&amp;eacute;n contuviera asignaciones a una variable llamada &lt;code&gt;t0&lt;/code&gt; , o definiera su propia variable de &lt;code&gt;time&lt;/code&gt; . Podr&amp;iacute;amos tener errores o un comportamiento misteriosamente incorrecto.</target>
        </trans-unit>
        <trans-unit id="9694586c6d84150f32d012165fb51d66a0071dfd" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fb6a6428243b8c36b29add8e81342285442dea" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, hemos agregado una funci&amp;oacute;n de constructor personalizada para que pueda tomar argumentos de diferentes tipos &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; y promoverlos a un tipo com&amp;uacute;n (consulte &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructores&lt;/a&gt; y &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversi&amp;oacute;n y promoci&amp;oacute;n&lt;/a&gt; ). (Por supuesto, tambi&amp;eacute;n tendr&amp;iacute;amos que definir muchos otros m&amp;eacute;todos para que act&amp;uacute;e como un &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt; , por ejemplo , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;one&lt;/code&gt; , &lt;code&gt;zero&lt;/code&gt; , reglas de promoci&amp;oacute;n, etc.) De forma predeterminada, las instancias de este tipo se muestran de forma bastante simple , con informaci&amp;oacute;n sobre el nombre del tipo y los valores del campo, como por ejemplo, &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8c4e9914a1889e98efb20fcf34b5a7f7c01253" translate="yes" xml:space="preserve">
          <source>Here, you've created the same problem all over again: the compiler can't guess what &lt;code&gt;n&lt;/code&gt; is, so it doesn't know the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;Val(n)&lt;/code&gt;. Attempting to use &lt;code&gt;Val&lt;/code&gt;, but doing so incorrectly, can easily make performance &lt;em&gt;worse&lt;/em&gt; in many situations. (Only in situations where you're effectively combining &lt;code&gt;Val&lt;/code&gt; with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)</source>
          <target state="translated">Aqu&amp;iacute;, ha creado el mismo problema de nuevo: el compilador no puede adivinar qu&amp;eacute; es &lt;code&gt;n&lt;/code&gt; , por lo que no conoce el &lt;em&gt;tipo&lt;/em&gt; de &lt;code&gt;Val(n)&lt;/code&gt; . El intento de utilizar &lt;code&gt;Val&lt;/code&gt; , pero si lo hace de forma incorrecta, puede hacer f&amp;aacute;cilmente un rendimiento &lt;em&gt;peor&lt;/em&gt; en muchas situaciones. (Solo en situaciones en las que est&amp;aacute; combinando &lt;code&gt;Val&lt;/code&gt; de manera efectiva con el truco de la barrera de funci&amp;oacute;n, para hacer que la funci&amp;oacute;n del kernel sea m&amp;aacute;s eficiente, se debe usar un c&amp;oacute;digo como el anterior).</target>
        </trans-unit>
        <trans-unit id="c7628673517938376c201f828128315e60314655" translate="yes" xml:space="preserve">
          <source>Hermitian Conjugate Matrix</source>
          <target state="translated">Matriz Conjugada Hermitiana</target>
        </trans-unit>
        <trans-unit id="7426047f57253430c62cd4ed4e8350b30626acf7" translate="yes" xml:space="preserve">
          <source>Hermitian matrix</source>
          <target state="translated">Matriz hermitiana</target>
        </trans-unit>
        <trans-unit id="10678e1b00011a887c8ed10343c313db680c592e" translate="yes" xml:space="preserve">
          <source>Hessenberg decomposition</source>
          <target state="translated">La descomposición de Hessenberg</target>
        </trans-unit>
        <trans-unit id="18dcd84b08d39e78997dcf4fc69cbfdf65766429" translate="yes" xml:space="preserve">
          <source>Hex bytes (&lt;code&gt;\x&lt;/code&gt; with 1-2 trailing hex digits)</source>
          <target state="translated">Bytes hexadecimales ( &lt;code&gt;\x&lt;/code&gt; con 1-2 d&amp;iacute;gitos hexadecimales finales)</target>
        </trans-unit>
        <trans-unit id="5829ae1ed6f556d7c22293c127a375905a4cde38" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point literals are also valid, but only as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, with &lt;code&gt;p&lt;/code&gt; preceding the base-2 exponent:</source>
          <target state="translated">Los literales hexadecimales de punto flotante tambi&amp;eacute;n son v&amp;aacute;lidos, pero solo como valores &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , con &lt;code&gt;p&lt;/code&gt; antes del exponente en base 2:</target>
        </trans-unit>
        <trans-unit id="566a781a74cd1186e4a86a913b9dfbcd8a9760f5" translate="yes" xml:space="preserve">
          <source>Hibiscus</source>
          <target state="translated">Hibiscus</target>
        </trans-unit>
        <trans-unit id="590d79aff0a27abac1599349b9f60e654406e4f9" translate="yes" xml:space="preserve">
          <source>High Brightness Symbol</source>
          <target state="translated">Símbolo de alto brillo</target>
        </trans-unit>
        <trans-unit id="5c42b554d600e8a00d6d46015f5546b8d19934a3" translate="yes" xml:space="preserve">
          <source>High Voltage Sign</source>
          <target state="translated">Señal de alto voltaje</target>
        </trans-unit>
        <trans-unit id="ab1b93cb46a149db7c34f14c047358adef0d1f47" translate="yes" xml:space="preserve">
          <source>High-Heeled Shoe</source>
          <target state="translated">Zapato de tacón alto</target>
        </trans-unit>
        <trans-unit id="22cda4a90e394a1d9c3ad940b9369d0797179dd6" translate="yes" xml:space="preserve">
          <source>High-Level Embedding</source>
          <target state="translated">Incrustación de alto nivel</target>
        </trans-unit>
        <trans-unit id="772ba23e35e2b9a933b76e30398f7eb414430f46" translate="yes" xml:space="preserve">
          <source>High-Level Embedding on Windows with Visual Studio</source>
          <target state="translated">Incrustación de alto nivel en Windows con Visual Studio</target>
        </trans-unit>
        <trans-unit id="9f567cb6bf549d8f1f72a7aad5d5c25bc17a082a" translate="yes" xml:space="preserve">
          <source>High-Speed Train</source>
          <target state="translated">Tren de alta velocidad</target>
        </trans-unit>
        <trans-unit id="00e1cd5d9c96d48229c7017e30357cb8a8d1334d" translate="yes" xml:space="preserve">
          <source>High-Speed Train With Bullet Nose</source>
          <target state="translated">Tren de alta velocidad con nariz de bala</target>
        </trans-unit>
        <trans-unit id="1b2be27c3b5a49f7125a227298d591cb7aea55af" translate="yes" xml:space="preserve">
          <source>High-level libraries like &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</source>
          <target state="translated">Bibliotecas de alto nivel como &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; y &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e0b3549b5782921269587cd589e55b82058b718" translate="yes" xml:space="preserve">
          <source>High-level vendor-specific abstractions like &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</source>
          <target state="translated">Abstracciones espec&amp;iacute;ficas de proveedores de alto nivel como &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; y &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cef2d62c8136407d7a5910b738c2a4954d1ff380" translate="yes" xml:space="preserve">
          <source>Hocho</source>
          <target state="translated">Hocho</target>
        </trans-unit>
        <trans-unit id="1183df425fd69adfff4afc7c4b9f794b3027f62e" translate="yes" xml:space="preserve">
          <source>Hold up: why macros?</source>
          <target state="translated">Espera:¿por qué macros?</target>
        </trans-unit>
        <trans-unit id="a19d1b5e13bc5eadd5512a5657629c48486fc2aa" translate="yes" xml:space="preserve">
          <source>Holds a reference to an object of type &lt;code&gt;T&lt;/code&gt;, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.</source>
          <target state="translated">Contiene una referencia a un objeto de tipo &lt;code&gt;T&lt;/code&gt; , lo que garantiza que solo se acceda de forma at&amp;oacute;mica, es decir, de forma segura para subprocesos.</target>
        </trans-unit>
        <trans-unit id="6d4b2c4793516d9999da8f3caabfcc7a3164599f" translate="yes" xml:space="preserve">
          <source>Home, &lt;code&gt;^A&lt;/code&gt;</source>
          <target state="translated">Inicio, &lt;code&gt;^A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85d163149ee6c8d4bb4972a8d9d62f2349badb11" translate="yes" xml:space="preserve">
          <source>Homothetic</source>
          <target state="translated">Homothetic</target>
        </trans-unit>
        <trans-unit id="642aac9525060b37b0f7470d6f6c49db706b03d9" translate="yes" xml:space="preserve">
          <source>Honey Pot</source>
          <target state="translated">Tarro de miel</target>
        </trans-unit>
        <trans-unit id="a643db335a306154edebc33a5e2763a380d1411b" translate="yes" xml:space="preserve">
          <source>Honeybee</source>
          <target state="translated">Honeybee</target>
        </trans-unit>
        <trans-unit id="79734fdcfe66d25a072a5769ba821cd7967d89f5" translate="yes" xml:space="preserve">
          <source>Hooking into the &lt;code&gt;Random&lt;/code&gt; API</source>
          <target state="translated">Conectarse a la API &lt;code&gt;Random&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a938072797969a150ccb7384d30e3585d81c5ec0" translate="yes" xml:space="preserve">
          <source>Horizontal Black Hexagon</source>
          <target state="translated">Hexágono negro horizontal</target>
        </trans-unit>
        <trans-unit id="9d0c97d942673d5e711ab71b642cc25b6f24a2b9" translate="yes" xml:space="preserve">
          <source>Horizontal Ellipsis</source>
          <target state="translated">Elipsis horizontal</target>
        </trans-unit>
        <trans-unit id="3627a44f223e474759956cf47448b20612b0d19a" translate="yes" xml:space="preserve">
          <source>Horizontal Traffic Light</source>
          <target state="translated">Semáforo horizontal</target>
        </trans-unit>
        <trans-unit id="b7e611daf03b332b5f4ec9209097868ee372b256" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</source>
          <target state="translated">Concatenación horizontal y vertical en una sola llamada.Esta función se llama sintaxis de matriz de bloque.El primer argumento especifica el número de argumentos a concatenar en cada fila de bloque.</target>
        </trans-unit>
        <trans-unit id="f26372d5f0aca43e155e7d006ab50ec72ec57fe2" translate="yes" xml:space="preserve">
          <source>Horizontal rules</source>
          <target state="translated">Reglas horizontales</target>
        </trans-unit>
        <trans-unit id="26dfe8116b93ced6cfca858f375d23f1489d3207" translate="yes" xml:space="preserve">
          <source>Horse</source>
          <target state="translated">Horse</target>
        </trans-unit>
        <trans-unit id="4a166dcec39a913a939b3a42f695d1c218fcaebb" translate="yes" xml:space="preserve">
          <source>Horse Face</source>
          <target state="translated">Cara de caballo</target>
        </trans-unit>
        <trans-unit id="8f21624d2501467ee4a054c705bd995e4b73ebab" translate="yes" xml:space="preserve">
          <source>Horse Racing</source>
          <target state="translated">Carreras de caballos</target>
        </trans-unit>
        <trans-unit id="dbb927867e102f755c1433b1f25539bafdd7268b" translate="yes" xml:space="preserve">
          <source>Hospital</source>
          <target state="translated">Hospital</target>
        </trans-unit>
        <trans-unit id="ef97c144078e1020e0c1fdf8b383ff06d12e8270" translate="yes" xml:space="preserve">
          <source>Hot Beverage</source>
          <target state="translated">Bebidas calientes</target>
        </trans-unit>
        <trans-unit id="cb506dd41a005a6fcc0d4c18104ce66e01d7afa8" translate="yes" xml:space="preserve">
          <source>Hot Springs</source>
          <target state="translated">Aguas termales</target>
        </trans-unit>
        <trans-unit id="9c4ba7d047eb56093b34e5dc3e51e5fcc74603f4" translate="yes" xml:space="preserve">
          <source>Hotel</source>
          <target state="translated">Hotel</target>
        </trans-unit>
        <trans-unit id="c29e8e28d3952318903de2fb6079804d2ed9d9e6" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) with a minimum width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc1b57017e3ac9f33e4e51068baf64a23795adf" translate="yes" xml:space="preserve">
          <source>Hourglass</source>
          <target state="translated">Hourglass</target>
        </trans-unit>
        <trans-unit id="bf7a0304247679d7272f0a79f9d388f130597fd4" translate="yes" xml:space="preserve">
          <source>Hourglass With Flowing Sand</source>
          <target state="translated">Reloj de Arena con Arena Fluyente</target>
        </trans-unit>
        <trans-unit id="dc8745ba30beefa5d028f85ba9b11599a2ac8d7e" translate="yes" xml:space="preserve">
          <source>House</source>
          <target state="translated">House</target>
        </trans-unit>
        <trans-unit id="b6ac911209d87615e6f295e017b36c332cd3b878" translate="yes" xml:space="preserve">
          <source>House Building</source>
          <target state="translated">Construcción de la casa</target>
        </trans-unit>
        <trans-unit id="b07df507eb5fd0e4b6c36328d58c64ebcc7b5d32" translate="yes" xml:space="preserve">
          <source>House With Garden</source>
          <target state="translated">Casa con jardín</target>
        </trans-unit>
        <trans-unit id="75af347bffc8062b7ea5afa0a699184af65b1a37" translate="yes" xml:space="preserve">
          <source>How can I constrain or compute type parameters?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eefa8d28bdac822ea112d7e5259409579ba61c80" translate="yes" xml:space="preserve">
          <source>How can I modify the declaration of a type in my session?</source>
          <target state="translated">¿Cómo puedo modificar la declaración de un tipo en mi sesión?</target>
        </trans-unit>
        <trans-unit id="515d85b9b31cb430ad4b0705dfed0fd34c859e1a" translate="yes" xml:space="preserve">
          <source>How did the file name get quoted? Julia knows that &lt;code&gt;file&lt;/code&gt; is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of &lt;code&gt;file&lt;/code&gt; is never interpreted by a shell, so there's no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo se cotiz&amp;oacute; el nombre del archivo? Julia sabe que el &lt;code&gt;file&lt;/code&gt; est&amp;aacute; destinado a ser interpolado como un solo argumento, por lo que cita la palabra por ti. En realidad, eso no es del todo exacto: el valor del &lt;code&gt;file&lt;/code&gt; nunca es interpretado por un shell, por lo que no hay necesidad de comillas reales; las citas se insertan solo para su presentaci&amp;oacute;n al usuario. Esto incluso funcionar&amp;aacute; si interpola un valor como parte de una palabra de shell:</target>
        </trans-unit>
        <trans-unit id="7554712c2d173a82ff8ff4725649f94b899a6cab" translate="yes" xml:space="preserve">
          <source>How do I catch CTRL-C in a script?</source>
          <target state="translated">¿Cómo atrapo CTRL-C en un guión?</target>
        </trans-unit>
        <trans-unit id="2a65d886539b09798da7278037976d95b79a6f2f" translate="yes" xml:space="preserve">
          <source>How do I check if the current file is being run as the main script?</source>
          <target state="translated">¿Cómo puedo comprobar si el archivo actual se está ejecutando como el guión principal?</target>
        </trans-unit>
        <trans-unit id="07f058f4bf96d455fe968f2d1e89bd25936e7928" translate="yes" xml:space="preserve">
          <source>How do I delete an object in memory?</source>
          <target state="translated">¿Cómo puedo borrar un objeto de la memoria?</target>
        </trans-unit>
        <trans-unit id="07788c6091915f1a67274d44211a41dbc53e6935" translate="yes" xml:space="preserve">
          <source>How do I manage precompilation caches in distributed file systems?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b215618760cff9b8483504445b91edb71bee5871" translate="yes" xml:space="preserve">
          <source>How do I pass options to &lt;code&gt;julia&lt;/code&gt; using &lt;code&gt;#!/usr/bin/env&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo le paso opciones a &lt;code&gt;julia&lt;/code&gt; usando &lt;code&gt;#!/usr/bin/env&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="eb9157ff1fb18352038c8a12eae2a15bbdb246dd" translate="yes" xml:space="preserve">
          <source>How does &quot;null&quot;, &quot;nothingness&quot; or &quot;missingness&quot; work in Julia?</source>
          <target state="translated">¿Cómo funciona &quot;nulo&quot;,&quot;nada&quot; o &quot;falta&quot; en Julia?</target>
        </trans-unit>
        <trans-unit id="b5188f1df50966f544cd1288a28b80d8b68a2b7f" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd885280d6cbd9f996932c72e9d360397c1bf016" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo se construye un objeto &lt;code&gt;Point&lt;/code&gt; ? Es posible definir constructores personalizados para tipos compuestos, que se discutir&amp;aacute;n en detalle en &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructores&lt;/a&gt; , pero en ausencia de declaraciones especiales de constructor, hay dos formas predeterminadas de crear nuevos objetos compuestos, una en la que los par&amp;aacute;metros de tipo se dan expl&amp;iacute;citamente y el otro en el que est&amp;aacute;n impl&amp;iacute;citos en los argumentos del constructor del objeto.</target>
        </trans-unit>
        <trans-unit id="06e308a7a0638232b6f09929d443c3620a3b020e" translate="yes" xml:space="preserve">
          <source>How these arguments are initialized depends on the &quot;outer&quot; function; here, &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; will sequentially set &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, calling the anonymous function on each, just as would happen in the syntax &lt;code&gt;map(func, [A, B, C])&lt;/code&gt;.</source>
          <target state="translated">La forma en que se inicializan estos argumentos depende de la funci&amp;oacute;n &quot;externa&quot;; aqu&amp;iacute;, &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; establecer&amp;aacute; secuencialmente &lt;code&gt;x&lt;/code&gt; en &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; , llamando a la funci&amp;oacute;n an&amp;oacute;nima en cada uno, tal como suceder&amp;iacute;a en el &lt;code&gt;map(func, [A, B, C])&lt;/code&gt; sintaxis (func, [A, B, C]) .</target>
        </trans-unit>
        <trans-unit id="eaf97b67896b3cc13483847a79f98eac92d8c7ad" translate="yes" xml:space="preserve">
          <source>How you use this information is up to you. Obviously, it would be far and away best to fix &lt;code&gt;pos&lt;/code&gt; to be type-stable: if you did so, all of the variables in &lt;code&gt;f&lt;/code&gt; would be concrete, and its performance would be optimal. However, there are circumstances where this kind of &lt;em&gt;ephemeral&lt;/em&gt; type instability might not matter too much: for example, if &lt;code&gt;pos&lt;/code&gt; is never used in isolation, the fact that &lt;code&gt;f&lt;/code&gt;'s output is type-stable (for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the &quot;damage&quot; from type instability. Also, note that even Julia Base has functions that are type unstable. For example, the function &lt;code&gt;findfirst&lt;/code&gt; returns the index into an array where a key is found, or &lt;code&gt;nothing&lt;/code&gt; if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, &lt;code&gt;Union&lt;/code&gt;s containing either &lt;code&gt;missing&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; are color highlighted in yellow, instead of red.</source>
          <target state="translated">La forma en que utilice esta informaci&amp;oacute;n depende de usted. Obviamente, ser&amp;iacute;a mucho mejor arreglar &lt;code&gt;pos&lt;/code&gt; para que sea de tipo estable: si lo hiciera, todas las variables en &lt;code&gt;f&lt;/code&gt; ser&amp;iacute;an concretas y su rendimiento ser&amp;iacute;a &amp;oacute;ptimo. Sin embargo, hay circunstancias en las que este tipo de inestabilidad de tipo &lt;em&gt;ef&amp;iacute;mero&lt;/em&gt; podr&amp;iacute;a no importar demasiado: por ejemplo, si &lt;code&gt;pos&lt;/code&gt; nunca se usa de forma aislada, el hecho de que la salida de &lt;code&gt;f&lt;/code&gt; sea ​​estable en &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; (para Float64entradas) proteger&amp;aacute; el c&amp;oacute;digo posterior de los efectos de propagaci&amp;oacute;n de la inestabilidad de tipo. Esto es particularmente relevante en los casos en los que corregir la inestabilidad del tipo es dif&amp;iacute;cil o imposible. En tales casos, los consejos anteriores (por ejemplo, agregar anotaciones de tipo y / o dividir funciones) son sus mejores herramientas para contener el &quot;da&amp;ntilde;o&quot; de la inestabilidad de tipo. Adem&amp;aacute;s, tenga en cuenta que incluso Julia Base tiene funciones de tipo inestable. Por ejemplo, la funci&amp;oacute;n &lt;code&gt;findfirst&lt;/code&gt; devuelve el &amp;iacute;ndice a una matriz donde se encuentra una clave, o &lt;code&gt;nothing&lt;/code&gt; si no se encuentra, una inestabilidad de tipo clara. Para que sea m&amp;aacute;s f&amp;aacute;cil encontrar el tipo de inestabilidades que probablemente sean importantes, &lt;code&gt;Union&lt;/code&gt; s que contenga &lt;code&gt;missing&lt;/code&gt; o &lt;code&gt;nothing&lt;/code&gt; son de color resaltado en amarillo, en lugar de rojo.</target>
        </trans-unit>
        <trans-unit id="042ec23eb15357af1265112d56deb61892b131f1" translate="yes" xml:space="preserve">
          <source>However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:</source>
          <target state="translated">Sin embargo,hay que tener en cuenta que el despacho de macros se basa en los tipos de AST que se entregan a la macro,no en los tipos que la AST evalúa en tiempo de ejecución:</target>
        </trans-unit>
        <trans-unit id="ec8145ef611e8eb6adb7aa2875037ca9cf5cb809" translate="yes" xml:space="preserve">
          <source>However, all the information we need for the loop is embedded in the type information of the arguments. Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an &lt;em&gt;expression&lt;/em&gt; that calculates the index:</source>
          <target state="translated">Sin embargo, toda la informaci&amp;oacute;n que necesitamos para el ciclo est&amp;aacute; incrustada en la informaci&amp;oacute;n de tipo de los argumentos. Por lo tanto, podemos utilizar funciones generadas para mover la iteraci&amp;oacute;n al tiempo de compilaci&amp;oacute;n; en el lenguaje del compilador, usamos funciones generadas para desenrollar manualmente el ciclo. El cuerpo se vuelve casi id&amp;eacute;ntico, pero en lugar de calcular el &amp;iacute;ndice lineal, creamos una &lt;em&gt;expresi&amp;oacute;n&lt;/em&gt; que calcula el &amp;iacute;ndice:</target>
        </trans-unit>
        <trans-unit id="42e7ab564618248599a98b48397f91d9696cc5fd" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</source>
          <target state="translated">Sin embargo,hacer esto también será muy lento y perderá la memoria,por lo que normalmente debe evitarlo y en su lugar seguir leyendo.La siguiente sección trata sobre cómo utilizar las llamadas indirectas para lograr un efecto similar de manera eficiente.</target>
        </trans-unit>
        <trans-unit id="d98a9aa4753704d7124f1d48bec32b6c3a7df644" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently achieve a similar effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4c1ec1ac04c3b7530d92971ca6fe0a67c59d9d" translate="yes" xml:space="preserve">
          <source>However, for mutable objects the warning is printed as expected:</source>
          <target state="translated">Sin embargo,para los objetos mutables la advertencia se imprime como se esperaba:</target>
        </trans-unit>
        <trans-unit id="2b94a9c2374adeaf4e451f1d8f8dbbec3cf93bf0" translate="yes" xml:space="preserve">
          <source>However, future calls to &lt;code&gt;tryeval&lt;/code&gt; will continue to see the definition of &lt;code&gt;newfun&lt;/code&gt; as it was &lt;em&gt;at the previous statement at the REPL&lt;/em&gt;, and thus before that call to &lt;code&gt;tryeval&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, las futuras llamadas a &lt;code&gt;tryeval&lt;/code&gt; seguir&amp;aacute;n viendo la definici&amp;oacute;n de &lt;code&gt;newfun&lt;/code&gt; como estaba &lt;em&gt;en la declaraci&amp;oacute;n anterior en el REPL&lt;/em&gt; y, por lo tanto, antes de esa llamada a &lt;code&gt;tryeval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2749cf17a2b4294f113fe7c480d466ff1081a71" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;x&lt;/code&gt; is bound to an object of type &lt;code&gt;Array&lt;/code&gt; (or any other &lt;em&gt;mutable&lt;/em&gt; type). From within the function, you cannot &quot;unbind&quot; &lt;code&gt;x&lt;/code&gt; from this Array, but you &lt;em&gt;can&lt;/em&gt; change its content. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a28d68e1fc2327784959f0995bfa65f1bc559d" translate="yes" xml:space="preserve">
          <source>However, if needed you can specialize on any or all of these arguments. The final argument &lt;code&gt;bc&lt;/code&gt; is a lazy representation of a (potentially fused) broadcast operation, a &lt;code&gt;Broadcasted&lt;/code&gt; object. For these purposes, the most important fields of the wrapper are &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, describing the function and argument list, respectively. Note that the argument list can &amp;mdash; and often does &amp;mdash; include other nested &lt;code&gt;Broadcasted&lt;/code&gt; wrappers.</source>
          <target state="translated">Sin embargo, si es necesario, puede especializarse en alguno o todos estos argumentos. El argumento final &lt;code&gt;bc&lt;/code&gt; es una representaci&amp;oacute;n perezosa de una operaci&amp;oacute;n de transmisi&amp;oacute;n (potencialmente fusionada), un objeto &lt;code&gt;Broadcasted&lt;/code&gt; . A estos efectos, los campos m&amp;aacute;s importantes de la envoltura son &lt;code&gt;f&lt;/code&gt; y &lt;code&gt;args&lt;/code&gt; , que describe la lista de funciones y argumentos, respectivamente. Tenga en cuenta que la lista de argumentos puede incluir, y a menudo lo hace, otras envolturas de &lt;code&gt;Broadcasted&lt;/code&gt; anidadas .</target>
        </trans-unit>
        <trans-unit id="a1a03264a4e905ebd619a9b03ec0d4363bf201f9" translate="yes" xml:space="preserve">
          <source>However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:</source>
          <target state="translated">Sin embargo,si intentas redefinir una constante incorporada o una función ya en uso,Julia te dará un error:</target>
        </trans-unit>
        <trans-unit id="b612aa5b83e1e5e4f183ec87a4a8051d812c4982" translate="yes" xml:space="preserve">
          <source>However, it is not hard to construct cases where this will fail:</source>
          <target state="translated">Sin embargo,no es difícil construir casos en los que esto fallará:</target>
        </trans-unit>
        <trans-unit id="f588e867dce1639bbbc3e181485bd13a34f96de5" translate="yes" xml:space="preserve">
          <source>However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done conveniently by adding the keyword &lt;code&gt;outer&lt;/code&gt;:</source>
          <target state="translated">Sin embargo, en ocasiones es &amp;uacute;til reutilizar una variable local existente como variable de iteraci&amp;oacute;n. Esto se puede hacer convenientemente agregando la palabra clave &lt;code&gt;outer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b3fc16da92345edab485c9b8587412c5e7cbbb69" translate="yes" xml:space="preserve">
          <source>However, it's still possible, for instance, to send a &lt;code&gt;MyType&lt;/code&gt; to a process which has loaded &lt;code&gt;DummyModule&lt;/code&gt; even if it's not in scope:</source>
          <target state="translated">Sin embargo, todav&amp;iacute;a es posible, por ejemplo, enviar un &lt;code&gt;MyType&lt;/code&gt; a un proceso que ha cargado &lt;code&gt;DummyModule&lt;/code&gt; incluso si no est&amp;aacute; dentro del alcance:</target>
        </trans-unit>
        <trans-unit id="0206b7f024c599046b1522c22d104a0f2b4ea5b8" translate="yes" xml:space="preserve">
          <source>However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called &lt;code&gt;array3&lt;/code&gt; from a function like this:</source>
          <target state="translated">Sin embargo, hacer uso de estas t&amp;eacute;cnicas puede resultar sorprendentemente sutil. Por ejemplo, no ser&amp;iacute;a de ayuda si &lt;code&gt;array3&lt;/code&gt; a array3 desde una funci&amp;oacute;n como esta:</target>
        </trans-unit>
        <trans-unit id="1ad09b70c7675ac7974cd81421e0b196fa34837e" translate="yes" xml:space="preserve">
          <source>However, other similar calls still don't work:</source>
          <target state="translated">Sin embargo,otras llamadas similares todavía no funcionan:</target>
        </trans-unit>
        <trans-unit id="d6c01a830ee4c6c4b08c6d0fd04973c57ba502a5" translate="yes" xml:space="preserve">
          <source>However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use &lt;code&gt;llvmcall&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, dado que no se puede confiar en la vectorizaci&amp;oacute;n autom&amp;aacute;tica, el uso futuro ser&amp;aacute; principalmente a trav&amp;eacute;s de bibliotecas que usan &lt;code&gt;llvmcall&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a9c9e751e43cb6eaac4e5372d46543dc59ec370" translate="yes" xml:space="preserve">
          <source>However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:</source>
          <target state="translated">Sin embargo,como esto es un poco engorroso,se ofrecen varios métodos de conveniencia.Por ejemplo,podríamos haber escrito lo anterior como:</target>
        </trans-unit>
        <trans-unit id="4963644e11f9a07fc917ac8319ecfbd548bbe63b" translate="yes" xml:space="preserve">
          <source>However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. The first is to use an absolute path, for example &lt;code&gt;using Base.Sort&lt;/code&gt;. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:</source>
          <target state="translated">Sin embargo, algunos m&amp;oacute;dulos contienen subm&amp;oacute;dulos, lo que significa que a veces es necesario acceder a un m&amp;oacute;dulo que no es de nivel superior. Hay dos maneras de hacer esto. La primera es usar una ruta absoluta, por ejemplo, &lt;code&gt;using Base.Sort&lt;/code&gt; . El segundo es usar una ruta relativa, lo que facilita la importaci&amp;oacute;n de subm&amp;oacute;dulos del m&amp;oacute;dulo actual o cualquiera de sus m&amp;oacute;dulos adjuntos:</target>
        </trans-unit>
        <trans-unit id="5f8e9c86265d52a44715f5ea3dcba697bb6fdada" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788054e244adc6c2716171e1c63990c4810a9000" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, a veces tiene sentido mantener la primera letra may&amp;uacute;scula, por ejemplo, si un argumento para una funci&amp;oacute;n es una letra may&amp;uacute;scula: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="734c2f5135f1e869aae040511570811afbc769c7" translate="yes" xml:space="preserve">
          <source>However, the outer &lt;code&gt;quote&lt;/code&gt; expression is able to interpolate values inside the &lt;code&gt;$&lt;/code&gt; in the inner quote. This is done with multiple &lt;code&gt;$&lt;/code&gt;s:</source>
          <target state="translated">Sin embargo, la expresi&amp;oacute;n de &lt;code&gt;quote&lt;/code&gt; externas puede interpolar valores dentro de &lt;code&gt;$&lt;/code&gt; en la comilla interna. Esto se hace con varios &lt;code&gt;$&lt;/code&gt; s:</target>
        </trans-unit>
        <trans-unit id="a78965b80768b2188b4d959fddb093f72b6aa627" translate="yes" xml:space="preserve">
          <source>However, there are cases where you may need to declare different versions of the outer function for different element types or types of the &lt;code&gt;AbstractVector&lt;/code&gt; of the field &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;MySimpleContainer&lt;/code&gt;. You could do it like this:</source>
          <target state="translated">Sin embargo, hay casos en los que es posible que deba declarar diferentes versiones de la funci&amp;oacute;n externa para diferentes tipos de elementos o tipos de &lt;code&gt;AbstractVector&lt;/code&gt; del campo &lt;code&gt;a&lt;/code&gt; en &lt;code&gt;MySimpleContainer&lt;/code&gt; . Podr&amp;iacute;as hacerlo as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="3975391f531616484a0e31ee77d8e0e00f61fa9e" translate="yes" xml:space="preserve">
          <source>However, there are three key differences:</source>
          <target state="translated">Sin embargo,hay tres diferencias clave:</target>
        </trans-unit>
        <trans-unit id="f5c45c8616fbe8c99fd70a67651ffd25fb8f16b8" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;not&lt;/em&gt; recommended. Instead, use the more efficient &lt;code&gt;complex&lt;/code&gt; function to construct a complex value directly from its real and imaginary parts:</source>
          <target state="translated">Sin embargo, esto &lt;em&gt;no se&lt;/em&gt; recomienda. En su lugar, use la funci&amp;oacute;n &lt;code&gt;complex&lt;/code&gt; m&amp;aacute;s eficiente para construir un valor complejo directamente a partir de sus partes real e imaginaria:</target>
        </trans-unit>
        <trans-unit id="a2261e024bded1ce38fa0b00996da87c5f69ba9d" translate="yes" xml:space="preserve">
          <source>However, type promotion between the primitive types above and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; is not automatic and must be explicitly stated.</source>
          <target state="translated">Sin embargo, la promoci&amp;oacute;n de tipos entre los tipos primitivos anteriores y &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt; no es autom&amp;aacute;tica y debe indicarse expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="a17c41ad2e8a1887210e57ce0ca80b0a2e7e175c" translate="yes" xml:space="preserve">
          <source>However, we don't do this for a good reason: wrapping the &lt;code&gt;expr&lt;/code&gt; in a new scope block (the anonymous function) also slightly changes the meaning of the expression (the scope of any variables in it), while we want &lt;code&gt;@time&lt;/code&gt; to be usable with minimum impact on the wrapped code.</source>
          <target state="translated">Sin embargo, no hacemos esto por una buena raz&amp;oacute;n: envolver la &lt;code&gt;expr&lt;/code&gt; en un nuevo bloque de alcance (la funci&amp;oacute;n an&amp;oacute;nima) tambi&amp;eacute;n cambia ligeramente el significado de la expresi&amp;oacute;n (el alcance de cualquier variable en ella), mientras que nosotros queremos &lt;code&gt;@time&lt;/code&gt; a ser utilizable con un impacto m&amp;iacute;nimo en el c&amp;oacute;digo envuelto.</target>
        </trans-unit>
        <trans-unit id="0b0f70feaa3a28d45e6f3a13fc1f48acf2f37d7c" translate="yes" xml:space="preserve">
          <source>However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type. For example, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; is valid, since &lt;code&gt;Ptr&lt;/code&gt; is always a word-size primitive type. But, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; is not valid, since the type layout of &lt;code&gt;T&lt;/code&gt; is not known statically.</source>
          <target state="translated">Sin embargo, aunque el dise&amp;ntilde;o de tipos debe conocerse est&amp;aacute;ticamente para calcular el C ABI previsto, los par&amp;aacute;metros est&amp;aacute;ticos de la funci&amp;oacute;n se consideran parte de este entorno est&amp;aacute;tico. Los par&amp;aacute;metros est&amp;aacute;ticos de la funci&amp;oacute;n se pueden usar como par&amp;aacute;metros de tipo en la firma de la llamada, siempre que no afecten el dise&amp;ntilde;o del tipo. Por ejemplo, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; es v&amp;aacute;lido, ya que &lt;code&gt;Ptr&lt;/code&gt; es siempre un tipo primitivo del tama&amp;ntilde;o de una palabra. Pero, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; no es v&amp;aacute;lido, ya que el dise&amp;ntilde;o de tipos de &lt;code&gt;T&lt;/code&gt; no se conoce est&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="08e25fd1d8072dc28d6c1dfa6f07c1fbd4ffc288" translate="yes" xml:space="preserve">
          <source>However, you can get access to &lt;code&gt;PowerShell&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d668f1d842d230950802dd8f5eb4d3254c4568" translate="yes" xml:space="preserve">
          <source>Hundred Points Symbol</source>
          <target state="translated">Símbolo de los cien puntos</target>
        </trans-unit>
        <trans-unit id="fdd59db74c581af271b7941aa03e44ed5fe0b191" translate="yes" xml:space="preserve">
          <source>Hushed Face</source>
          <target state="translated">Cara callada</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="9dfda2b4e8d2ebd709351cb5956b33e0e4ffe363" translate="yes" xml:space="preserve">
          <source>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, &lt;em&gt;The American Statistician&lt;/em&gt;, Vol. 50, No. 4, pp. 361-365</source>
          <target state="translated">Hyndman, RJ y Fan, Y. (1996) &quot;Muestra cuantiles en paquetes estad&amp;iacute;sticos&quot;, &lt;em&gt;The American Statistician&lt;/em&gt; , vol. 50, n&amp;uacute;m. 4, p&amp;aacute;gs. 361-365</target>
        </trans-unit>
        <trans-unit id="cde96ad42b76d0bdd741afbb558f7a3b372bce7e" translate="yes" xml:space="preserve">
          <source>I (interval)</source>
          <target state="translated">I (intervalo)</target>
        </trans-unit>
        <trans-unit id="1f1b2f73366cab7e556f4c5764548bfeee9e55d4" translate="yes" xml:space="preserve">
          <source>I passed an argument &lt;code&gt;x&lt;/code&gt; to a function, modified it inside that function, but on the outside, the variable &lt;code&gt;x&lt;/code&gt; is still unchanged. Why?</source>
          <target state="translated">Pas&amp;eacute; un argumento &lt;code&gt;x&lt;/code&gt; a una funci&amp;oacute;n, lo modifiqu&amp;eacute; dentro de esa funci&amp;oacute;n, pero en el exterior, la variable &lt;code&gt;x&lt;/code&gt; sigue sin cambios. &amp;iquest;Por qu&amp;eacute;?</target>
        </trans-unit>
        <trans-unit id="f6d15c9cfe8c2c69adbb304be5e27663dff93f96" translate="yes" xml:space="preserve">
          <source>I.e. the value returned by &lt;code&gt;codeunit(s, i)&lt;/code&gt; is of the type returned by &lt;code&gt;codeunit(s)&lt;/code&gt;.</source>
          <target state="translated">Es decir, el valor devuelto por &lt;code&gt;codeunit(s, i)&lt;/code&gt; es del tipo devuelto por &lt;code&gt;codeunit(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cf18e3da9119216f8e328e30538193a84b6a06e" translate="yes" xml:space="preserve">
          <source>I/O and Network</source>
          <target state="translated">I/O y Red</target>
        </trans-unit>
        <trans-unit id="f202b270f0bf2c3423308846f107faa93c51a606" translate="yes" xml:space="preserve">
          <source>ID of the device that contains the file</source>
          <target state="translated">La identificación del dispositivo que contiene el archivo</target>
        </trans-unit>
        <trans-unit id="f9c4d94c8313e5f3e388b78d066d32450a104438" translate="yes" xml:space="preserve">
          <source>IO Output Contextual Properties</source>
          <target state="translated">Propiedades contextuales de salida de IO</target>
        </trans-unit>
        <trans-unit id="197f5eacc88f8f1df449bfc2c0077d2d00ba82c7" translate="yes" xml:space="preserve">
          <source>IO redirection can be accomplished by passing keyword arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; to the &lt;code&gt;pipeline&lt;/code&gt; function:</source>
          <target state="translated">La redirecci&amp;oacute;n de E / S se puede lograr pasando argumentos de palabras clave &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; y &lt;code&gt;stderr&lt;/code&gt; a la funci&amp;oacute;n de &lt;code&gt;pipeline&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="01d2fc4baf23050afed6538bf5b3afda200aec20" translate="yes" xml:space="preserve">
          <source>IOBuffer</source>
          <target state="translated">IOBuffer</target>
        </trans-unit>
        <trans-unit id="1e240958856813e40093848d027d47dc30e4009a" translate="yes" xml:space="preserve">
          <source>IOContext</source>
          <target state="translated">IOContext</target>
        </trans-unit>
        <trans-unit id="29093ff8b21b1b330d3e6699a2ad82a180dd947e" translate="yes" xml:space="preserve">
          <source>IOContext()</source>
          <target state="translated">IOContext()</target>
        </trans-unit>
        <trans-unit id="3afa239559b1455a86cd4aafab53cb6dd69792c0" translate="yes" xml:space="preserve">
          <source>IOStream</source>
          <target state="translated">IOStream</target>
        </trans-unit>
        <trans-unit id="8d31d2211f88e51d4dac04058ee63fd1f5837600" translate="yes" xml:space="preserve">
          <source>Ice Cream</source>
          <target state="translated">Helado</target>
        </trans-unit>
        <trans-unit id="2b3a1ae210dbbbf1609a9fd75685f6380218b075" translate="yes" xml:space="preserve">
          <source>IdDict</source>
          <target state="translated">IdDict</target>
        </trans-unit>
        <trans-unit id="898cecd14809e1e6d2d6a1ad03f40fe8f8898ff9" translate="yes" xml:space="preserve">
          <source>Identical To</source>
          <target state="translated">Idéntico a</target>
        </trans-unit>
        <trans-unit id="c539ce4823e892243cf1d72e5cda29852ab1bb48" translate="yes" xml:space="preserve">
          <source>Identical To And Slanted Parallel</source>
          <target state="translated">Idéntico y paralelo inclinado</target>
        </trans-unit>
        <trans-unit id="44763ae8a5457dbe6219995560f8ceac0b654107" translate="yes" xml:space="preserve">
          <source>Identical With Dot Above</source>
          <target state="translated">Idéntico al punto anterior</target>
        </trans-unit>
        <trans-unit id="49f0f00de3919e6aa513f490a486fcbae4d4df50" translate="yes" xml:space="preserve">
          <source>If $n$ is negative, then it is defined in terms of the identity</source>
          <target state="translated">Si $n$ es negativo,entonces se define en términos de la identidad</target>
        </trans-unit>
        <trans-unit id="4ed2889e692f7a726f27cb34a6abbc329da52fe8" translate="yes" xml:space="preserve">
          <source>If $n$ is non-negative, then it is the number of ways to choose &lt;code&gt;k&lt;/code&gt; out of &lt;code&gt;n&lt;/code&gt; items:</source>
          <target state="translated">Si $ n $ no es negativo, entonces es el n&amp;uacute;mero de formas de elegir &lt;code&gt;k&lt;/code&gt; de &lt;code&gt;n&lt;/code&gt; elementos:</target>
        </trans-unit>
        <trans-unit id="21a045b4d60526617fd3c07b9d46739e69a41cdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalue, compute the principal matrix logarithm of &lt;code&gt;A&lt;/code&gt;, i.e. the unique matrix $X$ such that $e^X = A$ and $-\pi &amp;lt; Im(\lambda) &amp;lt; \pi$ for all the eigenvalues $\lambda$ of $X$. If &lt;code&gt;A&lt;/code&gt; has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; no tiene un valor propio real negativo, calcule el logaritmo de la matriz principal de &lt;code&gt;A&lt;/code&gt; , es decir, la matriz &amp;uacute;nica $ X $ tal que $ e ^ X = A $ y $ - \ pi &amp;lt;Im (\ lambda) &amp;lt;\ pi $ para todos los valores propios $ \ lambda $ de $ X $. Si &lt;code&gt;A&lt;/code&gt; tiene valores propios no positivos, se devuelve una funci&amp;oacute;n matricial no principal siempre que sea posible.</target>
        </trans-unit>
        <trans-unit id="7259d98627a04b894a1123257649b9b0e506f9f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalues, compute the principal matrix square root of &lt;code&gt;A&lt;/code&gt;, that is the unique matrix $X$ with eigenvalues having positive real part such that $X^2 = A$. Otherwise, a nonprincipal square root is returned.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; no tiene valores propios reales negativos, calcule la ra&amp;iacute;z cuadrada de la matriz principal de &lt;code&gt;A&lt;/code&gt; , que es la matriz &amp;uacute;nica $ X $ con valores propios que tienen una parte real positiva tal que $ X ^ 2 = A $. De lo contrario, se devuelve una ra&amp;iacute;z cuadrada no principal.</target>
        </trans-unit>
        <trans-unit id="390ecc8380adb6dd4fff37f515d8dc55040ad6a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt; or real-&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt;, then the Hessenberg decomposition produces a real-symmetric tridiagonal matrix and &lt;code&gt;F.H&lt;/code&gt; is of type &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e08a2a0f6796f08007ab9fdda2c45c43480624f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d3df34d4b0d8669771d98ccd80e4361eb22b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is real-symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. For such matrices, eigenvalues &amp;lambda; that appear to be slightly negative due to roundoff errors are treated as if they were zero More precisely, matrices with all eigenvalues &lt;code&gt;&amp;ge; -rtol*(max |&amp;lambda;|)&lt;/code&gt; are treated as semidefinite (yielding a Hermitian square root), with negative eigenvalues taken to be zero. &lt;code&gt;rtol&lt;/code&gt; is a keyword argument to &lt;code&gt;sqrt&lt;/code&gt; (in the Hermitian/real-symmetric case only) that defaults to machine precision scaled by &lt;code&gt;size(A,1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b01775b8b82ce68d3f6a6f522f474a638dda03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the cosine. Otherwise, the cosine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su autodescomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular el coseno. De lo contrario, el coseno se determina llamando a &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acf6a44af56176e5053aa08ad7d4eea1a7727bea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su autodescomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular el coseno inverso. De lo contrario, el coseno inverso se determina mediante &lt;code&gt;log&lt;/code&gt; y &lt;code&gt;sqrt&lt;/code&gt; . Para conocer la teor&amp;iacute;a y las f&amp;oacute;rmulas logar&amp;iacute;tmicas utilizadas para calcular esta funci&amp;oacute;n, consulte &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="656a2e02dd9901a5d5d038f1484c6e9a0c0da179" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_1&quot; id=&quot;citeref-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfce79aa807e6b2cb49ddfffb2847f191045922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su autodescomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular el seno inverso. De lo contrario, el seno inverso se determina mediante &lt;code&gt;log&lt;/code&gt; y &lt;code&gt;sqrt&lt;/code&gt; . Para conocer la teor&amp;iacute;a y las f&amp;oacute;rmulas logar&amp;iacute;tmicas utilizadas para calcular esta funci&amp;oacute;n, consulte &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c57d54383c6569d422099f76dc516cae4a4a6b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_2&quot; id=&quot;citeref-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2646487106f321c98004368d4fc3670f47b0a86e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su descomposici&amp;oacute;n propia ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular la tangente inversa. De lo contrario, la tangente inversa se determina mediante &lt;code&gt;log&lt;/code&gt; . Para conocer la teor&amp;iacute;a y las f&amp;oacute;rmulas logar&amp;iacute;tmicas utilizadas para calcular esta funci&amp;oacute;n, consulte &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88a24bd15ac5a68c08c00b78778d22ccaac3c21f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_3&quot; id=&quot;citeref-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317ce8e704df5d75a6762d7ee94cb8590a0eeb84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the sine. Otherwise, the sine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su autodescomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular el seno. De lo contrario, el seno se determina llamando a &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f03ca25824d588274952404db5eb47ba9feeba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. Otherwise, the square root is determined by means of the Bj&amp;ouml;rck-Hammarling method &lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt;, which computes the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) and then the complex square root of the triangular factor.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su descomposici&amp;oacute;n propia ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se utiliza para calcular la ra&amp;iacute;z cuadrada. De lo contrario, la ra&amp;iacute;z cuadrada se determina mediante el m&amp;eacute;todo de Bj&amp;ouml;rck-Hammarling &lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt; , que calcula la forma compleja de Schur ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; ) y luego la ra&amp;iacute;z cuadrada compleja del factor triangular.</target>
        </trans-unit>
        <trans-unit id="da6d9fe794edc15bdf1db668291afd8d8cb893d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the tangent. Otherwise, the tangent is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, su autodescomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ) se usa para calcular la tangente. De lo contrario, la tangente se determina llamando a &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e82ebcef54c304de01d1461f11b56325e46b2234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; and &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es sim&amp;eacute;trico o hermitiano, se utiliza su autodecomposici&amp;oacute;n ( &lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt; ), si &lt;code&gt;A&lt;/code&gt; es triangular se emplea una versi&amp;oacute;n mejorada del m&amp;eacute;todo inverso de escalado y cuadrado (ver &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; y &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt; ). Para matrices generales, se calcula la forma compleja de Schur ( &lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt; ) y se usa el algoritmo triangular en el factor triangular.</target>
        </trans-unit>
        <trans-unit id="7cd81f11c1d70424b51ccffe350316108e01c22e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;sup&gt;&lt;a href=&quot;#footnote-AH12&quot; id=&quot;citeref-AH12&quot;&gt;[AH12]&lt;/a&gt;&lt;/sup&gt; and &lt;sup&gt;&lt;a href=&quot;#footnote-AHR13&quot; id=&quot;citeref-AHR13&quot;&gt;[AHR13]&lt;/a&gt;&lt;/sup&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31effe06eb8010b919cfa614d0573384a4c26bdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DataType&lt;/code&gt;&lt;code&gt;T&lt;/code&gt; does not have a specific size, an error is thrown.</source>
          <target state="translated">Si &lt;code&gt;DataType&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; no tiene un tama&amp;ntilde;o espec&amp;iacute;fico, se produce un error.</target>
        </trans-unit>
        <trans-unit id="65a78265c4f32be6b8f80e6ff2b5005fabff1e58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Eigen&lt;/code&gt; is the factorization object, the eigenvalues can be obtained via &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors as the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c71436c7107833fddd5b4b5c6ae6ac2cda922a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::GeneralizedEigen&lt;/code&gt; is the factorization object, the eigenvalues can be obtained via &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors as the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01e4881f70ca748aeb84922a14f5f7db186c9f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::GeneralizedSchur&lt;/code&gt; is the factorization object, the (quasi) triangular Schur factors can be obtained via &lt;code&gt;F.S&lt;/code&gt; and &lt;code&gt;F.T&lt;/code&gt;, the left unitary/orthogonal Schur vectors via &lt;code&gt;F.left&lt;/code&gt; or &lt;code&gt;F.Q&lt;/code&gt;, and the right unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.right&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; and &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt;. The generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; can be obtained with &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab48030073624eeb674b91b0955f920e2a071342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Hessenberg&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt;. When &lt;code&gt;Q&lt;/code&gt; is extracted, the resulting type is the &lt;code&gt;HessenbergQ&lt;/code&gt; object, and may be converted to a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4e73df12d848cb37ff07b3e198fc0482a106ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::SVD&lt;/code&gt; is the factorization object, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; can be obtained via &lt;code&gt;F.U&lt;/code&gt;, &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.V&lt;/code&gt; and &lt;code&gt;F.Vt&lt;/code&gt;, such that &lt;code&gt;A = U * Diagonal(S) * Vt&lt;/code&gt;. The singular values in &lt;code&gt;S&lt;/code&gt; are sorted in descending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f171f3d3fce677fec26e12b57715e21774c193" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Schur&lt;/code&gt; is the factorization object, the (quasi) triangular Schur factor can be obtained via either &lt;code&gt;F.Schur&lt;/code&gt; or &lt;code&gt;F.T&lt;/code&gt; and the orthogonal/unitary Schur vectors via &lt;code&gt;F.vectors&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt;. The eigenvalues of &lt;code&gt;A&lt;/code&gt; can be obtained with &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ac2f54db074364d37a4067713ee52ebafa3e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I_1&lt;/code&gt; is changed to a two-dimensional matrix, then &lt;code&gt;X&lt;/code&gt; becomes an &lt;code&gt;n+1&lt;/code&gt;-dimensional array of shape &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt;. The matrix adds a dimension.</source>
          <target state="translated">Si &lt;code&gt;I_1&lt;/code&gt; se cambia a una matriz bidimensional, entonces &lt;code&gt;X&lt;/code&gt; se convierte en una matriz &lt;code&gt;n+1&lt;/code&gt; - dimensional de forma &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt; . La matriz agrega una dimensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2337775037e3e4a6505e42024632bd3eb4bbd6dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S::BunchKaufman&lt;/code&gt; is the factorization object, the components can be obtained via &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c942e11644bfa14cfe833c922c7cc44bc3db5861" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S::LQ&lt;/code&gt; is the factorization object, the lower triangular component can be obtained via &lt;code&gt;S.L&lt;/code&gt;, and the orthogonal/unitary component via &lt;code&gt;S.Q&lt;/code&gt;, such that &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d018b41d67fa72dfd3dd7eab414a34042d26fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;, then the memory is assumed to contain a reference to a Julia object (a &lt;code&gt;jl_value_t*&lt;/code&gt;), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector. If the &lt;code&gt;Ptr&lt;/code&gt; itself is actually a &lt;code&gt;jl_value_t*&lt;/code&gt;, it can be converted back to a Julia object reference by &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt;&lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt;&lt;/a&gt;. (Julia values &lt;code&gt;v&lt;/code&gt; can be converted to &lt;code&gt;jl_value_t*&lt;/code&gt; pointers, as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, by calling &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt;&lt;code&gt;pointer_from_objref(v)&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;Any&lt;/code&gt; , entonces se supone que la memoria contiene una referencia a un objeto de Julia (un &lt;code&gt;jl_value_t*&lt;/code&gt; ), el resultado ser&amp;aacute; una referencia a este objeto y el objeto no se copiar&amp;aacute;. Debe tener cuidado en este caso para asegurarse de que el objeto siempre est&amp;eacute; visible para el recolector de basura (los punteros no cuentan, pero la nueva referencia s&amp;iacute;) para asegurarse de que la memoria no se libere prematuramente. Tenga en cuenta que si el objeto no fue asignado originalmente por Julia, el recolector de basura de Julia nunca finalizar&amp;aacute; el nuevo objeto. Si el &lt;code&gt;Ptr&lt;/code&gt; en s&amp;iacute; es en realidad un &lt;code&gt;jl_value_t*&lt;/code&gt; , puede volver a convertirse en una referencia de objeto de Julia mediante &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt; &lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt; &lt;/a&gt; . (Julia valora &lt;code&gt;v&lt;/code&gt; se puede convertir en punteros &lt;code&gt;jl_value_t*&lt;/code&gt; , como &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; , llamando a &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt; &lt;code&gt;pointer_from_objref(v)&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="51788d4fcfdfd4d39c958952b0bc0324310a6a5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; type, then it will return the closest value to &lt;code&gt;x&lt;/code&gt; representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; tipo, entonces se devuelve el valor m&amp;aacute;s cercano a &lt;code&gt;x&lt;/code&gt; representable por &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedc994cd3fc0835ff4382a890fe92f16cb71d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a collection type and &lt;code&gt;x&lt;/code&gt; a collection, the result of &lt;code&gt;convert(T, x)&lt;/code&gt; may alias all or part of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de colecci&amp;oacute;n &lt;code&gt;x&lt;/code&gt; una colecci&amp;oacute;n, el resultado de &lt;code&gt;convert(T, x)&lt;/code&gt; puede alias todo o parte de &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca5b35227b72b028ed45253536f1af95a0b6efba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de punto flotante, el resultado es el valor representable m&amp;aacute;s cercano, que podr&amp;iacute;a ser infinito positivo o negativo.</target>
        </trans-unit>
        <trans-unit id="4201a0a82cce066dea7c824bdf90b57c195e9972" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a numeric type, the result is an array of that type, with any non-numeric elements as &lt;code&gt;NaN&lt;/code&gt; for floating-point types, or zero. Other useful values of &lt;code&gt;T&lt;/code&gt; include &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;AbstractString&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo num&amp;eacute;rico, el resultado es una matriz de ese tipo, con cualquier elemento no num&amp;eacute;rico como &lt;code&gt;NaN&lt;/code&gt; para tipos de punto flotante, o cero. Otros valores &amp;uacute;tiles de &lt;code&gt;T&lt;/code&gt; incluyen &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;AbstractString&lt;/code&gt; y &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5708e9143fa5c221a25e2fd582d17441adb4aff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union of types containing &lt;code&gt;Missing&lt;/code&gt;, return a new type with &lt;code&gt;Missing&lt;/code&gt; removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69fee994b4c0ef137b6453b3ceac4a68a22fb0fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; type, an &lt;a href=&quot;#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;, for example if &lt;code&gt;x&lt;/code&gt; is not integer-valued, or is outside the range supported by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt; tipo, una &lt;a href=&quot;#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt; se elevar&amp;aacute; si &lt;code&gt;x&lt;/code&gt; no es representable por &lt;code&gt;T&lt;/code&gt; , por ejemplo, si &lt;code&gt;x&lt;/code&gt; no es valorada n&amp;uacute;mero entero-, o est&amp;aacute; fuera del rango soportado por &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c36ac776e4be839ff56e17825105904e00568128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integer type, an &lt;code&gt;InexactError&lt;/code&gt; is raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo entero, un &lt;code&gt;InexactError&lt;/code&gt; se eleva si &lt;code&gt;x&lt;/code&gt; no es representable por &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7762b87399cdbea094b67bb56bb79bce4032130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and but does &lt;em&gt;not&lt;/em&gt; have a top-level UUID entry, &lt;code&gt;uuid&lt;/code&gt; is a dummy UUID generated by hashing the canonical (real) path to &lt;code&gt;X/Project.toml&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;X/Project.toml&lt;/code&gt; existe pero &lt;em&gt;no&lt;/em&gt; tiene una entrada UUID de nivel superior, &lt;code&gt;uuid&lt;/code&gt; es un UUID ficticio generado mediante el hash de la ruta can&amp;oacute;nica (real) a &lt;code&gt;X/Project.toml&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57feda5962ebeb025a02c2fc5115db7f5ee74658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and has a &lt;code&gt;uuid&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; is that value.</source>
          <target state="translated">Si &lt;code&gt;X/Project.toml&lt;/code&gt; existe y tiene una entrada &lt;code&gt;uuid&lt;/code&gt; , entonces &lt;code&gt;uuid&lt;/code&gt; es ese valor.</target>
        </trans-unit>
        <trans-unit id="b0ad6875ad056062a02a932f0ca014f6680202e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alg = DivideAndConquer()&lt;/code&gt; a divide-and-conquer algorithm is used to calculate the SVD. Another (typically slower but more accurate) option is &lt;code&gt;alg = QRIteration()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6feb00535e98202cbe0e255e2cd1a8e59544d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, at most one &lt;code&gt;read&lt;/code&gt; call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the &lt;code&gt;all&lt;/code&gt; option.</source>
          <target state="translated">Si &lt;code&gt;all&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; (el valor predeterminado), esta funci&amp;oacute;n bloquear&amp;aacute; el intento repetido de leer todos los bytes solicitados, hasta que se produzca un error o el final del archivo. Si &lt;code&gt;all&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , se realiza como m&amp;aacute;ximo una llamada de &lt;code&gt;read&lt;/code&gt; y la cantidad de datos devueltos depende del dispositivo. Tenga en cuenta que no todos los tipos de transmisi&amp;oacute;n admiten la opci&amp;oacute;n de &lt;code&gt;all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3a53d050caeb89134ca9bb80d1091ff36a0cf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a power of 2 or 10, &lt;a href=&quot;#Base.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; should be used, as these will typically be faster and more accurate. For example,</source>
          <target state="translated">Si &lt;code&gt;b&lt;/code&gt; es una potencia de 2 o 10, debe usarse &lt;a href=&quot;#Base.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#Base.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; , ya que normalmente ser&amp;aacute;n m&amp;aacute;s r&amp;aacute;pidos y precisos. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="89b9fac160344d84b2e97547e3cbb9b2dd975a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_size&lt;/code&gt; is specified, the collection is processed in batch mode. &lt;code&gt;f&lt;/code&gt; must then be a function that must accept a &lt;code&gt;Vector&lt;/code&gt; of argument tuples and must return a vector of results. The input vector will have a length of &lt;code&gt;batch_size&lt;/code&gt; or less.</source>
          <target state="translated">Si se especifica &lt;code&gt;batch_size&lt;/code&gt; , la colecci&amp;oacute;n se procesa en modo batch. &lt;code&gt;f&lt;/code&gt; debe ser una funci&amp;oacute;n que debe aceptar un &lt;code&gt;Vector&lt;/code&gt; de tuplas de argumentos y debe devolver un vector de resultados. El vector de entrada tendr&amp;aacute; una longitud de &lt;code&gt;batch_size&lt;/code&gt; o menos.</target>
        </trans-unit>
        <trans-unit id="9a514f5181b462b5cf60570457a733a924782944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;collection&lt;/code&gt; is ordered, use &lt;a href=&quot;#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt; to add all the elements of another collection to it. The result of the preceding example is equivalent to &lt;code&gt;append!([1, 2, 3], [4, 5, 6])&lt;/code&gt;. For &lt;code&gt;AbstractSet&lt;/code&gt; objects, &lt;a href=&quot;#Base.union!&quot;&gt;&lt;code&gt;union!&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2467dc77e236fb9b24d515beabeb30ab9b34314" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dims&lt;/code&gt; is a tuple, the order of the dimensions in &lt;code&gt;dims&lt;/code&gt; is relevant and specifies the linear order of the slices. E.g., if &lt;code&gt;A&lt;/code&gt; is three dimensional and &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(1, 2)&lt;/code&gt;, the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(2, 1)&lt;/code&gt; instead, the same slices will be taken, but the result order will be row-major instead.</source>
          <target state="translated">Si &lt;code&gt;dims&lt;/code&gt; es una tupla, el orden de las dimensiones en &lt;code&gt;dims&lt;/code&gt; es relevante y especifica el orden lineal de los cortes. Por ejemplo, si &lt;code&gt;A&lt;/code&gt; es tridimensional y &lt;code&gt;dims&lt;/code&gt; es &lt;code&gt;(1, 2)&lt;/code&gt; , los ordenamientos de las dos primeras dimensiones se reorganizan de manera que se clasifiquen los cortes (de la tercera dimensi&amp;oacute;n restante). Si &lt;code&gt;dims&lt;/code&gt; es &lt;code&gt;(2, 1)&lt;/code&gt; lugar, se tomar&amp;aacute;n los mismos cortes, pero el orden de resultado ser&amp;aacute; el de fila mayor.</target>
        </trans-unit>
        <trans-unit id="74fad15bfd2101b3b16f9ea74a15c93af724d1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dlm&lt;/code&gt; is omitted, it defaults to &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se omite &lt;code&gt;dlm&lt;/code&gt; , el valor predeterminado es &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d7429e0d71b847a07568d302028712dbaf31f03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factorize&lt;/code&gt; is called on a Hermitian positive-definite matrix, for instance, then &lt;code&gt;factorize&lt;/code&gt; will return a Cholesky factorization.</source>
          <target state="translated">Si se llama a &lt;code&gt;factorize&lt;/code&gt; en una matriz hermitiana positiva definida, por ejemplo, entonces &lt;code&gt;factorize&lt;/code&gt; devolver&amp;aacute; una factorizaci&amp;oacute;n de Cholesky.</target>
        </trans-unit>
        <trans-unit id="b7c73e768a4a1fc2665ff51aa066980c89d3ec1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;follow_symlinks=false&lt;/code&gt;, and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be created as a symbolic link. If &lt;code&gt;follow_symlinks=true&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be a copy of the file or directory &lt;code&gt;src&lt;/code&gt; refers to. Return &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;follow_symlinks=false&lt;/code&gt; y &lt;code&gt;src&lt;/code&gt; es un enlace simb&amp;oacute;lico, &lt;code&gt;dst&lt;/code&gt; se crear&amp;aacute; como un enlace simb&amp;oacute;lico. Si &lt;code&gt;follow_symlinks=true&lt;/code&gt; y &lt;code&gt;src&lt;/code&gt; es un enlace simb&amp;oacute;lico, &lt;code&gt;dst&lt;/code&gt; ser&amp;aacute; una copia del archivo o directorio al que se refiere &lt;code&gt;src&lt;/code&gt; . Regrese &lt;code&gt;dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fefe7c70552bb288eba8725570e0711eb9913bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;full = false&lt;/code&gt; (default), a &quot;thin&quot; SVD is returned. For a $M \times N$ matrix &lt;code&gt;A&lt;/code&gt;, in the full factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times M&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times N&lt;/code&gt;, while in the thin factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times K&lt;/code&gt;, where &lt;code&gt;K = \min(M,N)&lt;/code&gt; is the number of singular values.</source>
          <target state="translated">Si &lt;code&gt;full = false&lt;/code&gt; (predeterminado), se devuelve un SVD &quot;delgado&quot;. Para una matriz &lt;code&gt;A&lt;/code&gt; de $ M \ veces N $ , en la factorizaci&amp;oacute;n completa &lt;code&gt;U&lt;/code&gt; es &lt;code&gt;M \times M&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es &lt;code&gt;N \times N&lt;/code&gt; , mientras que en la factorizaci&amp;oacute;n delgada &lt;code&gt;U&lt;/code&gt; es &lt;code&gt;M \times K&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es &lt;code&gt;N \times K&lt;/code&gt; , donde &lt;code&gt;K = \min(M,N)&lt;/code&gt; es el n&amp;uacute;mero de valores singulares.</target>
        </trans-unit>
        <trans-unit id="e7087620ad88bc806c680dac427ffd57a67879dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fussy_sqrt&lt;/code&gt; is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:</source>
          <target state="translated">Si se llama a &lt;code&gt;fussy_sqrt&lt;/code&gt; con un valor negativo de otra funci&amp;oacute;n, en lugar de intentar continuar la ejecuci&amp;oacute;n de la funci&amp;oacute;n que llama, regresa inmediatamente, mostrando el mensaje de error en la sesi&amp;oacute;n interactiva:</target>
        </trans-unit>
        <trans-unit id="c19e0b85728fe9481b7abf51cbb032dc0e45287a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, these &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to the method bodies yielded by expanding the generators.</source>
          <target state="translated">Si &lt;code&gt;generated&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , las instancias de &lt;code&gt;CodeInfo&lt;/code&gt; devueltas corresponder&amp;aacute;n a implementaciones de reserva. Se produce un error si no existe una implementaci&amp;oacute;n alternativa. Si &lt;code&gt;generated&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , estas instancias de &lt;code&gt;CodeInfo&lt;/code&gt; corresponder&amp;aacute;n a los cuerpos del m&amp;eacute;todo generados al expandir los generadores.</target>
        </trans-unit>
        <trans-unit id="3b5b7e505ab23a5d0aa601628f61af1433ebc0f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;header&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the first row of data will be read as header and the tuple &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; is returned instead of only &lt;code&gt;data_cells&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;header&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , la primera fila de datos se leer&amp;aacute; como encabezado y se &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; la tupla (data_cells, header_cells) en lugar de solo &lt;code&gt;data_cells&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c950181a2a1658a2e38c89bd49475efe3e66e317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding code unit &lt;code&gt;i&lt;/code&gt; is part of. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return &lt;code&gt;i&lt;/code&gt;; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to 0 or &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; return &lt;code&gt;i&lt;/code&gt;. In all other cases throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;i&lt;/code&gt; est&amp;aacute; dentro de los l&amp;iacute;mites en &lt;code&gt;s&lt;/code&gt; , devuelve el &amp;iacute;ndice del inicio del car&amp;aacute;cter de cuya unidad de c&amp;oacute;digo de codificaci&amp;oacute;n &lt;code&gt;i&lt;/code&gt; es parte. En otras palabras, si &lt;code&gt;i&lt;/code&gt; es el comienzo de un car&amp;aacute;cter, devuelve &lt;code&gt;i&lt;/code&gt; ; si &lt;code&gt;i&lt;/code&gt; no es el comienzo de un car&amp;aacute;cter, rebobina hasta el comienzo de un car&amp;aacute;cter y devuelve ese &amp;iacute;ndice. Si &lt;code&gt;i&lt;/code&gt; es igual a 0 o &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; devuelve &lt;code&gt;i&lt;/code&gt; . En todos los dem&amp;aacute;s casos, lanza &lt;code&gt;BoundsError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed8634de2b332fe1583659d48b66208896196beb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts after index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the next character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, move forward until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt; return &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is in bounds but greater or equal to &lt;code&gt;lastindex(str)&lt;/code&gt; return &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;i&lt;/code&gt; est&amp;aacute; dentro de los l&amp;iacute;mites en &lt;code&gt;s&lt;/code&gt; , devuelve el &amp;iacute;ndice del inicio del car&amp;aacute;cter cuya codificaci&amp;oacute;n comienza despu&amp;eacute;s del &amp;iacute;ndice &lt;code&gt;i&lt;/code&gt; . En otras palabras, si &lt;code&gt;i&lt;/code&gt; es el comienzo de un car&amp;aacute;cter, devuelve el comienzo del siguiente car&amp;aacute;cter; si &lt;code&gt;i&lt;/code&gt; no es el comienzo de un car&amp;aacute;cter, avanza hasta el comienzo de un car&amp;aacute;cter y devuelve ese &amp;iacute;ndice. Si &lt;code&gt;i&lt;/code&gt; es igual a &lt;code&gt;0&lt;/code&gt; , devuelve &lt;code&gt;1&lt;/code&gt; . Si &lt;code&gt;i&lt;/code&gt; est&amp;aacute; dentro de los l&amp;iacute;mites pero es mayor o igual que &lt;code&gt;lastindex(str)&lt;/code&gt; devuelve &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; . De lo contrario, lanza &lt;code&gt;BoundsError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bcc465fac95b41229c6fb79ecf0d3dab69e75e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts before index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the previous character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;1&lt;/code&gt; return &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; return &lt;code&gt;lastindex(str)&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;i&lt;/code&gt; est&amp;aacute; dentro de los l&amp;iacute;mites en &lt;code&gt;s&lt;/code&gt; , devuelve el &amp;iacute;ndice del inicio del car&amp;aacute;cter cuya codificaci&amp;oacute;n comienza antes del &amp;iacute;ndice &lt;code&gt;i&lt;/code&gt; . En otras palabras, si &lt;code&gt;i&lt;/code&gt; es el comienzo de un car&amp;aacute;cter, devuelve el comienzo del car&amp;aacute;cter anterior; si &lt;code&gt;i&lt;/code&gt; no es el comienzo de un car&amp;aacute;cter, rebobina hasta el comienzo de un car&amp;aacute;cter y devuelve ese &amp;iacute;ndice. Si &lt;code&gt;i&lt;/code&gt; es igual a &lt;code&gt;1&lt;/code&gt; , devuelve &lt;code&gt;0&lt;/code&gt; . Si &lt;code&gt;i&lt;/code&gt; es igual a &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; devuelve &lt;code&gt;lastindex(str)&lt;/code&gt; . De lo contrario, lanza &lt;code&gt;BoundsError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ebe5e40c213fd1e7b9dc945437a4e812c30e543" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), then &lt;code&gt;ix&lt;/code&gt; is initialized to contain the indices of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fcfeccc007b268d4af436c2f9443a9d036bba79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, but &lt;code&gt;ix&lt;/code&gt; does not contain (a permutation of) the indices of &lt;code&gt;v&lt;/code&gt;, the behavior of &lt;code&gt;partialsortperm!&lt;/code&gt; is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfff02ba2ab7ab8f47553333086d7d3b017d4eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is not specified, &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; are used to connect.</source>
          <target state="translated">Si no se especifica &lt;code&gt;io&lt;/code&gt; , se utilizan el &lt;code&gt;host&lt;/code&gt; y el &lt;code&gt;port&lt;/code&gt; para conectarse.</target>
        </trans-unit>
        <trans-unit id="675d2f45d06133423691ac8939a36ff3793bfbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.</source>
          <target state="translated">Si se especifica &lt;code&gt;io&lt;/code&gt; , se utiliza para leer la informaci&amp;oacute;n de host / puerto. Un trabajador de Julia imprime su direcci&amp;oacute;n de enlace y su puerto al inicio. Esto permite que los trabajadores de Julia escuchen en cualquier puerto libre disponible en lugar de requerir que los puertos de los trabajadores se configuren manualmente.</target>
        </trans-unit>
        <trans-unit id="23c03ff245d9cf669803a913ec063d9d852e916b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;irange&lt;/code&gt; is not &lt;code&gt;1:n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the dimension of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">Si &lt;code&gt;irange&lt;/code&gt; no es &lt;code&gt;1:n&lt;/code&gt; , donde &lt;code&gt;n&lt;/code&gt; es la dimensi&amp;oacute;n de &lt;code&gt;A&lt;/code&gt; , entonces la factorizaci&amp;oacute;n devuelta ser&amp;aacute; una factorizaci&amp;oacute;n &lt;em&gt;truncada&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="33bb6515a9488e11cd97387cfe2fdf0354f00b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isless(x, y)&lt;/code&gt; is defined, then so is &lt;code&gt;isless(y, x)&lt;/code&gt; and &lt;code&gt;isequal(x, y)&lt;/code&gt;, and exactly one of those three yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;isless(x, y)&lt;/code&gt; , entonces &lt;code&gt;isless(y, x)&lt;/code&gt; e &lt;code&gt;isequal(x, y)&lt;/code&gt; , y exactamente uno de esos tres da como resultado &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27bcd4132639e391333ba702df2bbfcfeb96c942" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if &lt;code&gt;itr&lt;/code&gt; contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the median of non-missing values.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; contiene &lt;code&gt;NaN&lt;/code&gt; o valores &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , el resultado tambi&amp;eacute;n es &lt;code&gt;NaN&lt;/code&gt; o &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; tiene prioridad si &lt;code&gt;itr&lt;/code&gt; contiene ambos). Usar la &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n de omitir &lt;code&gt;missing&lt;/code&gt; entradas y calcular la mediana de los valores no perdidos.</target>
        </trans-unit>
        <trans-unit id="c3e083f5fc9364992337e03964ee084acea5fae6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the mean of non-missing values.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; contiene &lt;code&gt;NaN&lt;/code&gt; o valores &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , el resultado tambi&amp;eacute;n es &lt;code&gt;NaN&lt;/code&gt; o &lt;code&gt;missing&lt;/code&gt; ( &lt;code&gt;missing&lt;/code&gt; tiene prioridad si la matriz contiene ambos). Usar la &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n de omitir &lt;code&gt;missing&lt;/code&gt; entradas y calcular la media de los valores no perdidos.</target>
        </trans-unit>
        <trans-unit id="6474b35658d7c26eeead842892ada1aea0d886f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; es un &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; se pueden proporcionar para calcular la desviaci&amp;oacute;n est&amp;aacute;ndar sobre las dimensiones, y &lt;code&gt;m&lt;/code&gt; pueden contener medios para cada dimensi&amp;oacute;n de la &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51822a7fae2f9177cdbe8acba291b2ecbdaf5a84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;means&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; es un &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; se pueden proporcionar para calcular la desviaci&amp;oacute;n est&amp;aacute;ndar sobre las dimensiones, y &lt;code&gt;means&lt;/code&gt; pueden contener medios para cada dimensi&amp;oacute;n de &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a062a8f0de1a26806b03ecc36f3c075df17d6625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions. In that case, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf5ec759432f757b892cc486fe0509d46288036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; es un &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; se pueden proporcionar para calcular la varianza sobre las dimensiones, y &lt;code&gt;m&lt;/code&gt; pueden contener medios para cada dimensi&amp;oacute;n de &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37d953297aa88c0f3bc07a3115b3b34627aebd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;mean&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;itr&lt;/code&gt; es un &lt;code&gt;AbstractArray&lt;/code&gt; , &lt;code&gt;dims&lt;/code&gt; se pueden proporcionar para calcular la varianza sobre las dimensiones, y &lt;code&gt;mean&lt;/code&gt; puede contener medios para cada dimensi&amp;oacute;n de &lt;code&gt;itr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="990c04cdd5ec49c07722688547969ed041fe0726" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c42d84f4d44608418a9c06e641987a8cc6e81e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions. In that case, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5a74c045541a90c529fb0859ca2583588298de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range (a &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt;&lt;code&gt;LinRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Si se proporcionan la &lt;code&gt;length&lt;/code&gt; y la &lt;code&gt;stop&lt;/code&gt; y el &lt;code&gt;step&lt;/code&gt; no, el tama&amp;ntilde;o del paso se calcular&amp;aacute; autom&amp;aacute;ticamente de manera que haya elementos espaciados linealmente de &lt;code&gt;length&lt;/code&gt; en el rango (un &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt; &lt;code&gt;LinRange&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a704a76b38109c4ddf6a00329dc6ebcf8c7f4fac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d6d1b8a88beec41cb040befac543132aff1625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;overlap=true&lt;/code&gt;, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0677161ec30784ce49b4b8aeda531d688c559665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pids&lt;/code&gt; is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, &lt;code&gt;localindices&lt;/code&gt; and &lt;code&gt;indexpids&lt;/code&gt; will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.</source>
          <target state="translated">Si &lt;code&gt;pids&lt;/code&gt; se especifica pids , la matriz compartida se mapear&amp;aacute; en todos los procesos del host actual, incluido el maestro. Pero, los &lt;code&gt;localindices&lt;/code&gt; y los &lt;code&gt;indexpids&lt;/code&gt; solo se referir&amp;aacute;n a procesos de trabajo. Esto facilita el c&amp;oacute;digo de distribuci&amp;oacute;n del trabajo para usar trabajadores para el c&amp;aacute;lculo real con el proceso maestro actuando como un controlador.</target>
        </trans-unit>
        <trans-unit id="39265b02d633cf948cee760fccd02e8e4c595e22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;quotes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, columns enclosed within double-quote (&quot;) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote. Specifying &lt;code&gt;dims&lt;/code&gt; as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files. If &lt;code&gt;comments&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lines beginning with &lt;code&gt;comment_char&lt;/code&gt; and text following &lt;code&gt;comment_char&lt;/code&gt; in any line are ignored.</source>
          <target state="translated">Si las &lt;code&gt;quotes&lt;/code&gt; son &lt;code&gt;true&lt;/code&gt; , las columnas encerradas entre comillas dobles (&quot;) pueden contener nuevas l&amp;iacute;neas y delimitadores de columna. Los caracteres de comillas dobles dentro de un campo entre comillas deben escaparse con otra comilla doble. Especificar &lt;code&gt;dims&lt;/code&gt; como una tupla de lo esperado las filas y columnas (incluido el encabezado, si lo hay) pueden acelerar la lectura de archivos grandes. Si los &lt;code&gt;comments&lt;/code&gt; son &lt;code&gt;true&lt;/code&gt; , las l&amp;iacute;neas que comienzan con &lt;code&gt;comment_char&lt;/code&gt; y el texto que sigue a &lt;code&gt;comment_char&lt;/code&gt; en cualquier l&amp;iacute;nea se ignoran.</target>
        </trans-unit>
        <trans-unit id="072d5e68fa14ef444211e0638bdf60961c940d9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reuseaddr=true&lt;/code&gt;, multiple threads or processes can bind to the same address without error if they all set &lt;code&gt;reuseaddr=true&lt;/code&gt;, but only the last to bind will receive any traffic.</source>
          <target state="translated">Si &lt;code&gt;reuseaddr=true&lt;/code&gt; , varios subprocesos o procesos pueden vincularse a la misma direcci&amp;oacute;n sin error si todos establecen &lt;code&gt;reuseaddr=true&lt;/code&gt; , pero solo el &amp;uacute;ltimo en vincularse recibir&amp;aacute; tr&amp;aacute;fico.</target>
        </trans-unit>
        <trans-unit id="88b9f6afde6b8b83ebdb2719c69ddd36ee622e38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rng&lt;/code&gt; is not specified, it defaults to seeding the state of the shared thread-local generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd9d0433c4fe181d962946c85904ec68a57d1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rook&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, rook pivoting is used. If &lt;code&gt;rook&lt;/code&gt; is false, rook pivoting is not used.</source>
          <target state="translated">Si la &lt;code&gt;rook&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , se usa el pivote de torre. Si la &lt;code&gt;rook&lt;/code&gt; es falsa, no se usa el pivote de torre.</target>
        </trans-unit>
        <trans-unit id="3686d47af71436aa8068aa094e6acfdb577abbc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipblanks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, blank lines in the input will be ignored.</source>
          <target state="translated">Si &lt;code&gt;skipblanks&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , se ignorar&amp;aacute;n las l&amp;iacute;neas en blanco en la entrada.</target>
        </trans-unit>
        <trans-unit id="01862aa97c770501d33a4692799d52e5b5e3dee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;spawn = true&lt;/code&gt;, the Task created for &lt;code&gt;func&lt;/code&gt; may be scheduled on another thread in parallel, equivalent to creating a task via &lt;a href=&quot;../multi-threading/index#Base.Threads.@spawn&quot;&gt;&lt;code&gt;Threads.@spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a873983f34f90f6f3366d1e91c3b5438a1e6c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced (a &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt;&lt;code&gt;StepRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Si se proporcionan &lt;code&gt;step&lt;/code&gt; y &lt;code&gt;stop&lt;/code&gt; y no la &lt;code&gt;length&lt;/code&gt; , la longitud total del rango se calcular&amp;aacute; autom&amp;aacute;ticamente de manera que los elementos est&amp;eacute;n espaciados por &lt;code&gt;step&lt;/code&gt; (un &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt; &lt;code&gt;StepRange&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a062e99e636224da62916657b0080cc837347ab0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a505616ea56a3e3c587fbb37c2a52b74909df91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;InterruptException&lt;/code&gt; is not thrown by Ctrl-C. Running code upon such event requires &lt;a href=&quot;../base/index#Base.atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt;. This is the default behavior in Julia script run without &lt;code&gt;-i&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a52fdda97e9a9edb8d40a32fdbba7468a954c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is an abstract type, then the method that would be called by &lt;code&gt;invoke&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;types&lt;/code&gt; es un tipo abstracto, se devuelve el m&amp;eacute;todo que se llamar&amp;iacute;a mediante &lt;code&gt;invoke&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99dfe42909a3f5fda34b5da4dc246c9c5fb25583" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, return an array of methods whose types match. If &lt;code&gt;module&lt;/code&gt; is specified, return an array of methods defined in that module. A list of modules can also be specified as an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58b04b4e4485017440ce0c5de7416ee07070fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, returns an array of methods whose types match.</source>
          <target state="translated">Si se especifica &lt;code&gt;types&lt;/code&gt; , devuelve una matriz de m&amp;eacute;todos cuyos tipos coinciden.</target>
        </trans-unit>
        <trans-unit id="b3892fb415986ed95819205d489e6d5bbab6470a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mmap&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the file specified by &lt;code&gt;source&lt;/code&gt; is memory mapped for potential speedups. Default is &lt;code&gt;true&lt;/code&gt; except on Windows. On Windows, you may want to specify &lt;code&gt;true&lt;/code&gt; if the file is large, and is only read once and not written to.</source>
          <target state="translated">Si &lt;code&gt;use_mmap&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el archivo especificado por la &lt;code&gt;source&lt;/code&gt; se mapea en memoria para posibles aceleraciones. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; excepto en Windows. En Windows, es posible que desee especificar &lt;code&gt;true&lt;/code&gt; si el archivo es grande y solo se lee una vez y no se escribe.</target>
        </trans-unit>
        <trans-unit id="5645668108ab9880ec8d6ff07db8800e64be268c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wait&lt;/code&gt; is false, the process runs asynchronously. You can later wait for it and check its exit status by calling &lt;code&gt;success&lt;/code&gt; on the returned process object.</source>
          <target state="translated">Si la &lt;code&gt;wait&lt;/code&gt; es falsa, el proceso se ejecuta de forma asincr&amp;oacute;nica. Luego puede esperarlo y verificar su estado de salida llamando a &lt;code&gt;success&lt;/code&gt; en el objeto de proceso devuelto.</target>
        </trans-unit>
        <trans-unit id="4328d82bb88eefa0e600962ab951d3053ce804f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a number, this is essentially the same as &lt;code&gt;one(x)/x&lt;/code&gt;, but for some types &lt;code&gt;inv(x)&lt;/code&gt; may be slightly more efficient.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un n&amp;uacute;mero, esto es esencialmente lo mismo que &lt;code&gt;one(x)/x&lt;/code&gt; , pero para algunos tipos &lt;code&gt;inv(x)&lt;/code&gt; puede ser un poco m&amp;aacute;s eficiente.</target>
        </trans-unit>
        <trans-unit id="5d6e97018433ee560ec26ad905f78e6763128a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a type, return a &quot;larger&quot; type, defined so that arithmetic operations &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are guaranteed not to overflow nor lose precision for any combination of values that type &lt;code&gt;x&lt;/code&gt; can hold.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un tipo, devuelve un tipo &quot;m&amp;aacute;s grande&quot;, definido de modo que se garantice que las operaciones aritm&amp;eacute;ticas &lt;code&gt;+&lt;/code&gt; y &lt;code&gt;-&lt;/code&gt; no se desborden ni pierden precisi&amp;oacute;n para cualquier combinaci&amp;oacute;n de valores que el tipo &lt;code&gt;x&lt;/code&gt; pueda contener.</target>
        </trans-unit>
        <trans-unit id="88ba7ee31764ff507d81e94f6a3b385c0be71e42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a value, it is converted to &lt;code&gt;widen(typeof(x))&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es un valor, se convierte a &lt;code&gt;widen(typeof(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a828e6b72bb380836af54de218be15aa9ebea9db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; will return an array filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es una referencia de objeto, todos los elementos se referir&amp;aacute;n al mismo objeto. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; devolver&amp;aacute; una matriz llena con el resultado de evaluar &lt;code&gt;Foo()&lt;/code&gt; una vez.</target>
        </trans-unit>
        <trans-unit id="c793973e3f101c15348a8c798bb0a96d340155d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db317e66581e31b148fb1c68097906f9ec9dcecb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not an &lt;code&gt;AbstractArray&lt;/code&gt; but it supports &lt;code&gt;axes&lt;/code&gt;, indexing, and its type supports &lt;code&gt;ndims&lt;/code&gt;, then &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; may be implemented to just return itself. Further, if &lt;code&gt;x&lt;/code&gt; defines its own &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt;, then it must define its &lt;code&gt;broadcastable&lt;/code&gt; method to return itself for the custom style to have any effect.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; no es un &lt;code&gt;AbstractArray&lt;/code&gt; pero admite &lt;code&gt;axes&lt;/code&gt; , indexaci&amp;oacute;n y su tipo admite &lt;code&gt;ndims&lt;/code&gt; , entonces se puede implementar &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; para que se devuelva a s&amp;iacute; mismo. Adem&amp;aacute;s, si &lt;code&gt;x&lt;/code&gt; define su propio &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt; , entonces debe definir su m&amp;eacute;todo de &lt;code&gt;broadcastable&lt;/code&gt; para que se devuelva a s&amp;iacute; mismo para que el estilo personalizado tenga alg&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="ead093ec45b992f54a438f256340d7b0a0ef7df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; supports iteration, the returned value should have the same &lt;code&gt;axes&lt;/code&gt; and indexing behaviors as &lt;code&gt;collect(x)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; admite la iteraci&amp;oacute;n, el valor devuelto debe tener los mismos &lt;code&gt;axes&lt;/code&gt; y comportamientos de indexaci&amp;oacute;n que &lt;code&gt;collect(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9eb6d4efdb2a84932dc930c8197ad4f7fad62394" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt; literal (e.g. &lt;code&gt;2&lt;/code&gt; in &lt;code&gt;x^2&lt;/code&gt; or &lt;code&gt;-3&lt;/code&gt; in &lt;code&gt;x^-3&lt;/code&gt;), the Julia code &lt;code&gt;x^y&lt;/code&gt; is transformed by the compiler to &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt;, to enable compile-time specialization on the value of the exponent. (As a default fallback we have &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt;, where usually &lt;code&gt;^ == Base.^&lt;/code&gt; unless &lt;code&gt;^&lt;/code&gt; has been defined in the calling namespace.)</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es un literal &lt;code&gt;Int&lt;/code&gt; (por ejemplo, &lt;code&gt;2&lt;/code&gt; en &lt;code&gt;x^2&lt;/code&gt; o &lt;code&gt;-3&lt;/code&gt; en &lt;code&gt;x^-3&lt;/code&gt; ), el compilador transforma el c&amp;oacute;digo de Julia &lt;code&gt;x^y&lt;/code&gt; en &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt; , para habilitar la especializaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n en el valor del exponente. (Como alternativa predeterminada tenemos &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt; , donde normalmente &lt;code&gt;^ == Base.^&lt;/code&gt; menos que &lt;code&gt;^&lt;/code&gt; se haya definido en el espacio de nombres de la llamada).</target>
        </trans-unit>
        <trans-unit id="4030642b9b0fac77c474cfa27dc2012de7dca7c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;yes&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (&quot;denormals&quot;). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;yes==true&lt;/code&gt; but the hardware does not support zeroing of subnormal numbers.</source>
          <target state="translated">Si &lt;code&gt;yes&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , las operaciones de coma flotante subsiguientes siguen las reglas de la aritm&amp;eacute;tica IEEE sobre valores subnormales (&quot;desnormales&quot;). De lo contrario, las operaciones de coma flotante est&amp;aacute;n permitidas (pero no son obligatorias) para convertir las entradas o salidas subnormales a cero. Devuelve &lt;code&gt;true&lt;/code&gt; menos que &lt;code&gt;yes==true&lt;/code&gt; pero el hardware no admite la puesta a cero de n&amp;uacute;meros subnormales.</target>
        </trans-unit>
        <trans-unit id="4fe82c65bb97ee33e80659528026f81237a00185" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as &lt;code&gt;&amp;lt;-...&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">Si Julia eran un lenguaje que hace un uso m&amp;aacute;s liberal de los caracteres ASCII, el operador sorber podr&amp;iacute;a haber sido escrito como &lt;code&gt;&amp;lt;-...&lt;/code&gt; en lugar de &lt;code&gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c31aabb66505776aad35d90bd36db4dbf2d1b9d" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as &lt;code&gt;...-&amp;gt;&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">Si Julia eran un lenguaje que hace un uso m&amp;aacute;s liberal de los caracteres ASCII, el operador splatting podr&amp;iacute;a haber sido escrito como &lt;code&gt;...-&amp;gt;&lt;/code&gt; en lugar de &lt;code&gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60a92e91dcf7c91c0849e69c5ad346e21b345fcf" translate="yes" xml:space="preserve">
          <source>If [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vu&lt;/code&gt;] does not contain all eigenvalues of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">Si [ &lt;code&gt;vl&lt;/code&gt; , &lt;code&gt;vu&lt;/code&gt; ] no contiene todos los valores propios de &lt;code&gt;A&lt;/code&gt; , entonces la factorizaci&amp;oacute;n devuelta ser&amp;aacute; una factorizaci&amp;oacute;n &lt;em&gt;truncada&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="730dc1af168d94eefd1482151f83529bc44df580" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is empty, readers (on a &lt;code&gt;take!&lt;/code&gt; call) will block until data is available.</source>
          <target state="translated">Si un &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; est&amp;aacute; vac&amp;iacute;o, los lectores (en una llamada &lt;code&gt;take!&lt;/code&gt; ) Se bloquear&amp;aacute;n hasta que haya datos disponibles.</target>
        </trans-unit>
        <trans-unit id="84662f0c325b992dd59906d92d27342a4c4aeef8" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is full, writers (on a &lt;code&gt;put!&lt;/code&gt; call) will block until space becomes available.</source>
          <target state="translated">Si un &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; est&amp;aacute; lleno, los escritores (en una llamada &lt;code&gt;put!&lt;/code&gt; ) Se bloquear&amp;aacute;n hasta que haya espacio disponible.</target>
        </trans-unit>
        <trans-unit id="800a9b7d396fd78b7b6ed22445dc02985ff5d965" translate="yes" xml:space="preserve">
          <source>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of &lt;code&gt;VecElement&lt;/code&gt; that naturally maps to the SIMD type. Specifically:</source>
          <target state="translated">Si una rutina C / C ++ tiene un argumento o valor de retorno que es un tipo SIMD nativo, el tipo Julia correspondiente es una tupla homog&amp;eacute;nea de &lt;code&gt;VecElement&lt;/code&gt; que se asigna naturalmente al tipo SIMD. Espec&amp;iacute;ficamente:</target>
        </trans-unit>
        <trans-unit id="c33b9c9ad9c6bea2ac47b4bed7df57b3ce4b628b" translate="yes" xml:space="preserve">
          <source>If a Julia function returns an array, the return value of &lt;code&gt;jl_eval_string&lt;/code&gt; and &lt;code&gt;jl_call&lt;/code&gt; can be cast to a &lt;code&gt;jl_array_t*&lt;/code&gt;:</source>
          <target state="translated">Si una funci&amp;oacute;n de Julia devuelve una matriz, el valor de retorno de &lt;code&gt;jl_eval_string&lt;/code&gt; y &lt;code&gt;jl_call&lt;/code&gt; se puede convertir en un &lt;code&gt;jl_array_t*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da26aec502d267a61bc582bb3d104bf1101787e9" translate="yes" xml:space="preserve">
          <source>If a composite type is declared with &lt;code&gt;mutable struct&lt;/code&gt; instead of &lt;code&gt;struct&lt;/code&gt;, then instances of it can be modified:</source>
          <target state="translated">Si un tipo compuesto se declara con una &lt;code&gt;mutable struct&lt;/code&gt; lugar de una &lt;code&gt;struct&lt;/code&gt; , se pueden modificar instancias de &amp;eacute;l:</target>
        </trans-unit>
        <trans-unit id="4c7983e304a903c4c76a6412696125933d637b1a" translate="yes" xml:space="preserve">
          <source>If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.</source>
          <target state="translated">Si el nombre de una función requiere varias palabras,considere si podría representar más de un concepto y sería mejor dividirlo en partes.</target>
        </trans-unit>
        <trans-unit id="38936f146450cf1d3ca2236e47484dcaa49c5476" translate="yes" xml:space="preserve">
          <source>If a keyword argument is not assigned a default value in the method definition, then it is &lt;em&gt;required&lt;/em&gt;: an &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt;&lt;code&gt;UndefKeywordError&lt;/code&gt;&lt;/a&gt; exception will be thrown if the caller does not assign it a value:</source>
          <target state="translated">Si a un argumento de palabra clave no se le asigna un valor predeterminado en la definici&amp;oacute;n del m&amp;eacute;todo, entonces es &lt;em&gt;necesario&lt;/em&gt; : se &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt; &lt;code&gt;UndefKeywordError&lt;/code&gt; &lt;/a&gt; una excepci&amp;oacute;n UndefKeywordError si la persona que llama no le asigna un valor:</target>
        </trans-unit>
        <trans-unit id="605fe15674b1485baef4edc3c0b585f43273c96f" translate="yes" xml:space="preserve">
          <source>If a name is qualified (e.g. &lt;code&gt;Base.sin&lt;/code&gt;), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, &lt;code&gt;Base.+&lt;/code&gt; for example, you must use &lt;code&gt;Base.:+&lt;/code&gt; to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: &lt;code&gt;Base.:(==)&lt;/code&gt;.</source>
          <target state="translated">Si un nombre est&amp;aacute; calificado (por ejemplo, &lt;code&gt;Base.sin&lt;/code&gt; ), se puede acceder a &amp;eacute;l incluso si no se exporta. Esto suele ser &amp;uacute;til al depurar. Tambi&amp;eacute;n se le pueden agregar m&amp;eacute;todos utilizando el nombre calificado como el nombre de la funci&amp;oacute;n. Sin embargo, debido a las ambig&amp;uuml;edades sint&amp;aacute;cticas que surgen, si desea agregar m&amp;eacute;todos a una funci&amp;oacute;n en un m&amp;oacute;dulo diferente cuyo nombre contiene solo s&amp;iacute;mbolos, como un operador, &lt;code&gt;Base.+&lt;/code&gt; Por ejemplo, debe usar &lt;code&gt;Base.:+&lt;/code&gt; para referirse a &amp;eacute;l . Si el operador tiene m&amp;aacute;s de un car&amp;aacute;cter de longitud, debe rodearlo entre par&amp;eacute;ntesis, como: &lt;code&gt;Base.:(==)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906babc709733bae3d983752e96904e9364b6d02" translate="yes" xml:space="preserve">
          <source>If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the manner in which this rounding is done can be changed if required according to the rounding modes presented in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;.</source>
          <target state="translated">Si un n&amp;uacute;mero no tiene una representaci&amp;oacute;n exacta de punto flotante, debe redondearse a un valor representable apropiado. Sin embargo, la forma en que se realiza este redondeo se puede cambiar si es necesario de acuerdo con los modos de redondeo presentados en el &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;est&amp;aacute;ndar IEEE 754&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6c6ec423ec9e7ccad324608060715dc6c4297ac" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has a project file, then the graph entry for its UUID is the &lt;code&gt;[deps]&lt;/code&gt; map of the project file, which is considered to be empty if the section is absent.</source>
          <target state="translated">Si un subdirectorio de paquete tiene un archivo de proyecto, entonces la entrada del gr&amp;aacute;fico para su UUID es el mapa &lt;code&gt;[deps]&lt;/code&gt; del archivo de proyecto, que se considera vac&amp;iacute;o si la secci&amp;oacute;n est&amp;aacute; ausente.</target>
        </trans-unit>
        <trans-unit id="b858ef46784b4025474ecb1ef203d57b534b42bf" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.</source>
          <target state="translated">Si un subdirectorio de un paquete no tiene un archivo de proyecto,entonces se omite en el gráfico y las declaraciones de importación en su código se tratan como de nivel superior,al igual que el proyecto principal y REPL.</target>
        </trans-unit>
        <trans-unit id="2f45dbf01a0d76d1b423a11e7134b517f4cc2734" translate="yes" xml:space="preserve">
          <source>If a regular expression does match, the value returned by &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;RegexMatch&lt;/code&gt; object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:</source>
          <target state="translated">Si una expresi&amp;oacute;n regular coincide, el valor devuelto por la &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt; es un objeto &lt;code&gt;RegexMatch&lt;/code&gt; . Estos objetos registran c&amp;oacute;mo coincide la expresi&amp;oacute;n, incluida la subcadena con la que coincide el patr&amp;oacute;n y las subcadenas capturadas, si las hay. Este ejemplo solo captura la parte de la subcadena que coincide, pero quiz&amp;aacute;s queramos capturar cualquier texto que no est&amp;eacute; en blanco despu&amp;eacute;s del car&amp;aacute;cter de comentario. Podr&amp;iacute;amos hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="5e6085fa6af3d4081b0dc16abe2813cbe1633ab2" translate="yes" xml:space="preserve">
          <source>If a second argument &lt;code&gt;val&lt;/code&gt; is provided, it will be passed to the task (via the return value of &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;) when it runs again. If &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the value is raised as an exception in the woken task.</source>
          <target state="translated">Si se proporciona un segundo argumento &lt;code&gt;val&lt;/code&gt; , se pasar&amp;aacute; a la tarea (a trav&amp;eacute;s del valor de retorno de &lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; ) cuando se vuelva a ejecutar. Si el &lt;code&gt;error&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el valor se eleva como una excepci&amp;oacute;n en la tarea activada.</target>
        </trans-unit>
        <trans-unit id="731b72f6b2ff317794a532fdec183702202f0468" translate="yes" xml:space="preserve">
          <source>If a subtype is used to represent values that may occasionally be rational (e.g. a square-root type that represents &lt;code&gt;&amp;radic;n&lt;/code&gt; for integers &lt;code&gt;n&lt;/code&gt; will give a rational result when &lt;code&gt;n&lt;/code&gt; is a perfect square), then it should also implement &lt;code&gt;isinteger&lt;/code&gt;, &lt;code&gt;iszero&lt;/code&gt;, &lt;code&gt;isone&lt;/code&gt;, and &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;Real&lt;/code&gt; values (since all of these default to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;AbstractIrrational&lt;/code&gt; types), as well as defining &lt;a href=&quot;../base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; to equal that of the corresponding &lt;code&gt;Rational&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad86ee27c201caed09e850508017b392f709911" translate="yes" xml:space="preserve">
          <source>If a test fails consistently it can be changed to use the &lt;code&gt;@test_broken&lt;/code&gt; macro. This will denote the test as &lt;code&gt;Broken&lt;/code&gt; if the test continues to fail and alerts the user via an &lt;code&gt;Error&lt;/code&gt; if the test succeeds.</source>
          <target state="translated">Si una prueba falla constantemente, se puede cambiar para usar la macro &lt;code&gt;@test_broken&lt;/code&gt; . Esto indicar&amp;aacute; que la prueba est&amp;aacute; &lt;code&gt;Broken&lt;/code&gt; si la prueba contin&amp;uacute;a fallando y alerta al usuario mediante un &lt;code&gt;Error&lt;/code&gt; si la prueba tiene &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="f4acf383897e60ec242acf14416a5081e1af3573" translate="yes" xml:space="preserve">
          <source>If a tuple of keyword argument names &lt;code&gt;kwnames&lt;/code&gt; is provided, this also checks whether the method of &lt;code&gt;f&lt;/code&gt; matching &lt;code&gt;t&lt;/code&gt; has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with &lt;code&gt;kwargs...&lt;/code&gt;, any names given in &lt;code&gt;kwnames&lt;/code&gt; are considered valid. Otherwise the provided names must be a subset of the method's keyword arguments.</source>
          <target state="translated">Si se proporciona una tupla de nombres de argumentos de palabras clave &lt;code&gt;kwnames&lt;/code&gt; , esto tambi&amp;eacute;n verifica si el m&amp;eacute;todo de &lt;code&gt;f&lt;/code&gt; que coincide con &lt;code&gt;t&lt;/code&gt; tiene los nombres de argumentos de palabras clave dados. Si el m&amp;eacute;todo de coincidencia acepta un n&amp;uacute;mero variable de argumentos de palabra clave, por ejemplo, con &lt;code&gt;kwargs...&lt;/code&gt; , cualquier nombre dado en &lt;code&gt;kwnames&lt;/code&gt; se considera v&amp;aacute;lido. De lo contrario, los nombres proporcionados deben ser un subconjunto de los argumentos de palabras clave del m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="abfdad8cad5f7ab5488ad45c94b34a153640fd97" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df6568badc4d30be904f3a616a563af8fd77a0a" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="translated">Si un tipo se define como un subtipo de &lt;code&gt;AbstractArray&lt;/code&gt; , hereda un conjunto muy grande de comportamientos enriquecidos que incluyen iteraci&amp;oacute;n e indexaci&amp;oacute;n multidimensional construida sobre el acceso de un solo elemento. Consulte la &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;p&amp;aacute;gina del manual de matrices&lt;/a&gt; y la &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;secci&amp;oacute;n Julia Base&lt;/a&gt; para obtener m&amp;aacute;s m&amp;eacute;todos compatibles.</target>
        </trans-unit>
        <trans-unit id="72a8103071abaea7ac2a617ea71042865eddd171" translate="yes" xml:space="preserve">
          <source>If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the &quot;values&quot; as subtypes.</source>
          <target state="translated">Si un tipo es efectivamente una enumeración,debe definirse como un tipo único (idealmente una estructura inmutable o primitiva),siendo los valores de la enumeración ejemplos de ello.Los constructores y los convertidores pueden comprobar si los valores son válidos.Se prefiere este diseño a hacer de la enumeración un tipo abstracto,con los &quot;valores&quot; como subtipos.</target>
        </trans-unit>
        <trans-unit id="22206d1a9cff4ea1aad87ee3f387a4a25003f12d" translate="yes" xml:space="preserve">
          <source>If a user is presented with a credential prompt they can abort the prompt by typing &lt;code&gt;^D&lt;/code&gt; (pressing the control key together with the &lt;code&gt;d&lt;/code&gt; key).</source>
          <target state="translated">Si a un usuario se le presenta una solicitud de credencial, puede cancelar la solicitud escribiendo &lt;code&gt;^D&lt;/code&gt; (presionando la tecla de control junto con la tecla &lt;code&gt;d&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ebb7b0aa6b2c808bffa6df77883dc4cf4f4f7ece" translate="yes" xml:space="preserve">
          <source>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</source>
          <target state="translated">Si no se especifica un grupo de trabajadores,se utilizan todos los trabajadores disponibles,es decir,el grupo de trabajadores por defecto.</target>
        </trans-unit>
        <trans-unit id="ec5bfd99caef655cee76ea6c587f7690d264c4bb" translate="yes" xml:space="preserve">
          <source>If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">Si todos los datos son numéricos,el resultado será una matriz numérica.Si algunos elementos no pueden analizarse como números,se obtiene una matriz heterogénea de números y cadenas.</target>
        </trans-unit>
        <trans-unit id="9ac5a121e4737af42e151921b98260446a6d1fe7" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are integers, then the value in location &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value of &lt;code&gt;X&lt;/code&gt;, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;ing to the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; if necessary.</source>
          <target state="translated">Si todos los &amp;iacute;ndices &lt;code&gt;I_k&lt;/code&gt; son enteros, entonces el valor en la ubicaci&amp;oacute;n &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; de &lt;code&gt;A&lt;/code&gt; se sobrescribe con el valor de &lt;code&gt;X&lt;/code&gt; , &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; al &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt; de &lt;code&gt;A&lt;/code&gt; si es necesario.</target>
        </trans-unit>
        <trans-unit id="16c375c96eb496fe31b2274a71fede0f6283f232" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are vectors, for example, then the shape of &lt;code&gt;X&lt;/code&gt; would be &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt;, with location &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; of &lt;code&gt;X&lt;/code&gt; containing the value &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt;.</source>
          <target state="translated">Si todos los &amp;iacute;ndices &lt;code&gt;I_k&lt;/code&gt; son vectores, por ejemplo, entonces la forma de &lt;code&gt;X&lt;/code&gt; ser&amp;iacute;a &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt; , con ubicaci&amp;oacute;n &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; de &lt;code&gt;X&lt;/code&gt; que contiene el valor &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7329bd9dbc66827b90f349500e9813dc3f4dd6b" translate="yes" xml:space="preserve">
          <source>If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.</source>
          <target state="translated">Si todos los argumentos son escalares o matrices de dimensión cero,devuelve un escalar sin envolver.</target>
        </trans-unit>
        <trans-unit id="947c4d2702167c0b010760802f3c8902ac7ef2b7" translate="yes" xml:space="preserve">
          <source>If all the indices are scalars, then the result &lt;code&gt;X&lt;/code&gt; is a single element from the array &lt;code&gt;A&lt;/code&gt;. Otherwise, &lt;code&gt;X&lt;/code&gt; is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</source>
          <target state="translated">Si todos los &amp;iacute;ndices son escalares, entonces el resultado &lt;code&gt;X&lt;/code&gt; es un solo elemento de la matriz &lt;code&gt;A&lt;/code&gt; . De lo contrario, &lt;code&gt;X&lt;/code&gt; es una matriz con el mismo n&amp;uacute;mero de dimensiones que la suma de las dimensionalidades de todos los &amp;iacute;ndices.</target>
        </trans-unit>
        <trans-unit id="3044600e4ff9e45b323c2058f952d5b48a41642d" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="translated">Si todas estas comprobaciones pasan, el mensaje y los pares clave-valor se eval&amp;uacute;an por completo y se pasan al registrador actual mediante la funci&amp;oacute;n &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt; &lt;code&gt;Logging.handle_message&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;handle_message()&lt;/code&gt; puede realizar un filtrado adicional seg&amp;uacute;n sea necesario y mostrar el evento en la pantalla, guardarlo en un archivo, etc.</target>
        </trans-unit>
        <trans-unit id="80169baf9571e6bf174d6f8272d7aa9246651030" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Logging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec4431d05d00195da3b5ef4209465d15c43707c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers.</source>
          <target state="translated">Si se especifica una funci&amp;oacute;n &lt;code&gt;init&lt;/code&gt; del tipo &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; , se llama a todos los trabajadores participantes.</target>
        </trans-unit>
        <trans-unit id="3b65b9c692ce6d8deffe1b518910973b66bdfe66" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function, of signature &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt;, is specified, it is called on all the participating workers. You can specify that each worker runs the &lt;code&gt;init&lt;/code&gt; function on a distinct portion of the array, thereby parallelizing initialization.</source>
          <target state="translated">Si se especifica una funci&amp;oacute;n &lt;code&gt;init&lt;/code&gt; , de firma &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; , se llama a todos los trabajadores participantes. Puede especificar que cada trabajador ejecute la funci&amp;oacute;n &lt;code&gt;init&lt;/code&gt; en una parte distinta de la matriz, paralelizando as&amp;iacute; la inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dcd6328c4dd12bc549abfb594d444224ffd4160c" translate="yes" xml:space="preserve">
          <source>If an array of eltype &lt;code&gt;Ptr{T}&lt;/code&gt; is passed as a &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; argument, &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; will attempt to first make a null-terminated copy of the array with each element replaced by its &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; version. This allows, for example, passing an &lt;code&gt;argv&lt;/code&gt; pointer array of type &lt;code&gt;Vector{String}&lt;/code&gt; to an argument of type &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt;.</source>
          <target state="translated">Si se pasa una matriz de eltype &lt;code&gt;Ptr{T}&lt;/code&gt; como un argumento &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; , &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; intentar&amp;aacute; hacer primero una copia terminada en nulo de la matriz con cada elemento reemplazado por su versi&amp;oacute;n &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; . Esto permite, por ejemplo, pasar una matriz de punteros &lt;code&gt;argv&lt;/code&gt; de tipo &lt;code&gt;Vector{String}&lt;/code&gt; a un argumento de tipo &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa768f627a40c9d0913fe21e857ab82ce9b4abc" translate="yes" xml:space="preserve">
          <source>If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a &lt;code&gt;GitError&lt;/code&gt;. This is roughly equivalent to the following command line statement:</source>
          <target state="translated">Si surge alg&amp;uacute;n conflicto que no pueda resolverse autom&amp;aacute;ticamente, la rebase abortar&amp;aacute;, dejando el repositorio y el &amp;aacute;rbol de trabajo en su estado original, y la funci&amp;oacute;n arrojar&amp;aacute; un &lt;code&gt;GitError&lt;/code&gt; . Esto es aproximadamente equivalente a la siguiente declaraci&amp;oacute;n de l&amp;iacute;nea de comando:</target>
        </trans-unit>
        <trans-unit id="cb2726b6f11cf6d744cc2e0de08cc88e0caae92f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d387af77f5db6a955f974f865de51228d37bd15f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting-1&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="translated">Si cualquier &amp;iacute;ndice &lt;code&gt;I_k&lt;/code&gt; selecciona m&amp;aacute;s de una ubicaci&amp;oacute;n, entonces el lado derecho &lt;code&gt;X&lt;/code&gt; debe ser una matriz con la misma forma que el resultado de indexar &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; o un vector con el mismo n&amp;uacute;mero de elementos . El valor en la ubicaci&amp;oacute;n &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; de &lt;code&gt;A&lt;/code&gt; se sobrescribe con el valor &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt; , convirti&amp;eacute;ndose si es necesario. El operador de asignaci&amp;oacute;n por elementos &lt;code&gt;.=&lt;/code&gt; Puede usarse para &lt;a href=&quot;#Broadcasting-1&quot;&gt;transmitir &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; a trav&amp;eacute;s de las ubicaciones seleccionadas:</target>
        </trans-unit>
        <trans-unit id="a2dae61ea17ea95a5a6582831ba526a24537cb67" translate="yes" xml:space="preserve">
          <source>If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to &lt;code&gt;new&lt;/code&gt;, returning the resulting object:</source>
          <target state="translated">Si se define alg&amp;uacute;n m&amp;eacute;todo de constructor interno, no se proporciona ning&amp;uacute;n m&amp;eacute;todo de constructor predeterminado: se presume que se ha proporcionado todos los constructores internos que necesita. El constructor predeterminado es equivalente a escribir su propio m&amp;eacute;todo de constructor interno que toma todos los campos del objeto como par&amp;aacute;metros (restringidos a ser del tipo correcto, si el campo correspondiente tiene un tipo), y los pasa a &lt;code&gt;new&lt;/code&gt; , devolviendo el objeto resultante:</target>
        </trans-unit>
        <trans-unit id="e9dbb4d7bac298e185fc7fe07e57c374bc123283" translate="yes" xml:space="preserve">
          <source>If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus &lt;code&gt;src/X.jl&lt;/code&gt;; otherwise, there is no path mapping for &lt;code&gt;uuid&lt;/code&gt;. When loading &lt;code&gt;X&lt;/code&gt;, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring &lt;code&gt;X&lt;/code&gt; as a dependency).</source>
          <target state="translated">Si cualquiera de estos resultados tiene &amp;eacute;xito, la ruta al punto de entrada del c&amp;oacute;digo fuente ser&amp;aacute; ese resultado, la ruta relativa desde ese resultado m&amp;aacute;s &lt;code&gt;src/X.jl&lt;/code&gt; ; de lo contrario, no hay mapeo de ruta para &lt;code&gt;uuid&lt;/code&gt; . Al cargar &lt;code&gt;X&lt;/code&gt; , si no se encuentra la ruta del c&amp;oacute;digo fuente, la b&amp;uacute;squeda fallar&amp;aacute; y se le pedir&amp;aacute; al usuario que instale la versi&amp;oacute;n apropiada del paquete o que tome otra acci&amp;oacute;n correctiva (por ejemplo, declarar &lt;code&gt;X&lt;/code&gt; como una dependencia).</target>
        </trans-unit>
        <trans-unit id="4ddf1789b0cb07d74b04fcfdb8b7aef3cf09d72f" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the standard deviation of non-missing values.</source>
          <target state="translated">Si la matriz contiene &lt;code&gt;NaN&lt;/code&gt; o valores &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , el resultado tambi&amp;eacute;n es &lt;code&gt;NaN&lt;/code&gt; o &lt;code&gt;missing&lt;/code&gt; (la &lt;code&gt;missing&lt;/code&gt; tiene prioridad si la matriz contiene ambos). Usar la &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n de omitir &lt;code&gt;missing&lt;/code&gt; entradas y calcular la desviaci&amp;oacute;n est&amp;aacute;ndar de los valores no perdidos.</target>
        </trans-unit>
        <trans-unit id="3a6293b5e98855a8ee42f2bca1bebc73fa339517" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the variance of non-missing values.</source>
          <target state="translated">Si la matriz contiene &lt;code&gt;NaN&lt;/code&gt; o valores &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , el resultado tambi&amp;eacute;n es &lt;code&gt;NaN&lt;/code&gt; o &lt;code&gt;missing&lt;/code&gt; (la &lt;code&gt;missing&lt;/code&gt; tiene prioridad si la matriz contiene ambos). Usar la &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n de omitir &lt;code&gt;missing&lt;/code&gt; entradas y calcular la varianza de los valores no perdidos.</target>
        </trans-unit>
        <trans-unit id="38e45e26639753f801787edbbd58523b34871d79" translate="yes" xml:space="preserve">
          <source>If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.</source>
          <target state="translated">Si al menos un argumento es una tupla y todos los demás son escalares o matrices de dimensión cero,devuelve una tupla.</target>
        </trans-unit>
        <trans-unit id="186a2528019c2b28f2ac036bd36737c001f4c334" translate="yes" xml:space="preserve">
          <source>If called with the optional &lt;code&gt;stream&lt;/code&gt; argument, then returns &lt;code&gt;stream&lt;/code&gt; itself.</source>
          <target state="translated">Si se llama con el argumento de &lt;code&gt;stream&lt;/code&gt; opcional , devuelve el &lt;code&gt;stream&lt;/code&gt; s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="c2dc6a2dba2346f86620a63b3cfed83cd90e27f4" translate="yes" xml:space="preserve">
          <source>If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):</source>
          <target state="translated">Si las variables capturadas se utilizan en una sección del código de rendimiento crítico,entonces los siguientes consejos ayudan a asegurar que su uso sea eficiente.En primer lugar,si se sabe que una variable capturada no cambia de tipo,entonces puede declararse explícitamente con una anotación de tipo (en la variable,no en el lado derecho):</target>
        </trans-unit>
        <trans-unit id="1a5d4d133718a06af974dc91ca305c022dd4e098" translate="yes" xml:space="preserve">
          <source>If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.</source>
          <target state="translated">Si se especifican los tipos de campo,los argumentos se convierten.En caso contrario,los tipos de los argumentos se utilizan directamente.</target>
        </trans-unit>
        <trans-unit id="8f773999b3dbcf00b06936dfadd297798081b077" translate="yes" xml:space="preserve">
          <source>If instead you want to specialize on the destination type &lt;code&gt;DestType&lt;/code&gt; without specializing on &lt;code&gt;DestStyle&lt;/code&gt;, then you should define a method with the following signature:</source>
          <target state="translated">Si, en cambio, desea especializarse en el tipo de destino &lt;code&gt;DestType&lt;/code&gt; sin especializarse en &lt;code&gt;DestStyle&lt;/code&gt; , entonces debe definir un m&amp;eacute;todo con la siguiente firma:</target>
        </trans-unit>
        <trans-unit id="861e841404a73546cfbc58b3413de786fc3740a2" translate="yes" xml:space="preserve">
          <source>If it does not have a project file, it can import any top-level package&amp;mdash;i.e. the same packages that can be loaded in &lt;code&gt;Main&lt;/code&gt; or the REPL.</source>
          <target state="translated">Si no tiene un archivo de proyecto, puede importar cualquier paquete de nivel superior, es decir, los mismos paquetes que se pueden cargar en &lt;code&gt;Main&lt;/code&gt; o REPL.</target>
        </trans-unit>
        <trans-unit id="4cdc37b95e5e03c0daf7e3854e30ae2e06ab2fbd" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry, compute a deterministic hash function of &lt;code&gt;uuid&lt;/code&gt; and &lt;code&gt;git-tree-sha1&lt;/code&gt;&amp;mdash;call it &lt;code&gt;slug&lt;/code&gt;&amp;mdash;and look for a directory named &lt;code&gt;packages/X/$slug&lt;/code&gt; in each directory in the Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; global array. Use the first such directory that exists.</source>
          <target state="translated">Si tiene una entrada &lt;code&gt;git-tree-sha1&lt;/code&gt; , calcule una funci&amp;oacute;n hash determinista de &lt;code&gt;uuid&lt;/code&gt; y &lt;code&gt;git-tree-sha1&lt;/code&gt; ( ll&amp;aacute;melo &lt;code&gt;slug&lt;/code&gt; ) y busque un directorio llamado &lt;code&gt;packages/X/$slug&lt;/code&gt; en cada directorio de la matriz global Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; . Utilice el primer directorio de este tipo que exista.</target>
        </trans-unit>
        <trans-unit id="cd1241924f2c661cd879945fa2b395e0b0c5bf1c" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;path&lt;/code&gt; entry, use that path (relative to the directory containing the manifest file).</source>
          <target state="translated">Si tiene una entrada de &lt;code&gt;path&lt;/code&gt; , use esa ruta (relativa al directorio que contiene el archivo de manifiesto).</target>
        </trans-unit>
        <trans-unit id="ecfbca60e91ee74286b0eaf619c2ce8c59e2470c" translate="yes" xml:space="preserve">
          <source>If it has a project file, it can only import those packages which are identified in the &lt;code&gt;[deps]&lt;/code&gt; section of the project file.</source>
          <target state="translated">Si tiene un archivo de proyecto, solo puede importar aquellos paquetes que est&amp;aacute;n identificados en la secci&amp;oacute;n &lt;code&gt;[deps]&lt;/code&gt; del archivo de proyecto.</target>
        </trans-unit>
        <trans-unit id="d73050aa6cb9e92d8510b86ef26b845581d55552" translate="yes" xml:space="preserve">
          <source>If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global &lt;code&gt;IdDict&lt;/code&gt; that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.</source>
          <target state="translated">Si se requiere mantener el puntero a una variable entre funciones (o bloques de alcance), entonces no es posible usar &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; . En este caso, es necesario crear y mantener una referencia a la variable en el &amp;aacute;mbito global de Julia. Una forma sencilla de lograr esto es utilizar un &lt;code&gt;IdDict&lt;/code&gt; global que contendr&amp;aacute; las referencias, evitando la desasignaci&amp;oacute;n por parte del GC. Sin embargo, este m&amp;eacute;todo solo funcionar&amp;aacute; correctamente con tipos mutables.</target>
        </trans-unit>
        <trans-unit id="473e682023e21d67484bab11333a56f6e24d4e3e" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt;, then counts for the number of calls to &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; and &lt;code&gt;maybe_collect()&lt;/code&gt; are printed.</source>
          <target state="translated">Si es el &lt;code&gt;n&lt;/code&gt; &amp;ordm; vez que &lt;code&gt;jl_gc_collect()&lt;/code&gt; se ha llamado, y &lt;code&gt;n&lt;/code&gt; pertenece a la secuencia aritm&amp;eacute;tica representado por &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt; , entonces no cuenta para el n&amp;uacute;mero de llamadas a &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; y &lt;code&gt;maybe_collect()&lt;/code&gt; se imprimen.</target>
        </trans-unit>
        <trans-unit id="130d982e40fa648e81bf69006602371d8efc3765" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">Si es el &lt;code&gt;n&lt;/code&gt; &amp;ordm; vez que &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; se ha llamado, y &lt;code&gt;n&lt;/code&gt; pertenece a la secuencia aritm&amp;eacute;tica representado por &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt; , a continuaci&amp;oacute;n, la recolecci&amp;oacute;n de basura es forzada.</target>
        </trans-unit>
        <trans-unit id="40d1d12e4aea313c12b9b3da68ad08e9a0d521e5" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;maybe_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">Si es el &lt;code&gt;n&lt;/code&gt; &amp;ordm; vez que &lt;code&gt;maybe_collect()&lt;/code&gt; se ha llamado, y &lt;code&gt;n&lt;/code&gt; pertenece a la secuencia aritm&amp;eacute;tica representado por &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt; , a continuaci&amp;oacute;n, la recolecci&amp;oacute;n de basura es forzada.</target>
        </trans-unit>
        <trans-unit id="74f9655f12c7f5e7ed84cb6e935e104ba2688d1a" translate="yes" xml:space="preserve">
          <source>If keyword &lt;code&gt;supertypes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, also return arguments with a parent type of &lt;code&gt;typ&lt;/code&gt;, excluding type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">Si los &lt;code&gt;supertypes&lt;/code&gt; palabras clave son &lt;code&gt;true&lt;/code&gt; , tambi&amp;eacute;n devuelve argumentos con un tipo principal de &lt;code&gt;typ&lt;/code&gt; , excluyendo el tipo &lt;code&gt;Any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc696527340f0e0e085e98638a1e2d12825b4024" translate="yes" xml:space="preserve">
          <source>If memory usage is your concern, you can always replace objects with ones that consume less memory. For example, if &lt;code&gt;A&lt;/code&gt; is a gigabyte-sized array that you no longer need, you can free the memory with &lt;code&gt;A = nothing&lt;/code&gt;. The memory will be released the next time the garbage collector runs; you can force this to happen with &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt;&lt;code&gt;gc()&lt;/code&gt;&lt;/a&gt;. Moreover, an attempt to use &lt;code&gt;A&lt;/code&gt; will likely result in an error, because most methods are not defined on type &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">Si el uso de la memoria es lo que le preocupa, siempre puede reemplazar los objetos por otros que consuman menos memoria. Por ejemplo, si &lt;code&gt;A&lt;/code&gt; es una matriz del tama&amp;ntilde;o de un gigabyte que ya no necesita, puede liberar la memoria con &lt;code&gt;A = nothing&lt;/code&gt; . La memoria se liberar&amp;aacute; la pr&amp;oacute;xima vez que se ejecute el recolector de basura; puede forzar que esto suceda con &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt; &lt;code&gt;gc()&lt;/code&gt; &lt;/a&gt; . Adem&amp;aacute;s, un intento de usar &lt;code&gt;A&lt;/code&gt; probablemente resultar&amp;aacute; en un error, porque la mayor&amp;iacute;a de los m&amp;eacute;todos no est&amp;aacute;n definidos en el tipo &lt;code&gt;Nothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d311a5ead70c39f70d69a25fb13adf9b0a2959d" translate="yes" xml:space="preserve">
          <source>If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the &quot;cost&quot; of a given line&amp;ndash;or really, the cost of the sequence of function calls up to and including this line&amp;ndash;is proportional to how often it appears in the set of all backtraces.</source>
          <target state="translated">Si dedica gran parte de su tiempo de ejecuci&amp;oacute;n a ejecutar una l&amp;iacute;nea de c&amp;oacute;digo en particular, esta l&amp;iacute;nea se mostrar&amp;aacute; con frecuencia en el conjunto de todas las trazas. En otras palabras, el &quot;costo&quot; de una l&amp;iacute;nea determinada, o en realidad, el costo de la secuencia de llamadas a funciones hasta esta l&amp;iacute;nea inclusive, es proporcional a la frecuencia con la que aparece en el conjunto de todos los trazos retroactivos.</target>
        </trans-unit>
        <trans-unit id="99791a8f1a9660eaeaa9f5b9e831b943f3ed9006" translate="yes" xml:space="preserve">
          <source>If needed, the sorting algorithm can be chosen:</source>
          <target state="translated">Si es necesario,se puede elegir el algoritmo de clasificación:</target>
        </trans-unit>
        <trans-unit id="4223679e9c9b3c609f6bfb56a1e1db206adba7ec" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;type&lt;/code&gt; argument is specified, the default is &lt;code&gt;Vector{UInt8}&lt;/code&gt;.</source>
          <target state="translated">Si no se especifica ning&amp;uacute;n argumento de &lt;code&gt;type&lt;/code&gt; , el valor predeterminado es &lt;code&gt;Vector{UInt8}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfa8e1861fd13b4e706313c90dcab6ea83fe0c35" translate="yes" xml:space="preserve">
          <source>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to &lt;a href=&quot;#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si no se pasa ning&amp;uacute;n argumento, la tarea se bloquea durante un per&amp;iacute;odo indefinido. Una tarea solo se puede reiniciar mediante una llamada expl&amp;iacute;cita a &lt;a href=&quot;#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa0a9f892d2c7e314c83b4254ca8ced8f31ecd25" translate="yes" xml:space="preserve">
          <source>If no custom testset type is given it defaults to creating a &lt;code&gt;DefaultTestSet&lt;/code&gt;. &lt;code&gt;DefaultTestSet&lt;/code&gt; records all the results and, if there are any &lt;code&gt;Fail&lt;/code&gt;s or &lt;code&gt;Error&lt;/code&gt;s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</source>
          <target state="translated">Si no se proporciona un tipo de conjunto de pruebas personalizado, el valor predeterminado es crear un &lt;code&gt;DefaultTestSet&lt;/code&gt; . &lt;code&gt;DefaultTestSet&lt;/code&gt; registra todos los resultados y, si hay alguna &lt;code&gt;Fail&lt;/code&gt; o &lt;code&gt;Error&lt;/code&gt; , lanza una excepci&amp;oacute;n al final del conjunto de prueba de nivel superior (no anidado), junto con un resumen de los resultados de la prueba.</target>
        </trans-unit>
        <trans-unit id="9b7b804c01f85b077652b971d063a65bcf5b1f8e" translate="yes" xml:space="preserve">
          <source>If one of the editor environment variables is set, but no editor entry matches it, the default editor entry is invoked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0f744d0d8245436d7c2b792319d69a40debe40" translate="yes" xml:space="preserve">
          <source>If possible, &lt;code&gt;one(x)&lt;/code&gt; returns a value of the same type as &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;one(T)&lt;/code&gt; returns a value of type &lt;code&gt;T&lt;/code&gt;. However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless. In that case, &lt;code&gt;one(x)&lt;/code&gt; should return an identity value of the same precision (and shape, for matrices) as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Si es posible, &lt;code&gt;one(x)&lt;/code&gt; devuelve un valor del mismo tipo que &lt;code&gt;x&lt;/code&gt; , y &lt;code&gt;one(T)&lt;/code&gt; devuelve un valor de tipo &lt;code&gt;T&lt;/code&gt; . Sin embargo, este puede no ser el caso para los tipos que representan cantidades dimensionales (por ejemplo, tiempo en d&amp;iacute;as), ya que la identidad multiplicativa debe ser adimensional. En ese caso, &lt;code&gt;one(x)&lt;/code&gt; deber&amp;iacute;a devolver un valor de identidad de la misma precisi&amp;oacute;n (y forma, para matrices) que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe767ad4883ee037996d5cf486b48b4286df5e71" translate="yes" xml:space="preserve">
          <source>If set to a string that starts with the case-insensitive substring &lt;code&gt;&quot;infinite&quot;&lt;/code&gt;, then spinning threads never sleep. Otherwise, &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; is interpreted as an unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.</source>
          <target state="translated">Si se establece en una cadena que comienza con la subcadena &lt;code&gt;&quot;infinite&quot;&lt;/code&gt; que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas , los hilos giratorios nunca duermen. De lo contrario, &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; se interpreta como un entero de 64 bits sin signo ( &lt;code&gt;uint64_t&lt;/code&gt; ) y da, en nanosegundos, la cantidad de tiempo despu&amp;eacute;s del cual los hilos giratorios deben dormir.</target>
        </trans-unit>
        <trans-unit id="20e80c59100f13ca7e73369cbf1cacf7e59c1aa3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then Julia's thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.</source>
          <target state="translated">Si se establece en cualquier valor adem&amp;aacute;s de &lt;code&gt;0&lt;/code&gt; , la pol&amp;iacute;tica de subprocesos de Julia es coherente con la ejecuci&amp;oacute;n en una m&amp;aacute;quina dedicada: el subproceso maestro est&amp;aacute; en el proceso 0 y los subprocesos est&amp;aacute;n afinidos. De lo contrario, Julia permite que el sistema operativo maneje la pol&amp;iacute;tica de subprocesos.</target>
        </trans-unit>
        <trans-unit id="f40c9b9b4bbc428bc99a8f3b50c7542418d6c605" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector never performs &quot;quick sweeps&quot; of memory.</source>
          <target state="translated">Si se establece en cualquier valor que no sea &lt;code&gt;0&lt;/code&gt; , el recolector de basura de Julia nunca realiza &quot;barridos r&amp;aacute;pidos&quot; de memoria.</target>
        </trans-unit>
        <trans-unit id="eb0219b86b58bf1246d63c4e45daa90f20eb81c3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there's a critical error.</source>
          <target state="translated">Si se establece en cualquier valor que no sea &lt;code&gt;0&lt;/code&gt; , el recolector de basura de Julia esperar&amp;aacute; a que se conecte un depurador en lugar de abortar cuando haya un error cr&amp;iacute;tico.</target>
        </trans-unit>
        <trans-unit id="1ba30fe7de8eb6c5eb6e36c3ca16b929b1d23810" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the compiler will create and register an event listener for just-in-time (JIT) profiling.</source>
          <target state="translated">Si se establece en cualquier valor que no sea &lt;code&gt;0&lt;/code&gt; , el compilador crear&amp;aacute; y registrar&amp;aacute; un detector de eventos para la generaci&amp;oacute;n de perfiles Just-In-Time (JIT).</target>
        </trans-unit>
        <trans-unit id="3b0cd4807865348218a8157872f2d19ba8cef0a0" translate="yes" xml:space="preserve">
          <source>If set, then Julia prints detailed information about the cache in the loading process of &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt;&lt;code&gt;Base.require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se establece, Julia imprime informaci&amp;oacute;n detallada sobre el cach&amp;eacute; en el proceso de carga de &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt; &lt;code&gt;Base.require&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31ed13caeaa2adf17adcff6b38e069bb43cc30cf" translate="yes" xml:space="preserve">
          <source>If set, these environment variables take strings that optionally start with the character &lt;code&gt;'r'&lt;/code&gt;, followed by a string interpolation of a colon-separated list of three signed 64-bit integers (&lt;code&gt;int64_t&lt;/code&gt;). This triple of integers &lt;code&gt;a:b:c&lt;/code&gt; represents the arithmetic sequence &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a + b&lt;/code&gt;, &lt;code&gt;a + 2*b&lt;/code&gt;, ... &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Si se establecen, estas variables de entorno toman cadenas que comienzan opcionalmente con el car&amp;aacute;cter &lt;code&gt;'r'&lt;/code&gt; , seguidas de una interpolaci&amp;oacute;n de cadenas de una lista separada por dos puntos de tres enteros de 64 bits con &lt;code&gt;int64_t&lt;/code&gt; ( int64_t ). Este triple de enteros &lt;code&gt;a:b:c&lt;/code&gt; representa la secuencia aritm&amp;eacute;tica &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;a + b&lt;/code&gt; , &lt;code&gt;a + 2*b&lt;/code&gt; , ... &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ec6755ec5d15a629cdab4809712a90cbd8c460" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will have the effect of prepending &lt;code&gt;/foo/bar&lt;/code&gt; to the default depot path. If &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;DEPOT_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">Si la variable de entorno &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; ya est&amp;aacute; configurada, su valor anterior se antepondr&amp;aacute; con &lt;code&gt;/foo/bar&lt;/code&gt; . Por otro lado, si no se establece &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; , entonces se establecer&amp;aacute; en &lt;code&gt;/foo/bar:&lt;/code&gt; lo que tendr&amp;aacute; el efecto de anteponer &lt;code&gt;/foo/bar&lt;/code&gt; a la ruta de dep&amp;oacute;sito predeterminada. Si &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; se establece en la cadena vac&amp;iacute;a, se expande a un &lt;code&gt;DEPOT_PATH&lt;/code&gt; vac&amp;iacute;oformaci&amp;oacute;n. En otras palabras, la cadena vac&amp;iacute;a se interpreta como una matriz de elementos cero, no como una matriz de un elemento de la cadena vac&amp;iacute;a. Este comportamiento se eligi&amp;oacute; para que fuera posible establecer una ruta de dep&amp;oacute;sito vac&amp;iacute;a a trav&amp;eacute;s de la variable de entorno. Si desea que la ruta de almac&amp;eacute;n por defecto, o bien desactivar la variable de entorno o si debe tener un valor, configurarlo para que la cadena &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="951a284bb764079dcd311388a60d7dc6fdec988b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DIR&lt;/code&gt; environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The &lt;code&gt;bin&lt;/code&gt; folder under JULIA_DIR should be on the system PATH.</source>
          <target state="translated">Si la variable de entorno &lt;code&gt;JULIA_DIR&lt;/code&gt; no se ha configurado, agr&amp;eacute;guela mediante el panel Sistema antes de iniciar Visual Studio. La carpeta &lt;code&gt;bin&lt;/code&gt; bajo JULIA_DIR debe estar en la RUTA del sistema.</target>
        </trans-unit>
        <trans-unit id="17b0935fee49a1bcd1eec16c0060a0a58dff07ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will expand to a &lt;code&gt;LOAD_PATH&lt;/code&gt; value of &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. If &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;LOAD_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">Si la variable de entorno &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; ya est&amp;aacute; configurada, su valor anterior se antepondr&amp;aacute; con &lt;code&gt;/foo/bar&lt;/code&gt; . Por otro lado, si no se establece &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; , entonces se establecer&amp;aacute; en &lt;code&gt;/foo/bar:&lt;/code&gt; que se expandir&amp;aacute; a un valor &lt;code&gt;LOAD_PATH&lt;/code&gt; de &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; . Si &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; se establece en la cadena vac&amp;iacute;a, se expande a un &lt;code&gt;LOAD_PATH&lt;/code&gt; vac&amp;iacute;oformaci&amp;oacute;n. En otras palabras, la cadena vac&amp;iacute;a se interpreta como una matriz de elementos cero, no como una matriz de un elemento de la cadena vac&amp;iacute;a. Este comportamiento se eligi&amp;oacute; para que fuera posible establecer una ruta de carga vac&amp;iacute;a a trav&amp;eacute;s de la variable de entorno. Si desea que la ruta de carga por defecto, o bien desactivar la variable de entorno o si debe tener un valor, configurarlo para que la cadena &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31f515fa1981bd1d01e28ffd032994e4003fc1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;digits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">Si se proporciona el argumento de la palabra clave &lt;code&gt;digits&lt;/code&gt; , se redondea al n&amp;uacute;mero especificado de d&amp;iacute;gitos despu&amp;eacute;s del lugar decimal (o antes si es negativo), en la base &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f504c38da450ab2719c1e9cd12d8dd34afd33e92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;optimize&lt;/code&gt; keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the &lt;code&gt;raw&lt;/code&gt; keyword to true. To dump the entire module that encapsulates the function (with declarations), set the &lt;code&gt;dump_module&lt;/code&gt; keyword to true. Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of source (default) or none, to specify the verbosity of code comments.</source>
          <target state="translated">Si la palabra clave &lt;code&gt;optimize&lt;/code&gt; est&amp;aacute; establecida, el c&amp;oacute;digo se mostrar&amp;aacute; antes de las optimizaciones LLVM. Todos los metadatos y llamadas dbg. * Se eliminan del c&amp;oacute;digo de bits impreso. Para el IR completo, establezca la palabra clave sin &lt;code&gt;raw&lt;/code&gt; en verdadero. Para volcar todo el m&amp;oacute;dulo que encapsula la funci&amp;oacute;n (con declaraciones), establezca la palabra clave &lt;code&gt;dump_module&lt;/code&gt; en true. El argumento &lt;code&gt;debuginfo&lt;/code&gt; de la palabra clave puede ser fuente (predeterminado) o ninguno, para especificar la verbosidad de los comentarios del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="383ecf21766e01ab864dfe9bc7ce841c588d3356" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sigdigits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of significant digits, in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">Si se proporciona el argumento de la palabra clave &lt;code&gt;sigdigits&lt;/code&gt; , se redondea al n&amp;uacute;mero especificado de d&amp;iacute;gitos significativos, en la base &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cee1b7494eb88d56f5f87336c27b832a3eac177f" translate="yes" xml:space="preserve">
          <source>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; for the method signature of the wrapper and similarly in the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is also acceptable.</source>
          <target state="translated">Si el contenedor de C nunca espera que el usuario pase punteros a la memoria administrada por Julia, entonces tambi&amp;eacute;n es aceptable usar &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; para la firma del m&amp;eacute;todo del contenedor y de manera similar en &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e69c1bb25c07d7be2be84b2aa57348cae51e4053" translate="yes" xml:space="preserve">
          <source>If the above example source is saved in the file &lt;code&gt;embed_example.c&lt;/code&gt;, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute &lt;code&gt;clang&lt;/code&gt; for &lt;code&gt;gcc&lt;/code&gt;.:</source>
          <target state="translated">Si la fuente de ejemplo anterior est&amp;aacute; guardada en el archivo &lt;code&gt;embed_example.c&lt;/code&gt; , entonces el siguiente comando lo compilar&amp;aacute; en un programa en ejecuci&amp;oacute;n en Linux y Windows (entorno MSYS2), o si est&amp;aacute; en OS / X, entonces sustituya &lt;code&gt;clang&lt;/code&gt; por &lt;code&gt;gcc&lt;/code&gt; .:</target>
        </trans-unit>
        <trans-unit id="9e156941127d94f84d815e5639eaa0e64bcbc457" translate="yes" xml:space="preserve">
          <source>If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching &lt;code&gt;uuid&lt;/code&gt; then:</source>
          <target state="translated">Si lo anterior no es el caso y el archivo del proyecto tiene un archivo de manifiesto correspondiente y el manifiesto contiene un &lt;code&gt;uuid&lt;/code&gt; coincidente de estrofa, entonces:</target>
        </trans-unit>
        <trans-unit id="9f8fd643e0107bc4fc2c8bed2be168d68373f53a" translate="yes" xml:space="preserve">
          <source>If the alias is documented and not the real definition then the docsystem (&lt;code&gt;?&lt;/code&gt; mode) will not return the docstring attached to the alias when the real definition is searched for.</source>
          <target state="translated">Si el alias est&amp;aacute; documentado y no la definici&amp;oacute;n real, entonces el docsystem ( modo &lt;code&gt;?&lt;/code&gt; ) No devolver&amp;aacute; la cadena de documentaci&amp;oacute;n adjunta al alias cuando se busque la definici&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="f3fd8dba5118a65c9f036f4528fd62b5f0cc2628" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;Future&lt;/code&gt; is owned by a different node, this call will block to wait for the answer. It is recommended to wait for &lt;code&gt;rr&lt;/code&gt; in a separate task instead or to use a local &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; as a proxy:</source>
          <target state="translated">Si el argumento &lt;code&gt;Future&lt;/code&gt; es propiedad de un nodo diferente, esta llamada se bloquear&amp;aacute; para esperar la respuesta. En su lugar, se recomienda esperar a &lt;code&gt;rr&lt;/code&gt; en una tarea separada o usar un &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; local como proxy:</target>
        </trans-unit>
        <trans-unit id="a730ef6e1a231827c433cc4447592ea8e3ba9efc" translate="yes" xml:space="preserve">
          <source>If the arguments inside the square brackets are separated by semicolons (&lt;code&gt;;&lt;/code&gt;) or newlines instead of commas, then their contents are &lt;em&gt;vertically concatenated&lt;/em&gt; together instead of the arguments being used as elements themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5145bb0b73803c7679be17ccbd9728f2cf20e73d" translate="yes" xml:space="preserve">
          <source>If the condition could not be evaluated because an exception was thrown, which occurs in this case because &lt;code&gt;length&lt;/code&gt; is not defined for symbols, an &lt;code&gt;Error&lt;/code&gt; object is returned and an exception is thrown:</source>
          <target state="translated">Si la condici&amp;oacute;n no se pudo evaluar porque se lanz&amp;oacute; una excepci&amp;oacute;n, lo que ocurre en este caso porque la &lt;code&gt;length&lt;/code&gt; no est&amp;aacute; definida para los s&amp;iacute;mbolos, se devuelve un objeto &lt;code&gt;Error&lt;/code&gt; y se lanza una excepci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e94faa3d332e304494043498c5a9abf524bed6e4" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is &lt;code&gt;true&lt;/code&gt;, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. Here it is in action:</source>
          <target state="translated">Si la expresi&amp;oacute;n de condici&amp;oacute;n &lt;code&gt;x &amp;lt; y&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces se eval&amp;uacute;a el bloque correspondiente; de lo contrario, se eval&amp;uacute;a la expresi&amp;oacute;n de condici&amp;oacute;n &lt;code&gt;x &amp;gt; y&lt;/code&gt; , y si es &lt;code&gt;true&lt;/code&gt; , se eval&amp;uacute;a el bloque correspondiente; si ninguna expresi&amp;oacute;n es verdadera, se eval&amp;uacute;a el bloque &lt;code&gt;else&lt;/code&gt; . Aqu&amp;iacute; est&amp;aacute; en acci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e00b24f52421478ecff61089fe0cac3ea509a829" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used.</source>
          <target state="translated">Si la expresi&amp;oacute;n de condici&amp;oacute;n &lt;code&gt;x &amp;lt; y&lt;/code&gt; es verdadera, entonces se eval&amp;uacute;a el bloque correspondiente; de lo contrario, se eval&amp;uacute;a la expresi&amp;oacute;n de condici&amp;oacute;n &lt;code&gt;x &amp;gt; y&lt;/code&gt; , y si es verdadera, se eval&amp;uacute;a el bloque correspondiente; si ninguna expresi&amp;oacute;n es verdadera, se eval&amp;uacute;a el bloque &lt;code&gt;else&lt;/code&gt; . Los bloques &lt;code&gt;elseif&lt;/code&gt; y &lt;code&gt;else&lt;/code&gt; son opcionales y se pueden utilizar tantos bloques &lt;code&gt;elseif&lt;/code&gt; como se desee.</target>
        </trans-unit>
        <trans-unit id="03e22d8ef38f6c3785531b2aa7d1787777d83c8c" translate="yes" xml:space="preserve">
          <source>If the condition is false, then a &lt;code&gt;Fail&lt;/code&gt; is returned and an exception is thrown:</source>
          <target state="translated">Si la condici&amp;oacute;n es falsa, se devuelve un &lt;code&gt;Fail&lt;/code&gt; y se lanza una excepci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="6b3bbdbb81ff4f33d7f44d969bf8034d1606bc1e" translate="yes" xml:space="preserve">
          <source>If the condition is true, a &lt;code&gt;Pass&lt;/code&gt; is returned:</source>
          <target state="translated">Si la condici&amp;oacute;n es verdadera, se devuelve un &lt;code&gt;Pass&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cc2105b7ae7cdead96d8521e45a1f5d3d101c4e9" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, the entire ternary operator expression evaluates to the string &lt;code&gt;&quot;less than&quot;&lt;/code&gt; and otherwise it evaluates to the string &lt;code&gt;&quot;not less than&quot;&lt;/code&gt;. The original three-way example requires chaining multiple uses of the ternary operator together:</source>
          <target state="translated">Si la expresi&amp;oacute;n &lt;code&gt;x &amp;lt; y&lt;/code&gt; es verdadera, toda la expresi&amp;oacute;n del operador ternario se eval&amp;uacute;a como la cadena &lt;code&gt;&quot;less than&quot;&lt;/code&gt; y, de lo contrario, se eval&amp;uacute;a como la cadena &lt;code&gt;&quot;not less than&quot;&lt;/code&gt; . El ejemplo original de tres v&amp;iacute;as requiere encadenar m&amp;uacute;ltiples usos del operador ternario juntos:</target>
        </trans-unit>
        <trans-unit id="07cadc79598faa1c956be711a85436f8d736e63e" translate="yes" xml:space="preserve">
          <source>If the file does not exist a new file is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1992d697b66c6b6347599acbdb8e5fdb9a6621c" translate="yes" xml:space="preserve">
          <source>If the first argument is a single integer &lt;code&gt;n&lt;/code&gt;, then all block rows are assumed to have &lt;code&gt;n&lt;/code&gt; block columns.</source>
          <target state="translated">Si el primer argumento es un solo entero &lt;code&gt;n&lt;/code&gt; , entonces se supone que todas las filas de bloque tienen &lt;code&gt;n&lt;/code&gt; columnas de bloque.</target>
        </trans-unit>
        <trans-unit id="87ae95240cbc769b0a9964dbc95f1267c9ef783f" translate="yes" xml:space="preserve">
          <source>If the index vector &lt;code&gt;ix&lt;/code&gt; is initialized with the indices of &lt;code&gt;v&lt;/code&gt; (or a permutation thereof), &lt;code&gt;initialized&lt;/code&gt; should be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c79a9397806971d24321842119edaddb016dad" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Si la entrada contiene valores &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , devuelva &lt;code&gt;missing&lt;/code&gt; si todos los valores no perdidos son &lt;code&gt;false&lt;/code&gt; (o de manera equivalente, si la entrada no contiene ning&amp;uacute;n valor &lt;code&gt;true&lt;/code&gt; ), siguiendo la &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;l&amp;oacute;gica de tres valores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5db00182f423a4757b1d59390942e088eaf24587" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Si la entrada contiene valores &lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , devuelva &lt;code&gt;missing&lt;/code&gt; si todos los valores no perdidos son &lt;code&gt;true&lt;/code&gt; (o de manera equivalente, si la entrada no contiene valores &lt;code&gt;false&lt;/code&gt; ), siguiendo la &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;l&amp;oacute;gica de tres valores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8eeb9c03396e664e28a99fc47d48774045eb6d62" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Si la entrada contiene valores &lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , devuelva &lt;code&gt;missing&lt;/code&gt; si todos los valores no perdidos son &lt;code&gt;false&lt;/code&gt; (o de manera equivalente, si la entrada no contiene ning&amp;uacute;n valor &lt;code&gt;true&lt;/code&gt; ), siguiendo la &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;l&amp;oacute;gica de tres valores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2728419995e95b64eb82cdbd209797e56617a7a2" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">Si la entrada contiene valores &lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; , devuelva &lt;code&gt;missing&lt;/code&gt; si todos los valores no perdidos son &lt;code&gt;true&lt;/code&gt; (o de manera equivalente, si la entrada no contiene valores &lt;code&gt;false&lt;/code&gt; ), siguiendo la &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;l&amp;oacute;gica de tres valores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43376b031124803be76025ed520e15accd07f21d" translate="yes" xml:space="preserve">
          <source>If the julia program needs to access symbols from the main executable, it may be necessary to add &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; linker flag at compile time on Linux in addition to the ones generated by &lt;code&gt;julia-config.jl&lt;/code&gt; described below. This is not necessary when compiling a shared library.</source>
          <target state="translated">Si el programa julia necesita acceder a los s&amp;iacute;mbolos del ejecutable principal, puede ser necesario agregar &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; indicador del enlazador din&amp;aacute;mico de exportaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n en Linux, adem&amp;aacute;s de los generados por &lt;code&gt;julia-config.jl&lt;/code&gt; que se describen a continuaci&amp;oacute;n. Esto no es necesario al compilar una biblioteca compartida.</target>
        </trans-unit>
        <trans-unit id="a36bc8b8e7c85e66ed4f1f189a3aca52b1c00920" translate="yes" xml:space="preserve">
          <source>If the keyword argument &lt;code&gt;parallel&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;peakflops&lt;/code&gt; is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument &lt;code&gt;n&lt;/code&gt; still refers to the size of the problem that is solved on each processor.</source>
          <target state="translated">Si el argumento de la palabra clave &lt;code&gt;parallel&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;peakflops&lt;/code&gt; se ejecuta en paralelo en todos los procesadores de trabajo. Se devuelve la tasa de flop de toda la computadora paralela. Cuando se ejecuta en paralelo, solo se utiliza 1 hilo BLAS. El argumento &lt;code&gt;n&lt;/code&gt; todav&amp;iacute;a se refiere al tama&amp;ntilde;o del problema que se resuelve en cada procesador.</target>
        </trans-unit>
        <trans-unit id="8e60aaeb2ffed3f0c824ded63844d08244a81e67" translate="yes" xml:space="preserve">
          <source>If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.</source>
          <target state="translated">Si el último componente de un camino contiene un punto,divide el camino en todo lo que está antes del punto y todo lo que está incluido y después del punto.En caso contrario,devuelve una tupla del argumento sin modificar y la cadena vacía.</target>
        </trans-unit>
        <trans-unit id="474f41b19a8b8b1c73bfdf0eee429dd261cef652" translate="yes" xml:space="preserve">
          <source>If the library cannot be found, this method throws an error, unless the keyword argument &lt;code&gt;throw_error&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, in which case this method returns &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">Si no se puede encontrar la biblioteca, este m&amp;eacute;todo arroja un error, a menos que el argumento de palabra clave &lt;code&gt;throw_error&lt;/code&gt; est&amp;eacute; establecido en &lt;code&gt;false&lt;/code&gt; , en cuyo caso este m&amp;eacute;todo &lt;code&gt;nothing&lt;/code&gt; devuelve nada .</target>
        </trans-unit>
        <trans-unit id="87fd4485b83cceeff36ce0886165792add3d72c0" translate="yes" xml:space="preserve">
          <source>If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt;. The value of &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; on the master process specifies the number of seconds a newly launched worker waits for connection establishment.</source>
          <target state="translated">Si el proceso maestro no logra establecer una conexi&amp;oacute;n con un trabajador reci&amp;eacute;n iniciado en 60.0 segundos, el trabajador lo trata como una situaci&amp;oacute;n fatal y termina. Este tiempo de espera se puede controlar mediante la variable de entorno &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; . El valor de &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; en el proceso maestro especifica la cantidad de segundos que un trabajador reci&amp;eacute;n lanzado espera para establecer la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1862e9ef97d71a1468775f4ed8202c8fd632c055" translate="yes" xml:space="preserve">
          <source>If the memory is already owned by Julia, or is an &lt;code&gt;isbits&lt;/code&gt; type, and is known to be non-null:</source>
          <target state="translated">Si la memoria ya es propiedad de Julia, o es del tipo &lt;code&gt;isbits&lt;/code&gt; , y se sabe que no es nula:</target>
        </trans-unit>
        <trans-unit id="da0b487002a4f8f988224bf9329d865f41bc0778" translate="yes" xml:space="preserve">
          <source>If the memory is owned by C:</source>
          <target state="translated">Si la memoria es propiedad de C:</target>
        </trans-unit>
        <trans-unit id="f1a7911f936ea8810a1eaa7a8869f8e6799d2d65" translate="yes" xml:space="preserve">
          <source>If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:</source>
          <target state="translated">Si el numerador y el denominador de un racional tienen factores comunes,se reducen a los términos más bajos de manera que el denominador no sea negativo:</target>
        </trans-unit>
        <trans-unit id="0a769d477ab736aacb751c850c5686d3d0e58a61" translate="yes" xml:space="preserve">
          <source>If the optional vector of eigenvalues &lt;code&gt;eigvals&lt;/code&gt; is specified, &lt;code&gt;eigvecs&lt;/code&gt; returns the specific corresponding eigenvectors.</source>
          <target state="translated">Si se especifica el vector opcional de autovalores &lt;code&gt;eigvals&lt;/code&gt; , &lt;code&gt;eigvecs&lt;/code&gt; devuelve los autovectores correspondientes espec&amp;iacute;ficos.</target>
        </trans-unit>
        <trans-unit id="0f4dba4502da69dc32bb858b6da003d9801f45e4" translate="yes" xml:space="preserve">
          <source>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call &lt;code&gt;free(ptr)&lt;/code&gt; when the returned &lt;code&gt;Array&lt;/code&gt; object is finalized. If the &lt;code&gt;own&lt;/code&gt; parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</source>
          <target state="translated">Si el puntero de inter&amp;eacute;s es una matriz de datos simples (tipo primitivo o estructura inmutable), la funci&amp;oacute;n &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; puede ser m&amp;aacute;s &amp;uacute;til. El par&amp;aacute;metro final deber&amp;iacute;a ser verdadero si Julia deber&amp;iacute;a &quot;tomar posesi&amp;oacute;n&quot; del b&amp;uacute;fer subyacente y llamar a &lt;code&gt;free(ptr)&lt;/code&gt; cuando finalice el objeto &lt;code&gt;Array&lt;/code&gt; devuelto . Si el &lt;code&gt;own&lt;/code&gt; par&amp;aacute;metro se omite o es falso, la persona que llama debe asegurarse de que el b&amp;uacute;fer siga existiendo hasta que se complete todo el acceso.</target>
        </trans-unit>
        <trans-unit id="0a512e781dfe335955a62e8e7a271098861da5ec" translate="yes" xml:space="preserve">
          <source>If the project file in the directory matches &lt;code&gt;uuid&lt;/code&gt; and name &lt;code&gt;X&lt;/code&gt;, then either:</source>
          <target state="translated">Si el archivo del proyecto en el directorio coincide con &lt;code&gt;uuid&lt;/code&gt; y el nombre &lt;code&gt;X&lt;/code&gt; , entonces:</target>
        </trans-unit>
        <trans-unit id="bf4eb78a003bcabdcd8e4f19b55a5c4f0ed307f6" translate="yes" xml:space="preserve">
          <source>If the regular expression does not match the given string, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; &amp;ndash; a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</source>
          <target state="translated">Si la expresi&amp;oacute;n regular no coincide con la cadena dada, la &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; devuelve nada , un valor especial que no imprime nada en el indicador interactivo. Aparte de no imprimir, es un valor completamente normal y puede probarlo mediante programaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="ee4c72df00bad1d261a873768e4600ba229c34af" translate="yes" xml:space="preserve">
          <source>If the type were declared &lt;code&gt;mutable&lt;/code&gt;, you could reach in and directly change the field values to violate this invariant. Of course, messing around with an object's internals uninvited is bad practice. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's invariants.</source>
          <target state="translated">Si el tipo se declara &lt;code&gt;mutable&lt;/code&gt; , puede acceder y cambiar directamente los valores del campo para violar este invariante. Por supuesto, jugar con las partes internas de un objeto sin ser invitado es una mala pr&amp;aacute;ctica. Usted (u otra persona) tambi&amp;eacute;n puede proporcionar m&amp;eacute;todos constructores externos adicionales en cualquier momento posterior, pero una vez que se declara un tipo, no hay forma de agregar m&amp;aacute;s m&amp;eacute;todos constructores internos. Dado que los m&amp;eacute;todos de constructor externos solo pueden crear objetos llamando a otros m&amp;eacute;todos de constructor, en &amp;uacute;ltima instancia, se debe llamar a alg&amp;uacute;n constructor interno para crear un objeto. Esto garantiza que todos los objetos del tipo declarado deben existir mediante una llamada a uno de los m&amp;eacute;todos constructores internos proporcionados con el tipo, lo que proporciona cierto grado de aplicaci&amp;oacute;n de los invariantes de un tipo.</target>
        </trans-unit>
        <trans-unit id="01f0d92fa173f69330393a510ea1e6b5d8ca8533" translate="yes" xml:space="preserve">
          <source>If the value of the environment variable begins with the character &lt;code&gt;'r'&lt;/code&gt;, then the interval between garbage collection events is randomized.</source>
          <target state="translated">Si el valor de la variable de entorno comienza con el car&amp;aacute;cter &lt;code&gt;'r'&lt;/code&gt; , entonces el intervalo entre los eventos de recolecci&amp;oacute;n de basura es aleatorio.</target>
        </trans-unit>
        <trans-unit id="820aaeab0441978d6dfdcb42b5456e2d42286bc7" translate="yes" xml:space="preserve">
          <source>If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a &lt;code&gt;RefValue{Any}&lt;/code&gt; before it is pushed to &lt;code&gt;IdDict&lt;/code&gt;. In this approach, the container has to be created or filled in via C code using, for example, the function &lt;code&gt;jl_new_struct&lt;/code&gt;. If the container is created by &lt;code&gt;jl_call*&lt;/code&gt;, then you will need to reload the pointer to be used in C code.</source>
          <target state="translated">Si la variable es inmutable, entonces debe estar envuelta en un contenedor mutable equivalente o, preferiblemente, en un &lt;code&gt;RefValue{Any}&lt;/code&gt; antes de ser empujada a &lt;code&gt;IdDict&lt;/code&gt; . En este enfoque, el contenedor debe crearse o completarse mediante c&amp;oacute;digo C utilizando, por ejemplo, la funci&amp;oacute;n &lt;code&gt;jl_new_struct&lt;/code&gt; . Si el contenedor es creado por &lt;code&gt;jl_call*&lt;/code&gt; , entonces deber&amp;aacute; volver a cargar el puntero para usarlo en c&amp;oacute;digo C.</target>
        </trans-unit>
        <trans-unit id="fdaae9a23c5ac63bef99dbd5a31ebb51593f593b" translate="yes" xml:space="preserve">
          <source>If these default definitions are not wanted, modules can be defined using the keyword &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt; instead (note: &lt;code&gt;Core&lt;/code&gt; is still imported, as per above). In terms of &lt;code&gt;baremodule&lt;/code&gt;, a standard &lt;code&gt;module&lt;/code&gt; looks like this:</source>
          <target state="translated">Si no se desean estas definiciones predeterminadas, los m&amp;oacute;dulos se pueden definir utilizando la palabra clave &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; &lt;/a&gt; en su lugar (nota: &lt;code&gt;Core&lt;/code&gt; todav&amp;iacute;a se importa, como se indic&amp;oacute; anteriormente). En t&amp;eacute;rminos de &lt;code&gt;baremodule&lt;/code&gt; , un &lt;code&gt;module&lt;/code&gt; est&amp;aacute;ndar se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="c97bc8058490cb5b35c86c1a7b0a8b4a5dcbea0d" translate="yes" xml:space="preserve">
          <source>If this example were rewritten to use a &lt;code&gt;for&lt;/code&gt; keyword for each variable, then the output would be different: the second and fourth values would contain &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Si este ejemplo se reescrito para usar una &lt;code&gt;for&lt;/code&gt; palabra clave para cada variable, entonces la salida ser&amp;iacute;a diferente: el segundo y cuarto valores contendr&amp;iacute;an &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38daf5829da47e0525cef7ca98a723264df0b06d" translate="yes" xml:space="preserve">
          <source>If this file refers to a device, the ID of the device it refers to</source>
          <target state="translated">Si este archivo se refiere a un dispositivo,el ID del dispositivo al que se refiere</target>
        </trans-unit>
        <trans-unit id="0d9cafaaf4c7067eb590c8bf606a63edc65e8a80" translate="yes" xml:space="preserve">
          <source>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</source>
          <target state="translated">Si se trata de un bloqueo recursivo que ha sido adquirido antes,disminuya un contador interno y regrese inmediatamente.</target>
        </trans-unit>
        <trans-unit id="63b7f441c98451c302d3c2456a6e97efda6509d1" translate="yes" xml:space="preserve">
          <source>If this is all extremely confusing, try reading &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets&quot;&lt;/a&gt;. It's an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.</source>
          <target state="translated">Si todo esto es extremadamente confuso, intente leer &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;El m&amp;iacute;nimo absoluto que todo desarrollador de software debe conocer absoluta y positivamente sobre Unicode y conjuntos de caracteres&quot;&lt;/a&gt; . Es una excelente introducci&amp;oacute;n a Unicode y UTF-8, y puede ayudar a aliviar cierta confusi&amp;oacute;n sobre el tema.</target>
        </trans-unit>
        <trans-unit id="3b40c130d40171e44a3b89ef397dcc6ac5ad60b6" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;code&gt;rmprocs&lt;/code&gt; will wait until all requested &lt;code&gt;pids&lt;/code&gt; are removed.</source>
          <target state="translated">Si no se especifica, &lt;code&gt;rmprocs&lt;/code&gt; esperar&amp;aacute; hasta que se eliminen todos los &lt;code&gt;pids&lt;/code&gt; solicitados .</target>
        </trans-unit>
        <trans-unit id="7a6ee4e75683acdd450d6763b02459999f504699" translate="yes" xml:space="preserve">
          <source>If we also wanted to test the debug messages, these need to be enabled with the &lt;code&gt;min_level&lt;/code&gt; keyword:</source>
          <target state="translated">Si tambi&amp;eacute;n quisi&amp;eacute;ramos probar los mensajes de depuraci&amp;oacute;n, estos deben habilitarse con la palabra clave &lt;code&gt;min_level&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="61986d68f0f6799ea1176f1c31636a4efe0c3579" translate="yes" xml:space="preserve">
          <source>If we create &lt;code&gt;SharedArray&lt;/code&gt;s and time these functions, we get the following results (with &lt;code&gt;julia -p 4&lt;/code&gt;):</source>
          <target state="translated">Si creamos &lt;code&gt;SharedArray&lt;/code&gt; sy cronometramos estas funciones, obtenemos los siguientes resultados (con &lt;code&gt;julia -p 4&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="a1227c57ad13fa72c3a7892e71df86ffd4baf6f1" translate="yes" xml:space="preserve">
          <source>If we expect that evaluating an expression &lt;em&gt;should&lt;/em&gt; throw an exception, then we can use &lt;code&gt;@test_throws&lt;/code&gt; to check that this occurs:</source>
          <target state="translated">Si esperamos que la evaluaci&amp;oacute;n de una expresi&amp;oacute;n &lt;em&gt;debe&lt;/em&gt; lanzar una excepci&amp;oacute;n, entonces podemos utilizar &lt;code&gt;@test_throws&lt;/code&gt; para comprobar que esto ocurre:</target>
        </trans-unit>
        <trans-unit id="0245cafc71ed8d5f923ae289b03588ae96f1d3b5" translate="yes" xml:space="preserve">
          <source>If we instead pass &lt;code&gt;x&lt;/code&gt; as an argument to the function it no longer allocates memory (the allocation reported below is due to running the &lt;code&gt;@time&lt;/code&gt; macro in global scope) and is significantly faster after the first call:</source>
          <target state="translated">Si, en cambio, pasamos &lt;code&gt;x&lt;/code&gt; como argumento a la funci&amp;oacute;n, ya no asigna memoria (la asignaci&amp;oacute;n informada a continuaci&amp;oacute;n se debe a la ejecuci&amp;oacute;n de la macro &lt;code&gt;@time&lt;/code&gt; en el alcance global) y es significativamente m&amp;aacute;s r&amp;aacute;pida despu&amp;eacute;s de la primera llamada:</target>
        </trans-unit>
        <trans-unit id="f2aae1a0bcfd34dce76c0f68b8969fc76cde279d" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5a88256f096da52ec6c3ef7cb82d3f97728f34" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="translated">Si queremos que se muestre en su lugar como &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt; , definir&amp;iacute;amos el siguiente m&amp;eacute;todo para imprimir el objeto en un objeto de salida dado &lt;code&gt;io&lt;/code&gt; (que representa un archivo, terminal, b&amp;uacute;fer, etc&amp;eacute;tera; consulte &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Redes y flujos&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="a3d5a08a0cd3e04540689d3b049bf572b10229ab" translate="yes" xml:space="preserve">
          <source>If you apply &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt; to other type objects (or non-type objects), a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised:</source>
          <target state="translated">Si aplica &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt; a otros objetos de tipo (u objetos que no son de tipo), se &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; un MethodError :</target>
        </trans-unit>
        <trans-unit id="a311e1352bca4f5ac56973ae4e9111089c7fd93d" translate="yes" xml:space="preserve">
          <source>If you are defining a method &quot;cascade&quot; that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:</source>
          <target state="translated">Si está definiendo un método &quot;en cascada&quot; que suministra valores por defecto,tenga cuidado de no dejar caer ningún argumento que corresponda a potenciales valores por defecto.Por ejemplo,suponga que está escribiendo un algoritmo de filtrado digital y tiene un método que maneja los bordes de la señal aplicando un relleno:</target>
        </trans-unit>
        <trans-unit id="1ec45be5f3cad18e0598bb550f7ab8781aa51939" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; definiendo un tipo de matriz que permite la indexaci&amp;oacute;n no tradicional (&amp;iacute;ndices que comienzan en algo distinto de 1), debe especializar los &lt;code&gt;axes&lt;/code&gt; . Tambi&amp;eacute;n debe especializarse &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; es&lt;/a&gt; para que el &lt;code&gt;dims&lt;/code&gt; argumento (normalmente un &lt;code&gt;Dims&lt;/code&gt; tama&amp;ntilde;o-tupla) puede aceptar &lt;code&gt;AbstractUnitRange&lt;/code&gt; objetos, quiz&amp;aacute; rango tipos &lt;code&gt;Ind&lt;/code&gt; de su propio dise&amp;ntilde;o. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Matrices con &amp;iacute;ndices personalizados&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24ace472fa970e0efc7d5e99433a90005d823df2" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74f29b3463d83a18c14379e83918c00f3cf63aa" translate="yes" xml:space="preserve">
          <source>If you are ever stuck, you can ask &lt;code&gt;Pkg&lt;/code&gt; for help:</source>
          <target state="translated">Si alguna vez te quedas atascado, puedes pedir ayuda a &lt;code&gt;Pkg&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8735c4e810f6e4e3ffda27e1b3f1ab39f60104c6" translate="yes" xml:space="preserve">
          <source>If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into &lt;code&gt;libjulia&lt;/code&gt; with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.</source>
          <target state="translated">Si est&amp;aacute; utilizando la API de Julia C desde un lenguaje que admite excepciones (p. Ej., Python, C #, C ++), tiene sentido envolver cada llamada en &lt;code&gt;libjulia&lt;/code&gt; con una funci&amp;oacute;n que verifique si se lanz&amp;oacute; una excepci&amp;oacute;n y luego volver&amp;aacute; a generar la excepci&amp;oacute;n en el idioma anfitri&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9d33189460471265e09a2493a0c7846b4727b27d" translate="yes" xml:space="preserve">
          <source>If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:</source>
          <target state="translated">Si lo llamas en una sesión interactiva sin asignar el valor de retorno en ningún lugar,verás la tupla devuelta:</target>
        </trans-unit>
        <trans-unit id="757e93c7d7c03576f2e8bdb2961d5a609265324d" translate="yes" xml:space="preserve">
          <source>If you define both styles of indexing for your &lt;code&gt;AbstractArray&lt;/code&gt;, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; creates an iterator whose type depends on the setting of this trait.</source>
          <target state="translated">Si define ambos estilos de indexaci&amp;oacute;n para su &lt;code&gt;AbstractArray&lt;/code&gt; , este rasgo se puede utilizar para seleccionar el estilo de indexaci&amp;oacute;n m&amp;aacute;s eficaz. Algunos m&amp;eacute;todos verifican este rasgo en sus entradas y lo env&amp;iacute;an a diferentes algoritmos seg&amp;uacute;n el patr&amp;oacute;n de acceso m&amp;aacute;s eficiente. En particular, cada &lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; crea un iterador cuyo tipo depende de la configuraci&amp;oacute;n de este rasgo.</target>
        </trans-unit>
        <trans-unit id="9ff95da549c7d7e30f1529ab4e07584cdcd87231" translate="yes" xml:space="preserve">
          <source>If you define custom exception types, your &lt;code&gt;showerror&lt;/code&gt; method can support hints by calling &lt;a href=&quot;#Base.Experimental.show_error_hints&quot;&gt;&lt;code&gt;Experimental.show_error_hints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0561f634340ef3ef5927debe41e5dcc4c8cce30a" translate="yes" xml:space="preserve">
          <source>If you examine the contents of &lt;code&gt;hello.txt&lt;/code&gt; at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the &lt;code&gt;IOStream&lt;/code&gt; must be closed before the write is actually flushed to disk:</source>
          <target state="translated">Si examina el contenido de &lt;code&gt;hello.txt&lt;/code&gt; en este punto, notar&amp;aacute; que est&amp;aacute; vac&amp;iacute;o; todav&amp;iacute;a no se ha escrito nada en el disco. Esto se debe a que &lt;code&gt;IOStream&lt;/code&gt; debe cerrarse antes de que la escritura se vac&amp;iacute;e realmente en el disco:</target>
        </trans-unit>
        <trans-unit id="61d643164ec2351bd9d6fcf481fa957527066f53" translate="yes" xml:space="preserve">
          <source>If you have a matrix &lt;code&gt;A&lt;/code&gt; that is slightly non-Hermitian due to roundoff errors in its construction, wrap it in &lt;code&gt;Hermitian(A)&lt;/code&gt; before passing it to &lt;code&gt;cholesky&lt;/code&gt; in order to treat it as perfectly Hermitian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eaa143836add2b691eb62610bcaeb5c4d609829" translate="yes" xml:space="preserve">
          <source>If you have a type that uses a native pointer:</source>
          <target state="translated">Si tienes un tipo que usa un puntero nativo:</target>
        </trans-unit>
        <trans-unit id="aaf9e1541b4bdb0c52c8f375b573b49db90dd938" translate="yes" xml:space="preserve">
          <source>If you have code that you want executed whenever Julia is run, you can put it in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Si tiene un c&amp;oacute;digo que desea ejecutar siempre que se ejecute Julia, puede ponerlo en &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6993e56b8a3ed1437873eaf20d58be9dd8dc4fb" translate="yes" xml:space="preserve">
          <source>If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your &lt;code&gt;SparseMatrixCSC&lt;/code&gt; object contains unsorted row indices, one quick way to sort them is by doing a double transpose.</source>
          <target state="translated">Si tiene datos en formato CSC de una aplicaci&amp;oacute;n o biblioteca diferente y desea importarlos en Julia, aseg&amp;uacute;rese de usar la indexaci&amp;oacute;n basada en 1. Los &amp;iacute;ndices de fila de cada columna deben ordenarse. Si su objeto &lt;code&gt;SparseMatrixCSC&lt;/code&gt; contiene &amp;iacute;ndices de fila sin clasificar, una forma r&amp;aacute;pida de ordenarlos es haciendo una doble transposici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="be1012643129d3902e3bcc736a2f09368b135cc7" translate="yes" xml:space="preserve">
          <source>If you interpolate an array as part of a shell word, Julia emulates the shell's &lt;code&gt;{a,b,c}&lt;/code&gt; argument generation:</source>
          <target state="translated">Si interpola una matriz como parte de una palabra de shell, Julia emula la generaci&amp;oacute;n de argumentos &lt;code&gt;{a,b,c}&lt;/code&gt; del shell :</target>
        </trans-unit>
        <trans-unit id="66c0ea7806057d283c6cb2263bc03f2b5f51cca2" translate="yes" xml:space="preserve">
          <source>If you know that a module is &lt;em&gt;not&lt;/em&gt; safe to precompile your module (for example, for one of the reasons described below), you should put &lt;code&gt;__precompile__(false)&lt;/code&gt; in the module file (typically placed at the top). This will cause &lt;code&gt;Base.compilecache&lt;/code&gt; to throw an error, and will cause &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</source>
          <target state="translated">Si sabe que un m&amp;oacute;dulo &lt;em&gt;no&lt;/em&gt; es seguro para precompilar su m&amp;oacute;dulo (por ejemplo, por una de las razones que se describen a continuaci&amp;oacute;n), debe poner &lt;code&gt;__precompile__(false)&lt;/code&gt; en el archivo del m&amp;oacute;dulo (normalmente se coloca en la parte superior). Esto har&amp;aacute; que &lt;code&gt;Base.compilecache&lt;/code&gt; arroje un error y har&amp;aacute; que el &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; lo cargue directamente en el proceso actual y omita la precompilaci&amp;oacute;n y el almacenamiento en cach&amp;eacute;. Esto tambi&amp;eacute;n evita que el m&amp;oacute;dulo sea importado por cualquier otro m&amp;oacute;dulo precompilado.</target>
        </trans-unit>
        <trans-unit id="8e09fd6adcf3b546269be2b7ff41cc7243507fad" translate="yes" xml:space="preserve">
          <source>If you need a reference to the created task, pass a &lt;code&gt;Ref{Task}&lt;/code&gt; object via the keyword argument &lt;code&gt;taskref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9119dc7e0716f5e2cbcc069fcd20399d5871b899" translate="yes" xml:space="preserve">
          <source>If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a &quot;name cascade&quot; where (for example) you dispatch on the first argument and then call an internal method:</source>
          <target state="translated">Si se necesita despachar con múltiples argumentos,y hay muchos inconvenientes con demasiadas combinaciones para que sea práctico definir todas las variantes posibles,entonces considere la posibilidad de introducir una &quot;cascada de nombres&quot; en la que (por ejemplo)se despacha con el primer argumento y luego se llama a un método interno:</target>
        </trans-unit>
        <trans-unit id="5c6a0fa6b882b862c349ff5b92d17fa1f5f4c109" translate="yes" xml:space="preserve">
          <source>If you need to guarantee exact reproducibility of random data, it is advisable to simply &lt;em&gt;save the data&lt;/em&gt; (e.g. as a supplementary attachment in a scientific publication). (You can also, of course, specify a particular Julia version and package manifest, especially if you require bit reproducibility.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f3bebbfec4cfb424affa402369c33eff6a7949" translate="yes" xml:space="preserve">
          <source>If you need to obtain valid indices for a string, you can use the &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt;&lt;code&gt;prevind&lt;/code&gt;&lt;/a&gt; functions to increment/decrement to the next/previous valid index, as mentioned above. You can also use the &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; function to iterate over the valid character indices:</source>
          <target state="translated">Si necesita obtener &amp;iacute;ndices v&amp;aacute;lidos para una cadena, puede usar las funciones &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt; &lt;code&gt;prevind&lt;/code&gt; &lt;/a&gt; para incrementar / disminuir al &amp;iacute;ndice v&amp;aacute;lido siguiente / anterior, como se mencion&amp;oacute; anteriormente. Tambi&amp;eacute;n puede utilizar la funci&amp;oacute;n &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; para iterar sobre los &amp;iacute;ndices de caracteres v&amp;aacute;lidos:</target>
        </trans-unit>
        <trans-unit id="ffe59bec712e7149856d034145a9690621f691b0" translate="yes" xml:space="preserve">
          <source>If you need to solve many systems of the form &lt;code&gt;(A+&amp;mu;I)x = b&lt;/code&gt; for the same &lt;code&gt;A&lt;/code&gt; and different &lt;code&gt;&amp;mu;&lt;/code&gt;, it might be beneficial to first compute the Hessenberg factorization &lt;code&gt;F&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; via the &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt; function. Given &lt;code&gt;F&lt;/code&gt;, Julia employs an efficient algorithm for &lt;code&gt;(F+&amp;mu;*I) \ b&lt;/code&gt; (equivalent to &lt;code&gt;(A+&amp;mu;*I)x \ b&lt;/code&gt;) and related operations like determinants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c200e4c125ec6f24cad360d6dae92d524d5333" translate="yes" xml:space="preserve">
          <source>If you prefer to use the environment variable you can set it as follows in Bash (Linux/macOS):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e449fc3b5ae85ea55ddb2c14a81e3b450b101b1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;multiplex=true&lt;/code&gt; as an option to &lt;code&gt;addprocs&lt;/code&gt;, SSH multiplexing is used to create a tunnel between the master and workers. If you have configured SSH multiplexing on your own and the connection has already been established, SSH multiplexing is used regardless of &lt;code&gt;multiplex&lt;/code&gt; option. If multiplexing is enabled, forwarding is set by using the existing connection (&lt;code&gt;-O forward&lt;/code&gt; option in ssh). This is beneficial if your servers require password authentication; you can avoid authentication in Julia by logging in to the server ahead of &lt;code&gt;addprocs&lt;/code&gt;. The control socket will be located at &lt;code&gt;~/.ssh/julia-%r@%h:%p&lt;/code&gt; during the session unless the existing multiplexing connection is used. Note that bandwidth may be limited if you create multiple processes on a node and enable multiplexing, because in that case processes share a single multiplexing TCP connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801f3bd6c180fb1f8c8c459f54a17ac585429686" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;branch&lt;/code&gt;, this must be done in reference format, since the string will be turned into a &lt;code&gt;GitReference&lt;/code&gt;. For example, if you wanted to merge branch &lt;code&gt;branch_a&lt;/code&gt;, you would call &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt;.</source>
          <target state="translated">Si especifica una &lt;code&gt;branch&lt;/code&gt; , debe hacerlo en formato de referencia, ya que la cadena se convertir&amp;aacute; en una &lt;code&gt;GitReference&lt;/code&gt; . Por ejemplo, si desea fusionar la rama &lt;code&gt;branch_a&lt;/code&gt; , debe llamar a &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12b4daadf4d05ca4bd1781bb32cf57f260bb2750" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, &lt;code&gt;eachindex&lt;/code&gt; will return an iterable that spans the largest range along each dimension.</source>
          <target state="translated">Si proporciona m&amp;aacute;s de un argumento &lt;code&gt;AbstractArray&lt;/code&gt; , cada &lt;code&gt;eachindex&lt;/code&gt; crear&amp;aacute; un objeto iterable que es r&amp;aacute;pido para todos los argumentos (un &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt; si todas las entradas tienen indexaci&amp;oacute;n lineal r&amp;aacute;pida, un &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; en&lt;/a&gt; caso contrario). Si las matrices tienen diferentes tama&amp;ntilde;os y / o dimensionalidades, cada &lt;code&gt;eachindex&lt;/code&gt; devolver&amp;aacute; un iterable que abarca el rango m&amp;aacute;s grande a lo largo de cada dimensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f56a6f95645242ddef63028fd0be36ad60f0ec75" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad751359c9250bca5bb370e9aaa6dde27fda5aad" translate="yes" xml:space="preserve">
          <source>If you try this in the REPL, you will see that &lt;code&gt;schedule&lt;/code&gt; returns immediately. That is because it simply adds &lt;code&gt;t&lt;/code&gt; to an internal queue of tasks to run. Then, the REPL will print the next prompt and wait for more input. Waiting for keyboard input provides an opportunity for other tasks to run, so at that point &lt;code&gt;t&lt;/code&gt; will start. &lt;code&gt;t&lt;/code&gt; calls &lt;a href=&quot;../../base/parallel/index#Base.sleep&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt;, which sets a timer and stops execution. If other tasks have been scheduled, they could run then. After five seconds, the timer fires and restarts &lt;code&gt;t&lt;/code&gt;, and you will see &lt;code&gt;done&lt;/code&gt; printed. &lt;code&gt;t&lt;/code&gt; is then finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf64552bec6648b4a2dbc60f5636537b6e39be4" translate="yes" xml:space="preserve">
          <source>If you want a quantity that is of the same type as &lt;code&gt;x&lt;/code&gt;, or of type &lt;code&gt;T&lt;/code&gt;, even if &lt;code&gt;x&lt;/code&gt; is dimensionful, use &lt;a href=&quot;#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Si desea una cantidad que sea del mismo tipo que &lt;code&gt;x&lt;/code&gt; , o del tipo &lt;code&gt;T&lt;/code&gt; , incluso si &lt;code&gt;x&lt;/code&gt; es dimensional, utilice una &lt;a href=&quot;#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="0d6bdd166c95ac54bc84be65e3c70b26b5a5d3fc" translate="yes" xml:space="preserve">
          <source>If you want to &lt;em&gt;avoid&lt;/em&gt; adding dots for selected function calls in &lt;code&gt;expr&lt;/code&gt;, splice those function calls in with &lt;code&gt;$&lt;/code&gt;. For example, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; is equivalent to &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (no dot for &lt;code&gt;sort&lt;/code&gt;).</source>
          <target state="translated">Si desea &lt;em&gt;evitar&lt;/em&gt; agregar puntos para las llamadas a funciones seleccionadas en &lt;code&gt;expr&lt;/code&gt; , empalme esas llamadas a funciones con &lt;code&gt;$&lt;/code&gt; . Por ejemplo, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; es equivalente a &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (sin punto para &lt;code&gt;sort&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="683a65524138ed99d613028444b793379d0ca4fd" translate="yes" xml:space="preserve">
          <source>If you want to extract a character from a string, you index into it:</source>
          <target state="translated">Si quieres extraer un personaje de una cadena,lo indexas:</target>
        </trans-unit>
        <trans-unit id="af6bdcdecfb445706192e5de8fd952192d9e2d0e" translate="yes" xml:space="preserve">
          <source>If you want to read the output of the external command, &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; can be used instead:</source>
          <target state="translated">Si desea leer la salida del comando externo, puede usar &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; en&lt;/a&gt; su lugar:</target>
        </trans-unit>
        <trans-unit id="9ee9527d2c41ad82a10f035e6e19f07b44c36b95" translate="yes" xml:space="preserve">
          <source>If you want to test that some particular messages are generated while ignoring the rest, you can set the keyword &lt;code&gt;match_mode=:any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66677df9764417ef6a9289f8e4f6bf8274c36caa" translate="yes" xml:space="preserve">
          <source>If you want to use logging as an audit trail you should disable this for your logger type.</source>
          <target state="translated">Si desea utilizar el registro como una pista de auditoría,debe desactivarlo para su tipo de registro.</target>
        </trans-unit>
        <trans-unit id="e7c7d63501e2b9d2d6b42831c4f6216f8a461efd" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, you can open it with the write (&lt;code&gt;&quot;w&quot;&lt;/code&gt;) flag:</source>
          <target state="translated">Si desea escribir en un archivo, puede abrirlo con la marca de escritura ( &lt;code&gt;&quot;w&quot;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="c3b03f51e5a4a15df40aa0cdfd2977b041193157" translate="yes" xml:space="preserve">
          <source>If you were to profile &lt;code&gt;dumbsum3&lt;/code&gt;, and a backtrace was taken while it was executing &lt;code&gt;dumbsum(1)&lt;/code&gt;, the backtrace would look like this:</source>
          <target state="translated">Si &lt;code&gt;dumbsum3&lt;/code&gt; perfilar dumbsum3 y se realiz&amp;oacute; un backtrace mientras se ejecutaba &lt;code&gt;dumbsum(1)&lt;/code&gt; , el backtrace se ver&amp;iacute;a as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="0bc4f596ffa41c5fb93ede00ad1673e3a89c26be" translate="yes" xml:space="preserve">
          <source>If you wish to specialize on a particular style &lt;code&gt;DestStyle&lt;/code&gt;, define a method for</source>
          <target state="translated">Si desea especializarse en un estilo &lt;code&gt;DestStyle&lt;/code&gt; en particular , defina un m&amp;eacute;todo para</target>
        </trans-unit>
        <trans-unit id="9416eec2408335a70a9403f87954e9d92bc5beb6" translate="yes" xml:space="preserve">
          <source>If you would like to define your own block, for example a &lt;code&gt;terminology&lt;/code&gt; block used like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81fa178f278896f499b8c79cc33cce8975b52ac" translate="yes" xml:space="preserve">
          <source>If you write a custom &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; type, you can specify that it has fast linear indexing using</source>
          <target state="translated">Si escribe un tipo &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt; personalizado , puede especificar que tenga una indexaci&amp;oacute;n lineal r&amp;aacute;pida usando</target>
        </trans-unit>
        <trans-unit id="731e84cb8afd8370c60140146ac6c2a5c345b233" translate="yes" xml:space="preserve">
          <source>If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.</source>
          <target state="translated">Si se escribe un código genérico que maneja números,y que se puede esperar que se ejecute con muchos argumentos de tipo numérico diferentes,trate de utilizar literales de tipo numérico que afecten los argumentos lo menos posible a través de la promoción.</target>
        </trans-unit>
        <trans-unit id="dcea13c507e05364e2e2a422c4d4bb092770bc50" translate="yes" xml:space="preserve">
          <source>If your array type does have fixed dimensionality requirements, then you should subtype &lt;code&gt;AbstractArrayStyle&lt;/code&gt;. For example, the sparse array code has the following definitions:</source>
          <target state="translated">Si su tipo de matriz tiene requisitos de dimensionalidad fijos, entonces debe subtipificar &lt;code&gt;AbstractArrayStyle&lt;/code&gt; . Por ejemplo, el c&amp;oacute;digo de matriz dispersa tiene las siguientes definiciones:</target>
        </trans-unit>
        <trans-unit id="86e175e64e8da6c7e916078c1c6ea2b5a935db82" translate="yes" xml:space="preserve">
          <source>If your code has recursion, one potentially-confusing point is that a line in a &quot;child&quot; function can accumulate more counts than there are total backtraces. Consider the following function definitions:</source>
          <target state="translated">Si su código tiene recursividad,un punto potencialmente confuso es que una línea en una función &quot;infantil&quot; puede acumular más conteos que el total de retrocesos.Considere las siguientes definiciones de funciones:</target>
        </trans-unit>
        <trans-unit id="aa3f9be2eca1806a6c02bd56dca6f747bcc2726c" translate="yes" xml:space="preserve">
          <source>If your function returns an &lt;code&gt;Array&lt;/code&gt; or some other complex type, it may have to allocate memory. Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.</source>
          <target state="translated">Si su funci&amp;oacute;n devuelve una &lt;code&gt;Array&lt;/code&gt; o alg&amp;uacute;n otro tipo complejo, es posible que deba asignar memoria. Desafortunadamente, a menudo la asignaci&amp;oacute;n y su inverso, la recolecci&amp;oacute;n de basura, son cuellos de botella sustanciales.</target>
        </trans-unit>
        <trans-unit id="203770fc43c2ec3f449524fb36ddffdf662a89aa" translate="yes" xml:space="preserve">
          <source>If, on the other hand, Julia was loading the &lt;em&gt;other&lt;/em&gt;&lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt;&amp;mdash;it finds its stanza in the manifest, see that it does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;path&lt;/code&gt; entry, but that it does have a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry. It then computes the &lt;code&gt;slug&lt;/code&gt; for this UUID/SHA-1 pair, which is &lt;code&gt;HDkrT&lt;/code&gt; (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this &lt;code&gt;Priv&lt;/code&gt; package will be &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; in one of the package depots. Suppose the contents of &lt;code&gt;DEPOT_PATH&lt;/code&gt; is &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt;, then Julia will look at the following paths to see if they exist:</source>
          <target state="translated">Si, por otro lado, Julia estaba cargando el &lt;em&gt;otro&lt;/em&gt; paquete &lt;code&gt;Priv&lt;/code&gt; , el que tiene UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt; , encuentra su estrofa en el manifiesto, vea que &lt;em&gt;no&lt;/em&gt; tiene una entrada de &lt;code&gt;path&lt;/code&gt; , pero que tiene una entrada &lt;code&gt;git-tree-sha1&lt;/code&gt; . Luego calcula el &lt;code&gt;slug&lt;/code&gt; para este par UUID / SHA-1, que es &lt;code&gt;HDkrT&lt;/code&gt; (los detalles exactos de este c&amp;aacute;lculo no son importantes, pero es consistente y determinista). Esto significa que la ruta a este paquete &lt;code&gt;Priv&lt;/code&gt; ser&amp;aacute; &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; en uno de los dep&amp;oacute;sitos de paquetes. Suponga que el contenido de &lt;code&gt;DEPOT_PATH&lt;/code&gt; es &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt; , luego Julia buscar&amp;aacute; en las siguientes rutas para ver si existen:</target>
        </trans-unit>
        <trans-unit id="08884ba6d9fbd224895a7cbdeceeec1f4c59bf40" translate="yes" xml:space="preserve">
          <source>Image Of</source>
          <target state="translated">Imagen de</target>
        </trans-unit>
        <trans-unit id="6ea4ebbef3751656124627e822bd05d7b6569f88" translate="yes" xml:space="preserve">
          <source>Image Of Or Approximately Equal To</source>
          <target state="translated">Imagen de o aproximadamente igual a</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="a1dd283e60c10a07da0fde84cdded35b0d62bc7f" translate="yes" xml:space="preserve">
          <source>Immediately run finalizers registered for object &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Ejecute inmediatamente los finalizadores registrados para el objeto &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f8a84e660062cc9351aa99e4736b44741ec8c96" translate="yes" xml:space="preserve">
          <source>Immutable composite types with no fields are singletons; there can be only one instance of such types:</source>
          <target state="translated">Los tipos compuestos inmutables sin campos son monolitos;sólo puede haber una instancia de tales tipos:</target>
        </trans-unit>
        <trans-unit id="546c2aff0baec3bbc325a5abd6340afd6a503d6d" translate="yes" xml:space="preserve">
          <source>ImmutableDict</source>
          <target state="translated">ImmutableDict</target>
        </trans-unit>
        <trans-unit id="4d5fca35f85700fe41f680f762e716a68cf32a0c" translate="yes" xml:space="preserve">
          <source>ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key</source>
          <target state="translated">ImmutableDict es un diccionario implementado como una lista de enlaces inmutables,que es óptima para pequeños diccionarios que se construyen sobre muchas inserciones individuales Tenga en cuenta que no es posible eliminar un valor,aunque se puede anular y ocultar parcialmente insertando un nuevo valor con la misma clave</target>
        </trans-unit>
        <trans-unit id="5a205de46742b724da4bcd47864315bbfb29bffa" translate="yes" xml:space="preserve">
          <source>Imp</source>
          <target state="translated">Imp</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="91db407238f7692c5a1c288977c0c95bb564522e" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id &lt;code&gt;pid&lt;/code&gt;, specified by &lt;code&gt;config&lt;/code&gt; and return a pair of &lt;code&gt;IO&lt;/code&gt; objects. Messages from &lt;code&gt;pid&lt;/code&gt; to current process will be read off &lt;code&gt;instrm&lt;/code&gt;, while messages to be sent to &lt;code&gt;pid&lt;/code&gt; will be written to &lt;code&gt;outstrm&lt;/code&gt;. The custom transport implementation must ensure that messages are delivered and received completely and in order. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; sets up TCP/IP socket connections in-between workers.</source>
          <target state="translated">Implementado por administradores de cl&amp;uacute;steres mediante transportes personalizados. Debe establecer una conexi&amp;oacute;n l&amp;oacute;gica con el trabajador con id &lt;code&gt;pid&lt;/code&gt; , especificado por &lt;code&gt;config&lt;/code&gt; y devolver un par de objetos &lt;code&gt;IO&lt;/code&gt; . Los mensajes de &lt;code&gt;pid&lt;/code&gt; al proceso actual se leer&amp;aacute;n en &lt;code&gt;instrm&lt;/code&gt; , mientras que los mensajes que se env&amp;iacute;en a &lt;code&gt;pid&lt;/code&gt; se escribir&amp;aacute;n en &lt;code&gt;outstrm&lt;/code&gt; . La implementaci&amp;oacute;n del transporte personalizado debe garantizar que los mensajes se entreguen y reciban en su totalidad y en orden. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; configura conexiones de socket TCP / IP entre trabajadores.</target>
        </trans-unit>
        <trans-unit id="08979f61f84f8ad3b659b0b75ccddbf1892ea3a4" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. For every Julia worker launched by this function, it should append a &lt;code&gt;WorkerConfig&lt;/code&gt; entry to &lt;code&gt;launched&lt;/code&gt; and notify &lt;code&gt;launch_ntfy&lt;/code&gt;. The function MUST exit once all workers, requested by &lt;code&gt;manager&lt;/code&gt; have been launched. &lt;code&gt;params&lt;/code&gt; is a dictionary of all keyword arguments &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; was called with.</source>
          <target state="translated">Implementado por administradores de cl&amp;uacute;steres. Por cada trabajador Julia puesto en marcha por esta funci&amp;oacute;n, se debe anexar una &lt;code&gt;WorkerConfig&lt;/code&gt; entrada a &lt;code&gt;launched&lt;/code&gt; y notificar &lt;code&gt;launch_ntfy&lt;/code&gt; . La funci&amp;oacute;n DEBE salir una vez que se hayan iniciado todos los trabajadores solicitados por el &lt;code&gt;manager&lt;/code&gt; . &lt;code&gt;params&lt;/code&gt; es un diccionario de todos los argumentos de palabras clave &lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt; se llam&amp;oacute; a addprocs .</target>
        </trans-unit>
        <trans-unit id="b5a68dbaa7e53b1fdc013e1b1b627c788dfd10b1" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, by &lt;a href=&quot;#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;. It should cause the remote worker specified by &lt;code&gt;pid&lt;/code&gt; to exit. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; executes a remote &lt;code&gt;exit()&lt;/code&gt; on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">Implementado por administradores de cl&amp;uacute;steres. Se llama en el proceso maestro, por &lt;a href=&quot;#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt; . Deber&amp;iacute;a hacer que el trabajador remoto especificado por &lt;code&gt;pid&lt;/code&gt; salga. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; ejecuta una &lt;code&gt;exit()&lt;/code&gt; remota () en &lt;code&gt;pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dba266234257c3d4b0aca4b478ddab2be6ca2905" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">Implementado por administradores de cl&amp;uacute;steres. Se llama en el proceso maestro, durante la vida de un trabajador, con los valores de &lt;code&gt;op&lt;/code&gt; eraci&amp;oacute;n apropiados :</target>
        </trans-unit>
        <trans-unit id="2d46cc8d098f423748bfcc369918df042e230bb1" translate="yes" xml:space="preserve">
          <source>Implicit names from identifiers and dot expressions are available as of Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6456a3318802fc28959139bf29a9bdf8b9e1954" translate="yes" xml:space="preserve">
          <source>Import Command</source>
          <target state="translated">Comando de importación</target>
        </trans-unit>
        <trans-unit id="a4489b5a6e6e45ce5f1172241f2ce59438e83997" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MyModule&lt;/code&gt; above we wanted to add a method to the standard &lt;code&gt;show&lt;/code&gt; function, so we had to write &lt;code&gt;import Base.show&lt;/code&gt;. Functions whose names are only visible via &lt;code&gt;using&lt;/code&gt; cannot be extended.</source>
          <target state="translated">En &lt;code&gt;MyModule&lt;/code&gt; anterior, quer&amp;iacute;amos agregar un m&amp;eacute;todo a la funci&amp;oacute;n &lt;code&gt;show&lt;/code&gt; est&amp;aacute;ndar , por lo que tuvimos que escribir &lt;code&gt;import Base.show&lt;/code&gt; . Las funciones cuyos nombres solo son visibles mediante el &lt;code&gt;using&lt;/code&gt; no se pueden ampliar.</target>
        </trans-unit>
        <trans-unit id="035c9cab15fd9dc0120582c57dc7ae1a95ac181b" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;very rare&lt;/em&gt; cases it might make sense for the constructor &lt;code&gt;T(x)&lt;/code&gt; to return an object not of type &lt;code&gt;T&lt;/code&gt;. This could happen if a wrapper type is its own inverse (e.g. &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt;), or to support an old calling syntax for backwards compatibility when a library is restructured. But &lt;code&gt;convert(T, x)&lt;/code&gt; should always return a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">En &lt;em&gt;muy raros&lt;/em&gt; casos puede que tenga sentido para el constructor &lt;code&gt;T(x)&lt;/code&gt; para devolver un objeto no de tipo &lt;code&gt;T&lt;/code&gt; . Esto podr&amp;iacute;a suceder si un tipo de contenedor es su propio inverso (por ejemplo, &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt; ), o para admitir una sintaxis de llamada antigua para compatibilidad con versiones anteriores cuando se reestructura una biblioteca. Pero &lt;code&gt;convert(T, x)&lt;/code&gt; siempre debe devolver un valor de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6ddd3549cd522fa313ced4025d3d58df8994646" translate="yes" xml:space="preserve">
          <source>In C++ or Java, for example, in a method call like &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt;, the object obj &quot;receives&quot; the method call and is implicitly passed to the method via the &lt;code&gt;this&lt;/code&gt; keyword, rather than as an explicit method argument. When the current &lt;code&gt;this&lt;/code&gt; object is the receiver of a method call, it can be omitted altogether, writing just &lt;code&gt;meth(arg1,arg2)&lt;/code&gt;, with &lt;code&gt;this&lt;/code&gt; implied as the receiving object.</source>
          <target state="translated">En C ++ o Java, por ejemplo, en una llamada a un m&amp;eacute;todo como &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt; , el objeto obj &quot;recibe&quot; la llamada al m&amp;eacute;todo y se pasa impl&amp;iacute;citamente al m&amp;eacute;todo a trav&amp;eacute;s de la palabra clave &lt;code&gt;this&lt;/code&gt; , en lugar de como un argumento de m&amp;eacute;todo expl&amp;iacute;cito. . Cuando el objeto actual &lt;code&gt;this&lt;/code&gt; es el receptor de una llamada a un m&amp;eacute;todo, se puede omitir por completo, escribiendo solo &lt;code&gt;meth(arg1,arg2)&lt;/code&gt; , con &lt;code&gt;this&lt;/code&gt; impl&amp;iacute;cito como el objeto receptor.</target>
        </trans-unit>
        <trans-unit id="0b44231782a66524e37b6a261f0e356297afae45" translate="yes" xml:space="preserve">
          <source>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is &quot;virtual&quot; (although it's more general than that since methods are dispatched on every argument type, not only &lt;code&gt;this&lt;/code&gt;, using the most-specific-declaration rule).</source>
          <target state="translated">En C ++, de forma predeterminada, tiene un env&amp;iacute;o est&amp;aacute;tico, es decir, necesita anotar una funci&amp;oacute;n como virtual, para tener un env&amp;iacute;o din&amp;aacute;mico. Por otro lado, en Julia cada m&amp;eacute;todo es &quot;virtual&quot; (aunque es m&amp;aacute;s general que eso, ya que los m&amp;eacute;todos se distribuyen en cada tipo de argumento, no solo en &lt;code&gt;this&lt;/code&gt; , usando la regla de declaraci&amp;oacute;n m&amp;aacute;s espec&amp;iacute;fica).</target>
        </trans-unit>
        <trans-unit id="848c2eb8261286f9fd639a07ac24e094cd08249a" translate="yes" xml:space="preserve">
          <source>In Julia &amp;le; 0.6, all global scopes did work like the current REPL: when &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; occurred in a loop (or &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, or &lt;code&gt;struct&lt;/code&gt; body) but outside of a function body (or &lt;code&gt;let&lt;/code&gt; block or comprehension), it was decided based on whether a global named &lt;code&gt;x&lt;/code&gt; was defined or not whether &lt;code&gt;x&lt;/code&gt; should be local to the loop. This behavior has the advantage of being intuitive and convenient since it approximates the behavior inside of a function body as closely as possible. In particular, it makes it easy to move code back and forth between a function body and the REPL when trying to debug the behavior of a function. However, it has some downsides. First, it's quite a complex behavior: many people over the years were confused about this behavior and complained that it was complicated and hard both to explain and understand. Fair point. Second, and arguably worse, is that it's bad for programming &quot;at scale.&quot; When you see a small piece of code in one place like this, it's quite clear what's going on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64f4137e1f00234d12e399e1c5435c90a8e6c63" translate="yes" xml:space="preserve">
          <source>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK library&lt;/a&gt;, which in turn is built on top of basic linear-algebra building-blocks known as the &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt;. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</source>
          <target state="translated">En Julia (como en gran parte de la computaci&amp;oacute;n cient&amp;iacute;fica), las operaciones densas de &amp;aacute;lgebra lineal se basan en la &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;biblioteca LAPACK&lt;/a&gt; , que a su vez se construye sobre los bloques de construcci&amp;oacute;n b&amp;aacute;sicos de &amp;aacute;lgebra lineal conocidos como &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt; . Hay implementaciones altamente optimizadas de BLAS disponibles para cada arquitectura de computadora y, a veces, en las rutinas de &amp;aacute;lgebra lineal de alto rendimiento es &amp;uacute;til llamar a las funciones BLAS directamente.</target>
        </trans-unit>
        <trans-unit id="247a76ccd2e14a487830d09d4cedad7b8f5df0c1" translate="yes" xml:space="preserve">
          <source>In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.</source>
          <target state="translated">En Julia 1.0 este método sólo soportaba una matriz de destino cuadrada.Julia 1.1.añadió soporte para una matriz rectangular.</target>
        </trans-unit>
        <trans-unit id="7eb90fb66dbd8787a2bcb4484cc97817d278a46b" translate="yes" xml:space="preserve">
          <source>In Julia 1.0, the default &lt;code&gt;--project=@.&lt;/code&gt; option did not search up from the root directory of a Git repository for the &lt;code&gt;Project.toml&lt;/code&gt; file. From Julia 1.1 forward, it does.</source>
          <target state="translated">En Julia 1.0, el valor predeterminado &lt;code&gt;--project=@.&lt;/code&gt; La opci&amp;oacute;n no busc&amp;oacute; desde el directorio ra&amp;iacute;z de un repositorio de Git para el archivo &lt;code&gt;Project.toml&lt;/code&gt; . Desde Julia 1.1 en adelante, lo hace.</target>
        </trans-unit>
        <trans-unit id="0050127afe87c7fac6e12932d051462ec8c65b3e" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randcycle&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">En Julia 1.1, &lt;code&gt;randcycle&lt;/code&gt; devuelve un vector &lt;code&gt;v&lt;/code&gt; con &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; mientras que en Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8b5eb0c54cc4aad9911d4c5d77bfea05f710df6" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randperm&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">En Julia 1.1, &lt;code&gt;randperm&lt;/code&gt; devuelve un vector &lt;code&gt;v&lt;/code&gt; con &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; mientras que en Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f25573f2ef6b2638e0373e20cdd6eceb2e703331" translate="yes" xml:space="preserve">
          <source>In Julia 1.5 and above the number of threads can also be specified on startup using the &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; command line argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d630cc94b63c31ac28921da908c57f1454c54e15" translate="yes" xml:space="preserve">
          <source>In Julia &lt;code&gt;%&lt;/code&gt; is the remainder operator, whereas in Python it is the modulus.</source>
          <target state="translated">En Julia &lt;code&gt;%&lt;/code&gt; es el operador restante, mientras que en Python es el m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="cbc49b243ca968548d5e6046855ea243ea0a10fe" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type &lt;code&gt;T&lt;/code&gt; inside the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, as they are passed by value. For C code accepting pointers, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt;. In contrast, pointers returned by the C function called should be declared to be of output type &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr{T}&lt;/code&gt;&lt;/a&gt;, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type &lt;code&gt;Ptr{T}&lt;/code&gt; within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</source>
          <target state="translated">En las llamadas de envoltura de c&amp;oacute;digo de Julia a rutinas C externas, los datos ordinarios (no punteros) deben declararse como de tipo &lt;code&gt;T&lt;/code&gt; dentro de &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; , ya que se pasan por valor. Para el c&amp;oacute;digo C que acepta punteros, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt; generalmente debe usarse para los tipos de argumentos de entrada, permitiendo el uso de punteros a la memoria administrada por Julia o C a trav&amp;eacute;s de la llamada impl&amp;iacute;cita a &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt; . Por el contrario, los punteros devueltos por la funci&amp;oacute;n C llamada deben declararse como del tipo de salida &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr{T}&lt;/code&gt; &lt;/a&gt; , lo que refleja que la memoria a la que se apunta es administrada &amp;uacute;nicamente por C. Los punteros contenidos en estructuras C deben representarse como campos de tipo &lt;code&gt;Ptr{T}&lt;/code&gt; dentro de los tipos de estructuras de Julia correspondientes dise&amp;ntilde;ados para imitar la estructura interna de las estructuras de C correspondientes.</target>
        </trans-unit>
        <trans-unit id="1fa4d6ec34fe20b0509960e834e463ea1a6b4cc7" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type &lt;code&gt;Ref{T}&lt;/code&gt;, as Fortran passes all variables by pointers to memory locations. The return type should either be &lt;code&gt;Cvoid&lt;/code&gt; for Fortran subroutines, or a &lt;code&gt;T&lt;/code&gt; for Fortran functions returning the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">En las llamadas de envoltura de c&amp;oacute;digo de Julia a rutinas externas de Fortran, todos los argumentos de entrada deben declararse como del tipo &lt;code&gt;Ref{T}&lt;/code&gt; , ya que Fortran pasa todas las variables mediante punteros a ubicaciones de memoria. El tipo de retorno debe ser o bien &lt;code&gt;Cvoid&lt;/code&gt; para subrutinas Fortran, o una &lt;code&gt;T&lt;/code&gt; para las funciones de Fortran regresan el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34f3cdb66f13e42ca43c63a9c817a8c4007728b9" translate="yes" xml:space="preserve">
          <source>In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</source>
          <target state="translated">En Julia cada módulo tiene su propio alcance global/espacio de nombres,mientras que en MATLAB sólo hay un alcance global.</target>
        </trans-unit>
        <trans-unit id="a3d6aa810b7eb985858c7d4e38c552636ecace4b" translate="yes" xml:space="preserve">
          <source>In Julia loops are fast, there is no need to write &quot;vectorized&quot; code for performance reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9649a4e1eb5caa62495053957d722a3d4bba674" translate="yes" xml:space="preserve">
          <source>In Julia mode, the REPL supports something called &lt;em&gt;prompt pasting&lt;/em&gt;. This activates when pasting text that starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt; into the REPL. In that case, only expressions starting with &lt;code&gt;julia&amp;gt;&lt;/code&gt; are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt;. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.</source>
          <target state="translated">En el modo Julia, REPL admite algo llamado &lt;em&gt;pegado r&amp;aacute;pido&lt;/em&gt; . Esto se activa al pegar texto que comienza con &lt;code&gt;julia&amp;gt;&lt;/code&gt; en el REPL. En ese caso, solo se &lt;code&gt;julia&amp;gt;&lt;/code&gt; expresiones que comienzan con julia&amp;gt; , otras se eliminan. Esto hace que sea posible pegar un fragmento de c&amp;oacute;digo que se haya copiado de una sesi&amp;oacute;n REPL sin tener que borrar las indicaciones y los resultados. Esta funci&amp;oacute;n est&amp;aacute; habilitada de forma predeterminada, pero puede deshabilitarse o habilitarse a voluntad con &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt; . Si est&amp;aacute; habilitado, puede probarlo pegando el bloque de c&amp;oacute;digo sobre este p&amp;aacute;rrafo directamente en el REPL. Esta funci&amp;oacute;n no funciona en el s&amp;iacute;mbolo del sistema est&amp;aacute;ndar de Windows debido a su limitaci&amp;oacute;n para detectar cu&amp;aacute;ndo ocurre un pegado.</target>
        </trans-unit>
        <trans-unit id="7129a6b15edfb73c2cd4cd30d7a70ed28691edca" translate="yes" xml:space="preserve">
          <source>In Julia the &lt;code&gt;@&lt;/code&gt; symbol refers to a macro, whereas in Python it refers to a decorator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d6ea2617d808e81c678587852ffabe403f81cb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; are not assignment operators.</source>
          <target state="translated">En Julia, &lt;code&gt;&amp;lt;-&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; y &lt;code&gt;-&amp;gt;&lt;/code&gt; no son operadores de asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="601692d3aba8995fb01afb976c7c7f5a8aab46fc" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;...&lt;/code&gt; is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</source>
          <target state="translated">En Julia, &lt;code&gt;...&lt;/code&gt; no se usa para continuar l&amp;iacute;neas de c&amp;oacute;digo. En cambio, las expresiones incompletas contin&amp;uacute;an autom&amp;aacute;ticamente en la siguiente l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="5bdd69cd27046bb2e3189abcdf750e49518e8509" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;Ref&lt;/code&gt; objects are dereferenced (loaded or stored) with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">En Julia, los objetos &lt;code&gt;Ref&lt;/code&gt; se desreferencian (cargan o almacenan) con &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbe698f34efa48506b3a034b90fcbacaa3b44d79" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; produces &lt;code&gt;[1, 3]&lt;/code&gt;.</source>
          <target state="translated">En Julia, &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; produce &lt;code&gt;[1, 3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41c6478a96484907c7a62d3fc652aeb5cc697413" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; throws a &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt;&lt;code&gt;BoundsError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En Julia, &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; arroja un &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt; &lt;code&gt;BoundsError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0974da83f18cbcaffe16bb6459e3edda104c9151" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[x,y,z]&lt;/code&gt; will always construct a 3-element array containing &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">En Julia, &lt;code&gt;[x,y,z]&lt;/code&gt; siempre construir&amp;aacute; una matriz de 3 elementos que contenga &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d138a3241eb075445bbb09d48ceedbc03b1d34e" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;a:b&lt;/code&gt; and &lt;code&gt;a:b:c&lt;/code&gt; construct &lt;code&gt;AbstractRange&lt;/code&gt; objects. To construct a full vector like in MATLAB, use &lt;code&gt;collect(a:b)&lt;/code&gt;. Generally, there is no need to call &lt;code&gt;collect&lt;/code&gt; though. An &lt;code&gt;AbstractRange&lt;/code&gt; object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, or with iterators such as &lt;code&gt;enumerate&lt;/code&gt;, and &lt;code&gt;zip&lt;/code&gt;. The special objects can mostly be used as if they were normal arrays.</source>
          <target state="translated">En Julia, &lt;code&gt;a:b&lt;/code&gt; y &lt;code&gt;a:b:c&lt;/code&gt; construyen &lt;code&gt;AbstractRange&lt;/code&gt; objetos. Para construir un vector completo como en MATLAB, use &lt;code&gt;collect(a:b)&lt;/code&gt; . Generalmente, no es necesario llamar por &lt;code&gt;collect&lt;/code&gt; . Un objeto &lt;code&gt;AbstractRange&lt;/code&gt; actuar&amp;aacute; como una matriz normal en la mayor&amp;iacute;a de los casos, pero es m&amp;aacute;s eficiente porque calcula sus valores de forma perezosa. Este patr&amp;oacute;n de creaci&amp;oacute;n de objetos especializados en lugar de matrices completas se usa con frecuencia y tambi&amp;eacute;n se ve en funciones como &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; o con iteradores como &lt;code&gt;enumerate&lt;/code&gt; y &lt;code&gt;zip&lt;/code&gt; . Los objetos especiales se pueden utilizar principalmente como si fueran matrices normales.</target>
        </trans-unit>
        <trans-unit id="5622f51f1798995f4e2f17cefbf558acb8bdcceb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;return&lt;/code&gt; does not require parentheses.</source>
          <target state="translated">En Julia, la &lt;code&gt;return&lt;/code&gt; no requiere par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="c5612272a8f825cb7424d2a9deb9bd304a01ce42" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;x += y&lt;/code&gt; gets replaced during parsing by &lt;code&gt;x = x + y&lt;/code&gt;. For arrays, this has the consequence that, rather than storing the result in the same location in memory as &lt;code&gt;x&lt;/code&gt;, it allocates a new array to store the result.</source>
          <target state="translated">En Julia, &lt;code&gt;x += y&lt;/code&gt; se reemplaza durante el an&amp;aacute;lisis por &lt;code&gt;x = x + y&lt;/code&gt; . Para las matrices, esto tiene la consecuencia de que, en lugar de almacenar el resultado en la misma ubicaci&amp;oacute;n de la memoria que &lt;code&gt;x&lt;/code&gt; , asigna una nueva matriz para almacenar el resultado.</target>
        </trans-unit>
        <trans-unit id="40831d3e8b132da3257b046df4af0d9dab5df46c" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, because they can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b1700c001aef7c6e8210d638550d343b095441" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="translated">En Julia,una función es un objeto que asigna una tupla de valores de argumento a un valor de retorno.Las funciones de Julia no son funciones matemáticas puras,en el sentido de que las funciones pueden alterarse y ser afectadas por el estado global del programa.La sintaxis básica para definir funciones en Julia es:</target>
        </trans-unit>
        <trans-unit id="1c8982a95e255a5e2cc9c0e2345b6061fd0be88f" translate="yes" xml:space="preserve">
          <source>In Julia, a function may contain multiple concrete implementations (called &lt;em&gt;Methods&lt;/em&gt;), selected via multiple dispatch, whereas functions in Python have a single implementation (no polymorphism).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f670eb9f52ba71aa8ad7654d94717d406c50aa0" translate="yes" xml:space="preserve">
          <source>In Julia, a new local scope is introduced by most code blocks, including loops and &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;catch&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;. Note that comprehensions (list, generator, etc.) introduce a new local scope both in Python and Julia, whereas &lt;code&gt;if&lt;/code&gt; blocks do not introduce a new local scope in both languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9d45e10bb7e036a0e05a4d8d4376715db6b481" translate="yes" xml:space="preserve">
          <source>In Julia, a range like &lt;code&gt;a:b&lt;/code&gt; is not shorthand for a vector like in R, but is a specialized &lt;code&gt;AbstractRange&lt;/code&gt; object that is used for iteration without high memory overhead. To convert a range into a vector, use &lt;code&gt;collect(a:b)&lt;/code&gt;.</source>
          <target state="translated">En Julia, un rango como &lt;code&gt;a:b&lt;/code&gt; no es una abreviatura de un vector como en R, sino que es un objeto &lt;code&gt;AbstractRange&lt;/code&gt; especializado que se usa para la iteraci&amp;oacute;n sin una gran sobrecarga de memoria. Para convertir un rango en un vector, use &lt;code&gt;collect(a:b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40f5223023ecdb73df06f3b1a01d3f068c335d77" translate="yes" xml:space="preserve">
          <source>In Julia, all arguments to functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;passed by sharing&lt;/a&gt; (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a &lt;code&gt;!&lt;/code&gt; indicates that it will mutate or destroy the value of one or more of its arguments (compare, for example, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;). Callees must make explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non- mutating functions are implemented by calling a function of the same name with an added &lt;code&gt;!&lt;/code&gt; at the end on an explicit copy of the input, and returning that copy.</source>
          <target state="translated">En Julia, todos los argumentos de las funciones se &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;pasan compartiendo&lt;/a&gt; (es decir, mediante punteros). Algunos lenguajes de computaci&amp;oacute;n t&amp;eacute;cnica pasan las matrices por valor, y si bien esto evita la modificaci&amp;oacute;n accidental por parte de los destinatarios de un valor en el llamador, dificulta evitar la copia no deseada de matrices. Por convenci&amp;oacute;n, el nombre de una funci&amp;oacute;n que termina en &lt;code&gt;!&lt;/code&gt; indica que mutar&amp;aacute; o destruir&amp;aacute; el valor de uno o m&amp;aacute;s de sus argumentos (compare, por ejemplo, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt; ). Callees debe hacer copias expl&amp;iacute;citas para asegurarse de que no modifican entradas que no tienen la intenci&amp;oacute;n de cambiar. Muchas funciones no mutantes se implementan llamando a una funci&amp;oacute;n del mismo nombre con un a&amp;ntilde;adido &lt;code&gt;!&lt;/code&gt; al final en una copia expl&amp;iacute;cita de la entrada y devolviendo esa copia.</target>
        </trans-unit>
        <trans-unit id="9c3127614001f5fb915dc8fbc84746b3f3f27566" translate="yes" xml:space="preserve">
          <source>In Julia, an array &quot;slice&quot; expression like &lt;code&gt;array[1:5, :]&lt;/code&gt; creates a copy of that data (except on the left-hand side of an assignment, where &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; assigns in-place to that portion of &lt;code&gt;array&lt;/code&gt;). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.</source>
          <target state="translated">En Julia, una expresi&amp;oacute;n de &quot;corte&quot; de &lt;code&gt;array[1:5, :]&lt;/code&gt; como array [1: 5 ,: ] crea una copia de esos datos (excepto en el lado izquierdo de una asignaci&amp;oacute;n, donde &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; asigna en lugar de esa parte de la &lt;code&gt;array&lt;/code&gt; ). Si est&amp;aacute; realizando muchas operaciones en el segmento, esto puede ser bueno para el rendimiento porque es m&amp;aacute;s eficiente trabajar con una copia contigua m&amp;aacute;s peque&amp;ntilde;a de lo que ser&amp;iacute;a indexar en la matriz original. Por otro lado, si solo est&amp;aacute; realizando algunas operaciones simples en el segmento, el costo de las operaciones de asignaci&amp;oacute;n y copia puede ser sustancial.</target>
        </trans-unit>
        <trans-unit id="3012ec15c747cb5e8c8ab3cbb7a1be0e9f5c2879" translate="yes" xml:space="preserve">
          <source>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</source>
          <target state="translated">En Julia,exceder el máximo valor representable de un tipo dado resulta en un comportamiento envolvente:</target>
        </trans-unit>
        <trans-unit id="64ca87b8c062eb3ffaa0f39bec7e937ad18a966d" translate="yes" xml:space="preserve">
          <source>In Julia, if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are arrays, logical comparison operations like &lt;code&gt;A == B&lt;/code&gt; do not return an array of booleans. Instead, use &lt;code&gt;A .== B&lt;/code&gt;, and similarly for the other boolean operators like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">En Julia, si &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; son matrices, las operaciones de comparaci&amp;oacute;n l&amp;oacute;gica como &lt;code&gt;A == B&lt;/code&gt; no devuelven una matriz de valores booleanos. En su lugar, use &lt;code&gt;A .== B&lt;/code&gt; , y de manera similar para los otros operadores booleanos como &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d1570d580f73be0193694bd4c3eb228fc48008c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing a matrix with arrays like &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; refers to a sub-matrix that contains the intersections of the first and second rows with the first and third columns. In Python, &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; refers to a vector that contains the values of cell &lt;code&gt;[1,1]&lt;/code&gt; and &lt;code&gt;[2,3]&lt;/code&gt; in the matrix. &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; in Julia is equivalent with &lt;code&gt;X[np.ix_([0,1],[0,2])]&lt;/code&gt; in Python. &lt;code&gt;X[[0,1], [0,2]]&lt;/code&gt; in Python is equivalent with &lt;code&gt;X[[CartesianIndex(1,1), CartesianIndex(2,3)]]&lt;/code&gt; in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d922f5b73911084e1798e1fbea58a0f20f71a33c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</source>
          <target state="translated">En Julia,la indexación de matrices,cuerdas,etc.se basa en 1 y no en 0.</target>
        </trans-unit>
        <trans-unit id="06df6596eaa7007459b69a3e35309023ab071dc0" translate="yes" xml:space="preserve">
          <source>In Julia, like Python but unlike R, strings can be created with triple quotes &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;. This syntax is convenient for constructing strings that contain line breaks.</source>
          <target state="translated">En Julia, como Python pero a diferencia de R, las cadenas se pueden crear con comillas triples &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; . Esta sintaxis es conveniente para construir cadenas que contienen saltos de l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="6ff09f4efca3c4661d730a90a1c75212c7df44ad" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b7771804f2b70605beeefa21f23d88e1f845ae" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="translated">En Julia, los n&amp;uacute;meros literales sin un punto decimal (como &lt;code&gt;42&lt;/code&gt; ) crean n&amp;uacute;meros enteros en lugar de n&amp;uacute;meros de punto flotante. Como resultado, algunas operaciones pueden generar un error de dominio si esperan un flotante; por ejemplo, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; arroja un error de dominio, ya que el resultado no es un n&amp;uacute;mero entero (consulte &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;la entrada de preguntas frecuentes sobre errores de dominio&lt;/a&gt; para obtener m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="abe9d8d534555f871e47223b8068b11086c34b86" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create signed integers, of type &lt;code&gt;Int&lt;/code&gt;, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as &lt;code&gt;Int64&lt;/code&gt; (if &lt;code&gt;Int&lt;/code&gt; is &lt;code&gt;Int32&lt;/code&gt;), &lt;code&gt;Int128&lt;/code&gt;, or the arbitrarily large &lt;code&gt;BigInt&lt;/code&gt; type. There are no numeric literal suffixes, such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;LL&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;UL&lt;/code&gt;, &lt;code&gt;ULL&lt;/code&gt; to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with &lt;code&gt;0x&lt;/code&gt; like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the &lt;em&gt;length&lt;/em&gt; of the literal, including leading 0s. For example, &lt;code&gt;0x0&lt;/code&gt; and &lt;code&gt;0x00&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;0x000&lt;/code&gt; and &lt;code&gt;0x0000&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, then literals with 5 to 8 hex digits have type &lt;code&gt;UInt32&lt;/code&gt;, 9 to 16 hex digits type &lt;code&gt;UInt64&lt;/code&gt; and 17 to 32 hex digits type &lt;code&gt;UInt128&lt;/code&gt;. This needs to be taken into account when defining hexadecimal masks, for example &lt;code&gt;~0xf == 0xf0&lt;/code&gt; is very different from &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt;. 64 bit &lt;code&gt;Float64&lt;/code&gt; and 32 bit &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; bit literals are expressed as &lt;code&gt;1.0&lt;/code&gt; and &lt;code&gt;1.0f0&lt;/code&gt; respectively. Floating point literals are rounded (and not promoted to the &lt;code&gt;BigFloat&lt;/code&gt; type) if they can not be exactly represented. Floating point literals are closer in behavior to C/C++. Octal (prefixed with &lt;code&gt;0o&lt;/code&gt;) and binary (prefixed with &lt;code&gt;0b&lt;/code&gt;) literals are also treated as unsigned.</source>
          <target state="translated">En Julia, los n&amp;uacute;meros literales sin un punto decimal (como &lt;code&gt;42&lt;/code&gt; ) crean enteros con signo, de tipo &lt;code&gt;Int&lt;/code&gt; , pero los literales demasiado grandes para caber en el tama&amp;ntilde;o de la palabra de la m&amp;aacute;quina se promover&amp;aacute;n autom&amp;aacute;ticamente a un tipo de tama&amp;ntilde;o mayor, como &lt;code&gt;Int64&lt;/code&gt; (si &lt;code&gt;Int&lt;/code&gt; es &lt;code&gt;Int32&lt;/code&gt; ), &lt;code&gt;Int128&lt;/code&gt; o el tipo &lt;code&gt;BigInt&lt;/code&gt; arbitrariamente grande . No hay sufijos literales num&amp;eacute;ricos, como &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;LL&lt;/code&gt; , &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , &lt;code&gt;ULL&lt;/code&gt; para indicar sin firmar y / o firmado frente a sin firmar. Los literales decimales siempre est&amp;aacute;n firmados y los literales hexadecimales (que comienzan con &lt;code&gt;0x&lt;/code&gt; como C / C ++), no est&amp;aacute;n firmados. Los literales hexadecimales tambi&amp;eacute;n, a diferencia de C / C ++ / Java y a diferencia de los literales decimales en Julia, tienen un tipo basado en la &lt;em&gt;longitud&lt;/em&gt; del literal, incluidos los ceros iniciales. Por ejemplo, &lt;code&gt;0x0&lt;/code&gt; y &lt;code&gt;0x00&lt;/code&gt; tienen el tipo &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;0x000&lt;/code&gt; y &lt;code&gt;0x0000&lt;/code&gt; tienen el tipo &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt; , luego los literales con 5 a 8 d&amp;iacute;gitos hexadecimales tienen el tipo &lt;code&gt;UInt32&lt;/code&gt; , 9 a 16 d&amp;iacute;gitos hexadecimales tipo &lt;code&gt;UInt64&lt;/code&gt; y 17 a 32 d&amp;iacute;gitos hexadecimales tipo &lt;code&gt;UInt128&lt;/code&gt; . Esto debe tenerse en cuenta al definir m&amp;aacute;scaras hexadecimales, por ejemplo, &lt;code&gt;~0xf == 0xf0&lt;/code&gt; es muy diferente de &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt; . 64 bits &lt;code&gt;Float64&lt;/code&gt; y &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt; bit de 32 bits se expresan como &lt;code&gt;1.0&lt;/code&gt; y &lt;code&gt;1.0f0&lt;/code&gt; respectivamente. Los literales de coma flotante se redondean (y no se promueven al tipo &lt;code&gt;BigFloat&lt;/code&gt; ) si no se pueden representar con exactitud. Los literales de punto flotante tienen un comportamiento m&amp;aacute;s parecido al de C / C ++. Los literales octales (con el prefijo &lt;code&gt;0o&lt;/code&gt; ) y binarios (con el prefijo &lt;code&gt;0b&lt;/code&gt; ) tambi&amp;eacute;n se tratan como sin firmar.</target>
        </trans-unit>
        <trans-unit id="bdfe6baa0b2a1067c27d35abb55f2ee6ec449a3c" translate="yes" xml:space="preserve">
          <source>In Julia, missing values are represented by the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object rather than by &lt;code&gt;NA&lt;/code&gt;. Use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;ismissing.(x)&lt;/code&gt; for element-wise operation on vectors) instead of &lt;code&gt;is.na(x)&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function is generally used instead of &lt;code&gt;na.rm=TRUE&lt;/code&gt; (though in some particular cases functions take a &lt;code&gt;skipmissing&lt;/code&gt; argument).</source>
          <target state="translated">En Julia, los valores perdidos est&amp;aacute;n representados por el objeto &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; lugar de &lt;code&gt;NA&lt;/code&gt; . Utilice &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt; (o &lt;code&gt;ismissing.(x)&lt;/code&gt; para la operaci&amp;oacute;n de elementos en vectores) en lugar de &lt;code&gt;is.na(x)&lt;/code&gt; . La funci&amp;oacute;n de &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; se usa generalmente en lugar de &lt;code&gt;na.rm=TRUE&lt;/code&gt; (aunque en algunos casos particulares las funciones toman un argumento de &lt;code&gt;skipmissing&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c2883abece45992fb07a9eafea704ad64c7847f2" translate="yes" xml:space="preserve">
          <source>In Julia, modulus is &lt;code&gt;mod(a, b)&lt;/code&gt;, not &lt;code&gt;a %% b&lt;/code&gt;. &lt;code&gt;%&lt;/code&gt; in Julia is the remainder operator.</source>
          <target state="translated">En Julia, el m&amp;oacute;dulo es &lt;code&gt;mod(a, b)&lt;/code&gt; , no &lt;code&gt;a %% b&lt;/code&gt; . &lt;code&gt;%&lt;/code&gt; en Julia es el operador restante.</target>
        </trans-unit>
        <trans-unit id="d79893a1ef0fe5a790c5d1bb686e33bb258470f4" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e2622d04790dce54d4881a8ca271df72d322df7" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="translated">En Julia, la mayor&amp;iacute;a de los operadores son solo funciones con soporte para sintaxis especial. (Las excepciones son operadores con sem&amp;aacute;ntica de evaluaci&amp;oacute;n especial como &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; . Estos operadores no pueden ser funciones ya que la &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;evaluaci&amp;oacute;n de cortocircuito&lt;/a&gt; requiere que sus operandos no se eval&amp;uacute;en antes de la evaluaci&amp;oacute;n del operador). En consecuencia, tambi&amp;eacute;n puede aplicarlos usando listas de argumentos entre par&amp;eacute;ntesis , como lo har&amp;iacute;a con cualquier otra funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="cec708186271fab31b28911da66c39fb5ef32d0d" translate="yes" xml:space="preserve">
          <source>In Julia, multiple values are returned and assigned as tuples, e.g. &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; or &lt;code&gt;a, b = 1, 2&lt;/code&gt;. MATLAB's &lt;code&gt;nargout&lt;/code&gt;, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.</source>
          <target state="translated">En Julia, se devuelven m&amp;uacute;ltiples valores y se asignan como tuplas, p. Ej. &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; o &lt;code&gt;a, b = 1, 2&lt;/code&gt; . El &lt;code&gt;nargout&lt;/code&gt; de MATLAB , que a menudo se usa en MATLAB para realizar un trabajo opcional basado en el n&amp;uacute;mero de valores devueltos, no existe en Julia. En su lugar, los usuarios pueden utilizar argumentos opcionales y de palabras clave para lograr capacidades similares.</target>
        </trans-unit>
        <trans-unit id="4f6861a8c923af27ce752544647b06d9e6a0a07e" translate="yes" xml:space="preserve">
          <source>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</source>
          <target state="translated">En Julia,no todas las estructuras de datos soportan una indexación lógica.Además,la indexación lógica en Julia se apoya sólo con vectores de longitud igual al objeto que se indexa.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="451c3e5bbe0419b361a11d608a26c62bcc892288" translate="yes" xml:space="preserve">
          <source>In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:</source>
          <target state="translated">En Julia,se devuelve una tupla de valores para simular el retorno de múltiples valores.Sin embargo,las tuplas pueden ser creadas y desestructuradas sin necesidad de paréntesis,proporcionando así la ilusión de que se están devolviendo múltiples valores,en lugar de un único valor de tupla.Por ejemplo,la siguiente función devuelve un par de valores:</target>
        </trans-unit>
        <trans-unit id="d1f236e7a8645aa4ffbd134429aa159fdbc206da" translate="yes" xml:space="preserve">
          <source>In Julia, parentheses must be used to call a function with zero arguments, like in &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En Julia, se deben usar par&amp;eacute;ntesis para llamar a una funci&amp;oacute;n con cero argumentos, como en &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b62993ba8b73165f19053f9f6eaf87bfbe97454f" translate="yes" xml:space="preserve">
          <source>In Julia, reductions such as &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; are performed over every element of an array when called with a single argument, as in &lt;code&gt;sum(A)&lt;/code&gt;, even if &lt;code&gt;A&lt;/code&gt; has more than one dimension.</source>
          <target state="translated">En Julia, las reducciones como &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; se realizan sobre cada elemento de una matriz cuando se llama con un solo argumento, como en &lt;code&gt;sum(A)&lt;/code&gt; , incluso si &lt;code&gt;A&lt;/code&gt; tiene m&amp;aacute;s de una dimensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6b1973243505286be855fb241367233be8bd84fa" translate="yes" xml:space="preserve">
          <source>In Julia, sparse matrices are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;Compressed Sparse Column (CSC) format&lt;/a&gt;. Julia sparse matrices have the type &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Tv&lt;/code&gt; is the type of the stored values, and &lt;code&gt;Ti&lt;/code&gt; is the integer type for storing column pointers and row indices. The internal representation of &lt;code&gt;SparseMatrixCSC&lt;/code&gt; is as follows:</source>
          <target state="translated">En Julia, las matrices dispersas se almacenan en el &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;formato de columna dispersa comprimida (CSC)&lt;/a&gt; . Las matrices dispersas de Julia tienen el tipo &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt; &lt;/a&gt; , donde &lt;code&gt;Tv&lt;/code&gt; es el tipo de los valores almacenados y &lt;code&gt;Ti&lt;/code&gt; es el tipo entero para almacenar punteros de columna e &amp;iacute;ndices de fila. La representaci&amp;oacute;n interna de &lt;code&gt;SparseMatrixCSC&lt;/code&gt; es la siguiente:</target>
        </trans-unit>
        <trans-unit id="a5c3c759720c16030d42ce9ed7346415b8cda62d" translate="yes" xml:space="preserve">
          <source>In Julia, the &lt;code&gt;adjoint&lt;/code&gt; function performs conjugate transposition; in MATLAB, &lt;code&gt;adjoint&lt;/code&gt; provides the &quot;adjugate&quot; or classical adjoint, which is the transpose of the matrix of cofactors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8bc1ec2e65356b67489d496d41c529e84e8334" translate="yes" xml:space="preserve">
          <source>In Julia, the binding of a variable &lt;code&gt;x&lt;/code&gt; cannot be changed by passing &lt;code&gt;x&lt;/code&gt; as an argument to a function. When calling &lt;code&gt;change_value!(x)&lt;/code&gt; in the above example, &lt;code&gt;y&lt;/code&gt; is a newly created variable, bound initially to the value of &lt;code&gt;x&lt;/code&gt;, i.e. &lt;code&gt;10&lt;/code&gt;; then &lt;code&gt;y&lt;/code&gt; is rebound to the constant &lt;code&gt;17&lt;/code&gt;, while the variable &lt;code&gt;x&lt;/code&gt; of the outer scope is left untouched.</source>
          <target state="translated">En Julia, la vinculaci&amp;oacute;n de una variable &lt;code&gt;x&lt;/code&gt; no se puede cambiar pasando &lt;code&gt;x&lt;/code&gt; como argumento a una funci&amp;oacute;n. Al llamar &lt;code&gt;change_value!(x)&lt;/code&gt; en el ejemplo anterior, &lt;code&gt;y&lt;/code&gt; es una variable reci&amp;eacute;n creada, vinculada inicialmente al valor de &lt;code&gt;x&lt;/code&gt; , es decir, &lt;code&gt;10&lt;/code&gt; ; luego &lt;code&gt;y&lt;/code&gt; se recupera a la constante &lt;code&gt;17&lt;/code&gt; , mientras que la variable &lt;code&gt;x&lt;/code&gt; del alcance externo se deja intacta.</target>
        </trans-unit>
        <trans-unit id="e2d42d83a28f2989051e64390c6b07102af77a3d" translate="yes" xml:space="preserve">
          <source>In Julia, the commonly used &lt;code&gt;Int&lt;/code&gt; type corresponds to the machine integer type (&lt;code&gt;Int32&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt;), unlike in Python, where &lt;code&gt;int&lt;/code&gt; is an arbitrary length integer. This means in Julia the &lt;code&gt;Int&lt;/code&gt; type will overflow, such that &lt;code&gt;2^64 == 0&lt;/code&gt;. If you need larger values use another appropriate type, such as &lt;code&gt;Int128&lt;/code&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or a floating point type like &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad2abcec621eb10f8cdb25e242afd4f9efd6dd1" translate="yes" xml:space="preserve">
          <source>In Julia, the elements of a collection can be passed as arguments to a function using the splat operator &lt;code&gt;...&lt;/code&gt;, as in &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt;.</source>
          <target state="translated">En Julia, los elementos de una colecci&amp;oacute;n se pueden pasar como argumentos a una funci&amp;oacute;n usando el operador splat &lt;code&gt;...&lt;/code&gt; , como en &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d494edc49792467615a5bbbdd57215d8dd338e99" translate="yes" xml:space="preserve">
          <source>In Julia, the exponentiation operator is &lt;code&gt;^&lt;/code&gt;, not &lt;code&gt;**&lt;/code&gt; as in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d049ffcb952000d0f8ebc0a66e0ee55d575d87" translate="yes" xml:space="preserve">
          <source>In Julia, the operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) performs the bitwise XOR operation, i.e. &lt;code&gt;^&lt;/code&gt; in C/C++. Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</source>
          <target state="translated">En Julia, el operador &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; ) realiza la operaci&amp;oacute;n XOR bit a bit, es decir, &lt;code&gt;^&lt;/code&gt; en C / C ++. Adem&amp;aacute;s, los operadores bit a bit no tienen la misma precedencia que C / ++, por lo que pueden ser necesarios par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="8490fa684242627635a34751122775551824f7e6" translate="yes" xml:space="preserve">
          <source>In Julia, the operators &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) perform the bitwise operations equivalent to &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;xor&lt;/code&gt; respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of &lt;code&gt;A&lt;/code&gt; equal to 1 or 2 use &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt;).</source>
          <target state="translated">En Julia, los operadores &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;|&lt;/code&gt; , y &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt; ) realizan las operaciones bit a bit equivalentes a &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , y &lt;code&gt;xor&lt;/code&gt; respectivamente en MATLAB, y tienen una precedencia similar a los operadores bit a bit de Python (a diferencia de C). Pueden operar en escalares o en elementos a trav&amp;eacute;s de arreglos y se pueden usar para combinar arreglos l&amp;oacute;gicos, pero tenga en cuenta la diferencia en el orden de las operaciones: es posible que se requieran par&amp;eacute;ntesis (por ejemplo, para seleccionar elementos de &lt;code&gt;A&lt;/code&gt; igual a 1 o 2 uso &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e2a4d55a36175a20161ae921b2cf660cd6f7ede" translate="yes" xml:space="preserve">
          <source>In Julia, the standard operators over a matrix type are matrix operations, whereas, in Python, the standard operators are element-wise operations. When both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, &lt;code&gt;A * B&lt;/code&gt; in Julia performs matrix multiplication, not element-wise multiplication as in Python. &lt;code&gt;A * B&lt;/code&gt; in Julia is equivalent with &lt;code&gt;A @ B&lt;/code&gt; in Python, whereas &lt;code&gt;A * B&lt;/code&gt; in Python is equivalent with &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c924b695c23524838be4cdefba6d4ecf3f12bd7f" translate="yes" xml:space="preserve">
          <source>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</source>
          <target state="translated">En Julia,los valores no se copian cuando se asignan o pasan a una función.Si una función modifica una matriz,los cambios serán visibles en el llamador.Esto es muy diferente de R y permite que las nuevas funciones operen en grandes estructuras de datos de manera mucho más eficiente.</target>
        </trans-unit>
        <trans-unit id="4125f91a0372e71681729284bfb74b1b5f121b87" translate="yes" xml:space="preserve">
          <source>In Julia, varargs are specified using the splat operator &lt;code&gt;...&lt;/code&gt;, which always follows the name of a specific variable, unlike R, for which &lt;code&gt;...&lt;/code&gt; can occur in isolation.</source>
          <target state="translated">En Julia, los varargs se especifican usando el operador splat &lt;code&gt;...&lt;/code&gt; , que siempre sigue al nombre de una variable espec&amp;iacute;fica, a diferencia de R, para la cual &lt;code&gt;...&lt;/code&gt; puede ocurrir de forma aislada.</target>
        </trans-unit>
        <trans-unit id="61706e2cf7e3e0b63c2023adcea629882d9748dd" translate="yes" xml:space="preserve">
          <source>In Julia, vectors and matrices are concatenated using &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;rbind&lt;/code&gt; and &lt;code&gt;cbind&lt;/code&gt; like in R.</source>
          <target state="translated">En Julia, los vectores y las matrices se concatenan usando &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; &lt;/a&gt; , no &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;rbind&lt;/code&gt; y &lt;code&gt;cbind&lt;/code&gt; como en R.</target>
        </trans-unit>
        <trans-unit id="c15bdde6dec6d1761a5dc60f223d32d1ac186e83" translate="yes" xml:space="preserve">
          <source>In Julia, we can access the parts independently to make a copy of that string:</source>
          <target state="translated">En Julia,podemos acceder a las partes de forma independiente para hacer una copia de esa cadena:</target>
        </trans-unit>
        <trans-unit id="8bbe2d9f25b242e167641a97cc1e17c904778314" translate="yes" xml:space="preserve">
          <source>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</source>
          <target state="translated">En Julia,el espacio en blanco es significativo,a diferencia de C/C++,así que hay que tener cuidado al añadir/eliminar espacios en blanco de un programa de Julia.</target>
        </trans-unit>
        <trans-unit id="dfd2a6192ce5ab720952e7ded70bfe43e1c2837a" translate="yes" xml:space="preserve">
          <source>In Julia, you can't dispatch on a &lt;em&gt;value&lt;/em&gt; such as &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. However, you can dispatch on parametric types, and Julia allows you to include &quot;plain bits&quot; values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters. A common example is the dimensionality parameter in &lt;code&gt;Array{T,N}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type (e.g., &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;) but &lt;code&gt;N&lt;/code&gt; is just an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">En Julia, no se puede enviar con un &lt;em&gt;valor&lt;/em&gt; como &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; . Sin embargo, puede distribuir en tipos param&amp;eacute;tricos, y Julia le permite incluir valores de &quot;bits simples&quot; (tipos, s&amp;iacute;mbolos, enteros, n&amp;uacute;meros de coma flotante, tuplas, etc.) como par&amp;aacute;metros de tipo. Un ejemplo com&amp;uacute;n es el par&amp;aacute;metro de dimensionalidad en &lt;code&gt;Array{T,N}&lt;/code&gt; , donde &lt;code&gt;T&lt;/code&gt; es un tipo (por ejemplo, &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ) pero &lt;code&gt;N&lt;/code&gt; es solo un &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0987332b373dba2f6dccb678d104e0da95c47a9e" translate="yes" xml:space="preserve">
          <source>In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; or in the statement &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">En MATLAB, una forma idiom&amp;aacute;tica de eliminar valores no deseados es utilizar la indexaci&amp;oacute;n l&amp;oacute;gica, como en la expresi&amp;oacute;n &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; o en la declaraci&amp;oacute;n &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; para modificar &lt;code&gt;x&lt;/code&gt; en el lugar. En contraste, Julia proporciona el &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; funciones de orden superior . , lo que permite a los usuarios escribir &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; y &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; como alternativas a las transliteraciones correspondientes &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; y &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; . &amp;iexcl;Usando &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;reduce el uso de matrices temporales.</target>
        </trans-unit>
        <trans-unit id="af1c31248c4802059b749cc923a13d7acffd80c9" translate="yes" xml:space="preserve">
          <source>In Python, the majority of values can be used in logical contexts (e.g. &lt;code&gt;if &quot;a&quot;:&lt;/code&gt; means the following block is executed, and &lt;code&gt;if &quot;&quot;:&lt;/code&gt; means it is not). In Julia, you need explicit conversion to &lt;code&gt;Bool&lt;/code&gt; (e.g. &lt;code&gt;if &quot;a&quot;&lt;/code&gt; throws an exception). If you want to test for a non-empty string in Julia, you would explicitly write &lt;code&gt;if !isempty(&quot;&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e02ea871ca138515cbf18e7481d0fb87b2d5244" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">En R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; es equivalente a &lt;code&gt;c(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="616e3b4685be805ef30bd44974ee4d2b22ae8fea" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">En R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; es equivalente &lt;code&gt;c(1, 3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0a60c169bc6c80688de200a5cb77dbd4fa3448" translate="yes" xml:space="preserve">
          <source>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; or in the statement &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">En R, una forma idiom&amp;aacute;tica de eliminar valores no deseados es usar la indexaci&amp;oacute;n l&amp;oacute;gica, como en la expresi&amp;oacute;n &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; o en la declaraci&amp;oacute;n &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; para modificar &lt;code&gt;x&lt;/code&gt; in situ. En contraste, Julia proporciona el &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt; funciones de orden superior . , lo que permite a los usuarios escribir &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; y &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; como alternativas a las transliteraciones correspondientes &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; y &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; . &amp;iexcl;Usando &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;reduce el uso de matrices temporales.</target>
        </trans-unit>
        <trans-unit id="f6752ab2f8e0e7630531a6d7a1987e0bbb17b890" translate="yes" xml:space="preserve">
          <source>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</source>
          <target state="translated">En R,el rendimiento requiere vectorización.En Julia,ocurre casi lo contrario:el código de mejor rendimiento se logra a menudo utilizando bucles desviados.</target>
        </trans-unit>
        <trans-unit id="01878b8d1b390512d629c49ff65589c19ca63ad8" translate="yes" xml:space="preserve">
          <source>In a linear-algebra context, this means that even though operations like &lt;code&gt;vector + vector&lt;/code&gt; and &lt;code&gt;vector * scalar&lt;/code&gt; are defined, it can be advantageous to instead use &lt;code&gt;vector .+ vector&lt;/code&gt; and &lt;code&gt;vector .* scalar&lt;/code&gt; because the resulting loops can be fused with surrounding computations. For example, consider the two functions:</source>
          <target state="translated">En un contexto de &amp;aacute;lgebra lineal, esto significa que aunque se definen operaciones como &lt;code&gt;vector + vector&lt;/code&gt; y &lt;code&gt;vector * scalar&lt;/code&gt; , puede ser ventajoso usar &lt;code&gt;vector .+ vector&lt;/code&gt; y &lt;code&gt;vector .* scalar&lt;/code&gt; porque los bucles resultantes se pueden fusionar con c&amp;aacute;lculos circundantes . Por ejemplo, considere las dos funciones:</target>
        </trans-unit>
        <trans-unit id="9e1d6d725f550ad6f9da6bf98cc247f18f2108d6" translate="yes" xml:space="preserve">
          <source>In a local scope, all variables are inherited from its parent global scope block unless:</source>
          <target state="translated">En un ámbito local,todas las variables se heredan de su bloque padre de ámbito global a menos que:</target>
        </trans-unit>
        <trans-unit id="8fb94127a63695dc8bd7c2b91c9aa1704119e38b" translate="yes" xml:space="preserve">
          <source>In a module, declare that the file specified by &lt;code&gt;path&lt;/code&gt; (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</source>
          <target state="translated">En un m&amp;oacute;dulo, declare que el archivo especificado por la &lt;code&gt;path&lt;/code&gt; (relativa o absoluta) es una dependencia para la precompilaci&amp;oacute;n; es decir, ser&amp;aacute; necesario volver a compilar el m&amp;oacute;dulo si este archivo cambia.</target>
        </trans-unit>
        <trans-unit id="ba39320cdec145895823bcc997669a25a6af7855" translate="yes" xml:space="preserve">
          <source>In a sense, Julia falls into the &quot;no automatic promotion&quot; category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch &amp;ndash; something which Julia's dispatch and type systems are particularly well-suited to handle. &quot;Automatic&quot; promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</source>
          <target state="translated">En cierto sentido, Julia cae en la categor&amp;iacute;a &quot;sin promoci&amp;oacute;n autom&amp;aacute;tica&quot;: los operadores matem&amp;aacute;ticos son solo funciones con una sintaxis especial y los argumentos de las funciones nunca se convierten autom&amp;aacute;ticamente. Sin embargo, se puede observar que aplicar operaciones matem&amp;aacute;ticas a una amplia variedad de tipos de argumentos mixtos es solo un caso extremo de env&amp;iacute;o m&amp;uacute;ltiple polim&amp;oacute;rfico, algo para lo que los sistemas de env&amp;iacute;o y tipo de Julia son particularmente adecuados para manejar. La promoci&amp;oacute;n &quot;autom&amp;aacute;tica&quot; de operandos matem&amp;aacute;ticos simplemente surge como una aplicaci&amp;oacute;n especial: Julia viene con reglas predefinidas de distribuci&amp;oacute;n general para operadores matem&amp;aacute;ticos, invocadas cuando no existe una implementaci&amp;oacute;n espec&amp;iacute;fica para alguna combinaci&amp;oacute;n de tipos de operandos. Estas reglas generales primero promueven todos los operandos a un tipo com&amp;uacute;n utilizando reglas de promoci&amp;oacute;n definidas por el usuario,y luego invocar una implementaci&amp;oacute;n especializada del operador en cuesti&amp;oacute;n para los valores resultantes, ahora del mismo tipo. Los tipos definidos por el usuario pueden participar f&amp;aacute;cilmente en este sistema de promoci&amp;oacute;n definiendo m&amp;eacute;todos para la conversi&amp;oacute;n hacia y desde otros tipos, y proporcionando un pu&amp;ntilde;ado de reglas de promoci&amp;oacute;n que definen a qu&amp;eacute; tipos deben promocionar cuando se mezclan con otros tipos.</target>
        </trans-unit>
        <trans-unit id="c6a6dfe6183c6c2d1bbad1fc9762d95e2e3097dd" translate="yes" xml:space="preserve">
          <source>In a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair &lt;code&gt;name::Symbol =&amp;gt; value&lt;/code&gt; or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e44910a826a7be9fd86ad6a5c3ed3f73d517fa" translate="yes" xml:space="preserve">
          <source>In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with &lt;code&gt;using LinearAlgebra&lt;/code&gt;. Basic operations, such as &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;inv&lt;/code&gt; are all supported:</source>
          <target state="translated">Adem&amp;aacute;s de (y como parte de) su soporte para matrices multidimensionales, Julia proporciona implementaciones nativas de muchas operaciones de &amp;aacute;lgebra lineal comunes y &amp;uacute;tiles que se pueden cargar &lt;code&gt;using LinearAlgebra&lt;/code&gt; . Todas las operaciones b&amp;aacute;sicas, como &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt; &lt;code&gt;tr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; e &lt;code&gt;inv&lt;/code&gt; , son compatibles:</target>
        </trans-unit>
        <trans-unit id="f10487aa88c806dfd44fdee05bfc7281d910b478" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;, a few other basic functions are needed to use tasks effectively.</source>
          <target state="translated">Adem&amp;aacute;s de &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt; , se necesitan algunas otras funciones b&amp;aacute;sicas para utilizar las tareas de forma eficaz.</target>
        </trans-unit>
        <trans-unit id="f2ab7ee40bd53e11319399c116d8d2cc2c48169d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;using Base&lt;/code&gt;, modules also automatically contain definitions of the &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt; functions, which evaluate expressions/files within the global scope of that module.</source>
          <target state="translated">Adem&amp;aacute;s de &lt;code&gt;using Base&lt;/code&gt; , los m&amp;oacute;dulos tambi&amp;eacute;n contienen autom&amp;aacute;ticamente definiciones de &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; e &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt; funciones, que eval&amp;uacute;an expresiones / archivos dentro del alcance global de ese m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="10d21e803c8a9917ec9f0f6ebe5595e193060fc6" translate="yes" xml:space="preserve">
          <source>In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for &lt;code&gt;AbstractArrays&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de todos los m&amp;eacute;todos iterables e indexables de arriba, estos tipos tambi&amp;eacute;n pueden interactuar entre s&amp;iacute; y utilizar la mayor&amp;iacute;a de los m&amp;eacute;todos definidos en Julia Base para &lt;code&gt;AbstractArrays&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e406211c0c63c531f5fd9ccb75f3528a5be0658c" translate="yes" xml:space="preserve">
          <source>In addition to linear indexing, an &lt;code&gt;N&lt;/code&gt;-dimensional array may be indexed with fewer or more than &lt;code&gt;N&lt;/code&gt; indices in certain situations.</source>
          <target state="translated">Adem&amp;aacute;s de la indexaci&amp;oacute;n lineal, una matriz &lt;code&gt;N&lt;/code&gt; - dimensional puede indexarse ​​con menos o m&amp;aacute;s de &lt;code&gt;N&lt;/code&gt; &amp;iacute;ndices en determinadas situaciones.</target>
        </trans-unit>
        <trans-unit id="98e86e056613a088089dad092fe39f17f798108b" translate="yes" xml:space="preserve">
          <source>In addition to tasks Julia forwards natively supports multi-threading. Note that this section is experimental and the interfaces may change in the future.</source>
          <target state="translated">Además de las tareas que Julia realiza,apoya nativamente el multihilo.Tenga en cuenta que esta sección es experimental y las interfaces pueden cambiar en el futuro.</target>
        </trans-unit>
        <trans-unit id="ec666f0e17f38401053d73ee95bfc69ad9a82cc3" translate="yes" xml:space="preserve">
          <source>In addition to the given argument list, every macro is passed extra arguments named &lt;code&gt;__source__&lt;/code&gt; and &lt;code&gt;__module__&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de la lista de argumentos dada, a cada macro se le pasan argumentos adicionales llamados &lt;code&gt;__source__&lt;/code&gt; y &lt;code&gt;__module__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f681189a6c7a87dd61774b09673a55a0c0fa70a2" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24215bb3919d42188faab69329d0bd6705349ee5" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="translated">Adem&amp;aacute;s, Julia proporciona muchas &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;factorizaciones&lt;/a&gt; que se pueden utilizar para acelerar problemas como la resoluci&amp;oacute;n lineal o la exponenciaci&amp;oacute;n de la matriz al prefactorizar una matriz en una forma m&amp;aacute;s adecuada (por motivos de rendimiento o memoria) al problema. Consulte la documentaci&amp;oacute;n sobre &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n. Como ejemplo:</target>
        </trans-unit>
        <trans-unit id="655d29ad2536f5920e2f78273e9aa1a0a062ab22" translate="yes" xml:space="preserve">
          <source>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</source>
          <target state="translated">En todos los casos la ambigüedad se resuelve a favor de la interpretación como literales numéricos:</target>
        </trans-unit>
        <trans-unit id="73ededace2cf23e632ef0400ebd52a78d322cb00" translate="yes" xml:space="preserve">
          <source>In all of the above modes, the executed lines get saved to a history file, which can be searched. To initiate an incremental search through the previous history, type &lt;code&gt;^R&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;r&lt;/code&gt; key. The prompt will change to &lt;code&gt;(reverse-i-search)`':&lt;/code&gt;, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type &lt;code&gt;^R&lt;/code&gt; again.</source>
          <target state="translated">En todos los modos anteriores, las l&amp;iacute;neas ejecutadas se guardan en un archivo hist&amp;oacute;rico, que se puede buscar. Para iniciar una b&amp;uacute;squeda incremental a trav&amp;eacute;s del historial anterior, escriba &lt;code&gt;^R&lt;/code&gt; - la tecla de control junto con la tecla &lt;code&gt;r&lt;/code&gt; . El mensaje cambiar&amp;aacute; a &lt;code&gt;(reverse-i-search)`':&lt;/code&gt; , y mientras escribe, la consulta de b&amp;uacute;squeda aparecer&amp;aacute; entre comillas. El resultado m&amp;aacute;s reciente que coincide con la consulta se actualizar&amp;aacute; din&amp;aacute;micamente a la derecha de los dos puntos a medida que se escriba m&amp;aacute;s. Para encontrar un resultado anterior utilizando la misma consulta, simplemente escriba &lt;code&gt;^R&lt;/code&gt; nuevamente.</target>
        </trans-unit>
        <trans-unit id="486b6c3b28f75c69ec1138bc26e8cd5e151040ee" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; ultimately operates on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object, which is in charge of queueing and restarting tasks. When a task calls &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;, the task is marked as non-runnable, added to the condition's queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on the condition, which causes tasks waiting for that condition to become runnable again.</source>
          <target state="translated">En todos estos casos, la &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; finalmente opera en un objeto &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; , que se encarga de poner en cola y reiniciar las tareas. Cuando las llamadas de una tarea &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; en una &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; , la tarea se marca como no ejecutable, se agrega a la cola de la condici&amp;oacute;n y cambia al programador. El programador elegir&amp;aacute; entonces otra tarea para ejecutar o bloquear&amp;aacute; la espera de eventos externos. Si todo va bien, eventualmente un controlador de eventos llamar&amp;aacute; a &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt; sobre la condici&amp;oacute;n, lo que hace que las tareas que esperan esa condici&amp;oacute;n se vuelvan a ejecutar.</target>
        </trans-unit>
        <trans-unit id="a3a06ca6a5caa39934e953da1e9f4336d389c6e0" translate="yes" xml:space="preserve">
          <source>In all these cases, &lt;code&gt;x&lt;/code&gt; is bound to a tuple of the trailing values passed to &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">En todos estos casos, &lt;code&gt;x&lt;/code&gt; est&amp;aacute; vinculado a una tupla de los valores finales pasados ​​a &lt;code&gt;bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b99ce256d318c1c2f2354f48619a6804a821c4e0" translate="yes" xml:space="preserve">
          <source>In an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).</source>
          <target state="translated">En una topología de todo a todo (la predeterminada),todos los trabajadores se conectan entre sí a través de enchufes TCP simples.La política de seguridad de los nodos del clúster debe garantizar,por tanto,la libre conectividad entre los trabajadores para la efímera gama de puertos (varía según el sistema operativo).</target>
        </trans-unit>
        <trans-unit id="3c8cda3e1e2865b38c43f81658a24d808d5fe92a" translate="yes" xml:space="preserve">
          <source>In both Julia and MATLAB, the variable &lt;code&gt;ans&lt;/code&gt; is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, &lt;code&gt;ans&lt;/code&gt; is not set when Julia code is run in non-interactive mode.</source>
          <target state="translated">Tanto en Julia como en MATLAB, la variable &lt;code&gt;ans&lt;/code&gt; se establece en el valor de la &amp;uacute;ltima expresi&amp;oacute;n emitida en una sesi&amp;oacute;n interactiva. En Julia, a diferencia de MATLAB, &lt;code&gt;ans&lt;/code&gt; no se establece cuando el c&amp;oacute;digo de Julia se ejecuta en modo no interactivo.</target>
        </trans-unit>
        <trans-unit id="b8e4ada1bafffe80f21502163f1a66167c6265bb" translate="yes" xml:space="preserve">
          <source>In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:</source>
          <target state="translated">Tanto en el modo Julián como en el modo de ayuda de la REPL,se pueden introducir los primeros caracteres de una función o tipo y luego pulsar la tecla de tabulación para obtener una lista de todas las coincidencias:</target>
        </trans-unit>
        <trans-unit id="661336deabc49d6bd089fab9e0056b342efe5561" translate="yes" xml:space="preserve">
          <source>In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; on local instances of a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, or on unfetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Since calling &lt;code&gt;fetch&lt;/code&gt; on a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; also removes its reference from the remote store, this is not required on fetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Explicitly calling &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; results in an immediate message sent to the remote node to go ahead and remove its reference to the value.</source>
          <target state="translated">En el caso de referencias remotas, el tama&amp;ntilde;o del objeto de referencia local es bastante peque&amp;ntilde;o, mientras que el valor almacenado en el nodo remoto puede ser bastante grande. Dado que es posible que el objeto local no se recopile de inmediato, es una buena pr&amp;aacute;ctica llamar expl&amp;iacute;citamente a &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; en instancias locales de un &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; o en &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; s no recuperados . Dado que llamar a &lt;code&gt;fetch&lt;/code&gt; en un &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; tambi&amp;eacute;n elimina su referencia del almac&amp;eacute;n remoto, esto no es necesario en los &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; s recuperados . Llamar expl&amp;iacute;citamente a &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt; da como resultado un mensaje inmediato enviado al nodo remoto para continuar y eliminar su referencia al valor.</target>
        </trans-unit>
        <trans-unit id="bf07799a9aab60dca9abdd6af2de0083f4fd55f9" translate="yes" xml:space="preserve">
          <source>In cases where &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; would need to take a Julia object and turn it into a &lt;code&gt;Ptr&lt;/code&gt;, this function should be used to define and perform that conversion.</source>
          <target state="translated">En los casos en los que &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; ir&lt;/a&gt; necesitar&amp;iacute;a tomar un objeto Julia y convertirlo en un &lt;code&gt;Ptr&lt;/code&gt; , esta funci&amp;oacute;n debe usarse para definir y realizar esa conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="62d2a9fdaaf73a0db81376306b368d8784225fa7" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;x&lt;/code&gt; cannot be safely converted to &lt;code&gt;T&lt;/code&gt;, unlike &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;cconvert&lt;/code&gt; may return an object of a type different from &lt;code&gt;T&lt;/code&gt;, which however is suitable for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; to handle. The result of this function should be kept valid (for the GC) until the result of &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; is not needed anymore. This can be used to allocate memory that will be accessed by the &lt;code&gt;ccall&lt;/code&gt;. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</source>
          <target state="translated">En los casos en que &lt;code&gt;x&lt;/code&gt; no se puede convertir de forma segura a &lt;code&gt;T&lt;/code&gt; , a diferencia de &lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;cconvert&lt;/code&gt; puede devolver un objeto de un tipo diferente de &lt;code&gt;T&lt;/code&gt; , que sin embargo es adecuado para que &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; lo&lt;/a&gt; maneje. El resultado de esta funci&amp;oacute;n debe mantenerse v&amp;aacute;lido (para el GC) hasta que el resultado de &lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt; ya no sea necesario. Esto se puede utilizar para asignar memoria a la que acceder&amp;aacute; &lt;code&gt;ccall&lt;/code&gt; . Si es necesario asignar varios objetos, se puede usar una tupla de los objetos como valor de retorno.</target>
        </trans-unit>
        <trans-unit id="20a6a008693353a3bba07852d46b5ac7a61ffe13" translate="yes" xml:space="preserve">
          <source>In cases where you want to be able to mix multiple &lt;code&gt;AbstractArrayStyle&lt;/code&gt;s and keep track of dimensionality, your style needs to support a &lt;a href=&quot;../base/index#Base.Val&quot;&gt;&lt;code&gt;Val&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">En los casos en los que desee poder mezclar varios &lt;code&gt;AbstractArrayStyle&lt;/code&gt; sy realizar un seguimiento de la dimensionalidad, su estilo debe admitir un constructor &lt;a href=&quot;../base/index#Base.Val&quot;&gt; &lt;code&gt;Val&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="371183813ad83fb61979b332a5033cb1b76e325b" translate="yes" xml:space="preserve">
          <source>In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The &lt;code&gt;finally&lt;/code&gt; keyword provides a way to run some code when a given block of code exits, regardless of how it exits.</source>
          <target state="translated">En el c&amp;oacute;digo que realiza cambios de estado o utiliza recursos como archivos, normalmente hay un trabajo de limpieza (como cerrar archivos) que debe realizarse cuando el c&amp;oacute;digo est&amp;aacute; terminado. Las excepciones complican potencialmente esta tarea, ya que pueden hacer que un bloque de c&amp;oacute;digo salga antes de llegar a su final normal. La palabra clave &lt;code&gt;finally&lt;/code&gt; proporciona una forma de ejecutar c&amp;oacute;digo cuando un bloque de c&amp;oacute;digo determinado sale, independientemente de c&amp;oacute;mo salga.</target>
        </trans-unit>
        <trans-unit id="439d8b30359bbc8d6b7d18a09ea082d188e37311" translate="yes" xml:space="preserve">
          <source>In contrast to the use of the &lt;code&gt;...&lt;/code&gt; operator to denote slurping many different arguments into one argument when defining a function, the &lt;code&gt;...&lt;/code&gt; operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of &lt;code&gt;...&lt;/code&gt; is called splatting:</source>
          <target state="translated">En contraste con el uso del operador &lt;code&gt;...&lt;/code&gt; para denotar la incorporaci&amp;oacute;n de muchos argumentos diferentes en un argumento al definir una funci&amp;oacute;n, el operador &lt;code&gt;...&lt;/code&gt; tambi&amp;eacute;n se usa para hacer que un argumento de funci&amp;oacute;n &amp;uacute;nica se divida en muchos argumentos diferentes cuando se usa en el contexto de una llamada a funci&amp;oacute;n. Este uso de &lt;code&gt;...&lt;/code&gt; se llama salpicar:</target>
        </trans-unit>
        <trans-unit id="9c8f753b1f6a1a771efd3464599b303870131486" translate="yes" xml:space="preserve">
          <source>In contrast with &lt;code&gt;for i = 1:length(A)&lt;/code&gt;, iterating with &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; provides an efficient way to iterate over any array type.</source>
          <target state="translated">En contraste con &lt;code&gt;for i = 1:length(A)&lt;/code&gt; , la iteraci&amp;oacute;n con cada &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt; proporciona una forma eficiente de iterar sobre cualquier tipo de matriz.</target>
        </trans-unit>
        <trans-unit id="7142e8f2e408ab35102cc379780cf0e33b4e8234" translate="yes" xml:space="preserve">
          <source>In contrast, once &lt;code&gt;m&lt;/code&gt; is constructed, the type of &lt;code&gt;m.a&lt;/code&gt; cannot change:</source>
          <target state="translated">Por el contrario, una vez que se construye &lt;code&gt;m&lt;/code&gt; , el tipo de &lt;code&gt;m.a&lt;/code&gt; no puede cambiar:</target>
        </trans-unit>
        <trans-unit id="0d5137a043d33963d37d01766416ca959609cfd8" translate="yes" xml:space="preserve">
          <source>In general you can place a &lt;code&gt;return&lt;/code&gt; statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with &lt;code&gt;do&lt;/code&gt; blocks. For example:</source>
          <target state="translated">En general, puede colocar una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; cualquier lugar dentro del cuerpo de una funci&amp;oacute;n, incluso dentro de los bucles o condicionales profundamente anidados, pero tenga cuidado con los bloques &lt;code&gt;do&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c2d6d0431d403e66982fc3bf0664898813b75b58" translate="yes" xml:space="preserve">
          <source>In general, a broadcast operation is represented by a lazy &lt;code&gt;Broadcasted&lt;/code&gt; container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested &lt;code&gt;Broadcasted&lt;/code&gt; containers, forming a large expression tree to be evaluated. A nested tree of &lt;code&gt;Broadcasted&lt;/code&gt; containers is directly constructed by the implicit dot syntax; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; is transiently represented by &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt;, for example. This is invisible to users as it is immediately realized through a call to &lt;code&gt;copy&lt;/code&gt;, but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the &lt;code&gt;Broadcasted&lt;/code&gt; object into it with a default &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; method. The built-in fallback &lt;code&gt;broadcast&lt;/code&gt; and &lt;code&gt;broadcast!&lt;/code&gt; methods similarly construct a transient &lt;code&gt;Broadcasted&lt;/code&gt; representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own &lt;code&gt;copyto!&lt;/code&gt; specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the &lt;code&gt;Broadcasted&lt;/code&gt; type, allowing for dispatch and specialization.</source>
          <target state="translated">En general, una operaci&amp;oacute;n de transmisi&amp;oacute;n est&amp;aacute; representada por un contenedor de &lt;code&gt;Broadcasted&lt;/code&gt; diferida que retiene la funci&amp;oacute;n que se aplicar&amp;aacute; junto con sus argumentos. Esos argumentos pueden ser en s&amp;iacute; mismos contenedores &lt;code&gt;Broadcasted&lt;/code&gt; m&amp;aacute;s anidados , formando un gran &amp;aacute;rbol de expresi&amp;oacute;n para ser evaluado. Un &amp;aacute;rbol anidado de contenedores &lt;code&gt;Broadcasted&lt;/code&gt; se construye directamente mediante la sintaxis de punto impl&amp;iacute;cita; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; est&amp;aacute; representado transitoriamente por &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt; , por ejemplo. Esto es invisible para los usuarios, ya que se realiza de inmediato a trav&amp;eacute;s de una llamada para &lt;code&gt;copy&lt;/code&gt; , pero es este contenedor el que proporciona la base para la extensibilidad de la difusi&amp;oacute;n para los autores de tipos personalizados. La maquinaria de transmisi&amp;oacute;n incorporada determinar&amp;aacute; el tipo y tama&amp;ntilde;o del resultado en funci&amp;oacute;n de los argumentos, lo asignar&amp;aacute; y finalmente copiar&amp;aacute; la realizaci&amp;oacute;n del objeto &lt;code&gt;Broadcasted&lt;/code&gt; en &amp;eacute;l con un &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; predeterminado . &amp;iexcl;La &lt;code&gt;broadcast&lt;/code&gt; y la &lt;code&gt;broadcast!&lt;/code&gt; respaldo incorporadas ! m&amp;eacute;todos de manera similar construir un transitorio &lt;code&gt;Broadcasted&lt;/code&gt; representaci&amp;oacute;n de la operaci&amp;oacute;n para que puedan seguir el mismo c&amp;oacute;digo base. Esto permite que las implementaciones de matrices personalizadas proporcionen su propia &lt;code&gt;copyto!&lt;/code&gt; especializaci&amp;oacute;n para personalizar y optimizar la transmisi&amp;oacute;n. Esto est&amp;aacute; nuevamente determinado por el estilo de transmisi&amp;oacute;n calculado. Esta es una parte tan importante de la operaci&amp;oacute;n que se almacena como el primer par&amp;aacute;metro de tipo del tipo &lt;code&gt;Broadcasted&lt;/code&gt; , lo que permite el env&amp;iacute;o y la especializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8d1babd281f2e672316bf23dea36c5ab29827a0a" translate="yes" xml:space="preserve">
          <source>In general, if you have &lt;code&gt;N&lt;/code&gt; samples collected at a line, you can expect an uncertainty on the order of &lt;code&gt;sqrt(N)&lt;/code&gt; (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia's garbage collector is written in C, such events can be detected using the &lt;code&gt;C=true&lt;/code&gt; output mode described below, or by using &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;.)</source>
          <target state="translated">En general, si tiene &lt;code&gt;N&lt;/code&gt; muestras recolectadas en una l&amp;iacute;nea, puede esperar una incertidumbre del orden de &lt;code&gt;sqrt(N)&lt;/code&gt; (salvo otras fuentes de ruido, como qu&amp;eacute; tan ocupada est&amp;aacute; la computadora con otras tareas). La principal excepci&amp;oacute;n a esta regla es la recolecci&amp;oacute;n de basura, que se ejecuta con poca frecuencia pero tiende a ser bastante costosa. (Dado que el recolector de basura de Julia est&amp;aacute; escrito en C, tales eventos se pueden detectar usando el modo de salida &lt;code&gt;C=true&lt;/code&gt; que se describe a continuaci&amp;oacute;n, o usando &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="efbd7c168e8e9417f99b66ae892e749285151330" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;for&lt;/code&gt; loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;&amp;isin;&lt;/code&gt; is typically used instead of &lt;code&gt;=&lt;/code&gt;, since it makes the code read more clearly:</source>
          <target state="translated">En general, la construcci&amp;oacute;n de bucle &lt;code&gt;for&lt;/code&gt; puede iterar sobre cualquier contenedor. En estos casos, la palabra clave alternativa (pero totalmente equivalente) &lt;code&gt;in&lt;/code&gt; o &lt;code&gt;&amp;isin;&lt;/code&gt; generalmente se usa en lugar de &lt;code&gt;=&lt;/code&gt; , ya que hace que el c&amp;oacute;digo se lea con mayor claridad:</target>
        </trans-unit>
        <trans-unit id="e63801e02d1bdf10fcfad068986ce15007cba3d8" translate="yes" xml:space="preserve">
          <source>In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell's. The only difference is that the interpolation is integrated and aware of Julia's notion of what is a single string value, and what is a container for multiple values. Let's try the above two examples in Julia:</source>
          <target state="translated">En general,la sintaxis del backtick de Julia está cuidadosamente diseñada para que puedas cortar y pegar comandos de shell como en los backticks y funcionarán:los comportamientos de escape,cita e interpolación son los mismos que los del shell.La única diferencia es que la interpolación está integrada y es consciente de la noción de Julia de lo que es un valor de una sola cadena,y de lo que es un contenedor para múltiples valores.Probemos los dos ejemplos anteriores en Julia:</target>
        </trans-unit>
        <trans-unit id="e9d0a19dc1691ca7e9543783f1a58a636105f54f" translate="yes" xml:space="preserve">
          <source>In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.</source>
          <target state="translated">En general,a diferencia de muchos otros lenguajes de computación técnica,Julia no espera que los programas se escriban en un estilo vectorizado para el rendimiento.El compilador de Julia utiliza la inferencia de tipos y genera código optimizado para la indexación de arreglos escalares,permitiendo que los programas se escriban en un estilo que sea conveniente y legible,sin sacrificar el rendimiento,y usando menos memoria a veces.</target>
        </trans-unit>
        <trans-unit id="0aca2d8ec448ee15667ecd2efa9a783d316a76f6" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">En general, no puede suponer que la salida de la &lt;code&gt;display&lt;/code&gt; va a &lt;code&gt;stdout&lt;/code&gt; (a diferencia de &lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print(x)&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; ). Por ejemplo, la &lt;code&gt;display(x)&lt;/code&gt; puede abrir una ventana separada con una imagen. &lt;code&gt;display(x)&lt;/code&gt; significa &quot;mostrar &lt;code&gt;x&lt;/code&gt; de la mejor manera posible para los dispositivos de salida actuales&quot;. Si desea una salida de texto similar a REPL que est&amp;eacute; garantizada para ir a &lt;code&gt;stdout&lt;/code&gt; , use &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt; &lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="7ec09f4dcceb1c007da785592e4c12f3a7b2638d" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421d35772a37767957f94e34c887a2a8d79cd54e" translate="yes" xml:space="preserve">
          <source>In interpreting the results, there are a few important details. Under the &lt;code&gt;user&lt;/code&gt; setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia's compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt;&lt;/a&gt; to reset all allocation counters. Finally, execute the desired commands and quit Julia to trigger the generation of the &lt;code&gt;.mem&lt;/code&gt; files.</source>
          <target state="translated">Al interpretar los resultados, hay algunos detalles importantes. Bajo la configuraci&amp;oacute;n de &lt;code&gt;user&lt;/code&gt; , la primera l&amp;iacute;nea de cualquier funci&amp;oacute;n llamada directamente desde REPL exhibir&amp;aacute; asignaci&amp;oacute;n debido a eventos que suceden en el c&amp;oacute;digo REPL mismo. M&amp;aacute;s significativamente, la compilaci&amp;oacute;n JIT tambi&amp;eacute;n se suma a los recuentos de asignaciones, porque gran parte del compilador de Julia est&amp;aacute; escrito en Julia (y la compilaci&amp;oacute;n generalmente requiere asignaci&amp;oacute;n de memoria). El procedimiento recomendado es forzar la compilaci&amp;oacute;n ejecutando todos los comandos que desea analizar, luego llame a &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt; &lt;/a&gt; para restablecer todos los contadores de asignaci&amp;oacute;n. Finalmente, ejecute los comandos deseados y salga de Julia para activar la generaci&amp;oacute;n de los archivos &lt;code&gt;.mem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfcc306e80c7cf321f53ff98ff95ac030d502bfd" translate="yes" xml:space="preserve">
          <source>In loops and &lt;a href=&quot;../arrays/index#man-comprehensions&quot;&gt;comprehensions&lt;/a&gt;, new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a &lt;code&gt;let&lt;/code&gt; block, as demonstrated by this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b38f63219b850b33b9abc3b16ad8edd611a5f30" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e2766644f11aec36d4590582770e2731974fc5" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="translated">En los lenguajes orientados a objetos convencionales, como C ++, Java, Python y Ruby, los tipos compuestos tambi&amp;eacute;n tienen funciones con nombre asociadas, y la combinaci&amp;oacute;n se denomina &quot;objeto&quot;. En lenguajes orientados a objetos m&amp;aacute;s puros, como Ruby o Smalltalk, todos los valores son objetos, sean compuestos o no. En lenguajes orientados a objetos menos puros, incluidos C ++ y Java, algunos valores, como n&amp;uacute;meros enteros y valores de punto flotante, no son objetos, mientras que las instancias de tipos compuestos definidos por el usuario son objetos verdaderos con m&amp;eacute;todos asociados. En Julia, todos los valores son objetos, pero las funciones no est&amp;aacute;n empaquetadas con los objetos sobre los que operan. Esto es necesario ya que Julia elige qu&amp;eacute; m&amp;eacute;todo de una funci&amp;oacute;n usar por env&amp;iacute;o m&amp;uacute;ltiple, lo que significa que los tipos de &lt;em&gt;todos&lt;/em&gt;de los argumentos de una funci&amp;oacute;n se tienen en cuenta al seleccionar un m&amp;eacute;todo, en lugar de solo el primero (consulte &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;M&amp;eacute;todos&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre m&amp;eacute;todos y env&amp;iacute;o). Por tanto, ser&amp;iacute;a inapropiado que las funciones &quot;pertenecieran&quot; s&amp;oacute;lo a su primer argumento. Organizar m&amp;eacute;todos en objetos funcionales en lugar de nombrar bolsas de m&amp;eacute;todos &quot;dentro&quot; de cada objeto termina siendo un aspecto muy beneficioso del dise&amp;ntilde;o del lenguaje.</target>
        </trans-unit>
        <trans-unit id="eae8b05ff1c12682f8c0f5b0dacd56bde327dcb6" translate="yes" xml:space="preserve">
          <source>In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix. This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with &lt;code&gt;!&lt;/code&gt; below (e.g. &lt;code&gt;mul!&lt;/code&gt;) according to the usual Julia convention.</source>
          <target state="translated">En muchos casos, existen versiones in situ de operaciones matriciales que le permiten proporcionar una matriz o vector de salida preasignado. Esto es &amp;uacute;til al optimizar c&amp;oacute;digo cr&amp;iacute;tico para evitar la sobrecarga de asignaciones repetidas. Estas operaciones in situ tienen el sufijo &lt;code&gt;!&lt;/code&gt; a continuaci&amp;oacute;n (por ejemplo, &lt;code&gt;mul!&lt;/code&gt; ) de acuerdo con la convenci&amp;oacute;n habitual de Julia.</target>
        </trans-unit>
        <trans-unit id="1ed441529eec7f43ad66971217220df4ecd80a6e" translate="yes" xml:space="preserve">
          <source>In many cases, Julia is able to automatically vectorize inner for loops without the use of &lt;code&gt;@simd&lt;/code&gt;. Using &lt;code&gt;@simd&lt;/code&gt; gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:</source>
          <target state="translated">En muchos casos, Julia puede vectorizar autom&amp;aacute;ticamente bucles for internos sin el uso de &lt;code&gt;@simd&lt;/code&gt; . El uso de &lt;code&gt;@simd&lt;/code&gt; le da al compilador un poco m&amp;aacute;s de libertad para hacerlo posible en m&amp;aacute;s situaciones. En cualquier caso, su bucle interno debe tener las siguientes propiedades para permitir la vectorizaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="36269174e578550d7d7f0601c4aea1c6ce0438f9" translate="yes" xml:space="preserve">
          <source>In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="translated">En muchos casos, los argumentos de funci&amp;oacute;n tienen valores predeterminados sensibles y, por lo tanto, es posible que no sea necesario pasarlos expl&amp;iacute;citamente en cada llamada. Por ejemplo, la funci&amp;oacute;n &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt; &lt;code&gt;Date(y, [m, d])&lt;/code&gt; &lt;/a&gt; del m&amp;oacute;dulo &lt;code&gt;Dates&lt;/code&gt; construye un tipo de &lt;code&gt;Date&lt;/code&gt; para un a&amp;ntilde;o &lt;code&gt;y&lt;/code&gt; , mes &lt;code&gt;m&lt;/code&gt; y d&amp;iacute;a &lt;code&gt;d&lt;/code&gt; dado . Sin embargo, &lt;code&gt;m&lt;/code&gt; y &lt;code&gt;d&lt;/code&gt; argumentos son opcionales y su valor predeterminado es &lt;code&gt;1&lt;/code&gt; . Este comportamiento se puede expresar de forma concisa como:</target>
        </trans-unit>
        <trans-unit id="1dd343721288798b24ab9ba3f9547e7ac41c164d" translate="yes" xml:space="preserve">
          <source>In many cases, it is redundant to provide the type of &lt;code&gt;Point&lt;/code&gt; object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply &lt;code&gt;Point&lt;/code&gt; itself as a constructor, provided that the implied value of the parameter type &lt;code&gt;T&lt;/code&gt; is unambiguous:</source>
          <target state="translated">En muchos casos, es redundante proporcionar el tipo de objeto &lt;code&gt;Point&lt;/code&gt; que se desea construir, ya que los tipos de argumentos para la llamada al constructor ya proporcionan impl&amp;iacute;citamente informaci&amp;oacute;n de tipo. Por esa raz&amp;oacute;n, tambi&amp;eacute;n puede aplicar el propio &lt;code&gt;Point&lt;/code&gt; como un constructor, siempre que el valor impl&amp;iacute;cito del tipo de par&amp;aacute;metro &lt;code&gt;T&lt;/code&gt; no sea ambiguo:</target>
        </trans-unit>
        <trans-unit id="269254287f284598e6e04a282963713d5ef0932c" translate="yes" xml:space="preserve">
          <source>In many cases, the resolution specified for rounding (e.g., &lt;code&gt;Dates.Second(30)&lt;/code&gt;) divides evenly into the next largest period (in this case, &lt;code&gt;Dates.Minute(1)&lt;/code&gt;). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to the nearest 10 hours?</source>
          <target state="translated">En muchos casos, la resoluci&amp;oacute;n especificada para el redondeo (p. Ej., &lt;code&gt;Dates.Second(30)&lt;/code&gt; ) se divide uniformemente en el siguiente per&amp;iacute;odo m&amp;aacute;s grande (en este caso, &lt;code&gt;Dates.Minute(1)&lt;/code&gt; ). Pero el comportamiento de redondeo en casos en los que esto no es cierto puede generar confusi&amp;oacute;n. &amp;iquest;Cu&amp;aacute;l es el resultado esperado de redondear un &lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; a las 10 horas m&amp;aacute;s cercanas?</target>
        </trans-unit>
        <trans-unit id="619846970e9e167e4db1b981435711d687bd4ed9" translate="yes" xml:space="preserve">
          <source>In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is &lt;em&gt;not&lt;/em&gt; the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.</source>
          <target state="translated">En muchos lenguajes con declaraciones de tipo opcionales, agregar declaraciones es la forma principal de hacer que el c&amp;oacute;digo se ejecute m&amp;aacute;s r&amp;aacute;pido. Este &lt;em&gt;no&lt;/em&gt; es el caso de Julia. En Julia, el compilador generalmente conoce los tipos de todos los argumentos de funci&amp;oacute;n, variables locales y expresiones. Sin embargo, hay algunos casos espec&amp;iacute;ficos en los que las declaraciones son &amp;uacute;tiles.</target>
        </trans-unit>
        <trans-unit id="9450b748dbcdb8ba9fd42add95485312cab4012f" translate="yes" xml:space="preserve">
          <source>In mathematics, &lt;code&gt;+&lt;/code&gt; usually denotes a &lt;em&gt;commutative&lt;/em&gt; operation, where the order of the operands does not matter. An example of this is matrix addition, where &lt;code&gt;A + B == B + A&lt;/code&gt; for any matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; that have the same shape. In contrast, &lt;code&gt;*&lt;/code&gt; typically denotes a &lt;em&gt;noncommutative&lt;/em&gt; operation, where the order of the operands &lt;em&gt;does&lt;/em&gt; matter. An example of this is matrix multiplication, where in general &lt;code&gt;A * B != B * A&lt;/code&gt;. As with matrix multiplication, string concatenation is noncommutative: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt;. As such, &lt;code&gt;*&lt;/code&gt; is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.</source>
          <target state="translated">En matem&amp;aacute;ticas, &lt;code&gt;+&lt;/code&gt; generalmente denota una operaci&amp;oacute;n &lt;em&gt;conmutativa&lt;/em&gt; , donde el orden de los operandos no importa. Un ejemplo de esto es la suma de matrices, donde &lt;code&gt;A + B == B + A&lt;/code&gt; para las matrices &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; que tienen la misma forma. Por el contrario, &lt;code&gt;*&lt;/code&gt; normalmente denota una operaci&amp;oacute;n &lt;em&gt;no conmutativa&lt;/em&gt; , donde el orden de los operandos &lt;em&gt;s&amp;iacute;&lt;/em&gt; importa. Un ejemplo de esto es la multiplicaci&amp;oacute;n de matrices, donde, en general, &lt;code&gt;A * B != B * A&lt;/code&gt; . Al igual que con la multiplicaci&amp;oacute;n de matrices, la concatenaci&amp;oacute;n de cadenas no es conmutativa: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt; . Como tal, &lt;code&gt;*&lt;/code&gt; es una opci&amp;oacute;n m&amp;aacute;s natural para un operador de concatenaci&amp;oacute;n de cadenas infijas, consistente con el uso matem&amp;aacute;tico com&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="d668367cdfd665ad4130e8623549b132951b0865" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8bd1f7589c990d976c1051b69449b020a43727" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">En casos m&amp;aacute;s complejos, resolver las ambig&amp;uuml;edades del m&amp;eacute;todo implica cierto elemento de dise&amp;ntilde;o; este tema se explora m&amp;aacute;s &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;adelante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79e9987996de7a2336075063e303687b6133cecc" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4d8bd032078d1d618f689c7b9a8339132970a1" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;code&gt;abs&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, si &lt;code&gt;A&lt;/code&gt; es un subtipo &lt;code&gt;S&lt;/code&gt; de &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; con un tipo de elemento &lt;code&gt;T&lt;/code&gt; que admite &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; y &lt;code&gt;/&lt;/code&gt; , el tipo de retorno es &lt;code&gt;LU{T,S{T}}&lt;/code&gt; . Si se elige pivotar (predeterminado), el tipo de elemento tambi&amp;eacute;n debe admitir &lt;code&gt;abs&lt;/code&gt; y &lt;code&gt;&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b67b5f42c4b6dbeb6aa0f0d5f6894ea2c19994e" translate="yes" xml:space="preserve">
          <source>In order to &lt;a href=&quot;#catch-ctrl-c&quot;&gt;catch CTRL-C&lt;/a&gt; in the script you can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01897c1c5dfe56ff403bf92da50402dc901b089" translate="yes" xml:space="preserve">
          <source>In order to access the data of x, we can use &lt;code&gt;jl_array_data&lt;/code&gt;:</source>
          <target state="translated">Para acceder a los datos de x, podemos usar &lt;code&gt;jl_array_data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1c8c964572487783a93c9f805bd24c6191a24c97" translate="yes" xml:space="preserve">
          <source>In order to build this program you have to put the path to the Julia header into the include path and link against &lt;code&gt;libjulia&lt;/code&gt;. For instance, when Julia is installed to &lt;code&gt;$JULIA_DIR&lt;/code&gt;, one can compile the above test program &lt;code&gt;test.c&lt;/code&gt; with &lt;code&gt;gcc&lt;/code&gt; using:</source>
          <target state="translated">Para construir este programa, debe colocar la ruta al encabezado de Julia en la ruta de inclusi&amp;oacute;n y vincularla con &lt;code&gt;libjulia&lt;/code&gt; . Por ejemplo, cuando Julia est&amp;aacute; instalada en &lt;code&gt;$JULIA_DIR&lt;/code&gt; , se puede compilar el programa de prueba anterior &lt;code&gt;test.c&lt;/code&gt; con &lt;code&gt;gcc&lt;/code&gt; usando:</target>
        </trans-unit>
        <trans-unit id="f634f39fd97c0fd5eaef9dfae9571e089a9c4f67" translate="yes" xml:space="preserve">
          <source>In order to check whether &lt;code&gt;ret&lt;/code&gt; is of a specific Julia type, we can use the &lt;code&gt;jl_isa&lt;/code&gt;, &lt;code&gt;jl_typeis&lt;/code&gt;, or &lt;code&gt;jl_is_...&lt;/code&gt; functions. By typing &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; into the Julia shell we can see that the return type is &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;double&lt;/code&gt; in C). To convert the boxed Julia value into a C double the &lt;code&gt;jl_unbox_float64&lt;/code&gt; function is used in the above code snippet.</source>
          <target state="translated">Con el fin de comprobar si &lt;code&gt;ret&lt;/code&gt; es de un tipo espec&amp;iacute;fico de Julia, podemos utilizar los &lt;code&gt;jl_isa&lt;/code&gt; , &lt;code&gt;jl_typeis&lt;/code&gt; , o &lt;code&gt;jl_is_...&lt;/code&gt; funciones. Al escribir &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; en el shell de Julia, podemos ver que el tipo de retorno es &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;double&lt;/code&gt; en C). Para convertir el valor de Julia en caja en un doble de C , se usa la funci&amp;oacute;n &lt;code&gt;jl_unbox_float64&lt;/code&gt; en el fragmento de c&amp;oacute;digo anterior.</target>
        </trans-unit>
        <trans-unit id="c26dfd25e758364e0dcd1c617a188ec51d32baad" translate="yes" xml:space="preserve">
          <source>In order to compute trigonometric functions with degrees instead of radians, suffix the function with &lt;code&gt;d&lt;/code&gt;. For example, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt;&lt;code&gt;sind(x)&lt;/code&gt;&lt;/a&gt; computes the sine of &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is specified in degrees. The complete list of trigonometric functions with degree variants is:</source>
          <target state="translated">Para calcular funciones trigonom&amp;eacute;tricas con grados en lugar de radianes, agregue el sufijo &lt;code&gt;d&lt;/code&gt; a la funci&amp;oacute;n . Por ejemplo, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt; &lt;code&gt;sind(x)&lt;/code&gt; &lt;/a&gt; calcula el seno de &lt;code&gt;x&lt;/code&gt; donde &lt;code&gt;x&lt;/code&gt; se especifica en grados. La lista completa de funciones trigonom&amp;eacute;tricas con variantes de grado es:</target>
        </trans-unit>
        <trans-unit id="f65b6a7038eae90009481c5aaae33e0c39a02ac4" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;repr(io, mime, x)&lt;/code&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="translated">Para definir un nuevo backend de pantalla, primero se debe crear un subtipo &lt;code&gt;D&lt;/code&gt; de la clase abstracta &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; &lt;/a&gt; . Luego, para cada tipo MIME ( cadena &lt;code&gt;mime&lt;/code&gt; ) que se puede mostrar en &lt;code&gt;D&lt;/code&gt; , se debe definir una funci&amp;oacute;n de &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; que muestre &lt;code&gt;x&lt;/code&gt; como ese tipo MIME, normalmente llamando a &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(io, mime, x)&lt;/code&gt; &lt;/a&gt; o &lt;code&gt;repr(io, mime, x)&lt;/code&gt; . Se debe &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; un MethodError si &lt;code&gt;x&lt;/code&gt; no se puede mostrar como ese tipo MIME; esto es autom&amp;aacute;tico si uno llama &lt;code&gt;show&lt;/code&gt; o &lt;code&gt;repr&lt;/code&gt; . Finalmente, se debe definir una funci&amp;oacute;n de &lt;code&gt;display(d::D, x)&lt;/code&gt; que las consultas se pueden &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt; &lt;code&gt;showable(mime, x)&lt;/code&gt; &lt;/a&gt; para los tipos de &lt;code&gt;mime&lt;/code&gt; admitidos por &lt;code&gt;D&lt;/code&gt; y muestra el &quot;mejor&quot;; &lt;code&gt;MethodError&lt;/code&gt; debe lanzar un MethodError si no se encuentran tipos MIME compatibles para &lt;code&gt;x&lt;/code&gt; . De manera similar, algunos subtipos pueden desear anular la &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt; &lt;code&gt;redisplay(d::D, ...)&lt;/code&gt; &lt;/a&gt; . (Nuevamente, uno debe &lt;code&gt;import Base.display&lt;/code&gt; para agregar nuevos m&amp;eacute;todos para &lt;code&gt;display&lt;/code&gt; ). Los valores de retorno de estas funciones dependen de la implementaci&amp;oacute;n (ya que en algunos casos puede ser &amp;uacute;til devolver un &quot;identificador&quot; de pantalla de alg&amp;uacute;n tipo). Las funciones de pantalla para &lt;code&gt;D&lt;/code&gt; se pueden llamar directamente, pero tambi&amp;eacute;n se pueden invocar autom&amp;aacute;ticamente desde la &lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt; simplemente empujando una nueva pantalla en la pila de backend de pantalla con:</target>
        </trans-unit>
        <trans-unit id="704ebdff29ebf61fba245cec0a90e4a3393b7079" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.repr-Tuple%7BMIME,Any%7D&quot;&gt;&lt;code&gt;repr(io, mime, x)&lt;/code&gt;&lt;/a&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc544618a386ab5d58649ad21c68fc6a33673b83" translate="yes" xml:space="preserve">
          <source>In order to define automatically the values of this dictionary at startup time, one can use the &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; function in the &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c036b6a91aa7223777701c5e046f12ec492ccc" translate="yes" xml:space="preserve">
          <source>In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method should be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fa42e97ec0c0f5639428f8bc25c0313c261f3b" translate="yes" xml:space="preserve">
          <source>In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.</source>
          <target state="translated">Para despachar una lista de argumentos paramétricos de varios niveles,a menudo es mejor separar cada nivel de despacho en funciones distintas.Esto puede sonar similar en el enfoque del despacho único,pero como veremos más adelante,es aún más flexible.</target>
        </trans-unit>
        <trans-unit id="c64f4c986b251a9a23920c12ed0e829f663e97f9" translate="yes" xml:space="preserve">
          <source>In order to implement such a &lt;code&gt;copy&lt;/code&gt; or &lt;code&gt;copyto!&lt;/code&gt;, method, of course, you must work with the &lt;code&gt;Broadcasted&lt;/code&gt; wrapper to compute each element. There are two main ways of doing so:</source>
          <target state="translated">&amp;iexcl;Para implementar tal &lt;code&gt;copy&lt;/code&gt; o &lt;code&gt;copyto!&lt;/code&gt; , m&amp;eacute;todo, por supuesto, debe trabajar con el contenedor &lt;code&gt;Broadcasted&lt;/code&gt; para calcular cada elemento. Hay dos formas principales de hacerlo:</target>
        </trans-unit>
        <trans-unit id="7c65ae2a5b36599056aee26d3163a0e9101f727b" translate="yes" xml:space="preserve">
          <source>In order to losslessly represent arbitrary byte streams stored in a &lt;code&gt;String&lt;/code&gt;, a &lt;code&gt;Char&lt;/code&gt; value may store information that cannot be converted to a Unicode codepoint &amp;mdash; converting such a &lt;code&gt;Char&lt;/code&gt; to &lt;code&gt;UInt32&lt;/code&gt; will throw an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid(c::Char)&lt;/code&gt;&lt;/a&gt; function can be used to query whether &lt;code&gt;c&lt;/code&gt; represents a valid Unicode character.</source>
          <target state="translated">Para representar sin p&amp;eacute;rdidas secuencias de bytes arbitrarias almacenadas en una &lt;code&gt;String&lt;/code&gt; , un valor de &lt;code&gt;Char&lt;/code&gt; puede almacenar informaci&amp;oacute;n que no se puede convertir a un punto de c&amp;oacute;digo Unicode; la conversi&amp;oacute;n de dicho &lt;code&gt;Char&lt;/code&gt; a &lt;code&gt;UInt32&lt;/code&gt; arrojar&amp;aacute; un error. La funci&amp;oacute;n &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid(c::Char)&lt;/code&gt; &lt;/a&gt; se puede utilizar para consultar si &lt;code&gt;c&lt;/code&gt; representa un car&amp;aacute;cter Unicode v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="fab91460cbe612949b4b9d95753296ca7abe3d3b" translate="yes" xml:space="preserve">
          <source>In order to pass this function to C, we obtain its address using the macro &lt;code&gt;@cfunction&lt;/code&gt;:</source>
          <target state="translated">Para pasar esta funci&amp;oacute;n a C, obtenemos su direcci&amp;oacute;n usando la macro &lt;code&gt;@cfunction&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cd5618b4a563dff2d7a927d5353ef78a361df290" translate="yes" xml:space="preserve">
          <source>In order to refer to &lt;code&gt;MyType&lt;/code&gt; across all processes, &lt;code&gt;DummyModule.jl&lt;/code&gt; needs to be loaded on every process. Calling &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; loads it only on a single process. To load it on every process, use the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt;&lt;code&gt;@everywhere&lt;/code&gt;&lt;/a&gt; macro (starting Julia with &lt;code&gt;julia -p 2&lt;/code&gt;):</source>
          <target state="translated">Para hacer referencia a &lt;code&gt;MyType&lt;/code&gt; en todos los procesos, &lt;code&gt;DummyModule.jl&lt;/code&gt; necesario cargar DummyModule.jl en cada proceso. Llamar a &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; carga solo en un &amp;uacute;nico proceso. Para cargarlo en cada proceso, use la macro &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt; &lt;code&gt;@everywhere&lt;/code&gt; &lt;/a&gt; (comenzando Julia con &lt;code&gt;julia -p 2&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="47f30e462ec98fcc58c9494bb836f85ec8257aff" translate="yes" xml:space="preserve">
          <source>In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values &amp;ndash;- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.</source>
          <target state="translated">Para soportar la mutaci&amp;oacute;n, tales objetos generalmente se asignan en el mont&amp;oacute;n y tienen direcciones de memoria estables. Un objeto mutable es como un peque&amp;ntilde;o contenedor que puede contener diferentes valores a lo largo del tiempo y, por lo tanto, solo se puede identificar de manera confiable con su direcci&amp;oacute;n. Por el contrario, una instancia de un tipo inmutable se asocia con valores de campo espec&amp;iacute;ficos - los valores de campo por s&amp;iacute; solos le dicen todo sobre el objeto. Al decidir si convertir un tipo en mutable, pregunte si dos instancias con los mismos valores de campo se considerar&amp;iacute;an id&amp;eacute;nticas o si podr&amp;iacute;an necesitar cambiar de forma independiente con el tiempo. Si se consideraran id&amp;eacute;nticos, el tipo probablemente deber&amp;iacute;a ser inmutable.</target>
        </trans-unit>
        <trans-unit id="2f2293a5b64eabd8ff88bd22ea606404b9b1e108" translate="yes" xml:space="preserve">
          <source>In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The &lt;code&gt;continue&lt;/code&gt; keyword accomplishes this:</source>
          <target state="translated">En otras circunstancias, es &amp;uacute;til poder detener una iteraci&amp;oacute;n y pasar a la siguiente inmediatamente. La palabra clave &lt;code&gt;continue&lt;/code&gt; logra esto:</target>
        </trans-unit>
        <trans-unit id="c004c636d1b0703eca9cda2590edfd6579e7129c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa(A,Type{B})&lt;/code&gt;&lt;/a&gt; is true if and only if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are the same object and that object is a type. Without the parameter, &lt;code&gt;Type&lt;/code&gt; is simply an abstract type which has all type objects as its instances, including, of course, singleton types:</source>
          <target state="translated">En otras palabras, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa(A,Type{B})&lt;/code&gt; &lt;/a&gt; es verdadero si y solo si &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; son el mismo objeto y ese objeto es un tipo. Sin el par&amp;aacute;metro, &lt;code&gt;Type&lt;/code&gt; es simplemente un tipo abstracto que tiene todos los objetos de tipo como sus instancias, incluidos, por supuesto, los tipos singleton:</target>
        </trans-unit>
        <trans-unit id="fb4e1a8fb772b24b6039451c201b81e5c718d91a" translate="yes" xml:space="preserve">
          <source>In other words, in the parlance of type theory, Julia's type parameters are &lt;em&gt;invariant&lt;/em&gt;, rather than being &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;covariant (or even contravariant)&lt;/a&gt;. This is for practical reasons: while any instance of &lt;code&gt;Point{Float64}&lt;/code&gt; may conceptually be like an instance of &lt;code&gt;Point{Real}&lt;/code&gt; as well, the two types have different representations in memory:</source>
          <target state="translated">En otras palabras, en el lenguaje de la teor&amp;iacute;a de tipos, los par&amp;aacute;metros de tipo de Julia son &lt;em&gt;invariantes&lt;/em&gt; , en lugar de ser &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;covariantes (o incluso contravariantes)&lt;/a&gt; . Esto es por razones pr&amp;aacute;cticas: mientras que cualquier instancia de &lt;code&gt;Point{Float64}&lt;/code&gt; puede ser conceptualmente como una instancia de &lt;code&gt;Point{Real}&lt;/code&gt; tambi&amp;eacute;n, los dos tipos tienen diferentes representaciones en la memoria:</target>
        </trans-unit>
        <trans-unit id="2489400c16a870eb77390027298b5bae2afac7fd" translate="yes" xml:space="preserve">
          <source>In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character rather than multiple invalid characters. This rule may be best explained with an example:</source>
          <target state="translated">En particular,esto significa que las secuencias de unidades de código demasiado largas y demasiado altas y sus prefijos se tratan como un único carácter inválido en lugar de múltiples caracteres inválidos.Esta regla puede explicarse mejor con un ejemplo:</target>
        </trans-unit>
        <trans-unit id="86e6d7b557572810776afd763390d8c87a4b9b3f" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="translated">En particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; es t&amp;iacute;picamente una versi&amp;oacute;n &quot;bonita impresa&quot; de &lt;code&gt;x&lt;/code&gt; dise&amp;ntilde;ada para el consumo humano. Consulte tambi&amp;eacute;n &lt;code&gt;repr(x)&lt;/code&gt; para devolver una cadena correspondiente a &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt; que puede estar m&amp;aacute;s cerca de c&amp;oacute;mo se ingresar&amp;iacute;a el valor de &lt;code&gt;x&lt;/code&gt; en Julia.</target>
        </trans-unit>
        <trans-unit id="44f2256825b7ba89fb1041db2fbe0f7cb5785da9" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a352a9e712137ef0293428d01a95dc381f03f45f" translate="yes" xml:space="preserve">
          <source>In particular, if you define a &lt;code&gt;function __init__()&lt;/code&gt; in a module, then Julia will call &lt;code&gt;__init__()&lt;/code&gt; immediately &lt;em&gt;after&lt;/em&gt; the module is loaded (e.g., by &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, or &lt;code&gt;require&lt;/code&gt;) at runtime for the &lt;em&gt;first&lt;/em&gt; time (i.e., &lt;code&gt;__init__&lt;/code&gt; is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their &lt;code&gt;__init__&lt;/code&gt; functions called &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;__init__&lt;/code&gt; of the enclosing module.</source>
          <target state="translated">En particular, si define una &lt;code&gt;function __init__()&lt;/code&gt; en un m&amp;oacute;dulo, Julia llamar&amp;aacute; a &lt;code&gt;__init__()&lt;/code&gt; inmediatamente &lt;em&gt;despu&amp;eacute;s de&lt;/em&gt; que se cargue el m&amp;oacute;dulo (por ejemplo, por &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n , &lt;code&gt;using&lt;/code&gt; o &lt;code&gt;require&lt;/code&gt; ) en tiempo de ejecuci&amp;oacute;n por &lt;em&gt;primera&lt;/em&gt; vez (es decir, &lt;code&gt;__init__&lt;/code&gt; es solo se llama una vez, y solo despu&amp;eacute;s de que se hayan ejecutado todas las instrucciones del m&amp;oacute;dulo). Debido a que se llama despu&amp;eacute;s de que el m&amp;oacute;dulo est&amp;aacute; totalmente importada, los subm&amp;oacute;dulos u otros m&amp;oacute;dulos importados tienen sus &lt;code&gt;__init__&lt;/code&gt; funciones llamadas &lt;em&gt;antes de&lt;/em&gt; la &lt;code&gt;__init__&lt;/code&gt; del m&amp;oacute;dulo de cerramiento.</target>
        </trans-unit>
        <trans-unit id="7f00fe64f586624c25d908def02434ca5a5747cc" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;LibGit2.free&lt;/code&gt; should be called afterward on the &lt;code&gt;Ref&lt;/code&gt; object.</source>
          <target state="translated">En particular, tenga en cuenta que &lt;code&gt;LibGit2.free&lt;/code&gt; debe llamarse posteriormente en el objeto &lt;code&gt;Ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b992ee319e3397f73ab42aa368ea422a279c258" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;missing == missing&lt;/code&gt; returns &lt;code&gt;missing&lt;/code&gt;, so &lt;code&gt;==&lt;/code&gt; cannot be used to test whether a value is missing. To test whether &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;, use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En particular, tenga en cuenta que &lt;code&gt;missing == missing&lt;/code&gt; devuelve &lt;code&gt;missing&lt;/code&gt; , por lo que &lt;code&gt;==&lt;/code&gt; no se puede usar para probar si falta un valor. Para probar si &lt;code&gt;x&lt;/code&gt; est&amp;aacute; &lt;code&gt;missing&lt;/code&gt; , el uso &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10aa2526d9c8eb28f8fc8b12b251cb66391f9afe" translate="yes" xml:space="preserve">
          <source>In particular, this means that small enough immutable values like integers and floats are typically passed to functions in registers (or stack allocated).</source>
          <target state="translated">En particular,esto significa que valores suficientemente pequeños e inmutables,como números enteros y flotadores,suelen pasar a las funciones de los registros (o a la pila asignada).</target>
        </trans-unit>
        <trans-unit id="bd271b290661f2d2dcd371ac877e792e11b0ae4c" translate="yes" xml:space="preserve">
          <source>In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent to writing:</source>
          <target state="translated">En lugar de la sintaxis escrita,la llamada macro se expande en el tiempo de análisis hasta su resultado devuelto.Esto es equivalente a la escritura:</target>
        </trans-unit>
        <trans-unit id="f1faf89b83d5028304b1044be098d4330cb094e6" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">En la pr&amp;aacute;ctica, especialmente cuando se proporciona funcionalidad reutilizable, generalmente se envuelven los usos de &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt; en las funciones de Julia que configuran argumentos y luego verifican los errores de cualquier manera que la funci&amp;oacute;n C o Fortran los indique, propag&amp;aacute;ndose al llamador de Julia como excepciones. Esto es especialmente importante ya que las API de C y Fortran son notoriamente inconsistentes sobre c&amp;oacute;mo indican las condiciones de error. Por ejemplo, la funci&amp;oacute;n de la biblioteca &lt;code&gt;getenv&lt;/code&gt; C se incluye en la siguiente funci&amp;oacute;n de Julia, que es una versi&amp;oacute;n simplificada de la definici&amp;oacute;n real de &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt; &lt;code&gt;env.jl&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4ee03fd7f1bb01022cf62529b6c1e2c9383e98c5" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function specifies. And if an error occurs it is thrown as a normal Julia exception. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804d748c80f6e79bb9e342f1f2304330f7eae29d" translate="yes" xml:space="preserve">
          <source>In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.</source>
          <target state="translated">En principio,el propio analizador de Markdown también puede ser ampliado arbitrariamente por paquetes,o puede utilizarse un sabor totalmente personalizado de Markdown,pero en general esto debería ser innecesario.</target>
        </trans-unit>
        <trans-unit id="f1e4e6ce2511929e6de42c91eafd73bc415389d8" translate="yes" xml:space="preserve">
          <source>In short, it is an immutable dictionary that is a subclass of &lt;code&gt;IO&lt;/code&gt;. It supports standard dictionary operations such as &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, and can also be used as an I/O stream.</source>
          <target state="translated">En resumen, es un diccionario inmutable que es una subclase de &lt;code&gt;IO&lt;/code&gt; . Admite operaciones de diccionario est&amp;aacute;ndar, como &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt; , y tambi&amp;eacute;n se puede utilizar como flujo de E / S.</target>
        </trans-unit>
        <trans-unit id="638b74bbfc0d77182896b29b38f7e41990e9ec77" translate="yes" xml:space="preserve">
          <source>In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise. For example, instead of initializing &lt;code&gt;a&lt;/code&gt; with zeros, initialize it with:</source>
          <target state="translated">En algunas aplicaciones, una alternativa a poner a cero los n&amp;uacute;meros subnormales es inyectar un poquito de ruido. Por ejemplo, en lugar de inicializar &lt;code&gt;a&lt;/code&gt; con ceros, inicial&amp;iacute;zalo con:</target>
        </trans-unit>
        <trans-unit id="c0f7478a3f0be2e5b9c7e0905c13888f63fbab1a" translate="yes" xml:space="preserve">
          <source>In some applications, it is convenient to store explicit zero values in a &lt;code&gt;SparseMatrixCSC&lt;/code&gt;. These &lt;em&gt;are&lt;/em&gt; accepted by functions in &lt;code&gt;Base&lt;/code&gt; (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The &lt;a href=&quot;#SparseArrays.nnz&quot;&gt;&lt;code&gt;nnz&lt;/code&gt;&lt;/a&gt; function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use &lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt;&lt;code&gt;count(!iszero, x)&lt;/code&gt;&lt;/a&gt;, which inspects every stored element of a sparse matrix. &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;, and the in-place &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;, can be used to remove stored zeros from the sparse matrix.</source>
          <target state="translated">En algunas aplicaciones, es conveniente para almacenar los valores cero expl&amp;iacute;citas en un &lt;code&gt;SparseMatrixCSC&lt;/code&gt; . Estos &lt;em&gt;son&lt;/em&gt; aceptados por funciones en &lt;code&gt;Base&lt;/code&gt; (pero no hay garant&amp;iacute;a de que se conservar&amp;aacute;n en operaciones de mutaci&amp;oacute;n). Estos ceros almacenados expl&amp;iacute;citamente son tratados como no ceros estructurales por muchas rutinas. La funci&amp;oacute;n &lt;a href=&quot;#SparseArrays.nnz&quot;&gt; &lt;code&gt;nnz&lt;/code&gt; &lt;/a&gt; devuelve el n&amp;uacute;mero de elementos almacenados expl&amp;iacute;citamente en la estructura de datos dispersos, incluidos los elementos no ceros estructurales. Para contar el n&amp;uacute;mero exacto de n&amp;uacute;meros no ceros, use &lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt; &lt;code&gt;count(!iszero, x)&lt;/code&gt; &lt;/a&gt; , que inspecciona todos los elementos almacenados de una matriz dispersa. &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; &lt;/a&gt; , y los dropzeros in &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt; , se puede utilizar para eliminar los ceros almacenados de la matriz dispersa.</target>
        </trans-unit>
        <trans-unit id="7200ec90f922f3162b688616528f07bbd46b3f3f" translate="yes" xml:space="preserve">
          <source>In some cases changing the value of a &lt;code&gt;const&lt;/code&gt; variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.</source>
          <target state="translated">En algunos casos, cambiar el valor de una variable &lt;code&gt;const&lt;/code&gt; ante genera una advertencia en lugar de un error. Sin embargo, esto puede producir un comportamiento impredecible o da&amp;ntilde;ar el estado de su programa, por lo que debe evitarse. Esta funci&amp;oacute;n est&amp;aacute; pensada &amp;uacute;nicamente para su comodidad durante el uso interactivo.</target>
        </trans-unit>
        <trans-unit id="0bca4b7af7b2c3f590b22d6bdc9c439dda8d86d1" translate="yes" xml:space="preserve">
          <source>In some cases it might be convenient not to have to define &lt;code&gt;MyStyle&lt;/code&gt;, in which case you can leverage one of the general broadcast wrappers:</source>
          <target state="translated">En algunos casos, puede ser conveniente no tener que definir &lt;code&gt;MyStyle&lt;/code&gt; , en cuyo caso puede aprovechar uno de los contenedores de transmisi&amp;oacute;n generales:</target>
        </trans-unit>
        <trans-unit id="6f5f29a98f7076181fba48634a540b92f8996002" translate="yes" xml:space="preserve">
          <source>In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called &lt;em&gt;parallel map&lt;/em&gt;, implemented in Julia as the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; function. For example, we could compute the singular values of several large random matrices in parallel as follows:</source>
          <target state="translated">En algunos casos, no se necesita ning&amp;uacute;n operador de reducci&amp;oacute;n, y simplemente deseamos aplicar una funci&amp;oacute;n a todos los enteros en alg&amp;uacute;n rango (o, m&amp;aacute;s generalmente, a todos los elementos en alguna colecci&amp;oacute;n). Esta es otra operaci&amp;oacute;n &amp;uacute;til llamada &lt;em&gt;mapa paralelo&lt;/em&gt; , implementada en Julia como la funci&amp;oacute;n &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt; . Por ejemplo, podr&amp;iacute;amos calcular los valores singulares de varias matrices aleatorias grandes en paralelo de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="6de51e42bc98441adfec5061cc53937870969a7a" translate="yes" xml:space="preserve">
          <source>In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for &lt;code&gt;MersenneTwister&lt;/code&gt;, which natively writes random values in an array.</source>
          <target state="translated">En algunos casos, para un tipo de RNG dado, la generaci&amp;oacute;n de una matriz de valores aleatorios puede ser m&amp;aacute;s eficiente con un m&amp;eacute;todo especializado que simplemente usando la t&amp;eacute;cnica de desacoplamiento explicada anteriormente. Este es, por ejemplo, el caso de &lt;code&gt;MersenneTwister&lt;/code&gt; , que escribe de forma nativa valores aleatorios en una matriz.</target>
        </trans-unit>
        <trans-unit id="f953f89be50274569ebdd1d16dd1091ac2cf9f4a" translate="yes" xml:space="preserve">
          <source>In some cases, it is useful to adjust the behavior of &lt;code&gt;show&lt;/code&gt; methods depending on the context. This can be achieved via the &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; type, which allows passing contextual properties together with a wrapped IO stream. For example, we can build a shorter representation in our &lt;code&gt;show&lt;/code&gt; method when the &lt;code&gt;:compact&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, falling back to the long representation if the property is &lt;code&gt;false&lt;/code&gt; or absent:</source>
          <target state="translated">En algunos casos, es &amp;uacute;til ajustar el comportamiento de los m&amp;eacute;todos &lt;code&gt;show&lt;/code&gt; seg&amp;uacute;n el contexto. Esto se puede lograr mediante el tipo &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt; , que permite pasar propiedades contextuales junto con un flujo IO envuelto. Por ejemplo, podemos construir una representaci&amp;oacute;n m&amp;aacute;s corta en nuestro m&amp;eacute;todo &lt;code&gt;show&lt;/code&gt; cuando la propiedad &lt;code&gt;:compact&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , volviendo a la representaci&amp;oacute;n larga si la propiedad es &lt;code&gt;false&lt;/code&gt; o est&amp;aacute; ausente:</target>
        </trans-unit>
        <trans-unit id="ef681cb1496bc3731bd754661d5504701ec7c4ad" translate="yes" xml:space="preserve">
          <source>In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the &lt;code&gt;Sampler&lt;/code&gt; constructor. Let's assume we defined two helper types for &lt;code&gt;Die&lt;/code&gt;, say &lt;code&gt;SamplerDie1&lt;/code&gt; which should be used to generate only few random values, and &lt;code&gt;SamplerDieMany&lt;/code&gt; for many values. We can use those types as follows:</source>
          <target state="translated">En algunos casos, el hecho de que se desee generar solo un pu&amp;ntilde;ado de valores o una gran cantidad de valores tendr&amp;aacute; un impacto en la elecci&amp;oacute;n del algoritmo. Esto se maneja con el tercer par&amp;aacute;metro del constructor &lt;code&gt;Sampler&lt;/code&gt; . Supongamos que definimos dos tipos de ayuda para &lt;code&gt;Die&lt;/code&gt; , digamos &lt;code&gt;SamplerDie1&lt;/code&gt; , que deber&amp;iacute;a usarse para generar solo unos pocos valores aleatorios, y &lt;code&gt;SamplerDieMany&lt;/code&gt; para muchos valores. Podemos usar esos tipos de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="a8e2e50c5e5c4d32f74208fde4cbb36b4d6312f3" translate="yes" xml:space="preserve">
          <source>In some languages, the empty tuple (&lt;code&gt;()&lt;/code&gt;) is considered the canonical form of nothingness. However, in julia it is best thought of as just a regular tuple that happens to contain zero values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5807b7c193c64d46f5bc3d42f551af1a206e90" translate="yes" xml:space="preserve">
          <source>In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bc7cae3ed284ebaa58a72dfb5ca4f122d19b91" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793adcc5e6d1a8b0006e672f0871fab8bd1ee12e" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools-1&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="translated">En algunas situaciones, su funci&amp;oacute;n puede necesitar asignar memoria como parte de su operaci&amp;oacute;n, y esto puede complicar la simple imagen de arriba. En tales casos, considere usar una de las &lt;a href=&quot;#tools-1&quot;&gt;herramientas&lt;/a&gt; siguientes para diagnosticar problemas o escriba una versi&amp;oacute;n de su funci&amp;oacute;n que separe la asignaci&amp;oacute;n de sus aspectos algor&amp;iacute;tmicos (consulte &lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;Asignaci&amp;oacute;n previa de salidas&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a0f5f99ad11403dc52acb366ff631558f32f389" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; for the tests.</source>
          <target state="translated">En el paso 2 a continuaci&amp;oacute;n, edite &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; para cambiar el c&amp;oacute;digo fuente y &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; para las pruebas.</target>
        </trans-unit>
        <trans-unit id="18fa22072854af164b60f3647ea657dba3a66a38" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and create any test file of your choosing.</source>
          <target state="translated">En el paso 2 a continuaci&amp;oacute;n, edite &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; para cambiar el c&amp;oacute;digo fuente y cree cualquier archivo de prueba de su elecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4a0eaae9f72d9710fb65a9583dfc845568e81d5f" translate="yes" xml:space="preserve">
          <source>In such cases one should redesign the code to avoid the possibility of a race condition or use &lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;synchronization primitives&lt;/a&gt;.</source>
          <target state="translated">En tales casos, se debe redise&amp;ntilde;ar el c&amp;oacute;digo para evitar la posibilidad de una condici&amp;oacute;n de carrera o usar &lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;primitivas de sincronizaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e9e71bba5509813057399a4f8d90c9c53704d76" translate="yes" xml:space="preserve">
          <source>In such cases, the result is always 1-d.</source>
          <target state="translated">En tales casos,el resultado es siempre 1-d.</target>
        </trans-unit>
        <trans-unit id="de5de110f5af15ec4cd1a61e4b555c94b532b3cc" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c795388eedec3a869fe287bc8b5bbacb71a43dbd" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="translated">En los lenguajes de computaci&amp;oacute;n t&amp;eacute;cnica, es com&amp;uacute;n tener versiones &quot;vectorizadas&quot; de funciones, que simplemente aplican una funci&amp;oacute;n dada &lt;code&gt;f(x)&lt;/code&gt; a cada elemento de una matriz &lt;code&gt;A&lt;/code&gt; para producir una nueva matriz v&amp;iacute;a &lt;code&gt;f(A)&lt;/code&gt; . Este tipo de sintaxis es conveniente para el procesamiento de datos, pero en otros lenguajes la vectorizaci&amp;oacute;n tambi&amp;eacute;n se requiere a menudo para el rendimiento: si los bucles son lentos, la versi&amp;oacute;n &quot;vectorizada&quot; de una funci&amp;oacute;n puede llamar al c&amp;oacute;digo de biblioteca r&amp;aacute;pido escrito en un lenguaje de bajo nivel. En Julia, las funciones vectorizadas &lt;em&gt;no&lt;/em&gt; son necesarias para el rendimiento y, de hecho, a menudo es beneficioso escribir sus propios bucles (consulte &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Consejos de rendimiento&lt;/a&gt; ), pero a&amp;uacute;n pueden ser convenientes. Por lo tanto, &lt;em&gt;cualquier&lt;/em&gt; funci&amp;oacute;n de Julia &lt;code&gt;f&lt;/code&gt; se puede aplicar por elementos a cualquier matriz (u otra colecci&amp;oacute;n) con la sintaxis &lt;code&gt;f.(A)&lt;/code&gt; . Por ejemplo, el &lt;code&gt;sin&lt;/code&gt; se puede aplicar a todos los elementos en el vector &lt;code&gt;A&lt;/code&gt; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="1295513c71d65c30e7efa46afbaa35e5c9e76740" translate="yes" xml:space="preserve">
          <source>In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to by both &lt;code&gt;echo&lt;/code&gt; processes, and the other end of the pipe is read from by the &lt;code&gt;sort&lt;/code&gt; command.</source>
          <target state="translated">En t&amp;eacute;rminos de plomer&amp;iacute;a UNIX, lo que est&amp;aacute; sucediendo aqu&amp;iacute; es que ambos procesos de &lt;code&gt;echo&lt;/code&gt; crean y escriben un solo objeto de tuber&amp;iacute;a UNIX , y el comando &lt;code&gt;sort&lt;/code&gt; lee el otro extremo de la tuber&amp;iacute;a .</target>
        </trans-unit>
        <trans-unit id="bc29b396f06d90d9310efc41817564ce48560df4" translate="yes" xml:space="preserve">
          <source>In the Julia REPL and several other Julia editing environments, you can type many Unicode math symbols by typing the backslashed LaTeX symbol name followed by tab. For example, the variable name &lt;code&gt;&amp;delta;&lt;/code&gt; can be entered by typing &lt;code&gt;\delta&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;, or even &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; by &lt;code&gt;\alpha&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\hat&lt;/code&gt;- &lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\_2&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;. (If you find a symbol somewhere, e.g. in someone else's code, that you don't know how to type, the REPL help will tell you: just type &lt;code&gt;?&lt;/code&gt; and then paste the symbol.)</source>
          <target state="translated">En Julia REPL y varios otros entornos de edici&amp;oacute;n de Julia, puede escribir muchos s&amp;iacute;mbolos matem&amp;aacute;ticos Unicode escribiendo el nombre del s&amp;iacute;mbolo LaTeX con barra invertida seguido de tabulador. Por ejemplo, el nombre de la variable &lt;code&gt;&amp;delta;&lt;/code&gt; se puede ingresar escribiendo &lt;code&gt;\delta&lt;/code&gt; - &lt;em&gt;tab&lt;/em&gt; , o incluso &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; con &lt;code&gt;\alpha&lt;/code&gt; - &lt;em&gt;tab&lt;/em&gt; - &lt;code&gt;\hat&lt;/code&gt; - &lt;em&gt;tab&lt;/em&gt; - &lt;code&gt;\_2&lt;/code&gt; - &lt;em&gt;tab&lt;/em&gt; . (Si encuentra un s&amp;iacute;mbolo en alguna parte, por ejemplo, en el c&amp;oacute;digo de otra persona, que no sabe c&amp;oacute;mo escribir, la ayuda de REPL le dir&amp;aacute;: simplemente escriba &lt;code&gt;?&lt;/code&gt; Y luego pegue el s&amp;iacute;mbolo).</target>
        </trans-unit>
        <trans-unit id="7569c827c9a13b3faf85c9b20e363a3375ada161" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;@everywhere module Foo&lt;/code&gt; defined &lt;code&gt;Foo&lt;/code&gt; on all nodes. However the call to &lt;code&gt;Foo.foo()&lt;/code&gt; created a new global binding &lt;code&gt;gvar&lt;/code&gt; on the local node, but this was not found on node 2 resulting in an &lt;code&gt;UndefVarError&lt;/code&gt; error.</source>
          <target state="translated">En el ejemplo anterior, el &lt;code&gt;@everywhere module Foo&lt;/code&gt; defini&amp;oacute; a &lt;code&gt;Foo&lt;/code&gt; en todos los nodos. Sin embargo, la llamada a &lt;code&gt;Foo.foo()&lt;/code&gt; cre&amp;oacute; un nuevo &lt;code&gt;gvar&lt;/code&gt; de enlace global en el nodo local, pero esto no se encontr&amp;oacute; en el nodo 2, lo que result&amp;oacute; en un error &lt;code&gt;UndefVarError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4befd8beabfc58d36d63a701ccb0fcbe3c3991f4" translate="yes" xml:space="preserve">
          <source>In the absence of a type declaration with &lt;code&gt;::&lt;/code&gt;, the type of a method parameter is &lt;code&gt;Any&lt;/code&gt; by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type &lt;code&gt;Any&lt;/code&gt;. Thus, we can define a catch-all method for &lt;code&gt;f&lt;/code&gt; like so:</source>
          <target state="translated">En ausencia de una declaraci&amp;oacute;n de tipo con &lt;code&gt;::&lt;/code&gt; , el tipo de un par&amp;aacute;metro de m&amp;eacute;todo es &lt;code&gt;Any&lt;/code&gt; por defecto, lo que significa que no est&amp;aacute; restringido ya que todos los valores en Julia son instancias del tipo abstracto &lt;code&gt;Any&lt;/code&gt; . Por lo tanto, podemos definir un m&amp;eacute;todo general para &lt;code&gt;f&lt;/code&gt; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="804c2e460ca33d08a52c531b866706df762bfe07" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e6eb62fa9a3db0a4d3297fcd4c7b6e7504f490" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="translated">En el formulario de asignaci&amp;oacute;n, el cuerpo de la funci&amp;oacute;n debe ser una sola expresi&amp;oacute;n, aunque puede ser una expresi&amp;oacute;n compuesta (consulte &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Expresiones compuestas&lt;/a&gt; ). Las definiciones de funciones breves y simples son comunes en Julia. En consecuencia, la sintaxis de la funci&amp;oacute;n corta es bastante idiom&amp;aacute;tica, lo que reduce considerablemente tanto el tipeo como el ruido visual.</target>
        </trans-unit>
        <trans-unit id="8b4a822ba35b7b2a2b87214b87f56abe71bd6a7e" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values &amp;ndash; and any function that was defined &lt;em&gt;before&lt;/em&gt; the definition of the generated function.</source>
          <target state="translated">En el cuerpo de la funci&amp;oacute;n generada, solo tiene acceso a los &lt;em&gt;tipos&lt;/em&gt; de argumentos, no a sus valores, y a cualquier funci&amp;oacute;n que se haya definido &lt;em&gt;antes de&lt;/em&gt; la definici&amp;oacute;n de la funci&amp;oacute;n generada.</target>
        </trans-unit>
        <trans-unit id="50c2c4d1cb9a5c5c26d9acf8cbb1ac2672dac8d1" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f8a53fe3cbe9ccdbd0383d96fd01b1b384f1cc" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;Point&lt;/code&gt;, the type of &lt;code&gt;T&lt;/code&gt; is unambiguously implied if and only if the two arguments to &lt;code&gt;Point&lt;/code&gt; have the same type. When this isn't the case, the constructor will fail with a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">En el caso de &lt;code&gt;Point&lt;/code&gt; , el tipo de &lt;code&gt;T&lt;/code&gt; est&amp;aacute; impl&amp;iacute;cito de forma inequ&amp;iacute;voca si y solo si los dos argumentos de &lt;code&gt;Point&lt;/code&gt; tienen el mismo tipo. Cuando este no es el caso, el constructor fallar&amp;aacute; con un &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8083b5b25cdad6fa0ec0e103815341575e54f6a2" translate="yes" xml:space="preserve">
          <source>In the case that the type of &lt;code&gt;a[1]&lt;/code&gt; is not known precisely, &lt;code&gt;x&lt;/code&gt; can be declared via &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt;. The use of the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function allows &lt;code&gt;a[1]&lt;/code&gt; to be any object convertible to an &lt;code&gt;Int32&lt;/code&gt; (such as &lt;code&gt;UInt8&lt;/code&gt;), thus increasing the genericity of the code by loosening the type requirement. Notice that &lt;code&gt;convert&lt;/code&gt; itself needs a type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce the type of the return value of a function, even &lt;code&gt;convert&lt;/code&gt;, unless the types of all the function's arguments are known.</source>
          <target state="translated">En el caso de que el tipo de &lt;code&gt;a[1]&lt;/code&gt; no se conoce con precisi&amp;oacute;n, &lt;code&gt;x&lt;/code&gt; se pueden declarar a trav&amp;eacute;s de &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt; . El uso de la funci&amp;oacute;n de &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt; permite que &lt;code&gt;a[1]&lt;/code&gt; sea ​​cualquier objeto convertible a &lt;code&gt;Int32&lt;/code&gt; (como &lt;code&gt;UInt8&lt;/code&gt; ), aumentando as&amp;iacute; la gen&amp;eacute;ricoidad del c&amp;oacute;digo al aflojar el requisito de tipo. Tenga en cuenta que la &lt;code&gt;convert&lt;/code&gt; s&amp;iacute; necesita una anotaci&amp;oacute;n de tipo en este contexto para lograr la estabilidad de tipo. Esto se debe a que el compilador no puede deducir el tipo de valor de retorno de una funci&amp;oacute;n, ni siquiera &lt;code&gt;convert&lt;/code&gt; ir , a menos que se conozcan los tipos de todos los argumentos de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7c1119f311ce545842278fe205e3f9855f274299" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831b049ac64422357fdc2a1f1e12b98990a72d96" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">En el contexto de una expresi&amp;oacute;n, los s&amp;iacute;mbolos se utilizan para indicar el acceso a las variables; cuando se eval&amp;uacute;a una expresi&amp;oacute;n, un s&amp;iacute;mbolo se reemplaza con el valor vinculado a ese s&amp;iacute;mbolo en el &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;&amp;aacute;mbito&lt;/a&gt; apropiado .</target>
        </trans-unit>
        <trans-unit id="bb0ccf20285ac1f5e0c9e737c0f406f1f62a6d45" translate="yes" xml:space="preserve">
          <source>In the context of function definitions, the &lt;code&gt;...&lt;/code&gt; operator is used to combine many different arguments into a single argument. This use of &lt;code&gt;...&lt;/code&gt; for combining many different arguments into a single argument is called slurping:</source>
          <target state="translated">En el contexto de las definiciones de funciones, el operador &lt;code&gt;...&lt;/code&gt; se usa para combinar muchos argumentos diferentes en un solo argumento. Este uso de &lt;code&gt;...&lt;/code&gt; para combinar muchos argumentos diferentes en un solo argumento se llama sorber:</target>
        </trans-unit>
        <trans-unit id="93652cdf53268e5b525c9968aae662e21595f44e" translate="yes" xml:space="preserve">
          <source>In the end we will present Julia's approach to distributed and parallel computing. With scientific computing in mind, Julia natively implements interfaces to distribute a process across multiple cores or machines. Also we will mention useful external packages for distributed programming like &lt;code&gt;MPI.jl&lt;/code&gt; and &lt;code&gt;DistributedArrays.jl&lt;/code&gt;.</source>
          <target state="translated">Al final, presentaremos el enfoque de Julia para la computaci&amp;oacute;n distribuida y paralela. Con la inform&amp;aacute;tica cient&amp;iacute;fica en mente, Julia implementa de forma nativa interfaces para distribuir un proceso en varios n&amp;uacute;cleos o m&amp;aacute;quinas. Tambi&amp;eacute;n mencionaremos paquetes externos &amp;uacute;tiles para programaci&amp;oacute;n distribuida como &lt;code&gt;MPI.jl&lt;/code&gt; y &lt;code&gt;DistributedArrays.jl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d323acfd53199deb66ce97dad2e67a0a4f124fda" translate="yes" xml:space="preserve">
          <source>In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:</source>
          <target state="translated">En el caso de que un conjunto de pruebas anidado no tenga fallos,como ocurrió aquí,se ocultará en el resumen.Si tenemos un fallo en la prueba,sólo se mostrarán los detalles de los conjuntos de pruebas fallidas:</target>
        </trans-unit>
        <trans-unit id="381773d3ab62fd2b5a03a4a6a4af80e1db7c0e67" translate="yes" xml:space="preserve">
          <source>In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; provide non-standard string literal &lt;code&gt;@x_str&lt;/code&gt;, then one can write &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; or &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; to disambiguate between the two.</source>
          <target state="translated">En el caso de que dos m&amp;oacute;dulos proporcionen cadenas de caracteres o literales de comando no est&amp;aacute;ndar con el mismo nombre, es posible calificar la cadena o el literal de comando con un nombre de m&amp;oacute;dulo. Por ejemplo, si tanto &lt;code&gt;Foo&lt;/code&gt; como &lt;code&gt;Bar&lt;/code&gt; proporcionan una cadena literal no est&amp;aacute;ndar &lt;code&gt;@x_str&lt;/code&gt; , entonces se puede escribir &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; o &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; para eliminar la ambig&amp;uuml;edad entre los dos.</target>
        </trans-unit>
        <trans-unit id="9a888754236863b7dc502d80ea92bd70226cbd16" translate="yes" xml:space="preserve">
          <source>In the example above, the code between &lt;code&gt;#=&lt;/code&gt; and &lt;code&gt;=#&lt;/code&gt; is run as a &lt;code&gt;bash&lt;/code&gt; script. Julia ignores this part since it is a multi-line comment for Julia. The Julia code after &lt;code&gt;=#&lt;/code&gt; is ignored by &lt;code&gt;bash&lt;/code&gt; since it stops parsing the file once it reaches to the &lt;code&gt;exec&lt;/code&gt; statement.</source>
          <target state="translated">En el ejemplo anterior, el c&amp;oacute;digo entre &lt;code&gt;#=&lt;/code&gt; y &lt;code&gt;=#&lt;/code&gt; se ejecuta como un script &lt;code&gt;bash&lt;/code&gt; . Julia ignora esta parte ya que es un comentario de varias l&amp;iacute;neas para Julia. El c&amp;oacute;digo de Julia after &lt;code&gt;=#&lt;/code&gt; es ignorado por &lt;code&gt;bash&lt;/code&gt; ya que deja de analizar el archivo una vez que llega a la instrucci&amp;oacute;n &lt;code&gt;exec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fab8ccf3e309196934d3171621e67c5c348c19f" translate="yes" xml:space="preserve">
          <source>In the example below the in-range check for referencing element &lt;code&gt;i&lt;/code&gt; of array &lt;code&gt;A&lt;/code&gt; is skipped to improve performance.</source>
          <target state="translated">En el siguiente ejemplo, se omite la verificaci&amp;oacute;n dentro del rango para hacer referencia al elemento &lt;code&gt;i&lt;/code&gt; de la matriz &lt;code&gt;A&lt;/code&gt; para mejorar el rendimiento.</target>
        </trans-unit>
        <trans-unit id="93579590b1d00912366971a9f1eaa55dfd5a9050" translate="yes" xml:space="preserve">
          <source>In the example manifest file above, to find the path of the first &lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;&amp;mdash;Julia looks for its stanza in the manifest file, sees that it has a &lt;code&gt;path&lt;/code&gt; entry, looks at &lt;code&gt;deps/Priv&lt;/code&gt; relative to the &lt;code&gt;App&lt;/code&gt; project directory&amp;mdash;let's suppose the &lt;code&gt;App&lt;/code&gt; code lives in &lt;code&gt;/home/me/projects/App&lt;/code&gt;&amp;mdash;sees that &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; exists and therefore loads &lt;code&gt;Priv&lt;/code&gt; from there.</source>
          <target state="translated">En el archivo de manifiesto de ejemplo anterior, para encontrar la ruta del primer paquete &lt;code&gt;Priv&lt;/code&gt; (el que tiene UUID &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; ),Julia busca su estrofa en el archivo de manifiesto, ve que tiene una entrada de &lt;code&gt;path&lt;/code&gt; , busca en &lt;code&gt;deps/Priv&lt;/code&gt; relativo al directorio del proyecto de la &lt;code&gt;App&lt;/code&gt; , supongamos que el c&amp;oacute;digo de la &lt;code&gt;App&lt;/code&gt; reside en &lt;code&gt;/home/me/projects/App&lt;/code&gt; , ve que &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; existe y, por lo tanto, carga &lt;code&gt;Priv&lt;/code&gt; desde all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="d5f7b0ad7d3e9a880bbfbe0e4c7c117bb4c01b0c" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt;, each &lt;code&gt;I_k&lt;/code&gt; may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">En la expresi&amp;oacute;n &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; , cada &lt;code&gt;I_k&lt;/code&gt; puede ser un &amp;iacute;ndice escalar, una matriz de &amp;iacute;ndices escalares o un objeto que representa una matriz de &amp;iacute;ndices escalares y puede convertirse a tal mediante &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="fa27a03548fec1bfca9a5a7f95888f72d9a7ae58" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">En la expresi&amp;oacute;n &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; , la subexpresi&amp;oacute;n &lt;code&gt;b&lt;/code&gt; solo se eval&amp;uacute;a si &lt;code&gt;a&lt;/code&gt; se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bac07dea1e6da71dd93fed592d9cea2988762e4a" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a || b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">En la expresi&amp;oacute;n &lt;code&gt;a || b&lt;/code&gt; , la subexpresi&amp;oacute;n &lt;code&gt;b&lt;/code&gt; solo se eval&amp;uacute;a si &lt;code&gt;a&lt;/code&gt; se eval&amp;uacute;a como &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96db94e2ee75dc648cf0225c95d894886287a60b" translate="yes" xml:space="preserve">
          <source>In the first example, the return breaks out of &lt;code&gt;test1&lt;/code&gt; as soon as it hits an even number, so &lt;code&gt;test1([5,6,7])&lt;/code&gt; returns &lt;code&gt;12&lt;/code&gt;.</source>
          <target state="translated">En el primer ejemplo, el retorno sale de &lt;code&gt;test1&lt;/code&gt; tan pronto como llega a un n&amp;uacute;mero par, por lo que &lt;code&gt;test1([5,6,7])&lt;/code&gt; devuelve &lt;code&gt;12&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b8c088e43cc4d9778c3e9bd051248b7beb86cd4" translate="yes" xml:space="preserve">
          <source>In the first step, a handle to the Julia function &lt;code&gt;sqrt&lt;/code&gt; is retrieved by calling &lt;code&gt;jl_get_function&lt;/code&gt;. The first argument passed to &lt;code&gt;jl_get_function&lt;/code&gt; is a pointer to the &lt;code&gt;Base&lt;/code&gt; module in which &lt;code&gt;sqrt&lt;/code&gt; is defined. Then, the double value is boxed using &lt;code&gt;jl_box_float64&lt;/code&gt;. Finally, in the last step, the function is called using &lt;code&gt;jl_call1&lt;/code&gt;. &lt;code&gt;jl_call0&lt;/code&gt;, &lt;code&gt;jl_call2&lt;/code&gt;, and &lt;code&gt;jl_call3&lt;/code&gt; functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use &lt;code&gt;jl_call&lt;/code&gt;:</source>
          <target state="translated">En el primer paso, se recupera un identificador de la funci&amp;oacute;n de Julia &lt;code&gt;sqrt&lt;/code&gt; llamando a &lt;code&gt;jl_get_function&lt;/code&gt; . El primer argumento que se pasa a &lt;code&gt;jl_get_function&lt;/code&gt; es un puntero al m&amp;oacute;dulo &lt;code&gt;Base&lt;/code&gt; en el que se define &lt;code&gt;sqrt&lt;/code&gt; . Luego, el valor doble est&amp;aacute; &lt;code&gt;jl_box_float64&lt;/code&gt; usando jl_box_float64 . Finalmente, en el &amp;uacute;ltimo paso, la funci&amp;oacute;n se llama usando &lt;code&gt;jl_call1&lt;/code&gt; . Tambi&amp;eacute;n existen las funciones &lt;code&gt;jl_call0&lt;/code&gt; , &lt;code&gt;jl_call2&lt;/code&gt; y &lt;code&gt;jl_call3&lt;/code&gt; , para manejar convenientemente diferentes n&amp;uacute;meros de argumentos. Para pasar m&amp;aacute;s argumentos, use &lt;code&gt;jl_call&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7b958da57c917010bf3ef94ad88b96d1969aed7b" translate="yes" xml:space="preserve">
          <source>In the following REPL session:</source>
          <target state="translated">En la siguiente sesión de la REPL:</target>
        </trans-unit>
        <trans-unit id="c8932c25606bd0610c3cdf0d60756b479ad881b6" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes and call a generic function on it.</source>
          <target state="translated">En el siguiente ejemplo usaremos &lt;code&gt;DistributedArrays.jl&lt;/code&gt; y &lt;code&gt;CuArrays.jl&lt;/code&gt; para distribuir una matriz en m&amp;uacute;ltiples procesos y llamar a una funci&amp;oacute;n gen&amp;eacute;rica en ella.</target>
        </trans-unit>
        <trans-unit id="7ef78cc2f03187abe5d3245512be5e3c871b1647" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes by first casting it through &lt;code&gt;distribute()&lt;/code&gt; and &lt;code&gt;CuArray()&lt;/code&gt;.</source>
          <target state="translated">En el siguiente ejemplo, usaremos &lt;code&gt;DistributedArrays.jl&lt;/code&gt; y &lt;code&gt;CuArrays.jl&lt;/code&gt; para distribuir una matriz a trav&amp;eacute;s de m&amp;uacute;ltiples procesos lanz&amp;aacute;ndola primero a trav&amp;eacute;s de &lt;code&gt;distribute()&lt;/code&gt; y &lt;code&gt;CuArray()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eddb2dbc7e71b5027d64a28a0762a40add354815" translate="yes" xml:space="preserve">
          <source>In the following examples &lt;code&gt;&quot;...&quot;&lt;/code&gt; is used to illustrate an arbitrary docstring.</source>
          <target state="translated">En los siguientes ejemplos, &lt;code&gt;&quot;...&quot;&lt;/code&gt; se utiliza para ilustrar una cadena de documentos arbitraria.</target>
        </trans-unit>
        <trans-unit id="89782f85382fa4913d7651a1e194d5e19db89926" translate="yes" xml:space="preserve">
          <source>In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.</source>
          <target state="translated">En las siguientes secciones,repasaremos brevemente algunas técnicas que pueden ayudar a que tu código de Julia funcione lo más rápido posible.</target>
        </trans-unit>
        <trans-unit id="04625a717e704769cefecb369eb2164fdede25ee" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.</source>
          <target state="translated">En el primer caso,los números enteros se amplían al tamaño de la palabra del sistema y,por lo tanto,el resultado es 128.En el segundo caso,no se produce tal ensanchamiento y el desbordamiento de los números enteros da como resultado -128.</target>
        </trans-unit>
        <trans-unit id="96b938fab6579b9bca905e7cf7ff960b0076051e" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is &lt;code&gt;Int64[100, 128]&lt;/code&gt;. In the latter case, no such widening happens and integer overflow results in &lt;code&gt;Int8[100, -128]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459cd312cf19872b6f89a3fcbc8f7c42d8e4d02e" translate="yes" xml:space="preserve">
          <source>In the last example, a &lt;code&gt;Vector{Any}&lt;/code&gt; is produced; the reason is that &lt;code&gt;eltype(Die) == Any&lt;/code&gt;. The remedy is to define &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt;.</source>
          <target state="translated">En el &amp;uacute;ltimo ejemplo, se produce un &lt;code&gt;Vector{Any}&lt;/code&gt; ; la raz&amp;oacute;n es que &lt;code&gt;eltype(Die) == Any&lt;/code&gt; . El remedio es definir &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cbf68db8681a41c42664645e9482a6f5917d216" translate="yes" xml:space="preserve">
          <source>In the latter case, the result type is &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; since &lt;code&gt;BigInt&lt;/code&gt; is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; and &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; &amp;ndash; the symmetry is implied by the way &lt;code&gt;promote_rule&lt;/code&gt; is used in the promotion process.</source>
          <target state="translated">En el &amp;uacute;ltimo caso, el tipo de resultado es &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; ya que &lt;code&gt;BigInt&lt;/code&gt; es el &amp;uacute;nico tipo lo suficientemente grande como para contener n&amp;uacute;meros enteros para aritm&amp;eacute;tica de enteros de precisi&amp;oacute;n arbitraria. Tambi&amp;eacute;n tenga en cuenta que no es necesario definir tanto la &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; como la &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; - la simetr&amp;iacute;a est&amp;aacute; impl&amp;iacute;cita en el la forma en que se utiliza &lt;code&gt;promote_rule&lt;/code&gt; en el proceso de promoci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="53f7c1a582426e8808f0c1bf813e62ee2f97e7c7" translate="yes" xml:space="preserve">
          <source>In the meantime, overflow-safe integer operations can be achieved through the use of external libraries such as &lt;a href=&quot;https://github.com/JeffreySarnoff/SaferIntegers.jl&quot;&gt;SaferIntegers.jl&lt;/a&gt;. Note that, as stated previously, the use of these libraries significantly increases the execution time of code using the checked integer types. However, for limited usage, this is far less of an issue than if it were used for all integer operations. You can follow the status of the discussion &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/855&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898e17acc6c8cf82e0dc07003deafaedea5b3686" translate="yes" xml:space="preserve">
          <source>In these and other cases, you can get the result you want by choosing an &lt;em&gt;input type&lt;/em&gt; that conveys your willingness to accept an &lt;em&gt;output type&lt;/em&gt; in which the result can be represented:</source>
          <target state="translated">En estos y otros casos, puede obtener el resultado que desea eligiendo un &lt;em&gt;tipo de entrada&lt;/em&gt; que transmita su voluntad de aceptar un &lt;em&gt;tipo de salida&lt;/em&gt; en el que se pueda representar el resultado:</target>
        </trans-unit>
        <trans-unit id="0181a5895aa6ed6a57ecf3e1abb5400987bdae76" translate="yes" xml:space="preserve">
          <source>In these examples, &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt;, which has two fields. &lt;code&gt;b&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt;, which is a primitive bitstype with no fields at all. &lt;code&gt;ex&lt;/code&gt; is an &lt;a href=&quot;#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt;, which has one field.</source>
          <target state="translated">En estos ejemplos, &lt;code&gt;a&lt;/code&gt; es un &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt; , que tiene dos campos. &lt;code&gt;b&lt;/code&gt; es un &lt;code&gt;Int&lt;/code&gt; , que es un bitstype primitivo sin campos en absoluto. &lt;code&gt;ex&lt;/code&gt; es una &lt;a href=&quot;#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt; , que tiene un campo.</target>
        </trans-unit>
        <trans-unit id="e95b83474ed0f82b1495ebdd8823b0e63d6666c2" translate="yes" xml:space="preserve">
          <source>In this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.</source>
          <target state="translated">En este y todos los ejemplos siguientes se supone que su nivel superior es de alcance mundial con un espacio de trabajo limpio,por ejemplo,un REPL recién iniciado.</target>
        </trans-unit>
        <trans-unit id="ffae775fe01ba274356f2a5f0bbbfa16bf832464" translate="yes" xml:space="preserve">
          <source>In this case &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; MUST be defined in the remote process. Note that &lt;code&gt;A&lt;/code&gt; is a global variable defined in the local workspace. Worker 2 does not have a variable called &lt;code&gt;A&lt;/code&gt; under &lt;code&gt;Main&lt;/code&gt;. The act of shipping the closure &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; to worker 2 results in &lt;code&gt;Main.A&lt;/code&gt; being defined on 2. &lt;code&gt;Main.A&lt;/code&gt; continues to exist on worker 2 even after the call &lt;code&gt;remotecall_fetch&lt;/code&gt; returns. Remote calls with embedded global references (under &lt;code&gt;Main&lt;/code&gt; module only) manage globals as follows:</source>
          <target state="translated">En este caso, la &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; a&lt;/a&gt; DEBE definirse en el proceso remoto. Tenga en cuenta que &lt;code&gt;A&lt;/code&gt; es una variable global definida en el espacio de trabajo local. El trabajador 2 no tiene una variable llamada &lt;code&gt;A&lt;/code&gt; en &lt;code&gt;Main&lt;/code&gt; . El acto de enviar el cierre &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; al trabajador 2 da como resultado que &lt;code&gt;Main.A&lt;/code&gt; se defina en 2. &lt;code&gt;Main.A&lt;/code&gt; sigue existiendo en el trabajador 2 incluso despu&amp;eacute;s de que regrese la llamada &lt;code&gt;remotecall_fetch&lt;/code&gt; . Las llamadas remotas con referencias globales integradas ( solo en el m&amp;oacute;dulo &lt;code&gt;Main&lt;/code&gt; ) gestionan globales de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="0560676ee24f0b0b03f58f97d95e6f878eed22df" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; is better. It is also more helpful to the compiler to annotate specific uses (e.g. &lt;code&gt;a[i]::Int&lt;/code&gt;) than to try to pack many alternatives into one type.</source>
          <target state="translated">En este caso, &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; es mejor. Tambi&amp;eacute;n es m&amp;aacute;s &amp;uacute;til para el compilador anotar usos espec&amp;iacute;ficos (por ejemplo, &lt;code&gt;a[i]::Int&lt;/code&gt; ) que intentar empaquetar muchas alternativas en un solo tipo.</target>
        </trans-unit>
        <trans-unit id="e89af6907bd5ca30fed3e340c7ce252f260cfa01" translate="yes" xml:space="preserve">
          <source>In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:</source>
          <target state="translated">En este caso,una tupla de valores se empalma en una llamada varargs precisamente donde va el número variable de argumentos.Sin embargo,este no tiene por qué ser el caso:</target>
        </trans-unit>
        <trans-unit id="567cd07e5f348036853e90930a72f1f415e7cf4a" translate="yes" xml:space="preserve">
          <source>In this case the final (empty) line before the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; sets the indentation level.</source>
          <target state="translated">En este caso, la l&amp;iacute;nea final (vac&amp;iacute;a) antes del cierre &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; establece el nivel de sangr&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="192b075c1bd1fea405ec3cb3c290131367b6aebf" translate="yes" xml:space="preserve">
          <source>In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if &lt;code&gt;q[i,j,t]&lt;/code&gt; is near the end of the block assigned to one worker and &lt;code&gt;q[i,j,t+1]&lt;/code&gt; is near the beginning of the block assigned to another, it's very likely that &lt;code&gt;q[i,j,t]&lt;/code&gt; will not be ready at the time it's needed for computing &lt;code&gt;q[i,j,t+1]&lt;/code&gt;. In such cases, one is better off chunking the array manually. Let's split along the second dimension. Define a function that returns the &lt;code&gt;(irange, jrange)&lt;/code&gt; indices assigned to this worker:</source>
          <target state="translated">En este caso, si tratamos de dividir el trabajo usando un &amp;iacute;ndice unidimensional, es probable que tengamos problemas: si &lt;code&gt;q[i,j,t]&lt;/code&gt; est&amp;aacute; cerca del final del bloque asignado a un trabajador &lt;code&gt;q[i,j,t+1]&lt;/code&gt; est&amp;aacute; cerca del comienzo del bloque asignado a otro, es muy probable que &lt;code&gt;q[i,j,t]&lt;/code&gt; no est&amp;eacute; listo en el momento en que se necesita para calcular &lt;code&gt;q[i,j,t+1]&lt;/code&gt; . En tales casos, es mejor fragmentar la matriz manualmente. Dividamos a lo largo de la segunda dimensi&amp;oacute;n. Defina una funci&amp;oacute;n que devuelva los &lt;code&gt;(irange, jrange)&lt;/code&gt; asignados a este trabajador:</target>
        </trans-unit>
        <trans-unit id="b26744f8a00507231770f287451074d8e90f3846" translate="yes" xml:space="preserve">
          <source>In this case, the character &lt;code&gt;&amp;forall;&lt;/code&gt; is a three-byte character, so the indices 2 and 3 are invalid and the next character's index is 4; this next valid index can be computed by &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind(s,1)&lt;/code&gt;&lt;/a&gt;, and the next index after that by &lt;code&gt;nextind(s,4)&lt;/code&gt; and so on.</source>
          <target state="translated">En este caso, el car&amp;aacute;cter &lt;code&gt;&amp;forall;&lt;/code&gt; es un car&amp;aacute;cter de tres bytes, por lo que los &amp;iacute;ndices 2 y 3 no son v&amp;aacute;lidos y el &amp;iacute;ndice del siguiente car&amp;aacute;cter es 4; este siguiente &amp;iacute;ndice v&amp;aacute;lido puede ser calculado por &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind(s,1)&lt;/code&gt; &lt;/a&gt; , y el siguiente &amp;iacute;ndice despu&amp;eacute;s de &lt;code&gt;nextind(s,4)&lt;/code&gt; por nextind (s, 4) y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="e5db3b629f524d1fec7f4ffc91f2ae6bde25d1db" translate="yes" xml:space="preserve">
          <source>In this case, the speedup due to &lt;code&gt;@fastmath&lt;/code&gt; is a factor of about 3.7. This is unusually large &amp;ndash; in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result &amp;ndash; in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.</source>
          <target state="translated">En este caso, la aceleraci&amp;oacute;n debida a &lt;code&gt;@fastmath&lt;/code&gt; es un factor de aproximadamente 3,7. Esto es inusualmente grande; en general, la aceleraci&amp;oacute;n ser&amp;aacute; menor. (En este ejemplo en particular, el conjunto de trabajo del punto de referencia es lo suficientemente peque&amp;ntilde;o como para caber en la cach&amp;eacute; L1 del procesador, por lo que la latencia de acceso a la memoria no influye y el tiempo de computaci&amp;oacute;n est&amp;aacute; dominado por el uso de la CPU. En muchos programas del mundo real este no es el caso). Adem&amp;aacute;s, en este caso, esta optimizaci&amp;oacute;n no cambia el resultado; en general, el resultado ser&amp;aacute; ligeramente diferente. En algunos casos, especialmente para algoritmos num&amp;eacute;ricamente inestables, el resultado puede ser muy diferente.</target>
        </trans-unit>
        <trans-unit id="6188940203c290544c44a0f6a7e7493e9e0ab89b" translate="yes" xml:space="preserve">
          <source>In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see &lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs&lt;/a&gt;.</source>
          <target state="translated">En este contexto, MPI se refiere al est&amp;aacute;ndar MPI-1. A partir de MPI-2, el comit&amp;eacute; de est&amp;aacute;ndares de MPI introdujo un nuevo conjunto de mecanismos de comunicaci&amp;oacute;n, denominados colectivamente Acceso a memoria remota (RMA). La motivaci&amp;oacute;n para agregar rma al est&amp;aacute;ndar MPI fue facilitar patrones de comunicaci&amp;oacute;n unilaterales. Para obtener informaci&amp;oacute;n adicional sobre el &amp;uacute;ltimo est&amp;aacute;ndar MPI, consulte &lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92a7a3f559dc2f0e3123bf1d2da5d1162f830e7c" translate="yes" xml:space="preserve">
          <source>In this example it is accomplished by defining &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; to create the appropriate wrapped array. (Note that while &lt;code&gt;similar&lt;/code&gt; supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it's important that &lt;code&gt;SparseArray&lt;/code&gt; is mutable (supports &lt;code&gt;setindex!&lt;/code&gt;). Defining &lt;code&gt;similar&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt; and &lt;code&gt;setindex!&lt;/code&gt; for &lt;code&gt;SparseArray&lt;/code&gt; also makes it possible to &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; the array:</source>
          <target state="translated">En este ejemplo, se logra definiendo &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; para crear la matriz envuelta adecuada. (Tenga en cuenta que si bien &lt;code&gt;similar&lt;/code&gt; admite formas de 1 y 2 argumentos, en la mayor&amp;iacute;a de los casos solo necesita especializarse en la forma de 3 argumentos). Para que esto funcione, es importante que &lt;code&gt;SparseArray&lt;/code&gt; sea ​​mutable (&amp;iexcl;admite &lt;code&gt;setindex!&lt;/code&gt; ). Definiendo &lt;code&gt;similar&lt;/code&gt; , &lt;code&gt;getindex&lt;/code&gt; y &lt;code&gt;setindex!&lt;/code&gt; para &lt;code&gt;SparseArray&lt;/code&gt; tambi&amp;eacute;n hace posible &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; la matriz:</target>
        </trans-unit>
        <trans-unit id="05a24eb92f7d5686dff145712d9c9981f290a66e" translate="yes" xml:space="preserve">
          <source>In this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After exiting both catch blocks normally (i.e., without throwing a further exception) all exceptions are removed from the stack and are no longer accessible.</source>
          <target state="translated">En este ejemplo,la excepción de la causa raíz (A)está primero en la pila,con otra excepción (B)después de ella.Después de salir de ambos bloques de captura normalmente (es decir,sin lanzar otra excepción)todas las excepciones se retiran de la pila y ya no son accesibles.</target>
        </trans-unit>
        <trans-unit id="4336cae1e8edd1087fd9411fb166bd6a222c2c06" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;A&lt;/code&gt; is a mutable container that contains one element, which can be set by &lt;code&gt;A[] = 1.0&lt;/code&gt; and retrieved with &lt;code&gt;A[]&lt;/code&gt;. All zero-dimensional arrays have the same size (&lt;code&gt;size(A) == ()&lt;/code&gt;), and length (&lt;code&gt;length(A) == 1&lt;/code&gt;). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia's definition.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;A&lt;/code&gt; es un contenedor mutable que contiene un elemento, que puede establecerse con &lt;code&gt;A[] = 1.0&lt;/code&gt; y recuperarse con &lt;code&gt;A[]&lt;/code&gt; . Todas las matrices de dimensi&amp;oacute;n cero tienen el mismo tama&amp;ntilde;o ( &lt;code&gt;size(A) == ()&lt;/code&gt; ) y longitud ( &lt;code&gt;length(A) == 1&lt;/code&gt; ). En particular, las matrices de dimensi&amp;oacute;n cero no est&amp;aacute;n vac&amp;iacute;as. Si encuentra esto poco intuitivo, aqu&amp;iacute; hay algunas ideas que pueden ayudar a comprender la definici&amp;oacute;n de Julia.</target>
        </trans-unit>
        <trans-unit id="6a0bf2dc540c812cb1923adeb5876321d55dbf26" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;N&lt;/code&gt; is passed as a parameter, so its &quot;value&quot; is known to the compiler. Essentially, &lt;code&gt;Val(T)&lt;/code&gt; works only when &lt;code&gt;T&lt;/code&gt; is either hard-coded/literal (&lt;code&gt;Val(3)&lt;/code&gt;) or already specified in the type-domain.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;N&lt;/code&gt; se pasa como par&amp;aacute;metro, por lo que el compilador conoce su &quot;valor&quot;. Esencialmente, &lt;code&gt;Val(T)&lt;/code&gt; funciona solo cuando &lt;code&gt;T&lt;/code&gt; est&amp;aacute; codificado de forma r&amp;iacute;gida / literal ( &lt;code&gt;Val(3)&lt;/code&gt; ) o ya est&amp;aacute; especificado en el dominio de tipo.</target>
        </trans-unit>
        <trans-unit id="92f4b81b4c3f20308317f94d5766f434fb02e58c" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;b&lt;/code&gt; is a runnable &lt;code&gt;Task&lt;/code&gt; that hasn't started yet.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;b&lt;/code&gt; es una &lt;code&gt;Task&lt;/code&gt; ejecutable que a&amp;uacute;n no se ha iniciado.</target>
        </trans-unit>
        <trans-unit id="9f7bc1ef4d38fd2e360681f2040c8ad0f73774eb" translate="yes" xml:space="preserve">
          <source>In this example, observe that the new definition for &lt;code&gt;newfun&lt;/code&gt; has been created, but can't be immediately called. The new global is immediately visible to the &lt;code&gt;tryeval&lt;/code&gt; function, so you could write &lt;code&gt;return newfun&lt;/code&gt; (without parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new method definition!</source>
          <target state="translated">En este ejemplo, observe que se ha creado la nueva definici&amp;oacute;n de &lt;code&gt;newfun&lt;/code&gt; , pero no se puede llamar de inmediato. El nuevo global es inmediatamente visible para la funci&amp;oacute;n &lt;code&gt;tryeval&lt;/code&gt; , por lo que puede escribir &lt;code&gt;return newfun&lt;/code&gt; (sin par&amp;eacute;ntesis). &amp;iexcl;Pero ni usted, ni ninguno de sus llamantes, ni las funciones a las que llaman, etc., pueden llamar a esta nueva definici&amp;oacute;n de m&amp;eacute;todo!</target>
        </trans-unit>
        <trans-unit id="f0f0d16b1aed858c0d51da9625d8755a2c35d48e" translate="yes" xml:space="preserve">
          <source>In this example, the remote which is being fetched from &lt;em&gt;does&lt;/em&gt; have a file called &lt;code&gt;our_file&lt;/code&gt; in its index, which is why we must reset.</source>
          <target state="translated">En este ejemplo, el mando a distancia que se han recuperado desde &lt;em&gt;hace&lt;/em&gt; tener un archivo llamado &lt;code&gt;our_file&lt;/code&gt; en su &amp;iacute;ndice, por lo que hay que restablecer.</target>
        </trans-unit>
        <trans-unit id="a138591f083f547736d80bd3d40dd03ced901f2b" translate="yes" xml:space="preserve">
          <source>In this example, the task ran on pid 2, called from pid 1.</source>
          <target state="translated">En este ejemplo,la tarea se ejecutó en el PID 2,llamado desde el PID 1.</target>
        </trans-unit>
        <trans-unit id="f39c0221e85d683a6f4024da4ca9271cf6b8c812" translate="yes" xml:space="preserve">
          <source>In this example, the tuple &lt;code&gt;(1,2,3)&lt;/code&gt; is interpolated as an expression into a conditional test:</source>
          <target state="translated">En este ejemplo, la tupla &lt;code&gt;(1,2,3)&lt;/code&gt; se interpola como una expresi&amp;oacute;n en una prueba condicional:</target>
        </trans-unit>
        <trans-unit id="a8e780cf12ef36b63b08a74c8c07d0b380150440" translate="yes" xml:space="preserve">
          <source>In this example, the value of variable &lt;code&gt;a&lt;/code&gt; is interpolated:</source>
          <target state="translated">En este ejemplo, se interpola el valor de la variable &lt;code&gt;a&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d77924d6298476fc4b219142016e1167310fe63c" translate="yes" xml:space="preserve">
          <source>In this example, we can see that the top level function called is in the file &lt;code&gt;event.jl&lt;/code&gt;. This is the function that runs the REPL when you launch Julia. If you examine line 97 of &lt;code&gt;REPL.jl&lt;/code&gt;, you'll see this is where the function &lt;code&gt;eval_user_input()&lt;/code&gt; is called. This is the function that evaluates what you type at the REPL, and since we're working interactively these functions were invoked when we entered &lt;code&gt;@profile myfunc()&lt;/code&gt;. The next line reflects actions taken in the &lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt;&lt;code&gt;@profile&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">En este ejemplo, podemos ver que la funci&amp;oacute;n de nivel superior llamada est&amp;aacute; en el archivo &lt;code&gt;event.jl&lt;/code&gt; . Esta es la funci&amp;oacute;n que ejecuta REPL cuando inicia Julia. Si examina la l&amp;iacute;nea 97 de &lt;code&gt;REPL.jl&lt;/code&gt; , ver&amp;aacute; que aqu&amp;iacute; es donde se llama a la funci&amp;oacute;n &lt;code&gt;eval_user_input()&lt;/code&gt; . Esta es la funci&amp;oacute;n que eval&amp;uacute;a lo que escribe en el REPL, y dado que estamos trabajando de forma interactiva, estas funciones se invocaron cuando &lt;code&gt;@profile myfunc()&lt;/code&gt; . La siguiente l&amp;iacute;nea refleja las acciones realizadas en la macro &lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt; &lt;code&gt;@profile&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c91076ff3785f6e6c7acf1c7077368cdbb7151f" translate="yes" xml:space="preserve">
          <source>In this manner, Julia acts as its own &lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;preprocessor&lt;/a&gt;, and allows code generation from inside the language. The above code could be written slightly more tersely using the &lt;code&gt;:&lt;/code&gt; prefix quoting form:</source>
          <target state="translated">De esta manera, Julia act&amp;uacute;a como su propio &lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;preprocesador&lt;/a&gt; y permite la generaci&amp;oacute;n de c&amp;oacute;digo desde dentro del lenguaje. El c&amp;oacute;digo anterior podr&amp;iacute;a escribirse un poco m&amp;aacute;s concisamente usando la forma de comillas &lt;code&gt;:&lt;/code&gt; prefix:</target>
        </trans-unit>
        <trans-unit id="7bd6fc4b177020a8a663dcee2fb9c4c397754164" translate="yes" xml:space="preserve">
          <source>In this module we export the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; functions (with the keyword &lt;code&gt;export&lt;/code&gt;), and also have the non-exported function &lt;code&gt;p&lt;/code&gt;. There are several different ways to load the Module and its inner functions into the current workspace:</source>
          <target state="translated">En este m&amp;oacute;dulo exportar el &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; funciones (con la palabra clave &lt;code&gt;export&lt;/code&gt; ), y tambi&amp;eacute;n tienen la funci&amp;oacute;n no exportada &lt;code&gt;p&lt;/code&gt; . Hay varias formas diferentes de cargar el m&amp;oacute;dulo y sus funciones internas en el espacio de trabajo actual:</target>
        </trans-unit>
        <trans-unit id="dcdbf4c0d317d8b968227eee1bb592e9cd8a0e88" translate="yes" xml:space="preserve">
          <source>In this particular case, the number of elements skipped &lt;em&gt;in memory&lt;/em&gt; matches the number of &lt;em&gt;linear indices&lt;/em&gt; skipped. This is only the case for contiguous arrays like &lt;code&gt;Array&lt;/code&gt; (and other &lt;code&gt;DenseArray&lt;/code&gt; subtypes) and is not true in general. Views with range indices are a good example of &lt;em&gt;non-contiguous&lt;/em&gt; strided arrays; consider &lt;code&gt;V = @view A[1:3:4, 2:2:6, 2:-1:1]&lt;/code&gt;. This view &lt;code&gt;V&lt;/code&gt; refers to the same memory as &lt;code&gt;A&lt;/code&gt; but is skipping and re-arranging some of its elements. The stride of the first dimension of &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; because we're only selecting every third row from our original array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fa363c46c4da719440f0a895d038cea7c0f22d" translate="yes" xml:space="preserve">
          <source>In this situation, use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to skip missing values</source>
          <target state="translated">En esta situaci&amp;oacute;n, utilice el &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt; funci&amp;oacute;n para omitir los valores perdidos</target>
        </trans-unit>
        <trans-unit id="9db9e9e3387eacd52cbab3963439723e71f36736" translate="yes" xml:space="preserve">
          <source>In this style of definition, the code generation feature is essentially an optional optimization. The compiler will use it if convenient, but otherwise may choose to use the normal implementation instead. This style is preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since normal code is more readable than code-generating code. However, which implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically.</source>
          <target state="translated">En este estilo de definición,la característica de generación de código es esencialmente una optimización opcional.El compilador la usará si es conveniente,pero por lo demás puede optar por usar la implementación normal en su lugar.Se prefiere este estilo,ya que permite al compilador tomar más decisiones y compilar programas de más maneras,y ya que el código normal es más legible que el código de generación de código.Sin embargo,la implementación que se utilice depende de los detalles de la implementación del compilador,por lo que es esencial que ambas implementaciones se comporten de forma idéntica.</target>
        </trans-unit>
        <trans-unit id="2472bd128ff5a0c2f02732fc91d35900b7540e31" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="translated">En este ejemplo de juguete, los dos m&amp;eacute;todos son f&amp;aacute;ciles de distinguir y elegir. Sin embargo, en un programa real, el dise&amp;ntilde;o del movimiento de datos puede requerir m&amp;aacute;s reflexi&amp;oacute;n y probablemente alguna medici&amp;oacute;n. Por ejemplo, si el primer proceso necesita la matriz &lt;code&gt;A&lt;/code&gt; , entonces el primer m&amp;eacute;todo podr&amp;iacute;a ser mejor. O, si calcular &lt;code&gt;A&lt;/code&gt; es costoso y solo el proceso actual lo tiene, entonces moverlo a otro proceso podr&amp;iacute;a ser inevitable. O, si el proceso actual tiene muy poco que ver entre &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;fetch(Bref)&lt;/code&gt; , podr&amp;iacute;a ser mejor eliminar el paralelismo por completo. O imagine que el &lt;code&gt;rand(1000,1000)&lt;/code&gt; se reemplaza con una operaci&amp;oacute;n m&amp;aacute;s cara. Entonces podr&amp;iacute;a tener sentido agregar otra declaraci&amp;oacute;n &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt; solo para este paso.</target>
        </trans-unit>
        <trans-unit id="4f15c62fbcd9523fb3f2a21376c6d6f2fb45889e" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf538f8e56ca0f93d90636a083c95bfe08cc9992" translate="yes" xml:space="preserve">
          <source>In this way a mesh network is established, wherein every worker is directly connected with every other worker.</source>
          <target state="translated">De esta manera se establece una red de malla,en la que cada trabajador está directamente conectado con todos los demás trabajadores.</target>
        </trans-unit>
        <trans-unit id="77e752e41de1e6877a1adbe41bf7b76e4f16d104" translate="yes" xml:space="preserve">
          <source>In-memory representation of a file entry in the index. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt;&lt;code&gt;git_index_entry&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Representaci&amp;oacute;n en memoria de una entrada de archivo en el &amp;iacute;ndice. Coincide con la estructura &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt; &lt;code&gt;git_index_entry&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06c7aeba98a0f145bac3596871ee20c6209a6fe5" translate="yes" xml:space="preserve">
          <source>In-place broadcasting can be supported by defining the appropriate &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; method. Because you might want to specialize either on &lt;code&gt;dest&lt;/code&gt; or the specific subtype of &lt;code&gt;bc&lt;/code&gt;, to avoid ambiguities between packages we recommend the following convention.</source>
          <target state="translated">Se puede &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; transmisi&amp;oacute;n en el lugar definiendo el m&amp;eacute;todo copyto! (Dest, bc :: Broadcasted) apropiado . Debido a que es posible que desee especializarse en &lt;code&gt;dest&lt;/code&gt; o en el subtipo espec&amp;iacute;fico de &lt;code&gt;bc&lt;/code&gt; , para evitar ambig&amp;uuml;edades entre paquetes, recomendamos la siguiente convenci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9b8eaa806ba1cb1b5e2ab868bf0bb847fbaf77f5" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc665a97127feb38e6b15a0be58c4193afb4afe7" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt;: randomly permute &lt;code&gt;v&lt;/code&gt; in-place, optionally supplying the random-number generator &lt;code&gt;rng&lt;/code&gt;.</source>
          <target state="translated">Versi&amp;oacute;n en el lugar de &lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt; : permutar aleatoriamente &lt;code&gt;v&lt;/code&gt; en el lugar, proporcionando opcionalmente el generador de n&amp;uacute;meros aleatorios &lt;code&gt;rng&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceae787569f3577706adf60b6b428b09067c76dc" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;code&gt;reverse&lt;/code&gt;.</source>
          <target state="translated">Versi&amp;oacute;n in situ del &lt;code&gt;reverse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d77496985aa0ae694adc6f64d73e36e7d090fe55" translate="yes" xml:space="preserve">
          <source>Inbox Tray</source>
          <target state="translated">Bandeja de entrada</target>
        </trans-unit>
        <trans-unit id="973cab0f46e932b28084ce2f784990fa4e35559b" translate="yes" xml:space="preserve">
          <source>Include a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.</source>
          <target state="translated">Incluya una sola frase de una línea que describa lo que hace la función o lo que representa el objeto después del bloque de firma simplificado.Si es necesario,proporcione más detalles en un segundo párrafo,después de una línea en blanco.</target>
        </trans-unit>
        <trans-unit id="7962fdf356cdba272a5b5a5a58199f8e50948161" translate="yes" xml:space="preserve">
          <source>Include any code examples in an &lt;code&gt;# Examples&lt;/code&gt; section.</source>
          <target state="translated">Incluya cualquier ejemplo de c&amp;oacute;digo en una secci&amp;oacute;n &lt;code&gt;# Examples&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66cb3917171f2315e55b05172cef1568516a6218" translate="yes" xml:space="preserve">
          <source>Including the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base definitions, for example testing code by running it with &quot;safe&quot; versions of some operators:</source>
          <target state="translated">Incluir el mismo código en diferentes módulos proporciona un comportamiento mixto.Uno podría usar esto para ejecutar el mismo código con diferentes definiciones de base,por ejemplo probando el código ejecutándolo con versiones &quot;seguras&quot; de algunos operadores:</target>
        </trans-unit>
        <trans-unit id="3677c6602caed5b57fccc20b31958c9939eb0f57" translate="yes" xml:space="preserve">
          <source>Incoming Envelope</source>
          <target state="translated">El sobre entrante</target>
        </trans-unit>
        <trans-unit id="1cebd71683222b1c7af41849d615c19b10f8b1ef" translate="yes" xml:space="preserve">
          <source>Incomplete Initialization</source>
          <target state="translated">Inicialización incompleta</target>
        </trans-unit>
        <trans-unit id="700503508878aea14fc71ea0dd89adddb349e058" translate="yes" xml:space="preserve">
          <source>Increases As</source>
          <target state="translated">Aumenta a medida que</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="81769cec07065990cf97fe9de01e67d1dff5a01a" translate="yes" xml:space="preserve">
          <source>Incremental history search, described above</source>
          <target state="translated">Búsqueda incremental de la historia,descrita anteriormente</target>
        </trans-unit>
        <trans-unit id="7777e9a1cc822589b38fa2cf3b16ff5bb4405461" translate="yes" xml:space="preserve">
          <source>IndexCartesian</source>
          <target state="translated">IndexCartesian</target>
        </trans-unit>
        <trans-unit id="0ad6144c812efd669c1e0522b10d3e8d01b0818e" translate="yes" xml:space="preserve">
          <source>IndexLinear</source>
          <target state="translated">IndexLinear</target>
        </trans-unit>
        <trans-unit id="5c7d3a57514b6cbb8c7494df1aa031252a9240c0" translate="yes" xml:space="preserve">
          <source>IndexStyle</source>
          <target state="translated">IndexStyle</target>
        </trans-unit>
        <trans-unit id="8b48578d3b12e1d393eb06b8ea5bee4e6f0ec92a" translate="yes" xml:space="preserve">
          <source>Indexable Collections</source>
          <target state="translated">Colecciones indexables</target>
        </trans-unit>
        <trans-unit id="04f77b5a53e8914ea949c0d3dbe59ff927176c3a" translate="yes" xml:space="preserve">
          <source>Indexed Assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="0795ddb093e3d5dd1a985acb78a5e1baf2eef779" translate="yes" xml:space="preserve">
          <source>Indexing and assignment</source>
          <target state="translated">Indización y asignación</target>
        </trans-unit>
        <trans-unit id="4274ea6199202594d8373033384d6bdb729f3196" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.</source>
          <target state="translated">Indicar que una función de clasificación debe utilizar el algoritmo de clasificación de inserción.La ordenación de la inserción atraviesa la colección un elemento a la vez,insertando cada elemento en su posición correcta y ordenada en la lista de salida.</target>
        </trans-unit>
        <trans-unit id="1a127225335e9d3a07a6be83a0e208ad31b15ede" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.</source>
          <target state="translated">Indicar que una función de clasificación debe utilizar el algoritmo de clasificación de fusión.Merge sort divide la colección en subcolecciones y las fusiona repetidamente,clasificando cada subcolección en cada paso,hasta que la colección completa se haya recombinado en forma ordenada.</target>
        </trans-unit>
        <trans-unit id="f0d9438aae14ca6f51f78f417b7df01df9f079a5" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest &lt;code&gt;k&lt;/code&gt; elements sorted from smallest to largest, finding them and sorting them using &lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt;&lt;code&gt;QuickSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Indique que una funci&amp;oacute;n de clasificaci&amp;oacute;n debe utilizar el algoritmo de clasificaci&amp;oacute;n r&amp;aacute;pida parcial. La ordenaci&amp;oacute;n r&amp;aacute;pida parcial devuelve los &lt;code&gt;k&lt;/code&gt; elementos m&amp;aacute;s peque&amp;ntilde;os ordenados de menor a mayor, encontr&amp;aacute;ndolos y orden&amp;aacute;ndolos usando &lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt; &lt;code&gt;QuickSort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c75327b4e50aced7a786e9b2e8496c590cde6e" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the quick sort algorithm, which is &lt;em&gt;not&lt;/em&gt; stable.</source>
          <target state="translated">Indique que una funci&amp;oacute;n de clasificaci&amp;oacute;n debe utilizar el algoritmo de clasificaci&amp;oacute;n r&amp;aacute;pida, que &lt;em&gt;no&lt;/em&gt; es estable.</target>
        </trans-unit>
        <trans-unit id="a54eb733590aa2b40370b6fb359ea865b8d99e9b" translate="yes" xml:space="preserve">
          <source>Indicate whether &lt;code&gt;x&lt;/code&gt; is &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Indicar si &lt;code&gt;x&lt;/code&gt; est&amp;aacute; &lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efe98c42fb3d546aaef0cbe63f84a3ed426eef2d" translate="yes" xml:space="preserve">
          <source>Indicates a test that should pass but currently consistently fails. Tests that the expression &lt;code&gt;ex&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; or causes an exception. Returns a &lt;code&gt;Broken&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it does, or an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if the expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Indica una prueba que deber&amp;iacute;a aprobarse pero que actualmente falla constantemente. Comprueba que la expresi&amp;oacute;n &lt;code&gt;ex&lt;/code&gt; se eval&amp;uacute;a como &lt;code&gt;false&lt;/code&gt; o provoca una excepci&amp;oacute;n. Devuelve un &lt;code&gt;Result&lt;/code&gt; &lt;code&gt;Broken&lt;/code&gt; si lo hace, o un &lt;code&gt;Result&lt;/code&gt; &lt;code&gt;Error&lt;/code&gt; si la expresi&amp;oacute;n se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f58aeaea39a890601871a48e22cb88bfcd1c627a" translate="yes" xml:space="preserve">
          <source>Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).</source>
          <target state="translated">Indica el estado de salida problemático de un proceso.Cuando se ejecutan comandos o tuberías,se lanza para indicar que se ha devuelto un código de salida distinto de cero (es decir,que el proceso invocado ha fallado).</target>
        </trans-unit>
        <trans-unit id="ff3a5eaf7321b1b596df1bcd003dbd2f9fcf89b1" translate="yes" xml:space="preserve">
          <source>Indices are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Los &amp;iacute;ndices son del mismo tipo que los devueltos por &lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9e9b57819d8a4759652850ab76b4d97192200f0" translate="yes" xml:space="preserve">
          <source>Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.</source>
          <target state="translated">Los &amp;iacute;ndices se pueden omitir si las dimensiones finales que no est&amp;aacute;n indexadas son todas de longitud uno. En otras palabras, los &amp;iacute;ndices finales se pueden omitir solo si solo hay un valor posible que esos &amp;iacute;ndices omitidos podr&amp;iacute;an ser para una expresi&amp;oacute;n de indexaci&amp;oacute;n dentro de los l&amp;iacute;mites. Por ejemplo, una matriz de cuatro dimensiones con tama&amp;ntilde;o &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; puede indexarse ​​con solo tres &amp;iacute;ndices, ya que la dimensi&amp;oacute;n que se omite (la cuarta dimensi&amp;oacute;n) tiene la longitud uno. Tenga en cuenta que la indexaci&amp;oacute;n lineal tiene prioridad sobre esta regla.</target>
        </trans-unit>
        <trans-unit id="a9eddea567bcc33c91213abd188cec156d2bbedc" translate="yes" xml:space="preserve">
          <source>Indices or keys are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Los &amp;iacute;ndices o claves son del mismo tipo que los devueltos por las &lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt; y los &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3e37e52d9d94ec6a75ede0c2186d1f73dd06e01f" translate="yes" xml:space="preserve">
          <source>Indirect Calls</source>
          <target state="translated">Llamadas indirectas</target>
        </trans-unit>
        <trans-unit id="8b89285e1320e669387b56f7e30bddb1aefce498" translate="yes" xml:space="preserve">
          <source>Individual pointers returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; can be translated into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s by passing them into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt;&lt;code&gt;StackTraces.lookup&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Los punteros individuales devueltos por &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt; se pueden traducir a &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt; s pas&amp;aacute;ndolos a &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt; &lt;code&gt;StackTraces.lookup&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f462554871703067824392ec24cc8ae7c200c6ce" translate="yes" xml:space="preserve">
          <source>Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes. Here's a simple example of a Perl one-liner at a shell prompt:</source>
          <target state="translated">Inevitablemente,uno quiere escribir comandos que no son tan simples,y se hace necesario usar comillas.Aquí hay un ejemplo simple de una línea de Perl en un intérprete de comandos:</target>
        </trans-unit>
        <trans-unit id="b24e30d8c474981541dc914b04b492ae2c3460dd" translate="yes" xml:space="preserve">
          <source>Inexact equality comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt;. The default &lt;code&gt;atol&lt;/code&gt; is zero and the default &lt;code&gt;rtol&lt;/code&gt; depends on the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The keyword argument &lt;code&gt;nans&lt;/code&gt; determines whether or not NaN values are considered equal (defaults to false).</source>
          <target state="translated">Comparaci&amp;oacute;n de igualdad inexacta: &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt; . El &lt;code&gt;atol&lt;/code&gt; predeterminado es cero y el &lt;code&gt;rtol&lt;/code&gt; predeterminado depende de los tipos de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; . El argumento de palabra clave &lt;code&gt;nans&lt;/code&gt; determina si los valores NaN se consideran iguales o no (el valor predeterminado es falso).</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="3b4f77ed6217d60a7fd4f6a9b544f27db8d0b2a2" translate="yes" xml:space="preserve">
          <source>Inf16</source>
          <target state="translated">Inf16</target>
        </trans-unit>
        <trans-unit id="f32fd60229b61d38504c1b80cfc905d76eb231a4" translate="yes" xml:space="preserve">
          <source>Inf32</source>
          <target state="translated">Inf32</target>
        </trans-unit>
        <trans-unit id="13b9b86c9d296608a20ee6add58865dfa6405d7b" translate="yes" xml:space="preserve">
          <source>Inference on the generated function may be run at &lt;em&gt;any&lt;/em&gt; time, including while your code is attempting to observe or mutate this state.</source>
          <target state="translated">La inferencia sobre la funci&amp;oacute;n generada se puede ejecutar en &lt;em&gt;cualquier&lt;/em&gt; momento, incluso mientras su c&amp;oacute;digo intenta observar o mutar este estado.</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="c7144cf7afebc5115a987ddb86ab81776ccb312f" translate="yes" xml:space="preserve">
          <source>Information Desk Person</source>
          <target state="translated">Persona del mostrador de información</target>
        </trans-unit>
        <trans-unit id="ee1bf915e3a7b6dbf22c44b17ef750f99d415033" translate="yes" xml:space="preserve">
          <source>Information Source</source>
          <target state="translated">Fuente de información</target>
        </trans-unit>
        <trans-unit id="1bcf6aaebaf6b2210eb3e22e29d6b1d78dde678a" translate="yes" xml:space="preserve">
          <source>Information about the datatype</source>
          <target state="translated">La información sobre el tipo de datos</target>
        </trans-unit>
        <trans-unit id="bc0f7289c05621e36794cb837d6af7d6579a4164" translate="yes" xml:space="preserve">
          <source>Information about the sizes of the array</source>
          <target state="translated">La información sobre los tamaños de la matriz</target>
        </trans-unit>
        <trans-unit id="2e1d962528e312390b3433d954b1b586fbe1d39c" translate="yes" xml:space="preserve">
          <source>Initialize &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;x = 1.0&lt;/code&gt;</source>
          <target state="translated">Inicializar &lt;code&gt;x&lt;/code&gt; con &lt;code&gt;x = 1.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d24f12b12b26a182fb25787fca39632feae214b" translate="yes" xml:space="preserve">
          <source>Initialize with the first loop iteration, to &lt;code&gt;x = 1 / rand()&lt;/code&gt;, then loop &lt;code&gt;for i = 2:10&lt;/code&gt;</source>
          <target state="translated">Inicialice con la primera iteraci&amp;oacute;n del ciclo, &lt;code&gt;x = 1 / rand()&lt;/code&gt; , luego haga &lt;code&gt;for i = 2:10&lt;/code&gt; ciclo para i = 2:10</target>
        </trans-unit>
        <trans-unit id="e1daf596559638b5a2545966e4511677e06d2d3d" translate="yes" xml:space="preserve">
          <source>Initially &lt;code&gt;f(x)&lt;/code&gt; has one definition</source>
          <target state="translated">Inicialmente &lt;code&gt;f(x)&lt;/code&gt; tiene una definici&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="65a228b7147b9d8893c482dc6a5436ee38235915" translate="yes" xml:space="preserve">
          <source>Inline elements</source>
          <target state="translated">Elementos en línea</target>
        </trans-unit>
        <trans-unit id="45667ade36979348043d403d58a921b295a413f5" translate="yes" xml:space="preserve">
          <source>Inner Constructor Methods</source>
          <target state="translated">Métodos de construcción interna</target>
        </trans-unit>
        <trans-unit id="5b1b953a0d0fba8d5b16a917eed0d32fa9a3dd01" translate="yes" xml:space="preserve">
          <source>Inner local scopes can, however, update variables in their parent scopes:</source>
          <target state="translated">Los alcances locales internos pueden,sin embargo,actualizar las variables en sus alcances parentales:</target>
        </trans-unit>
        <trans-unit id="8da1f19e44e7c32bb595b50d82bbd6ceb59679ad" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Capital Letters</source>
          <target state="translated">Símbolo de entrada para letras mayúsculas latinas</target>
        </trans-unit>
        <trans-unit id="c3dacb4d5649dfd7003c41b511f2d5e28217bcec" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Letters</source>
          <target state="translated">Símbolo de entrada para las letras latinas</target>
        </trans-unit>
        <trans-unit id="c56fdb4bd109b10836666b2146d13e58e8c262da" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Small Letters</source>
          <target state="translated">Símbolo de entrada para letras pequeñas latinas</target>
        </trans-unit>
        <trans-unit id="daa856648c7327c1e747ce6132f831c138ebed2c" translate="yes" xml:space="preserve">
          <source>Input Symbol For Numbers</source>
          <target state="translated">Símbolo de entrada para los números</target>
        </trans-unit>
        <trans-unit id="393164c17095f31b175cd1b93cce56c3dedbfb1e" translate="yes" xml:space="preserve">
          <source>Input Symbol For Symbols</source>
          <target state="translated">Símbolo de entrada para los símbolos</target>
        </trans-unit>
        <trans-unit id="6ac623d9f5d1fbc2e0f23f9accfd989544cd258f" translate="yes" xml:space="preserve">
          <source>Insert a sequential-consistency memory fence</source>
          <target state="translated">Insertar una valla de memoria de consistencia secuencial</target>
        </trans-unit>
        <trans-unit id="811acf3875523c22a2281d416b5b4f8370319cc7" translate="yes" xml:space="preserve">
          <source>Insert an &lt;code&gt;item&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. &lt;code&gt;index&lt;/code&gt; is the index of &lt;code&gt;item&lt;/code&gt; in the resulting &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Inserte un &lt;code&gt;item&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt; en el &lt;code&gt;index&lt;/code&gt; dado . &lt;code&gt;index&lt;/code&gt; es el &amp;iacute;ndice del &lt;code&gt;item&lt;/code&gt; en el &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="559e8d8937fda6b9aa5389a26a8c99a01c1659f4" translate="yes" xml:space="preserve">
          <source>Insert new line without executing it</source>
          <target state="translated">Insertar una nueva línea sin ejecutarla</target>
        </trans-unit>
        <trans-unit id="db69c06d74ad468e37833a8eff3cd0b19f6c2cae" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the beginning of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">Inserte uno o m&amp;aacute;s &lt;code&gt;items&lt;/code&gt; al comienzo de la &lt;code&gt;collection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e38ad6a771799a9a8891ef79be267ec402e8ceac" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">Inserte uno o m&amp;aacute;s &lt;code&gt;items&lt;/code&gt; al final de la &lt;code&gt;collection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3f950f8d7377ccffdca0b939ba6ac7684b1f51" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; in &lt;code&gt;collection&lt;/code&gt;. If &lt;code&gt;collection&lt;/code&gt; is an ordered container, the items are inserted at the end (in the given order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1912a8c6dfd808836326783d91aa44bc473362" translate="yes" xml:space="preserve">
          <source>Insert the elements of &lt;code&gt;items&lt;/code&gt; to the beginning of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Inserte los elementos de los &lt;code&gt;items&lt;/code&gt; al principio de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eec80463f132fabaec00763dec1737d74a5ca8f8" translate="yes" xml:space="preserve">
          <source>Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.</source>
          <target state="translated">Inserta una valla de memoria con semántica de ordenamiento secuencial.Hay algoritmos en los que esto es necesario,es decir,en los que un ordenamiento de adquisición/liberación es insuficiente.</target>
        </trans-unit>
        <trans-unit id="8a79f039f9c26eb844e9abd4767d0e8224e23795" translate="yes" xml:space="preserve">
          <source>Inserts a point in the program where garbage collection may run. This can be useful in rare cases in multi-threaded programs where some threads are allocating memory (and hence may need to run GC) but other threads are doing only simple operations (no allocation, task switches, or I/O). Calling this function periodically in non-allocating threads allows garbage collection to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea0f92c3d70dd355408c14ed7bbf0a9be4aeff9" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;kwargs&lt;/code&gt; will be a key-value iterator over a named tuple. Named tuples (as well as dictionaries with keys of &lt;code&gt;Symbol&lt;/code&gt;) can be passed as keyword arguments using a semicolon in a call, e.g. &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt;.</source>
          <target state="translated">Dentro de &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;kwargs&lt;/code&gt; ser&amp;aacute; un iterador de valor-clave sobre una tupla con nombre. Las tuplas con nombre (as&amp;iacute; como los diccionarios con claves de &lt;code&gt;Symbol&lt;/code&gt; ) se pueden pasar como argumentos de palabras clave usando un punto y coma en una llamada, por ejemplo, &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d505904dee884402cee2bfc93d1e5e6eac91aed0" translate="yes" xml:space="preserve">
          <source>Inside a function call, &lt;code&gt;f(a=b)&lt;/code&gt; passes &lt;code&gt;b&lt;/code&gt; as the value of keyword argument &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Dentro de una llamada de funci&amp;oacute;n, &lt;code&gt;f(a=b)&lt;/code&gt; pasa &lt;code&gt;b&lt;/code&gt; como el valor del argumento de palabra clave &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c0628bcc3fe3dc7f18266ed4703a4ef8a1c7fc8" translate="yes" xml:space="preserve">
          <source>Inside a local scope a global variable can be assigned to by using the keyword &lt;a href=&quot;../../base/base/index#global&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Dentro de un &amp;aacute;mbito local, se puede asignar una variable global usando la palabra clave &lt;a href=&quot;../../base/base/index#global&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="582d7159a5b73cf78ab92b918e0b2d46bdf1e604" translate="yes" xml:space="preserve">
          <source>Inside a local scope a variable can be forced to be a new local variable using the &lt;a href=&quot;../../base/base/index#local&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">Dentro de un &amp;aacute;mbito local, una variable puede ser forzada a ser una nueva variable local usando la palabra clave &lt;a href=&quot;../../base/base/index#local&quot;&gt; &lt;code&gt;local&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2d117997a7534c274cbe92ad615675971d22bedb" translate="yes" xml:space="preserve">
          <source>Inside of the &lt;code&gt;greet&lt;/code&gt; function, the assignment &lt;code&gt;x = &quot;hello&quot;&lt;/code&gt; causes &lt;code&gt;x&lt;/code&gt; to be a new local variable in the function's scope. There are two relevant facts: the assignment occurs in local scope and there is no existing local &lt;code&gt;x&lt;/code&gt; variable. Since &lt;code&gt;x&lt;/code&gt; is local, it doesn't matter if there is a global named &lt;code&gt;x&lt;/code&gt; or not. Here for example we define &lt;code&gt;x = 123&lt;/code&gt; before defining and calling &lt;code&gt;greet&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fad0a2de99eca8b6794c525262e6ccd85a1c70" translate="yes" xml:space="preserve">
          <source>Inside parentheses with commas, &lt;code&gt;(a=1,)&lt;/code&gt; constructs a &lt;a href=&quot;#Core.NamedTuple&quot;&gt;&lt;code&gt;NamedTuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Dentro de par&amp;eacute;ntesis con comas, &lt;code&gt;(a=1,)&lt;/code&gt; construye un &lt;a href=&quot;#Core.NamedTuple&quot;&gt; &lt;code&gt;NamedTuple&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="456c6fe8fc3a9803d2d238636df3fddf2e8ebda8" translate="yes" xml:space="preserve">
          <source>Inspects the given UUID and returns its version (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;).</source>
          <target state="translated">Inspecciona el UUID proporcionado y devuelve su versi&amp;oacute;n (consulte &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4ff8674778688251123ee296e21a5f29ce889b67" translate="yes" xml:space="preserve">
          <source>Instances can be constructed from strings via &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, or using the &lt;code&gt;big&lt;/code&gt; string literal.</source>
          <target state="translated">Las instancias se pueden construir a partir de cadenas mediante &lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt; o utilizando el literal de cadena &lt;code&gt;big&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2cd4547e98e69f493a2391724e35284eddfcf3f" translate="yes" xml:space="preserve">
          <source>Instead of calculating something or performing some action, you return a &lt;em&gt;quoted expression&lt;/em&gt; which, when evaluated, does what you want.</source>
          <target state="translated">En lugar de calcular algo o realizar alguna acci&amp;oacute;n, devuelve una &lt;em&gt;expresi&amp;oacute;n entre comillas&lt;/em&gt; que, cuando se eval&amp;uacute;a, hace lo que desea.</target>
        </trans-unit>
        <trans-unit id="e11074b6a3ddd4db91a1d67bb7c4e17f5cc3596e" translate="yes" xml:space="preserve">
          <source>Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:</source>
          <target state="translated">En lugar de clasificar directamente una matriz,puedes calcular una permutación de los índices de la matriz que pone la matriz en orden:</target>
        </trans-unit>
        <trans-unit id="d807ed905e686ec4c6c31127918a04393e4003ae" translate="yes" xml:space="preserve">
          <source>Instead of immediately running the command, backticks create a &lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; object to represent the command. You can use this object to connect the command to others via pipes, &lt;a href=&quot;../../base/base/index#Base.run&quot;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/a&gt; it, and &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">En lugar de ejecutar inmediatamente el comando, las comillas inversas crean un objeto &lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; para representar el comando. Puede usar este objeto para conectar el comando a otros a trav&amp;eacute;s de tuber&amp;iacute;as, &lt;a href=&quot;../../base/base/index#Base.run&quot;&gt; &lt;code&gt;run&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78863694892c2019c43a79b283ebb340da799f84" translate="yes" xml:space="preserve">
          <source>Instead of loading a registered version of &lt;code&gt;Example&lt;/code&gt;, Julia will load the source code contained in &lt;code&gt;tutorial/dev/Example&lt;/code&gt;.</source>
          <target state="translated">En lugar de cargar una versi&amp;oacute;n registrada de &lt;code&gt;Example&lt;/code&gt; , Julia cargar&amp;aacute; el c&amp;oacute;digo fuente contenido en el &lt;code&gt;tutorial/dev/Example&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80cddaa6c38b52b1b6910a5df7e62d1058e97067" translate="yes" xml:space="preserve">
          <source>Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments. When a generated function is called, the expression it returns is compiled and then run. To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on allowed constructs.</source>
          <target state="translated">En lugar de realizar algún cálculo o acción,una declaración de función generada devuelve una expresión citada que luego forma el cuerpo del método correspondiente a los tipos de los argumentos.Cuando se llama a una función generada,la expresión que devuelve se compila y luego se ejecuta.Para que esto sea eficiente,el resultado suele estar en caché.Y para hacer esto inferible,sólo un subconjunto limitado del lenguaje es utilizable.Así,las funciones generadas proporcionan una forma flexible de mover el trabajo desde el tiempo de ejecución al tiempo de compilación,a expensas de mayores restricciones en las construcciones permitidas.</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">En lugar de:</target>
        </trans-unit>
        <trans-unit id="a3a52a1be0f1de968cc5d8921a39676d67c34867" translate="yes" xml:space="preserve">
          <source>Instead, use a semicolon or insert a line break after &lt;code&gt;catch&lt;/code&gt;:</source>
          <target state="translated">En su lugar, use un punto y coma o inserte un salto de l&amp;iacute;nea despu&amp;eacute;s de la &lt;code&gt;catch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3f6b46a05cf7ae83de7f241a566b6dcab9f9f12b" translate="yes" xml:space="preserve">
          <source>Integer division (the &lt;code&gt;div&lt;/code&gt; function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt;) by -1. Both of these cases throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt;. The remainder and modulus functions (&lt;code&gt;rem&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;) throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt; when their second argument is zero.</source>
          <target state="translated">La divisi&amp;oacute;n de enteros (la funci&amp;oacute;n &lt;code&gt;div&lt;/code&gt; ) tiene dos casos excepcionales: dividir por cero y dividir el n&amp;uacute;mero negativo m&amp;aacute;s bajo ( &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt; ) por -1. Ambos casos arrojan un &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; &lt;/a&gt; . Las funciones resto y m&amp;oacute;dulo ( &lt;code&gt;rem&lt;/code&gt; y &lt;code&gt;mod&lt;/code&gt; ) arrojan un &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; &lt;/a&gt; cuando su segundo argumento es cero.</target>
        </trans-unit>
        <trans-unit id="27477953a7f5629b70d1f8667b4ce5a95bd7d163" translate="yes" xml:space="preserve">
          <source>Integer division was attempted with a denominator value of 0.</source>
          <target state="translated">Se intentó una división entera con un valor denominador de 0.</target>
        </trans-unit>
        <trans-unit id="44e36daccd6ac7a9f894c249dbe1f367783e4537" translate="yes" xml:space="preserve">
          <source>Integer square root: the largest integer &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt;.</source>
          <target state="translated">Ra&amp;iacute;z cuadrada entera: el entero m&amp;aacute;s grande &lt;code&gt;m&lt;/code&gt; tal que &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0f622cf48cf7d80bd106d7df1f3da91566c330d" translate="yes" xml:space="preserve">
          <source>Integer value N launches N additional local worker processes; &lt;code&gt;auto&lt;/code&gt; launches as many workers as the number of local CPU threads (logical cores)</source>
          <target state="translated">El valor entero N lanza N procesos de trabajo locales adicionales; inicia &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;ticamente tantos trabajadores como la cantidad de subprocesos de CPU local (n&amp;uacute;cleos l&amp;oacute;gicos)</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="0be1ec1ce9bd8f5a453ecb566c11ab0a7c7144d0" translate="yes" xml:space="preserve">
          <source>Integers and Floating-Point Numbers</source>
          <target state="translated">Números enteros y números de puntos flotantes</target>
        </trans-unit>
        <trans-unit id="cdcba026c96bc24c46aaded28b7a473dd9b651d8" translate="yes" xml:space="preserve">
          <source>Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, &lt;code&gt;1&lt;/code&gt; is an integer literal, while &lt;code&gt;1.0&lt;/code&gt; is a floating-point literal; their binary in-memory representations as objects are numeric primitives.</source>
          <target state="translated">Los n&amp;uacute;meros enteros y los valores de coma flotante son los componentes b&amp;aacute;sicos de la aritm&amp;eacute;tica y el c&amp;aacute;lculo. Las representaciones integradas de dichos valores se denominan primitivas num&amp;eacute;ricas, mientras que las representaciones de n&amp;uacute;meros enteros y de coma flotante como valores inmediatos en el c&amp;oacute;digo se conocen como literales num&amp;eacute;ricos. Por ejemplo, &lt;code&gt;1&lt;/code&gt; es un literal entero, mientras que &lt;code&gt;1.0&lt;/code&gt; es un literal de coma flotante; sus representaciones binarias en memoria como objetos son primitivas num&amp;eacute;ricas.</target>
        </trans-unit>
        <trans-unit id="be404ce277aac9d3b9b27f0140b709ff517b7820" translate="yes" xml:space="preserve">
          <source>Integers are compared in the standard manner &amp;ndash; by comparison of bits. Floating-point numbers are compared according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;:</source>
          <target state="translated">Los enteros se comparan de la manera est&amp;aacute;ndar, mediante la comparaci&amp;oacute;n de bits. Los n&amp;uacute;meros de coma flotante se comparan de acuerdo con el &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;est&amp;aacute;ndar IEEE 754&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="70680c64952b0114adcda3eb14a614e1841cd0c6" translate="yes" xml:space="preserve">
          <source>Integral Around A Point Operator</source>
          <target state="translated">Integral alrededor de un operador de punto</target>
        </trans-unit>
        <trans-unit id="425335bd88e128f008b3f48181d1c27b517bcc72" translate="yes" xml:space="preserve">
          <source>Integral Average With Slash</source>
          <target state="translated">Promedio integral con barra</target>
        </trans-unit>
        <trans-unit id="c6bac88caff6c11517b441d63dd4587857621bab" translate="yes" xml:space="preserve">
          <source>Integral With Double Stroke</source>
          <target state="translated">Integral con doble golpe</target>
        </trans-unit>
        <trans-unit id="18238ecc8130fd86a404d903215b4901fbd6604e" translate="yes" xml:space="preserve">
          <source>Integral With Intersection</source>
          <target state="translated">Integral con intersección</target>
        </trans-unit>
        <trans-unit id="8a62b59c92abaaa075d87faf375d4d0d5e2fdc39" translate="yes" xml:space="preserve">
          <source>Integral With Overbar</source>
          <target state="translated">Integral con sobrecarga</target>
        </trans-unit>
        <trans-unit id="08588fc154d2b615a7916934fe8e56ebda68acf8" translate="yes" xml:space="preserve">
          <source>Integral With Times Sign</source>
          <target state="translated">Integral con signo de tiempo</target>
        </trans-unit>
        <trans-unit id="31ecf2a75d24fa7ec2a5569e3665d7f415d4db51" translate="yes" xml:space="preserve">
          <source>Integral With Underbar</source>
          <target state="translated">Integral con la barra inferior</target>
        </trans-unit>
        <trans-unit id="23eafe62fdaca340d651a852cff8f87d44076b09" translate="yes" xml:space="preserve">
          <source>Integral With Union</source>
          <target state="translated">Integral con la Unión</target>
        </trans-unit>
        <trans-unit id="2885cb42f64585560c85104eeedf86ba7e0ed77e" translate="yes" xml:space="preserve">
          <source>Intel's &lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade; Amplifier&lt;/a&gt; (&lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt; in the build configuration), or</source>
          <target state="translated">&lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;Amplificador VTune &amp;trade; de&lt;/a&gt; Intel ( &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; establecido en &lt;code&gt;1&lt;/code&gt; en la configuraci&amp;oacute;n de compilaci&amp;oacute;n), o</target>
        </trans-unit>
        <trans-unit id="207cb56e67212ece90d1329dc4b01521c8f13014" translate="yes" xml:space="preserve">
          <source>Interacting with the contents or methods of &lt;code&gt;Core.Compiler&lt;/code&gt; in any way.</source>
          <target state="translated">Interactuar con los contenidos o m&amp;eacute;todos de &lt;code&gt;Core.Compiler&lt;/code&gt; de cualquier forma.</target>
        </trans-unit>
        <trans-unit id="d4f66ae8b3da23aee8b514d4076de7a8e09b0b4e" translate="yes" xml:space="preserve">
          <source>Interactive Utilities</source>
          <target state="translated">Utilidades interactivas</target>
        </trans-unit>
        <trans-unit id="71fefc1d52a78f40748037e8a91fc8ea4f8e2578" translate="yes" xml:space="preserve">
          <source>Interactive mode; REPL runs and &lt;code&gt;isinteractive()&lt;/code&gt; is true</source>
          <target state="translated">Modo interactivo; REPL se ejecuta y &lt;code&gt;isinteractive()&lt;/code&gt; es verdadero</target>
        </trans-unit>
        <trans-unit id="0270e20982d6093d44ba136572cbf822d6290a5d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_llvm</source>
          <target state="translated">InteractiveUtils.@code_llvm</target>
        </trans-unit>
        <trans-unit id="0309be470088530490561ff83d97b95071df357e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_lowered</source>
          <target state="translated">InteractiveUtils.@code_lowered</target>
        </trans-unit>
        <trans-unit id="00a7a46c62638c2b2d4deb9dc4bd43a8d3c3582c" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_native</source>
          <target state="translated">InteractiveUtils.@code_native</target>
        </trans-unit>
        <trans-unit id="4fa27864c86ced13027d392baeedb020be6c560a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_typed</source>
          <target state="translated">InteractiveUtils.@code_typed</target>
        </trans-unit>
        <trans-unit id="1e45473f814223dcb1c417d561e1870e1450bf83" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_warntype</source>
          <target state="translated">InteractiveUtils.@code_warntype</target>
        </trans-unit>
        <trans-unit id="eedef913d7842aa079f915bdbbb5f5e90c47c7f6" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@edit</source>
          <target state="translated">InteractiveUtils.@edit</target>
        </trans-unit>
        <trans-unit id="a6df5f45ac03e2c658d92e8736e88cafa5b98995" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@functionloc</source>
          <target state="translated">InteractiveUtils.@functionloc</target>
        </trans-unit>
        <trans-unit id="49e359f4c318b876f99ccb7d37f63e69deb2003d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@less</source>
          <target state="translated">InteractiveUtils.@less</target>
        </trans-unit>
        <trans-unit id="6e359d1c5b33d4212df3c4f8c3762813890df9ae" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@which</source>
          <target state="translated">InteractiveUtils.@which</target>
        </trans-unit>
        <trans-unit id="2d50f6ed31622302ae5f5a5feebfb95f2c420a04" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.clipboard()</source>
          <target state="translated">InteractiveUtils.clipboard()</target>
        </trans-unit>
        <trans-unit id="c1ad553095bd7ae0c9db5b342934998a5be27479" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_llvm()</source>
          <target state="translated">InteractiveUtils.code_llvm()</target>
        </trans-unit>
        <trans-unit id="a70df8f6770abff941be7ee8196e397ae5bbd4b8" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_native()</source>
          <target state="translated">InteractiveUtils.code_native()</target>
        </trans-unit>
        <trans-unit id="f009b2e3c7cb61122f070c557fb9f4dcd1edf6db" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_warntype()</source>
          <target state="translated">InteractiveUtils.code_warntype()</target>
        </trans-unit>
        <trans-unit id="d4c1c9ee2ecb7996d780a0e5d5ccea921a53d56a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.edit()</source>
          <target state="translated">InteractiveUtils.edit()</target>
        </trans-unit>
        <trans-unit id="424927890145616c60279ce930588fd54c4ac90e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.less()</source>
          <target state="translated">InteractiveUtils.less()</target>
        </trans-unit>
        <trans-unit id="49eeeef411d4549f28b217525726cf46e51440cb" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.methodswith()</source>
          <target state="translated">InteractiveUtils.methodswith()</target>
        </trans-unit>
        <trans-unit id="59973fd047bc66e11de11bff485ff30fc8072b48" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.subtypes()</source>
          <target state="translated">InteractiveUtils.subtypes()</target>
        </trans-unit>
        <trans-unit id="8cc40b484c66058018a0b8c42f2ab741a2014154" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.varinfo()</source>
          <target state="translated">InteractiveUtils.varinfo()</target>
        </trans-unit>
        <trans-unit id="391d124220b1a9c25f8d3323e7bb133c849aadc9" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.versioninfo()</source>
          <target state="translated">InteractiveUtils.versioninfo()</target>
        </trans-unit>
        <trans-unit id="068a8966386d6f477f70dcc54b094caba48a03f4" translate="yes" xml:space="preserve">
          <source>Intercalate</source>
          <target state="translated">Intercalate</target>
        </trans-unit>
        <trans-unit id="a791af570ec4e5730c5e110c39b173c357ea4d3a" translate="yes" xml:space="preserve">
          <source>Interconverts between dense and sparse formats.</source>
          <target state="translated">Interconvierte entre los formatos denso y disperso.</target>
        </trans-unit>
        <trans-unit id="c3229f4e0f20d697072608271bc7f20c5b6d789f" translate="yes" xml:space="preserve">
          <source>Interface to BLAS subroutines.</source>
          <target state="translated">Interfaz a las subrutinas BLAS.</target>
        </trans-unit>
        <trans-unit id="bcdb1ff794ae28041f3196a504b6115b3dea810a" translate="yes" xml:space="preserve">
          <source>Interface to libc, the C standard library.</source>
          <target state="translated">Interfaz a libc,la biblioteca estándar de C.</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="c2b213458be4f2f6fdec41d29483b814cba730b1" translate="yes" xml:space="preserve">
          <source>Interfaces to LAPACK subroutines.</source>
          <target state="translated">Interfaces a las subrutinas de LAPACK.</target>
        </trans-unit>
        <trans-unit id="a514e8807ceddceeb9d1c2be8e83634758fea386" translate="yes" xml:space="preserve">
          <source>Interior Product</source>
          <target state="translated">Producto interior</target>
        </trans-unit>
        <trans-unit id="0c4a9d0a55deb37d51d5b2b7f615f0874ed971d8" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;promote_type&lt;/code&gt; is used inside of &lt;code&gt;promote&lt;/code&gt; to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, which defines the complete promotion mechanism in about 35 lines.</source>
          <target state="translated">Internamente, &lt;code&gt;promote_type&lt;/code&gt; est&amp;aacute; dentro utilizado de &lt;code&gt;promote&lt;/code&gt; para determinar qu&amp;eacute; valores de los argumentos de tipo deben ser convertidos a la promoci&amp;oacute;n. Sin embargo, puede ser &amp;uacute;til por derecho propio. El lector curioso puede leer el c&amp;oacute;digo en &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; &lt;/a&gt; , que define el mecanismo de promoci&amp;oacute;n completo en unas 35 l&amp;iacute;neas.</target>
        </trans-unit>
        <trans-unit id="818408de3c95448c6a4c8c7cc57f8a8c85a4002d" translate="yes" xml:space="preserve">
          <source>Internally, an &lt;code&gt;AbstractChar&lt;/code&gt; type may use a variety of encodings. Conversion via &lt;code&gt;codepoint(char)&lt;/code&gt; will not reveal this encoding because it always returns the Unicode value of the character. &lt;code&gt;print(io, c)&lt;/code&gt; of any &lt;code&gt;c::AbstractChar&lt;/code&gt; produces an encoding determined by &lt;code&gt;io&lt;/code&gt; (UTF-8 for all built-in &lt;code&gt;IO&lt;/code&gt; types), via conversion to &lt;code&gt;Char&lt;/code&gt; if necessary.</source>
          <target state="translated">Internamente, un tipo &lt;code&gt;AbstractChar&lt;/code&gt; puede usar una variedad de codificaciones. La conversi&amp;oacute;n mediante &lt;code&gt;codepoint(char)&lt;/code&gt; no revelar&amp;aacute; esta codificaci&amp;oacute;n porque siempre devuelve el valor Unicode del car&amp;aacute;cter. &lt;code&gt;print(io, c)&lt;/code&gt; de cualquier &lt;code&gt;c::AbstractChar&lt;/code&gt; produce una codificaci&amp;oacute;n determinada por &lt;code&gt;io&lt;/code&gt; (UTF-8 para todos los tipos de &lt;code&gt;IO&lt;/code&gt; incorporados ), mediante conversi&amp;oacute;n a &lt;code&gt;Char&lt;/code&gt; si es necesario.</target>
        </trans-unit>
        <trans-unit id="4952806e1eda6ad8d06e741bd80f1e6d3a2efafd" translate="yes" xml:space="preserve">
          <source>Internally, this code creates two implementations of the function: a generated one where the first block in &lt;code&gt;if @generated&lt;/code&gt; is used, and a normal one where the &lt;code&gt;else&lt;/code&gt; block is used. Inside the &lt;code&gt;then&lt;/code&gt; part of the &lt;code&gt;if @generated&lt;/code&gt; block, code has the same semantics as other generated functions: argument names refer to types, and the code should return an expression. Multiple &lt;code&gt;if @generated&lt;/code&gt; blocks may occur, in which case the generated implementation uses all of the &lt;code&gt;then&lt;/code&gt; blocks and the alternate implementation uses all of the &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">Internamente, este c&amp;oacute;digo crea dos implementaciones de la funci&amp;oacute;n: una generada donde se usa el primer bloque en &lt;code&gt;if @generated&lt;/code&gt; , y una normal donde se usa el bloque &lt;code&gt;else&lt;/code&gt; . Dentro de la &lt;code&gt;then&lt;/code&gt; parte del &lt;code&gt;if @generated&lt;/code&gt; bloque, c&amp;oacute;digo tiene la misma sem&amp;aacute;ntica que otras funciones de creaci&amp;oacute;n: nombres de argumentos se refieren a los tipos, y el c&amp;oacute;digo deber&amp;iacute;a devolver una expresi&amp;oacute;n. Pueden &lt;code&gt;if @generated&lt;/code&gt; m&amp;uacute;ltiples bloques if @generated , en cuyo caso la implementaci&amp;oacute;n generada usa todos los bloques &lt;code&gt;then&lt;/code&gt; y la implementaci&amp;oacute;n alternativa usa todos los bloques &lt;code&gt;else&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="48012c80f49c5c1a3bff1ed20d31a89b4f215742" translate="yes" xml:space="preserve">
          <source>Interpolating into an unquoted expression is not supported and will cause a compile-time error:</source>
          <target state="translated">Interpolar en una expresión no citada no está soportado y causará un error en tiempo de compilación:</target>
        </trans-unit>
        <trans-unit id="213daae9f453b89afd1148247dfa9083fa51630b" translate="yes" xml:space="preserve">
          <source>Interpolating values via &lt;code&gt;$&lt;/code&gt; is available as of Julia 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="d67b7c5f52f05b37b77a64fd823fc76a0fce5a66" translate="yes" xml:space="preserve">
          <source>Interpret an iterable of key-value pairs as a named tuple, and perform a merge.</source>
          <target state="translated">Interpreta un iterable de pares clave-valor como una tupla con nombre,y realiza una fusión.</target>
        </trans-unit>
        <trans-unit id="cc53b2acfc42c6cf13c71d4c67ea40578eaaf1f7" translate="yes" xml:space="preserve">
          <source>Interpretation: accessing elements of poorly-typed arrays</source>
          <target state="translated">Interpretación:acceso a elementos de conjuntos mal tecleados</target>
        </trans-unit>
        <trans-unit id="7894bb109218bbe3ea53cb08c360e18b2453f383" translate="yes" xml:space="preserve">
          <source>Interpretation: call to a type-unstable function &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">Interpretaci&amp;oacute;n: llamada a una funci&amp;oacute;n de tipo inestable &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7784e3d882b6a7b4c22ed3b7f03fb99cea250d48" translate="yes" xml:space="preserve">
          <source>Interpretation: function with unstable return type</source>
          <target state="translated">Interpretación:función con tipo de retorno inestable</target>
        </trans-unit>
        <trans-unit id="9f71e4dd30d3efc21956f72596ba4278f8921c99" translate="yes" xml:space="preserve">
          <source>Interpretation: getting a field that is of non-leaf type. In this case, &lt;code&gt;ArrayContainer&lt;/code&gt; had a field &lt;code&gt;data::Array{T}&lt;/code&gt;. But &lt;code&gt;Array&lt;/code&gt; needs the dimension &lt;code&gt;N&lt;/code&gt;, too, to be a concrete type.</source>
          <target state="translated">Interpretaci&amp;oacute;n: obtener un campo que no es de tipo hoja. En este caso, &lt;code&gt;ArrayContainer&lt;/code&gt; ten&amp;iacute;a un campo de &lt;code&gt;data::Array{T}&lt;/code&gt; . Pero &lt;code&gt;Array&lt;/code&gt; tambi&amp;eacute;n necesita que la dimensi&amp;oacute;n &lt;code&gt;N&lt;/code&gt; sea ​​un tipo concreto.</target>
        </trans-unit>
        <trans-unit id="f71c83c811d3e87825b69245ec2c0dff4c1686bd" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; in the above example, such output is shown in uppercase.</source>
          <target state="translated">Interpretar la salida de &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; , como la de sus primos &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt; &lt;code&gt;@code_lowered&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt; &lt;code&gt;@code_typed&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt; &lt;code&gt;@code_llvm&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt; &lt;code&gt;@code_native&lt;/code&gt; &lt;/a&gt; , requiere un poco de pr&amp;aacute;ctica. Su c&amp;oacute;digo se presenta en una forma que ha sido muy digerida en su camino hacia la generaci&amp;oacute;n de c&amp;oacute;digo de m&amp;aacute;quina compilado. La mayor&amp;iacute;a de las expresiones est&amp;aacute;n anotadas por un tipo, indicado por &lt;code&gt;::T&lt;/code&gt; (donde &lt;code&gt;T&lt;/code&gt; podr&amp;iacute;a ser &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; , por ejemplo). La caracter&amp;iacute;stica m&amp;aacute;s importante de &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt; es que los tipos no concretos se muestran en rojo; en el ejemplo anterior, dicha salida se muestra en may&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="b25ba536a0a42dea499d4fc2b8979e5924399239" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; since this document is written in Markdown, which has no color, in this document, red text is denoted by uppercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc939bea48b5a28296b21d2be9495aa8bccd0b19" translate="yes" xml:space="preserve">
          <source>Interrupt or cancel</source>
          <target state="translated">Interrumpir o cancelar</target>
        </trans-unit>
        <trans-unit id="23165f09bcddd0acc011e45e34282dbbd91bd4cd" translate="yes" xml:space="preserve">
          <source>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</source>
          <target state="translated">Interrumpir la actual tarea de ejecución en los trabajadores especificados.Esto equivale a pulsar Ctrl-C en la máquina local.Si no se dan argumentos,todos los trabajadores son interrumpidos.</target>
        </trans-unit>
        <trans-unit id="658cc9a8a17acd75a5bc21930b12d446eea71552" translate="yes" xml:space="preserve">
          <source>Intersect all passed in sets and overwrite &lt;code&gt;s&lt;/code&gt; with the result. Maintain order with arrays.</source>
          <target state="translated">Interseccione todos los conjuntos pasados ​​y sobrescriba &lt;code&gt;s&lt;/code&gt; con el resultado. Mantenga el orden con matrices.</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="7d65fe6f634dc82a5910e500d111d1c2553d45ad" translate="yes" xml:space="preserve">
          <source>Intersection Beside And Joined With Intersection</source>
          <target state="translated">Intersección al lado y unido con la intersección</target>
        </trans-unit>
        <trans-unit id="f70ced5527bc06ac0250ff3ce0c6433b4fc007ad" translate="yes" xml:space="preserve">
          <source>Intersection With Dot</source>
          <target state="translated">Intersección con Dot</target>
        </trans-unit>
        <trans-unit id="fea160380c26aea0a6f5cf6d33e5059a2528bb99" translate="yes" xml:space="preserve">
          <source>Intersection With Logical And</source>
          <target state="translated">La intersección con la lógica y</target>
        </trans-unit>
        <trans-unit id="8a447498c8a13bd62bc28a71db064abbbd2ce851" translate="yes" xml:space="preserve">
          <source>Intersection With Overbar</source>
          <target state="translated">Intersección con la barra de control</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="95010e236dbeb1d0c89e9d5b6ed0ea0da0ed9572" translate="yes" xml:space="preserve">
          <source>Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's signature (when the signature matches).</source>
          <target state="translated">Intuitivamente,esto corresponde al tipo de argumentos de una función que es un subtipo de la firma de la función (cuando la firma coincide).</target>
        </trans-unit>
        <trans-unit id="f4bc4f6c3fe38fa1ef542295504817c8e94651bb" translate="yes" xml:space="preserve">
          <source>Inverse Bullet</source>
          <target state="translated">Bala invertida</target>
        </trans-unit>
        <trans-unit id="a2b80ae8599265e5e4df3c9c6eae5101a072d85a" translate="yes" xml:space="preserve">
          <source>Inverse White Circle</source>
          <target state="translated">Círculo blanco invertido</target>
        </trans-unit>
        <trans-unit id="f5c93f67585d1f2ce3d07fe77774efdd8e1c494a" translate="yes" xml:space="preserve">
          <source>Inverted Exclamation Mark</source>
          <target state="translated">Signo de exclamación invertido</target>
        </trans-unit>
        <trans-unit id="8ed370a70ad4ba84f93ff72e14bb89b2e795837a" translate="yes" xml:space="preserve">
          <source>Inverted Lazy S</source>
          <target state="translated">Lazy S invertido</target>
        </trans-unit>
        <trans-unit id="7e3bf2655c3d6132b1040ffc28240e0e2706a489" translate="yes" xml:space="preserve">
          <source>Inverted Ohm Sign / Mho</source>
          <target state="translated">Signo de Ohm invertido/Mho</target>
        </trans-unit>
        <trans-unit id="77352625457aa55d3c246bb35487f40a40f194e5" translate="yes" xml:space="preserve">
          <source>Inverted Question Mark</source>
          <target state="translated">Signo de interrogación invertido</target>
        </trans-unit>
        <trans-unit id="1dc2af95223d452f5604dae81acef5fd3a117e33" translate="yes" xml:space="preserve">
          <source>Invoke a method for the given generic function &lt;code&gt;f&lt;/code&gt; matching the specified types &lt;code&gt;argtypes&lt;/code&gt; on the specified arguments &lt;code&gt;args&lt;/code&gt; and passing the keyword arguments &lt;code&gt;kwargs&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; must conform with the specified types in &lt;code&gt;argtypes&lt;/code&gt;, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).</source>
          <target state="translated">Invocar un m&amp;eacute;todo para la funci&amp;oacute;n gen&amp;eacute;rica dada &lt;code&gt;f&lt;/code&gt; que coincida con los tipos &lt;code&gt;argtypes&lt;/code&gt; especificados en los argumentos especificados &lt;code&gt;args&lt;/code&gt; y pasando la palabra clave argumentos &lt;code&gt;kwargs&lt;/code&gt; . Los argumentos &lt;code&gt;args&lt;/code&gt; deben ajustarse a los tipos especificados en &lt;code&gt;argtypes&lt;/code&gt; , es decir, la conversi&amp;oacute;n no se realiza autom&amp;aacute;ticamente. Este m&amp;eacute;todo permite invocar un m&amp;eacute;todo diferente al m&amp;eacute;todo de emparejamiento m&amp;aacute;s espec&amp;iacute;fico, lo cual es &amp;uacute;til cuando se necesita expl&amp;iacute;citamente el comportamiento de una definici&amp;oacute;n m&amp;aacute;s general (a menudo como parte de la implementaci&amp;oacute;n de un m&amp;eacute;todo m&amp;aacute;s espec&amp;iacute;fico de la misma funci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="f0c54c7c50c82bf234e4ed64cb3ce50f2fd86de8" translate="yes" xml:space="preserve">
          <source>Invoke all handlers from &lt;a href=&quot;#Base.Experimental.register_error_hint&quot;&gt;&lt;code&gt;Experimental.register_error_hint&lt;/code&gt;&lt;/a&gt; for the particular exception type &lt;code&gt;typeof(ex)&lt;/code&gt;. &lt;code&gt;args&lt;/code&gt; must contain any other arguments expected by the handler for that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe30ecc758896527e5047bf5e1ab5207bc281f3" translate="yes" xml:space="preserve">
          <source>Irrational</source>
          <target state="translated">Irrational</target>
        </trans-unit>
        <trans-unit id="474a6d17a6faabac287216094db27839ef426282" translate="yes" xml:space="preserve">
          <source>Is Julia named after someone or something?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21fa8512b05ce15e621a0c6aca735529c300b50" translate="yes" xml:space="preserve">
          <source>Issue 8859, &quot;Fix least squares&quot;, https://github.com/JuliaLang/julia/pull/8859</source>
          <target state="translated">Número 8859,&quot;Arreglar los mínimos cuadrados&quot;,https://github.com/JuliaLang/julia/pull/8859</target>
        </trans-unit>
        <trans-unit id="beadd95d62ed185b3348f8f407f354b8cc251415" translate="yes" xml:space="preserve">
          <source>It also makes writing exponential functions more elegant:</source>
          <target state="translated">También hace que la escritura de funciones exponenciales sea más elegante:</target>
        </trans-unit>
        <trans-unit id="f6ba82c6b32228a1dcbba192584fb70b95766cb3" translate="yes" xml:space="preserve">
          <source>It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.</source>
          <target state="translated">Puede ser más eficiente.Algunas estructuras pueden ser empaquetadas eficientemente en arreglos,y en algunos casos el compilador es capaz de evitar la asignación de objetos inmutables por completo.</target>
        </trans-unit>
        <trans-unit id="2138e5233860592eb48b0938be0063487a8c3bbe" translate="yes" xml:space="preserve">
          <source>It can happen that &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; is already defined in the &lt;code&gt;Random&lt;/code&gt; module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding &lt;code&gt;SamplerS&lt;/code&gt; type is considered as internal detail, and may be changed without warning.</source>
          <target state="translated">Puede suceder que &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; ya est&amp;eacute; definido en el m&amp;oacute;dulo &lt;code&gt;Random&lt;/code&gt; . Entonces ser&amp;iacute;a posible omitir el paso 1) en la pr&amp;aacute;ctica (si se quiere especializar la generaci&amp;oacute;n para este tipo de RNG en particular), pero el tipo de &lt;code&gt;SamplerS&lt;/code&gt; correspondiente se considera un detalle interno y puede cambiarse sin previo aviso.</target>
        </trans-unit>
        <trans-unit id="b7db5f9d834448c3fd65f59044d31e02c3be0663" translate="yes" xml:space="preserve">
          <source>It can profile into Julia's core code and even (optionally) into C and Fortran libraries.</source>
          <target state="translated">Puede hacer un perfil del código central de Julia e incluso (opcionalmente)de las bibliotecas C y Fortran.</target>
        </trans-unit>
        <trans-unit id="c491763305aba9f2c8a952732183092d445bd3cb" translate="yes" xml:space="preserve">
          <source>It decomposes &lt;code&gt;[A; B]&lt;/code&gt; into &lt;code&gt;[UC; VS]H&lt;/code&gt;, where &lt;code&gt;[UC; VS]&lt;/code&gt; is a natural orthogonal basis for the column space of &lt;code&gt;[A; B]&lt;/code&gt;, and &lt;code&gt;H = RQ'&lt;/code&gt; is a natural non-orthogonal basis for the rowspace of &lt;code&gt;[A;B]&lt;/code&gt;, where the top rows are most closely attributed to the &lt;code&gt;A&lt;/code&gt; matrix, and the bottom to the &lt;code&gt;B&lt;/code&gt; matrix. The multi-cosine/sine matrices &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt; provide a multi-measure of how much &lt;code&gt;A&lt;/code&gt; vs how much &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; provide directions in which these are measured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10e801b8b0e3436ff2d170e31afdf3876bf67ea" translate="yes" xml:space="preserve">
          <source>It does not return.</source>
          <target state="translated">No regresa.</target>
        </trans-unit>
        <trans-unit id="62d668cd36ba8709a3dd4638a2eee6fedce824d7" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type and the tuple length is in the set {2-6,8-10,16}.</source>
          <target state="translated">Tiene una regla de compilaci&amp;oacute;n especial: una tupla homog&amp;eacute;nea de &lt;code&gt;VecElement{T}&lt;/code&gt; asigna a un tipo de &lt;code&gt;vector&lt;/code&gt; LLVM cuando &lt;code&gt;T&lt;/code&gt; es un tipo de bits primitivo y la longitud de la tupla est&amp;aacute; en el conjunto {2-6,8-10,16}.</target>
        </trans-unit>
        <trans-unit id="60e06d084730278b0af0749e7022e6e9535b9603" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f1e7a71c8a1cc6e09f468c80045e4456b3f7b6" translate="yes" xml:space="preserve">
          <source>It has a toplevel &lt;code&gt;path&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; will be mapped to that path, interpreted relative to the directory containing the project file.</source>
          <target state="translated">Tiene una entrada de &lt;code&gt;path&lt;/code&gt; superior , luego &lt;code&gt;uuid&lt;/code&gt; se asignar&amp;aacute; a esa ruta, interpretada en relaci&amp;oacute;n con el directorio que contiene el archivo del proyecto.</target>
        </trans-unit>
        <trans-unit id="5302402dcc63d9a0a8348f68814a706354ef52ba" translate="yes" xml:space="preserve">
          <source>It has access to a special locally existent function called &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; that creates objects of the block's type.</source>
          <target state="translated">Tiene acceso a una funci&amp;oacute;n especial existente localmente llamada &lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; que crea objetos del tipo del bloque.</target>
        </trans-unit>
        <trans-unit id="e219a846f311411f285e81a3aae4c1e7bf0947a9" translate="yes" xml:space="preserve">
          <source>It is almost always preferable to wrap an existing primitive type in a new composite type than to define your own primitive type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fbc8a317cac4fe1eddafff9a3cee6a2e600d5c8" translate="yes" xml:space="preserve">
          <source>It is also important to see how &lt;code&gt;@generated&lt;/code&gt; functions interact with method redefinition. Following the principle that a correct &lt;code&gt;@generated&lt;/code&gt; function must not observe any mutable state or cause any mutation of global state, we see the following behavior. Observe that the generated function &lt;em&gt;cannot&lt;/em&gt; call any method that was not defined prior to the &lt;em&gt;definition&lt;/em&gt; of the generated function itself.</source>
          <target state="translated">Tambi&amp;eacute;n es importante ver c&amp;oacute;mo &lt;code&gt;@generated&lt;/code&gt; funciones @generated interact&amp;uacute;an con la redefinici&amp;oacute;n del m&amp;eacute;todo. Siguiendo el principio de que una funci&amp;oacute;n &lt;code&gt;@generated&lt;/code&gt; correcta no debe observar ning&amp;uacute;n estado mutable ni provocar ninguna mutaci&amp;oacute;n del estado global, vemos el siguiente comportamiento. Observe que la funci&amp;oacute;n generada &lt;em&gt;no puede&lt;/em&gt; llamar a ning&amp;uacute;n m&amp;eacute;todo que no haya sido definido antes de la &lt;em&gt;definici&amp;oacute;n&lt;/em&gt; de la funci&amp;oacute;n generada en s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="acbe3463a0ccc2ec8908f82ece54174f7671b1ae" translate="yes" xml:space="preserve">
          <source>It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;1[] == 1&lt;/code&gt;). In particular, if &lt;code&gt;x = 0.0&lt;/code&gt; is defined as a scalar, it is an error to attempt to change its value via &lt;code&gt;x[] = 1.0&lt;/code&gt;. A scalar &lt;code&gt;x&lt;/code&gt; can be converted into a zero-dimensional array containing it via &lt;code&gt;fill(x)&lt;/code&gt;, and conversely, a zero-dimensional array &lt;code&gt;a&lt;/code&gt; can be converted to the contained scalar via &lt;code&gt;a[]&lt;/code&gt;. Another difference is that a scalar can participate in linear algebra operations such as &lt;code&gt;2 * rand(2,2)&lt;/code&gt;, but the analogous operation with a zero-dimensional array &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; is an error.</source>
          <target state="translated">Tambi&amp;eacute;n es importante comprender las diferencias con los escalares ordinarios. Los escalares no son contenedores mutables (a pesar de que son iterables y definen cosas como &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;getindex&lt;/code&gt; , &lt;em&gt;por ejemplo&lt;/em&gt; , &lt;code&gt;1[] == 1&lt;/code&gt; ). En particular, si &lt;code&gt;x = 0.0&lt;/code&gt; se define como un escalar, es un error intentar cambiar su valor mediante &lt;code&gt;x[] = 1.0&lt;/code&gt; . Un escalar &lt;code&gt;x&lt;/code&gt; se puede convertir en una matriz de dimensi&amp;oacute;n cero que lo contenga mediante &lt;code&gt;fill(x)&lt;/code&gt; y, a la inversa, una matriz de dimensi&amp;oacute;n cero &lt;code&gt;a&lt;/code&gt; se puede convertir en el escalar contenido mediante &lt;code&gt;a[]&lt;/code&gt; . Otra diferencia es que un escalar puede participar en operaciones de &amp;aacute;lgebra lineal como &lt;code&gt;2 * rand(2,2)&lt;/code&gt; , pero la operaci&amp;oacute;n an&amp;aacute;loga con una matriz de dimensi&amp;oacute;n cero &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; es un error.</target>
        </trans-unit>
        <trans-unit id="a6aa34f5f096577fc826b15725104feebe319049" translate="yes" xml:space="preserve">
          <source>It is also often useful to allow iteration over a collection in &lt;em&gt;reverse order&lt;/em&gt; by iterating over &lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt;&lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt;&lt;/a&gt;. To actually support reverse-order iteration, however, an iterator type &lt;code&gt;T&lt;/code&gt; needs to implement &lt;code&gt;iterate&lt;/code&gt; for &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt;. (Given &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt;, the underling iterator of type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;r.itr&lt;/code&gt;.) In our &lt;code&gt;Squares&lt;/code&gt; example, we would implement &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; methods:</source>
          <target state="translated">Tambi&amp;eacute;n suele ser &amp;uacute;til permitir la iteraci&amp;oacute;n sobre una colecci&amp;oacute;n en &lt;em&gt;orden inverso&lt;/em&gt; al iterar sobre &lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt; &lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt; &lt;/a&gt; . Sin embargo, para admitir realmente la iteraci&amp;oacute;n de orden inverso, un tipo de iterador &lt;code&gt;T&lt;/code&gt; necesita implementar &lt;code&gt;iterate&lt;/code&gt; para &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt; . (Dado &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt; , el iterador subyacente de tipo &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;r.itr&lt;/code&gt; .) En nuestro ejemplo de &lt;code&gt;Squares&lt;/code&gt; , implementar&amp;iacute;amos los m&amp;eacute;todos &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3e1077394826061ef79c129bd16ea289c7d0ba39" translate="yes" xml:space="preserve">
          <source>It is also possible to apply boldface formatting by using &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; as a color. For instance, to print answers in boldface font, one can use the following as a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">Tambi&amp;eacute;n es posible aplicar formato de negrita utilizando &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; como color. Por ejemplo, para imprimir las respuestas en negrita, se puede usar lo siguiente como &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b553bb959838778f24d5092568f001b6908e4f87" translate="yes" xml:space="preserve">
          <source>It is also possible to interact with a Julia REPL in the browser via &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;. See the package home for details.</source>
          <target state="translated">Tambi&amp;eacute;n es posible interactuar con Julia REPL en el navegador a trav&amp;eacute;s de &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt; . Vea el paquete a casa para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="107b61cbdd6b182357e4837cba9afce4360112e7" translate="yes" xml:space="preserve">
          <source>It is also used to &lt;code&gt;show&lt;/code&gt; julia source code which has gone through macro hygiene or otherwise contains variable names which can't be parsed normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f0d3358e54fed68167ad7e2f2668925a7d33bb" translate="yes" xml:space="preserve">
          <source>It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like &lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt;&lt;code&gt;pi&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Tambi&amp;eacute;n vale la pena enfatizar que las funciones deben tomar argumentos, en lugar de operar directamente en variables globales (aparte de constantes como &lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt; &lt;code&gt;pi&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="af4f80c2a3eb6b9cc2e18a2eac5ff00feaaaca4a" translate="yes" xml:space="preserve">
          <source>It is better to avoid errors than to rely on catching them.</source>
          <target state="translated">Es mejor evitar los errores que confiar en atraparlos.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
