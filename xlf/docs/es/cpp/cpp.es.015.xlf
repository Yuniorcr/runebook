<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="b2bd7d3deca1dfde9d0e77745248dd3241e3fb2f" translate="yes" xml:space="preserve">
          <source>Hardware could require that an object to be referenced by an &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; have stricter alignment than other &lt;code&gt;T&lt;/code&gt; objects, and whether operations on an &lt;code&gt;atomic_ref&lt;/code&gt; are lock-free can depend on the alignment of the referenced object.</source>
          <target state="translated">El hardware podr&amp;iacute;a requerir que un objeto al que hace referencia un &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; tenga una alineaci&amp;oacute;n m&amp;aacute;s estricta que otros objetos &lt;code&gt;T&lt;/code&gt; , y si las operaciones en un &lt;code&gt;atomic_ref&lt;/code&gt; est&amp;aacute;n libres de bloqueo puede depender de la alineaci&amp;oacute;n del objeto referenciado.</target>
        </trans-unit>
        <trans-unit id="50278ca49d19fb7161c9b6156704c44ac84f382e" translate="yes" xml:space="preserve">
          <source>Has all non-static data members and bit-fields declared in the same class (either all in the derived or all in some base)</source>
          <target state="translated">Tiene todos los miembros de datos no estáticos y los campos de bits declarados en la misma clase (ya sea todos en la base derivada o todos en alguna base)</target>
        </trans-unit>
        <trans-unit id="132088df73d03b2b991fee16006dc96529cc0d11" translate="yes" xml:space="preserve">
          <source>Has no base classes of the same type as the first non-static data member (see &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;)</source>
          <target state="translated">No tiene clases base del mismo tipo que el primer miembro de datos no est&amp;aacute;tico (ver &lt;a href=&quot;../language/ebo&quot;&gt;optimizaci&amp;oacute;n de base vac&amp;iacute;a&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3282080bc3a2066760485abf22d4931cd7cf3786" translate="yes" xml:space="preserve">
          <source>Has no non-static data members of reference type</source>
          <target state="translated">No tiene miembros de datos no estáticos de tipo de referencia</target>
        </trans-unit>
        <trans-unit id="c4b0a2efb77a438bdd71e13e8a4b27ab2c2ef90e" translate="yes" xml:space="preserve">
          <source>Has no two (possibly indirect) base class subobjects of the same type</source>
          <target state="translated">No tiene dos subobjetos de clase base (posiblemente indirectos)del mismo tipo</target>
        </trans-unit>
        <trans-unit id="e78a6eedfa1171855e11a7dd558ba1ee29f9b975" translate="yes" xml:space="preserve">
          <source>Has no virtual functions or virtual base classes</source>
          <target state="translated">No tiene funciones virtuales o clases base virtuales</target>
        </trans-unit>
        <trans-unit id="07ad7632b84dfe67303c7a8f028a0886800e4870" translate="yes" xml:space="preserve">
          <source>Has one or more &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructors&lt;/a&gt;, all of which are either &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial&lt;/a&gt; or deleted, and at least one of which is not deleted.</source>
          <target state="translated">Tiene uno o m&amp;aacute;s &lt;a href=&quot;../language/default_constructor&quot;&gt;constructores predeterminados&lt;/a&gt; , todos los cuales son &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;triviales&lt;/a&gt; o eliminados, y al menos uno de los cuales no se elimina.</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="cc87e65725671e76b83dd75a39435552efd495a6" translate="yes" xml:space="preserve">
          <source>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.</source>
          <target state="translated">Las funciones de hash sólo se requieren para producir el mismo resultado para la misma entrada dentro de una sola ejecución de un programa;esto permite hashes salados que evitan los ataques de negación de servicio por colisión.</target>
        </trans-unit>
        <trans-unit id="4cd57ebbbfb5b1908d66fa1e003e1ce14e29637e" translate="yes" xml:space="preserve">
          <source>Hash functions should not throw exceptions.</source>
          <target state="translated">Las funciones de hash no deben arrojar excepciones.</target>
        </trans-unit>
        <trans-unit id="7250b05d4111b3b36a49cda927210c8e3d368f6a" translate="yes" xml:space="preserve">
          <source>Hash policy</source>
          <target state="translated">Política de Hash</target>
        </trans-unit>
        <trans-unit id="b807d317600ff4b338e846d561ee4e0b84f0360a" translate="yes" xml:space="preserve">
          <source>Hash support</source>
          <target state="translated">Soporte de hachís</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="31341c6f0c7af677ffb8fadcb92038e8ac2b6193" translate="yes" xml:space="preserve">
          <source>Header</source>
          <target state="translated">Header</target>
        </trans-unit>
        <trans-unit id="f123fa3f00736262aa136563dd12c3a430fa1bf8" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive.</source>
          <target state="translated">Los tokens de preprocesamiento de nombre de encabezado solo se forman dentro de una directiva &lt;code&gt;#include&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a9eca02fd1369c5ba18c271ae9822e684c6bc3d" translate="yes" xml:space="preserve">
          <source>Headers required for a</source>
          <target state="translated">Los encabezados requeridos para una</target>
        </trans-unit>
        <trans-unit id="8cd5e50ec159eebcf43e109ff007519db94c87f5" translate="yes" xml:space="preserve">
          <source>Heap allocation</source>
          <target state="translated">Asignación de la pila</target>
        </trans-unit>
        <trans-unit id="adcf91c671cec8bebaf87ee37c2421ff5ebb56fd" translate="yes" xml:space="preserve">
          <source>Heap operations</source>
          <target state="translated">Operaciones de acumulación...</target>
        </trans-unit>
        <trans-unit id="43a1b94a7a6895d855248fbccdd91510cfbd3ac0" translate="yes" xml:space="preserve">
          <source>Helper Classes</source>
          <target state="translated">Clases de ayuda</target>
        </trans-unit>
        <trans-unit id="035f96a8918459049a59bec0947605cd2a64fdef" translate="yes" xml:space="preserve">
          <source>Helper classes</source>
          <target state="translated">Clases para ayudantes</target>
        </trans-unit>
        <trans-unit id="7612db9ee91cb4487af96f647ff4f3cd2038be3a" translate="yes" xml:space="preserve">
          <source>Helper concepts</source>
          <target state="translated">Conceptos de ayuda</target>
        </trans-unit>
        <trans-unit id="058d2ea713d8ed40ef598fece850d00d28cef415" translate="yes" xml:space="preserve">
          <source>Helper functions &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; are often used to generate &lt;code&gt;std::reference_wrapper&lt;/code&gt; objects.</source>
          <target state="translated">Las funciones auxiliares &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; se usan a menudo para generar objetos &lt;code&gt;std::reference_wrapper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9564c40bd71a52a2d2792a274dcd71ecab83247" translate="yes" xml:space="preserve">
          <source>Helper functions to control the format of input and output</source>
          <target state="translated">Funciones de ayuda para controlar el formato de entrada y salida</target>
        </trans-unit>
        <trans-unit id="24355834da4c51ce8fa25dadf7ca038baf516e2f" translate="yes" xml:space="preserve">
          <source>Helper objects</source>
          <target state="translated">Objetos de ayuda</target>
        </trans-unit>
        <trans-unit id="bbca939563aab0002ed11e9e60251643d9e2435c" translate="yes" xml:space="preserve">
          <source>Helper template</source>
          <target state="translated">Plantilla del ayudante</target>
        </trans-unit>
        <trans-unit id="26e4565205fc729962b9119b4035fad3d08ea499" translate="yes" xml:space="preserve">
          <source>Helper template alias</source>
          <target state="translated">El alias de la plantilla de ayudantes</target>
        </trans-unit>
        <trans-unit id="62f3bc8fedb9c00e4b9d3da1c58627fb9c932c3e" translate="yes" xml:space="preserve">
          <source>Helper templates</source>
          <target state="translated">Plantillas de ayuda</target>
        </trans-unit>
        <trans-unit id="58208feff4ae33c36603b46c3dceaa24f222cc8d" translate="yes" xml:space="preserve">
          <source>Helper types</source>
          <target state="translated">Tipos de ayudantes</target>
        </trans-unit>
        <trans-unit id="0b456005f09a660089e455709c3792d427e45f64" translate="yes" xml:space="preserve">
          <source>Helper variable template</source>
          <target state="translated">Plantilla variable del ayudante</target>
        </trans-unit>
        <trans-unit id="777d2c2c6fac9bb59d841ec60aa0bce62ce73ffb" translate="yes" xml:space="preserve">
          <source>Helper variable templates</source>
          <target state="translated">Plantillas de variables de ayuda</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="7023d54552e06b34cfb338ed903ce5341dc89c1a" translate="yes" xml:space="preserve">
          <source>Here &amp;mu; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;mean&lt;/a&gt; and &amp;sigma; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; (</source>
          <target state="translated">Aqu&amp;iacute; &amp;mu; es la &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;media&lt;/a&gt; y &amp;sigma; es la &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;desviaci&amp;oacute;n est&amp;aacute;ndar&lt;/a&gt; (</target>
        </trans-unit>
        <trans-unit id="de582de9c63661c059dbbb7442ed40762e356594" translate="yes" xml:space="preserve">
          <source>Here the sequence &lt;code&gt;= 0&lt;/code&gt; is known as pure-specifier, and appears either immediately after the declarator or after the optional virt-specifier (&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;).</source>
          <target state="translated">Aqu&amp;iacute; la secuencia &lt;code&gt;= 0&lt;/code&gt; se conoce como pura-especificador, y aparece ya sea inmediatamente despu&amp;eacute;s de la declarador o despu&amp;eacute;s de la virt-especificador opcional ( &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; o &lt;a href=&quot;final&quot;&gt;definitiva&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4d46b65d1ca1962518c48c70d9aa7c8452f90c5" translate="yes" xml:space="preserve">
          <source>Here, &lt;b&gt;insertion&lt;/b&gt; refers to any method which adds one or more elements to the container and &lt;b&gt;erasure&lt;/b&gt; refers to any method which removes one or more elements from the container.</source>
          <target state="translated">Aqu&amp;iacute;, la &lt;b&gt;inserci&amp;oacute;n se&lt;/b&gt; refiere a cualquier m&amp;eacute;todo que agrega uno o m&amp;aacute;s elementos al contenedor y la &lt;b&gt;eliminaci&amp;oacute;n se&lt;/b&gt; refiere a cualquier m&amp;eacute;todo que elimina uno o m&amp;aacute;s elementos del contenedor.</target>
        </trans-unit>
        <trans-unit id="b19a132f13926967d1824a2efe39a0ee64381eb2" translate="yes" xml:space="preserve">
          <source>Hermite polynomials</source>
          <target state="translated">Los polinomios de las hermitas</target>
        </trans-unit>
        <trans-unit id="2dc4f9ad06827dbb0f947199ccb4b57ddbc18030" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="translated">Las secuencias de escape hexadecimales no tienen l&amp;iacute;mite de longitud y terminan en el primer car&amp;aacute;cter que no es un d&amp;iacute;gito hexadecimal v&amp;aacute;lido. Si el valor representado por una &amp;uacute;nica secuencia de escape hexadecimal no se ajusta al rango de valores representados por el tipo de caracteres utilizado en este literal de cadena ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; o &lt;code&gt;wchar_t&lt;/code&gt; ), el resultado no se especifica.</target>
        </trans-unit>
        <trans-unit id="29f4576900e04b4bdfd8b4fe7f982605474c3863" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating literals</source>
          <target state="translated">Literales flotantes hexadecimales</target>
        </trans-unit>
        <trans-unit id="fcb2d1955da83c672014766fe096b6618bd4cc33" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point formatting ignores the stream precision specification, as required by the specification of &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El formato de punto flotante hexadecimal ignora la especificaci&amp;oacute;n de precisi&amp;oacute;n de flujo, como lo requiere la especificaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="903711dad7d075316de1f7c8c822711821173306" translate="yes" xml:space="preserve">
          <source>Higher level memory management utilities</source>
          <target state="translated">Utilidades de gestión de memoria de alto nivel</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="0201fd3572c6260109888327f99b40b98e8c814b" translate="yes" xml:space="preserve">
          <source>History of C++</source>
          <target state="translated">Historia de C++</target>
        </trans-unit>
        <trans-unit id="9c025e64c93f51353b31decb167c0c14635a6990" translate="yes" xml:space="preserve">
          <source>Host is unreachable</source>
          <target state="translated">El anfitrión es inalcanzable</target>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="translated">Hora,minuto,segundo</target>
        </trans-unit>
        <trans-unit id="a84d5827435e6eaee2628507f60c486924602e72" translate="yes" xml:space="preserve">
          <source>However if &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; no applications of the predicate are made.</source>
          <target state="translated">Sin embargo, si &lt;code&gt;ForwardIt1&lt;/code&gt; y &lt;code&gt;ForwardIt2&lt;/code&gt; cumplen los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; y &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; no se realizan aplicaciones del predicado.</target>
        </trans-unit>
        <trans-unit id="06e6faa2b0497056bfffbc66aaba9ed450e5ff3a" translate="yes" xml:space="preserve">
          <source>However, all C++ compilers use &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;two's complement&lt;/a&gt; representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from -2N-1</source>
          <target state="translated">Sin embargo, todos los compiladores de C ++ usan &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;la&lt;/a&gt; representaci&amp;oacute;n del complemento a dos , y a partir de C ++ 20, es la &amp;uacute;nica representaci&amp;oacute;n permitida por el est&amp;aacute;ndar, con el rango garantizado de -2N-1</target>
        </trans-unit>
        <trans-unit id="a5298c4b4732ec5cdb50753f0b7bff99ff4504e8" translate="yes" xml:space="preserve">
          <source>However, base class subobjects are not so constrained, and can be completely optimized out from the object layout:</source>
          <target state="translated">Sin embargo,los subobjetos de la clase base no están tan limitados,y pueden ser completamente optimizados a partir de la disposición del objeto:</target>
        </trans-unit>
        <trans-unit id="0474028c83ae02e6c1719cbd200f19338eb23c2e" translate="yes" xml:space="preserve">
          <source>However, for non-&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;, the number of iterator increments is O(N).</source>
          <target state="translated">Sin embargo, para los no &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; , el n&amp;uacute;mero de incrementos de iterador es O (N).</target>
        </trans-unit>
        <trans-unit id="a7074ce423985ae2c548c5817d3af2b722ab809a" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;BidirIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">Sin embargo, si &lt;code&gt;BidirIt&lt;/code&gt; cumple adicionalmente con los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , la complejidad es constante.</target>
        </trans-unit>
        <trans-unit id="c130fc889986236f01e7bd0a7491d9e506116625" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; then no applications of the predicate are made (size mismatch is detected without looking at any elements).</source>
          <target state="translated">Sin embargo, si &lt;code&gt;InputIt1&lt;/code&gt; y &lt;code&gt;InputIt2&lt;/code&gt; cumplen los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; y &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; , no se realizan aplicaciones del predicado (se detecta una discrepancia de tama&amp;ntilde;o sin mirar ning&amp;uacute;n elemento).</target>
        </trans-unit>
        <trans-unit id="d4de2084e6a7ba7c4a9702f5d91188f9754f96a6" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">Sin embargo, si &lt;code&gt;InputIt&lt;/code&gt; cumple adicionalmente con los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , la complejidad es constante.</target>
        </trans-unit>
        <trans-unit id="923af777ec78d98d0a47fdd5e9f0c732405eb150" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">Sin embargo, si &lt;code&gt;InputIt&lt;/code&gt; o &lt;code&gt;ForwardIt&lt;/code&gt; cumple adicionalmente con los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , la complejidad es constante.</target>
        </trans-unit>
        <trans-unit id="789aa7b03048a6d89e55166c2876d111a76287b2" translate="yes" xml:space="preserve">
          <source>However, if deduction succeeds for all parameters that participate in template argument deduction, and all template arguments that aren't deduced are explicitly specified or defaulted, then the remaining function parameters are compared with the corresponding function arguments. For each remaining parameter &lt;code&gt;P&lt;/code&gt; with a type that was non-dependent before substitution of any explicitly-specified template arguments, if the corresponding argument &lt;code&gt;A&lt;/code&gt; cannot be implicitly converted to &lt;code&gt;P&lt;/code&gt;, deduction fails.</source>
          <target state="translated">Sin embargo, si la deducci&amp;oacute;n tiene &amp;eacute;xito para todos los par&amp;aacute;metros que participan en la deducci&amp;oacute;n de argumentos de plantilla, y todos los argumentos de plantilla que no se deducen se especifican expl&amp;iacute;citamente o se omiten, los par&amp;aacute;metros de funci&amp;oacute;n restantes se comparan con los argumentos de funci&amp;oacute;n correspondientes. Para cada par&amp;aacute;metro restante &lt;code&gt;P&lt;/code&gt; con un tipo que no era dependiente antes de la sustituci&amp;oacute;n de cualquier argumento de plantilla especificado expl&amp;iacute;citamente, si el argumento correspondiente &lt;code&gt;A&lt;/code&gt; no se puede convertir impl&amp;iacute;citamente a &lt;code&gt;P&lt;/code&gt; , la deducci&amp;oacute;n falla.</target>
        </trans-unit>
        <trans-unit id="d3ec3f026f2aba3bad033eb828adf9c63839692d" translate="yes" xml:space="preserve">
          <source>However, if the declaration uses &lt;a href=&quot;constexpr&quot;&gt;&lt;code&gt;constexpr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;(since C++17) specifier, the member must be declared to have complete type.</source>
          <target state="translated">Sin embargo, si la declaraci&amp;oacute;n usa &lt;a href=&quot;constexpr&quot;&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;/a&gt; o un especificador en &lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt; (desde C ++ 17), se debe declarar que el miembro tiene un tipo completo.</target>
        </trans-unit>
        <trans-unit id="9217191a146bae3519a7a8c89cf7f10d4b0ff050" translate="yes" xml:space="preserve">
          <source>However, one implementation (libc++) is known to construct the &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; objects via two separate allocator &lt;code&gt;construct()&lt;/code&gt; calls, as arguably required by the standards as published, rather than emplacing a &lt;code&gt;value_type&lt;/code&gt; object.</source>
          <target state="translated">Sin embargo, se sabe que una implementaci&amp;oacute;n (libc ++) construye los objetos &lt;code&gt;key_type&lt;/code&gt; y &lt;code&gt;mapped_type&lt;/code&gt; a trav&amp;eacute;s de dos llamadas de &lt;code&gt;construct()&lt;/code&gt; asignador separadas , como posiblemente lo exijan los est&amp;aacute;ndares publicados, en lugar de emplazar un objeto &lt;code&gt;value_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b2db98636723bfe7992740aadfd807719cd51f4" translate="yes" xml:space="preserve">
          <source>However, the attributes that appear after the declarator (in the syntax above), apply to the type of the function, not to the function itself.</source>
          <target state="translated">Sin embargo,los atributos que aparecen después del declarante (en la sintaxis anterior),se aplican al tipo de la función,no a la función misma.</target>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">El coseno hiperb&amp;oacute;lico es una funci&amp;oacute;n completa en el plano complejo y no tiene cortes de rama. Es peri&amp;oacute;dico con respecto al componente imaginario, con per&amp;iacute;odo 2&amp;pi;i.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">Funciones hiperbólicas</target>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">El seno hiperb&amp;oacute;lico es una funci&amp;oacute;n completa en el plano complejo y no tiene cortes de ramas. Es peri&amp;oacute;dico con respecto al componente imaginario, con per&amp;iacute;odo 2&amp;pi;i.</target>
        </trans-unit>
        <trans-unit id="c6a249eb7c58320fe1bb3e19e6e61f7ae663bb92" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">La tangente hiperb&amp;oacute;lica es una funci&amp;oacute;n anal&amp;iacute;tica en la llanura compleja y no tiene cortes de ramas. Es peri&amp;oacute;dico con respecto al componente imaginario, con per&amp;iacute;odo &amp;pi;i, y tiene polos de primer orden a lo largo de la l&amp;iacute;nea imaginaria, en las coordenadas (0, &amp;pi; (1/2 + n)). Sin embargo, ninguna representaci&amp;oacute;n com&amp;uacute;n de coma flotante puede representar exactamente &amp;pi; / 2, por lo tanto, no hay ning&amp;uacute;n valor del argumento para el que se produce un error de polo.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="6b58ece8e2eb85355e743b6e1a72cb6eb0c30006" translate="yes" xml:space="preserve">
          <source>I/O Manipulators</source>
          <target state="translated">Manipuladores I/O</target>
        </trans-unit>
        <trans-unit id="0676b814ab2a9d403059287e94b18b3f3ed5e63c" translate="yes" xml:space="preserve">
          <source>I/O error</source>
          <target state="translated">Error de E/S</target>
        </trans-unit>
        <trans-unit id="3fd6cee6dbc10d47db1d5e293da18cd3279cfd34" translate="yes" xml:space="preserve">
          <source>I/O format flags are obtained, as if by</source>
          <target state="translated">Los indicadores de formato de E/S se obtienen,como si por</target>
        </trans-unit>
        <trans-unit id="00a1147221fe28724b5d852d3cc11debd18ea881" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ Inline Assembly</source>
          <target state="translated">IBM XL C/C++Ensamblaje en línea</target>
        </trans-unit>
        <trans-unit id="97e6907b70a51197746c7a59244053494e95092c" translate="yes" xml:space="preserve">
          <source>ICE</source>
          <target state="translated">ICE</target>
        </trans-unit>
        <trans-unit id="2eb6372a578be72d248c4e343e8fc7a5d78b9a77" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="translated">IEC 60559 recomienda que &lt;code&gt;from&lt;/code&gt; retorna siempre &lt;code&gt;from==to&lt;/code&gt; . En cambio, estas funciones vuelven &lt;code&gt;to&lt;/code&gt; , lo que hace que el comportamiento alrededor de cero sea consistente: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; devuelve &lt;code&gt;+0.0&lt;/code&gt; y &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; devuelve &lt;code&gt;&amp;ndash;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="47a57f6b8f5e7dac870d669f2d10489423c2c097" translate="yes" xml:space="preserve">
          <source>INVERTED UNDERTIE</source>
          <target state="translated">CORBATA INTERIOR INVERTIDA</target>
        </trans-unit>
        <trans-unit id="6f332e7bc9fb4c964cc115b4bb4e0c9c81b651a9" translate="yes" xml:space="preserve">
          <source>INVOKE</source>
          <target state="translated">INVOKE</target>
        </trans-unit>
        <trans-unit id="bfa0e3fd8d2d6bf8a03a66ca3906291682906b88" translate="yes" xml:space="preserve">
          <source>INVOKE&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOCAR &amp;lt;R&amp;gt; (f, t1, t2, ..., tN)</target>
        </trans-unit>
        <trans-unit id="381dd7d678830c863bcf610275aa82caf553b63a" translate="yes" xml:space="preserve">
          <source>INVOKE(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOCACIÓN(f,t1,t2,...,tN)</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="translated">La ISO 30112 define los caracteres de control POSIX como caracteres Unicode U+0000..U+001F,U+007F..U+009F,U+2028,y U+2029 (clases Unicode Cc,Zl,y Zp).</target>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="translated">ISO 30112 define los caracteres de espacio POSIX como caracteres Unicode U+0009..U+000D,U+0020,U+1680,U+180E,U+2000..U+2006,U+2008..U+200A,U+2028,U+2029,U+205F,y U+3000.</target>
        </trans-unit>
        <trans-unit id="83c8d536c17446dc8d23f11cf08547ab6f0ceaef" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-based year</source>
          <target state="translated">ISO 8601 año basado en la semana</target>
        </trans-unit>
        <trans-unit id="660c1f28ee4e6a1155a4515d1d3d38f625034fe8" translate="yes" xml:space="preserve">
          <source>ISO C language standard requires that C compilers support the following three pragmas, and some C++ compiler vendors support them, to varying degrees, in their C++ frontends:</source>
          <target state="translated">El estándar del lenguaje C de la ISO requiere que los compiladores C soporten los siguientes tres pragmas,y algunos proveedores de compiladores C++los soportan,en diversos grados,en sus frontales C++:</target>
        </trans-unit>
        <trans-unit id="f0de3ffcac31393cdc320a257a71c6856ecd9b41" translate="yes" xml:space="preserve">
          <source>Identical to the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">Id&amp;eacute;ntico a la complejidad de &lt;code&gt;Container::emplace_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c1a745105ff9b6c357cf50bdd91090ffef6ae55" translate="yes" xml:space="preserve">
          <source>Identifier removed</source>
          <target state="translated">Se ha eliminado el identificador</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="8967e7083aa7ece41be13822051695a635bff07e" translate="yes" xml:space="preserve">
          <source>If &amp;nu;&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="translated">Si &amp;nu;&amp;gt; = 128, el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="c861ca152a1a5790f61fc9a7ad6bc1a92ae258c8" translate="yes" xml:space="preserve">
          <source>If (and only if) reallocation takes place, all pointers, references, and iterators are invalidated.</source>
          <target state="translated">Si (y sólo si)se produce una reasignación,se invalidan todos los indicadores,referencias e iteradores.</target>
        </trans-unit>
        <trans-unit id="98c199ab16ab809f486bbb3423d179f029c19b26" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;ON&lt;/code&gt;, all floating-point arithmetic operators obey the current floating-point &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and report floating-point arithmetic errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt; unless part of a &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;static initializer&lt;/a&gt; (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</source>
          <target state="translated">Si &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt; es compatible y se establece en &lt;code&gt;ON&lt;/code&gt; , todos los operadores aritm&amp;eacute;ticos de punto flotante obedecen la &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;direcci&amp;oacute;n de redondeo de&lt;/a&gt; punto flotante actual e informan errores aritm&amp;eacute;ticos de punto flotante como se especifica en &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; a&lt;/a&gt; menos que sea parte de un &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;inicializador est&amp;aacute;tico&lt;/a&gt; (en cuyo caso, punto flotante no se generan excepciones y el modo de redondeo es el m&amp;aacute;s cercano).</target>
        </trans-unit>
        <trans-unit id="7bb02eee6cd1dc516434df27056595be6a6b00a7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; of an object of class type requires that a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is called to convert the initializer expression of type cv &lt;code&gt;S&lt;/code&gt; to the type cv &lt;code&gt;T&lt;/code&gt; of the object being initialized, the following functions are candidate functions:</source>
          <target state="translated">Si &lt;a href=&quot;copy_initialization&quot;&gt;la inicializaci&amp;oacute;n&lt;/a&gt; de copia de un objeto de tipo de clase requiere que se llame a una &lt;a href=&quot;cast_operator&quot;&gt;funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario&lt;/a&gt; para convertir la expresi&amp;oacute;n inicializadora de tipo cv &lt;code&gt;S&lt;/code&gt; al tipo cv &lt;code&gt;T&lt;/code&gt; del objeto que se est&amp;aacute; inicializando, las siguientes funciones son funciones candidatas:</target>
        </trans-unit>
        <trans-unit id="cc788d4e3b334778f8f385fbf8f9f00b88dbcecf" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; is used to exit a try-block and if any of the destructors of block-scoped automatic variables that are executed by the &lt;code&gt;goto&lt;/code&gt; throw exceptions, those exceptions are caught by the try blocks in which the variables are defined:</source>
          <target state="translated">Si se usa &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; para salir de un bloque try y si alguno de los destructores de variables autom&amp;aacute;ticas con &amp;aacute;mbito de bloque que se ejecutan mediante las excepciones de lanzamiento de &lt;code&gt;goto&lt;/code&gt; , los bloques try capturan esas excepciones en las que se definen las variables:</target>
        </trans-unit>
        <trans-unit id="ad02ee6de1557c2cab77c2034cb247d4122fb981" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; is true, does nothing. Otherwise, destroys the currently contained value.</source>
          <target state="translated">Si &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; es verdadero, no hace nada. De lo contrario, destruye el valor actualmente contenido.</target>
        </trans-unit>
        <trans-unit id="22e67fa78b1a05182b627ae99ffd3c2b45940a22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!m.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated month name for the month represented by &lt;code&gt;m&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;!m.ok()&lt;/code&gt; , equivalente a &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt; . De lo contrario, forma un &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; que consiste en el nombre abreviado del mes para el mes representado por &lt;code&gt;m&lt;/code&gt; , determinado utilizando el entorno local asociado con &lt;code&gt;os&lt;/code&gt; , e inserta &lt;code&gt;s&lt;/code&gt; en &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1a70707db6a348980443d56c9ab0c52464c252f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;!uppercase&lt;/code&gt; , se utilizar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f6dfc884c101654edafd48a800532bba66066cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!wd.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated weekday name for the weekday represented by &lt;code&gt;wd&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;!wd.ok()&lt;/code&gt; , equivalente a &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt; . De lo contrario, forma un &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; que consiste en el nombre abreviado del d&amp;iacute;a de la semana para el d&amp;iacute;a de la semana representado por &lt;code&gt;wd&lt;/code&gt; , determinado usando la configuraci&amp;oacute;n regional asociada con &lt;code&gt;os&lt;/code&gt; , e inserta &lt;code&gt;s&lt;/code&gt; en el &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc136d5ecc5ffd29fb88143ae3ce7ad3bfccb312" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;tuple&lt;/code&gt; is trivial.</source>
          <target state="translated">Si &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el destructor de &lt;code&gt;tuple&lt;/code&gt; es trivial.</target>
        </trans-unit>
        <trans-unit id="da8cff62887e613aba67b865a9e6d73a9a0208c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, calls &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt;. If that function returns &lt;code&gt;-1&lt;/code&gt;, sets &lt;code&gt;badbit&lt;/code&gt; in &lt;code&gt;os.rdstate()&lt;/code&gt; without propagating an exception.</source>
          <target state="translated">If &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , llama a &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; . Si esa funci&amp;oacute;n devuelve &lt;code&gt;-1&lt;/code&gt; , establece &lt;code&gt;badbit&lt;/code&gt; en &lt;code&gt;os.rdstate()&lt;/code&gt; sin propagar una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cd5e11e3cc0c402b0e9be870090813113d4c62f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt;, then an implementation-defined value is substituted instead of &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt;, possibly different for different values of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; , se sustituye un valor definido por la implementaci&amp;oacute;n en lugar de &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt; , posiblemente diferente para diferentes valores de &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92961dd363bdfb6c745602ae238d61a26e00ce3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; refer to the same object, then &lt;code&gt;a&lt;/code&gt; == &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;*a&lt;/code&gt; y &lt;code&gt;*b&lt;/code&gt; se refieren al mismo objeto, entonces &lt;code&gt;a&lt;/code&gt; == &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d8fc3988020f52aa4cd322d347c93e64ecb80c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, and &lt;code&gt;r&lt;/code&gt; is not the same as &lt;code&gt;*this&lt;/code&gt;, the object is destroyed through the owned deleter.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; ya posee un objeto y es el &amp;uacute;ltimo &lt;code&gt;shared_ptr&lt;/code&gt; que lo posee, y &lt;code&gt;r&lt;/code&gt; no es lo mismo que &lt;code&gt;*this&lt;/code&gt; , el objeto se destruye a trav&amp;eacute;s del borrador propio.</target>
        </trans-unit>
        <trans-unit id="d91b74584f1eaef50da01b154cf35ae1c060bd65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; ya posee un objeto y es el &amp;uacute;ltimo &lt;code&gt;shared_ptr&lt;/code&gt; que lo posee, el objeto se destruye a trav&amp;eacute;s del borrador propio.</target>
        </trans-unit>
        <trans-unit id="9547dd884045b3da73d2308453755944edbbda07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; both have dynamic type &lt;code&gt;std::exception&lt;/code&gt; then &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; tienen un tipo din&amp;aacute;mico &lt;code&gt;std::exception&lt;/code&gt; entonces &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d03bcb4418c0282af6a72fecf7a440fdb5debe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, but &lt;code&gt;other&lt;/code&gt; does not, then the contained value is destroyed by calling its destructor. &lt;code&gt;*this&lt;/code&gt; does not contain a value after the call.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; contiene un valor, pero &lt;code&gt;other&lt;/code&gt; no, entonces el valor contenido se destruye llamando a su destructor. &lt;code&gt;*this&lt;/code&gt; no contiene un valor despu&amp;eacute;s de la llamada.</target>
        </trans-unit>
        <trans-unit id="a7a277ddff2e8e400ab7cc6265a8854405fc6aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, destroy that value as if by &lt;code&gt;value().T::~T()&lt;/code&gt;. Otherwise, there are no effects.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; contiene un valor, destruya ese valor como si fuera by &lt;code&gt;value().T::~T()&lt;/code&gt; . De lo contrario, no hay efectos.</target>
        </trans-unit>
        <trans-unit id="3f2f61fd72ae5e884e1a574bf73169287b72c489" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, returns a reference to the contained value.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; contiene un valor, devuelve una referencia al valor contenido.</target>
        </trans-unit>
        <trans-unit id="c59d16b11cfaa885be1c6ecd9266546a41ca8652" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; tiene un mutex asociado (( &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; devuelve un puntero no nulo) y ha adquirido la propiedad del mismo ( &lt;code&gt;owns()&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; ), el mutex se desbloquea llamando a &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0082e088403160e49ff73354c8b162b48a36a42a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated thread (&lt;code&gt;joinable() == true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; is called.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; tiene un hilo asociado ( &lt;code&gt;joinable() == true&lt;/code&gt; ), se llama a &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9144affce378c4381a07accbbe9c5b400c516453" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is a suffix iterator, sets &lt;code&gt;*this&lt;/code&gt; to an end-of-sequence iterator.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; es un iterador de sufijo, establece &lt;code&gt;*this&lt;/code&gt; en un iterador de fin de secuencia.</target>
        </trans-unit>
        <trans-unit id="d1c58d5d72435da6477abb6fcff62548ec0974a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is the last object referring to the shared state, destroys the shared state. Otherwise does nothing.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; es el &amp;uacute;ltimo objeto que se refiere al estado compartido, destruye el estado compartido. De lo contrario no hace nada.</target>
        </trans-unit>
        <trans-unit id="43f3508ad52f8c72c8bffdd8e6f95fe0b279e431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; posee un objeto y es el &amp;uacute;ltimo &lt;code&gt;shared_ptr&lt;/code&gt; que lo posee, el objeto se destruye a trav&amp;eacute;s del borrador propio.</target>
        </trans-unit>
        <trans-unit id="0047e92ce8b32348ae1bf76f7759ee5ab1deddb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; still has an associated running thread (i.e. &lt;code&gt;joinable() == true&lt;/code&gt;), call &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt;. Otherwise, assigns the state of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; and sets &lt;code&gt;other&lt;/code&gt; to a default constructed state.</source>
          <target state="translated">Si &lt;code&gt;*this&lt;/code&gt; todav&amp;iacute;a tiene un subproceso en ejecuci&amp;oacute;n asociado (es decir, &lt;code&gt;joinable() == true&lt;/code&gt; ), llame a &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; . De lo contrario, asigna el estado de &lt;code&gt;other&lt;/code&gt; a &lt;code&gt;*this&lt;/code&gt; y establece &lt;code&gt;other&lt;/code&gt; en un estado construido predeterminado.</target>
        </trans-unit>
        <trans-unit id="1c3de47b3604829aa8d6c1f140e9684e3f5dc92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--a == --b&lt;/code&gt; then &lt;code&gt;a == b&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;--a == --b&lt;/code&gt; entonces &lt;code&gt;a == b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90fa435f3b59c79cbaeb4963bb4835737f7d7a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;::&lt;/code&gt; is followed by the character &lt;code&gt;~&lt;/code&gt; that is in turn followed by an identifier (that is, it specifies a destructor or pseudo-destructor), that identifier is looked up in the same scope as the name on the left hand side of &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;::&lt;/code&gt; es seguido por el car&amp;aacute;cter &lt;code&gt;~&lt;/code&gt; que a su vez es seguido por un identificador (es decir, especifica un destructor o pseudodestructor), ese identificador se busca en el mismo alcance que el nombre en el lado izquierdo de &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2a97dc8c387c983d7ce89c28639a1a4934e5f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; is true, the call to &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; may be skipped.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; es verdadero, se puede omitir la llamada a &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="383dd33e0c7222077e9f39a66a18786b4b4abb6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then the allocator is unchanged. Otherwise, after move-assignment, &lt;code&gt;get_allocator()&lt;/code&gt; equals &lt;code&gt;other.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , entonces el asignador no cambia. De lo contrario, despu&amp;eacute;s de la asignaci&amp;oacute;n de movimiento, &lt;code&gt;get_allocator()&lt;/code&gt; es igual a &lt;code&gt;other.get_allocator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="effa1c8a8ecca962a3e2c90eb4b0b4cd886ee427" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is true, then the allocators are exchanged using an unqualified call to non-member &lt;code&gt;swap&lt;/code&gt;. Otherwise, they are not swapped (and if &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;, the behavior is undefined).</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; es verdadero, entonces los asignadores se intercambian utilizando una llamada no calificada para el &lt;code&gt;swap&lt;/code&gt; no miembros . De lo contrario, no se intercambian (y si &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; , el comportamiento es indefinido).</target>
        </trans-unit>
        <trans-unit id="895e0eca3c2f91f7c107010968f8c4eae623b669" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is 2 (or a power of 2), the returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; es 2 (o una potencia de 2), el valor devuelto es exacto, se ignora el &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo actual&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1790032c97cf911e15ed06b1a6725dd974239d4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;, otherwise equivalent to &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt; , arroja &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; , de lo contrario es equivalente a &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5ebe4fc1a8abdaf844d29a3d314c89acaad005a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.get().*f&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; es una especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; es equivalente a &lt;code&gt;t1.get().*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="982ec353c22eb69baf317b330efaf0a7a5e7cce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; es una especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; es equivalente a &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="975228dc0d0d9d407e294a92674384d84c5af876" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; es equivalente a &lt;code&gt;t1.*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebb6d3a6dda70443130e44d3d8eef15c8850d72d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; es equivalente a &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46e80aaa2cfeed3cb98adbf86549699888d28e48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then this destructor is a trivial destructor.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces este destructor es un destructor trivial.</target>
        </trans-unit>
        <trans-unit id="50c9fd79a84089afcea1735d81a6458257a8ebf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is not the appropriate buffer size, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; can be used to change it.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; no es el tama&amp;ntilde;o de b&amp;uacute;fer apropiado, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; puede usarse para cambiarlo.</target>
        </trans-unit>
        <trans-unit id="3ea3c7ca7ae345831d1c696b26e5dd6650ec9617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; has lower precision, it is implementation-defined whether the value is rounded or truncated.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; tiene una precisi&amp;oacute;n menor, se define en la implementaci&amp;oacute;n si el valor se redondea o se trunca.</target>
        </trans-unit>
        <trans-unit id="4b20a41ac6a8f6f3b703c2287f3854ec31392c44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3253a1bdeb3cf6df583da218fc710e43b8aa013f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;gptr()&lt;/code&gt; (the next pointer in the get area). If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;pptr()&lt;/code&gt; (the next pointer in the put area). If neither bit is set in &lt;code&gt;which&lt;/code&gt;, the operation fails.</source>
          <target state="translated">Si se establece &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; en el &lt;code&gt;which&lt;/code&gt; , intenta reposicionar &lt;code&gt;gptr()&lt;/code&gt; (el siguiente puntero en el &amp;aacute;rea de obtenci&amp;oacute;n). Si se establece &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; en el &lt;code&gt;which&lt;/code&gt; , intenta reposicionar &lt;code&gt;pptr()&lt;/code&gt; (el siguiente puntero en el &amp;aacute;rea de venta). Si ninguno de los dos bits se establece en &lt;code&gt;which&lt;/code&gt; , la operaci&amp;oacute;n falla.</target>
        </trans-unit>
        <trans-unit id="1cfad288bd7fbccd70e8241c69a8d092c6bd2656" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or a similar allocator is used, a class does not have to implement a &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructor&lt;/a&gt; to satisfy this type requirement: a &lt;a href=&quot;../language/copy_constructor&quot;&gt;copy constructor&lt;/a&gt; that takes a &lt;code&gt;const T&amp;amp;&lt;/code&gt; argument can bind rvalue expressions. If a MoveInsertable class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="translated">Si se usa &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; o un asignador similar, una clase no tiene que implementar un &lt;a href=&quot;../language/move_constructor&quot;&gt;constructor de movimiento&lt;/a&gt; para satisfacer este requisito de tipo: un &lt;a href=&quot;../language/copy_constructor&quot;&gt;constructor de copia&lt;/a&gt; que toma un argumento &lt;code&gt;const T&amp;amp;&lt;/code&gt; puede vincular expresiones de valor. Si una clase MoveInsertable implementa un constructor de movimiento, tambi&amp;eacute;n puede implementar la &lt;a href=&quot;../utility/move&quot;&gt;sem&amp;aacute;ntica de movimiento&lt;/a&gt; para aprovechar el hecho de que el valor de &lt;code&gt;rv&lt;/code&gt; despu&amp;eacute;s de la construcci&amp;oacute;n no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="3e00f15acad4e10cd2ecd0299fd4d8b97a99bb7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; is a non-final non-union class type that is neither &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; nor derived from &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt;, throws an exception of an unspecified type that is publicly derived from both &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; and from &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, and constructed from &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt;. The default constructor of the &lt;code&gt;nested_exception&lt;/code&gt; base class calls &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;, capturing the currently handled exception object, if any, in a &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; es un tipo de clase no final no sindical que no es &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; ni derivado de &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; , arroja una excepci&amp;oacute;n de un tipo no especificado que se deriva p&amp;uacute;blicamente de ambos &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; y from &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; , y construido a partir de &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt; . El constructor predeterminado de la clase base &lt;code&gt;nested_exception&lt;/code&gt; llama a &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; , capturando el objeto de excepci&amp;oacute;n manejado actualmente, si lo hay, en &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ce6265115b5fdfcaa76a7165b74faf9d8dacb2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; es equivalente a &lt;code&gt;t1.*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f34e8cfb2a1707ab37515e5a9bdd7f9c647abe3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; es equivalente a &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bcb63cc68623b4a13fa5b83d65086795b276b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;pair&lt;/code&gt; is trivial.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el destructor del &lt;code&gt;pair&lt;/code&gt; es trivial.</target>
        </trans-unit>
        <trans-unit id="e1f522d5a7a2b7024a237d287703f33d30c5ccd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; is a pointer to a character type (e.g., when &lt;code&gt;Y&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;CharT&lt;/code&gt;), this may end up calling the &lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt;overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for null-terminated character strings&lt;/a&gt; (causing undefined behavior if the pointer does not in fact point to such a string), rather than &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;the overload for printing the value of the pointer itself&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; es un puntero a un tipo de car&amp;aacute;cter (p. Ej., Cuando &lt;code&gt;Y&lt;/code&gt; es &lt;code&gt;char&lt;/code&gt; o &lt;code&gt;char[]&lt;/code&gt; o &lt;code&gt;CharT&lt;/code&gt; ), esto puede terminar llamando a las &lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt;sobrecargas del &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; para terminaci&amp;oacute;n nula cadenas de caracteres&lt;/a&gt; (que provocan un comportamiento indefinido si el puntero no apunta realmente a dicha cadena), en lugar de &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;la sobrecarga para imprimir el valor del puntero en s&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f98e0f7ef82d28588de46aaf4b7958b9880eea5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer is a non-null pointer that should not be dereferenced.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; , el puntero es un puntero no nulo que no debe ser desreferenciado.</target>
        </trans-unit>
        <trans-unit id="7608858d123991a3d0370b23e31edd9570a303db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer points to a single null character.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; , el puntero apunta a un solo car&amp;aacute;cter nulo.</target>
        </trans-unit>
        <trans-unit id="5881678af232e47a5ff281e340e3ff360633c7fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Si nunca se ha llamado a &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; para este objeto, se devuelve la configuraci&amp;oacute;n regional global en el momento de la llamada. De lo contrario, se devuelve el entorno local pasado a la &amp;uacute;ltima llamada a &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a3196e43b35b6c3a7ee5a0b4c3620496db3d617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; is a null pointer (i.e. there is no associated stream buffer), then &lt;code&gt;state | badbit&lt;/code&gt; is assigned. May throw an exception.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; es un puntero nulo (es decir, no hay un b&amp;uacute;fer de flujo asociado), entonces &lt;code&gt;state | badbit&lt;/code&gt; es asignado. Puede lanzar una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="115f73826b05df3cd915bd8b19cd251d9d51edc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic ostrstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">Si se llam&amp;oacute; a &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; en un ostrstream din&amp;aacute;mico y luego no se llam&amp;oacute; a &lt;a href=&quot;freeze&quot;&gt;congelar (falso)&lt;/a&gt; , este destructor pierde memoria.</target>
        </trans-unit>
        <trans-unit id="bbdbfef825b7d3601eff06aaad9cae9874a72eb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">Si se llam&amp;oacute; a &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; en un flujo din&amp;aacute;mico din&amp;aacute;mico y no se llam&amp;oacute; a &lt;a href=&quot;freeze&quot;&gt;congelar (falso)&lt;/a&gt; despu&amp;eacute;s de eso, este destructor pierde memoria.</target>
        </trans-unit>
        <trans-unit id="478414339a40be92fc6757b885d21490b9c2c06c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">Si se llam&amp;oacute; a &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; en un flujo din&amp;aacute;mico din&amp;aacute;mico y no se llam&amp;oacute; a &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; despu&amp;eacute;s de eso, este destructor pierde memoria.</target>
        </trans-unit>
        <trans-unit id="28514525eb04de0df8ae0bd7f4815fcf5c0b385a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; is false and &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is true, returns &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; es falso y &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; es verdadero, devuelve &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eaf847410a4fe8abec9f71211445a94385c0d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and the copy operation must not throw exceptions</source>
          <target state="translated">Si &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces &lt;code&gt;A&lt;/code&gt; debe satisfacer &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; y la operaci&amp;oacute;n de copia no debe generar excepciones</target>
        </trans-unit>
        <trans-unit id="53014a7b4b50d8ae84406194de8be90fc34e0d34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and the move operation must not throw exceptions.</source>
          <target state="translated">Si &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces &lt;code&gt;A&lt;/code&gt; debe satisfacer &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; y la operaci&amp;oacute;n de mover no debe lanzar excepciones.</target>
        </trans-unit>
        <trans-unit id="39a1f82ebac72503acedbfb5e0cc69d3fea6e2da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lvalues of &lt;code&gt;A&lt;/code&gt; must be &lt;a href=&quot;swappable&quot;&gt;Swappable&lt;/a&gt; and the swap operation must not throw exceptions</source>
          <target state="translated">Si &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , los valores de &lt;code&gt;A&lt;/code&gt; deben ser &lt;a href=&quot;swappable&quot;&gt;intercambiables&lt;/a&gt; y la operaci&amp;oacute;n de intercambio no debe generar excepciones</target>
        </trans-unit>
        <trans-unit id="930ae60370eac3920b61ed4930312cdb72190d0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt;. This effectively requires &lt;code&gt;T&lt;/code&gt; to be move constructible.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , esto llamar&amp;aacute; a ubicaci&amp;oacute;n-nueva, como por &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt; . Esto efectivamente requiere que &lt;code&gt;T&lt;/code&gt; sea ​​movible de forma constructiva.</target>
        </trans-unit>
        <trans-unit id="a6edb79bda8a280ffb6fcbbc9ba3defcf2428641" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , esto llamar&amp;aacute; a ubicaci&amp;oacute;n-nueva, como por &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb858ecd848dc52275e556ff876a7f61bbd34174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; es un tipo de referencia, se reemplaza por el tipo al que se hace referencia</target>
        </trans-unit>
        <trans-unit id="b3c213b81227b94ede964107b48a991995b38510" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, &lt;code&gt;A&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; est&amp;aacute; calificado para cv, &lt;code&gt;A&lt;/code&gt; se reemplaza con una versi&amp;oacute;n no calificada de cv</target>
        </trans-unit>
        <trans-unit id="5d95d66680ab1fe42693574faecc757445aabf8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, the top-level cv-qualifiers are ignored. If &lt;code&gt;A&lt;/code&gt; is a reference type, the referred type is used by deduction.</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; est&amp;aacute; calificado para cv, se ignoran los calificadores de cv de nivel superior. Si &lt;code&gt;A&lt;/code&gt; es un tipo de referencia, el tipo referido se usa por deducci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dbb888d618ec657b4fdce4930acdf4d77c7df288" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was lvalue reference and &lt;code&gt;P&lt;/code&gt; was rvalue reference, A is considered to be more specialized than P</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; era referencia de valor y &lt;code&gt;P&lt;/code&gt; era referencia de valor, A se considera m&amp;aacute;s especializado que P</target>
        </trans-unit>
        <trans-unit id="a0457548dadf8dfad5e452b8705d672e063c513a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was more cv-qualified than &lt;code&gt;P&lt;/code&gt;, A is considered to be more specialized than P</source>
          <target state="translated">Si &lt;code&gt;A&lt;/code&gt; estaba m&amp;aacute;s calificado para cv que &lt;code&gt;P&lt;/code&gt; , A se considera m&amp;aacute;s especializado que P</target>
        </trans-unit>
        <trans-unit id="164bc5f2461c5b557de9ec3b7a0a95d7ca7b6398" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;B&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;std::enable_if&lt;/code&gt; has a public member typedef &lt;code&gt;type&lt;/code&gt;, equal to &lt;code&gt;T&lt;/code&gt;; otherwise, there is no member typedef.</source>
          <target state="translated">Si &lt;code&gt;B&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;std::enable_if&lt;/code&gt; tiene un miembro p&amp;uacute;blico typedef &lt;code&gt;type&lt;/code&gt; , igual a &lt;code&gt;T&lt;/code&gt; ; de lo contrario, no hay miembro typedef.</target>
        </trans-unit>
        <trans-unit id="84997cfae0e3bc373338233f13fc51673ecc94bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is defined, for each constructor (or constructor template) &lt;code&gt;Ci&lt;/code&gt; declared in the named primary template (if it is defined), a fictional function template &lt;code&gt;Fi&lt;/code&gt;, is constructed, such that</source>
          <target state="translated">Si se define &lt;code&gt;C&lt;/code&gt; , para cada constructor (o plantilla de constructor) &lt;code&gt;Ci&lt;/code&gt; declarado en la plantilla primaria nombrada (si est&amp;aacute; definida) , se construye una plantilla de funci&amp;oacute;n ficticia &lt;code&gt;Fi&lt;/code&gt; , de modo que</target>
        </trans-unit>
        <trans-unit id="cc1e774dd0f46e4682b7e19d8770ddcc69c901f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is not defined or does not declare any constructors, an additional fictional function template is added, derived as above from a hypothetical constructor &lt;code&gt;C()&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;C&lt;/code&gt; no est&amp;aacute; definido o no declara ning&amp;uacute;n constructor, se agrega una plantilla de funci&amp;oacute;n ficticia adicional, derivada como anteriormente de un constructor hipot&amp;eacute;tico &lt;code&gt;C()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61f6db7fe67ce601045229a53fee7ef72360c40c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Count&lt;/code&gt; is not &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;;</source>
          <target state="translated">Si &lt;code&gt;Count&lt;/code&gt; no es &lt;code&gt;std::dynamic_extent&lt;/code&gt; , &lt;code&gt;Count&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="e1dc222d7a60755a2201700bb9fa727680a8b6d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type and the second overload is chosen, the program is ill-formed.</source>
          <target state="translated">Si &lt;code&gt;D&lt;/code&gt; es un tipo de referencia y se elige la segunda sobrecarga, el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="f9c0db03f2072cdef42cb4c9c11cc3231d111137" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type, the second overload is defined as deleted. These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. The program is ill-formed if either of these two constructors is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;D&lt;/code&gt; es un tipo de referencia, la segunda sobrecarga se define como eliminada. Estas sobrecargas solo participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; . El programa est&amp;aacute; mal formado si cualquiera de estos dos constructores se selecciona por &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deducci&amp;oacute;n de argumento de plantilla de clase&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6d1f97a0f5c5a0f55060c5fcf0db428c8650e18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, equivalent to &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt;. Otherwise, equivalent to &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;Deleter&lt;/code&gt; es un tipo de referencia, equivalente a &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt; . De lo contrario, equivalente a &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e307062451ff2a7a85e243f182577d712be79ad5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, requires that &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; is nothrow-&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;Deleter&lt;/code&gt; es un tipo de referencia, requiere que &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; sea ​​nothrow- &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="765f5fc1e61e543452d73e1fb0814a6856e4589a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is not a reference type, requires that it is nothrow-&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;Deleter&lt;/code&gt; no es un tipo de referencia, requiere que no se arroje: &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa2f10aa226cd93b28fcf97d03c1ee958d0bbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, such pointer may be used to make &lt;a href=&quot;virtual&quot;&gt;virtual function calls&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;Derived&lt;/code&gt; es &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polim&amp;oacute;rfico&lt;/a&gt; , dicho puntero se puede usar para realizar &lt;a href=&quot;virtual&quot;&gt;llamadas a funciones virtuales&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3aeb6cf5a7fd827d219cf1ec41be16033ed0d80b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is derived from &lt;code&gt;Base&lt;/code&gt; or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Derived&lt;/code&gt; se deriva de &lt;code&gt;Base&lt;/code&gt; o si ambos son la misma clase sin uni&amp;oacute;n (en ambos casos ignorando la calificaci&amp;oacute;n cv), proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ebd268ac27013dab52c304d8fe0d856e345f4dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E2&lt;/code&gt; is not a mutable member, the &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt; of the result is the union of the cv-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;, otherwise (if &lt;code&gt;E2&lt;/code&gt; is a mutable member), it is the union of the volatile-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;;</source>
          <target state="translated">Si &lt;code&gt;E2&lt;/code&gt; no es un miembro mutable, la &lt;a href=&quot;cv&quot;&gt;calificaci&amp;oacute;n cv&lt;/a&gt; del resultado es la uni&amp;oacute;n de las calificaciones cv de &lt;code&gt;E1&lt;/code&gt; y &lt;code&gt;E2&lt;/code&gt; , de lo contrario (si &lt;code&gt;E2&lt;/code&gt; es un miembro mutable), es la uni&amp;oacute;n de las calificaciones vol&amp;aacute;tiles de &lt;code&gt;E1&lt;/code&gt; y &lt;code&gt;E2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="1cf4d112436b803bd3d27d42c800897ab593f0ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; has class type cv &lt;code&gt;T&lt;/code&gt;, then.</source>
          <target state="translated">Si &lt;code&gt;E&lt;/code&gt; en una &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;funci&amp;oacute;n llama a la expresi&amp;oacute;n &lt;/a&gt; &lt;code&gt;E(args)&lt;/code&gt; tiene el tipo de clase cv &lt;code&gt;T&lt;/code&gt; , entonces.</target>
        </trans-unit>
        <trans-unit id="1b8acc70084ea7a5796bb6ffccc7d45f74616a97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; names a set of overloaded functions and/or function templates (but not callable objects), the following rules are followed:</source>
          <target state="translated">Si &lt;code&gt;E&lt;/code&gt; en una &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;expresi&amp;oacute;n de llamada de funci&amp;oacute;n &lt;/a&gt; &lt;code&gt;E(args)&lt;/code&gt; nombra un conjunto de funciones y / o plantillas de funciones sobrecargadas (pero no objetos invocables), se siguen las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="8b40eb284409f27422ea732b684b0f26cb4eef16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; is not a polymorphic class type, or if &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; is an inaccessible or ambiguous base class of &lt;code&gt;E&lt;/code&gt;, there is no effect.</source>
          <target state="translated">Si &lt;code&gt;E&lt;/code&gt; no es un tipo de clase polim&amp;oacute;rfica, o si &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; es una clase base de &lt;code&gt;E&lt;/code&gt; inaccesible o ambigua , no hay ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="cfb9795d2d85864a23dfb415d8a0b25b1a06bb2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; specifies a member function, it may be virtual, in which case the final overrider of that function will be called, using dynamic dispatch at runtime.</source>
          <target state="translated">Si &lt;code&gt;E&lt;/code&gt; especifica una funci&amp;oacute;n miembro, puede ser virtual, en cuyo caso se llamar&amp;aacute; al anulador final de esa funci&amp;oacute;n, utilizando el despacho din&amp;aacute;mico en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7460d26bd30ccf50bedaefeb690ddad0b62aa2b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; exists and names a type, then &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; must be valid and name a type, and &lt;code&gt;Pred&lt;/code&gt; must be either &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; (the program is ill-formed otherwise).</source>
          <target state="translated">Si &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; existe y nombra un tipo, entonces &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; debe ser v&amp;aacute;lido y nombrar un tipo, y &lt;code&gt;Pred&lt;/code&gt; debe ser &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; (el programa est&amp;aacute; enfermo -formado de otra manera).</target>
        </trans-unit>
        <trans-unit id="e746872b3f4a32e36e22866e57c3635973587c0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is an integral type, equivalent to &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;InputIt&lt;/code&gt; es un tipo integral, equivalente a &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="236dbe55a4e3dcd17001ed4b1e01a9528c512d6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is not &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; by (possibly repeatedly) incrementing &lt;code&gt;first&lt;/code&gt;. If &lt;code&gt;InputIt&lt;/code&gt; is &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;first&lt;/code&gt; is not reachable from &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;InputIt&lt;/code&gt; no es &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , el comportamiento es indefinido si no se puede acceder al &lt;code&gt;last&lt;/code&gt; desde el &lt;code&gt;first&lt;/code&gt; (posiblemente repetidamente) increment&amp;aacute;ndolo &lt;code&gt;first&lt;/code&gt; . Si &lt;code&gt;InputIt&lt;/code&gt; es &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , el comportamiento no est&amp;aacute; definido si el &lt;code&gt;last&lt;/code&gt; no es accesible desde el &lt;code&gt;first&lt;/code&gt; y el &lt;code&gt;first&lt;/code&gt; no es accesible desde el &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c4d085e7ff79e59c030b2b8c81a1702c66b3ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, this function rereads the input in order to detect duplicates.</source>
          <target state="translated">Si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , esta funci&amp;oacute;n relee la entrada para detectar duplicados.</target>
        </trans-unit>
        <trans-unit id="c3749207d2ce68de1c41a9f49f0c2035e0f8ee1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have &lt;code&gt;pointer&lt;/code&gt;, but has all other four member types, then the member types are declared as follows:</source>
          <target state="translated">Si &lt;code&gt;Iter&lt;/code&gt; no tiene &lt;code&gt;pointer&lt;/code&gt; , pero tiene los otros cuatro tipos de miembros, los tipos de miembros se declaran de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="2654ba55a6d218cab7ca7778bb155b247c0f52ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have all five member types &lt;code&gt;difference_type&lt;/code&gt;, &lt;code&gt;value_type&lt;/code&gt;, &lt;code&gt;pointer&lt;/code&gt;, &lt;code&gt;reference&lt;/code&gt;, and &lt;code&gt;iterator_category&lt;/code&gt;, then this template has no members by any of those names (&lt;code&gt;std::iterator_traits&lt;/code&gt; is SFINAE-friendly).</source>
          <target state="translated">Si &lt;code&gt;Iter&lt;/code&gt; no tiene los cinco tipos de miembros &lt;code&gt;difference_type&lt;/code&gt; , &lt;code&gt;value_type&lt;/code&gt; , &lt;code&gt;pointer&lt;/code&gt; , &lt;code&gt;reference&lt;/code&gt; e &lt;code&gt;iterator_category&lt;/code&gt; , entonces esta plantilla no tiene miembros con ninguno de esos nombres ( &lt;code&gt;std::iterator_traits&lt;/code&gt; iterator_traits es compatible con SFINAE).</target>
        </trans-unit>
        <trans-unit id="f45e1c1900c90ccc18a25b3d04a0c5ca7a8286f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, the extent of the returned span &lt;code&gt;S&lt;/code&gt; is also &lt;code&gt;std::dynamic_extent&lt;/code&gt;; otherwise it is &lt;code&gt;sizeof(T) * N&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;N&lt;/code&gt; es &lt;code&gt;std::dynamic_extent&lt;/code&gt; , la extensi&amp;oacute;n del intervalo &lt;code&gt;S&lt;/code&gt; devuelto tambi&amp;eacute;n es &lt;code&gt;std::dynamic_extent&lt;/code&gt; ; de lo contrario es &lt;code&gt;sizeof(T) * N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="347ac408b6a94a1c447cd287529327ba6fa3d9ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is defined as a macro name at the point in the source code where &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; is included, then &lt;code&gt;assert&lt;/code&gt; does nothing.</source>
          <target state="translated">Si &lt;code&gt;NDEBUG&lt;/code&gt; se define como un nombre de macro en el punto en el c&amp;oacute;digo fuente, donde &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; se incluye, a continuaci&amp;oacute;n, &lt;code&gt;assert&lt;/code&gt; no hace nada.</target>
        </trans-unit>
        <trans-unit id="f059b210d4e1ce59a4454923ec15e6398050571e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is not defined, then &lt;code&gt;assert&lt;/code&gt; checks if its argument (which must have scalar type) compares equal to zero. If it does, &lt;code&gt;assert&lt;/code&gt; outputs implementation-specific diagnostic information on the standard error output and calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;. The diagnostic information is required to include the text of &lt;code&gt;expression&lt;/code&gt;, as well as the values of the standard macros &lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt;, and the standard variable &lt;code&gt;__func__&lt;/code&gt;(since C++11).</source>
          <target state="translated">Si &lt;code&gt;NDEBUG&lt;/code&gt; no est&amp;aacute; definido, entonces &lt;code&gt;assert&lt;/code&gt; verifica si su argumento (que debe tener un tipo escalar) se compara igual a cero. Si lo hace, &lt;code&gt;assert&lt;/code&gt; la informaci&amp;oacute;n de diagn&amp;oacute;stico espec&amp;iacute;fica de la implementaci&amp;oacute;n de salidas en la salida de error est&amp;aacute;ndar y llama a &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; . La informaci&amp;oacute;n de diagn&amp;oacute;stico es necesaria para incluir el texto de &lt;code&gt;expression&lt;/code&gt; , as&amp;iacute; como los valores de las macros est&amp;aacute;ndar &lt;code&gt;__FILE__&lt;/code&gt; , &lt;code&gt;__LINE__&lt;/code&gt; y la variable est&amp;aacute;ndar &lt;code&gt;__func__&lt;/code&gt; (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="bf81f02b0ae53877b2da220b99b70dbdc5bf8ca4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a function parameter list &lt;code&gt;(T)&lt;/code&gt;, then each parameter &lt;code&gt;P&lt;/code&gt;i from that list is compared with the corresponding argument &lt;code&gt;A&lt;/code&gt;i from &lt;code&gt;A&lt;/code&gt;'s function parameter list. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its declarator is compared with each remaining &lt;code&gt;A&lt;/code&gt;i in the parameter type list of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;P&lt;/code&gt; tiene una de las formas que incluyen una lista de par&amp;aacute;metros de funci&amp;oacute;n &lt;code&gt;(T)&lt;/code&gt; , entonces cada par&amp;aacute;metro &lt;code&gt;P&lt;/code&gt; i de esa lista se compara con el argumento correspondiente &lt;code&gt;A&lt;/code&gt; i de la lista de par&amp;aacute;metros de funci&amp;oacute;n de &lt;code&gt;A&lt;/code&gt; . Si el &amp;uacute;ltimo &lt;code&gt;P&lt;/code&gt; i es una expansi&amp;oacute;n paquete, entonces su declarador se compara con cada restante &lt;code&gt;A&lt;/code&gt; i en la lista tipo de par&amp;aacute;metro de &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03e7b27c0c840fc6ec6677dbe04f78b9c1de1735" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a template parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt;, then each element &lt;code&gt;P&lt;/code&gt;i of that template argument list is matched against the corresponding template argument &lt;code&gt;A&lt;/code&gt;i of its &lt;code&gt;A&lt;/code&gt;. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its pattern is compared against each remaining argument in the template argument list of &lt;code&gt;A&lt;/code&gt;. A trailing parameter pack that is not otherwise deduced, is deduced to an empty parameter pack.</source>
          <target state="translated">Si &lt;code&gt;P&lt;/code&gt; tiene una de las formas que incluyen una lista de par&amp;aacute;metros plantilla &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt; , a continuaci&amp;oacute;n, cada elemento &lt;code&gt;P&lt;/code&gt; i de que la lista de argumentos de plantilla se compara con el correspondiente argumento de plantilla &lt;code&gt;A&lt;/code&gt; i de su &lt;code&gt;A&lt;/code&gt; . Si el &amp;uacute;ltimo &lt;code&gt;P&lt;/code&gt; i es un Disco de expansi&amp;oacute;n, a continuaci&amp;oacute;n, su patr&amp;oacute;n se compara con cada argumento que queda en la lista de argumentos de plantilla &lt;code&gt;A&lt;/code&gt; . Un paquete de par&amp;aacute;metros final que no se deduce de otra manera, se deduce a un paquete de par&amp;aacute;metros vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="0f363934a6c954657e01cc4569036680c0791d2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a function type, pointer to function type, or pointer to member function type and if &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;overloaded_address&quot;&gt;set of overloaded functions&lt;/a&gt; not containing function templates, template argument deduction is attempted with each overload. If only one succeeds, that successful deduction is used. If none or more than one succeeds, the template parameter is non-deduced context (see below):</source>
          <target state="translated">Si &lt;code&gt;P&lt;/code&gt; es un tipo de funci&amp;oacute;n, puntero a tipo de funci&amp;oacute;n o puntero a tipo de funci&amp;oacute;n miembro y si &lt;code&gt;A&lt;/code&gt; es un &lt;a href=&quot;overloaded_address&quot;&gt;conjunto de funciones sobrecargadas que&lt;/a&gt; no contienen plantillas de funci&amp;oacute;n, se intenta la deducci&amp;oacute;n de argumentos de plantilla con cada sobrecarga. Si solo uno tiene &amp;eacute;xito, se utiliza esa deducci&amp;oacute;n exitosa. Si ninguno o m&amp;aacute;s de uno tiene &amp;eacute;xito, el par&amp;aacute;metro de plantilla es un contexto no deducido (ver m&amp;aacute;s abajo):</target>
        </trans-unit>
        <trans-unit id="798c24b5923fa6b7a5b42f42e0bab257c03db984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="translated">Si &lt;code&gt;P&lt;/code&gt; es un tipo de referencia, se reemplaza por el tipo mencionado</target>
        </trans-unit>
        <trans-unit id="000d2698f624166e9817ec6b2bf3be4c6abd2d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is cv-qualified, &lt;code&gt;P&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="translated">Si &lt;code&gt;P&lt;/code&gt; est&amp;aacute; calificado para cv, &lt;code&gt;P&lt;/code&gt; se reemplaza con una versi&amp;oacute;n no calificada de cv</target>
        </trans-unit>
        <trans-unit id="aaad64c2f2873b4fe56c05d24d46c262bd388e7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;State&lt;/code&gt; is trivially copy constructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy constructor. If &lt;code&gt;State&lt;/code&gt; is trivially copy assignable, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy assignment operator. If &lt;code&gt;State&lt;/code&gt; is trivially destructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial destructor.</source>
          <target state="translated">Si &lt;code&gt;State&lt;/code&gt; es trivialmente copiable constructible, &lt;code&gt;fpos&lt;/code&gt; tiene un constructor de copia trivial. Si &lt;code&gt;State&lt;/code&gt; es trivialmente asignable por copia, &lt;code&gt;fpos&lt;/code&gt; tiene un operador de asignaci&amp;oacute;n de copia trivial. Si &lt;code&gt;State&lt;/code&gt; es trivialmente destructible, &lt;code&gt;fpos&lt;/code&gt; tiene un destructor trivial.</target>
        </trans-unit>
        <trans-unit id="8dfc67b9e7a073b3ee7a9cff59bc3b6f0015ab5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both reference types, and the</source>
          <target state="translated">Si &lt;code&gt;T1&lt;/code&gt; y &lt;code&gt;T2&lt;/code&gt; son ambos tipos de referencia, y el</target>
        </trans-unit>
        <trans-unit id="b4afe72a5e507713bb840e388d5e58f8a34204b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both rvalue reference types: if the simple common reference type of &lt;code&gt;T1 &amp;amp;&lt;/code&gt; and &lt;code&gt;T2 &amp;amp;&lt;/code&gt; (determined according to the previous bullet) exists, then let &lt;code&gt;C&lt;/code&gt; denote that type's corresponding rvalue reference type. If &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then the simple common reference type of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T1&lt;/code&gt; y &lt;code&gt;T2&lt;/code&gt; son ambos tipos de referencia de valor r: si existe el tipo de referencia com&amp;uacute;n simple de &lt;code&gt;T1 &amp;amp;&lt;/code&gt; y &lt;code&gt;T2 &amp;amp;&lt;/code&gt; (determinado de acuerdo con la vi&amp;ntilde;eta anterior), entonces &lt;code&gt;C&lt;/code&gt; denote el tipo de referencia de valor r correspondiente de ese tipo. Si &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; , entonces el tipo simple de referencia com&amp;uacute;n de &lt;code&gt;T1&lt;/code&gt; y &lt;code&gt;T2&lt;/code&gt; es &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acc4957d82e8a29ddb9310686f84a5c8e80923c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; (i.e., both are lvalue reference types): their simple common reference type is &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt;, where</source>
          <target state="translated">Si &lt;code&gt;T1&lt;/code&gt; es &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; y &lt;code&gt;T2&lt;/code&gt; es &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; (es decir, ambos son tipos de referencia lvalue): su tipo de referencia com&amp;uacute;n simple es &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt; , donde</target>
        </trans-unit>
        <trans-unit id="08dbf99d80fdb16cd55d43187dd92a8a606edf58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; (the template parameter of &lt;code&gt;shared_ptr&lt;/code&gt;) is an array type &lt;code&gt;U[N]&lt;/code&gt;, &lt;code&gt;idx&lt;/code&gt; must be less than &lt;code&gt;N&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; (el par&amp;aacute;metro de plantilla de &lt;code&gt;shared_ptr&lt;/code&gt; ) es un tipo de matriz &lt;code&gt;U[N]&lt;/code&gt; , &lt;code&gt;idx&lt;/code&gt; debe ser menor que &lt;code&gt;N&lt;/code&gt; ; de lo contrario, el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="76e47a93376f512128c0f4db3b70d51d91d300a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; name the same type (including const/volatile qualifications), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;U&lt;/code&gt; nombran el mismo tipo (incluidas las calificaciones constantes / vol&amp;aacute;tiles), proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38278b1e8c4f34f7f9afed63ddee71b7095445d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; has a member typedef &lt;code&gt;allocator_type&lt;/code&gt; which is convertible from &lt;code&gt;Alloc&lt;/code&gt;or is an alias of &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt;(library fundamentals TS), the member constant &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; tiene un miembro typedef &lt;code&gt;allocator_type&lt;/code&gt; que es convertible de &lt;code&gt;Alloc&lt;/code&gt; o es un alias de &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt; (fundamentos de la biblioteca TS), el &lt;code&gt;value&lt;/code&gt; constante del miembro es &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81aa069be603406651761b390a77246a11143050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, a function type, or an array of unknown bound, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;void&lt;/code&gt; (posiblemente calificado por cv) , un tipo de funci&amp;oacute;n o una matriz de l&amp;iacute;mite desconocido, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf221325f890a6ce6f02bee9daee7fe55c23f701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; and if any two objects of type &lt;code&gt;T&lt;/code&gt; with the same value have the same &lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; y si dos objetos del tipo &lt;code&gt;T&lt;/code&gt; con el mismo valor tienen la misma &lt;a href=&quot;../language/objects&quot;&gt;representaci&amp;oacute;n de objeto&lt;/a&gt; , proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd6768a7a8e61b9b33b46e7ee729a0e3a0f70982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; (that is, a scalar type, a trivially copyable class with a &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, or array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; (es decir, un tipo escalar, una clase trivialmente copiable con un &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;constructor trivial predeterminado&lt;/a&gt; o una matriz de ese tipo / clase, posiblemente calificada por cv), proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1568f85d20b8988df4e7cc3a1520f513dcc3a32c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/derived_class&quot;&gt;derived class&lt;/a&gt; of some base &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;implicitly convertible&lt;/a&gt; to &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt;. The default deleter of the resulting &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; will use &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for &lt;code&gt;B&lt;/code&gt;, leading to &lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;undefined behavior&lt;/a&gt; unless the destructor of &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;. Note that &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; behaves differently: &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; will use the &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for the type &lt;code&gt;T&lt;/code&gt; and the owned object will be deleted correctly even if the destructor of &lt;code&gt;B&lt;/code&gt; is not &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una &lt;a href=&quot;../language/derived_class&quot;&gt;clase derivada&lt;/a&gt; de alguna base &lt;code&gt;B&lt;/code&gt; , entonces &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;impl&amp;iacute;citamente convertible&lt;/a&gt; a &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; . El eliminador predeterminado del &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; resultante utilizar&amp;aacute; la &lt;a href=&quot;new/operator_delete&quot;&gt;eliminaci&amp;oacute;n del operador&lt;/a&gt; para &lt;code&gt;B&lt;/code&gt; , lo que generar&amp;aacute; &lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;un comportamiento indefinido a&lt;/a&gt; menos que el destructor de &lt;code&gt;B&lt;/code&gt; sea &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt; . Tenga en cuenta que &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; comporta de manera diferente: &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; usar&amp;aacute; el &lt;a href=&quot;new/operator_delete&quot;&gt;operador delete&lt;/a&gt; para el tipo &lt;code&gt;T&lt;/code&gt; y el objeto de propiedad se eliminar&amp;aacute; correctamente incluso si el destructor de &lt;code&gt;B&lt;/code&gt; no es &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14d30fb0aa28f637b9fb71d066b29a527b12f2ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;polymorphic class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una &lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;clase polim&amp;oacute;rfica&lt;/a&gt; (es decir, una clase no sindical que declara o hereda al menos una funci&amp;oacute;n virtual), proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f4f4e6212d0ba8a754d82884bd2c1bd59ed77a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/type-id&quot;&gt;scalar type&lt;/a&gt; (that is a possibly cv-qualified &lt;a href=&quot;is_arithmetic&quot;&gt;arithmetic&lt;/a&gt;, pointer, &lt;a href=&quot;is_member_pointer&quot;&gt;pointer to member&lt;/a&gt;, &lt;a href=&quot;../language/enum&quot;&gt;enumeration&lt;/a&gt;, or &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;../language/type-id&quot;&gt;tipo escalar&lt;/a&gt; (es decir, una &lt;a href=&quot;is_arithmetic&quot;&gt;aritm&amp;eacute;tica&lt;/a&gt; , puntero, &lt;a href=&quot;is_member_pointer&quot;&gt;puntero a miembro&lt;/a&gt; , &lt;a href=&quot;../language/enum&quot;&gt;enumeraci&amp;oacute;n&lt;/a&gt; o tipo &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; posiblemente calificado por cv ), proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26b317cff4e6b234d366569c6bab42c37da84e1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt; (&quot;plain old data type&quot;), that is, both trivial and standard-layout, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt; (&quot;tipo de datos antiguo simple&quot;), es decir, tanto el dise&amp;ntilde;o trivial como el est&amp;aacute;ndar, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aabad78089db78755c758b0100bec563037cafec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa4f125d6fcfcc5603d821627566fc4b66114754" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type and the cv-unqualified version of the type of other is &lt;code&gt;T&lt;/code&gt; or a class derived from &lt;code&gt;T&lt;/code&gt;, the &lt;a href=&quot;converting_constructor&quot;&gt;non-explicit constructors&lt;/a&gt; of &lt;code&gt;T&lt;/code&gt; are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de clase y la versi&amp;oacute;n no calificada por cv del tipo de otro es &lt;code&gt;T&lt;/code&gt; o una clase derivada de &lt;code&gt;T&lt;/code&gt; , se examinan los &lt;a href=&quot;converting_constructor&quot;&gt;constructores no expl&amp;iacute;citos&lt;/a&gt; de &lt;code&gt;T&lt;/code&gt; y se selecciona la mejor coincidencia por resoluci&amp;oacute;n de sobrecarga. Luego se llama al constructor para inicializar el objeto.</target>
        </trans-unit>
        <trans-unit id="da7735d51b45c0cf73d900692c844b55829fb21a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type that has no default constructor but has a constructor taking &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; is performed.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de clase que no tiene un constructor predeterminado pero tiene un constructor que toma &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; , se realiza la inicializaci&amp;oacute;n de la&lt;a href=&quot;list_initialization&quot;&gt; lista&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5fd7b67551be2174ad147f6096e9f4d8ec3b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type,</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de clase,</target>
        </trans-unit>
        <trans-unit id="ec4bcfea7a6b88492eb03ffb2367361b716260ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de clase, &lt;code&gt;T&lt;/code&gt; ser&amp;aacute; un tipo completo; de lo contrario, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="896d68960185cda4dfdf0280d92d7ef716c2b80f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, and the cv-unqualified version of the type of other is not &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, or if &lt;code&gt;T&lt;/code&gt; is non-class type, but the type of other is a class type, &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequences&lt;/a&gt; that can convert from the type of other to &lt;code&gt;T&lt;/code&gt; (or to a type derived from T if T is a class type and a conversion function is available) are examined and the best one is selected through overload resolution. The result of the conversion, which is a prvalue temporary(until C++17)prvalue expression(since C++17) if a &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; was used, is then used to &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialize&lt;/a&gt; the object. The last step is usually &lt;a href=&quot;copy_elision&quot;&gt;optimized out&lt;/a&gt; and the result of the conversion is constructed directly in the memory allocated for the target object, but the appropriate constructor (move or copy) is required to be accessible even though it's not used.(until C++17)</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de clase, y la versi&amp;oacute;n no calificada por cv del tipo de otro no es &lt;code&gt;T&lt;/code&gt; o derivada de &lt;code&gt;T&lt;/code&gt; , o si &lt;code&gt;T&lt;/code&gt; es un tipo que no es de clase, pero el tipo de otro es un tipo de clase, &lt;a href=&quot;implicit_cast&quot;&gt;secuencias de conversi&amp;oacute;n definidas por el usuario&lt;/a&gt; que se pueden convertir del tipo de otro a &lt;code&gt;T&lt;/code&gt; (o a un tipo derivado de T si T es un tipo de clase y hay una funci&amp;oacute;n de conversi&amp;oacute;n disponible) se examinan y se selecciona el mejor mediante resoluci&amp;oacute;n de sobrecarga. El resultado de la conversi&amp;oacute;n, que es una expresi&amp;oacute;n prvalue temporal (hasta C ++ 17) prvalue (desde C ++ 17) si se utiliz&amp;oacute; un &lt;a href=&quot;converting_constructor&quot;&gt;constructor de conversi&amp;oacute;n&lt;/a&gt; , se utiliza para &lt;a href=&quot;direct_initialization&quot;&gt;inicializar directamente&lt;/a&gt; el objeto. El &amp;uacute;ltimo paso suele ser&lt;a href=&quot;copy_elision&quot;&gt;optimizado&lt;/a&gt; y el resultado de la conversi&amp;oacute;n se construye directamente en la memoria asignada para el objeto de destino, pero se requiere que el constructor apropiado (mover o copiar) sea accesible aunque no se use (hasta C ++ 17)</target>
        </trans-unit>
        <trans-unit id="d1e8a1503abd79c3951a5fdc99d54970e61781da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class, it</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una clase, es</target>
        </trans-unit>
        <trans-unit id="ed233d36e232baacab8bc15f22e8a539e4afdd7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a complete enumeration type, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names the underlying type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de enumeraci&amp;oacute;n completa, proporciona un miembro de typedef &lt;code&gt;type&lt;/code&gt; que da nombre al tipo subyacente de la &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db0456a21c631678465dcec0933012e0ff80219" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo compuesto (es decir, matriz, funci&amp;oacute;n, puntero de objeto, puntero de funci&amp;oacute;n, puntero de objeto miembro, puntero de funci&amp;oacute;n miembro, referencia, clase, uni&amp;oacute;n o enumeraci&amp;oacute;n, incluidas las variantes calificadas por cv), proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef33179463348172c7683162235f438e5b4d890a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type (that is, &lt;code&gt;const&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo calificado const (es decir, &lt;code&gt;const&lt;/code&gt; o &lt;code&gt;const volatile&lt;/code&gt; ), proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bd5fbe7c6f6fa50f124d44f0d758532e44d5237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type, it must be a class type with a user-provided default constructor.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo calificado const, debe ser un tipo de clase con un constructor predeterminado proporcionado por el usuario.</target>
        </trans-unit>
        <trans-unit id="91f7440ceeb8c74be7fd249bfe485e7779ba5401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a cv-qualified type, its cv-unqualified version is used for the purpose of default-initialization.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo calificado para cv, su versi&amp;oacute;n no calificada para cv se usa con el prop&amp;oacute;sito de inicializaci&amp;oacute;n predeterminada.</target>
        </trans-unit>
        <trans-unit id="e52096d9a275548201e72366e41ec09c171ba7e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a final class (that is, a class declared with the &lt;a href=&quot;../language/final&quot;&gt;final specifier&lt;/a&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una clase final (es decir, una clase declarada con el &lt;a href=&quot;../language/final&quot;&gt;especificador final&lt;/a&gt; ), proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0409542043a949225bfecbaf84bae28f3b1b559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a fundamental type (that is, arithmetic type, &lt;code&gt;void&lt;/code&gt;, or &lt;code&gt;nullptr_t&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo fundamental (es decir, tipo aritm&amp;eacute;tico, &lt;code&gt;void&lt;/code&gt; o &lt;code&gt;nullptr_t&lt;/code&gt; ), proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945c7b712dc29eea2b59cbb88e5b35a7559eb2f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a literal type, then this destructor is a trivial destructor.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo literal, entonces este destructor es un destructor trivial.</target>
        </trans-unit>
        <trans-unit id="64ca21f761a5e7e05def717cd2e2b74081f4cf00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a multidimensional array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una matriz multidimensional de alg&amp;uacute;n tipo &lt;code&gt;X&lt;/code&gt; , proporciona el miembro typedef &lt;code&gt;type&lt;/code&gt; igual a &lt;code&gt;X&lt;/code&gt; , de lo contrario &lt;code&gt;type&lt;/code&gt; es &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b1b0a24554bc1d76e3a383da4b1a44ea0d8546a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-class type, the value contained in the object is produced as the prvalue result. For a class type, this conversion.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo que no es de clase, el valor contenido en el objeto se produce como el resultado prvalue. Para un tipo de clase, esta conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="69946f1172c363138f6dfe6642850f73c0486b56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-union class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de clase no sindical, &lt;code&gt;T&lt;/code&gt; ser&amp;aacute; un tipo completo; de lo contrario, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="81c8d7a5988a6dccdd619ff7a279df533a7a5150" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type (lvalue reference or rvalue reference), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de referencia (referencia de valor o referencia de valor), proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8dafe7774d902eba322cf87364d4aea07d531abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type then &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; is always &lt;code&gt;false&lt;/code&gt;. The proper way to check a potentially-reference type for const-ness is to remove the reference: &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de referencia, entonces &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; siempre es &lt;code&gt;false&lt;/code&gt; . La forma correcta de verificar un tipo de referencia potencial para constancia es eliminar la referencia: &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ea9b4eb9eb04de1f92850f45ff1fddbdaee120f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type, then provides the member typedef &lt;code&gt;type&lt;/code&gt; which is a pointer to the referred type.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de referencia, proporciona el &lt;code&gt;type&lt;/code&gt; typedef miembro que es un puntero al tipo referido.</target>
        </trans-unit>
        <trans-unit id="2563eff1fa56e4b4ac0532f78126ffeeed82a1f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a scalar type, the object's initial value is the integral constant zero &lt;a href=&quot;explicit_cast&quot;&gt;explicitly converted&lt;/a&gt; to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo escalar, el valor inicial del objeto es la constante integral cero &lt;a href=&quot;explicit_cast&quot;&gt;convertido expl&amp;iacute;citamente&lt;/a&gt; a &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87c045c1fc56928cd55cfd53cf91e06e54ae07d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de dise&amp;ntilde;o est&amp;aacute;ndar (es decir, un tipo escalar, una clase de dise&amp;ntilde;o est&amp;aacute;ndar o una matriz de ese tipo / clase, posiblemente calificada por cv), proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b944fcc6217049e07d88eb139271e7fb7cc4f093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a type with a virtual destructor, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo con un destructor virtual, proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4437c61374698795bc2e7b0a725c5aea0e02d36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union type, the first non-static named data member is zero-initialized and all padding is initialized to zero bits.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de uni&amp;oacute;n, el primer miembro de datos con nombre no est&amp;aacute;tico se inicializa a cero y todo el relleno se inicializa a cero bits.</target>
        </trans-unit>
        <trans-unit id="c4e59ca1d67fedc2671ca4bc2d55bea20110e0a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a volatile-qualified type (that is, &lt;code&gt;volatile&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo calificado como vol&amp;aacute;til (es decir, &lt;code&gt;volatile&lt;/code&gt; o &lt;code&gt;const volatile&lt;/code&gt; ), proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="902b6c9678e19fc91eed33a7ee6f68dcf0f1506d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/abstract_class&quot;&gt;abstract class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one pure virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una &lt;a href=&quot;../language/abstract_class&quot;&gt;clase abstracta&lt;/a&gt; (es decir, una clase no sindical que declara o hereda al menos una funci&amp;oacute;n virtual pura), proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec8806b61c0e95ac652393c60f0f6708ecf1e2f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/type-id&quot;&gt;object type&lt;/a&gt; (that is any possibly cv-qualified type other than function, reference, or &lt;code&gt;void&lt;/code&gt; types), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;../language/type-id&quot;&gt;tipo de objeto&lt;/a&gt; (que es cualquier tipo posiblemente calificado por cv que no sea funci&amp;oacute;n, referencia o tipos &lt;code&gt;void&lt;/code&gt; ), proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0fb50089c183d77cfb88879ad7a640e825184ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;, &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt; is performed.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;aggregate_initialization&quot;&gt;tipo &lt;/a&gt;&lt;a href=&quot;aggregate_initialization&quot;&gt;agregado&lt;/a&gt; , se realiza la inicializaci&amp;oacute;n agregada .</target>
        </trans-unit>
        <trans-unit id="aa61f0f59c6b53db0c1c4a6741114952582e2eaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an aggregate type and the initializer list has a single element of the same or derived type (possibly cv-qualified), the object is initialized from that element (by &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; for copy-list-initialization, or by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; for direct-list-initialization).</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo agregado y la lista de inicializaci&amp;oacute;n tiene un solo elemento del mismo tipo o derivado (posiblemente calificado por cv), el objeto se inicializa desde ese elemento (por &lt;a href=&quot;copy_initialization&quot;&gt;inicializaci&amp;oacute;n&lt;/a&gt; de copia para inicializaci&amp;oacute;n de lista de copia, o por &lt;a href=&quot;direct_initialization&quot;&gt;direct- inicializaci&amp;oacute;n&lt;/a&gt; para direct-list-initialization).</target>
        </trans-unit>
        <trans-unit id="689228bd3413da8a5503b4c482886c287f618b2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type (that is, an integral type or a floating-point type) or a &lt;code&gt;cv-qualified&lt;/code&gt; version thereof, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo aritm&amp;eacute;tico (es decir, un tipo integral o un tipo de coma flotante) o una versi&amp;oacute;n &lt;code&gt;cv-qualified&lt;/code&gt; mismo, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbccf0b2c1488a744757cc2db3268bc8b20be41f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the floating-point types and the signed integer types, and in &lt;code&gt;false&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo aritm&amp;eacute;tico, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt; : esto da como resultado &lt;code&gt;true&lt;/code&gt; para los tipos de punto flotante y los tipos enteros con signo, y &lt;code&gt;false&lt;/code&gt; para los tipos enteros sin signo y el tipo &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcba9f80c891b0c1e133e1cb6925e4162b876bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt; and in &lt;code&gt;false&lt;/code&gt; for the signed integer types and the floating-point types.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo aritm&amp;eacute;tico, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt; : esto da como resultado &lt;code&gt;true&lt;/code&gt; para los tipos enteros sin signo y el tipo &lt;code&gt;bool&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; para los tipos enteros con signo y el flotante -tipos de puntos.</target>
        </trans-unit>
        <trans-unit id="c1fc66fc47bed74ebe67e8cc80e0ae9110815b91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if T is a multidimensional array, only the first dimension is removed.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una matriz de alg&amp;uacute;n tipo &lt;code&gt;X&lt;/code&gt; , proporciona el miembro typedef &lt;code&gt;type&lt;/code&gt; igual a &lt;code&gt;X&lt;/code&gt; , de lo contrario &lt;code&gt;type&lt;/code&gt; es &lt;code&gt;T&lt;/code&gt; . Tenga en cuenta que si T es una matriz multidimensional, solo se elimina la primera dimensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="79fca8c3f06baf2e5727ef4a8e28e151e6f0be48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[N]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[N]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. Otherwise, these constructors do not participate in overload resolution if &lt;code&gt;Y*&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz &lt;code&gt;U[N]&lt;/code&gt; , estos constructores no participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;Y(*)[N]&lt;/code&gt; no es convertible a &lt;code&gt;T*&lt;/code&gt; . Si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz &lt;code&gt;U[]&lt;/code&gt; , estos constructores no participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;Y(*)[]&lt;/code&gt; no es convertible a &lt;code&gt;T*&lt;/code&gt; . De lo contrario, estos constructores no participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;Y*&lt;/code&gt; no es convertible a &lt;code&gt;T*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b5f23983416e1c75433eb3c8db868b92738cbbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type,</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz,</target>
        </trans-unit>
        <trans-unit id="40f6a482e9f6bb37f7f795348ce26482a687ee2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of dimensions of the array. For any other type, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual al n&amp;uacute;mero de dimensiones de la matriz. Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es 0.</target>
        </trans-unit>
        <trans-unit id="50b11c4cc0a3bc2aa8bbbd2ffae9d6dac98f5145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of elements along the &lt;code&gt;N&lt;/code&gt;th dimension of the array, if &lt;code&gt;N&lt;/code&gt; is in &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt;. For any other type, or if &lt;code&gt;T&lt;/code&gt; is array of unknown bound along its first dimension and &lt;code&gt;N&lt;/code&gt; is 0, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz, proporciona la constante de miembro de &lt;code&gt;value&lt;/code&gt; igual al n&amp;uacute;mero de elementos a lo largo de la &lt;code&gt;N&lt;/code&gt; &amp;ordm; dimensi&amp;oacute;n de la matriz, si &lt;code&gt;N&lt;/code&gt; es en &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt; . Para cualquier otro tipo, o si &lt;code&gt;T&lt;/code&gt; es una matriz de l&amp;iacute;mite desconocido a lo largo de su primera dimensi&amp;oacute;n y &lt;code&gt;N&lt;/code&gt; es 0, el &lt;code&gt;value&lt;/code&gt; es 0.</target>
        </trans-unit>
        <trans-unit id="d418fb8b71e5b3d9f326ce97a54075d08f82dec3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo vac&amp;iacute;o (es decir, un tipo de clase sin uni&amp;oacute;n sin miembros de datos no est&amp;aacute;ticos que no sean campos de bits de tama&amp;ntilde;o 0, sin funciones virtuales, sin clases base virtuales y sin clases base no vac&amp;iacute;as), proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="615ee340215311c44d8a0200015cab668b08669e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error code enumeration, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una enumeraci&amp;oacute;n de c&amp;oacute;digo de error, esta plantilla proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f00d4c8f60284c8e8a5d4214a2b023ed99513026" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error condition enum, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es una condici&amp;oacute;n de error enum, esta plantilla proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64661dfb24aa2b41c7a58f86cc3e8e06dff1cc46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the signed integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de enumeraci&amp;oacute;n integral (excepto bool), proporciona el &lt;code&gt;type&lt;/code&gt; typedef del miembro, que es el tipo entero con signo correspondiente a &lt;code&gt;T&lt;/code&gt; , con los mismos calificadores cv.</target>
        </trans-unit>
        <trans-unit id="f9f1f9d4a2f0ac4a591a53f86518618b379c091c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the unsigned integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers. The unsigned integer type corresponding to an enumeration type is the unsigned integer type with the smallest &lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;rank&lt;/a&gt; having the same &lt;code&gt;sizeof&lt;/code&gt; as the enumeration.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de enumeraci&amp;oacute;n integral (excepto bool), proporciona el &lt;code&gt;type&lt;/code&gt; typedef del miembro, que es el tipo entero sin signo correspondiente a &lt;code&gt;T&lt;/code&gt; , con los mismos calificadores cv. El tipo entero sin signo correspondiente a un tipo de enumeraci&amp;oacute;n es el tipo entero sin signo con el &lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;rango&lt;/a&gt; m&amp;aacute;s peque&amp;ntilde;o que tiene el mismo &lt;code&gt;sizeof&lt;/code&gt; que la enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c91459dde93fa1a39419b8fda3571b1d3f2524ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an non-union class type, all base classes and non-static data members are zero-initialized, and all padding is initialized to zero bits. The constructors, if any, are ignored.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de clase sin uni&amp;oacute;n, todas las clases base y los miembros de datos no est&amp;aacute;ticos se inicializan en cero y todo el relleno se inicializa en cero bits. Los constructores, si los hay, son ignorados.</target>
        </trans-unit>
        <trans-unit id="c1d5d737127c3f29b041ec54c37e9b91100e0f8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an object type, then, for the type &lt;code&gt;U&lt;/code&gt; equal &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, if the expression &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; is well-formed in unevaluated context, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de objeto, entonces, para el tipo &lt;code&gt;U&lt;/code&gt; igual &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; , si la expresi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; est&amp;aacute; bien formada en contexto no evaluado, &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c22afe114b35ac81cf800a1156d7baffcb6d3c14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is array type, each element is zero-initialized</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es de tipo matriz, cada elemento est&amp;aacute; inicializado en cero</target>
        </trans-unit>
        <trans-unit id="dea68d51090e5d0f319644a92de20fb3d9b95d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the program that specializes &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; is ill-formed.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; no es &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , el programa que se especializa en &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="73b3d58d3922df960693448a6c809c6309de2344" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not a standard placeholder type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; no es un tipo de marcador de posici&amp;oacute;n est&amp;aacute;ndar, esta plantilla se deriva de &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ee1c8ebae98c21b02f68dd05886f8fe92f20e99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not const-qualified, then &lt;code&gt;rv&lt;/code&gt;'s resulting state (after the definition/expression is evaluated in either bullets above) is valid but unspecified; otherwise, it is unchanged.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; no est&amp;aacute; calificado const, entonces el estado resultante de &lt;code&gt;rv&lt;/code&gt; (despu&amp;eacute;s de evaluar la definici&amp;oacute;n / expresi&amp;oacute;n en cualquiera de los puntos anteriores) es v&amp;aacute;lido pero no especificado; de lo contrario, no ha cambiado.</target>
        </trans-unit>
        <trans-unit id="615bba93f7cf789b20b52441a5845c09300784e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is pointer to non-static member object or a pointer to non-static member function, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un puntero a un objeto miembro no est&amp;aacute;tico o un puntero a una funci&amp;oacute;n miembro no est&amp;aacute;tico, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5ac84ccbccc9198a7ab09ce3b026f6c47e5ff46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is reference type, nothing is done.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es un tipo de referencia, no se hace nada.</target>
        </trans-unit>
        <trans-unit id="2f854a51cba2ddf3f5cc88ad123c5f24a105a0f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type of a standard placeholder (_1, _2, _3, ...), then this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es el tipo de un marcador de posici&amp;oacute;n est&amp;aacute;ndar (_1, _2, _3, ...), entonces esta plantilla se deriva de &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="f81cf7e82856e3e7cad5504cd15ee27f838ea825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type produced by a call to &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;. For any other type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es el tipo producido por una llamada a &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; , esta plantilla se deriva de &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; . Para cualquier otro tipo, esta plantilla se deriva de &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51e3546d16456aa08a11e4cc71a3bbf5dec35bfe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is trivially-destructible, then this destructor is also trivial, so &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; is also trivially-destructible.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; es trivialmente destructible, entonces este destructor tambi&amp;eacute;n es trivial, por lo que el &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; tambi&amp;eacute;n es trivialmente destructible.</target>
        </trans-unit>
        <trans-unit id="d31c04866aa7a4ef595b5ddda4f6ba3e2b023b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; models &lt;a href=&quot;../concepts/defaultconstructible&quot;&gt;&lt;code&gt;DefaultConstructible&lt;/code&gt;&lt;/a&gt;, the default constructor of &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; constructs a semiregular wrapper containing a value-initialized &lt;code&gt;T&lt;/code&gt; and is equivalent to:</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; modelos &lt;a href=&quot;../concepts/defaultconstructible&quot;&gt; &lt;code&gt;DefaultConstructible&lt;/code&gt; &lt;/a&gt; , el constructor predeterminado de &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; constructos un semirregular envoltura que contiene un valor-inicializado &lt;code&gt;T&lt;/code&gt; y es equivalente a:</target>
        </trans-unit>
        <trans-unit id="02a86ca705d443044b0fbfb7fbc9ab041d9a2f6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; names the type &quot;array of &lt;code&gt;U&lt;/code&gt;&quot; or &quot;reference to array of &lt;code&gt;U&lt;/code&gt;&quot;, the member typedef &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;U*&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; nombra el tipo &quot;matriz de &lt;code&gt;U&lt;/code&gt; &quot; o &quot;referencia a la matriz de &lt;code&gt;U&lt;/code&gt; &quot;, el &lt;code&gt;type&lt;/code&gt; definici&amp;oacute;n de miembro es &lt;code&gt;U*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c2891f9d56d7ae3301606af512c7f8ffc24cd7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; satisface todos los requisitos de &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; , proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac1553fe834dd9a1efb1dfce83c0e4902b9cd37a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T&lt;/code&gt; satisface los requisitos del &lt;a href=&quot;../named_req/clock&quot;&gt;reloj&lt;/a&gt; , proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c87275ecad38359126e4f40cf9ccd9918c5e81e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">Si el constructor de movimientos de &lt;code&gt;T&lt;/code&gt; no es &lt;code&gt;noexcept&lt;/code&gt; y T no es &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; en &lt;code&gt;*this&lt;/code&gt; , vector usar&amp;aacute; el constructor de movimientos de lanzamiento. Si arroja, se renuncia a la garant&amp;iacute;a y los efectos no se especifican.</target>
        </trans-unit>
        <trans-unit id="407149e5ef249263ab827511e7e341fc16d6fcf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T_i&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; is also &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;T_i&lt;/code&gt; es (posiblemente calificado por cv) &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;F(T_i)&lt;/code&gt; solo se considera si &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; tambi&amp;eacute;n es &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4907a3ab559108aaf0ecc4b4c630266b6c2f7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;V&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed. If &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed unless the implementation yields correct values for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;U&lt;/code&gt; o &lt;code&gt;V&lt;/code&gt; no son representables en &lt;code&gt;std::intmax_t&lt;/code&gt; , el programa est&amp;aacute; mal formado. Si &lt;code&gt;Num&lt;/code&gt; o &lt;code&gt;Denom&lt;/code&gt; no es representable en &lt;code&gt;std::intmax_t&lt;/code&gt; , el programa est&amp;aacute; mal formada a menos que la aplicaci&amp;oacute;n da valores correctos para &lt;code&gt;U&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1339288b4eceede884dbe475de639d7a8e96920b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="translated">Si &lt;code&gt;X&lt;/code&gt; no reconoce el asignador, el t&amp;eacute;rmino se define como si &lt;code&gt;A&lt;/code&gt; fuera &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , excepto que no es necesario crear ning&amp;uacute;n objeto asignador y las especializaciones definidas por el usuario de &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; no se instancian.</target>
        </trans-unit>
        <trans-unit id="e215c6bfa230a8fadbd8fa567ff0d1dcc73d9d4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="translated">Si &lt;code&gt;X&lt;/code&gt; no reconoce el asignador, el t&amp;eacute;rmino se define como si &lt;code&gt;A&lt;/code&gt; fuera &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt; , excepto que no es necesario crear ning&amp;uacute;n objeto asignador y las especializaciones definidas por el usuario de &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; no se instancian.</target>
        </trans-unit>
        <trans-unit id="708924c7b6f5980aac166862125db725c9025582" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty or if no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;[s_first, s_last)&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o o si no se encuentra dicha secuencia, se devuelve el &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4de674a59bdc38a4524989e3aa936059b297e948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty, &lt;code&gt;first&lt;/code&gt; is returned. (since C++11)</source>
          <target state="translated">Si &lt;code&gt;[s_first, s_last)&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, &lt;code&gt;first&lt;/code&gt; se devuelve. (desde C ++ 11)</target>
        </trans-unit>
        <trans-unit id="ac8a7837d00559195769abe3422b2d4b64b0803f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; and &lt;code&gt;b &amp;lt; c&lt;/code&gt; then &lt;code&gt;a &amp;lt; c&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;a &amp;lt; b&lt;/code&gt; y &lt;code&gt;b &amp;lt; c&lt;/code&gt; entonces &lt;code&gt;a &amp;lt; c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0fbd3756fc442152ea5c157999e136ae32a5c4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; then &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;a &amp;lt; b&lt;/code&gt; entonces &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca13a23e17308315822746f838d58d67fdc10969" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;b == c&lt;/code&gt;, then &lt;code&gt;a == c&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;a == b&lt;/code&gt; y &lt;code&gt;b == c&lt;/code&gt; , a continuaci&amp;oacute;n, &lt;code&gt;a == c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57b477a3ad052ca87058c8d285998bd3826578b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="translated">Si &lt;code&gt;a == b&lt;/code&gt; , las llamadas posteriores a la sobrecarga del &lt;a href=&quot;operator()&quot;&gt; &lt;code&gt;operator()&lt;/code&gt; &lt;/a&gt; que no acepta un objeto &lt;code&gt;param_type&lt;/code&gt; causar&amp;aacute;n un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="058ec9eda946d2f87a4c67ddd844abb0705335fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, then &lt;code&gt;b == a&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;a == b&lt;/code&gt; , entonces &lt;code&gt;b == a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e95c4991d153eb49fcdeb67a49f232435c188d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; compare equal (&lt;code&gt;a == b&lt;/code&gt; is contextually convertible to &lt;code&gt;true&lt;/code&gt;) then either they are both non-dereferenceable or &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; are references bound to the same object</source>
          <target state="translated">Si &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; se comparan igual ( &lt;code&gt;a == b&lt;/code&gt; es contextualmente convertible a &lt;code&gt;true&lt;/code&gt; ), entonces ambos no son desreferenciables o &lt;code&gt;*a&lt;/code&gt; y &lt;code&gt;*b&lt;/code&gt; son referencias vinculadas al mismo objeto</target>
        </trans-unit>
        <trans-unit id="b0965a7f22c182c2dc94b342ec734afedbfb197f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and Stage 1 representation began with 0x or 0X, will pad after the x or X</source>
          <target state="translated">Si &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; y la representaci&amp;oacute;n de la Etapa 1 comenz&amp;oacute; con 0x o 0X, se rellenar&amp;aacute; despu&amp;eacute;s de x o X</target>
        </trans-unit>
        <trans-unit id="55fb07ae63090e46c1b31757c60deb3993a02ead" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and a sign character occurs in the representation, will pad after the sign</source>
          <target state="translated">Si &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; y aparece un car&amp;aacute;cter de signo en la representaci&amp;oacute;n, se rellenar&amp;aacute; despu&amp;eacute;s del signo</target>
        </trans-unit>
        <trans-unit id="df7f9cf85073b22f00c706bbf069fde1413ff653" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, will pad after</source>
          <target state="translated">Si &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; , se rellenar&amp;aacute; despu&amp;eacute;s</target>
        </trans-unit>
        <trans-unit id="efe26e828a675b79b7ef6061fde6939469a2c778" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt;, will pad before</source>
          <target state="translated">Si &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt; , se rellenar&amp;aacute; antes</target>
        </trans-unit>
        <trans-unit id="6ee5eea45cb84fb94f59a5848a1a90638eee5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alignof(T)&lt;/code&gt; is not a valid expression, the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;alignof(T)&lt;/code&gt; no es una expresi&amp;oacute;n v&amp;aacute;lida, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="39035be25eaa7a5daa7ee9badf8db195c8f6f1c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es &amp;plusmn; &amp;infin;, se devuelve + &amp;infin;</target>
        </trans-unit>
        <trans-unit id="dc64028dd5e1343ad289a2a638ecad4eabe7dfc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es &amp;plusmn; &amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; se eleva y se devuelve un valor definido por la implementaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="212c6a1d0fbeb2a948b299caf94641bec455cf7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned unmodified</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es &amp;plusmn; &amp;infin;, se devuelve sin modificar</target>
        </trans-unit>
        <trans-unit id="3af634b2f314cdb14e21e2e232aa0d848e98f5e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es &amp;plusmn; &amp;infin;, se devuelve y se almacena un valor no especificado en &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2926296a9d3ae122af29b30e2bff2458387535b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es &amp;plusmn; &amp;infin;, se devuelve, sin modificar</target>
        </trans-unit>
        <trans-unit id="dcb585953813ddfd53495aac0adc0c6028656a9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;&amp;infin;, or NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es &amp;plusmn; 0, &amp;plusmn; &amp;infin; o NaN, se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97a7ce4796bb66aaa2d696b735ad8ca62a0d506b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es &amp;plusmn; 0, se devuelve -&amp;infin; y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c925fdb14d37c5af0412f43389d6420fcbebc31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es &amp;plusmn; 0, se devuelve, sin modificar</target>
        </trans-unit>
        <trans-unit id="b763f3ae25fa4af1639d7559710e6c7dfb77bb58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified, and &lt;code&gt;0&lt;/code&gt; is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es &amp;plusmn; 0, se devuelve, sin modificar, y &lt;code&gt;0&lt;/code&gt; se almacena en &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f109ac78880a8e0fd5ca3edc07d2d1bf947af61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es NaN, se &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; se devuelve un valor definido por la implementaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="40f86add69087dfb700cacff3b1846927488c73a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es NaN, se devuelve NaN</target>
        </trans-unit>
        <trans-unit id="5f68328ad47978170da252aebc348fd2a3ba01b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es NaN, se devuelve NaN y se almacena un valor no especificado en &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b0e2c569c27377f09ed2aa7f3f01ddd8ab82ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es NaN, se devuelve NaN.</target>
        </trans-unit>
        <trans-unit id="b47b8c75e53c96b45595a288fa682cfb71c94c2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es un NaN, se devuelve &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="103047025bbc6992cc2c0159391152d1cac0b073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::lgamma(arg)&lt;/code&gt; is the logarithm of the factorial of &lt;code&gt;arg-1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es un n&amp;uacute;mero natural, &lt;code&gt;std::lgamma(arg)&lt;/code&gt; es el logaritmo del factorial de &lt;code&gt;arg-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d43e3c2f39b7c1f66e9428682a4d9539c507a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::tgamma(arg)&lt;/code&gt; is the factorial of &lt;code&gt;arg-1&lt;/code&gt;. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es un n&amp;uacute;mero natural, &lt;code&gt;std::tgamma(arg)&lt;/code&gt; es el factorial de &lt;code&gt;arg-1&lt;/code&gt; . Muchas implementaciones calculan el factorial de dominio entero exacto si el argumento es un entero suficientemente peque&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="2b3d194b382b4cec828f1996e8820c92fc1bc82f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is infinite, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es infinito, se devuelve &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e168df92098d4104c20f40ff2c56e9cb3e43970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not a floating-point number, the behavior is unspecified.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; no es un n&amp;uacute;mero de coma flotante, el comportamiento no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="2804f0355d48777b9700b17ec3da3dcca55d9469" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not zero, infinite, or NaN, the value returned is exactly equivalent to &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; no es cero, infinito o NaN, el valor devuelto es exactamente equivalente a &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="210d2992bbf2bb7d542ddc01b1a18747c781302a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error may occur.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es cero o es un n&amp;uacute;mero entero menor que cero, puede ocurrir un error de polo.</target>
        </trans-unit>
        <trans-unit id="05dafa4d596b7b6f157f2afaee02072f8d977259" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error or a domain error may occur.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es cero o es un entero menor que cero, puede ocurrir un error de polo o un error de dominio.</target>
        </trans-unit>
        <trans-unit id="c39db051a1df2187c97bcf9b3a8feca13bc7aae3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, &lt;code&gt;FP_ILOGB0&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es cero, se devuelve &lt;code&gt;FP_ILOGB0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4481c06a081e138b96375d6a39a2024c3db3720a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, returns zero and stores zero in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;arg&lt;/code&gt; es cero, devuelve cero y almacena cero en &lt;code&gt;*exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="277ca8d97ddf64738fdbd1aa4e973cb1bc8ff33f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is true, the returned bitmask is suitable for matching characters without regard to their case.</source>
          <target state="translated">Si &lt;code&gt;b&lt;/code&gt; es verdadero, la m&amp;aacute;scara de bits devuelta es adecuada para la coincidencia de caracteres sin tener en cuenta su caso.</target>
        </trans-unit>
        <trans-unit id="bc2ce27f23e51347316eec1df499f96102e63b30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;TIME_UTC&lt;/code&gt;, then.</source>
          <target state="translated">Si la &lt;code&gt;base&lt;/code&gt; es &lt;code&gt;TIME_UTC&lt;/code&gt; , entonces.</target>
        </trans-unit>
        <trans-unit id="39772be1360347ea75162c3cf41cc79a0690aefc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exp&lt;/code&gt; is finite and non-integer, a domain error occurs and a range error may occur.</source>
          <target state="translated">Si &lt;code&gt;base&lt;/code&gt; es finito y negativo y &lt;code&gt;exp&lt;/code&gt; es finito y no entero, se produce un error de dominio y puede ocurrir un error de rango.</target>
        </trans-unit>
        <trans-unit id="fcb4bb9772be34cee0a2ea72f8a48a52aed0d515" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is negative, a domain error or a pole error may occur.</source>
          <target state="translated">Si &lt;code&gt;base&lt;/code&gt; es cero y &lt;code&gt;exp&lt;/code&gt; es negativo, puede ocurrir un error de dominio o un error de polo.</target>
        </trans-unit>
        <trans-unit id="8cefb315066ca34b099a440410777215c4c88531" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is zero, a domain error may occur.</source>
          <target state="translated">Si &lt;code&gt;base&lt;/code&gt; es cero y &lt;code&gt;exp&lt;/code&gt; es cero, puede ocurrir un error de dominio.</target>
        </trans-unit>
        <trans-unit id="735a9c2b9ccda41b360b2ccc955e4ce336eebbf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == 0&lt;/code&gt;, will use conversion specifier &lt;code&gt;%i&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;basefield == 0&lt;/code&gt; , usar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72b1b1221364073e1a83ddb04c69595be539a496" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%x&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt; , usar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4a2fc2012f6b4718df5c8bbc44f6bc3ac7c622d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex&lt;/code&gt;, will use conversion specifier &lt;code&gt;%X&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;basefield == hex&lt;/code&gt; , usar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abc0fd7910d8386906f231979d946d3d6fcf720b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == oct&lt;/code&gt;, will use conversion specifier &lt;code&gt;%o&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;basefield == oct&lt;/code&gt; , usar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%o&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dafca5cc04b66da6cecdcb0541cbba62d4fe3fca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;begin == end&lt;/code&gt;, do nothing. Otherwise,</source>
          <target state="translated">Si &lt;code&gt;begin == end&lt;/code&gt; , no hacer nada. De otra manera,</target>
        </trans-unit>
        <trans-unit id="bc82eb0dcae0fc58deeb2027018fdeadab408395" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; and &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Si &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; y &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; son &lt;code&gt;true&lt;/code&gt; , entonces &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0c3b57cf400e324fc93a37880e317b6a3f4e7284" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha != 0&lt;/code&gt; obtains &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; if &lt;code&gt;v == true&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; if &lt;code&gt;v == false&lt;/code&gt;, and outputs each successive character &lt;code&gt;c&lt;/code&gt; of that string to &lt;code&gt;out&lt;/code&gt; with &lt;code&gt;*out++ = c&lt;/code&gt;. No further processing is done in this case, the function returns &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;boolalpha != 0&lt;/code&gt; obtiene &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; si &lt;code&gt;v == true&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; si &lt;code&gt;v == false&lt;/code&gt; , y genera cada car&amp;aacute;cter sucesivo &lt;code&gt;c&lt;/code&gt; de esa cadena para &lt;code&gt;out&lt;/code&gt; con &lt;code&gt;*out++ = c&lt;/code&gt; . La transformaci&amp;oacute;n posterior no se hace en este caso, la funci&amp;oacute;n devuelve &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="209116e8fd40fdecd41f59a58ba5cba05cc96e2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha == 0&lt;/code&gt;, then converts &lt;code&gt;v&lt;/code&gt; to type &lt;code&gt;int&lt;/code&gt; and performs integer output.</source>
          <target state="translated">Si &lt;code&gt;boolalpha == 0&lt;/code&gt; , convierte &lt;code&gt;v&lt;/code&gt; para escribir &lt;code&gt;int&lt;/code&gt; y realiza una salida entera.</target>
        </trans-unit>
        <trans-unit id="701f5d02367a24c659b0e907a89da5f3ee588ad7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is a null pointer, resizes the internal buffer to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">Si el &lt;code&gt;buffer&lt;/code&gt; es un puntero nulo, cambia el tama&amp;ntilde;o del b&amp;uacute;fer interno a su &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb7a30a4993475e7a73929ac360a9b27b0b3f966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not a null pointer, instructs the stream to use the user-provided buffer of size &lt;code&gt;size&lt;/code&gt; beginning at &lt;code&gt;buffer&lt;/code&gt;. The stream must be closed (with &lt;code&gt;fclose&lt;/code&gt;) before the &lt;a href=&quot;../../language/lifetime&quot;&gt;lifetime&lt;/a&gt; of the array pointed to by &lt;code&gt;buffer&lt;/code&gt; ends. The contents of the array after a successful call to &lt;code&gt;setvbuf&lt;/code&gt; are indeterminate and any attempt to use it is undefined behavior.</source>
          <target state="translated">Si &lt;code&gt;buffer&lt;/code&gt; no es un puntero nulo, encarga al corriente de usar el tamp&amp;oacute;n proporcionado por el usuario del tama&amp;ntilde;o &lt;code&gt;size&lt;/code&gt; comienzo al &lt;code&gt;buffer&lt;/code&gt; . La secuencia debe estar cerrada (con &lt;code&gt;fclose&lt;/code&gt; ) antes de que finalice la &lt;a href=&quot;../../language/lifetime&quot;&gt;vida &amp;uacute;til&lt;/a&gt; de la matriz a la que apunta el &lt;code&gt;buffer&lt;/code&gt; . El contenido de la matriz despu&amp;eacute;s de una llamada exitosa a &lt;code&gt;setvbuf&lt;/code&gt; es indeterminado y cualquier intento de usarlo es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="a4aa2a51ab02bfef78d16d2394217fe58c759175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Si el &lt;code&gt;buffer&lt;/code&gt; no es nulo, equivalente a &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fda3355283db2eca141b2739a1e7b6dba9c66231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt;, which turns off buffering.</source>
          <target state="translated">Si el &lt;code&gt;buffer&lt;/code&gt; es nulo, equivalente a &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt; , que desactiva el b&amp;uacute;fer.</target>
        </trans-unit>
        <trans-unit id="4dd6d32ffac07b48320fad08007c3cbc378f1ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">Si &lt;code&gt;c16&lt;/code&gt; no es la unidad de c&amp;oacute;digo final en una representaci&amp;oacute;n de 16 bits de un car&amp;aacute;cter ancho, no escribe en la matriz a la que apunta &lt;code&gt;s&lt;/code&gt; , solo se actualiza &lt;code&gt;*ps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43266a7e25edde20659efab6eb44b99980e95ed3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is invalid (does not contribute to a sequence of &lt;code&gt;char8_t&lt;/code&gt; corresponding to a valid multibyte character), the value of the macro &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; is stored in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;(size_t)(-1)&lt;/code&gt; is returned, and the conversion state is unspecified.</source>
          <target state="translated">Si &lt;code&gt;c8&lt;/code&gt; no es v&amp;aacute;lido (no contribuye a una secuencia de &lt;code&gt;char8_t&lt;/code&gt; correspondiente a un car&amp;aacute;cter multibyte v&amp;aacute;lido), el valor de la macro &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; se almacena en &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; , se devuelve &lt;code&gt;(size_t)(-1)&lt;/code&gt; y el estado de conversi&amp;oacute;n no se especifica.</target>
        </trans-unit>
        <trans-unit id="120e5087c8f2519bdf8d8babc3ba6bf88d5575b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is not the final UTF-8 code unit in a representation of a code point, the function does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">Si &lt;code&gt;c8&lt;/code&gt; no es la unidad de c&amp;oacute;digo UTF-8 final en una representaci&amp;oacute;n de un punto de c&amp;oacute;digo, la funci&amp;oacute;n no escribe en la matriz a la que apunta &lt;code&gt;s&lt;/code&gt; , solo se actualiza &lt;code&gt;*ps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2b9d98d74c329c422daa370d8349ea12b339fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is the null character &lt;code&gt;u8'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Si &lt;code&gt;c8&lt;/code&gt; es el car&amp;aacute;cter nulo &lt;code&gt;u8'\0'&lt;/code&gt; , se almacena un byte nulo, precedido por cualquier secuencia de cambio necesaria para restaurar el estado de cambio inicial y el par&amp;aacute;metro del estado de conversi&amp;oacute;n &lt;code&gt;*ps&lt;/code&gt; se actualiza para representar el estado de cambio inicial.</target>
        </trans-unit>
        <trans-unit id="9b496091b9a18ce0c88a971b0705f925544a2dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is the end-of-file indicator (&lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt;), then there is no character to append. The function does nothing and returns an unspecified value other than &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;c&lt;/code&gt; es el indicador de fin de archivo ( &lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt; ), entonces no hay ning&amp;uacute;n car&amp;aacute;cter para agregar. La funci&amp;oacute;n no hace nada y devuelve un valor no especificado que no sea &lt;code&gt;traits::eof()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d45180121f410762cee0225f3231172974d6d196" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, returns some value other than &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;. Otherwise, returns &lt;code&gt;(unsigned char)(c)&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">Si &lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; , devuelve alg&amp;uacute;n valor distinto de &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;(unsigned char)(c)&lt;/code&gt; en caso de &amp;eacute;xito, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="6b94f81efb67c916047d31de0fff924013dd49d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, pushes the character &lt;code&gt;ch&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that character. The external device associated with the stream is not modified.</source>
          <target state="translated">Si &lt;code&gt;ch&lt;/code&gt; no es igual a &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; , empuja el car&amp;aacute;cter &lt;code&gt;ch&lt;/code&gt; (reinterpretado como &lt;code&gt;unsigned char&lt;/code&gt; ) en el b&amp;uacute;fer de entrada asociado con la secuencia de &lt;code&gt;stream&lt;/code&gt; de manera que la operaci&amp;oacute;n de lectura posterior de la &lt;code&gt;stream&lt;/code&gt; recupere ese car&amp;aacute;cter. El dispositivo externo asociado con la secuencia no se modifica.</target>
        </trans-unit>
        <trans-unit id="d30189f2e98ef3c7b1c57bfc6a779e2cf97492e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;WEOF&lt;/code&gt;, pushes the wide character &lt;code&gt;ch&lt;/code&gt; into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that wide character. The external device associated with the stream is not modified.</source>
          <target state="translated">Si &lt;code&gt;ch&lt;/code&gt; no es igual a &lt;code&gt;WEOF&lt;/code&gt; , inserta el car&amp;aacute;cter ancho &lt;code&gt;ch&lt;/code&gt; en el b&amp;uacute;fer de entrada asociado con la secuencia de &lt;code&gt;stream&lt;/code&gt; de tal manera que la operaci&amp;oacute;n de lectura posterior de la &lt;code&gt;stream&lt;/code&gt; recuperar&amp;aacute; ese car&amp;aacute;cter ancho. El dispositivo externo asociado con la secuencia no se modifica.</target>
        </trans-unit>
        <trans-unit id="f9dcd2adfbf165acf0dba129b8151a07f338a6fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">Si &lt;code&gt;ch&lt;/code&gt; es igual a &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; , la operaci&amp;oacute;n falla y la secuencia no se ve afectada.</target>
        </trans-unit>
        <trans-unit id="6a114914a7e8a31a9eee7e4f7ac5bc1b503807f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;WEOF&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">Si &lt;code&gt;ch&lt;/code&gt; es igual a &lt;code&gt;WEOF&lt;/code&gt; , la operaci&amp;oacute;n falla y la secuencia no se ve afectada.</target>
        </trans-unit>
        <trans-unit id="eb3d10516cbec80af986272f9e48f6efa09dd2d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;command&lt;/code&gt; is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">Si el &lt;code&gt;command&lt;/code&gt; es un puntero nulo, verifica si el entorno host tiene un procesador de comando y devuelve un valor distinto de cero si y solo si el procesador de comando existe.</target>
        </trans-unit>
        <trans-unit id="85aea9f0ae028fe2640a672d5e277a7841d76dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp(a,b)==true&lt;/code&gt; then &lt;code&gt;comp(b,a)==false&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;comp(a,b)==true&lt;/code&gt; entonces &lt;code&gt;comp(b,a)==false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f7a074b5aca822ff123427c78123491180762d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp&lt;/code&gt; indicates two elements as equivalent, their order is unspecified.</source>
          <target state="translated">Si &lt;code&gt;comp&lt;/code&gt; indica dos elementos como equivalentes, su orden no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="0175bc0a73471ec1cd27562640c1d6735174424d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::directories_only&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing</source>
          <target state="translated">Si &lt;code&gt;copy_options::directories_only&lt;/code&gt; est&amp;aacute; presente en las &lt;code&gt;options&lt;/code&gt; , no hace nada</target>
        </trans-unit>
        <trans-unit id="815d288d8f8c46dcfd1ed95e2c2d74b9bc1cb888" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing.</source>
          <target state="translated">Si &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; est&amp;aacute; presente en las &lt;code&gt;options&lt;/code&gt; , no hace nada.</target>
        </trans-unit>
        <trans-unit id="18daaf9d57908b8b11d5a5ce74779de8f547638e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt;, then &lt;code&gt;dest&lt;/code&gt; is allowed to be a null pointer.</source>
          <target state="translated">Si &lt;code&gt;count&lt;/code&gt; es &lt;code&gt;​0​&lt;/code&gt; , entonces &lt;code&gt;dest&lt;/code&gt; se le permite ser un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="6e56b4ab0e5150566fb64d55ba8a1e8a4d01e821" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting character array is not null-terminated.</source>
          <target state="translated">Si se alcanza el &lt;code&gt;count&lt;/code&gt; antes de que se haya copiado toda la cadena &lt;code&gt;src&lt;/code&gt; , la matriz de caracteres resultante no tiene terminaci&amp;oacute;n nula.</target>
        </trans-unit>
        <trans-unit id="3896321b9a85e601977b36e1c20e47272d800cfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting wide character array is not null-terminated.</source>
          <target state="translated">Si se alcanza el &lt;code&gt;count&lt;/code&gt; antes de que se haya copiado toda la cadena &lt;code&gt;src&lt;/code&gt; , la matriz de caracteres anchos resultante no tiene terminaci&amp;oacute;n nula.</target>
        </trans-unit>
        <trans-unit id="06245894aa3eefe9ed953846b24765091a53209d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero or negative, &lt;code&gt;first&lt;/code&gt; is returned.</source>
          <target state="translated">Si el &lt;code&gt;count&lt;/code&gt; es cero o negativo, &lt;code&gt;first&lt;/code&gt; se devuelve.</target>
        </trans-unit>
        <trans-unit id="4f336d1b1de719a5985455a6d30969f36f1d4096" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, strings are considered equal.</source>
          <target state="translated">Si el &lt;code&gt;count&lt;/code&gt; es cero, las cadenas se consideran iguales.</target>
        </trans-unit>
        <trans-unit id="3f2e6aaeeb8e09e4e7d2914ab4ee68da289d48f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing.</source>
          <target state="translated">Si &lt;code&gt;count&lt;/code&gt; es cero, la funci&amp;oacute;n no hace nada.</target>
        </trans-unit>
        <trans-unit id="7ad8eda07b3297819cd8064cc3589079cc052fd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function returns a null pointer.</source>
          <target state="translated">Si &lt;code&gt;count&lt;/code&gt; es cero, la funci&amp;oacute;n devuelve un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="57a3e0d836eef087c17311ab2dbe908db83c04f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d_&lt;/code&gt; is a member variable holding the duration (i.e., time since epoch) of this &lt;code&gt;time_point&lt;/code&gt; object,</source>
          <target state="translated">Si &lt;code&gt;d_&lt;/code&gt; es una variable miembro que contiene la duraci&amp;oacute;n (es decir, el tiempo desde la &amp;eacute;poca) de este &lt;code&gt;time_point&lt;/code&gt; objeto ,</target>
        </trans-unit>
        <trans-unit id="3bbc1c66920a4038f904392405e8bb0f323da835" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;del&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it is assumed that the array was allocated with &lt;code&gt;new[]&lt;/code&gt;, and the destructor of this facet will call &lt;code&gt;delete[] tbl&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;del&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , se supone que la matriz se asign&amp;oacute; con &lt;code&gt;new[]&lt;/code&gt; , y el destructor de esta faceta llamar&amp;aacute; a &lt;code&gt;delete[] tbl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f2fea471de8b3d0628642cbd7cd79e507ef237c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; or the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;​0​&lt;/code&gt;, and the most resent operation done on this filebuf object was output (that is, either the put buffer is not empty, or the most recently called function was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;), then calls &lt;code&gt;std::codecvt::unshift&lt;/code&gt; to determine the unshift sequence necessary, and writes that sequence to the file by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;dir&lt;/code&gt; no est&amp;aacute; &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; o el desplazamiento &lt;code&gt;off&lt;/code&gt; no es &lt;code&gt;​0​&lt;/code&gt; , y la operaci&amp;oacute;n m&amp;aacute;s resienten hecho en este objeto fue filebuf de salida (es decir, ya sea el buffer de venta no est&amp;aacute; vac&amp;iacute;o, o lo &amp;uacute;ltimo que llama La funci&amp;oacute;n era &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; ), luego llama a &lt;code&gt;std::codecvt::unshift&lt;/code&gt; para determinar la secuencia de unshift necesaria, y escribe esa secuencia en el archivo llamando a &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57e5dcca2d6fb73331af4ef11d3a2dcb0d17f4d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a class member access expression (&lt;code&gt;e1.e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt;), the potential results of the object expression e1 is included in the set.</source>
          <target state="translated">Si &lt;code&gt;e&lt;/code&gt; es una expresi&amp;oacute;n de acceso de miembro de clase ( &lt;code&gt;e1.e2&lt;/code&gt; o &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt; ), los resultados potenciales de la expresi&amp;oacute;n de objeto e1 se incluyen en el conjunto.</target>
        </trans-unit>
        <trans-unit id="a611f1da12dbf6983879f4306f9df44390150021" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a comma expression (&lt;code&gt;e1,e2&lt;/code&gt;), the potential results of &lt;code&gt;e2&lt;/code&gt; are in the set of potential results</source>
          <target state="translated">Si &lt;code&gt;e&lt;/code&gt; es una expresi&amp;oacute;n de coma ( &lt;code&gt;e1,e2&lt;/code&gt; ), los resultados potenciales de &lt;code&gt;e2&lt;/code&gt; est&amp;aacute;n en el conjunto de resultados potenciales</target>
        </trans-unit>
        <trans-unit id="b272bd28e80dd2ac2a3667aaa761508a1896965d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a glvalue conditional expression (&lt;code&gt;e1?e2:e3&lt;/code&gt;, where e2 and e3 are glvalues), the union of the potential results of &lt;code&gt;e2&lt;/code&gt; and &lt;code&gt;e3&lt;/code&gt; are both included in the set.</source>
          <target state="translated">Si &lt;code&gt;e&lt;/code&gt; es una expresi&amp;oacute;n condicional de valor de gl ( &lt;code&gt;e1?e2:e3&lt;/code&gt; , donde e2 y e3 son valores de gl), la uni&amp;oacute;n de los resultados potenciales de &lt;code&gt;e2&lt;/code&gt; y &lt;code&gt;e3&lt;/code&gt; se incluye en el conjunto.</target>
        </trans-unit>
        <trans-unit id="2d9fdf08ba2dfa789e82b39c3610d8ef047043a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a pointer-to-member access expression (&lt;code&gt;e1.*e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt;) whose second operand is a constant expression, the potential results of the object expression e1 are included in the set</source>
          <target state="translated">Si &lt;code&gt;e&lt;/code&gt; es una expresi&amp;oacute;n de acceso de puntero a miembro ( &lt;code&gt;e1.*e2&lt;/code&gt; o &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt; ) cuyo segundo operando es una expresi&amp;oacute;n constante, los resultados potenciales de la expresi&amp;oacute;n de objeto e1 se incluyen en el conjunto</target>
        </trans-unit>
        <trans-unit id="136ae657a0856415b88b024f787e7474c99acad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt;, the expression &lt;code&gt;e&lt;/code&gt; is its only potential result</source>
          <target state="translated">Si &lt;code&gt;e&lt;/code&gt; es una &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n id&lt;/a&gt; , la expresi&amp;oacute;n &lt;code&gt;e&lt;/code&gt; es su &amp;uacute;nico resultado potencial</target>
        </trans-unit>
        <trans-unit id="6a6dd1d96309aaabbc396100ce7a188d685eba16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an array subscript expression (&lt;code&gt;e1[e2]&lt;/code&gt;) where one of the operands is an array, the potential results of that operand is included in the set</source>
          <target state="translated">Si &lt;code&gt;e&lt;/code&gt; es una expresi&amp;oacute;n de sub&amp;iacute;ndice de matriz ( &lt;code&gt;e1[e2]&lt;/code&gt; ) donde uno de los operandos es una matriz, los resultados potenciales de ese operando se incluyen en el conjunto</target>
        </trans-unit>
        <trans-unit id="a6876c60a5df4d3a02319ae4acfd99744e4aad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an expression in parentheses (&lt;code&gt;(e1)&lt;/code&gt;), the potential results of &lt;code&gt;e1&lt;/code&gt; are included in the set</source>
          <target state="translated">Si &lt;code&gt;e&lt;/code&gt; es una expresi&amp;oacute;n entre par&amp;eacute;ntesis ( &lt;code&gt;(e1)&lt;/code&gt; ), los resultados potenciales de &lt;code&gt;e1&lt;/code&gt; se incluyen en el conjunto</target>
        </trans-unit>
        <trans-unit id="af0a58bc0809e3f4c48c7935533640bb84b6d5da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eofbit&lt;/code&gt; is set on the stream prior to the call, the construction of the sentry object will set &lt;code&gt;failbit&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;eofbit&lt;/code&gt; se establece en la secuencia antes de la llamada, la construcci&amp;oacute;n del objeto centinela establecer&amp;aacute; &lt;code&gt;failbit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce0473bb777b78c63cd5012d3ff7b7e662f591ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt; and &lt;code&gt;equiv(b,c)==true&lt;/code&gt;, then &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;equiv(a,b)==true&lt;/code&gt; y &lt;code&gt;equiv(b,c)==true&lt;/code&gt; , entonces &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ba38a247100280f8e41691728cc66000be9e271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt;, then &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;equiv(a,b)==true&lt;/code&gt; , entonces &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="007bad278d6b4bc6d719829636a93a4a9c5a31b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating successful termination is returned to the host environment. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt;, an implementation-defined status, indicating</source>
          <target state="translated">Si &lt;code&gt;exit_code&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; , un estado definido por la implementaci&amp;oacute;n que indica la finalizaci&amp;oacute;n exitosa se devuelve al entorno del host. Si &lt;code&gt;exit_code&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; , un estado definido por la implementaci&amp;oacute;n que indica</target>
        </trans-unit>
        <trans-unit id="f710623c293fe447df3d92556a487868ef46a327" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exp&lt;/code&gt; is 0, then &lt;code&gt;x&lt;/code&gt; is returned, unmodified</source>
          <target state="translated">Si &lt;code&gt;exp&lt;/code&gt; es 0, entonces se devuelve &lt;code&gt;x&lt;/code&gt; , sin modificar</target>
        </trans-unit>
        <trans-unit id="fb1e695a18ffeb815e38e42b92e43f2bd57d73e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is a &lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;pointer to member function&lt;/a&gt; of class &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">Si &lt;code&gt;f&lt;/code&gt; es un &lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;puntero a la funci&amp;oacute;n miembro&lt;/a&gt; de la clase &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4837b4b3957d1d06787bdcfc0793edea20847145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail()==true&lt;/code&gt;, returns &lt;code&gt;pos_type(-1)&lt;/code&gt;. Otherwise, returns &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;fail()==true&lt;/code&gt; , devuelve &lt;code&gt;pos_type(-1)&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0463e8b7f222245f189b3d034b86d7447da42d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;failed()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, inserts the character &lt;code&gt;c&lt;/code&gt; into the associated stream buffer by calling &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt;, where &lt;code&gt;pbuf&lt;/code&gt; is the private member of type &lt;code&gt;streambuf_type*&lt;/code&gt;. Otherwise, does nothing.</source>
          <target state="translated">Si &lt;code&gt;failed()&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; , inserta el car&amp;aacute;cter &lt;code&gt;c&lt;/code&gt; en el b&amp;uacute;fer de flujo asociado llamando a &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; , donde &lt;code&gt;pbuf&lt;/code&gt; es el miembro privado de tipo &lt;code&gt;streambuf_type*&lt;/code&gt; . De lo contrario, no hace nada.</target>
        </trans-unit>
        <trans-unit id="5400983ef77493ea136e60df816cfe45d2e66859" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt; or &lt;code&gt;first1 == last1&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="translated">Si &lt;code&gt;first == last&lt;/code&gt; o &lt;code&gt;first1 == last1&lt;/code&gt; , &lt;code&gt;init&lt;/code&gt; se devuelve , sin modificar.</target>
        </trans-unit>
        <trans-unit id="4e003924877b9a466eeb7d707612a5f3ab0c7f79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt;, this function has no effect and will merely return &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;first == last&lt;/code&gt; , esta funci&amp;oacute;n no tiene efecto y simplemente devolver&amp;aacute; &lt;code&gt;d_first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3800b7d6b3d5edad60afa41413956ee387d068de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt;, only the first match is replaced.</source>
          <target state="translated">Si &lt;code&gt;flags&lt;/code&gt; contiene &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt; , solo se reemplaza la primera coincidencia.</target>
        </trans-unit>
        <trans-unit id="8971b9fbad479977ae5fffcd5b1ef85254f363f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt;, the non-matched subsequences are not copied into &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Si las &lt;code&gt;flags&lt;/code&gt; contienen &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt; , las subsecuencias no coincidentes no se copian en la &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afcd9815060753d019811a5dfbfcd47253700f41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%a&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt; , utilizar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a696cef7fabb97b740bacedd6f505fc04deb3ca2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;, will use conversion specifier &lt;code&gt;%A&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt; , usar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7df1b6bc3f01af8b0302af4f0306bba39947fde8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%f&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt; , usar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea893d1e69d7bcb42e6183b8b13629895919af1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%e&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt; , usar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="479647145b4986f0d7bf8bafb84a155b21c78b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%E&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt; , usar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="305a95ccb899fefeb95b7edf07cbcae48fc8c6b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same file as determined by &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="translated">Si &lt;code&gt;from&lt;/code&gt; y &lt;code&gt;to&lt;/code&gt; son el mismo archivo determinado por &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt; , informa un error</target>
        </trans-unit>
        <trans-unit id="5981efb911c3a456cb02b7dc34b28f6d5a818dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; does not exist, reports an error.</source>
          <target state="translated">Si &lt;code&gt;from&lt;/code&gt; no existe, informa un error.</target>
        </trans-unit>
        <trans-unit id="433f5d85237ac4e480b0d07ce3da6cac640403a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a directory, but &lt;code&gt;to&lt;/code&gt; is a regular file, reports an error</source>
          <target state="translated">Si &lt;code&gt;from&lt;/code&gt; es un directorio, pero &lt;code&gt;to&lt;/code&gt; es un archivo normal, informa un error</target>
        </trans-unit>
        <trans-unit id="77fcdb49cb08776e21d9d86e94d339ee3a5b233d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a symbolic link, then</source>
          <target state="translated">Si &lt;code&gt;from&lt;/code&gt; es un enlace simb&amp;oacute;lico, entonces</target>
        </trans-unit>
        <trans-unit id="d60be77b3f79d2ace2289a720e9b7a98142b9a06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">Si &lt;code&gt;from_stream&lt;/code&gt; no puede analizar todo lo especificado por la cadena de formato, o si se analiza informaci&amp;oacute;n insuficiente para especificar un resultado completo, o si el an&amp;aacute;lisis revela informaci&amp;oacute;n contradictoria, se &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9f4f8c173e4f387e8d6984eea14c0c97052549e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">Si &lt;code&gt;from_stream&lt;/code&gt; no puede analizar todo lo especificado por la cadena de formato, o si se analiza informaci&amp;oacute;n insuficiente para especificar un resultado completo, o si el an&amp;aacute;lisis revela informaci&amp;oacute;n contradictoria, &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0b2248b896ee027fabe63c433625c357d75a244" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;g&lt;/code&gt; is volatile-qualified (i.e., its cv-qualifiers are either &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;const volatile&lt;/code&gt;), the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;g&lt;/code&gt; tiene calificaci&amp;oacute;n vol&amp;aacute;til (es decir, sus calificadores cv son &lt;code&gt;volatile&lt;/code&gt; o &lt;code&gt;const volatile&lt;/code&gt; ), el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="ec3b72193abe9aedc79922cd71ce4f681ce5bb3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get() == nullptr&lt;/code&gt; there are no effects. Otherwise, the owned object is destroyed via &lt;a href=&quot;get_deleter&quot;&gt;&lt;code&gt;get_deleter()&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;get&quot;&gt;&lt;code&gt;(get())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si &lt;code&gt;get() == nullptr&lt;/code&gt; no hay efectos. De lo contrario, el objeto en propiedad se destruye mediante &lt;a href=&quot;get_deleter&quot;&gt; &lt;code&gt;get_deleter()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;get&quot;&gt; &lt;code&gt;(get())&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8cfb0ef527264e13542d3e75250bf692fe5adcb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;good() == true&lt;/code&gt;, returns the next character as obtained by &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="translated">Si es &lt;code&gt;good() == true&lt;/code&gt; , devuelve el siguiente car&amp;aacute;cter obtenido por &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d798bdc7a53000bbd5ee8924ceef0cc19c68c7ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;has_relative_path()&lt;/code&gt; returns false, the result is a copy of &lt;code&gt;*this&lt;/code&gt; Otherwise, the result is a path whose generic format pathname is the longest prefix of the generic format pathname of &lt;code&gt;*this&lt;/code&gt; that produces one fewer element in its iteration.</source>
          <target state="translated">Si &lt;code&gt;has_relative_path()&lt;/code&gt; devuelve falso, el resultado es una copia de &lt;code&gt;*this&lt;/code&gt; . De lo contrario, el resultado es una ruta cuyo nombre de ruta de formato gen&amp;eacute;rico es el prefijo m&amp;aacute;s largo del nombre de ruta de formato gen&amp;eacute;rico de &lt;code&gt;*this&lt;/code&gt; que produce un elemento menos en su iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3dea94fff00231911d476ee1bc47f5dd6bbd2db9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i == j&lt;/code&gt; and &lt;code&gt;(i, j)&lt;/code&gt; is in the domain of &lt;code&gt;==&lt;/code&gt; then this is equivalent to &lt;code&gt;*j&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;i == j&lt;/code&gt; y &lt;code&gt;(i, j)&lt;/code&gt; est&amp;aacute; en el dominio de &lt;code&gt;==&lt;/code&gt; , entonces esto es equivalente a &lt;code&gt;*j&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13008673cd8597a506cf3daa8b3ec63d08a1c87c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imbue()&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;imbue()&lt;/code&gt; is returned.</source>
          <target state="translated">Si nunca se ha llamado a &lt;code&gt;imbue()&lt;/code&gt; para este objeto, se devuelve la configuraci&amp;oacute;n regional global en el momento de la llamada. De lo contrario, se devuelve la configuraci&amp;oacute;n regional pasada a la &amp;uacute;ltima llamada a &lt;code&gt;imbue()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f7a6d2892cb99819b50181c82d0ac33627baaf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in==end&lt;/code&gt;, Stage 2 is terminated immediately, no further characters are extracted</source>
          <target state="translated">Si &lt;code&gt;in==end&lt;/code&gt; , la Etapa 2 finaliza inmediatamente, no se extraen m&amp;aacute;s caracteres</target>
        </trans-unit>
        <trans-unit id="f94d93ea046597d6595e925ae9e6a64c0253802b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index() == 0&lt;/code&gt;, returns a &lt;code&gt;sys_days&lt;/code&gt; that represents the date 7 days prior to the first &lt;code&gt;weekday()&lt;/code&gt; of the year and month.</source>
          <target state="translated">Si &lt;code&gt;index() == 0&lt;/code&gt; , devuelve un &lt;code&gt;sys_days&lt;/code&gt; que representa la fecha 7 d&amp;iacute;as antes del primer &lt;code&gt;weekday()&lt;/code&gt; la semana () del a&amp;ntilde;o y mes.</target>
        </trans-unit>
        <trans-unit id="b47ea618b12678469ff2fd08038755240643eae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, calls &lt;code&gt;is.setstate(failbit)&lt;/code&gt;(since c++11) and returns. Otherwise, if &lt;code&gt;is.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. This call can be suppressed if the put area of &lt;code&gt;is.tie()&lt;/code&gt; is empty. The implementation may defer the call to &lt;code&gt;flush&lt;/code&gt; until a call of &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; occurs. If no such call occurs before the sentry object is destroyed, it may be eliminated entirely.</source>
          <target state="translated">Si &lt;code&gt;is.good()&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , llama a &lt;code&gt;is.setstate(failbit)&lt;/code&gt; (desde c ++ 11) y regresa. De lo contrario, si &lt;code&gt;is.tie()&lt;/code&gt; no es un puntero nulo, llama a &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; para sincronizar la secuencia de salida con flujos externos. Esta llamada se puede suprimir si el &amp;aacute;rea de &lt;code&gt;is.tie()&lt;/code&gt; de is.tie () est&amp;aacute; vac&amp;iacute;a. La implementaci&amp;oacute;n puede diferir la llamada para &lt;code&gt;flush&lt;/code&gt; hasta que &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; una llamada de is.rdbuf () -&amp;gt; underflow () . Si no se produce dicha llamada antes de que se destruya el objeto centinela, se puede eliminar por completo.</target>
        </trans-unit>
        <trans-unit id="bbdd95c99548814da982d8d20409a38ef7943968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt; , el resultado es igual a &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a92eff5b31f025e8461e121aee4c206aa32fb17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt;, the result is not &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">Si es &lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt; , el resultado no es &lt;code&gt;NaN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c5e504a6bd1ecb25be6b144ecd53c96279275a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;islower&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="translated">Si &lt;code&gt;islower&lt;/code&gt; devuelve un valor distinto de cero, se garantiza que &lt;code&gt;iscntrl&lt;/code&gt; , &lt;code&gt;isdigit&lt;/code&gt; , &lt;code&gt;ispunct&lt;/code&gt; y &lt;code&gt;isspace&lt;/code&gt; devuelven cero para el mismo car&amp;aacute;cter en la misma configuraci&amp;oacute;n regional C.</target>
        </trans-unit>
        <trans-unit id="eeb4299451f00a6bbc3cc54d9636ef15cfbc4d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isupper&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="translated">Si &lt;code&gt;isupper&lt;/code&gt; devuelve un valor distinto de cero, se garantiza que &lt;code&gt;iscntrl&lt;/code&gt; , &lt;code&gt;isdigit&lt;/code&gt; , &lt;code&gt;ispunct&lt;/code&gt; y &lt;code&gt;isspace&lt;/code&gt; devuelven cero para el mismo car&amp;aacute;cter en la misma configuraci&amp;oacute;n regional C.</target>
        </trans-unit>
        <trans-unit id="1cf4537f9c301149e8cc2a31615b3d035dfb3d45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Si el &lt;code&gt;lock&lt;/code&gt; es invocado por un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; en cualquier modo (compartido o exclusivo) , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="1025c2a2787ed452c780e1dcd1489b21d28b0a1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined: for example, the program</source>
          <target state="translated">Si el &lt;code&gt;lock&lt;/code&gt; es invocado por un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; , el comportamiento no est&amp;aacute; definido: por ejemplo, el programa</target>
        </trans-unit>
        <trans-unit id="9a44d1e0b185f370bee6a94519b229c4dac6e172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock_shared&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (exclusive or shared), the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;lock_shared&lt;/code&gt; es invocado por un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; en cualquier modo (exclusivo o compartido), el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="4b1ebf8b0f2f951edb330b8fa8ae0d36a2cd369c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; is a &lt;a href=&quot;../language/static&quot;&gt;static member&lt;/a&gt; or a &lt;a href=&quot;../language/member_functions&quot;&gt;member function&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;member&lt;/code&gt; es un &lt;a href=&quot;../language/static&quot;&gt;miembro est&amp;aacute;tico&lt;/a&gt; o una &lt;a href=&quot;../language/member_functions&quot;&gt;funci&amp;oacute;n miembro&lt;/a&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="d629e4399641b9530158823e61e45ef4cbd7a6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mode &amp;gt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; wide-oriented. If &lt;code&gt;mode &amp;lt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; byte-oriented. If &lt;code&gt;mode==0&lt;/code&gt;, only queries the current orientation of the stream.</source>
          <target state="translated">Si &lt;code&gt;mode &amp;gt; 0&lt;/code&gt; , intenta hacer que la &lt;code&gt;stream&lt;/code&gt; est&amp;eacute; orientada de forma amplia. Si el &lt;code&gt;mode &amp;lt; 0&lt;/code&gt; , intenta hacer que la &lt;code&gt;stream&lt;/code&gt; est&amp;eacute; orientada a bytes. Si &lt;code&gt;mode==0&lt;/code&gt; , solo consulta la orientaci&amp;oacute;n actual de la transmisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c3e26d9cac416d20dc7c2b6fc8e45df72eb4d94c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;money_base::space&lt;/code&gt; or &lt;code&gt;money_base::none&lt;/code&gt; is the last element in the &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, the parser does not attempt to consume any whitespace after the other components of the monetary value were parsed. Otherwise, one or more whitespace characters are consumed where &lt;code&gt;money_base::space&lt;/code&gt; appears.</source>
          <target state="translated">Si &lt;code&gt;money_base::space&lt;/code&gt; o &lt;code&gt;money_base::none&lt;/code&gt; es el &amp;uacute;ltimo elemento en el &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; , el analizador no intenta consumir ning&amp;uacute;n espacio en blanco despu&amp;eacute;s de analizar los otros componentes del valor monetario. De lo contrario, se consumen uno o m&amp;aacute;s espacios en blanco donde aparece &lt;code&gt;money_base::space&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2acebccacc05bdce0834871463fa8d41cad28a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.grouping()&lt;/code&gt; does not permit thousands separators, the first separator encountered is treated as a parsing error, otherwise they are treated as optional.</source>
          <target state="translated">Si &lt;code&gt;mp.grouping()&lt;/code&gt; no permite miles de separadores, el primer separador encontrado se trata como un error de an&amp;aacute;lisis; de lo contrario, se trata como opcional.</target>
        </trans-unit>
        <trans-unit id="3018443da1f5de49f03fa88048943ced63037aee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.positive_sign()&lt;/code&gt; (in case positive format pattern is used) or &lt;code&gt;mp.negative_sign()&lt;/code&gt; (in case negative format pattern is used) returns a string with more than one character, the first character returned is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern, and the rest of the characters are placed after all other characters, for example, formatting pattern &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; with units &lt;code&gt;123&lt;/code&gt; and negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; would generate &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;mp.positive_sign()&lt;/code&gt; (en caso de que se use un patr&amp;oacute;n de formato positivo) o &lt;code&gt;mp.negative_sign()&lt;/code&gt; (en caso de que se use un patr&amp;oacute;n de formato negativo) devuelve una cadena con m&amp;aacute;s de un car&amp;aacute;cter, el primer car&amp;aacute;cter devuelto se coloca en la secuencia de salida donde &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; aparece en el patr&amp;oacute;n de formato, y el resto de los caracteres se colocan despu&amp;eacute;s de todos los dem&amp;aacute;s caracteres, por ejemplo, el patr&amp;oacute;n de formato &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; con las unidades &lt;code&gt;123&lt;/code&gt; y el signo negativo de &lt;code&gt;&quot;-&quot;&lt;/code&gt; puede dar como resultado &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; , mientras que el signo negativo de &lt;code&gt;&quot;()&quot;&lt;/code&gt; generar&amp;iacute;a &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="790ce4186370cb3fc98f05fbcd1efa576fc74ae4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, a string representing</source>
          <target state="translated">Si &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; , una cadena que representa</target>
        </trans-unit>
        <trans-unit id="c48b8077ed302c34e54734ee208fe448aa9fce59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the length of</source>
          <target state="translated">Si &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; , la longitud de</target>
        </trans-unit>
        <trans-unit id="f48f02b957cf489ffd4062413d130c7d61ac4261" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the position of the first character of the</source>
          <target state="translated">Si &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; , la posici&amp;oacute;n del primer car&amp;aacute;cter del</target>
        </trans-unit>
        <trans-unit id="d0a03be819895b29571bce6f30049ce00d836d67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0&lt;/code&gt; and &lt;code&gt;n &amp;lt; size()&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence that was matched by the</source>
          <target state="translated">Si &lt;code&gt;n &amp;gt; 0&lt;/code&gt; y &lt;code&gt;n &amp;lt; size()&lt;/code&gt; , devuelve una referencia a la &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; que representa la parte de la secuencia diana que se corresponde con el</target>
        </trans-unit>
        <trans-unit id="c9ebc82c0ecb8a48088d0a25037fb0de7b63320a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, a string representing entire matched expression is returned.</source>
          <target state="translated">Si &lt;code&gt;n == 0&lt;/code&gt; , se devuelve una cadena que representa la expresi&amp;oacute;n coincidente completa.</target>
        </trans-unit>
        <trans-unit id="793a6257509b6fed6781f48113e3c6c7ee94fe8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence matched by the entire matched regular expression.</source>
          <target state="translated">Si &lt;code&gt;n == 0&lt;/code&gt; , devuelve una referencia a &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representa la parte de la secuencia objetivo que coincide con toda la expresi&amp;oacute;n regular coincidente.</target>
        </trans-unit>
        <trans-unit id="465490bd86a1fdb5bc7e8b3d057830ae9c3992ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the counted range is valid and empty. Otherwise, the counted range is only valid if n is positive, i is dereferenceable, and &lt;code&gt;[++i, --n)&lt;/code&gt; is a valid counted range.</source>
          <target state="translated">Si &lt;code&gt;n == 0&lt;/code&gt; , el rango contado es v&amp;aacute;lido y est&amp;aacute; vac&amp;iacute;o. De lo contrario, el rango contado solo es v&amp;aacute;lido si n es positivo, i es desreferenciable y &lt;code&gt;[++i, --n)&lt;/code&gt; es un rango contado v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="101f7c47a2904602ca47dee8ebc924745b56a92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the length of the entire matched expression is returned.</source>
          <target state="translated">Si &lt;code&gt;n == 0&lt;/code&gt; , se devuelve la longitud de toda la expresi&amp;oacute;n coincidente.</target>
        </trans-unit>
        <trans-unit id="25afe120462723241b3dc46cef36ad98b886885e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the position of the first character of the entire matched expression is returned.</source>
          <target state="translated">Si &lt;code&gt;n == 0&lt;/code&gt; , se devuelve la posici&amp;oacute;n del primer car&amp;aacute;cter de toda la expresi&amp;oacute;n coincidente.</target>
        </trans-unit>
        <trans-unit id="2c59d6a4ff2080c941bbe2819b072e112c520e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal than 128, the behavior is implementation-defined</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; es mayor o igual que 128, el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="227f98cc1496f2fc8d051b223cb2a826b5a37aeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; es mayor o igual a 128, el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b0eb7273803ff8b80903c2e9df0d1f3a2350edf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater than the number of elements in the sequence, selects &lt;code&gt;last-first&lt;/code&gt; elements.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; es mayor que el n&amp;uacute;mero de elementos en la secuencia, selecciona los &lt;code&gt;last-first&lt;/code&gt; elementos.</target>
        </trans-unit>
        <trans-unit id="184888f0f32fc840aab5148b93e76a03075f7c34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is negative, the iterator is decremented. In this case, &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; es negativo, el iterador se reduce. En este caso, &lt;code&gt;InputIt&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; ; de lo contrario, el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="4dfef1823205b211d7bbfb1b78e819c624879b9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;m&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="translated">Si &lt;code&gt;n&lt;/code&gt; o &lt;code&gt;m&lt;/code&gt; es mayor o igual a 128, el comportamiento es definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="aad53311f76060eab43c7615e438c48408515bf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</source>
          <target state="translated">Si &lt;code&gt;new_cap&lt;/code&gt; es mayor que la &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , todos los iteradores, incluido el iterador pasado y el final, y todas las referencias a los elementos se invalidan. De lo contrario, no se invalidan los iteradores ni las referencias.</target>
        </trans-unit>
        <trans-unit id="255c1e92345c2e7929c0df945bb3108b691340d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, and &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; is made equal or greater than &lt;code&gt;new_cap&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;new_cap&lt;/code&gt; es mayor que la &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; actual () , se asigna nuevo almacenamiento y la &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; se iguala o es mayor que &lt;code&gt;new_cap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b2651e65eddca052bf67c187fdb378c5807dec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than or equal to the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, there is no effect.</source>
          <target state="translated">Si &lt;code&gt;new_cap&lt;/code&gt; es menor o igual que la &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; actual () , no hay efecto.</target>
        </trans-unit>
        <trans-unit id="4474adc2275755af141c407f92c0e2fd9a1bdda5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink request.</source>
          <target state="translated">Si &lt;code&gt;new_cap&lt;/code&gt; es menor que la &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; actual () , esta es una solicitud de reducci&amp;oacute;n no vinculante.</target>
        </trans-unit>
        <trans-unit id="a7e10ae2e285048c1842329a710bd58e4af2b39c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink-to-fit request equivalent to &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="translated">Si &lt;code&gt;new_cap&lt;/code&gt; es menor que el &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; actual () , esta es una solicitud de encogimiento a ajuste no vinculante equivalente a &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="bf95be7cd7ebf5692c3135c92a75c10543f6e749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_filename&lt;/code&gt; exists, the behavior is implementation-defined.</source>
          <target state="translated">Si existe &lt;code&gt;new_filename&lt;/code&gt; , el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="80cb878f6f5866322edb61fa31de1ba01506d28f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_size&lt;/code&gt; is zero, the behavior is implementation defined: null pointer may be returned (in which case the old memory block may or may not be freed) or some non-null pointer may be returned that may not be used to access storage.</source>
          <target state="translated">Si &lt;code&gt;new_size&lt;/code&gt; es cero, el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n: se puede devolver un puntero nulo (en cuyo caso, el bloque de memoria anterior se puede liberar o no) o se puede devolver alg&amp;uacute;n puntero no nulo que no se puede usar para acceder al almacenamiento.</target>
        </trans-unit>
        <trans-unit id="2de361cc207e32639639c741794ee2fcb6aa4087" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;noskipws&lt;/code&gt; is zero and &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; is nonzero, the function extracts and discards all whitespace characters until the next available character is not a whitespace character (as determined by the currently imbued locale in &lt;code&gt;is&lt;/code&gt;). If &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; returns &lt;code&gt;traits::eof()&lt;/code&gt;, the function calls &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;noskipws&lt;/code&gt; es cero e &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; no es cero, la funci&amp;oacute;n extrae y descarta todos los caracteres de espacio en blanco hasta que el siguiente car&amp;aacute;cter disponible no sea un espacio en blanco (seg&amp;uacute;n lo determinado por la configuraci&amp;oacute;n regional actualmente imbuida en &lt;code&gt;is&lt;/code&gt; ). Si &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; o &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; devuelve &lt;code&gt;traits::eof()&lt;/code&gt; , la funci&amp;oacute;n llama a &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; (que puede arrojar &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9c309a7e2f969d9c1fa291f40fe3ab598e47bd4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; was not default-constructed, the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;obj&lt;/code&gt; no se construy&amp;oacute; por defecto, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="4e236834fc06642f73e875ff2b0ea5467f35c428" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a directory, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="translated">Si &lt;code&gt;old_p&lt;/code&gt; es un directorio, entonces &lt;code&gt;new_p&lt;/code&gt; debe ser uno de:</target>
        </trans-unit>
        <trans-unit id="769c85f3779db98891c17618ad67c5dc15d9f91f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a non-directory file, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="translated">Si &lt;code&gt;old_p&lt;/code&gt; es un archivo que no es de directorio, entonces &lt;code&gt;new_p&lt;/code&gt; debe ser uno de:</target>
        </trans-unit>
        <trans-unit id="73715913e7ab67a68239322dafae4a19098bf520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;openmode&lt;/code&gt; is not one of the modes listed, the &lt;code&gt;open()&lt;/code&gt; fails.</source>
          <target state="translated">Si &lt;code&gt;openmode&lt;/code&gt; no es uno de los modos enumerados, &lt;code&gt;open()&lt;/code&gt; falla.</target>
        </trans-unit>
        <trans-unit id="6e9a3e1afd67e93539e35474985138b3c3deb24f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::add&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is set in &lt;code&gt;prms&lt;/code&gt;, but not in the file's current permissions is added to the file's permissions)</source>
          <target state="translated">Si &lt;code&gt;opts&lt;/code&gt; es &lt;code&gt;perm_options::add&lt;/code&gt; , los permisos del archivo se establecen exactamente en &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; (es decir, cualquier bit v&amp;aacute;lido establecido en &lt;code&gt;prms&lt;/code&gt; , pero no en los permisos actuales del archivo se agrega a los permisos del archivo)</target>
        </trans-unit>
        <trans-unit id="38f8c3a3043f7271f4f818139555edb242b7d47e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::remove&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is clear in &lt;code&gt;prms&lt;/code&gt;, but set in the file's current permissions is cleared in the file's permissions)</source>
          <target state="translated">Si &lt;code&gt;opts&lt;/code&gt; es &lt;code&gt;perm_options::remove&lt;/code&gt; , los permisos del archivo se establecen exactamente en &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; (es decir, cualquier bit v&amp;aacute;lido que est&amp;eacute; claro en &lt;code&gt;prms&lt;/code&gt; , pero establecido en el archivo los permisos actuales se borran en los permisos del archivo)</target>
        </trans-unit>
        <trans-unit id="743b1ea9d394f52e11e3859206c7efdd472d283a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::replace&lt;/code&gt;, file permissions are set to exactly &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; (meaning, every valid bit of &lt;code&gt;prms&lt;/code&gt; is applied)</source>
          <target state="translated">Si &lt;code&gt;opts&lt;/code&gt; es &lt;code&gt;perm_options::replace&lt;/code&gt; , los permisos de archivo se establecen exactamente en &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; (lo que significa que se aplica cada bit v&amp;aacute;lido de &lt;code&gt;prms&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4fef9d0f0afa6e8487fa35a14b4387e28190db47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns. Otherwise, if &lt;code&gt;os.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. During preparation, the constructor may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;os.good()&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , devuelve. De lo contrario, si &lt;code&gt;os.tie()&lt;/code&gt; no es un puntero nulo, llama a &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; para sincronizar la secuencia de salida con flujos externos. Durante la preparaci&amp;oacute;n, el constructor puede llamar a &lt;code&gt;setstate(failbit)&lt;/code&gt; (que puede arrojar &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="009d318ae78f457dac42968d4c493d6541c60df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, toggles whether it emits (i.e., transmits data to the underlying stream buffer) when flushed:</source>
          <target state="translated">Si &lt;code&gt;os.rdbuf()&lt;/code&gt; en realidad apunta a un &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt; &lt;code&gt;buf&lt;/code&gt; , conmuta si se emite (es decir, transmite los datos a la memoria de flujo subyacente) cuando tiraba:</target>
        </trans-unit>
        <trans-unit id="86470d4ce8b2df93a46fea671370851ae460db55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(2) or &lt;code&gt;std::move(*other)&lt;/code&gt;(3). Note that a moved-from optional still</source>
          <target state="translated">Si &lt;code&gt;other&lt;/code&gt; contiene un valor, dependiendo de si &lt;code&gt;*this&lt;/code&gt; contiene un valor, el valor contenido se &lt;a href=&quot;../../language/direct_initialization&quot;&gt;inicializa directamente&lt;/a&gt; o se asigna desde &lt;code&gt;*other&lt;/code&gt; (2) o &lt;code&gt;std::move(*other)&lt;/code&gt; (3). Tenga en cuenta que una opci&amp;oacute;n movida desde a&amp;uacute;n</target>
        </trans-unit>
        <trans-unit id="36484744e817604683f9351055f9e29eff44cf5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(5) or &lt;code&gt;std::move(*other)&lt;/code&gt;(6). Note that a moved-from optional still</source>
          <target state="translated">Si &lt;code&gt;other&lt;/code&gt; contiene un valor, dependiendo de si &lt;code&gt;*this&lt;/code&gt; contiene un valor, el valor contenido se &lt;a href=&quot;../../language/direct_initialization&quot;&gt;inicializa directamente&lt;/a&gt; o se asigna desde &lt;code&gt;*other&lt;/code&gt; (5) o &lt;code&gt;std::move(*other)&lt;/code&gt; (6). Tenga en cuenta que una opci&amp;oacute;n movida desde a&amp;uacute;n</target>
        </trans-unit>
        <trans-unit id="c8399508478e3a1e9b6988b20831b2cf1587c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;, has no effects. Otherwise, copies the state of the stream &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. This is done in the following sequence:</source>
          <target state="translated">Si &lt;code&gt;other&lt;/code&gt; refiere al mismo objeto que &lt;code&gt;*this&lt;/code&gt; , no tiene efectos. De lo contrario, copia el estado de la secuencia en &lt;code&gt;other&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; . Esto se hace en la siguiente secuencia:</target>
        </trans-unit>
        <trans-unit id="cde0508aa3c91b841b5bb98037ec418d76d0f467" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out_stream&lt;/code&gt; is a pointer to the associated &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;delim&lt;/code&gt; is the delimiter specified at the construction of this object, then the effect is equivalent to.</source>
          <target state="translated">Si &lt;code&gt;out_stream&lt;/code&gt; es un puntero al &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; asociado y &lt;code&gt;delim&lt;/code&gt; es el delimitador especificado en la construcci&amp;oacute;n de este objeto, entonces el efecto es equivalente a.</target>
        </trans-unit>
        <trans-unit id="9a4113e2f36160ea8f8bfa69f1009dc12f90fc93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 1&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="translated">Si &lt;code&gt;p == 1&lt;/code&gt; , las llamadas posteriores a la sobrecarga del &lt;a href=&quot;operator()&quot;&gt; &lt;code&gt;operator()&lt;/code&gt; &lt;/a&gt; que no acepta un objeto &lt;code&gt;param_type&lt;/code&gt; causar&amp;aacute;n un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="39fcfc6551db4ea098125222aa584e4d80195a5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, reports an error.</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; no existe, informa un error.</target>
        </trans-unit>
        <trans-unit id="c7e10031a884549bafa7d7b0cdef0c9d208f99c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, returns &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; no existe, devuelve &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35e83165c214a9475effb2ede4b6d71c2ec296a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; exists but file attributes cannot be determined, e.g. due to lack of permissions, returns &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; existe pero los atributos del archivo no se pueden determinar, por ejemplo, debido a la falta de permisos, devuelve &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="284cbde49fd69756d49af77ea69cb915f6cc4f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; has an implementation-defined file type, returns &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is the implementation-defined &lt;a href=&quot;file_type&quot;&gt;&lt;code&gt;file_type&lt;/code&gt;&lt;/a&gt; constant for that type.</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; tiene un tipo de archivo definido por la implementaci&amp;oacute;n, devoluciones &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; , donde &lt;code&gt;A&lt;/code&gt; es el definido por la implementaci&amp;oacute;n &lt;a href=&quot;file_type&quot;&gt; &lt;code&gt;file_type&lt;/code&gt; &lt;/a&gt; constante de ese tipo.</target>
        </trans-unit>
        <trans-unit id="84ba1d9110ba0eaab227ddc535151c53fd9656e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a block special file (as if by POSIX &lt;code&gt;S_ISBLK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es un archivo especial de bloque (como si fuera POSIX &lt;code&gt;S_ISBLK&lt;/code&gt; ), devuelve &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8d7bbe00812399696fe7cc6d0e4fb887d95e2e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a character special file (as if by POSIX &lt;code&gt;S_ISCHR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es un archivo especial de caracteres (como si fuera POSIX &lt;code&gt;S_ISCHR&lt;/code&gt; ), devuelve &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5948ebb49968bd5b647e0007b11f05d39ecbae58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a directory (as if by POSIX &lt;code&gt;S_ISDIR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es un directorio (como si fuera POSIX &lt;code&gt;S_ISDIR&lt;/code&gt; ), devuelve &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7098ea96e1e6fe0bd037998b47dc31e8e17fec8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a fifo or pipe file (as if by POSIX &lt;code&gt;S_ISFIFO&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es un archivo fifo o pipe (como si fuera POSIX &lt;code&gt;S_ISFIFO&lt;/code&gt; ), devuelve &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b2d16f4bd782dbe9f713f31636dbe449e4151e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a regular file (as if by POSIX &lt;code&gt;S_ISREG&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es un archivo regular (como si fuera POSIX &lt;code&gt;S_ISREG&lt;/code&gt; ), devuelve &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd7f50e30d338262c2966fea6e46450e597e3af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a socket (as if by POSIX &lt;code&gt;S_ISSOCK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es un socket (como si fuera POSIX &lt;code&gt;S_ISSOCK&lt;/code&gt; ), devuelve &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249fe3aff7a5aaa72c5e17941aa8c099b4d5e055" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a symlink, returns &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;p&lt;/code&gt; es un enlace simb&amp;oacute;lico, devuelve &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a1524ab079a206332a561da96374e5f2392e60c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parm_n&lt;/code&gt; is declared with reference type or with a type not compatible with the type that results from &lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;default argument promotions&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">Si se declara &lt;code&gt;parm_n&lt;/code&gt; con el tipo de referencia o con un tipo no compatible con el tipo que resulta de las &lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;promociones de argumento predeterminadas&lt;/a&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="e24b13015ddf20bc0adacae9ec44ca2ad7e04f7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; and native encoding is UTF-8, constructs a path directly as if by &lt;code&gt;path(source)&lt;/code&gt; or &lt;code&gt;path(first, last)&lt;/code&gt;. Note: this is the typical situation of a POSIX system that uses Unicode, such as Linux.</source>
          <target state="translated">Si &lt;code&gt;path::value_type&lt;/code&gt; es &lt;code&gt;char&lt;/code&gt; y la codificaci&amp;oacute;n nativa es UTF-8, construye una ruta directamente como por &lt;code&gt;path(source)&lt;/code&gt; o &lt;code&gt;path(first, last)&lt;/code&gt; . Nota: esta es la situaci&amp;oacute;n t&amp;iacute;pica de un sistema POSIX que utiliza Unicode, como Linux.</target>
        </trans-unit>
        <trans-unit id="f1467bab99e474a5aa0ae0855c89eab043a29738" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt;, conversion, if any, is system-dependent. This is the case on typical POSIX systems (such as Linux), where native encoding is UTF-8 and &lt;code&gt;string()&lt;/code&gt; performs no conversion.</source>
          <target state="translated">Si &lt;code&gt;path::value_type&lt;/code&gt; es &lt;code&gt;char&lt;/code&gt; , la conversi&amp;oacute;n, si la hay, depende del sistema. Este es el caso en los sistemas POSIX t&amp;iacute;picos (como Linux), donde la codificaci&amp;oacute;n nativa es UTF-8 y &lt;code&gt;string()&lt;/code&gt; no realiza conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ecd5f9bafd39fb01f214968395060cedf4c94446" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;placement_params&lt;/code&gt; are provided, they are passed to the allocation function as additional arguments. Such allocation functions are known as &quot;placement new&quot;, after the standard allocation function &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt;, which simply returns its second argument unchanged. This is used to construct objects in allocated storage:</source>
          <target state="translated">Si se proporcionan &lt;code&gt;placement_params&lt;/code&gt; , se pasan a la funci&amp;oacute;n de asignaci&amp;oacute;n como argumentos adicionales. Dichas funciones de asignaci&amp;oacute;n se conocen como &quot;colocaci&amp;oacute;n nueva&quot;, despu&amp;eacute;s de la funci&amp;oacute;n de asignaci&amp;oacute;n est&amp;aacute;ndar &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt; , que simplemente devuelve su segundo argumento sin cambios. Esto se utiliza para construir objetos en el almacenamiento asignado:</target>
        </trans-unit>
        <trans-unit id="73eb91c9e150b84ef667442582643acf6c0ee10d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">Si &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; , se arroja &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5825465b5dfa7d68d014c8c650a4880927e452b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt;, this constructor throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt;. If any characters examined in &lt;code&gt;str&lt;/code&gt; are not &lt;code&gt;zero&lt;/code&gt; or &lt;code&gt;one&lt;/code&gt;, it throws &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt; , este constructor arroja &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; . Si alguno de los caracteres examinados en &lt;code&gt;str&lt;/code&gt; no es &lt;code&gt;zero&lt;/code&gt; o &lt;code&gt;one&lt;/code&gt; , arroja &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9cdf4cfe8233d41239dac602c3524239510fa6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos == size()&lt;/code&gt;, a reference to the character with value &lt;code&gt;CharT()&lt;/code&gt; (the null character) is returned.</source>
          <target state="translated">Si &lt;code&gt;pos == size()&lt;/code&gt; , se devuelve una referencia al car&amp;aacute;cter con valor &lt;code&gt;CharT()&lt;/code&gt; (el car&amp;aacute;cter nulo).</target>
        </trans-unit>
        <trans-unit id="45d948614cf70d9e5ba39df1cc54e194a17a73da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt; - internal to the conversion functions - will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="translated">Si &lt;code&gt;pos&lt;/code&gt; no es un puntero nulo, entonces un puntero &lt;code&gt;ptr&lt;/code&gt; , interno a las funciones de conversi&amp;oacute;n, recibir&amp;aacute; la direcci&amp;oacute;n del primer car&amp;aacute;cter no convertido en &lt;code&gt;str.c_str()&lt;/code&gt; , y el &amp;iacute;ndice de ese car&amp;aacute;cter se calcular&amp;aacute; y almacenar&amp;aacute; en &lt;code&gt;*pos&lt;/code&gt; , dando el n&amp;uacute;mero de caracteres que fueron procesados ​​por la conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f6fea302ec518c538cb888ab49b9e51eb713903c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt;, internal to the conversion functions, will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="translated">Si &lt;code&gt;pos&lt;/code&gt; no es un puntero nulo, entonces un puntero &lt;code&gt;ptr&lt;/code&gt; , interno a las funciones de conversi&amp;oacute;n, recibir&amp;aacute; la direcci&amp;oacute;n del primer car&amp;aacute;cter no convertido en &lt;code&gt;str.c_str()&lt;/code&gt; , y el &amp;iacute;ndice de ese car&amp;aacute;cter se calcular&amp;aacute; y almacenar&amp;aacute; en &lt;code&gt;*pos&lt;/code&gt; , dando el n&amp;uacute;mero de caracteres que fueron procesados ​​por la conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="079f39fe95713c066d5cd5476974d3a17ef66bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not within the range of the container, an exception of type &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">Si &lt;code&gt;pos&lt;/code&gt; no est&amp;aacute; dentro del rango del contenedor, se &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; una excepci&amp;oacute;n de tipo std :: out_of_range .</target>
        </trans-unit>
        <trans-unit id="beb7dae20fb8d8052f57f043526ceb062d467b3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ps&lt;/code&gt; is not a null pointer, the &lt;code&gt;mbsinit&lt;/code&gt; function determines whether the pointed-to &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; object describes the initial conversion state.</source>
          <target state="translated">Si &lt;code&gt;ps&lt;/code&gt; no es un puntero nulo, la funci&amp;oacute;n &lt;code&gt;mbsinit&lt;/code&gt; determina si el objeto &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; apuntado a describe el estado de conversi&amp;oacute;n inicial.</target>
        </trans-unit>
        <trans-unit id="101e3c4415b14d26fb3724226aa4e6d4501f3aea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the behavior is the same as calling &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;(&lt;code&gt;new_size&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;ptr&lt;/code&gt; es un puntero nulo, el comportamiento es el mismo que llamar a &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;new_size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="75ce63992e734876e2a939cc380b004ef361f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the function does nothing.</source>
          <target state="translated">Si &lt;code&gt;ptr&lt;/code&gt; es un puntero nulo, la funci&amp;oacute;n no hace nada.</target>
        </trans-unit>
        <trans-unit id="f2dc2865c464168b736d26e4f6c5e34da572e57e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is empty, so is the new &lt;code&gt;shared_ptr&lt;/code&gt; (but its stored pointer is not necessarily null). Otherwise, the new &lt;code&gt;shared_ptr&lt;/code&gt; will share ownership with the initial value of &lt;code&gt;r&lt;/code&gt;, except that it is empty if the &lt;code&gt;dynamic_cast&lt;/code&gt; performed by &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; returns a null pointer.</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, tambi&amp;eacute;n lo est&amp;aacute; el nuevo &lt;code&gt;shared_ptr&lt;/code&gt; (pero su puntero almacenado no es necesariamente nulo). De lo contrario, el nuevo &lt;code&gt;shared_ptr&lt;/code&gt; compartir&amp;aacute; la propiedad con el valor inicial de &lt;code&gt;r&lt;/code&gt; , excepto que est&amp;aacute; vac&amp;iacute;o si &lt;code&gt;dynamic_cast&lt;/code&gt; realizado por &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; devuelve un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="b29c481ab6a6599cf423510b090aefb5d2a5a864" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not null, sets the default memory resource pointer to &lt;code&gt;r&lt;/code&gt;; otherwise, sets the default memory resource pointer to &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;r&lt;/code&gt; no es nulo, establece el puntero de recursos de memoria predeterminado en &lt;code&gt;r&lt;/code&gt; ; de lo contrario, establece el puntero de recursos de memoria predeterminado en &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="775fd3976f21369f6410f6f3d50cc92d417bb684" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rand()&lt;/code&gt; is used before any calls to &lt;code&gt;srand()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt; behaves as if it was seeded with &lt;code&gt;srand(1)&lt;/code&gt;.</source>
          <target state="translated">Si se usa &lt;code&gt;rand()&lt;/code&gt; antes de cualquier llamada a &lt;code&gt;srand()&lt;/code&gt; , &lt;code&gt;rand()&lt;/code&gt; comporta como si se hubiera sembrado con &lt;code&gt;srand(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e1109753adbdfe03f2bb121a57562bbd3b95645" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt;, extracts &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; characters and stores them into successive locations of the characater array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt; , extrae los caracteres &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; y los almacena en ubicaciones sucesivas de la matriz de caracteres cuyo primer elemento se&amp;ntilde;ala &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cb1ced447e9513c6cc2a7656394e6e283081981" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt;, calls &lt;code&gt;setstate(eofbit)&lt;/code&gt; and extracts no characters.</source>
          <target state="translated">Si &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt; , llama a &lt;code&gt;setstate(eofbit)&lt;/code&gt; y no extrae caracteres.</target>
        </trans-unit>
        <trans-unit id="1d663866c5ef6d453a0e6e1c3a442d54a0a631ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt;, extracts no characters.</source>
          <target state="translated">Si &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt; , no extrae caracteres.</target>
        </trans-unit>
        <trans-unit id="0bb9782f82ff3d24467c86f4716084ada4ca990f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; devuelve &lt;code&gt;Traits::eof()&lt;/code&gt; , llama a &lt;code&gt;setstate(badbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f7f0c931fb16fc794bc074b32fcde3eb8dce586" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()&lt;/code&gt; is null or if &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;rdbuf()&lt;/code&gt; es nulo o si &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; devuelve &lt;code&gt;Traits::eof()&lt;/code&gt; , llama a &lt;code&gt;setstate(badbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c685f865d646b3c4c7e1a09a3ab4541aca64af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object,</source>
          <target state="translated">Si &lt;code&gt;rep_&lt;/code&gt; es una variable miembro que contiene el n&amp;uacute;mero de ticks en un objeto de duraci&amp;oacute;n,</target>
        </trans-unit>
        <trans-unit id="dd202d89b0c5b4958bcc3baf6d4f8cc9e4180f5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object, and &lt;code&gt;D&lt;/code&gt; is the return type,</source>
          <target state="translated">Si &lt;code&gt;rep_&lt;/code&gt; es una variable miembro que contiene el n&amp;uacute;mero de ticks en un objeto de duraci&amp;oacute;n, y &lt;code&gt;D&lt;/code&gt; es el tipo de retorno,</target>
        </trans-unit>
        <trans-unit id="d39a4ad84577a00c15233086e6e7ac8affa4a963" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is the member variable holding the number of ticks in this duration object,</source>
          <target state="translated">Si &lt;code&gt;rep_&lt;/code&gt; es la variable miembro que contiene el n&amp;uacute;mero de ticks en este objeto de duraci&amp;oacute;n,</target>
        </trans-unit>
        <trans-unit id="f2eadcb39ee434e29ef05bd72b2b26a315c2acf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, the filebuf becomes</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo &lt;code&gt;n&lt;/code&gt; es cero, el filebuf se convierte en</target>
        </trans-unit>
        <trans-unit id="9b53eb098a63b3e541f5d769951b6fce364d2e5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, this function has no effect.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo &lt;code&gt;n&lt;/code&gt; es cero, esta funci&amp;oacute;n no tiene efecto.</target>
        </trans-unit>
        <trans-unit id="1972341d22f77196bc1af118f58697bce937d0f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets its internal conversion state to represent the initial shift state and returns &lt;code&gt;​0​&lt;/code&gt; if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo, restablece su estado conversi&amp;oacute;n interna para representar el estado de desplazamiento inicial y vuelve &lt;code&gt;​0​&lt;/code&gt; si la corriente de codificaci&amp;oacute;n multibyte no es un valor distinto de cero si la multibyte actual estado-dependiente (no utilizar secuencias de desplazamiento) o la codificaci&amp;oacute;n depende del estado (usa secuencias de cambio).</target>
        </trans-unit>
        <trans-unit id="c39632bb99f5cb18b879a3b49462f93b75999d15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo, restablece el estado de conversi&amp;oacute;n global y determina si se utilizan secuencias de cambio.</target>
        </trans-unit>
        <trans-unit id="6138f983954415f7151da4086aa9c700eb8d9987" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo, la llamada es equivalente a &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; para algunos buffer interno &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b425a38a00e233a7e79446325b7bf9c1fc117a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo, la llamada es equivalente a &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; para algunos buffer interno &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed35e82d64bb46cbad184112b5af458797318975" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo, la llamada es equivalente a &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; para algunos buffer interno &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12e013f90ae32cdb16251d5b6510a8d8d5565aed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo, la llamada es equivalente a &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; para algunos buffer interno &lt;code&gt;buf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0c98fdcb47a8abb41d844fc8c53f32413a8247d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc16&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo, los valores de &lt;code&gt;n&lt;/code&gt; y &lt;code&gt;pc16&lt;/code&gt; se ignoran y la llamada es equivalente a &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f441bdad904ce2a3ae27b238bbd76507e2b519da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc32&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo, los valores de &lt;code&gt;n&lt;/code&gt; y &lt;code&gt;pc32&lt;/code&gt; se ignoran y la llamada es equivalente a &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92f917820ffd997e9b4bad50e8a1e2f43abff234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc8&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo, los valores de &lt;code&gt;n&lt;/code&gt; y &lt;code&gt;pc8&lt;/code&gt; se ignoran y la llamada es equivalente a &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="002e16b0a8a0300cebc1bd2022bc72e0016d413f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pwc&lt;/code&gt; are ignored and call is equivalent to &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; es un puntero nulo, los valores de &lt;code&gt;n&lt;/code&gt; y &lt;code&gt;pwc&lt;/code&gt; se ignoran y la llamada es equivalente a &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="387220b12d5b9da678e75cc38f39c0d62fd87341" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c16&lt;/code&gt; is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; no es un puntero nulo y &lt;code&gt;c16&lt;/code&gt; es la &amp;uacute;ltima unidad de c&amp;oacute;digo de 16 bits en una codificaci&amp;oacute;n v&amp;aacute;lida de longitud variable de un punto de c&amp;oacute;digo, la funci&amp;oacute;n determina el n&amp;uacute;mero de bytes necesarios para almacenar la representaci&amp;oacute;n de caracteres multibyte de ese punto de c&amp;oacute;digo (incluyendo cualquier cambia las secuencias, y teniendo en cuenta el estado actual de conversi&amp;oacute;n multibyte &lt;code&gt;*ps&lt;/code&gt; ), y almacena la representaci&amp;oacute;n de caracteres multibyte en la matriz de caracteres cuyo primer elemento apunta a &lt;code&gt;s&lt;/code&gt; , actualizando &lt;code&gt;*ps&lt;/code&gt; seg&amp;uacute;n sea necesario. Como m&amp;aacute;ximo, &lt;code&gt;MB_CUR_MAX&lt;/code&gt; puede escribir bytes con esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8e98391f16286d01eda72c77dda336407bf1f401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c8&lt;/code&gt; is the last code unit in a valid UTF-8 encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; no es un puntero nulo y &lt;code&gt;c8&lt;/code&gt; es la &amp;uacute;ltima unidad de c&amp;oacute;digo en una codificaci&amp;oacute;n UTF-8 v&amp;aacute;lida de un punto de c&amp;oacute;digo, la funci&amp;oacute;n determina el n&amp;uacute;mero de bytes necesarios para almacenar la representaci&amp;oacute;n de caracteres multibyte de ese punto de c&amp;oacute;digo (incluidas las secuencias de desplazamiento, y teniendo en cuenta el estado actual de conversi&amp;oacute;n multibyte &lt;code&gt;*ps&lt;/code&gt; ), y almacena la representaci&amp;oacute;n de caracteres multibyte en la matriz de caracteres cuyo primer elemento apunta a trav&amp;eacute;s de &lt;code&gt;s&lt;/code&gt; , actualizando &lt;code&gt;*ps&lt;/code&gt; seg&amp;uacute;n sea necesario. Como m&amp;aacute;ximo, &lt;code&gt;MB_CUR_MAX&lt;/code&gt; puede escribir bytes con esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="efeff6f4bae9dbe7dacca63bdafb8df5873ba5a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to UTF-8 and stores the first UTf-8 code unit in &lt;code&gt;*pc8&lt;/code&gt; (if &lt;code&gt;pc8&lt;/code&gt; is not null).</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; no es un puntero nulo, inspecciona como m&amp;aacute;ximo &lt;code&gt;n&lt;/code&gt; bytes de la cadena de caracteres multibyte, comenzando con el byte se&amp;ntilde;alado por &lt;code&gt;s&lt;/code&gt; para determinar el n&amp;uacute;mero de bytes necesarios para completar el siguiente car&amp;aacute;cter multibyte (incluidas las secuencias de desplazamiento). Si la funci&amp;oacute;n determina que el siguiente car&amp;aacute;cter multibyte en &lt;code&gt;s&lt;/code&gt; est&amp;aacute; completo y es v&amp;aacute;lido, lo convierte a UTF-8 y almacena la primera unidad de c&amp;oacute;digo UTf-8 en &lt;code&gt;*pc8&lt;/code&gt; (si &lt;code&gt;pc8&lt;/code&gt; no es nulo).</target>
        </trans-unit>
        <trans-unit id="66571e29e3face4617295ef95324bcdf8412d045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 16-bit character and stores it in &lt;code&gt;*pc16&lt;/code&gt; (if &lt;code&gt;pc16&lt;/code&gt; is not null).</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; no es un puntero nulo, inspecciona como m&amp;aacute;ximo &lt;code&gt;n&lt;/code&gt; bytes de la cadena de caracteres multibyte, comenzando con el byte se&amp;ntilde;alado por &lt;code&gt;s&lt;/code&gt; para determinar el n&amp;uacute;mero de bytes necesarios para completar el siguiente car&amp;aacute;cter multibyte (incluidas las secuencias de desplazamiento). Si la funci&amp;oacute;n determina que el siguiente car&amp;aacute;cter multibyte en &lt;code&gt;s&lt;/code&gt; est&amp;aacute; completo y es v&amp;aacute;lido, lo convierte al car&amp;aacute;cter de 16 bits correspondiente y lo almacena en &lt;code&gt;*pc16&lt;/code&gt; (si &lt;code&gt;pc16&lt;/code&gt; no es nulo).</target>
        </trans-unit>
        <trans-unit id="e34686814ade46fa92cd32a9d644e0c7a90c8094" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 32-bit character and stores it in &lt;code&gt;*pc32&lt;/code&gt; (if &lt;code&gt;pc32&lt;/code&gt; is not null).</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; no es un puntero nulo, inspecciona como m&amp;aacute;ximo &lt;code&gt;n&lt;/code&gt; bytes de la cadena de caracteres multibyte, comenzando con el byte se&amp;ntilde;alado por &lt;code&gt;s&lt;/code&gt; para determinar el n&amp;uacute;mero de bytes necesarios para completar el siguiente car&amp;aacute;cter multibyte (incluidas las secuencias de desplazamiento). Si la funci&amp;oacute;n determina que el siguiente car&amp;aacute;cter multibyte en &lt;code&gt;s&lt;/code&gt; est&amp;aacute; completo y es v&amp;aacute;lido, lo convierte al car&amp;aacute;cter correspondiente de 32 bits y lo almacena en &lt;code&gt;*pc32&lt;/code&gt; (si &lt;code&gt;pc32&lt;/code&gt; no es nulo).</target>
        </trans-unit>
        <trans-unit id="2038e0d252e5f18478ed819b27d31e3681ca48d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding wide character and stores it in &lt;code&gt;*pwc&lt;/code&gt; (if &lt;code&gt;pwc&lt;/code&gt; is not null).</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; no es un puntero nulo, inspecciona como m&amp;aacute;ximo &lt;code&gt;n&lt;/code&gt; bytes de la cadena de caracteres multibyte, comenzando con el byte se&amp;ntilde;alado por &lt;code&gt;s&lt;/code&gt; para determinar el n&amp;uacute;mero de bytes necesarios para completar el siguiente car&amp;aacute;cter multibyte (incluidas las secuencias de desplazamiento). Si la funci&amp;oacute;n determina que el siguiente car&amp;aacute;cter multibyte en &lt;code&gt;s&lt;/code&gt; es completo y v&amp;aacute;lido, lo convierte al car&amp;aacute;cter ancho correspondiente y lo almacena en &lt;code&gt;*pwc&lt;/code&gt; (si &lt;code&gt;pwc&lt;/code&gt; no es nulo).</target>
        </trans-unit>
        <trans-unit id="6f4c68687ec93f7e26b9a23cfefd0d3cb05dc64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte character or &lt;code&gt;-1&lt;/code&gt; if the first bytes pointed to by &lt;code&gt;s&lt;/code&gt; do not form a valid multibyte character or &lt;code&gt;​0​&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is pointing at the null charcter &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; no es un puntero nulo, devuelve el n&amp;uacute;mero de bytes que se contienen en el car&amp;aacute;cter de varios bytes o &lt;code&gt;-1&lt;/code&gt; si los primeros bytes apuntada por &lt;code&gt;s&lt;/code&gt; no forman un car&amp;aacute;cter multibyte v&amp;aacute;lida o &lt;code&gt;​0​&lt;/code&gt; si &lt;code&gt;s&lt;/code&gt; est&amp;aacute; apuntando a la Charcter nula &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f76e4a5183e8ca08cf45c471464ea38bd49564a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte representation of &lt;code&gt;wc&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;wc&lt;/code&gt; is not a valid character.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; no es un puntero nulo, devuelve el n&amp;uacute;mero de bytes contenidos en la representaci&amp;oacute;n multibyte de &lt;code&gt;wc&lt;/code&gt; o &lt;code&gt;-1&lt;/code&gt; si &lt;code&gt;wc&lt;/code&gt; no es un car&amp;aacute;cter v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="6d6df3a6410ecce9d2acc8ffd84bf56f540ac991" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;c32&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; no es un puntero nulo, la funci&amp;oacute;n determina el n&amp;uacute;mero de bytes necesarios para almacenar la representaci&amp;oacute;n de caracteres multibyte de &lt;code&gt;c32&lt;/code&gt; (incluidas las secuencias de desplazamiento y teniendo en cuenta el estado de conversi&amp;oacute;n multibyte actual &lt;code&gt;*ps&lt;/code&gt; ), y almacena la representaci&amp;oacute;n de caracteres multibyte en la matriz de caracteres cuyo primer elemento es se&amp;ntilde;alado por &lt;code&gt;s&lt;/code&gt; , actualizando &lt;code&gt;*ps&lt;/code&gt; seg&amp;uacute;n sea necesario. Como m&amp;aacute;ximo, &lt;code&gt;MB_CUR_MAX&lt;/code&gt; puede escribir bytes con esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a9d1c6974b8b676a8501a6cacc05cdd5f413866d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;wc&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">Si &lt;code&gt;s&lt;/code&gt; no es un puntero nulo, la funci&amp;oacute;n determina el n&amp;uacute;mero de bytes necesarios para almacenar la representaci&amp;oacute;n de caracteres multibyte de &lt;code&gt;wc&lt;/code&gt; (incluidas las secuencias de desplazamiento y teniendo en cuenta el estado de conversi&amp;oacute;n multibyte actual &lt;code&gt;*ps&lt;/code&gt; ), y almacena la representaci&amp;oacute;n de caracteres multibyte en la matriz de caracteres cuyo primer elemento es se&amp;ntilde;alado por &lt;code&gt;s&lt;/code&gt; , actualizando &lt;code&gt;*ps&lt;/code&gt; seg&amp;uacute;n sea necesario. Como m&amp;aacute;ximo, &lt;code&gt;MB_CUR_MAX&lt;/code&gt; puede escribir bytes con esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7823afdead8eb41af529747e83ce1e0afbe2e6fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setjmp&lt;/code&gt; appears in any other context, the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;setjmp&lt;/code&gt; aparece en cualquier otro contexto, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="4c03a05548ddb96f3438cfeabf552db044243a9a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;showbase&lt;/code&gt; flag is set in &lt;code&gt;str.flags()&lt;/code&gt;, the currency symbol or currency string is required, if it is not set, the currency symbol is optional.</source>
          <target state="translated">Si el indicador &lt;code&gt;showbase&lt;/code&gt; est&amp;aacute; configurado en &lt;code&gt;str.flags()&lt;/code&gt; , se requiere el s&amp;iacute;mbolo de la moneda o la cadena de la moneda, si no est&amp;aacute; configurado, el s&amp;iacute;mbolo de la moneda es opcional.</target>
        </trans-unit>
        <trans-unit id="8969128c7f7485e9cafa97fcadad06ea89f50051" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size()&lt;/code&gt; is 0, &lt;code&gt;data()&lt;/code&gt; may or may not return a null pointer.</source>
          <target state="translated">Si &lt;code&gt;size()&lt;/code&gt; es 0, &lt;code&gt;data()&lt;/code&gt; puede o no devolver un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="5a6ee964cf02ec47b4f466324fac4fa5368b4c54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="translated">Si el &lt;code&gt;size&lt;/code&gt; es cero, el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n (se puede devolver un puntero nulo o se puede devolver alg&amp;uacute;n puntero no nulo que no se puede usar para acceder al almacenamiento).</target>
        </trans-unit>
        <trans-unit id="4de52063dd761a69f5fec3a1f793d8ab34506b00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Si el &lt;code&gt;size&lt;/code&gt; es cero, el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n (se puede devolver un puntero nulo o se puede devolver alg&amp;uacute;n puntero no nulo que no se puede usar para acceder al almacenamiento, pero se debe pasar a &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fece348a8ee3d70f7e3352f3e69bf03a082365cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fread&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">Si el &lt;code&gt;size&lt;/code&gt; o el &lt;code&gt;count&lt;/code&gt; es cero, &lt;code&gt;fread&lt;/code&gt; devuelve cero y no realiza ninguna otra acci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a444353fd5b9d3848488fa96c9629f1e576c66a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fwrite&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">Si &lt;code&gt;size&lt;/code&gt; o &lt;code&gt;count&lt;/code&gt; es cero, &lt;code&gt;fwrite&lt;/code&gt; devuelve cero y no realiza ninguna otra acci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="62c0f8b2707422825d3dfec002ee726a9c2cbd66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt;, that is, no inner allocators were declared, returns &lt;code&gt;*this&lt;/code&gt;. Otherwise returns a reference to &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt;, that is, a scoped allocator composed of all inner allocators of &lt;code&gt;*this&lt;/code&gt;, with the first inner allocator becoming the outer allocator.</source>
          <target state="translated">Si &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt; , es decir, no se declararon asignadores internos, devuelve &lt;code&gt;*this&lt;/code&gt; . De lo contrario, devuelve una referencia a &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; , es decir, un asignador con &amp;aacute;mbito compuesto por todos los asignadores internos de &lt;code&gt;*this&lt;/code&gt; , con el primer asignador interno convirti&amp;eacute;ndose en el asignador externo.</target>
        </trans-unit>
        <trans-unit id="791ac1fc4772ec7b51395220b898af37695b4777" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;sizeof...(T)&lt;/code&gt; es mayor que dos (es decir, &lt;code&gt;T...&lt;/code&gt; consiste en los tipos &lt;code&gt;T1, T2, R...&lt;/code&gt; ), entonces si &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; existe, el &lt;code&gt;type&lt;/code&gt; miembro indica &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; si ese tipo existe. En todos los dem&amp;aacute;s casos, no hay ning&amp;uacute;n &lt;code&gt;type&lt;/code&gt; miembro .</target>
        </trans-unit>
        <trans-unit id="ecc26feb6c4b2ae80a7529b5d61cf9ff7a5b097b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;sizeof...(T)&lt;/code&gt; es mayor que dos (es decir, &lt;code&gt;T...&lt;/code&gt; consiste en los tipos &lt;code&gt;T1, T2, R...&lt;/code&gt; ), entonces si existe el &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; , el el &lt;code&gt;type&lt;/code&gt; miembro denota &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; si tal tipo existe. En todos los dem&amp;aacute;s casos, no hay ning&amp;uacute;n &lt;code&gt;type&lt;/code&gt; miembro .</target>
        </trans-unit>
        <trans-unit id="78448ef5ca9bbafc2986882ac92ff12c158a9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;T0&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;sizeof...(T)&lt;/code&gt; es uno (es decir, &lt;code&gt;T...&lt;/code&gt; contiene solo un tipo &lt;code&gt;T0&lt;/code&gt; ), el &lt;code&gt;type&lt;/code&gt; miembro nombra el mismo tipo que &lt;code&gt;T0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b493ffdbed7ccd8ccc482ba14060e9c250b436b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; if it exists; otherwise there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;sizeof...(T)&lt;/code&gt; es uno (es decir, &lt;code&gt;T...&lt;/code&gt; contiene solo un tipo &lt;code&gt;T0&lt;/code&gt; ), el &lt;code&gt;type&lt;/code&gt; miembro nombra el mismo tipo que &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; si existe; de lo contrario no hay &lt;code&gt;type&lt;/code&gt; miembro .</target>
        </trans-unit>
        <trans-unit id="05312f022c61c0809a5b4f6761df43d1433c8e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains exactly two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;),</source>
          <target state="translated">Si &lt;code&gt;sizeof...(T)&lt;/code&gt; es dos (es decir, &lt;code&gt;T...&lt;/code&gt; contiene exactamente dos tipos &lt;code&gt;T1&lt;/code&gt; y &lt;code&gt;T2&lt;/code&gt; ),</target>
        </trans-unit>
        <trans-unit id="a9203e749bb438b9fb18b3027d7cd1938fde1b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;):</source>
          <target state="translated">Si &lt;code&gt;sizeof...(T)&lt;/code&gt; es dos (es decir, &lt;code&gt;T...&lt;/code&gt; contiene dos tipos &lt;code&gt;T1&lt;/code&gt; y &lt;code&gt;T2&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="003d0981a91b043f4c661755c19594dc3f2d5e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is zero, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;sizeof...(T)&lt;/code&gt; es cero, no hay ning&amp;uacute;n &lt;code&gt;type&lt;/code&gt; miembro .</target>
        </trans-unit>
        <trans-unit id="6e9a3b7bb26a60d38196ba47db1b4041c4e0a434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; or if any of the types in &lt;code&gt;Types&lt;/code&gt; is not a complete object type, the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; o si alguno de los tipos en &lt;code&gt;Types&lt;/code&gt; no es un tipo de objeto completo, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="4072b39e3de9b56d51b28e74e4a293634d9f7558" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp&lt;/code&gt; was not obtained by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;seekpos()&lt;/code&gt; on the same file, the behavior is undefined.</source>
          <target state="translated">Si no se obtuvo &lt;code&gt;sp&lt;/code&gt; llamando a &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;seekpos()&lt;/code&gt; en el mismo archivo, el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="546524cf93679255723e493223804c25db718c37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">Si se llama a &lt;code&gt;std::abs&lt;/code&gt; con un argumento de tipo &lt;code&gt;X&lt;/code&gt; ,de modo que &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;X&lt;/code&gt; no se puede convertir a &lt;code&gt;int&lt;/code&gt; por &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;promoci&amp;oacute;n integral&lt;/a&gt; , el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="feba3c26477487c1b1931e01bd15bdc0fb928819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_and&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="translated">Si &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; no &lt;code&gt;fetch_and&lt;/code&gt; miembro fetch_and (este miembro solo se proporciona para &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;tipos integrales&lt;/a&gt; ), el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="88a445f32dd035df709cb7b01fefe9115a63d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_xor&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="translated">Si &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; no &lt;code&gt;fetch_xor&lt;/code&gt; miembro fetch_xor (este miembro solo se proporciona para &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;tipos integrales&lt;/a&gt; ), el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="def722711403d134b11c7d54af7e5b4d9abce392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::consume_header&lt;/code&gt; is not selected when reading a file beginning with byte order mark, the Unicode character U+FEFF (Zero width non-breaking space) will be read as the first character of the string content.</source>
          <target state="translated">Si &lt;code&gt;std::consume_header&lt;/code&gt; no est&amp;aacute; seleccionado al leer un archivo que comienza con la marca de orden de bytes, el car&amp;aacute;cter Unicode U + FEFF (espacio sin interrupci&amp;oacute;n de ancho cero) se leer&amp;aacute; como el primer car&amp;aacute;cter del contenido de la cadena.</target>
        </trans-unit>
        <trans-unit id="d3cb249ea0f28d0b2a75ca2a7f403cf2a7474c16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; is a reference, this is the rvalue reference version of the same type. Otherwise (such as if the wrapped iterator returns by value), this is &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; unchanged</source>
          <target state="translated">Si &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; es una referencia, esta es la versi&amp;oacute;n de referencia rvalue del mismo tipo. De lo contrario (como si el iterador envuelto vuelve por valor), esto es &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; sin cambios</target>
        </trans-unit>
        <trans-unit id="949f1f6e0f15336724ef8f4cda94b4e5b055d867" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;std::wcstok&lt;/code&gt; for this particular wide string. The function searches for the first wide character which is</source>
          <target state="translated">Si &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , la llamada se trata como la primera llamada a &lt;code&gt;std::wcstok&lt;/code&gt; para esta cadena ancha en particular. La funci&amp;oacute;n busca el primer car&amp;aacute;cter ancho que es</target>
        </trans-unit>
        <trans-unit id="919d8cd3a8b53f2e18bf07280d97eede84dc299d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;strtok&lt;/code&gt; for this particular string. The function searches for the first character which is</source>
          <target state="translated">Si &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , la llamada se trata como la primera llamada a &lt;code&gt;strtok&lt;/code&gt; para esta cadena en particular. La funci&amp;oacute;n busca el primer car&amp;aacute;cter que es</target>
        </trans-unit>
        <trans-unit id="98634ae53f4036b3363ce6cbf8811e0fd64f6b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;std::wcstok&lt;/code&gt;: the function continues from where it left in previous invocation with the same &lt;code&gt;*ptr&lt;/code&gt;. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , la llamada se trata como llamadas posteriores a &lt;code&gt;std::wcstok&lt;/code&gt; : la funci&amp;oacute;n contin&amp;uacute;a desde donde se dej&amp;oacute; en la invocaci&amp;oacute;n anterior con el mismo &lt;code&gt;*ptr&lt;/code&gt; . El comportamiento es el mismo que si el puntero al car&amp;aacute;cter ancho que sigue al &amp;uacute;ltimo token detectado se pase como &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66ec70311bf6aedd6bdb60bbe9f819c870804830" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;strtok&lt;/code&gt;: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; , la llamada se trata como llamadas posteriores a &lt;code&gt;strtok&lt;/code&gt; : la funci&amp;oacute;n contin&amp;uacute;a desde donde se dej&amp;oacute; en la invocaci&amp;oacute;n anterior. El comportamiento es el mismo que si el puntero almacenado anteriormente se pasara como &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f00ca1c926f1dd5787b11275ecdbddb1666242a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; equals &lt;code&gt;str.internal&lt;/code&gt;, the fill characters are inserted where &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;space&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">Si &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; es igual a &lt;code&gt;str.internal&lt;/code&gt; , los caracteres de relleno se insertan donde &lt;code&gt;none&lt;/code&gt; aparece ninguno o &lt;code&gt;space&lt;/code&gt; en el patr&amp;oacute;n de formato.</target>
        </trans-unit>
        <trans-unit id="1fa5ee33bcecc47b8c59730282fe17b184cd0916" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; is non-zero (the &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; manipulator was used), then the currency symbol or string is generated by calling &lt;code&gt;mp.curr_symbol()&lt;/code&gt; and placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">Si &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; no es cero ( se utiliz&amp;oacute; el manipulador &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; ), entonces el s&amp;iacute;mbolo de moneda o cadena se genera llamando a &lt;code&gt;mp.curr_symbol()&lt;/code&gt; y se coloca en la secuencia de salida donde aparece el &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; en El patr&amp;oacute;n de formato.</target>
        </trans-unit>
        <trans-unit id="1f05ec444fc20459f458416318c1d398ea88ac26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.width()&lt;/code&gt; is non-zero (e.g. &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; was just used) and the number of CharT's after Stage 2 is less than &lt;code&gt;str.width()&lt;/code&gt;, then copies of the &lt;code&gt;fill&lt;/code&gt; character are inserted at the position indicated by padding to bring the length of the sequence to &lt;code&gt;str.width()&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;str.width()&lt;/code&gt; no es cero (p. Ej., &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; se acaba de usar) y el n&amp;uacute;mero de caracteres tras la Etapa 2 es menor que &lt;code&gt;str.width()&lt;/code&gt; , entonces se insertan copias del car&amp;aacute;cter de &lt;code&gt;fill&lt;/code&gt; en la posici&amp;oacute;n indicada por relleno para llevar la longitud de la secuencia a &lt;code&gt;str.width()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4dee41190e5faa1ca923bd889668d6289ee307f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stream&lt;/code&gt; is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</source>
          <target state="translated">Si la &lt;code&gt;stream&lt;/code&gt; es un puntero nulo, todas las secuencias de salida abiertas se vac&amp;iacute;an, incluidas las manipuladas dentro de los paquetes de la biblioteca o de lo contrario no son directamente accesibles para el programa.</target>
        </trans-unit>
        <trans-unit id="86e307545d5f002abef118325d5d3eb89a16b86d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt;, the result is finite.</source>
          <target state="translated">Si &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt; , el resultado es finito.</target>
        </trans-unit>
        <trans-unit id="a189eebdd38827d96375b30f0eca568ef1adf1d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 0&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;t == 0&lt;/code&gt; , el resultado es igual a &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcbb6f49ce7e941481d92cd71eec73b19dcdaf2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 1&lt;/code&gt;, the result is equal to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;t == 1&lt;/code&gt; , el resultado es igual a &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35800f7e22639b64ad669cbfd0243c9e80c3180f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;(*t1).*f&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;t1&lt;/code&gt; no satisface los elementos anteriores, entonces &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; es equivalente a &lt;code&gt;(*t1).*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f9a950127cdac35950e54e7e7f5e552a16d7cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;t1&lt;/code&gt; no satisface los elementos anteriores, entonces &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; es equivalente a &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="996fc7fea5a596a0a7f8caf3724383378f3397b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;rv&lt;/code&gt; do not refer to the same object , the value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the assignment.</source>
          <target state="translated">Si &lt;code&gt;t&lt;/code&gt; y &lt;code&gt;rv&lt;/code&gt; no se refieren al mismo objeto, el valor de &lt;code&gt;t&lt;/code&gt; es equivalente al valor de &lt;code&gt;rv&lt;/code&gt; antes de la asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="70f1cc8280f18381cdb55a983658d6c5ccf12f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; represents a time point during a leap second insertion, the last representable value of &lt;code&gt;sys_time&lt;/code&gt; prior to the insertion of the leap second is returned. In all other cases, &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;t&lt;/code&gt; representa un punto de tiempo durante una inserci&amp;oacute;n de segundo &lt;code&gt;sys_time&lt;/code&gt; el &amp;uacute;ltimo valor representable de sys_time antes de la inserci&amp;oacute;n del segundo intercalar . En todos los dem&amp;aacute;s casos, &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94842a48923ccea749a7b322cc54918cec93ee9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tbl&lt;/code&gt; is null, &lt;code&gt;classic_table()&lt;/code&gt; is used by all classification member functions. Otherwise, &lt;code&gt;tbl&lt;/code&gt; must be a pointer to the first element of an array of masks, at least &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; in size, and that array is used by all of this facet's classification member functions.</source>
          <target state="translated">Si &lt;code&gt;tbl&lt;/code&gt; es nulo, todas las funciones miembro de clasificaci&amp;oacute;n usan &lt;code&gt;classic_table()&lt;/code&gt; . De lo contrario, &lt;code&gt;tbl&lt;/code&gt; debe ser un puntero al primer elemento de una matriz de m&amp;aacute;scaras, al menos &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; en tama&amp;ntilde;o, y esa matriz es utilizada por todas las funciones miembro de clasificaci&amp;oacute;n de esta faceta.</target>
        </trans-unit>
        <trans-unit id="60c9f234140c969280e37d90ead363e725f41fef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt;, may throw any exception thrown by &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; with i being index().</source>
          <target state="translated">Si &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt; , puede lanzar cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; siendo i index ()</target>
        </trans-unit>
        <trans-unit id="b62e0ed67d83925a4f019bee274f6aaf3d721d41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;time_point&lt;/code&gt; has lower precision, it is implementation defined whether the value is rounded or truncated.</source>
          <target state="translated">Si &lt;code&gt;time_point&lt;/code&gt; tiene menor precisi&amp;oacute;n, su implementaci&amp;oacute;n se define si el valor es redondeado o truncado.</target>
        </trans-unit>
        <trans-unit id="f39154959538bec12350c40feb86c48847d93013" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;timeout_duration&lt;/code&gt; es menor o igual que &lt;code&gt;timeout_duration.zero()&lt;/code&gt; , la funci&amp;oacute;n se comporta como &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08ae6a5e709170320f3bb275e55a3ea39cb81509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;timeout_duration&lt;/code&gt; es menor o igual que &lt;code&gt;timeout_duration.zero()&lt;/code&gt; , la funci&amp;oacute;n se comporta como &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94988ecccf327007cfe6e9600377b3a54d244a96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;timeout_time&lt;/code&gt; ya ha pasado, esta funci&amp;oacute;n se comporta como &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91299d6184527b913bd3a4c6c83fcc921365520d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;timeout_time&lt;/code&gt; ya ha pasado, esta funci&amp;oacute;n se comporta como &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="985b3af9a0f9c066a712acb80e6a80e55df51846" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to&lt;/code&gt; does not exist, first executes &lt;code&gt;create_directory(to, from)&lt;/code&gt; (creates the new directory with a copy of the old directory's attributes)</source>
          <target state="translated">Si &lt;code&gt;to&lt;/code&gt; no existe, primero ejecuta &lt;code&gt;create_directory(to, from)&lt;/code&gt; (crea el nuevo directorio con una copia de los atributos del directorio anterior)</target>
        </trans-unit>
        <trans-unit id="869575bcc3b25a2f60e9720ddcdac4374d7f2bc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time between two UTC &lt;code&gt;time_point&lt;/code&gt;s, those two &lt;code&gt;time_point&lt;/code&gt;s will be the same, and that &lt;code&gt;time_point&lt;/code&gt; will be returned.</source>
          <target state="translated">Si &lt;code&gt;tp&lt;/code&gt; representa un tiempo inexistente entre dos UTC &lt;code&gt;time_point&lt;/code&gt; s, esos dos &lt;code&gt;time_point&lt;/code&gt; s ser&amp;aacute;n iguales y se &lt;code&gt;time_point&lt;/code&gt; ese time_point .</target>
        </trans-unit>
        <trans-unit id="b14c2985a9828fa673de15ad4b5432c7eec337ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Si &lt;code&gt;try_lock()&lt;/code&gt; tiene &amp;eacute;xito, operaciones anteriores de &lt;code&gt;unlock()&lt;/code&gt; en el mismo objeto</target>
        </trans-unit>
        <trans-unit id="f68c72d2cc410f03ed4771fd243cfec6c94f974e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;try_lock&lt;/code&gt; es llamado por un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; en cualquier modo (compartido o exclusivo), el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="2bcbd407f9c0eff5a0a0eb82929bbebd2a38ec19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Si un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; llama a &lt;code&gt;try_lock&lt;/code&gt; , el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="332a65a0871564214a2da39082b39ae682472b5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Si &lt;code&gt;try_lock_for(duration)&lt;/code&gt; tiene &amp;eacute;xito, operaciones anteriores de &lt;code&gt;unlock()&lt;/code&gt; en el mismo objeto</target>
        </trans-unit>
        <trans-unit id="57e45d172606dd71b8ad2f147535c7a9c26b7b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Si un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; en cualquier modo (compartido o exclusivo) llama a &lt;code&gt;try_lock_for&lt;/code&gt; , el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="e2913e9dfd8101ebfeeca847b3fbb13f36f0e999" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Si &lt;code&gt;try_lock_for&lt;/code&gt; es invocado por un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="3e3938b542994009b61584f5206da7eb84b567ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Si &lt;code&gt;try_lock_shared()&lt;/code&gt; tiene &amp;eacute;xito, operaciones anteriores de &lt;code&gt;unlock()&lt;/code&gt; en el mismo objeto</target>
        </trans-unit>
        <trans-unit id="88e17bb477f3b0dc9840117e325cc5419c64d635" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Si &lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; tiene &amp;eacute;xito, operaciones anteriores de &lt;code&gt;unlock()&lt;/code&gt; en el mismo objeto</target>
        </trans-unit>
        <trans-unit id="3cb436a54d222a2207a53f9e58e0c49e9a0e682d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Si un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; en cualquier modo (compartido o exclusivo) llama a &lt;code&gt;try_lock_shared_for&lt;/code&gt; , el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="2b4a06da759220650268238bcf1faa9bc1408f74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Si &lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; tiene &amp;eacute;xito, operaciones anteriores de &lt;code&gt;unlock()&lt;/code&gt; en el mismo objeto</target>
        </trans-unit>
        <trans-unit id="2b919196e38c014769e5a77c9fece0fc9c129522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Si un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; en cualquier modo (compartido o exclusivo) llama a &lt;code&gt;try_lock_shared_until&lt;/code&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="bd2e7ac4f22bfd95548a0a07a00613e5cf96f270" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">Si &lt;code&gt;try_lock_until(time_point)&lt;/code&gt; tiene &amp;eacute;xito, operaciones anteriores de &lt;code&gt;unlock()&lt;/code&gt; en el mismo objeto</target>
        </trans-unit>
        <trans-unit id="ee385f3e6edb77e1716bf26ec86831203e82ffc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">Si un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; en cualquier modo (compartido o exclusivo) llama a &lt;code&gt;try_lock_until&lt;/code&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="a43b3e939093abea19b584b116c2b4c2095ef181" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Si un hilo que ya posee el &lt;code&gt;mutex&lt;/code&gt; llama a &lt;code&gt;try_lock_until&lt;/code&gt; , el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="5c29403a2f55f94d0b6bdf83a06a0e7ac5dae5f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an array type, all dimensions other than the first must be specified as positive &lt;a href=&quot;constant_expression&quot;&gt;integral constant expression&lt;/a&gt;(until C++14)&lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;(since C++14), but the first dimension may be any expression convertible to &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;. This is the only way to directly create an array with size defined at runtime, such arrays are often referred to as</source>
          <target state="translated">Si &lt;code&gt;type&lt;/code&gt; es un tipo de matriz, todas las dimensiones que no sean la primera deben especificarse como &lt;a href=&quot;constant_expression&quot;&gt;expresi&amp;oacute;n constante integral&lt;/a&gt; positiva (hasta C ++ 14) &lt;a href=&quot;constant_expression&quot;&gt;convertida como expresi&amp;oacute;n constante&lt;/a&gt; de tipo &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; (desde C ++ 14), pero la primera dimensi&amp;oacute;n puede ser cualquier expresi&amp;oacute;n convertible a &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; . Esta es la &amp;uacute;nica forma de crear directamente una matriz con un tama&amp;ntilde;o definido en tiempo de ejecuci&amp;oacute;n, tales matrices a menudo se denominan</target>
        </trans-unit>
        <trans-unit id="987dae04e3210104881f78fd36a73b5af3bafb97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not a &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;standard layout type&lt;/a&gt;, the behavior is undefined(until C++17)use of the &lt;code&gt;offsetof&lt;/code&gt; macro is conditionally-supported(since C++17).</source>
          <target state="translated">Si &lt;code&gt;type&lt;/code&gt; no es un &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;tipo de dise&amp;ntilde;o est&amp;aacute;ndar&lt;/a&gt; , el comportamiento es indefinido (hasta C ++ 17) el uso de la &lt;code&gt;offsetof&lt;/code&gt; macro es condicionalmente compatible (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="8b86993c41ea614db0c1542ae39296df1802bd91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeid&lt;/code&gt; is used on an object under construction or destruction (in a destructor or in a constructor, including constructor's &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt; or &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;), then the &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object referred to by this &lt;code&gt;typeid&lt;/code&gt; represents the class that is being constructed or destroyed even if it is not the most-derived class.</source>
          <target state="translated">Si &lt;code&gt;typeid&lt;/code&gt; se usa en un objeto en construcci&amp;oacute;n o destrucci&amp;oacute;n (en un destructor o en un constructor, incluida la &lt;a href=&quot;constructor&quot;&gt;lista de inicializadores&lt;/a&gt; del constructor o &lt;a href=&quot;data_members#Member_initialization&quot;&gt;los inicializadores de miembros predeterminados&lt;/a&gt; ), el objeto &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; que hace referencia este &lt;code&gt;typeid&lt;/code&gt; representa la clase que se est&amp;aacute; construyendo o destruido incluso si no es la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="2c8bc9e007e9eab3e896a3aaff472ee164636be8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetc&lt;/code&gt; were performed, read operations retrieve the pushed-back characters in reverse order of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">Si se llama a &lt;code&gt;ungetc&lt;/code&gt; m&amp;aacute;s de una vez sin una lectura o reposicionamiento intermedio, puede fallar (en otras palabras, se garantiza un b&amp;uacute;fer de retroceso de tama&amp;ntilde;o 1, pero cualquier b&amp;uacute;fer m&amp;aacute;s grande est&amp;aacute; definido por la implementaci&amp;oacute;n). Si se realizaron varios &lt;code&gt;ungetc&lt;/code&gt; exitosos , las operaciones de lectura recuperan los caracteres rechazados en orden inverso a &lt;code&gt;ungetc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b93c880a13d41dd5f02146648e0bcdb941ad4432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetwc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetwc&lt;/code&gt; were performed, read operations retrieve the pushed-back wide characters in reverse order of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ungetwc&lt;/code&gt; se llama m&amp;aacute;s de una vez sin una lectura o reposicionamiento intermedio, puede fallar (en otras palabras, se garantiza un b&amp;uacute;fer de retroceso de tama&amp;ntilde;o 1, pero cualquier b&amp;uacute;fer m&amp;aacute;s grande est&amp;aacute; definido por la implementaci&amp;oacute;n). Si se realizaron m&amp;uacute;ltiples &lt;code&gt;ungetwc&lt;/code&gt; exitosas de ungetwc , las operaciones de lectura recuperan los caracteres anchos empujados hacia atr&amp;aacute;s en el orden inverso de &lt;code&gt;ungetwc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e79c0c8a7bbdaf2db59b21cc3df9306376d12ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;using: namespace&lt;/code&gt; appears in the beginning of an attribute list, no other attributes in the attribute list can specify a namespace: the namespace specified in a using applies to them all:</source>
          <target state="translated">Si &lt;code&gt;using: namespace&lt;/code&gt; aparece al comienzo de una lista de atributos, ning&amp;uacute;n otro atributo en la lista de atributos puede especificar un espacio de nombres: el espacio de nombres especificado en un uso se aplica a todos ellos:</target>
        </trans-unit>
        <trans-unit id="08c3c3c90c1cbb009889979159acc6ccce066254" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">Si &lt;code&gt;v.index() != w.index()&lt;/code&gt; , devuelve &lt;code&gt;false&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="73386b30a8cd9063a65cadd69c4f27f4b4729d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Si &lt;code&gt;v.index() != w.index()&lt;/code&gt; , devuelve &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="60664f03dd91064cc8bcd5281122b9be42c2ecf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">Si &lt;code&gt;v.valueless_by_exception()&lt;/code&gt; , devuelve &lt;code&gt;false&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="056416cb18ca600a6a47288399d10085b1d96979" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Si &lt;code&gt;v.valueless_by_exception()&lt;/code&gt; , devuelve &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="c3e0828292e64efc70577bb97a628f74f2c468ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; compares equivalent to either bound, returns a reference to &lt;code&gt;v&lt;/code&gt;, not the bound.</source>
          <target state="translated">Si &lt;code&gt;v&lt;/code&gt; se compara equivalente a cualquier l&amp;iacute;mite, devuelve una referencia a &lt;code&gt;v&lt;/code&gt; , no el l&amp;iacute;mite.</target>
        </trans-unit>
        <trans-unit id="75a090849c6c030efd853b2c4e1bec200144bf8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;va_arg&lt;/code&gt; is called when there are no more arguments in &lt;code&gt;ap&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Si se llama a &lt;code&gt;va_arg&lt;/code&gt; cuando no hay m&amp;aacute;s argumentos en &lt;code&gt;ap&lt;/code&gt; , el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="adb7aa1f42112a75264739ee28d6e8827e04fc33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">Si &lt;code&gt;w.valueless_by_exception()&lt;/code&gt; , devuelve &lt;code&gt;false&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="1ec2d68dd14c2554d3c630fe1822a69b8ee574f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Si &lt;code&gt;w.valueless_by_exception()&lt;/code&gt; , devuelve &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="4a2e019de572732991114a4b9ac83594fefd4e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wc&lt;/code&gt; is the null character, the null byte is written to &lt;code&gt;s&lt;/code&gt;, preceded by any shift sequences necessary to restore the initial shift state.</source>
          <target state="translated">Si &lt;code&gt;wc&lt;/code&gt; es el car&amp;aacute;cter nulo, el byte nulo se escribe en &lt;code&gt;s&lt;/code&gt; , precedido por cualquier secuencia de cambio necesaria para restaurar el estado de cambio inicial.</target>
        </trans-unit>
        <trans-unit id="2df38e58a0b81e321cbdefacc5fbfee02970c44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading (that is, if &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt;), then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="translated">Si lo &lt;code&gt;which&lt;/code&gt; incluye &lt;code&gt;ios_base::in&lt;/code&gt; y este b&amp;uacute;fer est&amp;aacute; abierto para lectura (es decir, if &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt; ), reposiciona el puntero de lectura &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; dentro del obtener el &amp;aacute;rea como se describe a continuaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="076480d9e864ea3eea8105519a4f861e38abff0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading, then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="translated">Si lo &lt;code&gt;which&lt;/code&gt; incluye &lt;code&gt;ios_base::in&lt;/code&gt; y este b&amp;uacute;fer est&amp;aacute; abierto para lectura, entonces reposiciona el puntero de lectura &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; dentro del &amp;aacute;rea de obtenci&amp;oacute;n como se describe a continuaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="412981fa397417a50c5b81ce7315076f976f90c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing (that is, &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt;), then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="translated">Si lo &lt;code&gt;which&lt;/code&gt; incluye &lt;code&gt;ios_base::out&lt;/code&gt; y este b&amp;uacute;fer est&amp;aacute; abierto para escritura (es decir, &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt; ), luego reposiciona el puntero de escritura &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; dentro del &amp;aacute;rea de venta como se describe abajo</target>
        </trans-unit>
        <trans-unit id="ebb77a9083ead2007e8eed624a96ab97b1b10e5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing, then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="translated">Si lo &lt;code&gt;which&lt;/code&gt; incluye &lt;code&gt;ios_base::out&lt;/code&gt; y este b&amp;uacute;fer est&amp;aacute; abierto para escritura, reposiciona el puntero de escritura &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; dentro del &amp;aacute;rea de colocaci&amp;oacute;n como se describe a continuaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="32ac61f3d8f163e81b3115553fcd68a7ebccec80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing (&lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt;), and &lt;code&gt;dir&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="translated">Si &lt;code&gt;which&lt;/code&gt; incluye tanto &lt;code&gt;ios_base::in&lt;/code&gt; como &lt;code&gt;ios_base::out&lt;/code&gt; y el b&amp;uacute;fer est&amp;aacute; abierto tanto para leer como para escribir ( &lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt; ), y &lt;code&gt;dir&lt;/code&gt; es &lt;code&gt;ios_base::beg&lt;/code&gt; o &lt;code&gt;ios_base::end&lt;/code&gt; , luego reposiciona los punteros de lectura y escritura como se describe a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d56bcb44c21f33d202f66d86615b3fd4c47e7a59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing, and &lt;code&gt;when&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="translated">Si lo &lt;code&gt;which&lt;/code&gt; incluye &lt;code&gt;ios_base::in&lt;/code&gt; y &lt;code&gt;ios_base::out&lt;/code&gt; y el b&amp;uacute;fer est&amp;aacute; abierto tanto para lectura como para escritura, y &lt;code&gt;when&lt;/code&gt; es &lt;code&gt;ios_base::beg&lt;/code&gt; o &lt;code&gt;ios_base::end&lt;/code&gt; , reposiciona los punteros de lectura y escritura como se describe a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9292e4a3413eb133a7f76bc6e4fe74a238c5b8bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, domain error</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; son ambos cero, error de dominio</target>
        </trans-unit>
        <trans-unit id="8a5e321969b66fbefa9cdd24eacf386b98fffc2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, range error does not occur either</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; son ambos cero, tampoco se produce un error de rango</target>
        </trans-unit>
        <trans-unit id="1a0e37c7feac7db699e4130a50b199ceedd910f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;y&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &amp;plusmn; &amp;infin; e &lt;code&gt;y&lt;/code&gt; no es NaN, se devuelve NaN y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8abb2fb48327f23dca2adde7572dddc2e811ad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, &amp;plusmn;0 is returned, and &amp;plusmn;&amp;infin; is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &amp;plusmn; &amp;infin;, se devuelve &amp;plusmn; 0 y se almacena &amp;plusmn; &amp;infin; en &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b9e315fe80911902dd03d84688ec8a34941e551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &amp;plusmn; &amp;infin;, se devuelve, sin modificar</target>
        </trans-unit>
        <trans-unit id="0d517d0ca1b88b420f9a711836c289f554f6f27a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;y&lt;/code&gt; is not zero, &amp;plusmn;0 is returned</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &amp;plusmn; 0 e &lt;code&gt;y&lt;/code&gt; no es cero, se devuelve &amp;plusmn; 0</target>
        </trans-unit>
        <trans-unit id="dcd1a0509c1e6bf68cbedd9162ffec0cc1242173" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;0 is returned, and &amp;plusmn;0 is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &amp;plusmn; 0, se devuelve &amp;plusmn; 0 y se almacena &amp;plusmn; 0 en &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb707c1e458814fee624b6c9deb60721133b5b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &amp;plusmn; 0, se devuelve, sin modificar</target>
        </trans-unit>
        <trans-unit id="f41dcbd3d46c8769c4b2fb80c374a0e5c0d62c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is negative, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;&amp;plusmn;0&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; es negativo, se devuelve &lt;code&gt;-&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6968a9e1c046845040fc68d63a376b5e6b8b85a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is positive, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;&amp;plusmn;0&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; es positivo, se devuelve &lt;code&gt;+&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="742021246f19681537f6e140bb629b64b21e4348" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-0&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;+&amp;infin;&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; es finito y negativo, se devuelve &lt;code&gt;-0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="854f55847c1c8f45111c844b75fe0c4c049cc744" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+0&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;+&amp;infin;&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; es finito y positivo, se devuelve &lt;code&gt;+0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70312266975b00e8f11c41c1477d3626e83ccaa9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;-&amp;infin;&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; es finito y negativo, se devuelve &lt;code&gt;-&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adfdc77216731e53faa0611a28dda473ddae36f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;-&amp;infin;&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; es finito y positivo, se devuelve &lt;code&gt;+&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c80b06556a1152fcb8c22f136b6473885d57b346" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es NaN, se devuelve NaN</target>
        </trans-unit>
        <trans-unit id="226af42b45e3a0a3b2917fd765deb1015d6b2d9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned, and NaN is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es NaN, se devuelve NaN y NaN se almacena en &lt;code&gt;*iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86712aaf103771c2d7819baa87af27b031d94ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, then NaN with the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es NaN, entonces se devuelve NaN con el signo de &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0446e18a46c6733752844d64ec7ed2bde15bde6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is negative, a domain error may occur</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es negativo, puede ocurrir un error de dominio</target>
        </trans-unit>
        <trans-unit id="0d4fee627ff864097e3bcf0e10e6f4e13892a483" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is zero, returns zero.</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; no es cero, calcula la mayor potencia integral de dos que no es mayor que &lt;code&gt;x&lt;/code&gt; . Si &lt;code&gt;x&lt;/code&gt; es cero, devuelve cero.</target>
        </trans-unit>
        <trans-unit id="2a471c8ab6033df659f209b9c95baa221163a386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the number of bits needed to store the value &lt;code&gt;x&lt;/code&gt;, that is, \(1 + \lfloor log_2(x) \rfloor\)1 + floor(log</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; no es cero, calcula el n&amp;uacute;mero de bits necesarios para almacenar el valor &lt;code&gt;x&lt;/code&gt; , es decir, \ (1 + \ lfloor log_2 (x) \ rfloor \) 1 + floor (log</target>
        </trans-unit>
        <trans-unit id="e48634bd82e2df6f62aec245642cb59777238384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es &amp;plusmn; &amp;infin; &lt;code&gt;x&lt;/code&gt; es finito, &lt;code&gt;x&lt;/code&gt; se devuelve.</target>
        </trans-unit>
        <trans-unit id="a2ddc1042c63e353212b7799d89a1b092aed734a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;x&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es &amp;plusmn; 0 &lt;code&gt;x&lt;/code&gt; no es NaN, se devuelve NaN y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c4d4232381ec31f82701b3b12b902639c119342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es -0, el resultado solo es negativo si la implementaci&amp;oacute;n admite el cero con signo de manera consistente en operaciones aritm&amp;eacute;ticas.</target>
        </trans-unit>
        <trans-unit id="bb77d357b03480982a5cb3af7fe4d1a54b4629b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;+&amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; se devuelve</target>
        </trans-unit>
        <trans-unit id="c32d4c116dec5e5a3f5f016622351bfcdbb1d9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; es &lt;code&gt;-&amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; se devuelve</target>
        </trans-unit>
        <trans-unit id="f2d2be60f0f9dee6ef4e60532e876177666a7509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; es finito, &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; se devuelve</target>
        </trans-unit>
        <trans-unit id="04ca9c751f9bab309085f696c5ce7e061eb53bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is negative or &lt;code&gt;-0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es &lt;code&gt;&amp;plusmn;0&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; es negativo o &lt;code&gt;-0&lt;/code&gt; , &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; se devuelve</target>
        </trans-unit>
        <trans-unit id="6c2e024aa12ac316eec5865ba0f65ada4018df50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is positive or &lt;code&gt;+0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;0&lt;/code&gt; is returned</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es &lt;code&gt;&amp;plusmn;0&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; es positivo o &lt;code&gt;+0&lt;/code&gt; , &lt;code&gt;&amp;plusmn;0&lt;/code&gt; se devuelve</target>
        </trans-unit>
        <trans-unit id="db8ff25a6b35fd58c6e2ad1d8257aa1fdbbc1afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, but the domain error does not occur, zero is returned.</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es cero, pero no se produce el error de dominio, se devuelve cero.</target>
        </trans-unit>
        <trans-unit id="934c80b3e977f6c9efabb47ff6836e6a1d4145a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, pole error does not occur</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es cero, no se produce un error de polo</target>
        </trans-unit>
        <trans-unit id="d5af0b5b04311e67b5c965ddebdd4dcbe743ea19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, the value stored in &lt;code&gt;*quo&lt;/code&gt; is unspecified.</source>
          <target state="translated">Si &lt;code&gt;y&lt;/code&gt; es cero, el valor almacenado en &lt;code&gt;*quo&lt;/code&gt; no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="687d9b31d16e817da643762a7f7e3d0c38df64e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt;, returns the earlier &lt;code&gt;sys_time&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt; &lt;code&gt;sys_time&lt;/code&gt; , devuelve el sys_time anterior .</target>
        </trans-unit>
        <trans-unit id="966a406501614a5b1c8f3e06813bd52dd307c0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt;, returns the later &lt;code&gt;sys_time&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt; , devuelve el &lt;code&gt;sys_time&lt;/code&gt; posterior</target>
        </trans-unit>
        <trans-unit id="7157b6daee7178a7db7bf2b7f98b21bf5509b46f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="647d48a9a025440a82db0559ba003eb986c87f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; (el signo de la parte imaginaria no est&amp;aacute; especificado)</target>
        </trans-unit>
        <trans-unit id="5a29bd926acd8a4ed08d36ea492ffa17b0f65b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d01365aea17ec2d928785c236cc8a0625a50a091" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aca45f2c4af7ce54c221c839224dcc7526370cce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(+0,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b21cb1c0525d180376e59f65f141faac479dcda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2af12e24fdf73967ee7ab61f7c4d443b37739feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b917afe8309bdfdc0889e4ce326dd3daf35a1e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc20a1d28cbfd032ecdaa31a57f9d5ee6abc083b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (el signo de la parte real no est&amp;aacute; especificado) y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; se eleva</target>
        </trans-unit>
        <trans-unit id="349b76e235126b678fc00eb96b36b916c8c7d87d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised (the sign of the real part is unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; (el signo de la parte real no est&amp;aacute; especificado)</target>
        </trans-unit>
        <trans-unit id="6a80692535fb97c3bb378cc0e2235f9e6f89868d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="992a6280563e8dfa9fd680864cf94914e2af8168" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02e1613ba0e3f7e9f51fc7723495ad1862a78f76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (el signo de la parte imaginaria no est&amp;aacute; especificado)</target>
        </trans-unit>
        <trans-unit id="dc7e1f5800458c8b0514039db23f6f89349f39ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4153d9975c2c48f8bb5202575acc2cae61f572c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (el signo de la parte real no est&amp;aacute; especificado)</target>
        </trans-unit>
        <trans-unit id="eedb8eec778280d3bcff49c582c5fed9ffc52c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7210962b1c353ac908b8a5cf3e83977c0e1052f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(+0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9373e34e81874d8368cad6f4032f12ba748b7b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (el signo de la parte imaginaria no est&amp;aacute; especificado)</target>
        </trans-unit>
        <trans-unit id="856848cafe4c0e36a1ad5ce519dc2788d0c24266" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (para cualquier finito distinto de cero y), el resultado es &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38ca6940a23e8be06d24918b22d707bed394bbfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (para cualquier finito distinto de cero y), el resultado es &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60544872fb73c896e74dc8e5fa99009db9780c61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (para cualquier y positivo finito), el resultado es &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff767095e325e1b139eddcef254efda6cab9a363" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (para cualquier y positivo finito), el resultado es &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8364d367783724c998297e19343a0b6ad6b6639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (para cualquier y positivo finito), el resultado es &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22be3e2e16abf84434eed428b48e35f8cb791fa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (para cualquier finito positivo y), el resultado es &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d272464f92e06bbc97dc2b60b9f4b305f104403b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (para cualquier finito positivo y), el resultado es &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="306394ed21756723034bdce29c6c92e8e8f975e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (para cualquier finito positivo y), el resultado es &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0345ff8887f149be457a2b367cd95f127874bb66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; for finite positive y</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; , el resultado es &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; para positivo finito y</target>
        </trans-unit>
        <trans-unit id="c635e396c397df4cdf68d1595b6463d80b6d5785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; (el signo de la parte real no est&amp;aacute; especificado) y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; se eleva</target>
        </trans-unit>
        <trans-unit id="7380faae64287df92ea78c0159ffc49274893e26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (el signo de la parte imaginaria no est&amp;aacute; especificado) y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; se eleva</target>
        </trans-unit>
        <trans-unit id="36abdae4241c852caca11998cf42433abb16ad9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+0,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(+0,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2cc8f6469e515605e9eee8a893ab1a721067296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+0,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ad221569da1d5607bc6299fce77cb0f1118a11f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+0,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01db2d5ca8d8ffef07cf540c0e3df9bf5160209e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+0,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89130d186050c98271f4a5474781aa4fa940206d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+0,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(+0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a317cdc33ca73c93da608e61b3b7948bfa218f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+0,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (el signo de la parte imaginaria no est&amp;aacute; especificado)</target>
        </trans-unit>
        <trans-unit id="57dcd4bc678fdc22d1a23e97a110d173535b6bb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+1,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(+1,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="874f1995c8e575acb11421be6dbde7ae2969a42f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (los signos no est&amp;aacute;n especificados)</target>
        </trans-unit>
        <trans-unit id="6c365d4aa356678ae4b570fb49e375a4b4ceb0dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="253435ca3d0567f0dfee4d306973a5da37660409" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="579af3f5ca612edf51749805e68c03351cf80f69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (los signos no est&amp;aacute;n especificados)</target>
        </trans-unit>
        <trans-unit id="e78b08f96f6d2562376b89afa7f88fc21913df8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; (sign of imaginary part unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; (signo de parte imaginaria no especificado)</target>
        </trans-unit>
        <trans-unit id="65dfdfd349a76964ed4ba8c2ee003dcba4c70340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (para cualquier y positivo finito), el resultado es &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec76329fb7fb62b9dc71b27cfd5913208f8099b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;+0cis(y)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (para cualquier y finito), el resultado es &lt;code&gt;+0cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75ba7cf268eccbdbd782004a0e2520694fb11834" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (para cualquier y finito positivo), el resultado es &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3891fa076b6dcc15dfa77f17c6418c9b728c5090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (para cualquier y finito positivo), el resultado es &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56a1f4835fd2810bef4e8bc0c75c1db28c6329f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; for finite positive y</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; , el resultado es &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; para y positivo finito</target>
        </trans-unit>
        <trans-unit id="5e60ca2bf087c1d87278fedd358c4673cece7420" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(-0,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89a4a107a9008e545e92be5b1df1c9b5efa21860" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (el signo de la parte real no est&amp;aacute; especificado)</target>
        </trans-unit>
        <trans-unit id="c1290368fb01d308fdca78b212732f24bae238f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; (el signo de la parte real no est&amp;aacute; especificado)</target>
        </trans-unit>
        <trans-unit id="02167beb857a58577bc43d28d09747ed8b716cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f227ab1339277464e7e7720ba15b77847f3dc1c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03b1fb212963f9bff1e0e7f5ce1396cadd18c663" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (el signo de la parte imaginaria no est&amp;aacute; especificado)</target>
        </trans-unit>
        <trans-unit id="a0cec12a18e653673a21b6afcf4d2893eaec9952" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,+0)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,+0)&lt;/code&gt; , el resultado es &lt;code&gt;(NaN,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48695bc07467a1b54d439f25c1947991dce4e386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,+y)&lt;/code&gt; (para cualquier finito distinto de cero y), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; puede elevarse</target>
        </trans-unit>
        <trans-unit id="12d365d3a5d388624d62c5ea98bf5be25d94d436" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43432f0ad9333692ce4de812743b6a8a23d990f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,y)&lt;/code&gt; (para cualquier finito distinto de cero), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; puede elevarse</target>
        </trans-unit>
        <trans-unit id="a74898800da79711b4ca4b837358da0c34309906" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,y)&lt;/code&gt; (para cualquier finito y), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3986c3fa864e6dfc01234c2970facb3af69b5d42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,y)&lt;/code&gt; (para cualquier finito y), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18e3df5ba9c4d12bc748141c867a2ba815fd8273" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,y)&lt;/code&gt; (para cualquier no distinto de cero y), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b8c5fbb845c531633355abb0a0435a2ec8eaaf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,y)&lt;/code&gt; (para cualquier y distinto de cero), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29a55443041f03e5d510319aa0568a45742e55ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(NaN,y)&lt;/code&gt; , el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df2ad89444d23b170108bda8da8ca9ee00ba6c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (para cualquier x finito que no sea cero), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e455efcd2e392de8d756291014af13967751bf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite positive x), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (para cualquier x positivo finito), el resultado es &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a071dd3e0155d43198db5c9184d3f7c8860d00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (para cualquier x finita), el resultado es &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85ebcf7fb682a9f3ba15fca2bb16f8628b521d02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (para cualquier x finita), el resultado es &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a6ecedf7500b1db3b4febd7f8959d0c1390edf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (para cualquier x finita), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7886e26ae70e5250a1e0be3778e2c07bd58265c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (para cualquier x positivo finito), el resultado es &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa903ae726de223dfc94489d7c3a22ae1b23a345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (para cualquier x positivo finito), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22db9353e8948056621c723acfc1f37d717bc4e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (para cualquier &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; x finito), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0dc41eed06a38a2687f77d174ad8f99a0594fb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; even if x is NaN</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; , el resultado es &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; incluso si x es NaN</target>
        </trans-unit>
        <trans-unit id="e9108ce5453cd6b3af30a85d4f435185194ec60d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,NaN)&lt;/code&gt; (para cualquier x finito distinto de cero), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; puede elevarse</target>
        </trans-unit>
        <trans-unit id="9b6b50afd0ebe3c85bd3492ea56b4593b842689c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite nonzero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,NaN)&lt;/code&gt; (para cualquier finito distinto de cero x), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; puede elevarse</target>
        </trans-unit>
        <trans-unit id="204a160d7ec82f80677f4376caef794a23c51075" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,NaN)&lt;/code&gt; (para cualquier x finita), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b650f50d0ed443a6d100ac136e84b4b3bd34bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,NaN)&lt;/code&gt; (para cualquier x finita), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d3a8274e24f46eb6d9b27c393f4df139396e5ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any nonzero finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,NaN)&lt;/code&gt; (para cualquier x finito distinto de cero), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b70aa5296158a2ccd9b37fee97192ed5754e1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,NaN)&lt;/code&gt; (para cualquier x positivo finito), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de160560a0670a88a8b2426dbe34cfbd96bd8f64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,NaN)&lt;/code&gt; (para cualquier &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; x finito), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd01cea44335f9b94fea310daa7ab95e4c6b7953" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,NaN)&lt;/code&gt; (para cualquier &lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; x finito), el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; puede elevarse</target>
        </trans-unit>
        <trans-unit id="d668d6a37cc758c14994156de53988e57bc6b406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; (unless x is &amp;plusmn;&amp;infin;) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si &lt;code&gt;z&lt;/code&gt; es &lt;code&gt;(x,NaN)&lt;/code&gt; , el resultado es &lt;code&gt;(NaN,NaN)&lt;/code&gt; (a menos que x sea &amp;plusmn; &amp;infin;) y se pueda aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="074f956a744f2e0d54cbe071efce74d2c8aa0db4" translate="yes" xml:space="preserve">
          <source>If A was transformed from a function parameter pack, deduction fails.(until C++14) it is compared with each remaining parameter type of the parameter template.(since C++14).</source>
          <target state="translated">Si A fue transformado de un paquete de parámetros de función,la deducción falla.(hasta C++14)se compara con cada tipo de parámetro restante de la plantilla de parámetros.(desde C++14).</target>
        </trans-unit>
        <trans-unit id="e0371b0116f4a5b56551a65f008047322bafb01e" translate="yes" xml:space="preserve">
          <source>If C is not an initializer-list constructor and the initializer list has a single element of possibly cv-qualified X, the implicit conversion sequence has Exact Match rank. If the initializer list has a single element of possibly cv-qualified type derived from X, the implicit conversion sequence has Conversion rank. (note the difference from aggregates: aggregates initialize directly from single-element init lists before considering &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, non-aggregates consider initializer_list constructors before any other constructors)</source>
          <target state="translated">Si C no es un constructor de la lista de inicializadores y la lista de inicializadores tiene un solo elemento de X posiblemente calificado por cv, la secuencia de conversi&amp;oacute;n impl&amp;iacute;cita tiene un rango de coincidencia exacta. Si la lista de inicializadores tiene un &amp;uacute;nico elemento de tipo posiblemente calificado por cv derivado de X, la secuencia de conversi&amp;oacute;n impl&amp;iacute;cita tiene rango de conversi&amp;oacute;n. (observe la diferencia con los agregados: los agregados se inicializan directamente de las listas de inicio de un solo elemento antes de considerar &lt;a href=&quot;aggregate_initialization&quot;&gt;la inicializaci&amp;oacute;n de agregados&lt;/a&gt; , los no agregados consideran los constructores initializer_list antes que cualquier otro constructor)</target>
        </trans-unit>
        <trans-unit id="d49d7071128c9d18da1c8f640ffd938c2f5bb26f" translate="yes" xml:space="preserve">
          <source>If P is a function parameter pack, the type A of each remaining parameter type of the argument template is compared with the type P of the declarator-id of the function parameter pack. Each comparison deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack.</source>
          <target state="translated">Si P es un paquete de parámetros de función,el tipo A de cada tipo de parámetro restante de la plantilla de argumentos se compara con el tipo P del id del declarante del paquete de parámetros de función.Cada comparación deduce los argumentos del modelo para las posiciones posteriores en los paquetes de parámetros del modelo ampliados por el paquete de parámetros de la función.</target>
        </trans-unit>
        <trans-unit id="67a08e610ae0b43d5b7d5de3fee248ad08df296b" translate="yes" xml:space="preserve">
          <source>If Stage 2 was terminated by the test &lt;code&gt;in==end&lt;/code&gt;, &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed to set the eof bit.</source>
          <target state="translated">Si la prueba termin&amp;oacute; en la etapa 2 &lt;code&gt;in==end&lt;/code&gt; , se ejecuta &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; para establecer el bit eof.</target>
        </trans-unit>
        <trans-unit id="a0a49b47583d28360f42a9c412de856cbcf247f7" translate="yes" xml:space="preserve">
          <source>If Statements with Initializer</source>
          <target state="translated">Si las declaraciones con el inicializador</target>
        </trans-unit>
        <trans-unit id="95e34bcbaa3c6e3efcc81854651af3ec74c54e09" translate="yes" xml:space="preserve">
          <source>If UTF-8 code unit produced is &lt;code&gt;u8'\0'&lt;/code&gt;, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">Si la unidad de c&amp;oacute;digo UTF-8 producida es &lt;code&gt;u8'\0'&lt;/code&gt; , el estado de conversi&amp;oacute;n &lt;code&gt;*ps&lt;/code&gt; representa el estado de cambio inicial.</target>
        </trans-unit>
        <trans-unit id="5031b0f6e6a8ffbd0c86254f140591158ac1c1ed" translate="yes" xml:space="preserve">
          <source>If UTF-8 encoding of the multibyte character in &lt;code&gt;*s&lt;/code&gt; consists of more than one UTF-8 code unit, then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc8&lt;/code&gt; will write out the additional UTF-8 code units, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">Si la codificaci&amp;oacute;n UTF-8 del car&amp;aacute;cter multibyte en &lt;code&gt;*s&lt;/code&gt; consta de m&amp;aacute;s de una unidad de c&amp;oacute;digo UTF-8, luego de la primera llamada a esta funci&amp;oacute;n, &lt;code&gt;*ps&lt;/code&gt; se actualiza de tal manera que la pr&amp;oacute;xima llamada a &lt;code&gt;mbrtoc8&lt;/code&gt; escriba el unidades de c&amp;oacute;digo UTF-8 adicionales, sin tener en cuenta &lt;code&gt;*s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57e85fdf8664c8892feaa0067e2ab68c323b2c7e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; declaration specifies a default, it must be a friend function definition, and no other declarations of this function are allowed in the translation unit.</source>
          <target state="translated">Si una declaraci&amp;oacute;n de &lt;a href=&quot;friend&quot;&gt;amigo&lt;/a&gt; especifica un valor predeterminado, debe ser una definici&amp;oacute;n de funci&amp;oacute;n de amigo, y no se permiten otras declaraciones de esta funci&amp;oacute;n en la unidad de traducci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="af125d901495baa7e68ae6bf7e676c729a2e9e7d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lambda&quot;&gt;lambda-expression&lt;/a&gt; appears in a default argument, it cannot explicitly or implicitly capture anything.</source>
          <target state="translated">Si una &lt;a href=&quot;lambda&quot;&gt;expresi&amp;oacute;n lambda&lt;/a&gt; aparece en un argumento predeterminado, no puede capturar nada de manera expl&amp;iacute;cita o impl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="a76f53af271b5a909124051c648419560af0ae0d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; appears as the last &lt;code&gt;P&lt;/code&gt;, then the type &lt;code&gt;P&lt;/code&gt; is matched against the type &lt;code&gt;A&lt;/code&gt; of each remaining argument of the call. Each match deduces the template arguments for the next position in the pack expansion:</source>
          <target state="translated">Si un &lt;a href=&quot;parameter_pack&quot;&gt;paquete de par&amp;aacute;metros&lt;/a&gt; aparece como la &amp;uacute;ltima &lt;code&gt;P&lt;/code&gt; , el tipo &lt;code&gt;P&lt;/code&gt; se compara con el tipo &lt;code&gt;A&lt;/code&gt; de cada argumento restante de la llamada. Cada coincidencia deduce los argumentos de plantilla para la siguiente posici&amp;oacute;n en la expansi&amp;oacute;n del paquete:</target>
        </trans-unit>
        <trans-unit id="b41eca314d823a30b3d9356e848b0ef641d30e0a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;choose&lt;/code&gt; is not passed and an ambiguous or nonexistent local time is encountered, a &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; or &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; exception (as applicable) will be thrown.</source>
          <target state="translated">Si no se pasa una &lt;code&gt;choose&lt;/code&gt; y se encuentra una hora local ambigua o inexistente , se generar&amp;aacute; una excepci&amp;oacute;n &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; o &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; (seg&amp;uacute;n corresponda).</target>
        </trans-unit>
        <trans-unit id="b0232a855656fad38033f04cd7d4e9aba797f804" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;va_list&lt;/code&gt; instance is created, passed to another function, and used via &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; in that function, then any subsequent use in the calling function should be preceded by a call to &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;va_list&lt;/code&gt; una instancia de va_list , se pasa a otra funci&amp;oacute;n y se usa a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; en esa funci&amp;oacute;n, cualquier uso posterior en la funci&amp;oacute;n de llamada debe ir precedido de una llamada a &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80b021b3e6bb48d6dea03f2d437af9bc0159b35f" translate="yes" xml:space="preserve">
          <source>If a MoveAssignable class implements a move assignment operator, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after assignment is unspecified.</source>
          <target state="translated">Si una clase MoveAssignable implementa un operador de asignaci&amp;oacute;n de movimiento, tambi&amp;eacute;n puede implementar la &lt;a href=&quot;../utility/move&quot;&gt;sem&amp;aacute;ntica de movimiento&lt;/a&gt; para aprovechar el hecho de que el valor de &lt;code&gt;rv&lt;/code&gt; despu&amp;eacute;s de la asignaci&amp;oacute;n no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="50fd9c6db39f2b44036e6dd5cc6b5f20e25a53df" translate="yes" xml:space="preserve">
          <source>If a MoveConstructible class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="translated">Si una clase MoveConstructible implementa un constructor de movimiento, tambi&amp;eacute;n puede implementar la &lt;a href=&quot;../utility/move&quot;&gt;sem&amp;aacute;ntica de movimiento&lt;/a&gt; para aprovechar el hecho de que el valor de &lt;code&gt;rv&lt;/code&gt; despu&amp;eacute;s de la construcci&amp;oacute;n no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="db6d3d9d7cd4ba49aa12646a4de72f6a71fe9090" translate="yes" xml:space="preserve">
          <source>If a UTF-8 string literal and a wide string literal are side by side, the program is ill-formed.</source>
          <target state="translated">Si un literal de cuerda UTF-8 y un literal de cuerda ancha están uno al lado del otro,el programa está mal formado.</target>
        </trans-unit>
        <trans-unit id="2e7730383bc958aa60b61242e15f22a8a4d39ba2" translate="yes" xml:space="preserve">
          <source>If a call had been made to &lt;a href=&quot;sync&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; since the last call to &lt;code&gt;emit()&lt;/code&gt;, then also flushes the wrapped stream by calling &lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt;&lt;code&gt;pubsync()&lt;/code&gt;&lt;/a&gt; on it.</source>
          <target state="translated">Si se realiz&amp;oacute; una llamada para &lt;a href=&quot;sync&quot;&gt; &lt;code&gt;sync&lt;/code&gt; &lt;/a&gt; desde la &amp;uacute;ltima llamada a &lt;code&gt;emit()&lt;/code&gt; , entonces tambi&amp;eacute;n se vac&amp;iacute;a la secuencia envuelta llamando a &lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt; &lt;code&gt;pubsync()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ea2bfcf7eb556e144def8831349ca368e38aca7" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;sprintf&lt;/code&gt; or &lt;code&gt;snprintf&lt;/code&gt; causes copying to take place between objects that overlap, the behavior is undefined (e.g. &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt;).</source>
          <target state="translated">Si una llamada a &lt;code&gt;sprintf&lt;/code&gt; o &lt;code&gt;snprintf&lt;/code&gt; hace que se realice una copia entre objetos que se superponen, el comportamiento no est&amp;aacute; definido (por ejemplo, &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3aa22cbaf61ec140e43d901a3568b282d2888df" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; fails, no further call to &lt;code&gt;try_lock&lt;/code&gt; is performed, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects and a &lt;code&gt;0&lt;/code&gt;-based index of the object that failed to lock is returned.</source>
          <target state="translated">Si falla una llamada a &lt;code&gt;try_lock&lt;/code&gt; , no se realiza ninguna otra llamada a &lt;code&gt;try_lock&lt;/code&gt; , se invoca el &lt;code&gt;unlock&lt;/code&gt; para los objetos bloqueados y se devuelve un &amp;iacute;ndice basado en &lt;code&gt;0&lt;/code&gt; del objeto que no se pudo bloquear.</target>
        </trans-unit>
        <trans-unit id="42b5fe2f519d0b2189f00f6cdee376383897d0d8" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">Si una llamada a &lt;code&gt;try_lock&lt;/code&gt; resulta en una excepci&amp;oacute;n, se llama a &lt;code&gt;unlock&lt;/code&gt; para cualquier objeto bloqueado antes de volver a lanzarlo.</target>
        </trans-unit>
        <trans-unit id="409e5d2187197971805f527baaf18e9e29ae37c9" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Si una llamada a &lt;code&gt;wrapper()&lt;/code&gt; pasa un const lvalue &lt;code&gt;std::string&lt;/code&gt; , entonces &lt;code&gt;T&lt;/code&gt; se deduce a &lt;code&gt;const std::string&amp;amp;&lt;/code&gt; , y &lt;code&gt;std::forward&lt;/code&gt; asegura que se pase una referencia de const lvalue a &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60d636afcff594f21611dd719c9b59be1be77be5" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a non-const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a non-const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Si una llamada a &lt;code&gt;wrapper()&lt;/code&gt; pasa un valor no constante de lstlue &lt;code&gt;std::string&lt;/code&gt; , entonces &lt;code&gt;T&lt;/code&gt; se deduce a &lt;code&gt;std::string&amp;amp;&lt;/code&gt; , y &lt;code&gt;std::forward&lt;/code&gt; asegura que se pase una referencia de valor no constante a &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="531e469ff5d08b04534632e848505259a8c9345f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes an rvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&lt;/code&gt; (not &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, or &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;), and &lt;code&gt;std::forward&lt;/code&gt; ensures that an rvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Si una llamada a &lt;code&gt;wrapper()&lt;/code&gt; pasa un rvalue &lt;code&gt;std::string&lt;/code&gt; , entonces &lt;code&gt;T&lt;/code&gt; se deduce a &lt;code&gt;std::string&lt;/code&gt; (no &lt;code&gt;std::string&amp;amp;&lt;/code&gt; , &lt;code&gt;const std::string&amp;amp;&lt;/code&gt; o &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; ), y &lt;code&gt;std::forward&lt;/code&gt; asegura que una referencia de valor se pasa a &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3db6809411e108c8a32250227388ae4694cdc2d7" translate="yes" xml:space="preserve">
          <source>If a capacity change takes place, all iterators and references, including the past-the-end iterator, are invalidated.</source>
          <target state="translated">Si se produce un cambio de capacidad,se invalidan todos los iteradores y referencias,incluido el iterador del pasado.</target>
        </trans-unit>
        <trans-unit id="91f5ccbd4323fb5f3ed4c55a818cff6f60b92726" translate="yes" xml:space="preserve">
          <source>If a capture list has a capture-default and does not explicitly capture the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;) or an automatic variable, it captures it</source>
          <target state="translated">Si una lista de captura tiene un valor predeterminado de captura y no captura expl&amp;iacute;citamente el objeto que lo encierra (como &lt;code&gt;this&lt;/code&gt; o &lt;code&gt;*this&lt;/code&gt; ) o una variable autom&amp;aacute;tica, lo captura</target>
        </trans-unit>
        <trans-unit id="7dd621d8a6ec99fac9a316fb824dc230d2630614" translate="yes" xml:space="preserve">
          <source>If a catch-clause for a derived class is placed after the catch-clause for a base class, the derived catch-clause will never be executed.</source>
          <target state="translated">Si se coloca una cláusula de captura para una clase derivada después de la cláusula de captura para una clase base,la cláusula de captura derivada nunca se ejecutará.</target>
        </trans-unit>
        <trans-unit id="20b89c206d6d992d89351af992dfddfea294ca6c" translate="yes" xml:space="preserve">
          <source>If a class has a public virtual destructor, it can be derived from, and the derived object can be safely deleted through a pointer to the base object (&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW #18&lt;/a&gt;).</source>
          <target state="translated">Si una clase tiene un destructor virtual p&amp;uacute;blico, se puede derivar de &amp;eacute;l, y el objeto derivado se puede eliminar de forma segura a trav&amp;eacute;s de un puntero al objeto base ( &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW # 18&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d189c715668bfca07f195aaf55d2d525ebbeda96" translate="yes" xml:space="preserve">
          <source>If a class requires a user-defined &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, a user-defined &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, or a user-defined &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, it almost certainly requires all three.</source>
          <target state="translated">Si una clase requiere un &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; definido por el usuario , un &lt;a href=&quot;copy_constructor&quot;&gt;constructor de copia&lt;/a&gt; definido por el usuario o un &lt;a href=&quot;as_operator&quot;&gt;operador de asignaci&amp;oacute;n de copia&lt;/a&gt; definido por el usuario , es casi seguro que requiera los tres.</target>
        </trans-unit>
        <trans-unit id="d0521b23151547cdfdf59688f7fc84d8f6a00c6f" translate="yes" xml:space="preserve">
          <source>If a class template has been declared, but not defined, at the point of instantiation, the instantiation yields an incomplete class type:</source>
          <target state="translated">Si se ha declarado una plantilla de clase,pero no se ha definido,en el punto de instanciación,la instanciación produce un tipo de clase incompleto:</target>
        </trans-unit>
        <trans-unit id="5de1ec538e9a507f38c522094bdfc9ac9990681e" translate="yes" xml:space="preserve">
          <source>If a const non-inline(since C++17) static data member or a constexpr static data member(since C++11) is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, a definition at namespace scope is still required, but it cannot have an initializer. This definition is deprecated for &lt;code&gt;constexpr&lt;/code&gt; data members(since C++17).</source>
          <target state="translated">Si un miembro de datos est&amp;aacute;ticos const no en l&amp;iacute;nea (desde C ++ 17) o un miembro de datos est&amp;aacute;ticos constexpr (desde C ++ 11) se &lt;a href=&quot;definition#ODR-use&quot;&gt;usa odr&lt;/a&gt; , todav&amp;iacute;a se requiere una definici&amp;oacute;n en el &amp;aacute;mbito del espacio de nombres, pero no puede tener un inicializador. Esta definici&amp;oacute;n est&amp;aacute; en desuso para los miembros de datos &lt;code&gt;constexpr&lt;/code&gt; (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="23a184ea03d379e5295d8a06a9fb5d4d84026185" translate="yes" xml:space="preserve">
          <source>If a constexpr if statement appears inside a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, and if condition is not &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt; after instantiation, the discarded statement is not instantiated when the enclosing template is instantiated .</source>
          <target state="translated">Si aparece una declaraci&amp;oacute;n constexpr if dentro de una &lt;a href=&quot;templates#Templated_entity&quot;&gt;entidad con plantilla&lt;/a&gt; , y si la condici&amp;oacute;n no &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;depende del valor&lt;/a&gt; despu&amp;eacute;s de la instanciaci&amp;oacute;n, la declaraci&amp;oacute;n descartada no se instancia cuando se instancia la plantilla adjunta.</target>
        </trans-unit>
        <trans-unit id="d387511a4c202656145b74050dd24c2d4377d5ea" translate="yes" xml:space="preserve">
          <source>If a constructor template or conversion function template has an &lt;a href=&quot;explicit&quot;&gt;conditional explicit specifier&lt;/a&gt; which happens to be &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt;, after deduction, if the context requires a candidate that is not explicit and the generated specialization is explicit, it is removed from the candidate set.</source>
          <target state="translated">Si una plantilla de constructor o una plantilla de funci&amp;oacute;n de conversi&amp;oacute;n tiene un &lt;a href=&quot;explicit&quot;&gt;especificador expl&amp;iacute;cito condicional&lt;/a&gt; que &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;depende del valor&lt;/a&gt; , despu&amp;eacute;s de la deducci&amp;oacute;n, si el contexto requiere un candidato que no es expl&amp;iacute;cito y la especializaci&amp;oacute;n generada es expl&amp;iacute;cita, se elimina del conjunto de candidatos.</target>
        </trans-unit>
        <trans-unit id="e7cac551c36c79f3db2d3cd4de291ee906f04949" translate="yes" xml:space="preserve">
          <source>If a contract condition of a virtual function &lt;code&gt;f&lt;/code&gt; odr-uses &lt;code&gt;*this&lt;/code&gt;, the class of which &lt;code&gt;f&lt;/code&gt; is a direct member must be an unambiguous and accessible base class of any class in which &lt;code&gt;f&lt;/code&gt; is overridden.</source>
          <target state="translated">Si una condici&amp;oacute;n de contrato de una funci&amp;oacute;n virtual &lt;code&gt;f&lt;/code&gt; -dr-usa &lt;code&gt;*this&lt;/code&gt; , la clase de la cual &lt;code&gt;f&lt;/code&gt; es un miembro directo debe ser una clase base inequ&amp;iacute;voca y accesible de cualquier clase en la que se anule &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a62eb301fbc04938195faede31c45cafa349ad46" translate="yes" xml:space="preserve">
          <source>If a conversion specification is invalid, the behavior is undefined.</source>
          <target state="translated">Si una especificación de conversión es inválida,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="5705ed552a56d6bfbeab747c83e7be8483a52343" translate="yes" xml:space="preserve">
          <source>If a data race occurs, the behavior of the program is undefined.</source>
          <target state="translated">Si se produce una carrera de datos,el comportamiento del programa es indefinido.</target>
        </trans-unit>
        <trans-unit id="882bf051762ba2c1ce6191c7588fe5e3cee6567e" translate="yes" xml:space="preserve">
          <source>If a declaration introduces a variable with automatic storage duration, it is initialized when its declaration statement is executed. All automatic variables declared in a block are destroyed on exit from the block (regardless how the block is exited: via &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;, &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, or by reaching its end), in order opposite to their order of initialization.</source>
          <target state="translated">Si una declaraci&amp;oacute;n introduce una variable con duraci&amp;oacute;n de almacenamiento autom&amp;aacute;tica, se inicializa cuando se ejecuta su declaraci&amp;oacute;n de declaraci&amp;oacute;n. Todas las variables autom&amp;aacute;ticas declaradas en un bloque se destruyen a la salida del bloque (independientemente de c&amp;oacute;mo se salga del bloque: por &lt;a href=&quot;exceptions&quot;&gt;excepci&amp;oacute;n&lt;/a&gt; , &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; o llegando a su final), en orden opuesto a su orden de inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="43c8efd199427ba6a640175787f51c9fb916e92f" translate="yes" xml:space="preserve">
          <source>If a delegating constructor exits with an exception after the non-delegating constructor successfully completed, the destructor for this object is called.</source>
          <target state="translated">Si un constructor delegado sale con una excepción después de que el constructor no delegado haya terminado con éxito,se llama al destructor de este objeto.</target>
        </trans-unit>
        <trans-unit id="1ac2fdfac54931742b99e44e4aa9aeaa05c1d2d6" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding and the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="translated">Si un destructor restablece el controlador de terminaci&amp;oacute;n durante el desenrollado de la pila y el desenrollamiento m&amp;aacute;s tarde condujo a que se &lt;code&gt;terminate&lt;/code&gt; llamada, el controlador que se instal&amp;oacute; al final de la expresi&amp;oacute;n de lanzamiento es el que se llamar&amp;aacute;. (nota: era ambiguo si volver a lanzar aplicaba los nuevos controladores).</target>
        </trans-unit>
        <trans-unit id="753c6e50ab4e318d953d5637b772a0f352fda59e" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called.</source>
          <target state="translated">Si un destructor restablece el controlador de terminaci&amp;oacute;n durante el desenrollado de la pila, no se especifica a qu&amp;eacute; controlador se llama si el desenrollamiento m&amp;aacute;s tarde llev&amp;oacute; a &lt;code&gt;terminate&lt;/code&gt; llamada.</target>
        </trans-unit>
        <trans-unit id="482827679143ed383496ea91dbd86707c7632c8b" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding and the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="translated">Si un destructor restablece el controlador inesperado durante el desenrollado de la pila y el desenrollamiento m&amp;aacute;s tarde provoc&amp;oacute; que se llamara &lt;code&gt;unexpected&lt;/code&gt; , el controlador que se instal&amp;oacute; al final de la expresi&amp;oacute;n de lanzamiento es el que se llamar&amp;aacute;. (nota: era ambiguo si volver a lanzar aplicaba los nuevos controladores).</target>
        </trans-unit>
        <trans-unit id="f833e8b1ca41ece97da3b5dfb8d80f4a17d92a84" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called.</source>
          <target state="translated">Si un destructor restablece el controlador inesperado durante el desenrollado de la pila, no se especifica a qu&amp;eacute; controlador se llama si el desenrollamiento m&amp;aacute;s tarde provoc&amp;oacute; &lt;code&gt;unexpected&lt;/code&gt; llamada inesperada .</target>
        </trans-unit>
        <trans-unit id="3b53fae349713df5efc757fb7b33531c67e72c29" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.</source>
          <target state="translated">Si se produce un error de dominio,se devuelve un valor definido por la implementación (NaN donde se admite).</target>
        </trans-unit>
        <trans-unit id="daaa304029da34d0537dff7e88f32d7146eac438" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned (NaN where supported).</source>
          <target state="translated">Si se produce un error de dominio,se devuelve un valor definido por la implementación (NaN donde se admite).</target>
        </trans-unit>
        <trans-unit id="8a2b2a5d22410f7c139500bf2d1ad8bd3daffb21" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned.</source>
          <target state="translated">Si se produce un error de dominio,se devuelve un valor definido por la aplicación.</target>
        </trans-unit>
        <trans-unit id="fc6ec94615e1c6cf0e59aab22eb031064112889e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="translated">Si un archivo o un directorio se borra o se añade al árbol de directorios después de que se haya creado el iterador de directorios,no se especifica si el cambio se observaría a través del iterador.</target>
        </trans-unit>
        <trans-unit id="3724f8b6f7d15be8a8f1594573af0e22249ce20e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the recursive directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="translated">Si un archivo o un directorio se borra o se añade al árbol de directorios después de que se haya creado el iterador recursivo de directorios,no se especifica si el cambio se observaría a través del iterador.</target>
        </trans-unit>
        <trans-unit id="39efafdede79fd69777a0e208a3fd4446a9e9cf1" translate="yes" xml:space="preserve">
          <source>If a friend declaration is the first declaration of the function in a translation unit and has a contract condition, that declaration must be a definition and must be the only declaration of the function in the translation unit:</source>
          <target state="translated">Si la declaración de un amigo es la primera declaración de la función en una unidad de traducción y tiene una condición contractual,esa declaración debe ser una definición y debe ser la única declaración de la función en la unidad de traducción:</target>
        </trans-unit>
        <trans-unit id="9348fef8e416c767f68b83ba99d0f25cfef8feda" translate="yes" xml:space="preserve">
          <source>If a function declared nodiscard or a function returning an enumeration or class declared nodiscard by value is called from a &lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;discarded-value expression&lt;/a&gt; other than a cast to void, the compiler is encouraged to issue a warning.</source>
          <target state="translated">Si una funci&amp;oacute;n declarada sin descarte o una funci&amp;oacute;n que devuelve una enumeraci&amp;oacute;n o clase declarada sin descarte por valor se llama desde una &lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;expresi&amp;oacute;n de valor descartado&lt;/a&gt; que no sea una conversi&amp;oacute;n para anular, se anima al compilador a emitir una advertencia.</target>
        </trans-unit>
        <trans-unit id="0e42988e69c29f9c1e608a2f0ffd727f5c2644ec" translate="yes" xml:space="preserve">
          <source>If a function exits via an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Si una funci&amp;oacute;n sale por una excepci&amp;oacute;n, se llama a &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad964142a18dcc049d042a23d7d71322620a52d8" translate="yes" xml:space="preserve">
          <source>If a function has more than one final overrider, the program is ill-formed:</source>
          <target state="translated">Si una función tiene más de un anulador final,el programa está mal formado:</target>
        </trans-unit>
        <trans-unit id="bafd7cb9d12f56ccf89ae9b7b4d93ed2022e34a5" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in one translation unit and the same function is declared without &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">Si una funci&amp;oacute;n se declara &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; en una unidad de traducci&amp;oacute;n y la misma funci&amp;oacute;n se declara sin &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; en otra unidad de traducci&amp;oacute;n, el programa est&amp;aacute; mal formado; No se requiere diagn&amp;oacute;stico.</target>
        </trans-unit>
        <trans-unit id="e3f9e3de669a5122870e6bc1eb5118c628c85194" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;final&lt;/code&gt;, and another function attempts to override it, the program is ill-formed:</source>
          <target state="translated">Si una funci&amp;oacute;n se declara con el especificador &lt;code&gt;final&lt;/code&gt; , y otra funci&amp;oacute;n intenta anularla, el programa est&amp;aacute; mal formado:</target>
        </trans-unit>
        <trans-unit id="3888ddb42cb2148d436948685603df58149529f7" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;override&lt;/code&gt;, but does not override a virtual function, the program is ill-formed:</source>
          <target state="translated">Si una funci&amp;oacute;n se declara con la &lt;code&gt;override&lt;/code&gt; del especificador , pero no anula una funci&amp;oacute;n virtual, el programa est&amp;aacute; mal formado:</target>
        </trans-unit>
        <trans-unit id="2f9f7412482ccba02363ec8e1d82ccc1ed257746" translate="yes" xml:space="preserve">
          <source>If a function is declared with type &lt;code&gt;T&lt;/code&gt; listed in its exception specification, the function may throw exceptions of that type or a type derived from it.</source>
          <target state="translated">Si una funci&amp;oacute;n se declara con el tipo &lt;code&gt;T&lt;/code&gt; enumerado en su especificaci&amp;oacute;n de excepci&amp;oacute;n, la funci&amp;oacute;n puede arrojar excepciones de ese tipo o un tipo derivado de &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="0815633756bffaa6b84ff1cbf11092af43ee34c1" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a class type, &lt;code&gt;class&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">Si existe una funci&amp;oacute;n o una variable en el alcance con un nombre id&amp;eacute;ntico al nombre de un tipo de &lt;code&gt;class&lt;/code&gt; , la clase puede anteponerse al nombre para la desambiguaci&amp;oacute;n, lo que da como resultado un &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;especificador de tipo elaborado&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43617584a5c434806ea859f8354d597162e188ea" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a non-union class type, &lt;code&gt;struct&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">Si existe una funci&amp;oacute;n o una variable en el alcance con un nombre id&amp;eacute;ntico al nombre de un tipo de clase no sindical, la &lt;code&gt;struct&lt;/code&gt; puede anteponerse al nombre para la desambiguaci&amp;oacute;n, lo que da como resultado un &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;especificador de tipo elaborado&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33c372b62b38e3e28c4c2d8049dc573ffb3184eb" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a union type, &lt;code&gt;union&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">Si existe una funci&amp;oacute;n o una variable en el alcance con el nombre id&amp;eacute;ntico al nombre de un tipo de &lt;code&gt;union&lt;/code&gt; , la uni&amp;oacute;n se puede anteponer al nombre para la desambiguaci&amp;oacute;n, lo que resulta en un &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;especificador de tipo elaborado&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3caf3302d65692054c0bd57d280ffa6d4243e44a" translate="yes" xml:space="preserve">
          <source>If a function overrides more than one function, all of the overridden functions must have the same list of contract conditions; no diagnostic is required if corresponding conditions will always evaluate to the same value.</source>
          <target state="translated">Si una función anula más de una función,todas las funciones anuladas deben tener la misma lista de condiciones contractuales;no se requiere ningún diagnóstico si las condiciones correspondientes se evalúan siempre con el mismo valor.</target>
        </trans-unit>
        <trans-unit id="135a8489da58532d74209fec452fabacfcbf21c6" translate="yes" xml:space="preserve">
          <source>If a function template, variable template, member function template, or member function or static data member of a class template is explicitly instantiated with an explicit instantiation definition, the template definition must be present in the same translation unit.</source>
          <target state="translated">Si una plantilla de función,plantilla variable,plantilla de función miembro,o función miembro o datos estáticos miembro de una plantilla de clase se instancian explícitamente con una definición de instanciación explícita,la definición de la plantilla debe estar presente en la misma unidad de traducción.</target>
        </trans-unit>
        <trans-unit id="f8f1e8e53e9248772a5ae660d45da68b260826d4" translate="yes" xml:space="preserve">
          <source>If a function that is not transaction-safe is called through a reference or pointer to a transaction-safe function, the behavior is undefined.</source>
          <target state="translated">Si se llama a una función que no es segura para las transacciones a través de una referencia o un puntero a una función segura para las transacciones,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="0bde24db3435358d326a5b26dc4f5fb9a3ee4c50" translate="yes" xml:space="preserve">
          <source>If a function uses return type deduction, it cannot be redeclared using the type that it deduces to, or another kind of return type deduction even if it deduces to the same type.</source>
          <target state="translated">Si una función utiliza la deducción de tipo de retorno,no puede ser redeclarada utilizando el tipo al que deduce,u otro tipo de deducción de tipo de retorno aunque deduzca al mismo tipo.</target>
        </trans-unit>
        <trans-unit id="26770c3740e0e9cd92c88700d97b6e2c4081721f" translate="yes" xml:space="preserve">
          <source>If a function was introduced by a using-declaration, declaring a function with the same name and parameter list is ill-formed (unless the declaration is for the same function). If a function template was introduced by a using-declaration, declaring a function template with the same name, parameter type list, return type, and template parameter list is ill-formed. Two using-declarations can introduce functions with the same name and parameter list, but if a call to that function is attempted, the program is ill-formed.</source>
          <target state="translated">Si una función se introdujo mediante una declaración de uso,la declaración de una función con el mismo nombre y lista de parámetros está mal formada (a menos que la declaración sea para la misma función).Si se introdujo un modelo de función mediante una declaración de empleo,la declaración de un modelo de función con el mismo nombre,lista de tipos de parámetros,tipo de devolución y lista de parámetros del modelo está mal hecha.Dos declaraciones de uso pueden introducir funciones con el mismo nombre y lista de parámetros,pero si se intenta llamar a esa función,el programa está mal formado.</target>
        </trans-unit>
        <trans-unit id="e751efac5a78fb2353ecab041674493ffe914d58" translate="yes" xml:space="preserve">
          <source>If a function-local (block-scope) static object was destroyed and then that function is called from the destructor of another static object and the control flow passes through the definition of that object (or if it is used indirectly, via pointer or reference), the behavior is undefined.</source>
          <target state="translated">Si se destruye un objeto estático de función-local (bloque-alcance)y luego se llama a esa función desde el destructor de otro objeto estático y el flujo de control pasa a través de la definición de ese objeto (o si se utiliza indirectamente,mediante puntero o referencia),el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="a5179d5f0b6b560d982bb76be1dd9a627d77214d" translate="yes" xml:space="preserve">
          <source>If a get area exists (e.g. the file was opened for reading), the effect is implementation-defined. Typical implementation may empty out the get area and move the current file position back by the corresponding number of bytes.</source>
          <target state="translated">Si existe un área de get (por ejemplo,el archivo se abrió para su lectura),el efecto se define en la implementación.La implementación típica puede vaciar el área get y mover la posición actual del archivo hacia atrás en el número de bytes correspondiente.</target>
        </trans-unit>
        <trans-unit id="5b16daea89246b1eee5a59e08c141c8e46338b5b" translate="yes" xml:space="preserve">
          <source>If a lambda captures the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;), either the nearest enclosing function must be a non-static member function or the lambda must be in a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;:</source>
          <target state="translated">Si una lambda captura el objeto envolvente (como &lt;code&gt;this&lt;/code&gt; o &lt;code&gt;*this&lt;/code&gt; ), la funci&amp;oacute;n de encierro m&amp;aacute;s cercana debe ser una funci&amp;oacute;n miembro no est&amp;aacute;tica o la lambda debe estar en un &lt;a href=&quot;data_members#Member_initialization&quot;&gt;inicializador de miembro predeterminado&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cfdecd26d4d9885f6eeae96917954311b903b67d" translate="yes" xml:space="preserve">
          <source>If a lambda expression (or an instantiation of a generic lambda's function call operator) ODR-uses &lt;code&gt;this&lt;/code&gt; or any variable with automatic storage duration, it must be captured by the lambda expression.</source>
          <target state="translated">Si una expresi&amp;oacute;n lambda (o una instanciaci&amp;oacute;n de un operador de llamada de funci&amp;oacute;n gen&amp;eacute;rica lambda) ODR-usa &lt;code&gt;this&lt;/code&gt; o cualquier variable con duraci&amp;oacute;n de almacenamiento autom&amp;aacute;tico, debe ser capturada por la expresi&amp;oacute;n lambda.</target>
        </trans-unit>
        <trans-unit id="c9245324f25aa6ef3f3a921517ba752285940aaf" translate="yes" xml:space="preserve">
          <source>If a lambda odr-uses a reference that is captured by reference, it is using the object referred-to by the original reference, not the captured reference itself:</source>
          <target state="translated">Si una lambda odr -utiliza una referencia capturada por referencia,está utilizando el objeto al que se refiere la referencia original,no la referencia capturada en sí misma:</target>
        </trans-unit>
        <trans-unit id="1da4cd3d4148fc5555feb74d4e942788fe474123" translate="yes" xml:space="preserve">
          <source>If a lambda-expression appears in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt;, it cannot explicitly or implicitly capture anything.</source>
          <target state="translated">Si una expresi&amp;oacute;n lambda aparece en un &lt;a href=&quot;default_arguments&quot;&gt;argumento predeterminado&lt;/a&gt; , no puede capturar nada de manera expl&amp;iacute;cita o impl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="e34c58387ec074a0a7abef6761392718c559bb60" translate="yes" xml:space="preserve">
          <source>If a member has a default member initializer and also appears in the member initialization list in a constructor, the default member initializer is ignored.</source>
          <target state="translated">Si un miembro tiene un inicializador de miembros por defecto y también aparece en la lista de inicialización de miembros en un constructor,se ignora el inicializador de miembros por defecto.</target>
        </trans-unit>
        <trans-unit id="f6c0536efbdc9b49435039f82fb9fa51a3523c3e" translate="yes" xml:space="preserve">
          <source>If a name is used in a class body before it is declared, and another declaration for that name is in scope, the program is &lt;a href=&quot;ub&quot;&gt;ill-formed, no diagnostic required&lt;/a&gt;.</source>
          <target state="translated">Si se usa un nombre en un cuerpo de clase antes de que se declare, y otra declaraci&amp;oacute;n para ese nombre est&amp;aacute; dentro del alcance, el programa est&amp;aacute; &lt;a href=&quot;ub&quot;&gt;mal formado, no se requiere diagn&amp;oacute;stico&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73b765e29ed3c027cc3bcfba763673a78b12e25b" translate="yes" xml:space="preserve">
          <source>If a narrowing conversion is required, other than from an integral type to a floating point type, the program is ill-formed.</source>
          <target state="translated">Si se requiere una conversión de estrechamiento,que no sea de un tipo integral a un tipo de punto flotante,el programa está mal formado.</target>
        </trans-unit>
        <trans-unit id="a10165cb0c4c283cd3dc5405e46c820a8e3f7689" translate="yes" xml:space="preserve">
          <source>If a nested lambda &lt;code&gt;m2&lt;/code&gt; captures something that is also captured by the immediately enclosing lambda &lt;code&gt;m1&lt;/code&gt;, then &lt;code&gt;m2&lt;/code&gt;'s capture is transformed as follows:</source>
          <target state="translated">Si un lambda &lt;code&gt;m2&lt;/code&gt; anidado captura algo que tambi&amp;eacute;n es capturado por el lambda &lt;code&gt;m1&lt;/code&gt; que lo encierra inmediatamente , la captura de &lt;code&gt;m2&lt;/code&gt; se transforma de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="35c0cb6d4e19455e10fc3b8d1fea7080305eff39" translate="yes" xml:space="preserve">
          <source>If a new object is created at the address that was occupied by another object, then all pointers, references, and the name of the original object will automatically refer to the new object and, once the lifetime of the new object begins, can be used to manipulate the new object, but only if the following conditions are satisfied:</source>
          <target state="translated">Si se crea un nuevo objeto en la dirección que ocupaba otro objeto,entonces todos los punteros,referencias y el nombre del objeto original se referirán automáticamente al nuevo objeto y,una vez que comience su vida útil,podrán utilizarse para manipularlo,pero sólo si se cumplen las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="040c4b92d07b4519ff12ccd42bcfa061a377c5b4" translate="yes" xml:space="preserve">
          <source>If a non-reference entity is captured by reference, implicitly or explicitly, and the function call operator of the closure object is invoked after the entity's lifetime has ended, undefined behavior occurs. The C++ closures do not extend the lifetimes of the captured references.</source>
          <target state="translated">Si una entidad no de referencia es capturada por referencia,implícita o explícitamente,y el operador de llamada de función del objeto de cierre es invocado después de que la vida de la entidad haya terminado,se produce un comportamiento indefinido.Los cierres de C++no prolongan la vida útil de las referencias capturadas.</target>
        </trans-unit>
        <trans-unit id="4ceaa0be0f1cb1c411ff6ee0a8d7f52ed257f167" translate="yes" xml:space="preserve">
          <source>If a non-static data member has an &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt; and also appears in a member initializer list, then member initializer list is executed and the default member initializer is ignored:</source>
          <target state="translated">Si un miembro de datos no est&amp;aacute;tico tiene un &lt;a href=&quot;data_members#Member_initialization&quot;&gt;inicializador de miembro predeterminado&lt;/a&gt; y tambi&amp;eacute;n aparece en una lista de inicializador de miembro, se ejecuta la lista de inicializador de miembro y se ignora el inicializador de miembro predeterminado:</target>
        </trans-unit>
        <trans-unit id="0aab394949317f4e8f5352a010f660fb204a47ce" translate="yes" xml:space="preserve">
          <source>If a non-type template parameter is used in the parameter list, and the corresponding template argument is deduced, the type of the deduced template argument ( as specified in its enclosing template parameter list, meaning references are preserved) must match the type of the non-type template parameter exactly, except that cv-qualifiers are dropped, and except where the template argument is deduced from an array bound&amp;mdash;in that case any integral type is allowed, even bool though it would always become true:</source>
          <target state="translated">Si se utiliza un par&amp;aacute;metro de plantilla que no es de tipo en la lista de par&amp;aacute;metros, y se deduce el argumento de plantilla correspondiente, el tipo de argumento de plantilla deducido (como se especifica en su lista de par&amp;aacute;metros de plantilla adjunta, lo que significa que se conservan las referencias) debe coincidir con el tipo de par&amp;aacute;metro de plantilla que no es de tipo exactamente, excepto que los calificadores cv se descartan, y excepto donde el argumento de plantilla se deduce de una matriz vinculada; en ese caso, se permite cualquier tipo integral, incluso bool, aunque siempre ser&amp;iacute;a cierto:</target>
        </trans-unit>
        <trans-unit id="6a9d189d5910a05ceacbf1d41469dc00391c4252" translate="yes" xml:space="preserve">
          <source>If a pack expansion is nested within another pack expansion, the parameter packs that appear inside the innermost pack expansion are expanded by it, and there must be another pack mentioned in the enclosing pack expansion, but not in the innermost one:</source>
          <target state="translated">Si una expansión de paquete está anidada dentro de otra expansión de paquete,los paquetes de parámetros que aparecen dentro de la expansión de paquete más interna se expanden por ella,y debe haber otro paquete mencionado en la expansión de paquete adjunta,pero no en la más interna:</target>
        </trans-unit>
        <trans-unit id="0444eb973f9088dccc9bd6e7338a1a6d154f5d7f" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, many implementations of this function leave &lt;code&gt;*t&lt;/code&gt; completely untouched.</source>
          <target state="translated">Si se encuentra un error de an&amp;aacute;lisis, muchas implementaciones de esta funci&amp;oacute;n dejan &lt;code&gt;*t&lt;/code&gt; completamente intacto.</target>
        </trans-unit>
        <trans-unit id="7dfecd9ffd391c85c521dbadb0fe904c065d326a" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, most implementations of this function leave &lt;code&gt;*t&lt;/code&gt; unmodified.</source>
          <target state="translated">Si se encuentra un error de an&amp;aacute;lisis, la mayor&amp;iacute;a de las implementaciones de esta funci&amp;oacute;n dejan &lt;code&gt;*t&lt;/code&gt; sin modificar.</target>
        </trans-unit>
        <trans-unit id="dcfd421c1a105975620bdb3e159a6ef656b96d8e" translate="yes" xml:space="preserve">
          <source>If a partial specialization of the member template is explicitly specialized for a given (implicit) specialization of the enclosing class template, the primary member template and its other partial specializations are still considered for this specialization of the enclosing class template.</source>
          <target state="translated">Si una especialización parcial de la plantilla de miembros se especializa explícitamente para una especialización dada (implícita)de la plantilla de clase adjunta,la plantilla de miembros primaria y sus otras especializaciones parciales se siguen considerando para esta especialización de la plantilla de clase adjunta.</target>
        </trans-unit>
        <trans-unit id="5e69c709c0eda47248b870b79a0045971cbc9fb3" translate="yes" xml:space="preserve">
          <source>If a pointer &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">Si un puntero &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95fa4aab00b2248a193df0012ce51bbbfdcb0a2a" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the correct sign).</source>
          <target state="translated">Si se produce un error de polo, se &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; o &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; (con el signo correcto).</target>
        </trans-unit>
        <trans-unit id="88c1375fb3e07154fab82fd39487a150f20a7acc" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Si se produce un error de polo, se &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; o &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83547df0814e730591b9f631b39a107992bddaca" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Si se produce un error de polo, se &lt;code&gt;+HUGE_VAL&lt;/code&gt; , &lt;code&gt;+HUGE_VALF&lt;/code&gt; o &lt;code&gt;+HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55c8a2c8fff5d682aefd99723282ecf86b260cc3" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;-HUGE_VAL&lt;/code&gt;, &lt;code&gt;-HUGE_VALF&lt;/code&gt;, or &lt;code&gt;-HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Si se produce un error de polo, se &lt;code&gt;-HUGE_VAL&lt;/code&gt; , &lt;code&gt;-HUGE_VALF&lt;/code&gt; o &lt;code&gt;-HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aad32c287435bd724b2b2cd991a06c95727932d" translate="yes" xml:space="preserve">
          <source>If a pole error or a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Si se produce un error de polo o un error de rango debido a un desbordamiento, se &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; o &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd506f2079e184fcad156bfb8a88cdf9abf44715" translate="yes" xml:space="preserve">
          <source>If a postcondition &lt;a href=&quot;../definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; a parameter in its predicate and the function body modifies the value of that parameter directly or indirectly, the behavior is undefined.</source>
          <target state="translated">Si una &lt;a href=&quot;../definition#ODR-use&quot;&gt;odr-condici&amp;oacute;n posterior utiliza&lt;/a&gt; un par&amp;aacute;metro en su predicado y el cuerpo de la funci&amp;oacute;n modifica el valor de ese par&amp;aacute;metro directa o indirectamente, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="d235423e2c4c1707a767d1a11cf327433b3567be" translate="yes" xml:space="preserve">
          <source>If a postcondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the function definition.</source>
          <target state="translated">Si se viola una condici&amp;oacute;n posterior, la ubicaci&amp;oacute;n de origen reflejada en el argumento &lt;code&gt;std::contract_violation&lt;/code&gt; es la ubicaci&amp;oacute;n de origen de la definici&amp;oacute;n de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8288ef9f3911668bdd42ba2bba9a0191080ea46e" translate="yes" xml:space="preserve">
          <source>If a precondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is implementation-defined.</source>
          <target state="translated">Si se viola una condici&amp;oacute;n previa, la ubicaci&amp;oacute;n de origen reflejada en el argumento &lt;code&gt;std::contract_violation&lt;/code&gt; est&amp;aacute; definida por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ef5fcd9d7689008da5f0e4bea11cd119b6efa160" translate="yes" xml:space="preserve">
          <source>If a primary template is a member of another class template, its partial specializations are members of the enclosing class template. If the enclosing template is instantiated, the declaration of each member partial specialization is instantiated as well (the same way declarations, but not definitions, of all other members of a template are instantiated).</source>
          <target state="translated">Si una plantilla primaria es miembro de otra plantilla de clase,sus especializaciones parciales son miembros de la plantilla de clase adjunta.Si la plantilla adjunta está instanciada,también se instanciará la declaración de cada especialización parcial de los miembros (de la misma manera que se instancian las declaraciones,pero no las definiciones,de todos los demás miembros de una plantilla).</target>
        </trans-unit>
        <trans-unit id="18b3bedb6ae9572a6c3106b7d4be5f3ebdfc4df2" translate="yes" xml:space="preserve">
          <source>If a program contains declarations of function templates that are</source>
          <target state="translated">Si un programa contiene declaraciones de plantillas de funciones que son</target>
        </trans-unit>
        <trans-unit id="87ffbc04e56c0394a3ecec919c439f807e6404bc" translate="yes" xml:space="preserve">
          <source>If a put area exist (e.g. file was opened for writing), first calls &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; to write all pending output to the file, including any unshift sequences.</source>
          <target state="translated">Si existe un &amp;aacute;rea de colocaci&amp;oacute;n (por ejemplo, el archivo se abri&amp;oacute; para escribir), primero se invoca el &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; para escribir todos los resultados pendientes en el archivo, incluidas las secuencias sin desplazamiento.</target>
        </trans-unit>
        <trans-unit id="919f0fed96116787f70c42581aa4648db9ff5450" translate="yes" xml:space="preserve">
          <source>If a put area exists (e.g. the file was opened for writing), calls &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; to write all pending output to the file, then flushes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si existe un &amp;aacute;rea de colocaci&amp;oacute;n (p. Ej., El archivo se abri&amp;oacute; para escritura), llama a &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; para escribir toda la salida pendiente en el archivo, luego vac&amp;iacute;a el archivo como si llamara &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="776889337c5b506a958bcb11170f9049bdd28571" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), and the character &lt;code&gt;c&lt;/code&gt; is equal to the character one position to the left of &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; (as determined by &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt;, then simply decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Si hay una posici&amp;oacute;n de devoluci&amp;oacute;n disponible en el &amp;aacute;rea de &lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt; ( gptr ()&amp;gt; eback () ), y el car&amp;aacute;cter &lt;code&gt;c&lt;/code&gt; es igual al car&amp;aacute;cter una posici&amp;oacute;n a la izquierda de &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; (seg&amp;uacute;n lo determinado por &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt; , luego simplemente disminuye el siguiente puntero ( &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9cb9d7c878f7f8a77860594336867a6041aa5088" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), then decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;) and returns the character it now points to.</source>
          <target state="translated">Si hay una posici&amp;oacute;n de devoluci&amp;oacute;n disponible en el &amp;aacute;rea de &lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt; ( gptr ()&amp;gt; eback () ), disminuye el siguiente puntero ( &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; ) y devuelve el car&amp;aacute;cter al que ahora apunta.</target>
        </trans-unit>
        <trans-unit id="79ac53d959c455debaf74453ed6b72c19ac11dfa" translate="yes" xml:space="preserve">
          <source>If a putback position is not available, then calls &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; to back up the input sequence if possible.</source>
          <target state="translated">Si una posici&amp;oacute;n de devoluci&amp;oacute;n no est&amp;aacute; disponible, llama a &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; para hacer una copia de seguridad de la secuencia de entrada si es posible.</target>
        </trans-unit>
        <trans-unit id="5c9db649e4e6e4c38883de06799ee045378481d1" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the same sign as &lt;code&gt;from&lt;/code&gt;).</source>
          <target state="translated">Si se produce un error de rango debido al desbordamiento, se &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; o &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; (con el mismo signo que &lt;code&gt;from&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9842b2827c672e6e4b846cc1f4ef41186aaaf5f3" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Si se produce un error de rango debido al desbordamiento, se &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; , &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; o &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e1bf2f0df7137552a9579d23123773adeb14193" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">Si se produce un error de rango debido a un desbordamiento, se &lt;code&gt;+HUGE_VAL&lt;/code&gt; , &lt;code&gt;+HUGE_VALF&lt;/code&gt; o &lt;code&gt;+HUGE_VALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55d9e5e2db658de793b6612e1c8dc0adb82837dc" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct result (after rounding) is returned.</source>
          <target state="translated">Si se produce un error de rango debido a un flujo insuficiente,se devuelve el resultado correcto (después del redondeo).</target>
        </trans-unit>
        <trans-unit id="144f2afda2da10823b65a9e4c24a0b3bb37c9913" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct value (after rounding) is returned.</source>
          <target state="translated">Si se produce un error de rango debido a un flujo insuficiente,se devuelve el valor correcto (después del redondeo).</target>
        </trans-unit>
        <trans-unit id="949156f77460641cf432a3cc1721f1ed036f3731" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding) is returned.</source>
          <target state="translated">Si se produce un error de rango debido a un flujo insuficiente,se devuelve el resultado correcto (después del redondeo).</target>
        </trans-unit>
        <trans-unit id="48f1515a1657338dc5a4774929668cb3a0851098" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding), that is.</source>
          <target state="translated">Si se produce un error en el rango debido a un flujo insuficiente,el resultado correcto (después del redondeo),es decir.</target>
        </trans-unit>
        <trans-unit id="bea570ee8fcad0dd93ebf596f86eddc89718e8ce" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.</source>
          <target state="translated">Si se produce un error de rango debido a un flujo insuficiente,se devuelve el resultado correcto si se admiten subnormales.</target>
        </trans-unit>
        <trans-unit id="4771fa50f8d7229b07b35621538a1aac36cd67a9" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned.</source>
          <target state="translated">Si se produce un error de rango debido a un flujo insuficiente,se devuelve el resultado correcto.</target>
        </trans-unit>
        <trans-unit id="ccb8e801dc7894cca248dbed67f56627d7cf0cc4" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;)for the stream is set.</source>
          <target state="translated">Si se produce un error de lectura o escritura, se establece el indicador de error ( &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; ) para la secuencia.</target>
        </trans-unit>
        <trans-unit id="e789f3da6463649b436aef5182ff1d2b5da92664" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator for the stream (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;) is set and the file position is unaffected.</source>
          <target state="translated">Si se produce un error de lectura o escritura, el indicador de error para la secuencia ( &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; ) se establece y la posici&amp;oacute;n del archivo no se ve afectada.</target>
        </trans-unit>
        <trans-unit id="86b3ac21433e164a790502ba1ef0db8db078e961" translate="yes" xml:space="preserve">
          <source>If a requires-expression contains invalid types or expressions in its requirements, and it does not appear within the declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, then the program is ill-formed.</source>
          <target state="translated">Si una expresi&amp;oacute;n requerida contiene tipos o expresiones inv&amp;aacute;lidas en sus requisitos, y no aparece dentro de la declaraci&amp;oacute;n de una &lt;a href=&quot;templates#Templated_entity&quot;&gt;entidad con plantilla&lt;/a&gt; , entonces el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="4b01d79ca1850a7a1aa26257022da9a9b9591827" translate="yes" xml:space="preserve">
          <source>If a rewritten candidate is selected by overload resolution for an operator &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;x @ y&lt;/code&gt; is interpreted as the rewritten expression: &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; if the selected candidate is a synthesized candidate with reversed order of parameters, or &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; otherwise, using the selected rewritten &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; candidate.</source>
          <target state="translated">Si se selecciona un candidato reescrito por resoluci&amp;oacute;n de sobrecarga para un operador &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;x @ y&lt;/code&gt; se interpreta como la expresi&amp;oacute;n reescrita: &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; si el candidato seleccionado es un candidato sintetizado con un orden inverso de par&amp;aacute;metros, o &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; contrario, utilizando el &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; reescrito seleccionado &amp;lt;=&amp;gt; candidato.</target>
        </trans-unit>
        <trans-unit id="d146da8681a775135daad12f043cc5018dc0ef5e" translate="yes" xml:space="preserve">
          <source>If a signal handler is executed as a result of a call to &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronously), then the execution of the handler is</source>
          <target state="translated">Si se ejecuta un controlador de se&amp;ntilde;al como resultado de una llamada a &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (sincr&amp;oacute;nicamente), entonces la ejecuci&amp;oacute;n del controlador es</target>
        </trans-unit>
        <trans-unit id="3f5eeae6c512283e05fb7f521150bb498afe542b" translate="yes" xml:space="preserve">
          <source>If a standard-layout &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; holds two (or more) standard-layout classes as members, and these classes have a common initial sequence of data members, it is well-defined to examine any member of that common initial sequence regardless of which member of the union is active.</source>
          <target state="translated">Si una &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n de&lt;/a&gt; dise&amp;ntilde;o est&amp;aacute;ndar contiene dos (o m&amp;aacute;s) clases de dise&amp;ntilde;o est&amp;aacute;ndar como miembros, y estas clases tienen una secuencia inicial com&amp;uacute;n de miembros de datos, est&amp;aacute; bien definido examinar cualquier miembro de esa secuencia inicial com&amp;uacute;n independientemente de qu&amp;eacute; miembro de La uni&amp;oacute;n est&amp;aacute; activa.</target>
        </trans-unit>
        <trans-unit id="e3cc007cd990ced3f77a08ffa3521f8f43ea784b" translate="yes" xml:space="preserve">
          <source>If a standard-layout union holds two or more standard-layout structs, it is permitted to inspect the common initial part of them.</source>
          <target state="translated">Si una unión de diseño estándar tiene dos o más estructuras de diseño estándar,se permite inspeccionar la parte inicial común de ellas.</target>
        </trans-unit>
        <trans-unit id="9c11517af35c72db9ca494141a4ef3243dbf8700" translate="yes" xml:space="preserve">
          <source>If a static data member is declared &lt;code&gt;constexpr&lt;/code&gt;, it is implicitly &lt;code&gt;inline&lt;/code&gt; and does not need to be redeclared at namespace scope. This redeclaration without an initializer (formerly required as shown above) is still permitted, but is deprecated.</source>
          <target state="translated">Si un miembro de datos est&amp;aacute;ticos se declara &lt;code&gt;constexpr&lt;/code&gt; , est&amp;aacute; impl&amp;iacute;citamente en &lt;code&gt;inline&lt;/code&gt; y no necesita ser redeclarado en el &amp;aacute;mbito del espacio de nombres. Esta redeclaraci&amp;oacute;n sin un inicializador (anteriormente requerida como se muestra arriba) todav&amp;iacute;a est&amp;aacute; permitida, pero est&amp;aacute; en desuso.</target>
        </trans-unit>
        <trans-unit id="58d434e5ce1cbd3b6a5b0e91079e4162ccbc510a" translate="yes" xml:space="preserve">
          <source>If a static data member of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; is declared &lt;code&gt;constexpr&lt;/code&gt;, it must be initialized with an initializer in which every expression is a constant expression, right inside the class definition:</source>
          <target state="translated">Si un miembro de datos est&amp;aacute;ticos de &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; se declara &lt;code&gt;constexpr&lt;/code&gt; , debe inicializarse con un inicializador en el que cada expresi&amp;oacute;n sea una expresi&amp;oacute;n constante, justo dentro de la definici&amp;oacute;n de clase:</target>
        </trans-unit>
        <trans-unit id="6d5250822667240cedf5abd394540f13a00c0bf0" translate="yes" xml:space="preserve">
          <source>If a static data member of integral or enumeration type is declared &lt;code&gt;const&lt;/code&gt; (and not &lt;code&gt;volatile&lt;/code&gt;), it can be initialized with an &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt; in which every expression is a &lt;a href=&quot;constexpr&quot;&gt;constant expression&lt;/a&gt;, right inside the class definition:</source>
          <target state="translated">Si un miembro de datos est&amp;aacute;ticos de tipo integral o de enumeraci&amp;oacute;n se declara &lt;code&gt;const&lt;/code&gt; ante (y no &lt;code&gt;volatile&lt;/code&gt; ), se puede inicializar con un &lt;a href=&quot;initialization&quot;&gt;inicializador&lt;/a&gt; en el que cada expresi&amp;oacute;n es una &lt;a href=&quot;constexpr&quot;&gt;expresi&amp;oacute;n constante&lt;/a&gt; , justo dentro de la definici&amp;oacute;n de clase:</target>
        </trans-unit>
        <trans-unit id="12dd0f953c32785837578e88c1ac2b71b7c9df42" translate="yes" xml:space="preserve">
          <source>If a substitution failure would occur in a requires-expression for every possible template argument, the program is ill-formed, no diagnostic required:</source>
          <target state="translated">Si se produjera un fallo de sustitución en una expresión de requisitos para cada posible argumento de plantilla,el programa está mal formado,no se requiere un diagnóstico:</target>
        </trans-unit>
        <trans-unit id="85a2d46acfcfae4cb4dbacf839e2b8264a66b2a5" translate="yes" xml:space="preserve">
          <source>If a textual representation is written using &lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; and that representation is restored into the same or a different object &lt;code&gt;y&lt;/code&gt; of the same type using &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt;, then &lt;code&gt;x==y&lt;/code&gt;.</source>
          <target state="translated">Si una representaci&amp;oacute;n textual se escribe usando &lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; y esa representaci&amp;oacute;n se restaura en el mismo objeto o en uno diferente &lt;code&gt;y&lt;/code&gt; del mismo tipo usando &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt; , entonces &lt;code&gt;x==y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="137821a74c9d0d2d1139c4f208ae9d5537a8856a" translate="yes" xml:space="preserve">
          <source>If a thread offers</source>
          <target state="translated">Si un hilo ofrece</target>
        </trans-unit>
        <trans-unit id="e2107d4d6cd0905d309a488e5a792dc268bd6478" translate="yes" xml:space="preserve">
          <source>If a token matches a user-defined literal syntax and a regular literal syntax, it is assumed to be a regular literal (that is, it's impossible to overload &lt;code&gt;LL&lt;/code&gt; in &lt;code&gt;123LL&lt;/code&gt;).</source>
          <target state="translated">Si un token coincide con una sintaxis literal definida por el usuario y una sintaxis literal regular, se supone que es un literal regular (es decir, es imposible sobrecargar &lt;code&gt;LL&lt;/code&gt; en &lt;code&gt;123LL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e7ee443e3c5d2843d1d2376575bce346735adf6d" translate="yes" xml:space="preserve">
          <source>If a type contains both a &lt;code&gt;value_type&lt;/code&gt; member and a &lt;code&gt;element_type&lt;/code&gt; member, then the specializations (5) and (6) are ambiguous.</source>
          <target state="translated">Si un tipo contiene un miembro &lt;code&gt;value_type&lt;/code&gt; y un elemento &lt;code&gt;element_type&lt;/code&gt; , las especializaciones (5) y (6) son ambiguas.</target>
        </trans-unit>
        <trans-unit id="0fdf3b97165e0c642a71a4a01aa77341934eb9b1" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, the default constructor of the union is deleted by default unless a &lt;a href=&quot;union#Union-like_classes&quot;&gt;variant member&lt;/a&gt; of the union has a default member initializer .</source>
          <target state="translated">Si una uni&amp;oacute;n contiene un miembro de datos no est&amp;aacute;tico con un &lt;a href=&quot;default_constructor&quot;&gt;constructor predeterminado&lt;/a&gt; no trivial , el constructor predeterminado de la uni&amp;oacute;n se elimina de manera predeterminada a menos que un &lt;a href=&quot;union#Union-like_classes&quot;&gt;miembro variante&lt;/a&gt; de la uni&amp;oacute;n tenga un inicializador de miembro predeterminado.</target>
        </trans-unit>
        <trans-unit id="ed781d9376b4a389124dc536ac979cb50e822257" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_constructor&quot;&gt;move&lt;/a&gt; constructor, &lt;a href=&quot;as_operator&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_operator&quot;&gt;move&lt;/a&gt; assignment, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;), that function is deleted by default in the union and needs to be defined explicitly by the programmer.</source>
          <target state="translated">Si una uni&amp;oacute;n contiene un miembro de datos no est&amp;aacute;tico con una funci&amp;oacute;n de miembro especial no trivial ( &lt;a href=&quot;copy_constructor&quot;&gt;copiar&lt;/a&gt; / &lt;a href=&quot;move_constructor&quot;&gt;mover&lt;/a&gt; constructor, &lt;a href=&quot;as_operator&quot;&gt;copiar&lt;/a&gt; / &lt;a href=&quot;move_operator&quot;&gt;mover&lt;/a&gt; asignaci&amp;oacute;n o &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; ), esa funci&amp;oacute;n se elimina por defecto en la uni&amp;oacute;n y debe ser definida expl&amp;iacute;citamente por el programador.</target>
        </trans-unit>
        <trans-unit id="099b8ae16a17dd76f9cadbb47f54a708a0db6c1f" translate="yes" xml:space="preserve">
          <source>If a universal character name does not correspond to a code point in ISO/IEC 10646 (the range 0x0-0x10FFFF, inclusive) or if a universal-character-name corresponds to a surrogate code point (the range 0xD800-0xDFFF, inclusive), the program is ill-formed.</source>
          <target state="translated">Si un nombre de carácter universal no corresponde a un punto de código en ISO/IEC 10646 (el rango 0x0-0x10FFFF,inclusive)o si un nombre de carácter universal corresponde a un punto de código sustituto (el rango 0xD800-0xDFFF,inclusive),el programa está mal formado.</target>
        </trans-unit>
        <trans-unit id="05d3d79510e285cdbcce2e730e70fb609e1930e6" translate="yes" xml:space="preserve">
          <source>If a user-defined &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is provided, the &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is called again on the value that it returns, recursively, until an &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is reached that returns a plain pointer. After that, built-in semantics are applied to that pointer.</source>
          <target state="translated">Si se proporciona un &lt;code&gt;operator-&amp;gt;&lt;/code&gt; definido por el usuario- &amp;gt; , se llama nuevamente al &lt;code&gt;operator-&amp;gt;&lt;/code&gt; en el valor que devuelve, recursivamente, hasta &lt;code&gt;operator-&amp;gt;&lt;/code&gt; se alcanza un operador-&amp;gt; que devuelve un puntero sin formato. Despu&amp;eacute;s de eso, la sem&amp;aacute;ntica incorporada se aplica a ese puntero.</target>
        </trans-unit>
        <trans-unit id="4afbc606ff35300da34cbcea95316abaecaec363" translate="yes" xml:space="preserve">
          <source>If a using-declaration brings the base class assignment operator into derived class, whose signature happens to match the derived class's copy-assignment or move-assignment operator, that operator is hidden by the implicitly-declared copy/move assignment operator of the derived class. Same applies to a using-declaration that inherits a base class constructor that happens to match the derived class copy/move constructor(since C++11).</source>
          <target state="translated">Si una declaración de uso lleva el operador de asignación de clase base a la clase derivada,cuya firma coincide con el operador de asignación de copia o de asignación de movimiento de la clase derivada,ese operador queda oculto por el operador de asignación de copia o de movimiento implícitamente declarado de la clase derivada.Lo mismo se aplica a una declaración de uso que hereda un constructor de clase base que casualmente coincide con el constructor de copia/movimiento de la clase derivada (desde C++11).</target>
        </trans-unit>
        <trans-unit id="f5b571b0ea54c128d0c23143cfd6e47087b60bac" translate="yes" xml:space="preserve">
          <source>If a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence. String concatenation can be used as a workaround:</source>
          <target state="translated">Si un dígito hexagonal válido sigue a un hexágono de escape en una cadena literal,no se compilará como una secuencia de escape inválida.La concatenación de cadenas puede ser usada como una solución alternativa:</target>
        </trans-unit>
        <trans-unit id="e40960cc6f868e411ccb39ae2869971ab6ec8fa0" translate="yes" xml:space="preserve">
          <source>If a violation handler exits by throwing an exception and a contract is violated on a call to a function with a non-throwing exception specification, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called:</source>
          <target state="translated">Si un manejador de violaci&amp;oacute;n sale lanzando una excepci&amp;oacute;n y se viola un contrato en una llamada a una funci&amp;oacute;n con una especificaci&amp;oacute;n de excepci&amp;oacute;n no &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; , se llama a std :: terminate :</target>
        </trans-unit>
        <trans-unit id="89d508127947fb06fdf07d63dd69506781a83552" translate="yes" xml:space="preserve">
          <source>If a virtual function is non-throwing, all declarations, including the definition, of every overrider must be non-throwing as well, unless the overrider is defined as deleted:</source>
          <target state="translated">Si una función virtual no es de lanzamiento,todas las declaraciones,incluida la definición,de cada anulador deben ser también de no lanzamiento,a menos que el anulador se defina como suprimido:</target>
        </trans-unit>
        <trans-unit id="a4f25c0ec9b3244cc6b75eca052c2b903d4a3faa" translate="yes" xml:space="preserve">
          <source>If a width specifier is used, matches exactly</source>
          <target state="translated">Si se utiliza un especificador de ancho,coincide exactamente</target>
        </trans-unit>
        <trans-unit id="ee230d51493f44d873329313db640aba06300254" translate="yes" xml:space="preserve">
          <source>If access-specifier is omitted, it defaults to &lt;code&gt;public&lt;/code&gt; for classes declared with class-key &lt;code&gt;struct&lt;/code&gt; and to &lt;code&gt;private&lt;/code&gt; for classes declared with class-key &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">Si se omite el especificador de acceso, el valor predeterminado es &lt;code&gt;public&lt;/code&gt; para clases declaradas con &lt;code&gt;struct&lt;/code&gt; clave de clase y &lt;code&gt;private&lt;/code&gt; para clases declaradas con clase de clave de &lt;code&gt;class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bb883e9abe3625b7a86952913a7a8fb72c62f08" translate="yes" xml:space="preserve">
          <source>If after preparation is completed, &lt;code&gt;is.good() == true&lt;/code&gt;, then any subsequent calls to &lt;code&gt;operator bool&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si despu&amp;eacute;s de completar la preparaci&amp;oacute;n, &lt;code&gt;is.good() == true&lt;/code&gt; , entonces cualquier llamada posterior al &lt;code&gt;operator bool&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9cb4a02d9dcd9af6fe36d5a1c910eb0e957522e" translate="yes" xml:space="preserve">
          <source>If all scalar types are big-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::big&lt;/code&gt;</source>
          <target state="translated">Si todos los tipos escalares son big-endian, &lt;code&gt;std::endian::native&lt;/code&gt; es igual a &lt;code&gt;std::endian::big&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d891a5fe804d25c6beb79958744a0d7c5ceede89" translate="yes" xml:space="preserve">
          <source>If all scalar types are little-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="translated">Si todos los tipos escalares son little-endian, &lt;code&gt;std::endian::native&lt;/code&gt; es igual a &lt;code&gt;std::endian::little&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d243121b5c4fac9f94b27743279405785142b5" translate="yes" xml:space="preserve">
          <source>If all scalar types have sizeof equal to 1, endianness does not matter and all three values, &lt;code&gt;std::endian::little&lt;/code&gt;, &lt;code&gt;std::endian::big&lt;/code&gt;, and &lt;code&gt;std::endian::native&lt;/code&gt; are the same</source>
          <target state="translated">Si todos los tipos escalares tienen un tama&amp;ntilde;o igual a 1, la endianidad no importa y los tres valores, &lt;code&gt;std::endian::little&lt;/code&gt; , &lt;code&gt;std::endian::big&lt;/code&gt; y &lt;code&gt;std::endian::native&lt;/code&gt; son los mismos</target>
        </trans-unit>
        <trans-unit id="fee72b37f3cceab886b744b0079670d877f9da6f" translate="yes" xml:space="preserve">
          <source>If all these requirements are satisfied, the program behaves as if there is only one definition in the entire program. Otherwise, the behavior is undefined.</source>
          <target state="translated">Si se cumplen todos estos requisitos,el programa se comporta como si hubiera una sola definición en todo el programa.De lo contrario,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="36968e9ab5f085f057a3410989745d6fedfc4429" translate="yes" xml:space="preserve">
          <source>If all variable arguments share a common type, a &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; provides a convenient mechanism (albeit with a different syntax) for accessing variable arguments. In this case however the arguments cannot be modified since &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; can only provide a const pointer to its elements.</source>
          <target state="translated">Si todos los argumentos variables comparten un tipo com&amp;uacute;n, &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; proporciona un mecanismo conveniente (aunque con una sintaxis diferente) para acceder a los argumentos variables. En este caso, sin embargo, los argumentos no pueden modificarse ya que &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; solo puede proporcionar un puntero constante a sus elementos.</target>
        </trans-unit>
        <trans-unit id="3d9bddcd412f103377a475053cbfe6abb6de8ca4" translate="yes" xml:space="preserve">
          <source>If allocation fails, calls &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; which may throw &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la asignaci&amp;oacute;n falla, llama a &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; que puede arrojar &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d22bb8db5e7c03b3a89c230b5d801c2d5d1be4c" translate="yes" xml:space="preserve">
          <source>If allocation fails, the coroutine throws &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;, unless the Promise type defines the member function &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt;. If that member function is defined, allocation uses the &lt;code&gt;nothrow&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; and on allocation failure, the coroutine immediately returns the object obtained from &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; to the caller.</source>
          <target state="translated">Si la asignaci&amp;oacute;n falla, la rutina arroja &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; , a menos que el tipo Promise defina la funci&amp;oacute;n miembro &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; . Si se define esa funci&amp;oacute;n miembro, la asignaci&amp;oacute;n utiliza la &lt;code&gt;nothrow&lt;/code&gt; forma de &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; y en caso de fallo de asignaci&amp;oacute;n, la rutina devuelve inmediatamente el objeto obtenido de &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; al llamante.</target>
        </trans-unit>
        <trans-unit id="10b291b7c1e1eda28b0d49719b46140dae50f0df" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.</source>
          <target state="translated">Si la asignación tiene éxito,devuelve un puntero al más bajo (primer)byte del bloque de memoria asignado que esté adecuadamente alineado para cualquier tipo de objeto.</target>
        </trans-unit>
        <trans-unit id="c9ec1b427a47550a259fb9e7cce19a17de85fede" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any scalar type.</source>
          <target state="translated">Si la asignación tiene éxito,devuelve un puntero al más bajo (primer)byte del bloque de memoria asignado que esté adecuadamente alineado para cualquier tipo de escalar.</target>
        </trans-unit>
        <trans-unit id="02152ab02c6a07719ce83211d89650966926f11f" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function is declared in different translation units, the accumulated sets of default arguments must be the same at the end of each translation unit.</source>
          <target state="translated">Si se declara una funci&amp;oacute;n en &lt;a href=&quot;inline&quot;&gt;l&amp;iacute;nea&lt;/a&gt; en diferentes unidades de traducci&amp;oacute;n, los conjuntos acumulados de argumentos predeterminados deben ser los mismos al final de cada unidad de traducci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1551cfc134da3f21c2cecb1326986402690023a3" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Si un &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b6cc884811a5bc876e80b90a3283051d48412ce" translate="yes" xml:space="preserve">
          <source>If an adaptor takes multiple arguments, these forms are equivalent:</source>
          <target state="translated">Si un adaptador toma múltiples argumentos,estas formas son equivalentes:</target>
        </trans-unit>
        <trans-unit id="e01b1c25d1638defb1bea8fb709196bd2ebf642e" translate="yes" xml:space="preserve">
          <source>If an argument can be interpreted as both a &lt;a href=&quot;type-id&quot;&gt;type-id&lt;/a&gt; and an expression, it is always interpreted as a type-id, even if the corresponding template parameter is non-type:</source>
          <target state="translated">Si un argumento puede interpretarse como una &lt;a href=&quot;type-id&quot;&gt;identificaci&amp;oacute;n de tipo&lt;/a&gt; y una expresi&amp;oacute;n, siempre se interpreta como una identificaci&amp;oacute;n de tipo, incluso si el par&amp;aacute;metro de plantilla correspondiente no es de tipo:</target>
        </trans-unit>
        <trans-unit id="c31ea93038a8a30a4e1fc8e381029269be15af66" translate="yes" xml:space="preserve">
          <source>If an array is so large (greater than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; elements, but less than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; bytes), that the difference between two pointers may not be representable as &lt;code&gt;std::ptrdiff_t&lt;/code&gt;, the result of subtracting two such pointers is undefined.</source>
          <target state="translated">Si una matriz es tan grande (mayor que los elementos &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; , pero menor que los bytes &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; ), la diferencia entre dos punteros puede no ser representable como &lt;code&gt;std::ptrdiff_t&lt;/code&gt; , el resultado de restar dos de estos punteros no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="799e3725591131ec4c78246e418ad8132ce4bd81" translate="yes" xml:space="preserve">
          <source>If an assertion is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the statement to which the assertion is applied.</source>
          <target state="translated">Si se viola una aserci&amp;oacute;n, la ubicaci&amp;oacute;n de origen reflejada en el argumento &lt;code&gt;std::contract_violation&lt;/code&gt; es la ubicaci&amp;oacute;n de origen de la declaraci&amp;oacute;n a la que se aplica la aserci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="940fbe62d35554fccc76640b50d6adbc0079900c" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_acquire&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that</source>
          <target state="translated">Si una tienda at&amp;oacute;mica en el hilo A est&amp;aacute; etiquetada &lt;code&gt;memory_order_release&lt;/code&gt; y una carga at&amp;oacute;mica en el hilo B de la misma variable est&amp;aacute; etiquetada &lt;code&gt;memory_order_acquire&lt;/code&gt; , todas las escrituras de memoria (at&amp;oacute;mica no at&amp;oacute;mica y relajada) que</target>
        </trans-unit>
        <trans-unit id="cf29cb2a4f015597bd5e89b82f0e88a7976c2e6a" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_consume&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that are</source>
          <target state="translated">Si un almac&amp;eacute;n at&amp;oacute;mico en el subproceso A est&amp;aacute; etiquetado como &lt;code&gt;memory_order_release&lt;/code&gt; y una carga at&amp;oacute;mica en el subproceso B de la misma variable est&amp;aacute; etiquetada como &lt;code&gt;memory_order_consume&lt;/code&gt; , todas las escrituras de memoria (at&amp;oacute;mica no at&amp;oacute;mica y relajada) que son</target>
        </trans-unit>
        <trans-unit id="fb35a531d8dbb01db97b20b4045440d69aef50c3" translate="yes" xml:space="preserve">
          <source>If an entity is declared, but not defined in some inner namespace, and then declared through using-declaration in the outer namespace, and then a definition appears in the outer namespace with the same unqualified name, that definition is a member of the outer namespace and conflicts with the using-declration:</source>
          <target state="translated">Si se declara una entidad,pero no se define en algún espacio de nombres interior,y luego se declara mediante la utilización-declaración en el espacio de nombres exterior,y luego aparece una definición en el espacio de nombres exterior con el mismo nombre no cualificado,esa definición es un miembro del espacio de nombres exterior y entra en conflicto con la utilización-declaración:</target>
        </trans-unit>
        <trans-unit id="cc997e2af47722454e317470db77023efe2a1536" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.</source>
          <target state="translated">Si se produce un error,el valor resultante del indicador de posición del archivo para la corriente es indeterminado.</target>
        </trans-unit>
        <trans-unit id="6911b84a61e5b6d4a44d583d9d016bd32e93add2" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.</source>
          <target state="translated">Si se produce un error,el valor resultante del indicador de posición del archivo para la corriente es indeterminado.Si se lee un elemento parcial,su valor es indeterminado.</target>
        </trans-unit>
        <trans-unit id="a220d01f6d39ee26bbdcd1467c8f79348871f6b1" translate="yes" xml:space="preserve">
          <source>If an error occurs, the value of any cached attributes is unspecified.</source>
          <target state="translated">Si se produce un error,no se especifica el valor de los atributos almacenados en la memoria intermedia.</target>
        </trans-unit>
        <trans-unit id="9cb826938ccf3fe4b9ff8ed25a48550d29964cf5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (e.g. by the constructor), the container is left unmodified, as if this function was never called (strong exception guarantee).</source>
          <target state="translated">Si se lanza una excepción (por ejemplo,por el constructor),el contenedor se deja sin modificar,como si nunca se hubiera llamado a esta función (fuerte garantía de excepción).</target>
        </trans-unit>
        <trans-unit id="e6b48d12afec14d3a79a0c500c4659180b4eec6c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (which can be due to &lt;code&gt;Allocator::allocate()&lt;/code&gt; or element copy/move constructor/assignment), this function has no effect (strong exception guarantee).</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n (que puede deberse a &lt;code&gt;Allocator::allocate()&lt;/code&gt; o elemento copiar / mover constructor / asignaci&amp;oacute;n), esta funci&amp;oacute;n no tiene efecto (garant&amp;iacute;a de excepci&amp;oacute;n fuerte).</target>
        </trans-unit>
        <trans-unit id="6b0edabc7639167b7745ce3af46fe3ed92a198db" translate="yes" xml:space="preserve">
          <source>If an exception is thrown and not caught, including exceptions that escape the initial function of &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, the main function, and the constructor or destructor of any static or thread-local objects, then &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. It is implementation-defined whether any stack unwinding takes place for uncaught exceptions.</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n y no se detecta, incluidas las excepciones que escapan de la funci&amp;oacute;n inicial de &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; , la funci&amp;oacute;n principal y el constructor o destructor de cualquier objeto est&amp;aacute;tico o local de thread, se llama a &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Est&amp;aacute; definido por la implementaci&amp;oacute;n si cualquier desbobinado de la pila tiene lugar para excepciones no capturadas.</target>
        </trans-unit>
        <trans-unit id="6c48ec192ada9dad6ea416b0b9a80403d55d5ef7" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, the insertion has no effect.</source>
          <target state="translated">Si una excepción es lanzada por cualquier operación,la inserción no tiene ningún efecto.</target>
        </trans-unit>
        <trans-unit id="74d7d81ca3798adddb2a94c8e751e9f52b51c3b5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect (strong exception guarantee).</source>
          <target state="translated">Si una excepción es lanzada por cualquier operación,esta función no tiene ningún efecto (fuerte garantía de excepción).</target>
        </trans-unit>
        <trans-unit id="5161835af8a659e8b34603c4018519221f368f0d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect.</source>
          <target state="translated">Si una excepción es lanzada por cualquier operación,esta función no tiene ningún efecto.</target>
        </trans-unit>
        <trans-unit id="7330a7b17e421be1c44660348af259ca51b2771d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during &lt;code&gt;insert_after&lt;/code&gt; there are no effects (strong exception guarantee).</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n durante &lt;code&gt;insert_after&lt;/code&gt; no hay efectos (garant&amp;iacute;a de excepci&amp;oacute;n fuerte).</target>
        </trans-unit>
        <trans-unit id="edd7ac01fb9845bcf837eeafecc9a3bfcff9c06c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in &lt;code&gt;[first, last)&lt;/code&gt; are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">Si se lanza una excepci&amp;oacute;n durante la inicializaci&amp;oacute;n, algunos objetos en &lt;code&gt;[first, last)&lt;/code&gt; se dejan en un estado v&amp;aacute;lido pero no especificado, y los objetos ya construidos se destruyen en un orden no especificado.</target>
        </trans-unit>
        <trans-unit id="ec0adbbf8914c8a6c4eec4111473b5a13e8599b3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in the source range are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">Si se lanza una excepción durante la inicialización,algunos objetos en el rango de la fuente se dejan en un estado válido pero no especificado,y los objetos ya construidos se destruyen en un orden no especificado.</target>
        </trans-unit>
        <trans-unit id="e9fecf24ed4ce20def8a83e7f8d57995cf139492" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">Si se lanza una excepción durante la inicialización,los objetos ya construidos se destruyen en un orden no especificado.</target>
        </trans-unit>
        <trans-unit id="e35211af8694cccb5bdef2a4d7dc7571b7be0615" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="translated">Si se lanza una excepción por cualquier razón,esta función no tiene ningún efecto (fuerte garantía de excepción).</target>
        </trans-unit>
        <trans-unit id="7307b2f5ebe1d631c57170aa7d478af487897112" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="translated">Si se lanza una excepción por cualquier razón,esta función no tiene ningún efecto (fuerte garantía de excepción).(desde C++11).</target>
        </trans-unit>
        <trans-unit id="e6bb71e623e7422ccad975c487b4cc2c5f5da503" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from a constructor or (rare) from a destructor of an object (regardless of the object's storage duration), destructors are called for all fully-constructed non-static non-variant (until C++14)members and base classes, in reverse order of completion of their constructors.  Variant members of union-like classes are only destroyed in the case of unwinding from constructor, and if the active member changed between initialization and destruction, the behavior is undefined.(since C++14).</source>
          <target state="translated">Si una excepción es lanzada desde un constructor o (raro)desde un destructor de un objeto (independientemente de la duración de almacenamiento del objeto),los destructores son llamados para todos los miembros no variantes no estáticos completamente construidos (hasta C++14)y las clases base,en orden inverso al de finalización de sus constructores.Los miembros de las variantes de las clases de unión sólo se destruyen en el caso de desenrollarse del constructor,y si el miembro activo cambió entre la inicialización y la destrucción,el comportamiento es indefinido (desde C++14).</target>
        </trans-unit>
        <trans-unit id="2ad1992b7bb0d63f90a28d4087b380a5f34ae1b1" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by T's move constructor, there are no effects.</source>
          <target state="translated">Si se lanza una excepción que no sea por el constructor de movimientos de T,no hay efectos.</target>
        </trans-unit>
        <trans-unit id="0aa3f34d072cd60cd1c35878bea5fd44d2e91e5c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the either end, there are no effects (strong exception guarantee).</source>
          <target state="translated">Si se genera una excepci&amp;oacute;n que no sea el constructor de copia, el constructor de movimiento, el operador de asignaci&amp;oacute;n o el operador de asignaci&amp;oacute;n de movimiento del tipo de valor, o si se produce una excepci&amp;oacute;n mientras se utiliza el &lt;code&gt;emplace&lt;/code&gt; para insertar un &amp;uacute;nico elemento en cada extremo, no hay efectos (fuerte garant&amp;iacute;a de excepci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="e8ab6bfb09942462906da02ee59e1dffd07b24d4" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the end and the value type is either &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or nothrow move constructible, there are no effects (strong exception guarantee).</source>
          <target state="translated">Si se genera una excepci&amp;oacute;n distinta de la del constructor de copia, el constructor de movimiento, el operador de asignaci&amp;oacute;n o el operador de asignaci&amp;oacute;n de movimiento del tipo de valor, o si se produce una excepci&amp;oacute;n mientras se utiliza el &lt;code&gt;emplace&lt;/code&gt; para insertar un &amp;uacute;nico elemento al final y el tipo de valor es ya sea &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; o nothrow move constructible, no hay efectos (garant&amp;iacute;a de excepci&amp;oacute;n fuerte).</target>
        </trans-unit>
        <trans-unit id="2b1a5d269dbdbb9335cbe2fc340876502acdd2c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at either end, this function has no effect (strong exception guarantee).</source>
          <target state="translated">Si se lanza una excepción al insertar un solo elemento en cualquiera de los extremos,esta función no tiene ningún efecto (fuerte garantía de excepción).</target>
        </trans-unit>
        <trans-unit id="bb38c7fc8ae93e70dfd12f9e670486bb28d436c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at the end, and T is &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, there are no effects (strong exception guarantee).</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n al insertar un &amp;uacute;nico elemento al final, y T es &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; o &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , no hay efectos (garant&amp;iacute;a de excepci&amp;oacute;n fuerte).</target>
        </trans-unit>
        <trans-unit id="5998c425618742c5b2fb20a25e64116eb53b0228" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the order of elements in &lt;code&gt;*this&lt;/code&gt; is unspecified.</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n, el orden de los elementos en &lt;code&gt;*this&lt;/code&gt; no se especifica.</target>
        </trans-unit>
        <trans-unit id="b5d6cabb3aae2ee52d65a4c1ac74ad65e7757f3c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the shared lock is not acquired.</source>
          <target state="translated">Si se lanza una excepción,la cerradura compartida no se adquiere.</target>
        </trans-unit>
        <trans-unit id="5440918eea68b650c34253d04fa176ac527a4e96" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, there are no effects (strong exception guarantee).</source>
          <target state="translated">Si se lanza una excepción,no hay efectos (fuerte garantía de excepción).</target>
        </trans-unit>
        <trans-unit id="34d24286b06e2a97113c97c53555bf7644c31051" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (&lt;a href=&quot;../../language/exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;).</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n, esta funci&amp;oacute;n no tiene efecto ( &lt;a href=&quot;../../language/exceptions&quot;&gt;garant&amp;iacute;a de excepci&amp;oacute;n fuerte&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2bd98e6e41884aadeeb627570c45089a1aee3259" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee), except if the exception comes from the comparison function.</source>
          <target state="translated">Si se lanza una excepción,esta función no tiene ningún efecto (fuerte garantía de excepción),excepto si la excepción proviene de la función de comparación.</target>
        </trans-unit>
        <trans-unit id="c56964bda95bd497a307eee33dbbbedb399c8d42" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee).</source>
          <target state="translated">Si se lanza una excepción,esta función no tiene ningún efecto (fuerte garantía de excepción).</target>
        </trans-unit>
        <trans-unit id="b1f960da1aad3dc9c4054b8661e9f9da8db12dca" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee). If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n, esta funci&amp;oacute;n no tiene efecto (garant&amp;iacute;a de excepci&amp;oacute;n fuerte). Si el constructor de movimientos de &lt;code&gt;T&lt;/code&gt; no est&amp;aacute; &lt;code&gt;noexcept&lt;/code&gt; y no es &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; en &lt;code&gt;*this&lt;/code&gt; , vector usar&amp;aacute; el constructor de movimientos de lanzamiento. Si arroja, se renuncia a la garant&amp;iacute;a y los efectos no se especifican.</target>
        </trans-unit>
        <trans-unit id="3e81fff806c92690d8247fab353f430b076a5ddb" translate="yes" xml:space="preserve">
          <source>If an exception was stored in the shared state referenced by the future (e.g. via a call to &lt;a href=&quot;../promise/set_exception&quot;&gt;&lt;code&gt;std::promise::set_exception()&lt;/code&gt;&lt;/a&gt;) then that exception will be thrown.</source>
          <target state="translated">Si se almacen&amp;oacute; una excepci&amp;oacute;n en el estado compartido al que hace referencia el futuro (por ejemplo, mediante una llamada a &lt;a href=&quot;../promise/set_exception&quot;&gt; &lt;code&gt;std::promise::set_exception()&lt;/code&gt; &lt;/a&gt; ), se generar&amp;aacute; esa excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d0137b7a583c99b14138ba2d912173e858c09f48" translate="yes" xml:space="preserve">
          <source>If an implicitly-declared destructor is not deleted, it is implicitly defined (that is, a function body is generated and compiled) by the compiler when it is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. This implicitly-defined destructor has an empty body.</source>
          <target state="translated">Si un destructor declarado impl&amp;iacute;citamente no se elimina, el compilador lo define impl&amp;iacute;citamente (es decir, un cuerpo de funci&amp;oacute;n es generado y compilado) cuando se &lt;a href=&quot;definition#ODR-use&quot;&gt;usa odr&lt;/a&gt; . Este destructor definido impl&amp;iacute;citamente tiene un cuerpo vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="5a6f2dbbaa4e8bf97f99dfa70fb418fa8a9f940e" translate="yes" xml:space="preserve">
          <source>If an inline function is declared in different translation units, the accumulated sets of &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; must be the same at the end of each translation unit.</source>
          <target state="translated">Si se declara una funci&amp;oacute;n en l&amp;iacute;nea en diferentes unidades de traducci&amp;oacute;n, los conjuntos acumulados de &lt;a href=&quot;default_arguments&quot;&gt;argumentos predeterminados&lt;/a&gt; deben ser los mismos al final de cada unidad de traducci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b7990c568402acf3a5d1219a03555ac57df4d740" translate="yes" xml:space="preserve">
          <source>If an inline function or variable(since C++17) with external linkage is defined differently in different translation units, the behavior is undefined.</source>
          <target state="translated">Si una función o variable en línea (desde C++17)con enlace externo se define de forma diferente en diferentes unidades de traducción,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="eb3fc767b94cfd5625015f9349fa6a8307905fac" translate="yes" xml:space="preserve">
          <source>If an insertion is performed, the mapped value is &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; (default-constructed for class types, zero-initialized otherwise) and a reference to it is returned.</source>
          <target state="translated">Si se realiza una inserci&amp;oacute;n, el valor mapeado se &lt;a href=&quot;../../language/value_initialization&quot;&gt;inicializa con el&lt;/a&gt; valor (construido por defecto para los tipos de clase, de lo contrario se inicializa con cero) y se devuelve una referencia al mismo.</target>
        </trans-unit>
        <trans-unit id="18180e9058d1e19c0f11fd992aa464bc733a35a8" translate="yes" xml:space="preserve">
          <source>If an insertion occurs and results in a rehashing of the container, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="translated">Si se produce una inserci&amp;oacute;n y se produce una revalorizaci&amp;oacute;n del contenedor, se invalidan todos los iteradores. De lo contrario, los iteradores no se ven afectados. Las referencias no est&amp;aacute;n invalidadas. La repetici&amp;oacute;n se produce solo si el nuevo n&amp;uacute;mero de elementos es mayor que &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a574aa99696eb2cfb80cca007e805d644a25910" translate="yes" xml:space="preserve">
          <source>If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined.</source>
          <target state="translated">Si la instanciación de una plantilla de arriba depende,directa o indirectamente,de un tipo incompleto,y esa instanciación podría dar un resultado diferente si ese tipo se completara hipotéticamente,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="a64bffb3522d60e8b666b70574ce5d49611f5000" translate="yes" xml:space="preserve">
          <source>If an internal operation throws an exception, it is caught and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; is set. If &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; is set for &lt;code&gt;badbit&lt;/code&gt;, the exception is rethrown.</source>
          <target state="translated">Si una operaci&amp;oacute;n interna arroja una excepci&amp;oacute;n, se &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; y se establece badbit . Si se establece &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;badbit&lt;/code&gt; , se vuelve a generar la excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5a642538c4470f54f4f527d91f99d4f6fe81ff66" translate="yes" xml:space="preserve">
          <source>If an operation on traits emits an exception, the behavior is undefined.</source>
          <target state="translated">Si una operación sobre los rasgos emite una excepción,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="6e13b70715d8672a431c8a76c567c768c6ee6a7b" translate="yes" xml:space="preserve">
          <source>If an overriding function specifies &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;, it must specify the same list contract conditions as the functions it overrides; no diagnostic is required if corresponding conditions will always evaluate to the same value. Otherwise, it is considered to have the list of contract conditions from one of its overriden functions; the names in the contract conditions are bound and the semantic constraints are checked at the point where the contract conditions appear.</source>
          <target state="translated">Si una funci&amp;oacute;n de anulaci&amp;oacute;n especifica &lt;a href=&quot;attributes/contract&quot;&gt;condiciones de contrato&lt;/a&gt; , debe especificar la misma lista de condiciones de contrato que las funciones que anula; no se requiere diagn&amp;oacute;stico si las condiciones correspondientes siempre se evaluar&amp;aacute;n con el mismo valor. De lo contrario, se considera que tiene la lista de condiciones contractuales de una de sus funciones anuladas; los nombres en las condiciones del contrato est&amp;aacute;n vinculados y las restricciones sem&amp;aacute;nticas se verifican en el punto donde aparecen las condiciones del contrato.</target>
        </trans-unit>
        <trans-unit id="ea6490ada6b718e0dd1982f5bd44675af661c0e9" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; references the control block created by &lt;code&gt;std::make_shared&lt;/code&gt; after the lifetime of all shared owners ended, the memory occupied by &lt;code&gt;T&lt;/code&gt; persists until all weak owners get destroyed as well, which may be undesirable if &lt;code&gt;sizeof(T)&lt;/code&gt; is large.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; referencia al bloque de control creado por &lt;code&gt;std::make_shared&lt;/code&gt; despu&amp;eacute;s de que finaliz&amp;oacute; la vida &amp;uacute;til de todos los propietarios compartidos, la memoria ocupada por &lt;code&gt;T&lt;/code&gt; persiste hasta que todos los propietarios d&amp;eacute;biles tambi&amp;eacute;n se destruyan, lo que puede ser indeseable si &lt;code&gt;sizeof(T)&lt;/code&gt; es grande.</target>
        </trans-unit>
        <trans-unit id="be9fa8a822bab5c2b3736388d805151fa47e91f3" translate="yes" xml:space="preserve">
          <source>If any Ti is not a comparison category type (&lt;a href=&quot;weak_equality&quot;&gt;&lt;code&gt;std::weak_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;partial_ordering&quot;&gt;&lt;code&gt;std::partial_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt;), U is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Si cualquier Ti no es un tipo de categor&amp;iacute;a de comparaci&amp;oacute;n ( &lt;a href=&quot;weak_equality&quot;&gt; &lt;code&gt;std::weak_equality&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;strong_equality&quot;&gt; &lt;code&gt;std::strong_equality&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;partial_ordering&quot;&gt; &lt;code&gt;std::partial_ordering&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;weak_ordering&quot;&gt; &lt;code&gt;std::weak_ordering&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;strong_ordering&quot;&gt; &lt;code&gt;std::strong_ordering&lt;/code&gt; &lt;/a&gt; ), U es &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa759a7594dd95d5f9753141e5b119ba2c2846a0" translate="yes" xml:space="preserve">
          <source>If any argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="translated">Si algún argumento es NaN,se devuelve NaN y no se informa del error de dominio</target>
        </trans-unit>
        <trans-unit id="7e09a18bf23aa9504f4b8622f9df9a40a3b55dc8" translate="yes" xml:space="preserve">
          <source>If any candidate function is a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; (static or non-static), but not a constructor, it is treated as if it has an extra parameter (</source>
          <target state="translated">Si alguna funci&amp;oacute;n candidata es una &lt;a href=&quot;member_functions&quot;&gt;funci&amp;oacute;n miembro&lt;/a&gt; (est&amp;aacute;tica o no est&amp;aacute;tica), pero no un constructor, se trata como si tuviera un par&amp;aacute;metro adicional (</target>
        </trans-unit>
        <trans-unit id="a6bcd0ea08bf821e3fbe550757f07bf7cf22d254" translate="yes" xml:space="preserve">
          <source>If any candidate is a function template, its specializations are generated using &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;, and such specializations are treated just like non-template functions except where specified otherwise in the tie-breaker rules. If a name refers to one or more function templates and also to a set of overloaded non-template functions, those functions and the specializations generated from the templates are all candidates.</source>
          <target state="translated">Si alg&amp;uacute;n candidato es una plantilla de funci&amp;oacute;n, sus especializaciones se generan mediante &lt;a href=&quot;template_argument_deduction&quot;&gt;la deducci&amp;oacute;n de argumentos de plantilla&lt;/a&gt; , y dichas especializaciones se tratan como funciones que no son de plantilla, excepto donde se especifique lo contrario en las reglas de desempate. Si un nombre se refiere a una o m&amp;aacute;s plantillas de funciones y tambi&amp;eacute;n a un conjunto de funciones no plantillas sobrecargadas, esas funciones y las especializaciones generadas a partir de las plantillas son todas candidatas.</target>
        </trans-unit>
        <trans-unit id="126493e0cbb7819d68c915080c830634b2cac172" translate="yes" xml:space="preserve">
          <source>If any function that is called directly by the stack unwinding mechanism, after initialization of the exception object and before the start of the exception handler, exits with an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. Such functions include &lt;a href=&quot;destructor&quot;&gt;destructors&lt;/a&gt; of objects with automatic storage duration whose scopes are exited, and the copy constructor of the exception object that is called (&lt;a href=&quot;copy_elision&quot;&gt;if not elided&lt;/a&gt;) to initialize catch-by-value arguments.</source>
          <target state="translated">Si alguna funci&amp;oacute;n a la que llama directamente el mecanismo de desenrollado de la pila, despu&amp;eacute;s de la inicializaci&amp;oacute;n del objeto de excepci&amp;oacute;n y antes del inicio del controlador de excepci&amp;oacute;n, sale con una excepci&amp;oacute;n, se llama a &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Dichas funciones incluyen &lt;a href=&quot;destructor&quot;&gt;destructores&lt;/a&gt; de objetos con duraci&amp;oacute;n de almacenamiento autom&amp;aacute;tico cuyos &amp;aacute;mbitos se abandonan, y el constructor de copia del objeto de excepci&amp;oacute;n que se llama ( &lt;a href=&quot;copy_elision&quot;&gt;si no se omite&lt;/a&gt; ) para inicializar argumentos de captura por valor.</target>
        </trans-unit>
        <trans-unit id="15dfee2b548c068d0cb9438923992bb46bcca31a" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces directly contains an inline namespace, that inline namespace is added to the set.</source>
          <target state="translated">Si algún espacio de nombres del conjunto asociado de clases y espacios de nombres contiene directamente un espacio de nombres en línea,ese espacio de nombres en línea se añade al conjunto.</target>
        </trans-unit>
        <trans-unit id="96b81c5fbadca60870db38fc2f9a183bb9b6fdca" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces is an &lt;a href=&quot;namespace&quot;&gt;inline namespace&lt;/a&gt;, its enclosing namespace is also added to the set.</source>
          <target state="translated">Si cualquier espacio de nombres en el conjunto asociado de clases y espacios de nombres es un &lt;a href=&quot;namespace&quot;&gt;espacio de nombres en l&amp;iacute;nea&lt;/a&gt; , su espacio de nombres adjunto tambi&amp;eacute;n se agrega al conjunto.</target>
        </trans-unit>
        <trans-unit id="77bf32371c11f8b0a2f664f75979c288885d06cb" translate="yes" xml:space="preserve">
          <source>If any of the function calls made, including the call to &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, fails, returns a null pointer. If any of the function calls made throws an exception, the exception is caught and rethrown after calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;. If the file is already closed, returns a null pointer right away.</source>
          <target state="translated">Si alguna de las llamadas a funciones realizadas, incluida la llamada a &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; , falla, devuelve un puntero nulo. Si alguna de las llamadas a funciones realizadas arroja una excepci&amp;oacute;n, la excepci&amp;oacute;n se captura y se vuelve a lanzar despu&amp;eacute;s de llamar a &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; . Si el archivo ya est&amp;aacute; cerrado, devuelve un puntero nulo de inmediato.</target>
        </trans-unit>
        <trans-unit id="96b62f2f876cd9ccd1e029ff20920e414e1372bd" translate="yes" xml:space="preserve">
          <source>If any of the function parameters uses a</source>
          <target state="translated">Si alguno de los parámetros de la función utiliza un</target>
        </trans-unit>
        <trans-unit id="2b9407b136cda4e52a8bcbbff35df15df1b4ed8a" translate="yes" xml:space="preserve">
          <source>If any of the operands is a pointer, the following rules apply:</source>
          <target state="translated">Si alguno de los operandos es un puntero,se aplican las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="6bea11d594aa54f1709b6bc92b826adf56fa3383" translate="yes" xml:space="preserve">
          <source>If any of the private members needs to access a public or protected member, a reference or pointer to the interface may be passed to the private function as a parameter. Alternatively, the back-reference may be maintained as part of the implementation class.</source>
          <target state="translated">Si alguno de los miembros privados necesita acceder a un miembro público o protegido,se puede pasar una referencia o un puntero a la interfaz a la función privada como parámetro.Alternativamente,la referencia trasera puede mantenerse como parte de la clase de implementación.</target>
        </trans-unit>
        <trans-unit id="f4cf008505537dd2a8c50313e658cc2022e63eda" translate="yes" xml:space="preserve">
          <source>If any of these situations occur in a translation unit, the definition of the type must appear in the same translation unit. Otherwise, it is not required.</source>
          <target state="translated">Si alguna de estas situaciones se produce en una unidad de traducción,la definición del tipo debe aparecer en la misma unidad de traducción.De lo contrario,no es necesario.</target>
        </trans-unit>
        <trans-unit id="205c5da68a3eed873a307fa520147b2a4368cf96" translate="yes" xml:space="preserve">
          <source>If any template definition has a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt; in which the qualifier refers to the</source>
          <target state="translated">Si alguna definici&amp;oacute;n de plantilla tiene un &lt;a href=&quot;qualified_lookup&quot;&gt;nombre calificado&lt;/a&gt; en el que el calificador se refiere a</target>
        </trans-unit>
        <trans-unit id="a99969c90cd633e5812cf58136c1c690e70c4d05" translate="yes" xml:space="preserve">
          <source>If any template definition has a member acess expression where the object expression is the</source>
          <target state="translated">Si alguna definición de plantilla tiene una expresión de acceso de miembro donde la expresión de objeto es la</target>
        </trans-unit>
        <trans-unit id="32c3e54b2ab54a4690246c40558fdcba870991e2" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on &lt;code&gt;*this&lt;/code&gt;, calling &lt;code&gt;notify_one&lt;/code&gt; unblocks one of the waiting threads.</source>
          <target state="translated">Si hay hilos esperando &lt;code&gt;*this&lt;/code&gt; , llamar a &lt;code&gt;notify_one&lt;/code&gt; desbloquea uno de los hilos en espera.</target>
        </trans-unit>
        <trans-unit id="7d2a968ab7f2dd81e4eead9cc317c64526456d40" translate="yes" xml:space="preserve">
          <source>If applying &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; to at least one of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; produces a different type, the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt;, if it exists; if not, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">Si la aplicaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; al menos a uno de &lt;code&gt;T1&lt;/code&gt; y &lt;code&gt;T2&lt;/code&gt; produce un tipo diferente, el &lt;code&gt;type&lt;/code&gt; miembro nombra el mismo tipo que &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt; , si existe; si no, no hay &lt;code&gt;type&lt;/code&gt; miembro .</target>
        </trans-unit>
        <trans-unit id="08759afad939001ce25641ffda80dd6d474e5c10" translate="yes" xml:space="preserve">
          <source>If arg is NaN, NaN is returned</source>
          <target state="translated">Si arg es NaN,NaN es devuelto</target>
        </trans-unit>
        <trans-unit id="a3fffd54a9398802b03cfe88989a4c46d2ce5774" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments to an operator in an expression has a class type or an enumeration type, both &lt;a href=&quot;expressions#Operators&quot;&gt;builtin operators&lt;/a&gt; and &lt;a href=&quot;operators&quot;&gt;user-defined operator overloads&lt;/a&gt; participate in overload resolution, with the set of candidate functions selected as follows:</source>
          <target state="translated">Si al menos uno de los argumentos para un operador en una expresi&amp;oacute;n tiene un tipo de clase o un tipo de enumeraci&amp;oacute;n, tanto los &lt;a href=&quot;expressions#Operators&quot;&gt;operadores incorporados&lt;/a&gt; como &lt;a href=&quot;operators&quot;&gt;las sobrecargas de operadores definidas por el usuario&lt;/a&gt; participan en la resoluci&amp;oacute;n de sobrecarga, con el conjunto de funciones candidatas seleccionadas de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="cfa2de104dcda4911fda849d8572dfd8b37d2933" translate="yes" xml:space="preserve">
          <source>If at least one of the deallocation functions is a destroying delete, all non-destroying deletes are ignored.</source>
          <target state="translated">Si al menos una de las funciones de distribución es un borrado destructivo,se ignoran todos los borrados no destructivos.</target>
        </trans-unit>
        <trans-unit id="edc900123598455f7b2624a5d0192ef2c77c276f" translate="yes" xml:space="preserve">
          <source>If at least one of the operands is a pointer or pointer-to-member, array-to-pointer conversions, derived-to-base pointer conversions, function pointer conversions, and qualification conversions are applied as necessary to convert both operands to the same pointer type.</source>
          <target state="translated">Si al menos uno de los operandos es un puntero o un puntero a miembro,se aplican conversiones de matriz a puntero,conversiones de puntero derivado a base,conversiones de puntero de función y conversiones de calificación según sea necesario para convertir ambos operandos al mismo tipo de puntero.</target>
        </trans-unit>
        <trans-unit id="8702bce6fb50aa6cb7bc28c668acc4a3e2449f0f" translate="yes" xml:space="preserve">
          <source>If bool_constexpr returns &lt;code&gt;true&lt;/code&gt;, this declaration has no effect. Otherwise a compile-time error is issued, and the text of message, if any, is included in the diagnostic message.</source>
          <target state="translated">Si bool_constexpr devuelve &lt;code&gt;true&lt;/code&gt; , esta declaraci&amp;oacute;n no tiene efecto. De lo contrario, se emite un error en tiempo de compilaci&amp;oacute;n y el texto del mensaje, si lo hay, se incluye en el mensaje de diagn&amp;oacute;stico.</target>
        </trans-unit>
        <trans-unit id="72593242b61b146efa6a985e10a179d983cf718b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contain values, the contained values are exchanged by calling &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; lvalues must satisfy &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="translated">Si tanto &lt;code&gt;*this&lt;/code&gt; como &lt;code&gt;other&lt;/code&gt; contienen valores, los valores contenidos se intercambian llamando &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt; . &lt;code&gt;T&lt;/code&gt; valores deben satisfacer &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9149200a2a016ffa0cff6b7a2b77a8a41a09bef3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not contain a value, the function has no effect.</source>
          <target state="translated">Si tanto &lt;code&gt;*this&lt;/code&gt; como &lt;code&gt;other&lt;/code&gt; no contienen un valor, la funci&amp;oacute;n no tiene efecto.</target>
        </trans-unit>
        <trans-unit id="51fcf538b4bb73b4d1fbe54dfcf29fa14c9c5798" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Base&lt;/code&gt; and &lt;code&gt;Derived&lt;/code&gt; are non-union class types, and they are not the same type (ignoring cv-qualification), &lt;code&gt;Derived&lt;/code&gt; shall be a &lt;a href=&quot;../language/incomplete_type&quot;&gt;complete type&lt;/a&gt;; otherwise the behavior is undefined.</source>
          <target state="translated">Si tanto &lt;code&gt;Base&lt;/code&gt; como &lt;code&gt;Derived&lt;/code&gt; son tipos de clase no sindicalizados, y no son del mismo tipo (ignorando la calificaci&amp;oacute;n cv), &lt;code&gt;Derived&lt;/code&gt; ser&amp;aacute; un &lt;a href=&quot;../language/incomplete_type&quot;&gt;tipo completo&lt;/a&gt; ; de lo contrario, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="031007df7a4bbbcc69dda82c9142cab39525a5c6" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are reference types before, determine which is more cv-qualified (in all other cases, cv-qualificiations are ignored for partial ordering purposes)</source>
          <target state="translated">Si tanto &lt;code&gt;P&lt;/code&gt; como &lt;code&gt;A&lt;/code&gt; son tipos de referencia anteriores, determine cu&amp;aacute;l es m&amp;aacute;s calificado para cv (en todos los dem&amp;aacute;s casos, las calificaciones de cv se ignoran para fines de pedido parcial)</target>
        </trans-unit>
        <trans-unit id="0fbe1e336c3df9cfce302d24095585fa919b438e" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are zero, returns zero. Otherwise, returns the greatest common divisor of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="translated">Si ambos &lt;code&gt;m&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; son cero, devuelve cero. De lo contrario, devuelve el m&amp;aacute;ximo com&amp;uacute;n divisor de &lt;code&gt;|m|&lt;/code&gt; y &lt;code&gt;|n|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5805a8f51641bf5a39fc87b226394ea5441b146" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent valid dates (&lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt;), the result of the lexicographical comparison is consistent with the calendar order.</source>
          <target state="translated">Si tanto &lt;code&gt;x&lt;/code&gt; como &lt;code&gt;y&lt;/code&gt; representan fechas v&amp;aacute;lidas ( &lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt; ), el resultado de la comparaci&amp;oacute;n lexicogr&amp;aacute;fica es consistente con el orden del calendario.</target>
        </trans-unit>
        <trans-unit id="942dbb8422270823dbf96e8d6ddba2211d8b9ddc" translate="yes" xml:space="preserve">
          <source>If both conversion functions and converting constructors can be used to perform some user-defined conversion, the conversion functions and constructors are both considered by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; in &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; and &lt;a href=&quot;reference_initialization&quot;&gt;reference-initialization&lt;/a&gt; contexts, but only the constructors are considered in &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; contexts.</source>
          <target state="translated">Si ambas funciones de conversi&amp;oacute;n y constructores de conversi&amp;oacute;n se pueden usar para realizar algunas de conversi&amp;oacute;n definida por el usuario, las funciones de conversi&amp;oacute;n y constructores son ambos considerados por &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; en &lt;a href=&quot;copy_initialization&quot;&gt;copia de inicializaci&amp;oacute;n&lt;/a&gt; y &lt;a href=&quot;reference_initialization&quot;&gt;de referencia de inicializaci&amp;oacute;n de&lt;/a&gt; contextos, pero s&amp;oacute;lo los constructores se consideran en &lt;a href=&quot;direct_initialization&quot;&gt;-inicializaci&amp;oacute;n directa&lt;/a&gt; contextos .</target>
        </trans-unit>
        <trans-unit id="a385931d531ce68f4e5f9578700e55c228573984" translate="yes" xml:space="preserve">
          <source>If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;rvalue&lt;/i&gt;&lt;/a&gt; (either a &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;prvalue&lt;/i&gt;&lt;/a&gt; such as a nameless temporary or an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;xvalue&lt;/i&gt;&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt;), and selects the copy assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;lvalue&lt;/i&gt;&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.</source>
          <target state="translated">Si se proporcionan operadores de asignaci&amp;oacute;n de copia y movimiento, la resoluci&amp;oacute;n de sobrecarga selecciona la asignaci&amp;oacute;n de movimiento si el argumento es un valor &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;r&lt;/i&gt;&lt;/a&gt; (un valor &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;pr&lt;/i&gt;&lt;/a&gt; tal como un temporal sin nombre o un valor &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;x&lt;/i&gt;&lt;/a&gt; como el resultado de &lt;code&gt;std::move&lt;/code&gt; ), y selecciona la asignaci&amp;oacute;n de copia si el argumento es un &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;lvalue&lt;/i&gt;&lt;/a&gt; (objeto nombrado o una funci&amp;oacute;n / operador que devuelve la referencia de lvalue). Si solo se proporciona la asignaci&amp;oacute;n de copia, todas las categor&amp;iacute;as de argumentos la seleccionan (siempre que tome su argumento por valor o como referencia a const, ya que los valores pueden unirse a las referencias de constante), lo que hace que la asignaci&amp;oacute;n de copia sea la alternativa para la asignaci&amp;oacute;n de movimiento, cuando se mueve no est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="0bcac6e95caaa2cc81cc604fdcf629399d168aad" translate="yes" xml:space="preserve">
          <source>If both copy and move constructors are provided and no other constructors are viable, overload resolution selects the move constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;rvalue&lt;/a&gt; of the same type (an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt; or a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; such as a nameless temporary(until C++17)), and selects the copy constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.</source>
          <target state="translated">Si se proporcionan constructores de copia y movimiento y ning&amp;uacute;n otro constructor es viable, la resoluci&amp;oacute;n de sobrecarga selecciona el constructor de movimiento si el argumento es un valor &lt;a href=&quot;value_category&quot;&gt;r&lt;/a&gt; del mismo tipo (un valor &lt;a href=&quot;value_category&quot;&gt;x&lt;/a&gt; como el resultado de &lt;code&gt;std::move&lt;/code&gt; o un &lt;a href=&quot;value_category&quot;&gt;valor&lt;/a&gt; como un sin nombre temporal (hasta C ++ 17)), y selecciona el constructor de copia si el argumento es un &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (objeto con nombre o una funci&amp;oacute;n / operador que devuelve la referencia de lvalue). Si solo se proporciona el constructor de copia, todas las categor&amp;iacute;as de argumentos lo seleccionan (siempre que tome una referencia a const, ya que los valores pueden unirse a las referencias de const), lo que hace que la copia del respaldo para el movimiento, cuando el movimiento no est&amp;eacute; disponible.</target>
        </trans-unit>
        <trans-unit id="60aa98cd9f6dc6c43b3235a9ef70bcb42b49d023" translate="yes" xml:space="preserve">
          <source>If both expression are well-formed, the conversion is ambiguous, and the program is ill-formed.</source>
          <target state="translated">Si ambas expresiones están bien formadas,la conversión es ambigua,y el programa está mal formado.</target>
        </trans-unit>
        <trans-unit id="6e8d82bcd24247033be13b857c411fcd62b8ed61" translate="yes" xml:space="preserve">
          <source>If both of the operands are arrays, three-way comparison is ill-formed except when comparing class members of array type.</source>
          <target state="translated">Si ambos operandos son matrices,la comparación entre tres está mal formada,excepto cuando se comparan miembros de la clase de tipo matrices.</target>
        </trans-unit>
        <trans-unit id="c64fda57212a716e4316cdd7fb2f466fbf4fcafb" translate="yes" xml:space="preserve">
          <source>If both operands are signed or both are unsigned, the operand with lesser</source>
          <target state="translated">Si ambos operandos están firmados o ambos están sin firmar,el operando con menor</target>
        </trans-unit>
        <trans-unit id="63fa8968e2f3efc134b4cba9025b815ed6390596" translate="yes" xml:space="preserve">
          <source>If both operands have arithmetic types, or if one operand has unscoped enumeration type and the other has integral type, the usual arithmetic conversions are applied to the operands, and then.</source>
          <target state="translated">Si ambos operandos tienen tipos aritméticos,o si un operando tiene un tipo de enumeración sin alcance y el otro tiene un tipo integral,se aplican las conversiones aritméticas habituales a los operandos,y luego.</target>
        </trans-unit>
        <trans-unit id="3cb97740b2dc89bf4961cce43d6e24c2e65d1e8e" translate="yes" xml:space="preserve">
          <source>If both operands have the same enumeration type E, the operator yields the result of converting the operands to the underlying type of E and applying &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; to the converted operands.</source>
          <target state="translated">Si ambos operandos tienen el mismo tipo de enumeraci&amp;oacute;n E, el operador produce el resultado de convertir los operandos al tipo subyacente de E y aplicar &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; a los operandos convertidos.</target>
        </trans-unit>
        <trans-unit id="70c8bba595d6b98224b1253c961bdde354216878" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; flags are set in &lt;code&gt;policy&lt;/code&gt;, it is up to the implementation whether to perform asynchronous execution or lazy evaluation.</source>
          <target state="translated">Si los indicadores &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; se establecen en la &lt;code&gt;policy&lt;/code&gt; , depende de la implementaci&amp;oacute;n si se realiza una ejecuci&amp;oacute;n asincr&amp;oacute;nica o una evaluaci&amp;oacute;n diferida.</target>
        </trans-unit>
        <trans-unit id="65568841562f35d225fc26d418379905f6cfe94d" translate="yes" xml:space="preserve">
          <source>If both the converted value and the precision are &lt;code&gt;​0​&lt;/code&gt; the conversion results in no characters.</source>
          <target state="translated">Si tanto el valor convertido y la precisi&amp;oacute;n son &lt;code&gt;​0​&lt;/code&gt; los resultados de la conversi&amp;oacute;n en ning&amp;uacute;n car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="575a8782581ff485f4e8203e4d066fcc1e4f258b" translate="yes" xml:space="preserve">
          <source>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, std::imaxdiv_t, respectively), returns both as an object of type &lt;code&gt;std::div_t&lt;/code&gt;, &lt;code&gt;std::ldiv_t&lt;/code&gt;, &lt;code&gt;std::lldiv_t&lt;/code&gt;, &lt;code&gt;std::imaxdiv_t&lt;/code&gt; defined as follows:</source>
          <target state="translated">Si tanto el resto como el cociente pueden representarse como objetos del tipo correspondiente (int, long, long long, std :: imaxdiv_t, respectivamente), devuelve ambos como un objeto de tipo &lt;code&gt;std::div_t&lt;/code&gt; , &lt;code&gt;std::ldiv_t&lt;/code&gt; , &lt;code&gt;std::lldiv_t&lt;/code&gt; , &lt;code&gt;std::imaxdiv_t&lt;/code&gt; definido como sigue:</target>
        </trans-unit>
        <trans-unit id="fa4b3adcc137d0171dfddcda07618256693fd4ac" translate="yes" xml:space="preserve">
          <source>If c16 is the null wide character &lt;code&gt;u'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Si c16 es el car&amp;aacute;cter ancho nulo &lt;code&gt;u'\0'&lt;/code&gt; , se almacena un byte nulo, precedido por cualquier secuencia de cambio necesaria para restaurar el estado de cambio inicial y el par&amp;aacute;metro del estado de conversi&amp;oacute;n &lt;code&gt;*ps&lt;/code&gt; se actualiza para representar el estado de cambio inicial.</target>
        </trans-unit>
        <trans-unit id="0f25466cdf38f545ddf52bc150f2465947dd2dd7" translate="yes" xml:space="preserve">
          <source>If c32 is the null wide character &lt;code&gt;U'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Si c32 es el car&amp;aacute;cter ancho nulo &lt;code&gt;U'\0'&lt;/code&gt; , se almacena un byte nulo, precedido por cualquier secuencia de cambio necesaria para restaurar el estado de cambio inicial y el par&amp;aacute;metro del estado de conversi&amp;oacute;n &lt;code&gt;*ps&lt;/code&gt; se actualiza para representar el estado de cambio inicial.</target>
        </trans-unit>
        <trans-unit id="2180c8a148a56a1d4c18f8160ac19934198a22be" translate="yes" xml:space="preserve">
          <source>If called during exception handling (typically, in a &lt;code&gt;catch&lt;/code&gt; clause), captures the current exception object and creates an &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; that holds either a copy or a reference to that exception object (depending on the implementation). The referenced object remains valid at least as long as there is an &lt;code&gt;exception_ptr&lt;/code&gt; object that refers to it.</source>
          <target state="translated">Si se llama durante el manejo de excepciones (generalmente, en una cl&amp;aacute;usula &lt;code&gt;catch&lt;/code&gt; ), captura el objeto de excepci&amp;oacute;n actual y crea un &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; que contiene una copia o una referencia a ese objeto de excepci&amp;oacute;n (dependiendo de la implementaci&amp;oacute;n). El objeto al que se hace referencia sigue siendo v&amp;aacute;lido al menos mientras haya un objeto &lt;code&gt;exception_ptr&lt;/code&gt; que se refiera a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="f5efa0791c0ccd4598c1223b0ede652827016b2d" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator delete&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void&lt;/code&gt;, the first argument &lt;code&gt;void*&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates. The specialization of the template operator delete is chosen with &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;.</source>
          <target state="translated">Si la &lt;code&gt;operator delete&lt;/code&gt; nivel de clase es una funci&amp;oacute;n de plantilla, debe tener el tipo de retorno de &lt;code&gt;void&lt;/code&gt; , el primer argumento &lt;code&gt;void*&lt;/code&gt; , y debe tener dos o m&amp;aacute;s par&amp;aacute;metros. En otras palabras, solo los formularios de ubicaci&amp;oacute;n pueden ser plantillas. La especializaci&amp;oacute;n de la eliminaci&amp;oacute;n del operador de plantilla se elige con &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;la deducci&amp;oacute;n de argumento de plantilla&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07af41f04d885dcdd7da101bd31c36d13b61ce99" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator new&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void*&lt;/code&gt;, the first argument &lt;code&gt;std::size_t&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates.</source>
          <target state="translated">Si el &lt;code&gt;operator new&lt;/code&gt; nivel de clase nuevo es una funci&amp;oacute;n de plantilla, debe tener el tipo de retorno de &lt;code&gt;void*&lt;/code&gt; , el primer argumento &lt;code&gt;std::size_t&lt;/code&gt; , y debe tener dos o m&amp;aacute;s par&amp;aacute;metros. En otras palabras, solo los formularios de ubicaci&amp;oacute;n pueden ser plantillas.</target>
        </trans-unit>
        <trans-unit id="ceee4451276b8b4bcab8ca22c22b303c8fd7055d" translate="yes" xml:space="preserve">
          <source>If concurrent calls to call_once pass different functions &lt;code&gt;f&lt;/code&gt;, it is unspecified which &lt;code&gt;f&lt;/code&gt; will be called. The selected function runs in the same thread as the &lt;code&gt;call_once&lt;/code&gt; invocation it was passed to.</source>
          <target state="translated">Si las llamadas simult&amp;aacute;neas a call_once pasan diferentes funciones &lt;code&gt;f&lt;/code&gt; , no se especifica a qu&amp;eacute; &lt;code&gt;f&lt;/code&gt; se llamar&amp;aacute;. La funci&amp;oacute;n seleccionada se ejecuta en el mismo hilo que la invocaci&amp;oacute;n &lt;code&gt;call_once&lt;/code&gt; a la que se pas&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="e0b50d3647e11790677fe9a4c279326685cf8395" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is present, control is transferred to the statement labeled with the &lt;code&gt;default:&lt;/code&gt; label.</source>
          <target state="translated">Si la condici&amp;oacute;n eval&amp;uacute;a el valor que no coincide con ninguno de los &lt;code&gt;case:&lt;/code&gt; etiquetas, y el &lt;code&gt;default:&lt;/code&gt; etiqueta est&amp;aacute; presente, el control se transfiere a la declaraci&amp;oacute;n etiquetada con el &lt;code&gt;default:&lt;/code&gt; etiqueta.</target>
        </trans-unit>
        <trans-unit id="c5d36a23ea15e574cf486f3e1d5ad8940a574a30" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that is equal to the value of one of constant_expressions, then control is transferred to the statement that is labeled with that constant_expression.</source>
          <target state="translated">Si la condición se evalúa al valor que es igual al valor de una de las expresiones_constantes,entonces el control se transfiere a la sentencia que está etiquetada con esa expresión_constante.</target>
        </trans-unit>
        <trans-unit id="5aa862d229a90e1dcafc139a33ba48261cc1ac13" translate="yes" xml:space="preserve">
          <source>If condition is a declaration such as &lt;code&gt;T t = x&lt;/code&gt;, the declared variable is only in scope in the body of the loop, and is destroyed and recreated on every iteration, in other words, such while loop is equivalent to.</source>
          <target state="translated">Si condici&amp;oacute;n es una declaraci&amp;oacute;n como &lt;code&gt;T t = x&lt;/code&gt; , la variable declarada solo est&amp;aacute; dentro del alcance del cuerpo del bucle, y se destruye y recrea en cada iteraci&amp;oacute;n, en otras palabras, como el bucle es equivalente a.</target>
        </trans-unit>
        <trans-unit id="cc5437232ebb64eb1e0a00ed4f6909a6272177e2" translate="yes" xml:space="preserve">
          <source>If control reaches the end of a function with the return type &lt;code&gt;void&lt;/code&gt; (possibly cv-qualified), end of a constructor, end of a destructor, or the end of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for a function with the return type (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt; without encountering a return statement, &lt;code&gt;return;&lt;/code&gt; is executed.</source>
          <target state="translated">Si el control alcanza el final de una funci&amp;oacute;n con el tipo de retorno &lt;code&gt;void&lt;/code&gt; (posiblemente calificado por cv), el final de un constructor, el final de un destructor o el final de un &lt;a href=&quot;function-try-block&quot;&gt;bloque&lt;/a&gt; de prueba de funci&amp;oacute;n para una funci&amp;oacute;n con el tipo de retorno (posiblemente cv -calificado) &lt;code&gt;void&lt;/code&gt; sin encontrar una declaraci&amp;oacute;n de &lt;code&gt;return;&lt;/code&gt; , devoluci&amp;oacute;n; es ejecutado.</target>
        </trans-unit>
        <trans-unit id="62b123ef59b7917fbc8133c9aaa1f1f874506d99" translate="yes" xml:space="preserve">
          <source>If control reaches the end of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;, &lt;code&gt;return 0;&lt;/code&gt; is executed.</source>
          <target state="translated">Si el control llega al final de la &lt;a href=&quot;main_function&quot;&gt;funci&amp;oacute;n principal&lt;/a&gt; , &lt;code&gt;return 0;&lt;/code&gt; es ejecutado.</target>
        </trans-unit>
        <trans-unit id="49147bdd2f3429795748cce29beffb564badb873" translate="yes" xml:space="preserve">
          <source>If cv appears after &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of declarator and applies to the pointer that's being declared.</source>
          <target state="translated">Si cv aparece despu&amp;eacute;s de &lt;code&gt;*&lt;/code&gt; en la declaraci&amp;oacute;n del puntero, es parte del declarador y se aplica al puntero que se declara.</target>
        </trans-unit>
        <trans-unit id="4d8f20c7d00a034ba772281f4476c576329d5b6f" translate="yes" xml:space="preserve">
          <source>If cv appears before &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of decl-specifier-seq and applies to the the pointed-to object.</source>
          <target state="translated">Si cv aparece antes &lt;code&gt;*&lt;/code&gt; en la declaraci&amp;oacute;n del puntero, es parte de decl-specifier-seq y se aplica al objeto se&amp;ntilde;alado.</target>
        </trans-unit>
        <trans-unit id="dbec49aac99d6e7dc2b90341eae53b09e233425a" translate="yes" xml:space="preserve">
          <source>If declarations &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt; are constrained and D1's associated constraints subsume D2's associated constraints (or if D2 is unconstrained), then D1 is said to be</source>
          <target state="translated">Si las declaraciones &lt;code&gt;D1&lt;/code&gt; y &lt;code&gt;D2&lt;/code&gt; est&amp;aacute;n restringidas y las restricciones asociadas de D1 subsumen las restricciones asociadas de D2 (o si D2 no est&amp;aacute; restringido), entonces se dice que D1 es</target>
        </trans-unit>
        <trans-unit id="2411be601f654a07bbdca0b7276e84a7d05756e0" translate="yes" xml:space="preserve">
          <source>If deduction fails , or if deduction succeeds, but the specialization it produces would be invalid (for example, an overloaded operator whose parameters are neither class nor enumeration types),(since C++14) the specialization is not included in the overload set, similar to &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;.</source>
          <target state="translated">Si la deducci&amp;oacute;n falla, o si la deducci&amp;oacute;n tiene &amp;eacute;xito, pero la especializaci&amp;oacute;n que produce no ser&amp;iacute;a v&amp;aacute;lida (por ejemplo, un operador sobrecargado cuyos par&amp;aacute;metros no son clase ni tipos de enumeraci&amp;oacute;n), (desde C ++ 14) la especializaci&amp;oacute;n no se incluye en el conjunto de sobrecarga , similar a &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5007ba94c2b890c9a53ac3f2ede0070a7fe62fea" translate="yes" xml:space="preserve">
          <source>If deduction succeeds in both directions, and the original &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; were reference types, then additional tests are made:</source>
          <target state="translated">Si la deducci&amp;oacute;n tiene &amp;eacute;xito en ambas direcciones, y las &lt;code&gt;P&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; originales eran tipos de referencia, se realizan pruebas adicionales:</target>
        </trans-unit>
        <trans-unit id="c96fa04a65c71e2fd19130c8575defd3c41edbfb" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt; is not an integer type, or if either is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, the program is ill-formed.</source>
          <target state="translated">Si &lt;code&gt;M&lt;/code&gt; o &lt;code&gt;N&lt;/code&gt; no es un tipo entero, o si cualquiera es (posiblemente calificado por cv) &lt;code&gt;bool&lt;/code&gt; , el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="c79ea3237a0ed39b951058e0ae87cf69e04e9f5e" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer, the behavior is undefined, even if &lt;code&gt;count&lt;/code&gt; is zero.</source>
          <target state="translated">Si &lt;code&gt;dest&lt;/code&gt; o &lt;code&gt;src&lt;/code&gt; es un puntero nulo, el comportamiento es indefinido, incluso si el &lt;code&gt;count&lt;/code&gt; es cero.</target>
        </trans-unit>
        <trans-unit id="1250474b9c6ad69852373ae63ef180eb204a2f48" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; has an implementation-defined &lt;a href=&quot;file_type&quot;&gt;file type&lt;/a&gt;, the effects of this function are implementation-defined.</source>
          <target state="translated">Si &lt;code&gt;from&lt;/code&gt; o &lt;code&gt;to&lt;/code&gt; tiene un &lt;a href=&quot;file_type&quot;&gt;tipo de archivo&lt;/a&gt; definido por la implementaci&amp;oacute;n , los efectos de esta funci&amp;oacute;n est&amp;aacute;n definidos por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4165a5260d21b11f33113753f30c5f524bccf1ba" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; is not a regular file, a directory, or a symlink, as determined by &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="translated">Si &lt;code&gt;from&lt;/code&gt; o &lt;code&gt;to&lt;/code&gt; no es un archivo normal, un directorio o un enlace simb&amp;oacute;lico, seg&amp;uacute;n lo determinado por &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt; , informa un error</target>
        </trans-unit>
        <trans-unit id="6f243ca5c29fe6335eb0defcad2154158bb206f7" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;m&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt; is zero, returns zero. Otherwise, returns the least common multiple of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;m&lt;/code&gt; o &lt;code&gt;n&lt;/code&gt; es cero, devuelve cero. De lo contrario, devuelve el m&amp;iacute;nimo com&amp;uacute;n m&amp;uacute;ltiplo de &lt;code&gt;|m|&lt;/code&gt; y &lt;code&gt;|n|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dab1eb6195d1939bf5f575a24a97060849eb62a" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;p1&lt;/code&gt; or &lt;code&gt;p2&lt;/code&gt; does not exist, an error is reported.</source>
          <target state="translated">Si &lt;code&gt;p1&lt;/code&gt; o &lt;code&gt;p2&lt;/code&gt; no existen, se informa un error.</target>
        </trans-unit>
        <trans-unit id="192b44dddfe8a0edbf403637b9dc082e8fcbccab" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; is NaN or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; es NaN o &lt;code&gt;y&lt;/code&gt; es NaN, se devuelve NaN</target>
        </trans-unit>
        <trans-unit id="5798cb4e0bd7a6d21c2a60a89c9c101a7f709c34" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">Si &lt;code&gt;x&lt;/code&gt; o &lt;code&gt;y&lt;/code&gt; es NaN, se devuelve NaN</target>
        </trans-unit>
        <trans-unit id="777b045843b0ca1ef95a9acf19549cb4d27be21b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;|m|&lt;/code&gt; or &lt;code&gt;|n|&lt;/code&gt; is not representable as a value of type &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Si cualquiera de &lt;code&gt;|m|&lt;/code&gt; o &lt;code&gt;|n|&lt;/code&gt; no es representable como un valor de tipo &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="b1b8d9bd67fa1ccf8414b0062f383f3be7b83851" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, NaN is returned</source>
          <target state="translated">Si cualquiera de los dos argumentos es NaN,NaN es devuelto</target>
        </trans-unit>
        <trans-unit id="503d04bbbfdfac42a885dc014eabc01dd48a5379" translate="yes" xml:space="preserve">
          <source>If either function is declared despite being unspecified, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal. This makes it possible to instantiate &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si cualquiera de las funciones se declara a pesar de no estar especificada, no se especifica cu&amp;aacute;l es su tipo de retorno, excepto que se garantiza que la declaraci&amp;oacute;n (aunque no necesariamente la definici&amp;oacute;n) de la funci&amp;oacute;n es legal. Esto hace posible crear instancias &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea65a53043b826e1ccaac4bd2898d99fa59f1dd" translate="yes" xml:space="preserve">
          <source>If either operand has scoped enumeration type, no conversion is performed: the other operand and the return type must have the same type</source>
          <target state="translated">Si cualquiera de los operandos tiene el tipo de enumeración de alcance,no se realiza ninguna conversión:el otro operando y el tipo de retorno deben tener el mismo tipo</target>
        </trans-unit>
        <trans-unit id="4facc3a3dde5ddbefb08336856d6b20eb05ed6dc" translate="yes" xml:space="preserve">
          <source>If either the remainder or the quotient cannot be represented, the behavior is undefined.</source>
          <target state="translated">Si no se puede representar el resto o el cociente,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="529682e54cfd3160519cd2474a27a6556b3a893e" translate="yes" xml:space="preserve">
          <source>If erasing at begin - only erased elements</source>
          <target state="translated">Si borrar al principio-sólo elementos borrados</target>
        </trans-unit>
        <trans-unit id="de5cb8f72cd15ee74ae08d973ff1870dcb3c7c8e" translate="yes" xml:space="preserve">
          <source>If erasing at end - only erased elements and the past-the-end iterator</source>
          <target state="translated">Si el borrado al final-sólo los elementos borrados y el iterador del pasado-final</target>
        </trans-unit>
        <trans-unit id="9de48b7003a6c58f9874d3ee61667a92104df825" translate="yes" xml:space="preserve">
          <source>If errors prevent even knowing whether &lt;code&gt;p&lt;/code&gt; exists, the non-throwing overload sets &lt;code&gt;ec&lt;/code&gt; and returns &lt;code&gt;file_status(file_type::none)&lt;/code&gt;, and the throwing overload throws &lt;code&gt;filesystem_error&lt;/code&gt;</source>
          <target state="translated">Si los errores evitan incluso saber si existe &lt;code&gt;p&lt;/code&gt; , la sobrecarga no &lt;code&gt;file_status(file_type::none)&lt;/code&gt; establece &lt;code&gt;ec&lt;/code&gt; y devuelve file_status (file_type :: none) , y la sobrecarga arroja &lt;code&gt;filesystem_error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d96531c98aaf0d81f4a8e0e1ddfb0d8bc73bc9f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="translated">Si la ejecuci&amp;oacute;n de una funci&amp;oacute;n invocada como parte del algoritmo arroja una excepci&amp;oacute;n y &lt;code&gt;ExecutionPolicy&lt;/code&gt; es una de las &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;pol&amp;iacute;ticas est&amp;aacute;ndar&lt;/a&gt; , se llama a &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Para cualquier otra &lt;code&gt;ExecutionPolicy&lt;/code&gt; , el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2f4657ab0e97f8d71eba8e43d00ec9ecedaa739f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="translated">Si la ejecuci&amp;oacute;n de una funci&amp;oacute;n invocada como parte del algoritmo arroja una excepci&amp;oacute;n y &lt;code&gt;ExecutionPolicy&lt;/code&gt; es una de las &lt;a href=&quot;execution_policy_tag_t&quot;&gt;pol&amp;iacute;ticas est&amp;aacute;ndar&lt;/a&gt; , se llama a &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Para cualquier otra &lt;code&gt;ExecutionPolicy&lt;/code&gt; , el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9a2f05c159a24f9f71a90bb51a81dc74cfece89a" translate="yes" xml:space="preserve">
          <source>If expr is omitted in the declaration of an array, the type declared is &quot;array of unknown bound of T&quot;, which is a kind of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, except when used in a declaration with an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initializer&lt;/a&gt;:</source>
          <target state="translated">Si se omite expr en la declaraci&amp;oacute;n de una matriz, el tipo declarado es &quot;matriz de l&amp;iacute;mite desconocido de T&quot;, que es un tipo de &lt;a href=&quot;incomplete_type&quot;&gt;tipo incompleto&lt;/a&gt; , excepto cuando se usa en una declaraci&amp;oacute;n con un &lt;a href=&quot;aggregate_initialization&quot;&gt;inicializador agregado&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d71ce2b38f67adf9252fa0e30106230c2ec3b97c" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function is not called.</source>
          <target state="translated">Si la expresión se evalúa a un valor de puntero nulo,no se llama a los destructores y no se llama a la función de distribución.</target>
        </trans-unit>
        <trans-unit id="6030f7d71e85a510bb8fdfa1c9d0573272b5c6c2" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function may or may not be called (it's implementation-defined), but the default deallocation functions are guaranteed to do nothing when handed a null pointer.</source>
          <target state="translated">Si la expresión se evalúa a un valor de puntero nulo,no se llama a los destructores,y la función de deallocation puede o no llamarse (está definida por la implementación),pero se garantiza que las funciones de deallocation por defecto no harán nada cuando se les entregue un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="5c393875f487dbcd2dff5fb7351c909c9b7c6ee3" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a pointer to a base class subobject of the object that was allocated with &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt;, the destructor of the base class must be virtual, otherwise the behavior is undefined.</source>
          <target state="translated">Si la expresi&amp;oacute;n se eval&amp;uacute;a como un puntero a un subobjeto de clase base del objeto que se asign&amp;oacute; con &lt;a href=&quot;new&quot;&gt;nuevo&lt;/a&gt; , el destructor de la clase base debe ser virtual, de lo contrario el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="1c30833ec734b1a7a3060b4576f5f2e61609aa23" translate="yes" xml:space="preserve">
          <source>If expression has array type &lt;code&gt;A&lt;/code&gt; and no ref-operator is present, then &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; has type</source>
          <target state="translated">Si la expresi&amp;oacute;n tiene un tipo de matriz &lt;code&gt;A&lt;/code&gt; y no hay ning&amp;uacute;n operador de referencia, entonces &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; tiene un tipo</target>
        </trans-unit>
        <trans-unit id="e6b3ab3f640c9298f96902e88e604333b949d1d4" translate="yes" xml:space="preserve">
          <source>If expression is a function call which returns a prvalue of class type or is a &lt;a href=&quot;operator_other&quot;&gt;comma expression&lt;/a&gt; whose right operand is such a function call, a temporary object is not introduced for that prvalue.</source>
          <target state="translated">Si expresi&amp;oacute;n es una llamada de funci&amp;oacute;n que devuelve un valor de tipo de clase o es una &lt;a href=&quot;operator_other&quot;&gt;expresi&amp;oacute;n de coma&lt;/a&gt; cuyo operando correcto es una llamada de funci&amp;oacute;n, no se introduce un objeto temporal para ese valor.</target>
        </trans-unit>
        <trans-unit id="fcbd7c68e8be5419186b82db2695d726340da722" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue other than a (possibly parenthesized) &lt;a href=&quot;consteval&quot;&gt;immediate invocation&lt;/a&gt;(since C++20), a temporary object is not &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from that prvalue.</source>
          <target state="translated">Si la expresi&amp;oacute;n es un valor adicional distinto de una &lt;a href=&quot;consteval&quot;&gt;invocaci&amp;oacute;n inmediata&lt;/a&gt; (posiblemente entre par&amp;eacute;ntesis) (desde C ++ 20), un objeto temporal no se &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializa a&lt;/a&gt; partir de ese valor.</target>
        </trans-unit>
        <trans-unit id="5eb42168b532c7b11548b11828f78705b38da223" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue, the result object is initialized directly by that expression. This does not involve a copy or move constructor when the types match (see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="translated">Si expresi&amp;oacute;n es un valor, el objeto resultante se inicializa directamente por esa expresi&amp;oacute;n. Esto no implica una copia o un constructor de movimiento cuando los tipos coinciden (ver &lt;a href=&quot;copy_elision&quot;&gt;copia elisi&amp;oacute;n&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e15b97975662cad27203429fdb2250f97231751" translate="yes" xml:space="preserve">
          <source>If expression is an lvalue expression that is the (possibly parenthesized) name of an automatic storage duration object declared in the body or as a parameter of the innermost enclosing function or lambda expression, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; to select the constructor to use for initialization of the returned value or, for &lt;code&gt;co_return&lt;/code&gt;, to select the overload of &lt;code&gt;promise.return_value()&lt;/code&gt;(since C++20) is performed</source>
          <target state="translated">Si expresi&amp;oacute;n es una expresi&amp;oacute;n de valor que es el nombre (posiblemente entre par&amp;eacute;ntesis) de un objeto de duraci&amp;oacute;n de almacenamiento autom&amp;aacute;tico declarado en el cuerpo o como un par&amp;aacute;metro de la funci&amp;oacute;n de encierro m&amp;aacute;s interna o expresi&amp;oacute;n lambda, entonces &lt;a href=&quot;overload_resolution&quot;&gt;sobrecargue la resoluci&amp;oacute;n&lt;/a&gt; para seleccionar el constructor que se usar&amp;aacute; para la inicializaci&amp;oacute;n de valor devuelto o, para &lt;code&gt;co_return&lt;/code&gt; , para seleccionar la sobrecarga de &lt;code&gt;promise.return_value()&lt;/code&gt; (ya que se realiza C ++ 20)</target>
        </trans-unit>
        <trans-unit id="adc41fc0a93030206f4cdfeba4b6fcb313c8da70" translate="yes" xml:space="preserve">
          <source>If expression is not a null pointer and the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt; is not a destroying delete(since C++20), the &lt;code&gt;delete&lt;/code&gt; expression invokes the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; (if any) for the object that's being destroyed, or for every element of the array being destroyed (proceeding from the last element to the first element of the array).</source>
          <target state="translated">Si la expresi&amp;oacute;n no es un puntero nulo y la &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;funci&amp;oacute;n de desasignaci&amp;oacute;n&lt;/a&gt; no es una eliminaci&amp;oacute;n destructora (desde C ++ 20), la expresi&amp;oacute;n &lt;code&gt;delete&lt;/code&gt; invoca el &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; (si lo hay) para el objeto que se est&amp;aacute; destruyendo o para cada elemento de la matriz que se est&amp;aacute; destruyendo (pasando del &amp;uacute;ltimo elemento al primer elemento de la matriz).</target>
        </trans-unit>
        <trans-unit id="d68091a3a051bfac77278071ebbbc0e0bd6aacd1" translate="yes" xml:space="preserve">
          <source>If extraction fails (e.g. if a letter was entered where a digit is expected), &lt;code&gt;value&lt;/code&gt; is left unmodified and &lt;code&gt;failbit&lt;/code&gt; is set.</source>
          <target state="translated">Si la extracci&amp;oacute;n falla (por ejemplo, si se ingres&amp;oacute; una letra donde se espera un d&amp;iacute;gito), el &lt;code&gt;value&lt;/code&gt; se deja sin modificar y se establece el &lt;code&gt;failbit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88e6442a7bfe1de939efde09d5178c75fe73775c" translate="yes" xml:space="preserve">
          <source>If extraction fails, zero is written to &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt; is set. If extraction results in the value too large or too small to fit in &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; is written and &lt;code&gt;failbit&lt;/code&gt; flag is set.</source>
          <target state="translated">Si la extracci&amp;oacute;n falla, se escribe cero en el &lt;code&gt;value&lt;/code&gt; y se establece &lt;code&gt;failbit&lt;/code&gt; . Si la extracci&amp;oacute;n da como resultado un valor demasiado grande o demasiado peque&amp;ntilde;o para ajustarse al &lt;code&gt;value&lt;/code&gt; , se &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; y se &lt;code&gt;failbit&lt;/code&gt; indicador de fallo .</target>
        </trans-unit>
        <trans-unit id="9f80eb0726a214c94ee0e311172def7a79d33bde" translate="yes" xml:space="preserve">
          <source>If feature testing is supported, the features described here are indicated by the macro constant &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; with a value equal or greater &lt;code&gt;201505&lt;/code&gt;.</source>
          <target state="translated">Si se admiten pruebas de caracter&amp;iacute;sticas, las caracter&amp;iacute;sticas descritas aqu&amp;iacute; se indican mediante la constante macro &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; con un valor igual o mayor a &lt;code&gt;201505&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7451ef31b492ad560a6bc540d182167c27d069c5" translate="yes" xml:space="preserve">
          <source>If for some &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;X​::​eq_int_type(e, X​::​to_int_type(c))&lt;/code&gt; is true, &lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">Si para algunos &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;X​::​eq_int_type(e, X​::​to_int_type(c))&lt;/code&gt; es verdadero, &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3824d6a7dbddfd44d6a10b166cb4fa4fdc9aa537" translate="yes" xml:space="preserve">
          <source>If forward declaration appears in local scope, it</source>
          <target state="translated">Si la declaración a posteriori aparece en el ámbito local,se</target>
        </trans-unit>
        <trans-unit id="64e89aa46e58a2c727a5922e705eb374f16e676e" translate="yes" xml:space="preserve">
          <source>If implemented, returns the number of characters left to read from the file.</source>
          <target state="translated">Si se implementa,devuelve el número de caracteres que quedan por leer del archivo.</target>
        </trans-unit>
        <trans-unit id="1dbd63790122a2d4ba6e64de77bc6208558b4f4f" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the if statement is equivalent to.</source>
          <target state="translated">Si se utiliza el init-statement,el if es equivalente al.</target>
        </trans-unit>
        <trans-unit id="3828f6a7891b0f54ec954884dcea4fe13ee69fe4" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the switch statement is equivalent to.</source>
          <target state="translated">Si se utiliza la declaración de init,la declaración de switch es equivalente a.</target>
        </trans-unit>
        <trans-unit id="c47d0b28593af3bb521e18dc6a2d3803710c1f80" translate="yes" xml:space="preserve">
          <source>If initialization terminates by throwing an exception (e.g. from the constructor), if new-expression allocated any storage, it calls the appropriate &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt;: &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; for non-array &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; for array &lt;code&gt;type&lt;/code&gt;. The deallocation function is looked up in global scope if the new-expression used the &lt;code&gt;::new&lt;/code&gt; syntax, otherwise it is looked up in the scope of &lt;code&gt;T&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a class type. If the failed allocation function was usual (non-placement), lookup for the deallocation function follows the rules described in &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. For a failed placement new, all parameter types, except the first, of the matching deallocation function must be identical to the parameters of the placement new. The call to the deallocation function is made the value obtained earlier from the allocation function passed as the first argument, alignment passed as the optional alignment argument(since C++17), and &lt;code&gt;placement_params&lt;/code&gt;, if any, passed as the additional placement arguments. If no deallocation function is found, memory is not deallocated.</source>
          <target state="translated">Si termina de inicializaci&amp;oacute;n por lanzar una excepci&amp;oacute;n (por ejemplo del constructor), si la nueva expresi&amp;oacute;n asigna cualquier almacenamiento, llama a la apropiada &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;funci&amp;oacute;n de cancelaci&amp;oacute;n de asignaci&amp;oacute;n&lt;/a&gt; : &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; la no-array &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; para array &lt;code&gt;type&lt;/code&gt; . La funci&amp;oacute;n de desasignaci&amp;oacute;n se busca en el &amp;aacute;mbito global si la nueva expresi&amp;oacute;n utiliza la sintaxis &lt;code&gt;::new&lt;/code&gt; ; de lo contrario, se busca en el &amp;aacute;mbito de &lt;code&gt;T&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de clase. Si la funci&amp;oacute;n de asignaci&amp;oacute;n fallida era habitual (sin ubicaci&amp;oacute;n), la b&amp;uacute;squeda de la funci&amp;oacute;n de desasignaci&amp;oacute;n sigue las reglas descritas en &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. Para una nueva ubicaci&amp;oacute;n fallida, todos los tipos de par&amp;aacute;metros, excepto el primero, de la funci&amp;oacute;n de desasignaci&amp;oacute;n coincidente deben ser id&amp;eacute;nticos a los par&amp;aacute;metros de la nueva ubicaci&amp;oacute;n. La llamada a la funci&amp;oacute;n de desasignaci&amp;oacute;n se convierte en el valor obtenido anteriormente de la funci&amp;oacute;n de asignaci&amp;oacute;n pasada como el primer argumento, la alineaci&amp;oacute;n pasada como el argumento de alineaci&amp;oacute;n opcional (desde C ++ 17), y la &lt;code&gt;placement_params&lt;/code&gt; , si los hay, pasados ​​como argumentos de colocaci&amp;oacute;n adicionales. Si no se encuentra ninguna funci&amp;oacute;n de desasignaci&amp;oacute;n, la memoria no se desasigna.</target>
        </trans-unit>
        <trans-unit id="25af59fbe30345e9f2749bc57dd4353c2aaf12fb" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">Si initializer es una lista de argumentos entre llaves, la matriz se &lt;a href=&quot;aggregate_initialization&quot;&gt;inicializar&amp;aacute; de&lt;/a&gt; forma agregada .</target>
        </trans-unit>
        <trans-unit id="03cdfead59246b594ac83a38977a55a017d25ad2" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the object is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;.</source>
          <target state="translated">Si initializer es una lista de argumentos entre llaves, el objeto se &lt;a href=&quot;list_initialization&quot;&gt;inicializa en una lista&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb798be20c8b8f83663a5d3251bd571437d043f9" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">Si initializer es una lista de argumentos entre par&amp;eacute;ntesis, la matriz se &lt;a href=&quot;aggregate_initialization&quot;&gt;inicializa de&lt;/a&gt; forma agregada .</target>
        </trans-unit>
        <trans-unit id="f352a230f880eaabfec8de9e04e32d41381d1c34" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the object is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt;.</source>
          <target state="translated">Si initializer es una lista de argumentos entre par&amp;eacute;ntesis, el objeto se &lt;a href=&quot;direct_initialization&quot;&gt;inicializa directamente&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b9b4663cfe2da6404a6f0c08f1da0645b33d77" translate="yes" xml:space="preserve">
          <source>If initializer is absent, each element is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">Si el inicializador est&amp;aacute; ausente, cada elemento se &lt;a href=&quot;default_initialization&quot;&gt;inicializa por defecto&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05b0a18ac26e055f0b1b9a9cd56c953cc13ad39f" translate="yes" xml:space="preserve">
          <source>If initializer is absent, the object is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;.</source>
          <target state="translated">Si el inicializador est&amp;aacute; ausente, el objeto se &lt;a href=&quot;default_initialization&quot;&gt;inicializa por defecto&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4a45120f7db08d564e532f628e9ea01317f74f2" translate="yes" xml:space="preserve">
          <source>If initializer is an empty pair of parentheses, each element is &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">Si initializer es un par de par&amp;eacute;ntesis vac&amp;iacute;o, cada elemento tiene un &lt;a href=&quot;value_initialization&quot;&gt;valor inicializado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19ed0a48a00d9537e7ba64e93a84031252754715" translate="yes" xml:space="preserve">
          <source>If it finds abbreviated name, followed by the characters that are valid for the full name, it continues reading until it consumes all the characters for the full name or finds a character that isn't expected, in which case parsing fails even if the first few characters were a valid abbreviation.</source>
          <target state="translated">Si encuentra el nombre abreviado,seguido de los caracteres que son válidos para el nombre completo,continúa leyendo hasta que consume todos los caracteres del nombre completo o encuentra un carácter que no se espera,en cuyo caso el análisis sintáctico falla incluso si los primeros caracteres eran una abreviatura válida.</target>
        </trans-unit>
        <trans-unit id="c6aab4ab699238bc505d419c37703aa0ef2626a9" translate="yes" xml:space="preserve">
          <source>If it is a non-const xvalue, the object to which it refers is in a valid but unspecified state;</source>
          <target state="translated">Si se trata de un valor x no constante,el objeto al que se refiere se encuentra en un estado válido pero no especificado;</target>
        </trans-unit>
        <trans-unit id="a83e8b41c48694346f5c6e5d8a58bf3d4cd145d7" translate="yes" xml:space="preserve">
          <source>If l&amp;ge;128, the behavior is implementation-defined</source>
          <target state="translated">Si l&amp;ge;128, el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="095b63a0e4834384f4f2cd6f96c502aa1765c012" translate="yes" xml:space="preserve">
          <source>If lineno is 0 or greater than 32767(until C++11)2147483647(since C++11), the behavior is undefined.</source>
          <target state="translated">Si el lineno es 0 o mayor que 32767(hasta C++11)2147483647(desde C++11),el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="0ce137b58879463fa5db786928dc6b5433066a3e" translate="yes" xml:space="preserve">
          <source>If lookup finds more than one deallocation function, the function to be called is selected as follows (see &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; for a more detailed description of these functions and their effects):</source>
          <target state="translated">Si la b&amp;uacute;squeda encuentra m&amp;aacute;s de una funci&amp;oacute;n de desasignaci&amp;oacute;n, la funci&amp;oacute;n a llamar se selecciona de la siguiente manera (consulte la &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;funci&amp;oacute;n de desasignaci&amp;oacute;n&lt;/a&gt; para obtener una descripci&amp;oacute;n m&amp;aacute;s detallada de estas funciones y sus efectos):</target>
        </trans-unit>
        <trans-unit id="16f6bcbb6edddebfaed64c4a8ff01d6fc6f7b460" translate="yes" xml:space="preserve">
          <source>If members of a union are classes with user-defined constructors and destructors, to switch the active member, explicit destructor and placement new are generally needed:</source>
          <target state="translated">Si los miembros de una unión son clases con constructores y destructores definidos por el usuario,para cambiar al miembro activo,generalmente se necesita un destructor y una colocación explícitos nuevos:</target>
        </trans-unit>
        <trans-unit id="9aaa368e593ef656dfef2f87849d89081dbdfcf4" translate="yes" xml:space="preserve">
          <source>If more than one match is possible, then any match is an acceptable result</source>
          <target state="translated">Si más de una coincidencia es posible,entonces cualquier coincidencia es un resultado aceptable</target>
        </trans-unit>
        <trans-unit id="02b8b892d773253c24c7deaa868506ebc598bb0d" translate="yes" xml:space="preserve">
          <source>If more than one preferred functions are found, only preferred functions are considered in the next step.</source>
          <target state="translated">Si se encuentra más de una función preferida,en el siguiente paso sólo se consideran las funciones preferidas.</target>
        </trans-unit>
        <trans-unit id="cbd23d50b99e7b96b25fd8ee6be5397b6972349c" translate="yes" xml:space="preserve">
          <source>If more than the implementation-defined maximum number of shared owners already locked the mutex in shared mode, &lt;code&gt;lock_shared&lt;/code&gt; blocks execution until the number of shared owners is reduced. The maximum number of owners is guaranteed to be at least 10000.</source>
          <target state="translated">Si m&amp;aacute;s del n&amp;uacute;mero m&amp;aacute;ximo de propietarios compartidos definido por la implementaci&amp;oacute;n ya bloque&amp;oacute; el mutex en modo compartido, &lt;code&gt;lock_shared&lt;/code&gt; bloquea la ejecuci&amp;oacute;n hasta que se reduzca el n&amp;uacute;mero de propietarios compartidos. Se garantiza que el n&amp;uacute;mero m&amp;aacute;ximo de propietarios sea de al menos 10000.</target>
        </trans-unit>
        <trans-unit id="f645135ade1dcc39a052821b217283911b76e60d" translate="yes" xml:space="preserve">
          <source>If multiple constructors are viable but none is better than the others, the implicit conversion sequence is the ambiguous conversion sequence.</source>
          <target state="translated">Si varios constructores son viables pero ninguno es mejor que los otros,la secuencia de conversión implícita es la secuencia de conversión ambigua.</target>
        </trans-unit>
        <trans-unit id="bbd656e7e48d690ef7ac59721f80eafd7184c36a" translate="yes" xml:space="preserve">
          <source>If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Si varios subprocesos intentan inicializar la misma variable local est&amp;aacute;tica al mismo tiempo, la inicializaci&amp;oacute;n ocurre exactamente una vez (se puede obtener un comportamiento similar para funciones arbitrarias con &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="71891f311caa8357864e30afc2d3a7d5ac7da117" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; (or, deprecated as of C++20, through the &lt;a href=&quot;atomic&quot;&gt;standalone functions&lt;/a&gt; for atomic access to std::shared_ptr).</source>
          <target state="translated">Si varios subprocesos de ejecuci&amp;oacute;n acceden al mismo objeto &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; sin sincronizaci&amp;oacute;n y cualquiera de esos accesos usa una funci&amp;oacute;n de miembro no constante de &lt;code&gt;shared_ptr&lt;/code&gt; , se producir&amp;aacute; una carrera de datos a menos que todo ese acceso se realice a trav&amp;eacute;s de una instancia de &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; (o, en desuso a partir de C ++ 20, a trav&amp;eacute;s de las &lt;a href=&quot;atomic&quot;&gt;funciones independientes&lt;/a&gt; para el acceso at&amp;oacute;mico a std :: shared_ptr).</target>
        </trans-unit>
        <trans-unit id="882b5e537cc3e18e7bf36e2a307bc0559f800747" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through these functions, which are overloads of the corresponding atomic access functions (&lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt;, etc.).</source>
          <target state="translated">Si varios subprocesos de ejecuci&amp;oacute;n acceden al mismo objeto &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; sin sincronizaci&amp;oacute;n y cualquiera de esos accesos utiliza una funci&amp;oacute;n de miembro no constante de &lt;code&gt;shared_ptr&lt;/code&gt; , se producir&amp;aacute; una carrera de datos a menos que todo ese acceso se realice a trav&amp;eacute;s de estas funciones, que son sobrecargas del funciones de acceso at&amp;oacute;mico correspondientes ( &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="bd64a01ec402003b9db85651e928cb1f1bbc53d5" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;weak_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si varios subprocesos de ejecuci&amp;oacute;n acceden al mismo objeto &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; sin sincronizaci&amp;oacute;n y cualquiera de esos accesos utiliza una funci&amp;oacute;n miembro no constante de &lt;code&gt;weak_ptr&lt;/code&gt; , se producir&amp;aacute; una carrera de datos a menos que todo ese acceso se realice a trav&amp;eacute;s de una instancia de &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40f81f722965ce77fe317399aac97f912e696cd4" translate="yes" xml:space="preserve">
          <source>If n&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="translated">Si n&amp;gt; = 128, el comportamiento est&amp;aacute; definido por la implementaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="42e3ee0efc70684fde11275bda977b0d1b55fd68" translate="yes" xml:space="preserve">
          <source>If necessary, obtains the status of &lt;code&gt;to&lt;/code&gt;, by no more than a single call to</source>
          <target state="translated">Si es necesario, obtiene el estado de &lt;code&gt;to&lt;/code&gt; , por no m&amp;aacute;s de una sola llamada a</target>
        </trans-unit>
        <trans-unit id="b0434e8f18603c02eef4062d15cac7f0e1d6bd92" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;*this&lt;/code&gt; nor &lt;code&gt;other&lt;/code&gt; contain a value, the function has no effect.</source>
          <target state="translated">Si ni &lt;code&gt;*this&lt;/code&gt; ni &lt;code&gt;other&lt;/code&gt; contienen un valor, la funci&amp;oacute;n no tiene efecto.</target>
        </trans-unit>
        <trans-unit id="1e8a7e77e5b17bbba28f9f5bde7a2ff9ba1ac92c" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt;, nor any implementation-defined policy flag is set in &lt;code&gt;policy&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Si ni &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; ni &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; , ni se establece ning&amp;uacute;n indicador de pol&amp;iacute;tica definido por la implementaci&amp;oacute;n en la &lt;code&gt;policy&lt;/code&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="403cdbe454265b3fef8904df0622a89b983cd05c" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted copy assignment operator and a defaulted move assignment operator. Otherwise, it has a deleted copy assignment operator (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="translated">Si no se especifica ninguna captura,el tipo de cierre tiene un operador de asignación de copia y un operador de asignación de movimiento por defecto.En caso contrario,tiene un operador de asignación de copia borrado (esto incluye el caso en que hay una captura-por defecto,aunque no capture realmente nada).</target>
        </trans-unit>
        <trans-unit id="1b35fa3984aaeb3db9a1c2d09a20b6a3e68e64ef" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted default constructor. Otherwise, it has no default constructor (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="translated">Si no se especifican capturas,el tipo de cierre tiene un constructor predeterminado.En caso contrario,no tiene ningún constructor por defecto (esto incluye el caso en que hay una captura-por defecto,aunque no capture realmente nada).</target>
        </trans-unit>
        <trans-unit id="cd433247692a3d2cd8a72c9ba4974a4b61306058" translate="yes" xml:space="preserve">
          <source>If no characters are extracted then &lt;code&gt;std::ios::failbit&lt;/code&gt; is set on &lt;code&gt;is&lt;/code&gt;, which may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si no se extraen caracteres, se establece &lt;code&gt;std::ios::failbit&lt;/code&gt; en &lt;code&gt;is&lt;/code&gt; , que puede arrojar &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69c02d0301239909ac59a990ef2ea5d140fa29fd" translate="yes" xml:space="preserve">
          <source>If no characters are extracted, &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; is called.</source>
          <target state="translated">Si no se extraen caracteres, se &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ba27093f4416e619f89024b343671475c2b0970" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="translated">Si no se extrajeron caracteres, llama a &lt;code&gt;setstate(failbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="536ea244a0d993a0064e14e4551396fff4cc9231" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;. In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, a null character (&lt;code&gt;CharT()&lt;/code&gt; is stored in the next successive location of the array.</source>
          <target state="translated">Si no se extrajeron caracteres, llama a &lt;code&gt;setstate(failbit)&lt;/code&gt; . En cualquier caso, si &lt;code&gt;count&amp;gt;0&lt;/code&gt; , un car&amp;aacute;cter nulo ( &lt;code&gt;CharT()&lt;/code&gt; se almacena en la siguiente ubicaci&amp;oacute;n sucesiva de la matriz.</target>
        </trans-unit>
        <trans-unit id="878b0f05459600af7530cf7141a045ee2d7f3e8f" translate="yes" xml:space="preserve">
          <source>If no characters were inserted, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;. If an exception was thrown while extracting, sets &lt;code&gt;failbit&lt;/code&gt; and, if &lt;code&gt;failbit&lt;/code&gt; is set in &lt;code&gt;exceptions()&lt;/code&gt;, rethrows the exception.</source>
          <target state="translated">Si no se insertaron caracteres, ejecuta &lt;code&gt;setstate(failbit)&lt;/code&gt; . Si se produjo una excepci&amp;oacute;n durante la extracci&amp;oacute;n, establece &lt;code&gt;failbit&lt;/code&gt; y, si se establece &lt;code&gt;failbit&lt;/code&gt; en &lt;code&gt;exceptions()&lt;/code&gt; , vuelve a lanzar la excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="edd868dcc474e443c25a49132bd6419f1abf7cca" translate="yes" xml:space="preserve">
          <source>If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Si no hay ning&amp;uacute;n cambio se realiza, &lt;code&gt;​0​&lt;/code&gt; se devuelve.</target>
        </trans-unit>
        <trans-unit id="530f889d2ad8b60ee918f8e2702b7883b29fb175" translate="yes" xml:space="preserve">
          <source>If no errors occur earg</source>
          <target state="translated">Si no se producen errores earg</target>
        </trans-unit>
        <trans-unit id="a4b69264dcfdc184105c0c5fcdc54a8a79767399" translate="yes" xml:space="preserve">
          <source>If no errors occur ln(1+arg) is returned.</source>
          <target state="translated">Si no hay errores,se devuelve ln(1+arg).</target>
        </trans-unit>
        <trans-unit id="f3037fe820d838daa891fb3539a8329f215061a7" translate="yes" xml:space="preserve">
          <source>If no errors occur,</source>
          <target state="translated">Si no se producen errores,</target>
        </trans-unit>
        <trans-unit id="47e97b549aae51b3c35168920f72ade75b7949f9" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;base&lt;/code&gt; raised to the power of &lt;code&gt;exp&lt;/code&gt; (or &lt;code&gt;iexp&lt;/code&gt;) (baseexp</source>
          <target state="translated">Si no se producen errores, la &lt;code&gt;base&lt;/code&gt; se eleva a la potencia de &lt;code&gt;exp&lt;/code&gt; (o &lt;code&gt;iexp&lt;/code&gt; ) (baseexp</target>
        </trans-unit>
        <trans-unit id="ef48764b6bc2b922ac28634b1b57e0a32884367d" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by 2 to the power of &lt;code&gt;exp&lt;/code&gt; (x&amp;times;2exp</source>
          <target state="translated">Si no se producen errores, &lt;code&gt;x&lt;/code&gt; multiplicado por 2 a la potencia de &lt;code&gt;exp&lt;/code&gt; (x &amp;times; 2exp</target>
        </trans-unit>
        <trans-unit id="be1997f1a364feb4c59b1137ec5be5c5163c893c" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; to the power of &lt;code&gt;arg&lt;/code&gt; (x&amp;times;FLT_RADIXexp</source>
          <target state="translated">Si no se producen errores, &lt;code&gt;x&lt;/code&gt; multiplicado por &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; a la potencia de &lt;code&gt;arg&lt;/code&gt; (x &amp;times; FLT_RADIXexp</target>
        </trans-unit>
        <trans-unit id="43e9fba55e5f456a3880c2a5f09b14d52ee81371" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range [0 ; &amp;infin;) along the real axis and in the range [&amp;minus;</source>
          <target state="translated">Si no se producen errores, se devuelve un arco coseno complejo de &lt;code&gt;z&lt;/code&gt; , en el rango [0; &amp;infin;) a lo largo del eje real y en el rango [-</target>
        </trans-unit>
        <trans-unit id="3ba083c7eab3d055b75951c25f225f73acff4188" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">Si no se producen errores, se devuelve un arco seno seno complejo de &lt;code&gt;z&lt;/code&gt; , en el rango de una franja sin l&amp;iacute;mites a lo largo del eje imaginario y en el intervalo [&amp;minus;&amp;pi; / 2; + &amp;pi; / 2] a lo largo del eje real.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
