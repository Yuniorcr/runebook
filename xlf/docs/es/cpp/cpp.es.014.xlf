<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="8b3f01687d89feac7cfe2128cd7fb4336c3f52ee" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;(y*&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(x))&lt;/code&gt;.</source>
          <target state="translated">Los errores y casos especiales se manejan como si la operaci&amp;oacute;n fuera implementada por &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;(y*&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8eceb47949f152b23fef3272be167f4940d38aa" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;cosh&quot;&gt;std::cosh&lt;/a&gt;(i*z)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the imaginary unit.</source>
          <target state="translated">Los errores y casos especiales se manejan como si la operaci&amp;oacute;n fuera implementada por &lt;code&gt;&lt;a href=&quot;cosh&quot;&gt;std::cosh&lt;/a&gt;(i*z)&lt;/code&gt; , donde &lt;code&gt;i&lt;/code&gt; es la unidad imaginaria.</target>
        </trans-unit>
        <trans-unit id="2ab0e556309413233a2f6554e50dca392be2f614" translate="yes" xml:space="preserve">
          <source>Errors are reported as specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los errores se informan como se especifica en &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7331ffbc406cc972b5f70c046e3dc2cb4171b6f9" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Los errores se informan consistentes con &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed0e29a499e18c343b1b41bf866f5a04007120ed" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los errores se informan consistentes con &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5864985afc7c53fae220dc47110ea05595ec5f47" translate="yes" xml:space="preserve">
          <source>Errors may be reported as specified in &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">Los errores pueden ser reportados como se especifica en &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee99754a522541dd514fb00437ecaa5173a3680b" translate="yes" xml:space="preserve">
          <source>Errors that arise during exception handling are handled by &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;(until C++17).</source>
          <target state="translated">Los errores que surgen durante el manejo de excepciones son manejados por &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; (hasta C ++ 17).</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">Secuencias de escape</target>
        </trans-unit>
        <trans-unit id="bd56cff3676fe902e346c447da9fdfeeaa8307a3" translate="yes" xml:space="preserve">
          <source>Escape sequences are used to represent certain special characters within &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; and &lt;a href=&quot;character_literal&quot;&gt;character literals&lt;/a&gt;.</source>
          <target state="translated">Las secuencias de escape se utilizan para representar ciertos caracteres especiales dentro de &lt;a href=&quot;string_literal&quot;&gt;literales de cadena&lt;/a&gt; y &lt;a href=&quot;character_literal&quot;&gt;literales de caracteres&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f742a88872219830426d31bbcd98064272e610fb" translate="yes" xml:space="preserve">
          <source>Essentially, &lt;code&gt;E1&lt;/code&gt; is evaluated and discarded in both cases; 2) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;data_members&quot;&gt;non-static data member&lt;/a&gt;:</source>
          <target state="translated">Esencialmente, &lt;code&gt;E1&lt;/code&gt; se eval&amp;uacute;a y se descarta en ambos casos; 2) si &lt;code&gt;E2&lt;/code&gt; es un &lt;a href=&quot;data_members&quot;&gt;miembro de datos no est&amp;aacute;tico&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cff4774a9f4e9cd8077ee08295f533dd38074331" translate="yes" xml:space="preserve">
          <source>Establishes &lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_weak_ordering&quot;&gt;strict weak ordering&lt;/a&gt; relation with the following properties</source>
          <target state="translated">Establece una &lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_weak_ordering&quot;&gt;estricta&lt;/a&gt; relaci&amp;oacute;n de orden d&amp;eacute;bil con las siguientes propiedades</target>
        </trans-unit>
        <trans-unit id="852a89d52bfbfe13219c2f99e5bebf530d7e1264" translate="yes" xml:space="preserve">
          <source>Establishes &lt;a href=&quot;memory_order&quot;&gt;memory synchronization ordering&lt;/a&gt; of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, without an associated atomic operation.</source>
          <target state="translated">Establece &lt;a href=&quot;memory_order&quot;&gt;la ordenaci&amp;oacute;n&lt;/a&gt; de sincronizaci&amp;oacute;n de memoria de accesos at&amp;oacute;micos no at&amp;oacute;micos y relajados, seg&amp;uacute;n las instrucciones del &lt;code&gt;order&lt;/code&gt; , sin una operaci&amp;oacute;n at&amp;oacute;mica asociada.</target>
        </trans-unit>
        <trans-unit id="f3f364090d806d3b0cee66b4e00edd9582f9bb6b" translate="yes" xml:space="preserve">
          <source>Establishes an &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;, that is, it satisfies the following properties:</source>
          <target state="translated">Establece una &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;relaci&amp;oacute;n de equivalencia&lt;/a&gt; , es decir, satisface las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="8d058e497d38c36626918d3f0a58443807999d35" translate="yes" xml:space="preserve">
          <source>Establishes an equivalence relation. Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x.param() == y.param()&lt;/code&gt; and future infinite sequences of values that would be generated by repeated invocations of &lt;code&gt;x(g1)&lt;/code&gt; and &lt;code&gt;y(g2)&lt;/code&gt; would be equal as long as &lt;code&gt;g1 == g2&lt;/code&gt;.</source>
          <target state="translated">Establece una relaci&amp;oacute;n de equivalencia. Devuelve &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;x.param() == y.param()&lt;/code&gt; y futuras secuencias infinitas de valores que se generar&amp;iacute;an mediante invocaciones repetidas de &lt;code&gt;x(g1)&lt;/code&gt; e &lt;code&gt;y(g2)&lt;/code&gt; ser&amp;iacute;an iguales siempre que &lt;code&gt;g1 == g2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="224e99f2262d85ee9bdcb40ff75322e28286d665" translate="yes" xml:space="preserve">
          <source>Establishes an exception handler around the body of a function.</source>
          <target state="translated">Establece un manejador de excepciones alrededor del cuerpo de una función.</target>
        </trans-unit>
        <trans-unit id="2c8128bfda4d0efc1187706eb75c4af98c699f3e" translate="yes" xml:space="preserve">
          <source>Establishes equivalence relationship with the following properties</source>
          <target state="translated">Establece una relación de equivalencia con las siguientes propiedades</target>
        </trans-unit>
        <trans-unit id="a0a813deb9e43ef1c13a8996290d00b720e38940" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, between a thread and a signal handler executed on the same thread. This is equivalent to &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt;, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as &lt;code&gt;order&lt;/code&gt; instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</source>
          <target state="translated">Establece la ordenaci&amp;oacute;n de sincronizaci&amp;oacute;n de memoria de accesos at&amp;oacute;micos no at&amp;oacute;micos y relajados, seg&amp;uacute;n las instrucciones del &lt;code&gt;order&lt;/code&gt; , entre un subproceso y un controlador de se&amp;ntilde;al ejecutado en el mismo subproceso. Esto es equivalente a &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; , excepto que no se emiten instrucciones de CPU para ordenar la memoria. Solo el reordenamiento de las instrucciones por el compilador se suprime a medida que el &lt;code&gt;order&lt;/code&gt; indica. Por ejemplo, una cerca con sem&amp;aacute;ntica de liberaci&amp;oacute;n evita que las lecturas o escrituras se muevan m&amp;aacute;s all&amp;aacute; de las escrituras posteriores y una cerca con sem&amp;aacute;ntica de adquisici&amp;oacute;n evita que las lecturas o escrituras se muevan antes que las lecturas anteriores.</target>
        </trans-unit>
        <trans-unit id="557e271e8a3a0cf9ee786e9ab59e8bf077dde9c7" translate="yes" xml:space="preserve">
          <source>Estimates the number of characters available for input in the associated character sequence. &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; is guaranteed not to return &lt;code&gt;Traits::eof()&lt;/code&gt; or throw an exception until at least that many characters are extracted.</source>
          <target state="translated">Estima el n&amp;uacute;mero de caracteres disponibles para ingresar en la secuencia de caracteres asociada. &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; est&amp;aacute; garantizado para no devolver &lt;code&gt;Traits::eof()&lt;/code&gt; o lanzar una excepci&amp;oacute;n hasta que se extraigan al menos esa cantidad de caracteres.</target>
        </trans-unit>
        <trans-unit id="5ad645d0b6cf4e8f2f0f5a5463bf7ca6f9950d22" translate="yes" xml:space="preserve">
          <source>Euclidean norm</source>
          <target state="translated">La norma euclidiana</target>
        </trans-unit>
        <trans-unit id="da7594d31984baf99a077013f0aee618827920d2" translate="yes" xml:space="preserve">
          <source>Evaluation order and sequencing</source>
          <target state="translated">Orden de evaluación y secuenciación</target>
        </trans-unit>
        <trans-unit id="f6b2d28039057e6a76561c58410eb4f016c0728f" translate="yes" xml:space="preserve">
          <source>Even before allocator support was removed from &lt;code&gt;std::function&lt;/code&gt; in C++17, these assignment operators use the default allocator rather than the allocator of &lt;code&gt;*this&lt;/code&gt; or the allocator of &lt;code&gt;other&lt;/code&gt; (see &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-closed.html#2386&quot;&gt;LWG #2386&lt;/a&gt;).</source>
          <target state="translated">Incluso antes de que el soporte del asignador se eliminara de la &lt;code&gt;std::function&lt;/code&gt; en C ++ 17, estos operadores de asignaci&amp;oacute;n utilizan el asignador predeterminado en lugar del asignador de &lt;code&gt;*this&lt;/code&gt; o el asignador de &lt;code&gt;other&lt;/code&gt; (ver &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-closed.html#2386&quot;&gt;LWG # 2386&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5bf28a5cb25e295e74fa193c881e4823ae53ebb2" translate="yes" xml:space="preserve">
          <source>Even if &lt;code&gt;ymd.ok()&lt;/code&gt; is true, the resulting &lt;code&gt;year_month_day&lt;/code&gt; may not represent a valid date if &lt;code&gt;ymd.day()&lt;/code&gt; is 29, 30, or 31.</source>
          <target state="translated">Incluso si &lt;code&gt;ymd.ok()&lt;/code&gt; es verdadero, el &lt;code&gt;year_month_day&lt;/code&gt; resultante puede no representar una fecha v&amp;aacute;lida si &lt;code&gt;ymd.day()&lt;/code&gt; es 29, 30 o 31.</target>
        </trans-unit>
        <trans-unit id="13f714ec21c59f4555ffdd439f65ba1de4339a70" translate="yes" xml:space="preserve">
          <source>Even if &lt;code&gt;ymwd.ok()&lt;/code&gt; is true, the resulting &lt;code&gt;year_month_weekday&lt;/code&gt; may not represent a valid date if &lt;code&gt;ymwd.index()&lt;/code&gt; is 5.</source>
          <target state="translated">Incluso si &lt;code&gt;ymwd.ok()&lt;/code&gt; es verdadero, el &lt;code&gt;year_month_weekday&lt;/code&gt; resultante puede no representar una fecha v&amp;aacute;lida si &lt;code&gt;ymwd.index()&lt;/code&gt; es 5.</target>
        </trans-unit>
        <trans-unit id="d9c13458a40bd815f989f602ad0395796fb458d9" translate="yes" xml:space="preserve">
          <source>Even if notified under lock, overload (1) makes no guarantees about the state of the associated predicate when returning due to timeout.</source>
          <target state="translated">Incluso si se notifica bajo llave,la sobrecarga (1)no garantiza el estado del predicado asociado al regresar debido al tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="e8a756d7fa529afd7aeb13d1511bd134a3d2cc0c" translate="yes" xml:space="preserve">
          <source>Even if the clock in use is &lt;code&gt;&lt;a href=&quot;../../chrono/steady_clock&quot;&gt;std::chrono::steady_clock&lt;/a&gt;&lt;/code&gt; or another monotonic clock, a system clock adjustment may induce a spurious wakeup.</source>
          <target state="translated">Incluso si el reloj en uso es &lt;code&gt;&lt;a href=&quot;../../chrono/steady_clock&quot;&gt;std::chrono::steady_clock&lt;/a&gt;&lt;/code&gt; u otro reloj mon&amp;oacute;tono, un ajuste del reloj del sistema puede inducir una activaci&amp;oacute;n espuria.</target>
        </trans-unit>
        <trans-unit id="30fbd007da85ebd7312535e0cc529833d2a4d4fe" translate="yes" xml:space="preserve">
          <source>Even if the name to the left of &lt;code&gt;::&lt;/code&gt; refers to a namespace, the template disambiguator is allowed:</source>
          <target state="translated">Incluso si el nombre a la izquierda de &lt;code&gt;::&lt;/code&gt; se refiere a un espacio de nombres, el desambigador de plantilla est&amp;aacute; permitido:</target>
        </trans-unit>
        <trans-unit id="82ac5cb6cfab85d924b4733697e77158a0419204" translate="yes" xml:space="preserve">
          <source>Even if the shared variable is atomic, it must be modified under the mutex in order to correctly publish the modification to the waiting thread.</source>
          <target state="translated">Incluso si la variable compartida es atómica,debe ser modificada bajo el mutex para publicar correctamente la modificación en el hilo de espera.</target>
        </trans-unit>
        <trans-unit id="4d9633b8291e518788e5b04c3307f8044e23b7cb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;%c&lt;/code&gt; expects &lt;code&gt;int&lt;/code&gt; argument, it is safe to pass a &lt;code&gt;char&lt;/code&gt; because of the integer promotion that takes place when a variadic function is called.</source>
          <target state="translated">Aunque &lt;code&gt;%c&lt;/code&gt; espera un argumento &lt;code&gt;int&lt;/code&gt; , es seguro pasar un &lt;code&gt;char&lt;/code&gt; debido a la promoci&amp;oacute;n de enteros que tiene lugar cuando se llama a una funci&amp;oacute;n variadic.</target>
        </trans-unit>
        <trans-unit id="eef899288103457cb2c6536cbb280b5cca3eb991" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;if&lt;/code&gt; is a &lt;a href=&quot;../../keywords/if&quot;&gt;keyword&lt;/a&gt; in C++, it is a ud-suffix of the &lt;a href=&quot;../../language/user_literal&quot;&gt;literal operator&lt;/a&gt; of the form &lt;code&gt;operator &quot;&quot;if&lt;/code&gt; and in the literal expressions such as &lt;code&gt;1if&lt;/code&gt; or &lt;code&gt;1.0if&lt;/code&gt; because it is not separated by whitespace and is not a standalone token.</source>
          <target state="translated">Aunque &lt;code&gt;if&lt;/code&gt; es una &lt;a href=&quot;../../keywords/if&quot;&gt;palabra clave&lt;/a&gt; en C ++, es un sufijo ud del &lt;a href=&quot;../../language/user_literal&quot;&gt;operador literal del operador&lt;/a&gt; de forma &lt;code&gt;operator &quot;&quot;if&lt;/code&gt; y en las expresiones literales como &lt;code&gt;1if&lt;/code&gt; o &lt;code&gt;1.0if&lt;/code&gt; porque no est&amp;aacute; separado por espacios en blanco y no es un token independiente .</target>
        </trans-unit>
        <trans-unit id="205833ef6be0b707c638302ab3b276a23d851ced" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;try&lt;/code&gt; blocks are allowed in constexpr functions, throwing exceptions is still disallowed in a constant expression.</source>
          <target state="translated">A pesar de que los bloques &lt;code&gt;try&lt;/code&gt; est&amp;aacute;n permitidos en las funciones constexpr, no se permiten arrojar excepciones en una expresi&amp;oacute;n constante.</target>
        </trans-unit>
        <trans-unit id="beca8aa735200901df75e963c1c548f38fd8410f" translate="yes" xml:space="preserve">
          <source>Even though destructors are not inherited, if a base class declares its destructor &lt;code&gt;virtual&lt;/code&gt;, the derived destructor always overrides it. This makes it possible to delete dynamically allocated objects of polymorphic type through pointers to base.</source>
          <target state="translated">Aunque los destructores no se heredan, si una clase base declara su destructor &lt;code&gt;virtual&lt;/code&gt; , el destructor derivado siempre lo anula. Esto hace posible eliminar objetos asignados din&amp;aacute;micamente de tipo polim&amp;oacute;rfico a trav&amp;eacute;s de punteros a la base.</target>
        </trans-unit>
        <trans-unit id="fd583cbe0ab59fe4a28f57f7cb504c86fd58cbce" translate="yes" xml:space="preserve">
          <source>Even though names in an unnamed namespace may be declared with external linkage, they are never accessible from other translation units because their namespace name is unique.</source>
          <target state="translated">Aunque los nombres de un espacio de nombres sin nombre pueden declararse con vinculación externa,nunca se puede acceder a ellos desde otras unidades de traducción porque su nombre de espacio de nombres es único.</target>
        </trans-unit>
        <trans-unit id="89f989b918b3efa1509410878202d64feeaad6c7" translate="yes" xml:space="preserve">
          <source>Even though the non-allocating placement new (9,10) cannot be replaced, a function with the same signature may be defined at class scope as described above. In addition, global overloads that look like placement new but take a non-void pointer type as the second argument are allowed, so the code that wants to ensure that the true placement new is called (e.g. &lt;code&gt;&lt;a href=&quot;../allocator/construct&quot;&gt;std::allocator::construct&lt;/a&gt;&lt;/code&gt;), must use &lt;code&gt;::new&lt;/code&gt; and also cast the pointer to &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">Aunque la ubicaci&amp;oacute;n no asignada nueva (9,10) no se puede reemplazar, una funci&amp;oacute;n con la misma firma se puede definir en el alcance de la clase como se describi&amp;oacute; anteriormente. Adem&amp;aacute;s, las sobrecargas globales que parecen una nueva ubicaci&amp;oacute;n pero toman un tipo de puntero no vac&amp;iacute;o ya que se permite el segundo argumento, por lo que el c&amp;oacute;digo que quiere garantizar que se llame a la nueva ubicaci&amp;oacute;n verdadera (por ejemplo, &lt;code&gt;&lt;a href=&quot;../allocator/construct&quot;&gt;std::allocator::construct&lt;/a&gt;&lt;/code&gt; ), debe usar &lt;code&gt;::new&lt;/code&gt; y tambi&amp;eacute;n lanzar el puntero a &lt;code&gt;void*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f76a45b89412fbbe4ac41ff04a11f89153e89cd3" translate="yes" xml:space="preserve">
          <source>Even though top-level &lt;a href=&quot;cv&quot;&gt;cv-qualifiers&lt;/a&gt; on the parameters are discarded in function declarations, they modify the type of the parameter as visible in the body of a function:</source>
          <target state="translated">Aunque &lt;a href=&quot;cv&quot;&gt;los calificadores cv de&lt;/a&gt; nivel superior en los par&amp;aacute;metros se descartan en las declaraciones de funci&amp;oacute;n, modifican el tipo del par&amp;aacute;metro como visible en el cuerpo de una funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a45dfe469d18cb059aef8c5b79aaf3c568df5677" translate="yes" xml:space="preserve">
          <source>Even when the destructor is called directly (e.g. &lt;code&gt;obj.~Foo();&lt;/code&gt;), the return statement in &lt;code&gt;~Foo()&lt;/code&gt; does not return control to the caller immediately: it calls all those member and base destructors first.</source>
          <target state="translated">Incluso cuando se llama directamente al destructor (por ejemplo, &lt;code&gt;obj.~Foo();&lt;/code&gt; ), la instrucci&amp;oacute;n return en &lt;code&gt;~Foo()&lt;/code&gt; no devuelve el control a la persona que llama de inmediato: primero llama a todos esos destructores de miembros y bases.</target>
        </trans-unit>
        <trans-unit id="c457cc0cca53f5efaec11bdae6464c7a8f3d1683" translate="yes" xml:space="preserve">
          <source>Even with relaxed memory model, out-of-thin-air values are not allowed to circularly depend on their own computations, for example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">Incluso con el modelo de memoria relajada, no se permite que los valores imprecisos dependan circularmente de sus propios c&amp;aacute;lculos, por ejemplo, con &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; inicialmente cero,</target>
        </trans-unit>
        <trans-unit id="0d294028b66fc033fb8f8b33345165f1b149cdc7" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; and &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; has a</source>
          <target state="translated">Cada &lt;a href=&quot;objects&quot;&gt;objeto&lt;/a&gt; y &lt;a href=&quot;reference&quot;&gt;referencia&lt;/a&gt; tiene un</target>
        </trans-unit>
        <trans-unit id="1e3d5eff0d465c69879e0e0871021f12c2fae6c2" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; is parametrized by one or more template parameters, indicated in the parameter-list of the template declaration syntax:</source>
          <target state="translated">Cada &lt;a href=&quot;templates&quot;&gt;plantilla&lt;/a&gt; est&amp;aacute; parametrizada por uno o m&amp;aacute;s par&amp;aacute;metros de plantilla, indicados en la lista de par&amp;aacute;metros de la sintaxis de declaraci&amp;oacute;n de plantilla:</target>
        </trans-unit>
        <trans-unit id="9a47d9aa16911998ba8cb56b9196661886621057" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt; has the property called</source>
          <target state="translated">Cada &lt;a href=&quot;type-id&quot;&gt;tipo de objeto&lt;/a&gt; tiene la propiedad llamada</target>
        </trans-unit>
        <trans-unit id="d4c1d197b0b4ce5bf0d47347c3c212d7928dae9a" translate="yes" xml:space="preserve">
          <source>Every call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; freezes the stream to preserve the validity of the pointer it returns. To allow the destructor to deallocate the buffer, &lt;code&gt;freeze(false)&lt;/code&gt; needs to be called explicitly.</source>
          <target state="translated">Cada llamada a &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; congela la secuencia para preservar la validez del puntero que devuelve. Para permitir que el destructor desasigne el b&amp;uacute;fer, debe invocarse expl&amp;iacute;citamente &lt;code&gt;freeze(false)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="267f5eca029a0473ad86866143a283d6e67dc0cd" translate="yes" xml:space="preserve">
          <source>Every catch-clause in the function-try-block for a constructor must terminate by throwing an exception. If the control reaches the end of such handler, the current exception is automatically rethrown as if by &lt;code&gt;throw;&lt;/code&gt;. The return statement is not allowed in any catch clause of a constructor's function-try-block.</source>
          <target state="translated">Cada cl&amp;aacute;usula catch en el bloque de prueba de funci&amp;oacute;n para un constructor debe terminar lanzando una excepci&amp;oacute;n. Si el control llega al final de dicho controlador, la excepci&amp;oacute;n actual se vuelve a &lt;code&gt;throw;&lt;/code&gt; autom&amp;aacute;ticamente como si fuera un lanzamiento; . La declaraci&amp;oacute;n de retorno no est&amp;aacute; permitida en ninguna cl&amp;aacute;usula catch de la funci&amp;oacute;n try-block del constructor.</target>
        </trans-unit>
        <trans-unit id="40c918ca9b8fb74eddbf2e3635eb193312898d9a" translate="yes" xml:space="preserve">
          <source>Every character &lt;code&gt;c&lt;/code&gt; obtained in Stage 1, other than the decimal point &lt;code&gt;'.'&lt;/code&gt;, is converted to &lt;code&gt;CharT&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).widen(c)&lt;/code&gt;.</source>
          <target state="translated">Todos los caracteres &lt;code&gt;c&lt;/code&gt; obtenidos en la Etapa 1, excepto el punto decimal &lt;code&gt;'.'&lt;/code&gt; , se convierte a &lt;code&gt;CharT&lt;/code&gt; llamando a &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).widen(c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55240b46d1b2c778147a32f69f02140623223676" translate="yes" xml:space="preserve">
          <source>Every copy assignment operator is &lt;a href=&quot;../language/as_operator#Trivial_copy_assignment_operator&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">Cada operador de asignaci&amp;oacute;n de copias es &lt;a href=&quot;../language/as_operator#Trivial_copy_assignment_operator&quot;&gt;trivial&lt;/a&gt; o eliminado</target>
        </trans-unit>
        <trans-unit id="44ece2209b7a05d39c75b1dcbb965646849a11d9" translate="yes" xml:space="preserve">
          <source>Every copy constructor is &lt;a href=&quot;../language/copy_constructor#Trivial_copy_constructor&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">Cada constructor de copia es &lt;a href=&quot;../language/copy_constructor#Trivial_copy_constructor&quot;&gt;trivial&lt;/a&gt; o eliminado</target>
        </trans-unit>
        <trans-unit id="ddca33bae1f5063131bf99b04d54385eb0d2361a" translate="yes" xml:space="preserve">
          <source>Every coroutine must have a return type that satisfies a number of requirements, noted below.</source>
          <target state="translated">Cada cortinilla debe tener un tipo de devolución que satisfaga una serie de requisitos,que se indican a continuación.</target>
        </trans-unit>
        <trans-unit id="6f0b1e2abf2c7b435c80221dcc61afd569006cf6" translate="yes" xml:space="preserve">
          <source>Every direct base of &lt;code&gt;T&lt;/code&gt; has a trivial default constructor</source>
          <target state="translated">Cada base directa de &lt;code&gt;T&lt;/code&gt; tiene un constructor trivial predeterminado</target>
        </trans-unit>
        <trans-unit id="e4f4a9e39d552d4d3b8434b290840e0cb2a72f79" translate="yes" xml:space="preserve">
          <source>Every expression required to be equality preserving is further required to be</source>
          <target state="translated">Toda expresión que se requiera para preservar la igualdad se requiere además que sea</target>
        </trans-unit>
        <trans-unit id="596cadab563dc077013bb82171b4d411422fe26e" translate="yes" xml:space="preserve">
          <source>Every function in C++ is either</source>
          <target state="translated">Cada función en C++es</target>
        </trans-unit>
        <trans-unit id="2e5a037bddcba35d74d8f0e90f7f426c42f8bbb7" translate="yes" xml:space="preserve">
          <source>Every function type, every function name with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, and every variable name with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, has a property called</source>
          <target state="translated">Cada tipo de funci&amp;oacute;n, cada nombre de funci&amp;oacute;n con &lt;a href=&quot;storage_duration&quot;&gt;enlace externo&lt;/a&gt; y cada nombre de variable con &lt;a href=&quot;storage_duration&quot;&gt;enlace externo&lt;/a&gt; , tiene una propiedad llamada</target>
        </trans-unit>
        <trans-unit id="9220204e7dd00c7e1b3f8ea123e9b7a6432dc43a" translate="yes" xml:space="preserve">
          <source>Every initializer clause is &lt;a href=&quot;eval_order&quot;&gt;sequenced before&lt;/a&gt; any initializer clause that follows it in the braced-init-list. This is in contrast with the arguments of a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;, which are &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt;.</source>
          <target state="translated">Cada cl&amp;aacute;usula de inicializador se &lt;a href=&quot;eval_order&quot;&gt;secuencia antes de&lt;/a&gt; cualquier cl&amp;aacute;usula de inicializador que le sigue en la lista de inicializaci&amp;oacute;n con llaves. Esto contrasta con los argumentos de una &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;expresi&amp;oacute;n de llamada de funci&amp;oacute;n&lt;/a&gt; , que no est&amp;aacute;n &lt;a href=&quot;eval_order&quot;&gt;secuenciados&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ec13c0519794ea073e3092993cf4c79e0a531c" translate="yes" xml:space="preserve">
          <source>Every move assignment operator is &lt;a href=&quot;../language/move_operator#Trivial_move_assignment_operator&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">Cada operador de asignaci&amp;oacute;n de movimiento es &lt;a href=&quot;../language/move_operator#Trivial_move_assignment_operator&quot;&gt;trivial&lt;/a&gt; o eliminado</target>
        </trans-unit>
        <trans-unit id="be04d7a82c5aad5c68ef07fc699cbbb387d1c3f3" translate="yes" xml:space="preserve">
          <source>Every move constructor is &lt;a href=&quot;../language/move_constructor#Trivial_move_constructor&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">Cada constructor de movimiento es &lt;a href=&quot;../language/move_constructor#Trivial_move_constructor&quot;&gt;trivial&lt;/a&gt; o eliminado</target>
        </trans-unit>
        <trans-unit id="cec5230f04de71fff49fd937f9a018fd570d7a46" translate="yes" xml:space="preserve">
          <source>Every name that denotes an entity is introduced into the program by a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;. Every name that denotes a label is introduced into the program either by a &lt;a href=&quot;goto&quot;&gt;goto statement&lt;/a&gt; or by a &lt;a href=&quot;statements#Labels&quot;&gt;labeled statement&lt;/a&gt;. A name used in more than one translation unit may refer to the same or different entities, depending on &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt;.</source>
          <target state="translated">Cada nombre que denota una entidad se introduce en el programa mediante una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; . Cada nombre que denota una etiqueta se introduce en el programa ya sea por una &lt;a href=&quot;goto&quot;&gt;declaraci&amp;oacute;n goto&lt;/a&gt; o por una &lt;a href=&quot;statements#Labels&quot;&gt;declaraci&amp;oacute;n etiquetada&lt;/a&gt; . Un nombre usado en m&amp;aacute;s de una unidad de traducci&amp;oacute;n puede referirse a la misma o diferentes entidades, dependiendo del &lt;a href=&quot;storage_duration#Linkage&quot;&gt;enlace&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b69a8648e61c5f2cb090d5c8ee69368fecb775bd" translate="yes" xml:space="preserve">
          <source>Every non-static data member of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; must be a direct member of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; or the same base class of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;, and must be well-formed in the context of the structured binding when named as &lt;code&gt;&lt;i&gt;&lt;b&gt;e&lt;/b&gt;&lt;/i&gt;.&lt;i&gt;name&lt;/i&gt;&lt;/code&gt;. &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; may not have an anonymous union member. The number of identifiers must equal the number of non-static data members.</source>
          <target state="translated">Cada miembro de datos no est&amp;aacute;ticos de &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; debe ser un miembro directo de &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; o la misma clase base de &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; , y debe estar bien formado en el contexto del enlace estructurado cuando se nombra como &lt;code&gt;&lt;i&gt;&lt;b&gt;e&lt;/b&gt;&lt;/i&gt;.&lt;i&gt;name&lt;/i&gt;&lt;/code&gt; . &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; no puede tener un miembro an&amp;oacute;nimo de la uni&amp;oacute;n. El n&amp;uacute;mero de identificadores debe ser igual al n&amp;uacute;mero de miembros de datos no est&amp;aacute;ticos.</target>
        </trans-unit>
        <trans-unit id="b87d3e4870484b5764d76023f3269d280331e5c7" translate="yes" xml:space="preserve">
          <source>Every non-static member of class type has a trivial default constructor</source>
          <target state="translated">Cada miembro no estático del tipo de clase tiene un constructor por defecto trivial</target>
        </trans-unit>
        <trans-unit id="2ce1bf1bc0be1980d77a06eeb4de4b342c337db3" translate="yes" xml:space="preserve">
          <source>Every standard library component that may need to allocate or release storage, from &lt;code&gt;std::string&lt;/code&gt;, &lt;code&gt;std::vector&lt;/code&gt;, and every container except &lt;code&gt;std::array&lt;/code&gt;, to &lt;code&gt;std::shared_ptr&lt;/code&gt; and &lt;code&gt;std::function&lt;/code&gt;, does so through an &lt;strong&gt;Allocator&lt;/strong&gt;: an object of a class type that satisfies the following requirements.</source>
          <target state="translated">Todos los componentes de la biblioteca est&amp;aacute;ndar que pueden necesitar asignar o liberar almacenamiento, desde &lt;code&gt;std::string&lt;/code&gt; , &lt;code&gt;std::vector&lt;/code&gt; y cada contenedor, excepto &lt;code&gt;std::array&lt;/code&gt; , a &lt;code&gt;std::shared_ptr&lt;/code&gt; y &lt;code&gt;std::function&lt;/code&gt; , lo hacen a trav&amp;eacute;s de un &lt;strong&gt;asignador&lt;/strong&gt; : Un objeto de un tipo de clase que cumple los siguientes requisitos.</target>
        </trans-unit>
        <trans-unit id="2cf1b35b018fe1d430f2ed7ed9345dcf2146ab69" translate="yes" xml:space="preserve">
          <source>Every stream I/O function if an exception is thrown by any member function of the associated stream buffer (e.g. sbumpc(), xsputn(), sgetc(), overflow(), etc)</source>
          <target state="translated">Cada función de E/S del flujo si una excepción es lanzada por cualquier función miembro del buffer de flujo asociado (por ejemplo,sbumpc(),xsputn(),sgetc(),overflow(),etc)</target>
        </trans-unit>
        <trans-unit id="b09575dd9bf238348e1eb74acc65642a4f28513f" translate="yes" xml:space="preserve">
          <source>Every successive character &lt;code&gt;c&lt;/code&gt; from the sequence of CharT's from Stage 3 is output as if by &lt;code&gt;*out++ = c&lt;/code&gt;.</source>
          <target state="translated">Cada car&amp;aacute;cter sucesivo &lt;code&gt;c&lt;/code&gt; de la secuencia de CharT de la Etapa 3 se emite como si &lt;code&gt;*out++ = c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa77f47a69b4e10cfca826c1e3a0f4dc9c68af3b" translate="yes" xml:space="preserve">
          <source>Every value of pointer type is one of the following:</source>
          <target state="translated">Cada valor del tipo de puntero es uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="2711daf557af7651a60993264c29beb1d7e39e00" translate="yes" xml:space="preserve">
          <source>Everything about the actual allocation details of bit fields within the class object</source>
          <target state="translated">Todo acerca de los detalles de la asignación real de los campos de bits dentro del objeto de clase</target>
        </trans-unit>
        <trans-unit id="17a1a39f3910e68bd1f80c1b610bdc32df68bf11" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, equivalence is determined by using the equivalence relation as described on &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">En todos los lugares donde la biblioteca est&amp;aacute;ndar utiliza los requisitos de &lt;a href=&quot;../named_req/compare&quot;&gt;Comparaci&amp;oacute;n&lt;/a&gt; , la equivalencia se determina utilizando la relaci&amp;oacute;n de equivalencia como se describe en &lt;a href=&quot;../named_req/compare&quot;&gt;Comparar&lt;/a&gt; . En t&amp;eacute;rminos imprecisos, dos objetos &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; son considerados equivalentes si se compara ni menos que el otro: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b75c2f9b6cdfbe488daafdef876670cbfaba7ec" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent (not unique) if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">En todos los lugares donde la biblioteca est&amp;aacute;ndar usa los requisitos de &lt;a href=&quot;../named_req/compare&quot;&gt;Comparaci&amp;oacute;n&lt;/a&gt; , la unicidad se determina usando la relaci&amp;oacute;n de equivalencia. En t&amp;eacute;rminos imprecisos, dos objetos &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; se consideran equivalentes (no &amp;uacute;nica) si ninguno se compara menos que el otro: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b615d029d5b8025e266ba5a37f8108df4dbd2078" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">En todos los lugares donde la biblioteca est&amp;aacute;ndar usa los requisitos de &lt;a href=&quot;../named_req/compare&quot;&gt;Comparaci&amp;oacute;n&lt;/a&gt; , la unicidad se determina usando la relaci&amp;oacute;n de equivalencia. En t&amp;eacute;rminos imprecisos, dos objetos &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; son considerados equivalentes si se compara ni menos que el otro: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cae74747ce921ce4dc2761826efeaa22990fc6f" translate="yes" xml:space="preserve">
          <source>Exact</source>
          <target state="translated">Exact</target>
        </trans-unit>
        <trans-unit id="b73dce3ae50ecab687b47c8e8958379cbaf57ff0" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;(last - first) - 1&lt;/code&gt; applications of the binary operation.</source>
          <target state="translated">Exactamente &lt;code&gt;(last - first) - 1&lt;/code&gt; aplicaciones de la operaci&amp;oacute;n binaria.</target>
        </trans-unit>
        <trans-unit id="4db39051f1f33d287e9bf44fd101eccfd97335d2" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;(last - first)/2&lt;/code&gt; swaps.</source>
          <target state="translated">Exactamente &lt;code&gt;(last - first)/2&lt;/code&gt; intercambios.</target>
        </trans-unit>
        <trans-unit id="999c7ba21fe6cfdf477efe576e8b30044ac5b242" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">Exactamente aplicaciones &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; del predicado.</target>
        </trans-unit>
        <trans-unit id="1fc8a6d486ec5aab15a1c1be51264f79f56fc49b" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; invocations of &lt;code&gt;g()&lt;/code&gt; and assignments.</source>
          <target state="translated">Exactamente &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; invocaciones de &lt;code&gt;g()&lt;/code&gt; y asignaciones.</target>
        </trans-unit>
        <trans-unit id="35529081f2f26b1b90fd973935838e5852bc467d" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; assignments, for &lt;code&gt;count &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">Exactamente &lt;code&gt;count&lt;/code&gt; las asignaciones, por &lt;code&gt;count &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a8809cf33804ae021cd515fa06675d07f185d82" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; assignments, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">Exactamente &lt;code&gt;count&lt;/code&gt; asignaciones, si &lt;code&gt;count&amp;gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0e851801f10602f0a4225377722df5cf5583ba1" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; invocations of &lt;code&gt;g()&lt;/code&gt; and assignments, for &lt;code&gt;count&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; exactamente las invocaciones de &lt;code&gt;g()&lt;/code&gt; y las asignaciones, para &lt;code&gt;count&amp;gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e8a97940b9961f72ad69126c982a5fb916192e8" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;distance(first, last)&lt;/code&gt; applications of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Aplicaciones de &lt;code&gt;distance(first, last)&lt;/code&gt; exacta (primera, &amp;uacute;ltima) de &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="664be72d77dd1a490f0db6001689b115d6a6b71a" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">Exactamente &lt;code&gt;last - first&lt;/code&gt; aplicaciones del predicado.</target>
        </trans-unit>
        <trans-unit id="7e7f4d09b4ff46a04df0991518050618d9d2f7b5" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; assignments.</source>
          <target state="translated">Exactamente &lt;code&gt;last - first&lt;/code&gt; tareas.</target>
        </trans-unit>
        <trans-unit id="b25aeebe72d8f421614fa0ad0873495e44259427" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; increments and assignments.</source>
          <target state="translated">Exactamente &lt;code&gt;last - first&lt;/code&gt; incrementos y asignaciones.</target>
        </trans-unit>
        <trans-unit id="dd0f4944e44dc9fa8a6fa7891d44439f219ac35c" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; move assignments.</source>
          <target state="translated">Exactamente &lt;code&gt;last - first&lt;/code&gt; asignaciones de primer movimiento.</target>
        </trans-unit>
        <trans-unit id="64786764c6cc4f57b36277db2d8d6df02d730d57" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; applications of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Exactamente &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; aplicaciones de &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd8d57c8139bdfd24f5d36db13c1c858637e062" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;n&lt;/code&gt; applications of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Exactamente &lt;code&gt;n&lt;/code&gt; aplicaciones de &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aabf3a891f0ec18e0d36466fa6f0c9ce5485153e" translate="yes" xml:space="preserve">
          <source>Exactly max(N-1,0) comparisons, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">Exactamente m&amp;aacute;ximo (N-1,0) comparaciones, donde &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99195733fda66fedc7bf44e9446fa1cb19801072" translate="yes" xml:space="preserve">
          <source>Exactly one of &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt;, &lt;code&gt;bool(a &amp;gt; b)&lt;/code&gt; and &lt;code&gt;bool(a == b)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Exactamente uno de &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; , &lt;code&gt;bool(a &amp;gt; b)&lt;/code&gt; y &lt;code&gt;bool(a == b)&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="c0a2d0e4e192dcffd92f7c5fc920779a3a46eca3" translate="yes" xml:space="preserve">
          <source>Examines the filesystem object referred to by this directory entry and stores its attributes for retrieval with &lt;a href=&quot;status&quot;&gt;&lt;code&gt;status()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;is_regular_file&quot;&gt;&lt;code&gt;is_regular_file()&lt;/code&gt;&lt;/a&gt;, and other status accessors.</source>
          <target state="translated">Examina el objeto de sistema de archivos que se refiere esta entrada y almacena directorio de sus atributos para la recuperaci&amp;oacute;n de &lt;a href=&quot;status&quot;&gt; &lt;code&gt;status()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exists&quot;&gt; &lt;code&gt;exists()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;is_regular_file&quot;&gt; &lt;code&gt;is_regular_file()&lt;/code&gt; &lt;/a&gt; , y otros m&amp;eacute;todos de acceso de estado.</target>
        </trans-unit>
        <trans-unit id="d9b9f013ab46e72d63d24bb4f00288b2d9847138" translate="yes" xml:space="preserve">
          <source>Examines the partitioned (as if by &lt;code&gt;&lt;a href=&quot;partition&quot;&gt;std::partition&lt;/a&gt;&lt;/code&gt;) range &lt;code&gt;[first, last)&lt;/code&gt; and locates the end of the first partition, that is, the first element that does not satisfy &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Examina el rango particionado (como por &lt;code&gt;&lt;a href=&quot;partition&quot;&gt;std::partition&lt;/a&gt;&lt;/code&gt; ) &lt;code&gt;[first, last)&lt;/code&gt; y localiza el final de la primera partici&amp;oacute;n, es decir, el primer elemento que no satisface &lt;code&gt;p&lt;/code&gt; o el &lt;code&gt;last&lt;/code&gt; si todos los elementos satisfacen &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcb284168678a0919d196ddf44691afe02c5f4b3" translate="yes" xml:space="preserve">
          <source>Examines the range &lt;code&gt;[first, last)&lt;/code&gt; and finds the largest range beginning at &lt;code&gt;first&lt;/code&gt; in which the elements are sorted in ascending order.</source>
          <target state="translated">Examina el rango &lt;code&gt;[first, last)&lt;/code&gt; y encuentra el rango m&amp;aacute;s grande que comienza al &lt;code&gt;first&lt;/code&gt; en el que los elementos se ordenan en orden ascendente.</target>
        </trans-unit>
        <trans-unit id="0a9b4d7926393a3c0dd8eb8f3c42a7ab58af6b22" translate="yes" xml:space="preserve">
          <source>Examines the range &lt;code&gt;[first, last)&lt;/code&gt; and finds the largest range beginning at &lt;code&gt;first&lt;/code&gt; which is a</source>
          <target state="translated">Examina el rango &lt;code&gt;[first, last)&lt;/code&gt; y encuentra el rango m&amp;aacute;s grande que comienza al &lt;code&gt;first&lt;/code&gt; que es un</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="bd9e11c33e704e33e3cee607c8252cdbbcd8a124" translate="yes" xml:space="preserve">
          <source>Example With Custom Comparator</source>
          <target state="translated">Ejemplo con el comparador personalizado</target>
        </trans-unit>
        <trans-unit id="ab4f744b89a1cf5abcd9dceb291ddd3e9f741894" translate="yes" xml:space="preserve">
          <source>Example from &lt;a href=&quot;http://www.gotw.ca/gotw/030.htm&quot;&gt;http://www.gotw.ca/gotw/030.htm&lt;/a&gt;.</source>
          <target state="translated">Ejemplo de &lt;a href=&quot;http://www.gotw.ca/gotw/030.htm&quot;&gt;http://www.gotw.ca/gotw/030.htm&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e251b366d1e0802c0331ec415628df8aa911103c" translate="yes" xml:space="preserve">
          <source>Example output on one of the implementations.</source>
          <target state="translated">Ejemplo de salida en una de las implementaciones.</target>
        </trans-unit>
        <trans-unit id="ea1fb9b04a44f008daf87c7d9f9e133ac9bce209" translate="yes" xml:space="preserve">
          <source>Example using a custom comparison function</source>
          <target state="translated">Ejemplo utilizando una función de comparación personalizada</target>
        </trans-unit>
        <trans-unit id="db0a68cbf7c526f2a972b13383c59c76ca98c33e" translate="yes" xml:space="preserve">
          <source>Example with vectors :</source>
          <target state="translated">Ejemplo con vectores :</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="8221a0d43625eba2795f842d5c24c7c9f59b0337" translate="yes" xml:space="preserve">
          <source>Examples of &lt;code&gt;Boolean&lt;/code&gt; types include &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;::reference&lt;/code&gt;. Pointers are not &lt;code&gt;Boolean&lt;/code&gt; types.</source>
          <target state="translated">Los ejemplos de tipos &lt;code&gt;Boolean&lt;/code&gt; incluyen &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;::reference&lt;/code&gt; . Los punteros no son tipos &lt;code&gt;Boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1eddcef956b054e171719c037485ba482a76be3" translate="yes" xml:space="preserve">
          <source>Examples of erasure methods are &lt;code&gt;&lt;a href=&quot;container/set/erase&quot;&gt;std::set::erase&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/vector/pop_back&quot;&gt;std::vector::pop_back&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/deque/pop_front&quot;&gt;std::deque::pop_front&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;container/map/clear&quot;&gt;std::map::clear&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ejemplos de m&amp;eacute;todos de borrado son &lt;code&gt;&lt;a href=&quot;container/set/erase&quot;&gt;std::set::erase&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/vector/pop_back&quot;&gt;std::vector::pop_back&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/deque/pop_front&quot;&gt;std::deque::pop_front&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;container/map/clear&quot;&gt;std::map::clear&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe47fa951fcb6357223febc9d44197fbb268fda" translate="yes" xml:space="preserve">
          <source>Examples of implementation-defined launch policies are the sync policy (execute immediately, within the async call) and the task policy (similar to async, but thread-locals are not cleared).</source>
          <target state="translated">Ejemplos de políticas de lanzamiento definidas para la implementación son la política de sincronización (ejecutar inmediatamente,dentro de la llamada async)y la política de tareas (similar a la de async,pero con hilos locales no despejados).</target>
        </trans-unit>
        <trans-unit id="e910df0f6bb9dfed95f71ce88f75479176c518cf" translate="yes" xml:space="preserve">
          <source>Examples of insertion methods are &lt;code&gt;&lt;a href=&quot;container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/map/emplace&quot;&gt;std::map::emplace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;container/deque/push_front&quot;&gt;std::deque::push_front&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ejemplos de m&amp;eacute;todos de inserci&amp;oacute;n son &lt;code&gt;&lt;a href=&quot;container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/map/emplace&quot;&gt;std::map::emplace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;container/deque/push_front&quot;&gt;std::deque::push_front&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69702eefdd99747ec1287d6c73c6d3f8f05c1292" translate="yes" xml:space="preserve">
          <source>Examples of partial specializations in the standard library include &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, which has a partial specialization for array types.</source>
          <target state="translated">Los ejemplos de especializaciones parciales en la biblioteca est&amp;aacute;ndar incluyen &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; , que tiene una especializaci&amp;oacute;n parcial para los tipos de matriz.</target>
        </trans-unit>
        <trans-unit id="a00ca19e4db47060f538e8b506c6503ac18be3b7" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;value_type&lt;/code&gt;, all the member types of &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; are complete types.</source>
          <target state="translated">Excepto &lt;code&gt;value_type&lt;/code&gt; , todos los tipos de miembros de &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; son tipos completos.</target>
        </trans-unit>
        <trans-unit id="8acd64a7d513ffba5fa93f11be47de7c9fc5c1db" translate="yes" xml:space="preserve">
          <source>Except for default argument, aligned_storage is expressible in terms of alignas:</source>
          <target state="translated">Salvo el argumento por defecto,aligned_storage es expresable en términos de alignas:</target>
        </trans-unit>
        <trans-unit id="f51732ca4ed72fa4525ab38c97db1146e4d04378" translate="yes" xml:space="preserve">
          <source>Except in the constructors of &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;, negative values of &lt;code&gt;std::streamsize&lt;/code&gt; are never used.</source>
          <target state="translated">Excepto en los constructores de &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; , los valores negativos de &lt;code&gt;std::streamsize&lt;/code&gt; nunca se usan.</target>
        </trans-unit>
        <trans-unit id="d587eb69ad8f0449298a08da77269d9ca0f24406" translate="yes" xml:space="preserve">
          <source>Except that if no exception specification is explicitly provided, the exception specification is considered to be one that would be used by the implicitly-declared destructor (see below). In most cases, this is &lt;code&gt;noexcept(true)&lt;/code&gt;. Thus a throwing destructor must be explicitly declared &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">Excepto que si no se proporciona expl&amp;iacute;citamente una especificaci&amp;oacute;n de excepci&amp;oacute;n, la especificaci&amp;oacute;n de excepci&amp;oacute;n se considera que ser&amp;iacute;a utilizada por el destructor declarado impl&amp;iacute;citamente (ver m&amp;aacute;s abajo). En la mayor&amp;iacute;a de los casos, esto no es &lt;code&gt;noexcept(true)&lt;/code&gt; . Por lo tanto, un destructor de lanzamiento debe declararse expl&amp;iacute;citamente &lt;code&gt;noexcept(false)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d95da02e76b8dae287531e540c02e16d08b2978" translate="yes" xml:space="preserve">
          <source>Except that names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope, which is also the scope of both statements.</source>
          <target state="translated">Salvo que los nombres declarados por el init-statement (si el init-statement es una declaración)y los nombres declarados por condición (si la condición es una declaración)tienen el mismo alcance,que es también el alcance de ambas declaraciones.</target>
        </trans-unit>
        <trans-unit id="29967c007b524bf4d82e67020addcf8209e607a6" translate="yes" xml:space="preserve">
          <source>Except that names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope, which is also the scope of statement.</source>
          <target state="translated">Salvo que los nombres declarados por el init-statement (si el init-statement es una declaración)y los nombres declarados por condición (si la condición es una declaración)están en el mismo ámbito,que es también el ámbito de la declaración.</target>
        </trans-unit>
        <trans-unit id="e357f711ee87c54bd0e9332d642407c850fea7c4" translate="yes" xml:space="preserve">
          <source>Except that the calls to &lt;code&gt;decay_copy&lt;/code&gt; are evaluated in the context of the caller, so that any exceptions thrown during evaluation and copying/moving of the arguments are thrown in the current thread, without starting the new thread.</source>
          <target state="translated">Excepto que las llamadas a &lt;code&gt;decay_copy&lt;/code&gt; se eval&amp;uacute;an en el contexto del llamador, de modo que cualquier excepci&amp;oacute;n lanzada durante la evaluaci&amp;oacute;n y copia / movimiento de los argumentos se lanza en el hilo actual, sin iniciar el nuevo hilo.</target>
        </trans-unit>
        <trans-unit id="1eeb0a1df8df205ed68a524cbaa8c0fab4fe1d23" translate="yes" xml:space="preserve">
          <source>Except that.</source>
          <target state="translated">Excepto eso.</target>
        </trans-unit>
        <trans-unit id="f96eec6bcb0eb29fc403d27737c989d54305c3d2" translate="yes" xml:space="preserve">
          <source>Exception categories</source>
          <target state="translated">Categorías de excepción</target>
        </trans-unit>
        <trans-unit id="b4b0dfe7027c1d349ba13a7e79558e44ec341bd8" translate="yes" xml:space="preserve">
          <source>Exception handling</source>
          <target state="translated">Manejo de excepciones</target>
        </trans-unit>
        <trans-unit id="2c1ebcb87ed425e2ea948b9057321bf79663c920" translate="yes" xml:space="preserve">
          <source>Exception handling provides a way of transferring control and information from some point in the execution of a program to a handler associated with a point previously passed by the execution (in other words, exception handling transfers control up the call stack).</source>
          <target state="translated">El manejo de excepciones proporciona una forma de transferir el control y la información desde algún punto de la ejecución de un programa a un manejador asociado con un punto previamente pasado por la ejecución (en otras palabras,el manejo de excepciones transfiere el control a la pila de llamadas).</target>
        </trans-unit>
        <trans-unit id="484018b13af3fa5985246c3cf1cb9a80f78a4b2e" translate="yes" xml:space="preserve">
          <source>Exception handling utilities</source>
          <target state="translated">Utilidades de manejo de excepciones</target>
        </trans-unit>
        <trans-unit id="f20b401bcfd0d6316854bd1c5be2e83c76d1de4f" translate="yes" xml:space="preserve">
          <source>Exception objects</source>
          <target state="translated">Objetos de excepción</target>
        </trans-unit>
        <trans-unit id="c178e2e0328be43fb7ba635e2d8a88fc566b2eb0" translate="yes" xml:space="preserve">
          <source>Exception of type &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; may be thrown on errors, with the following error codes:</source>
          <target state="translated">La excepci&amp;oacute;n del tipo &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; puede aparecer en los errores, con los siguientes c&amp;oacute;digos de error:</target>
        </trans-unit>
        <trans-unit id="80d5280e70d86ad891f2b40c8ed78d7da520c6d7" translate="yes" xml:space="preserve">
          <source>Exception safety</source>
          <target state="translated">Seguridad de excepción</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="860a1ec6dde884258f991928e357d615dac44a1f" translate="yes" xml:space="preserve">
          <source>Exceptions (e.g. &lt;code&gt;&lt;a href=&quot;error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;), assertions (e.g. &lt;code&gt;&lt;a href=&quot;error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Las excepciones (por ejemplo, &lt;code&gt;&lt;a href=&quot;error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; ), las afirmaciones (por ejemplo &lt;code&gt;&lt;a href=&quot;error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c85cdf1b242c92824cb3422445a6b69100c6e06" translate="yes" xml:space="preserve">
          <source>Exceptions of type &lt;code&gt;std::runtime_error&lt;/code&gt; are thrown by the following standard library components: &lt;code&gt;&lt;a href=&quot;../../locale/locale/locale&quot;&gt;std::locale::locale&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/locale/combine&quot;&gt;std::locale::combine&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los siguientes componentes de biblioteca est&amp;aacute;ndar &lt;code&gt;std::runtime_error&lt;/code&gt; excepciones de tipo std :: runtime_error : &lt;code&gt;&lt;a href=&quot;../../locale/locale/locale&quot;&gt;std::locale::locale&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../locale/locale/combine&quot;&gt;std::locale::combine&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3655d713d676393ce50c4dfe2c15b248f391aaef" translate="yes" xml:space="preserve">
          <source>Exceptions that are thrown from member initializers may be handled by &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;.</source>
          <target state="translated">Las excepciones que se generan desde los inicializadores de miembros pueden ser manejadas por &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3ccb3655838c7cc0f05342ca4d518865db28c05" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Intercambia el contenido de &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf0531db840de334e816e5c677f3bd63fcd3dd1a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">Intercambia los contenidos de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10d46d6be13fed97bcfc06d63285187114a038e8" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container adaptor with those of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c); swap(comp, other.comp);&lt;/code&gt;</source>
          <target state="translated">Intercambia el contenido del adaptador de contenedor con el de &lt;code&gt;other&lt;/code&gt; . Efectivamente llamadas &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c); swap(comp, other.comp);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e6e9555c788d205a45c120fea2405b48de6ce8a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container adaptor with those of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c);&lt;/code&gt;</source>
          <target state="translated">Intercambia el contenido del adaptador de contenedor con el de &lt;code&gt;other&lt;/code&gt; . Efectivamente llamadas &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="49de04ba32b7f84cb9cd03e37185b56ecd9e1b91" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container with those of &lt;code&gt;other&lt;/code&gt;. Does not cause iterators and references to associate with the other container.</source>
          <target state="translated">Intercambia los contenidos del contenedor con los de &lt;code&gt;other&lt;/code&gt; . No hace que los iteradores y las referencias se asocien con el otro contenedor.</target>
        </trans-unit>
        <trans-unit id="cca5e7e3ee4209e3931f1f34eaaecf8cf0a0bc6a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container with those of &lt;code&gt;other&lt;/code&gt;. Does not invoke any move, copy, or swap operations on individual elements.</source>
          <target state="translated">Intercambia los contenidos del contenedor con los de &lt;code&gt;other&lt;/code&gt; . No invoca ninguna operaci&amp;oacute;n de movimiento, copia o intercambio en elementos individuales.</target>
        </trans-unit>
        <trans-unit id="62bfbc4c539262880741976e01c4f02e7c1e4a00" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the stream buffer with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Intercambia el contenido del b&amp;uacute;fer de flujo con los de &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a6e431a73a626620ce066c3e9d4f31fda3acf08" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the string with those of &lt;code&gt;other&lt;/code&gt;. All iterators and references may be invalidated.</source>
          <target state="translated">Intercambia el contenido de la cadena con los de &lt;code&gt;other&lt;/code&gt; . Todos los iteradores y referencias pueden ser invalidados.</target>
        </trans-unit>
        <trans-unit id="a091ec29303367010ecc75278a112bbcdf30230b" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the sync stream buffer with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Intercambia el contenido del b&amp;uacute;fer de secuencia de sincronizaci&amp;oacute;n con los de &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6582eb59d4c7d4d4f55d78fce8cfcf8c22bc4bb7" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of two regular expressions.</source>
          <target state="translated">Intercambia el contenido de dos expresiones regulares.</target>
        </trans-unit>
        <trans-unit id="67e3c44b994c5e59c6fd36a93ede7ec7c8983289" translate="yes" xml:space="preserve">
          <source>Exchanges the given values.</source>
          <target state="translated">Intercambia los valores dados.</target>
        </trans-unit>
        <trans-unit id="a2b38d8b13b6bc9e51339c32d2d13644d36846b9" translate="yes" xml:space="preserve">
          <source>Exchanges the internal states of the lock objects.</source>
          <target state="translated">Intercambia los estados internos de los objetos de la cerradura.</target>
        </trans-unit>
        <trans-unit id="7c072815ce7ddc6a4942335ae6ce9574b39ca082" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states and stored tasks of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Intercambia los estados compartidos y las tareas almacenadas de &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b12f471554dcab6c425a7585115003928398434" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states of two &lt;code&gt;match_results&lt;/code&gt; objects.</source>
          <target state="translated">Intercambia los estados compartidos de dos objetos &lt;code&gt;match_results&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59d42fecea425bb592e078023cd032e5a993fe31" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states of two promise objects.</source>
          <target state="translated">Intercambia los estados compartidos de dos objetos de promesa.</target>
        </trans-unit>
        <trans-unit id="18b676510da12b57d475482111403500d0eaec7b" translate="yes" xml:space="preserve">
          <source>Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">Intercambia el estado de &lt;code&gt;lhs&lt;/code&gt; con el de &lt;code&gt;rhs&lt;/code&gt; . Efectivamente llama a &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1b9970f1ef14caaf33f01eabd758b36bb1eff60" translate="yes" xml:space="preserve">
          <source>Exchanges the state of the stream with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Intercambia el estado de la secuencia con los de &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31ddf92acf4cafa84669771e5848a6787348f3e4" translate="yes" xml:space="preserve">
          <source>Exchanges the state with another input/output stream object. Effectively calls &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;::swap(other)&lt;/code&gt;.</source>
          <target state="translated">Intercambia el estado con otro objeto de flujo de entrada / salida. Efectivamente llama a &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;::swap(other)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4b57df173bf97bd6ea27f8a30b30cea7df455a9" translate="yes" xml:space="preserve">
          <source>Exchanges the states of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, except for the associated &lt;code&gt;rdbuf&lt;/code&gt; objects. &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;other.rdbuf()&lt;/code&gt; returns the same values as before the call.</source>
          <target state="translated">Intercambia los estados de &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; , excepto los objetos &lt;code&gt;rdbuf&lt;/code&gt; asociados . &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;other.rdbuf()&lt;/code&gt; devuelve los mismos valores que antes de la llamada.</target>
        </trans-unit>
        <trans-unit id="7057d033a604041b5eda100f7d1ff124d6f8a8db" translate="yes" xml:space="preserve">
          <source>Exchanges the stored callable objects of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Intercambia los objetos invocables almacenados de &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4dce99c5d1d30eb407da92e2d161ddb796ea801" translate="yes" xml:space="preserve">
          <source>Exchanges the underlying handles of two thread objects.</source>
          <target state="translated">Intercambia los mangos subyacentes de dos objetos de hilo.</target>
        </trans-unit>
        <trans-unit id="4bec71ee58c3ce1a623ca2ef092eecb76d6de116" translate="yes" xml:space="preserve">
          <source>Exchanges the values referenced by &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;.</source>
          <target state="translated">Intercambia los valores referenciados por &lt;code&gt;t&lt;/code&gt; y &lt;code&gt;u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a51b1fd2363fd0ca07531efcb4dd24feaa75b80" translate="yes" xml:space="preserve">
          <source>Exchanges the view with that of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Intercambia la vista con la de &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be6d66875d5906f7cae3a9398d5dbf1c7968e188" translate="yes" xml:space="preserve">
          <source>Exclusive locking</source>
          <target state="translated">Cierre exclusivo</target>
        </trans-unit>
        <trans-unit id="7f9696585c07b96ae418afaf36f528ec350cef50" translate="yes" xml:space="preserve">
          <source>Executable file format error</source>
          <target state="translated">Error de formato de archivo ejecutable</target>
        </trans-unit>
        <trans-unit id="9c973cb9f93e36abf91a1e9c23f91399e854d72a" translate="yes" xml:space="preserve">
          <source>Executes a for loop over a range.</source>
          <target state="translated">Ejecuta un bucle de for sobre un rango.</target>
        </trans-unit>
        <trans-unit id="613b116d4f4f58b27e039a622ea9cf3d90eab7e4" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of condition becomes &lt;code&gt;false&lt;/code&gt;. The test takes place before each iteration.</source>
          <target state="translated">Ejecuta una declaraci&amp;oacute;n repetidamente, hasta que el valor de la condici&amp;oacute;n se vuelve &lt;code&gt;false&lt;/code&gt; . La prueba se realiza antes de cada iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fb5a19ea5e56f8a6995eea08fd4658f19b1ba739" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of expression becomes false. The test takes place after each iteration.</source>
          <target state="translated">Ejecuta una declaración repetidamente,hasta que el valor de la expresión se vuelve falso.La prueba tiene lugar después de cada iteración.</target>
        </trans-unit>
        <trans-unit id="0c64270896df6b47ed0ab90cdaa2526a36293282" translate="yes" xml:space="preserve">
          <source>Executes init-statement once, then executes statement and iteration_expression repeatedly, until the value of condition becomes false. The test takes place before each iteration.</source>
          <target state="translated">Ejecuta init-statement una vez,luego ejecuta statement e iteration_expression repetidamente,hasta que el valor de la condición se vuelve falso.La prueba tiene lugar antes de cada iteración.</target>
        </trans-unit>
        <trans-unit id="64b4397dfd824f8172c44d1c4f9e248b16268c1c" translate="yes" xml:space="preserve">
          <source>Executes the &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; exactly once, even if called concurrently, from several threads.</source>
          <target state="translated">Ejecuta el objeto &lt;a href=&quot;../named_req/callable&quot;&gt;invocable &lt;/a&gt; &lt;code&gt;f&lt;/code&gt; exactamente una vez, incluso si se llama simult&amp;aacute;neamente, desde varios subprocesos.</target>
        </trans-unit>
        <trans-unit id="5241bfbf176faa293d6e52adf2a2d31791dc7d39" translate="yes" xml:space="preserve">
          <source>Executes the &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; as if under a global lock: all outermost synchronized blocks in the program execute in a single total order. The end of each synchronized block synchronizes with the beginning of the next synchronized block in that order. Synchronized blocks that are nested within other synchronized blocks have no special semantics.</source>
          <target state="translated">Ejecuta la &lt;a href=&quot;statements#Compound_statements&quot;&gt;declaraci&amp;oacute;n compuesta&lt;/a&gt; como si estuviera bajo un bloqueo global: todos los bloques sincronizados m&amp;aacute;s externos en el programa se ejecutan en un solo orden total. El final de cada bloque sincronizado se sincroniza con el comienzo del siguiente bloque sincronizado en ese orden. Los bloques sincronizados que est&amp;aacute;n anidados dentro de otros bloques sincronizados no tienen una sem&amp;aacute;ntica especial.</target>
        </trans-unit>
        <trans-unit id="fb88910ec6e8f148a726def306751bb61d10e009" translate="yes" xml:space="preserve">
          <source>Executes the body of the lambda-expression, when invoked. When accessing a variable, accesses its captured copy (for the entities captured by copy), or the original object (for the entities captured by reference). Unless the keyword &lt;code&gt;mutable&lt;/code&gt; was used in the lambda-expression, the function-call operator is const-qualified and the objects that were captured by copy are non-modifiable from inside this &lt;code&gt;operator()&lt;/code&gt;. The function-call operator is never volatile-qualified and never virtual.</source>
          <target state="translated">Ejecuta el cuerpo de la expresi&amp;oacute;n lambda, cuando se invoca. Al acceder a una variable, accede a su copia capturada (para las entidades capturadas por copia), o al objeto original (para las entidades capturadas por referencia). A menos que la palabra clave &lt;code&gt;mutable&lt;/code&gt; se haya utilizado en la expresi&amp;oacute;n lambda, el operador de llamada de funci&amp;oacute;n est&amp;aacute; calificado y los objetos que fueron capturados por la copia no se pueden modificar desde este &lt;code&gt;operator()&lt;/code&gt; . El operador de llamada de funci&amp;oacute;n nunca es vol&amp;aacute;til y nunca es virtual.</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="de7349273ae9d07fc03da50e188f4f34b7d2aa3e" translate="yes" xml:space="preserve">
          <source>Execution policies</source>
          <target state="translated">Políticas de ejecución</target>
        </trans-unit>
        <trans-unit id="881673b7fc0425b71c75a900e8dd961e60da16d7" translate="yes" xml:space="preserve">
          <source>Exhausting memory in the pool causes the next allocation request for that pool to allocate an additional chunk of memory from the</source>
          <target state="translated">El agotamiento de la memoria del fondo común hace que la siguiente solicitud de asignación de ese fondo común asigne un trozo adicional de memoria de la</target>
        </trans-unit>
        <trans-unit id="4d3a207c682e51fd0f76ac46376bd504dd04bb4b" translate="yes" xml:space="preserve">
          <source>Existing elements of &lt;code&gt;a&lt;/code&gt; are destroyed or assigned to</source>
          <target state="translated">Los elementos existentes de &lt;code&gt;a&lt;/code&gt; son destruidos o asignados a</target>
        </trans-unit>
        <trans-unit id="28c764ed1d6222630406c5783a2aaab97f66bd88" translate="yes" xml:space="preserve">
          <source>Expanded value</source>
          <target state="translated">Valor expandido</target>
        </trans-unit>
        <trans-unit id="3a28add9450f041df1694bda9dbd7fe1ffe87170" translate="yes" xml:space="preserve">
          <source>Expands to an expression (not necessarily a compile-time constant) of type &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; equal to the number of clock ticks per second, as returned by &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se expande a una expresi&amp;oacute;n (no necesariamente una constante de tiempo de compilaci&amp;oacute;n) de tipo &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; igual al n&amp;uacute;mero de tics de reloj por segundo, como lo devuelve &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a94ceb9709072dbc8a9721a63225f49eded59877" translate="yes" xml:space="preserve">
          <source>Expands to an expression which can be used to initialize an &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; object that can be initialized from &lt;code&gt;value&lt;/code&gt;. If the atomic object has static storage duration, this initialization is &lt;a href=&quot;../language/constant_initialization&quot;&gt;constant initialization&lt;/a&gt;.</source>
          <target state="translated">Se expande a una expresi&amp;oacute;n que se puede usar para inicializar un objeto &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; que se puede inicializar desde el &lt;code&gt;value&lt;/code&gt; . Si el objeto at&amp;oacute;mico tiene una duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico, esta inicializaci&amp;oacute;n es &lt;a href=&quot;../language/constant_initialization&quot;&gt;una inicializaci&amp;oacute;n constante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de6a2f8e65def43ce5a852e140e79c980dade60d" translate="yes" xml:space="preserve">
          <source>Expands to an integer constant expression equal to the maximum value returned by the function &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt;. This value is implementation dependent. It's guaranteed that this value is at least &lt;code&gt;32767&lt;/code&gt;.</source>
          <target state="translated">Se expande a una expresi&amp;oacute;n constante entera igual al valor m&amp;aacute;ximo devuelto por la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; . Este valor depende de la implementaci&amp;oacute;n. Se garantiza que este valor es al menos &lt;code&gt;32767&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b74a3f6f88cbf8779ab38cebe0c4e5a1aa35bcc5" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">Se expande a una expresi&amp;oacute;n &lt;code&gt;double&lt;/code&gt; positiva que indica desbordamiento, no necesariamente representable como &lt;code&gt;float&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5ccabdc1716ee0f1f6ba421bfe7a3cb18e19e27" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;float&lt;/code&gt; expression that indicates overflow</source>
          <target state="translated">Se expande a una expresi&amp;oacute;n &lt;code&gt;float&lt;/code&gt; positiva que indica desbordamiento</target>
        </trans-unit>
        <trans-unit id="1517f254032c8417e8afa57de1c3cc258d11f6c4" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;long double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">Se expande a una expresi&amp;oacute;n &lt;code&gt;long double&lt;/code&gt; positiva que indica desbordamiento, no necesariamente representable como &lt;code&gt;float&lt;/code&gt; o &lt;code&gt;double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc198697dbf6af57511ca5dfb75efa170fb6388d" translate="yes" xml:space="preserve">
          <source>Expansion loci</source>
          <target state="translated">Loci de expansión</target>
        </trans-unit>
        <trans-unit id="d9e0a488e53cfe7c390afb8b463eb5bb25a7cfba" translate="yes" xml:space="preserve">
          <source>Experimental libraries</source>
          <target state="translated">Experimental libraries</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="52641b8a40589b37d9770ba9ee57a29be108ded9" translate="yes" xml:space="preserve">
          <source>Explicit (full) specialization of a member of a partial specialization is declared the same way as an explicit specialization of the primary template.</source>
          <target state="translated">La especialización explícita (completa)de un miembro de una especialización parcial se declara de la misma manera que una especialización explícita de la plantilla primaria.</target>
        </trans-unit>
        <trans-unit id="dd412ab552031cf5dc3a067286b0057cfec3dfe8" translate="yes" xml:space="preserve">
          <source>Explicit conversion from (possibly const) &lt;code&gt;fpos&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;. The result is the stored offset.</source>
          <target state="translated">Conversi&amp;oacute;n expl&amp;iacute;cita de (posiblemente const) &lt;code&gt;fpos&lt;/code&gt; a &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; . El resultado es el desplazamiento almacenado.</target>
        </trans-unit>
        <trans-unit id="1c63bca80feb759ba98d57e981b658fef25d5cce" translate="yes" xml:space="preserve">
          <source>Explicit instantiation</source>
          <target state="translated">Instanciación explícita</target>
        </trans-unit>
        <trans-unit id="4b142316d64b45cb4860439c17ed8cd8981f0aa9" translate="yes" xml:space="preserve">
          <source>Explicit instantiation can only appear in the enclosing namespace of the template, unless it uses qualified-id:</source>
          <target state="translated">La instanciación explícita sólo puede aparecer en el espacio de nombres adjunto a la plantilla,a menos que utilice una identificación cualificada:</target>
        </trans-unit>
        <trans-unit id="ee1fc799be568941add0e5c7edd28b1bd51ae960" translate="yes" xml:space="preserve">
          <source>Explicit instantiation declarations do not suppress the implicit instantiation of &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; functions, &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;-declarations, references, and class template specializations. (thus, when the inline function that is a subject of explicit instantiation declaration is ODR-used, it is implicitly instantiated for inlining, but its out-of-line copy is not generated in this TU).</source>
          <target state="translated">Declaraciones de instancias expl&amp;iacute;cita no suprimen la creaci&amp;oacute;n de instancias impl&amp;iacute;cita de la &lt;a href=&quot;inline&quot;&gt;l&amp;iacute;nea&lt;/a&gt; funciones, &lt;a href=&quot;auto&quot;&gt;autom&amp;oacute;viles&lt;/a&gt; -declarations, referencias y especializaciones de la plantilla de clase. (por lo tanto, cuando la funci&amp;oacute;n en l&amp;iacute;nea que es objeto de una declaraci&amp;oacute;n de instanciaci&amp;oacute;n expl&amp;iacute;cita se usa ODR, se crea una instancia impl&amp;iacute;cita para la alineaci&amp;oacute;n, pero su copia fuera de l&amp;iacute;nea no se genera en esta TU).</target>
        </trans-unit>
        <trans-unit id="572c84d2570e91de98df5fd413b0bd1a4670b56d" translate="yes" xml:space="preserve">
          <source>Explicit instantiation definition of a function template with &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; is not a use of the arguments, and does not attempt to initialize them:</source>
          <target state="translated">La definici&amp;oacute;n expl&amp;iacute;cita de instanciaci&amp;oacute;n de una plantilla de funci&amp;oacute;n con &lt;a href=&quot;default_arguments&quot;&gt;argumentos predeterminados&lt;/a&gt; no es un uso de los argumentos, y no intenta inicializarlos:</target>
        </trans-unit>
        <trans-unit id="0dcc010f6137a4796c623c315a5959bc45a20109" translate="yes" xml:space="preserve">
          <source>Explicit instantiation definitions ignore member access specifiers: parameter types and return types may be private.</source>
          <target state="translated">Las definiciones explícitas de instanciación ignoran los especificadores de acceso de los miembros:los tipos de parámetros y los tipos de retorno pueden ser privados.</target>
        </trans-unit>
        <trans-unit id="65478c257174b4e3c09ba657cd00b83b6bf1640b" translate="yes" xml:space="preserve">
          <source>Explicit instantiation has no effect if an &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; appeared before for the same set of template arguments.</source>
          <target state="translated">La creaci&amp;oacute;n de instancias expl&amp;iacute;cita no tiene efecto si antes aparec&amp;iacute;a una &lt;a href=&quot;template_specialization&quot;&gt;especializaci&amp;oacute;n expl&amp;iacute;cita&lt;/a&gt; para el mismo conjunto de argumentos de plantilla.</target>
        </trans-unit>
        <trans-unit id="d36a0cc2732df089c694dc98284a6d85796f30ad" translate="yes" xml:space="preserve">
          <source>Explicit instantiation of a function template or of a member function of a class template cannot use &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;constexpr&lt;/code&gt;. If the declaration of the explicit instantiation names an implicitly-declared special member function, the program is ill-formed.</source>
          <target state="translated">La creaci&amp;oacute;n de instancias expl&amp;iacute;cita de una plantilla de funci&amp;oacute;n o de una funci&amp;oacute;n miembro de una plantilla de clase no puede usar &lt;code&gt;inline&lt;/code&gt; o &lt;code&gt;constexpr&lt;/code&gt; . Si la declaraci&amp;oacute;n de la instancia expl&amp;iacute;cita nombra una funci&amp;oacute;n miembro especial declarada impl&amp;iacute;citamente, el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="30c811d49cc758004cfc53fc79ee65d4652de860" translate="yes" xml:space="preserve">
          <source>Explicit instantiations, explicit specializations, or partial specializations of concepts are not allowed (the meaning of the original definition of a constraint cannot be changed).</source>
          <target state="translated">No se permiten las instancias explícitas,las especializaciones explícitas o las especializaciones parciales de conceptos (no se puede cambiar el significado de la definición original de una restricción).</target>
        </trans-unit>
        <trans-unit id="2e55319f81d1a852746aa5972684208a80ae6770" translate="yes" xml:space="preserve">
          <source>Explicit specialization</source>
          <target state="translated">Especialización explícita</target>
        </trans-unit>
        <trans-unit id="593deb78caf931f5a8926f7968637e3804e9bc2d" translate="yes" xml:space="preserve">
          <source>Explicit specialization may be declared in any scope where its primary template may be defined (which may be different from the scope where the primary template is defined; such as with out-of-class specialization of a &lt;a href=&quot;member_template&quot;&gt;member template&lt;/a&gt;) . Explicit specialization has to appear after the non-specialized template declaration.</source>
          <target state="translated">La especializaci&amp;oacute;n expl&amp;iacute;cita se puede declarar en cualquier &amp;aacute;mbito en el que se pueda definir su plantilla principal (que puede ser diferente del &amp;aacute;mbito en el que se define la plantilla primaria; como con la especializaci&amp;oacute;n fuera de clase de una &lt;a href=&quot;member_template&quot;&gt;plantilla miembro&lt;/a&gt; ). La especializaci&amp;oacute;n expl&amp;iacute;cita debe aparecer despu&amp;eacute;s de la declaraci&amp;oacute;n de plantilla no especializada.</target>
        </trans-unit>
        <trans-unit id="8870f1f0b78d6b643054caef6f197e66cbb50dc0" translate="yes" xml:space="preserve">
          <source>Explicit specializations of function templates</source>
          <target state="translated">Especializaciones explícitas de las plantillas de funciones</target>
        </trans-unit>
        <trans-unit id="d9b457bfa7e9dfdb8f202a1cfd0b13910b32a1d1" translate="yes" xml:space="preserve">
          <source>Explicit template argument lists may not be specified when calling any of them.</source>
          <target state="translated">No se pueden especificar listas de argumentos de plantilla explícitas al llamar a cualquiera de ellas.</target>
        </trans-unit>
        <trans-unit id="901409defb65997b43ccf96e53d877ad8c4540d5" translate="yes" xml:space="preserve">
          <source>Explicit template arguments</source>
          <target state="translated">Argumentos explícitos de la plantilla</target>
        </trans-unit>
        <trans-unit id="4431a5f6720c93927b4ab9fdd98f9a2ec4e9c49f" translate="yes" xml:space="preserve">
          <source>Explicit template instantiation</source>
          <target state="translated">Instanciación explícita de la plantilla</target>
        </trans-unit>
        <trans-unit id="0fab44e233e42157cd5dea76fd8cf3c8b9d7adc5" translate="yes" xml:space="preserve">
          <source>Explicit template specialization</source>
          <target state="translated">Especialización en plantillas explícitas</target>
        </trans-unit>
        <trans-unit id="efc7df6ee447c5edc7f6c07135ad3f5023dea6a8" translate="yes" xml:space="preserve">
          <source>Explicit type conversion</source>
          <target state="translated">Conversión de tipos explícitos</target>
        </trans-unit>
        <trans-unit id="dd8bfe3fdab8ac97b580b2a4aef0404f178b5ac1" translate="yes" xml:space="preserve">
          <source>Exponential functions</source>
          <target state="translated">Funciones exponenciales</target>
        </trans-unit>
        <trans-unit id="af9874c4957d8cd8c01ba533edd025cf4c27e381" translate="yes" xml:space="preserve">
          <source>Exposes class &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; as a method of accessing individual bits. In particular, objects of this class are returned by &lt;a href=&quot;vector/operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt; by value.</source>
          <target state="translated">Expone la &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; clase &lt;a href=&quot;vector&quot;&gt;std :: vector&lt;/a&gt; &amp;lt;bool&amp;gt; :: como m&amp;eacute;todo de acceso a bits individuales. En particular, los objetos de esta clase son devueltos por el &lt;a href=&quot;vector/operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt; por valor.</target>
        </trans-unit>
        <trans-unit id="386b8e5c19a5d25975c5d960c8d6889b5c0e7456" translate="yes" xml:space="preserve">
          <source>Exposes the type named &lt;code&gt;type&lt;/code&gt;, which is the common type of two &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Expone el tipo llamado &lt;code&gt;type&lt;/code&gt; , que es el tipo com&amp;uacute;n de dos &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="81c630945113fb74890dbe59b04840a67c663c1b" translate="yes" xml:space="preserve">
          <source>Exposes the type named &lt;code&gt;type&lt;/code&gt;, which is the common type of two &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Expone el tipo llamado &lt;code&gt;type&lt;/code&gt; , que es el tipo com&amp;uacute;n de dos &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="dde7602ac0e3b525fda01f2a33c67f49539ca405" translate="yes" xml:space="preserve">
          <source>Exposition-only data member holding the sentinel (typically either a number, for a bounded iota view, or an instance of &lt;code&gt;std::unreachable_sentinel_t&lt;/code&gt; for an unbounded iota view.</source>
          <target state="translated">Miembro de datos de solo exposici&amp;oacute;n que contiene el centinela (normalmente un n&amp;uacute;mero, para una vista iota limitada, o una instancia de &lt;code&gt;std::unreachable_sentinel_t&lt;/code&gt; para una vista iota no limitada .</target>
        </trans-unit>
        <trans-unit id="cf2a2572c2908ed7f54343df2e7969e31bec570b" translate="yes" xml:space="preserve">
          <source>Exposition-only data member holding the sentinel of the underlying &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Miembro de datos de solo exposici&amp;oacute;n que tiene el centinela de la &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; subyacente .</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="41e32832dbe3b76f5e8fc2a5f15b3848cf05e235" translate="yes" xml:space="preserve">
          <source>Expression SFINAE</source>
          <target state="translated">Expresión SFINAE</target>
        </trans-unit>
        <trans-unit id="833207cd0a28197ca9f0d233e80f2413b069f412" translate="yes" xml:space="preserve">
          <source>Expression evaluation may produce a result (e.g., evaluation of &lt;code&gt;2+2&lt;/code&gt; produces the result &lt;code&gt;4&lt;/code&gt;) and may generate side-effects (e.g. evaluation of &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; prints the character &lt;code&gt;'4'&lt;/code&gt; on the standard output).</source>
          <target state="translated">La evaluaci&amp;oacute;n de expresi&amp;oacute;n puede producir un resultado (por ejemplo, la evaluaci&amp;oacute;n de &lt;code&gt;2+2&lt;/code&gt; produce el resultado &lt;code&gt;4&lt;/code&gt; ) y puede generar efectos secundarios (por ejemplo, la evaluaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; imprime el car&amp;aacute;cter &lt;code&gt;'4'&lt;/code&gt; en el est&amp;aacute;ndar salida).</target>
        </trans-unit>
        <trans-unit id="0a7a6ba0d7d2af3106edf9d912c2fc5a47512f54" translate="yes" xml:space="preserve">
          <source>Expression statements</source>
          <target state="translated">Declaraciones de expresión</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="bd7f69f355486bcb0814ab9e5cf3b7318931dffa" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;static_assert&lt;/code&gt;</source>
          <target state="translated">Extended &lt;code&gt;static_assert&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85f5fa538ad73dc2c1cf60d6bcfc4288cb6d221b" translate="yes" xml:space="preserve">
          <source>Extending memory management tools</source>
          <target state="translated">Ampliación de las herramientas de gestión de la memoria</target>
        </trans-unit>
        <trans-unit id="446e27d8fc1178607fbaea2ba6117c2bee0e3166" translate="yes" xml:space="preserve">
          <source>Extending the namespace std</source>
          <target state="translated">Extendiendo el namespace std</target>
        </trans-unit>
        <trans-unit id="e73f93d7fc042bb05945a0bc48fe3f9f81efe46b" translate="yes" xml:space="preserve">
          <source>Extension to &lt;a href=&quot;language/aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;</source>
          <target state="translated">Extensi&amp;oacute;n para &lt;a href=&quot;language/aggregate_initialization&quot;&gt;inicializaci&amp;oacute;n agregada&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d6e9863adde877292363ab102515ca7b6ccafb6" translate="yes" xml:space="preserve">
          <source>Extensions for &lt;code&gt;std::future&lt;/code&gt;</source>
          <target state="translated">Extensiones para &lt;code&gt;std::future&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71a1260f76544c68e3425a1c076e5499b0002fbb" translate="yes" xml:space="preserve">
          <source>Extent</source>
          <target state="translated">Extent</target>
        </trans-unit>
        <trans-unit id="f92e601eb8d663033dca3851ad6f1616d1966aa7" translate="yes" xml:space="preserve">
          <source>External links</source>
          <target state="translated">Enlaces externos</target>
        </trans-unit>
        <trans-unit id="a1aea7fedb01b55857a374fd355fdb3f3d76821e" translate="yes" xml:space="preserve">
          <source>Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container.</source>
          <target state="translated">La extracción de un nodo invalida sólo los iteradores al elemento extraído,y preserva el orden relativo de los elementos que no se borran.Los punteros y referencias al elemento extraído siguen siendo válidos,pero no pueden ser utilizados mientras el elemento sea propiedad de un nodo de manejo:se vuelven utilizables si el elemento se inserta en un contenedor.</target>
        </trans-unit>
        <trans-unit id="b5485507a535a08d29060699bc1ba26e5fbec017" translate="yes" xml:space="preserve">
          <source>Extracting a node invalidates the iterators to the extracted element. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container.</source>
          <target state="translated">La extracción de un nodo invalida los iteradores al elemento extraído.Los punteros y referencias al elemento extraído siguen siendo válidos,pero no pueden ser utilizados mientras el elemento sea propiedad de un nodo de manejo:se vuelven utilizables si el elemento se inserta en un contenedor.</target>
        </trans-unit>
        <trans-unit id="b15d94524be33e2064c90d0f8c997adad64d1ab7" translate="yes" xml:space="preserve">
          <source>Extracting a single character that is the last character of the stream does not set &lt;code&gt;eofbit&lt;/code&gt;: this is different from other formatted input functions, such as extracting the last integer with &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, but this behavior matches the behavior of &lt;code&gt;&lt;a href=&quot;../c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&quot;%c&quot;&lt;/code&gt; format specifier.</source>
          <target state="translated">Extraer un solo car&amp;aacute;cter que sea el &amp;uacute;ltimo car&amp;aacute;cter de la secuencia no establece &lt;code&gt;eofbit&lt;/code&gt; : esto es diferente de otras funciones de entrada formateadas, como extraer el &amp;uacute;ltimo entero con el &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; , pero este comportamiento coincide con el comportamiento de &lt;code&gt;&lt;a href=&quot;../c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; con &lt;code&gt;&quot;%c&quot;&lt;/code&gt; especificador de formato.</target>
        </trans-unit>
        <trans-unit id="77a2197986a0f5813101a331f598cfcb85a220fb" translate="yes" xml:space="preserve">
          <source>Extracts an element from the pair using tuple-like interface.</source>
          <target state="translated">Extrae un elemento del par usando una interfaz parecida a una tupla.</target>
        </trans-unit>
        <trans-unit id="ef0ddc3034770dba9709a96861d6340f80bd0470" translate="yes" xml:space="preserve">
          <source>Extracts and discards characters from the input stream until and including &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">Extrae y descarta caracteres de la secuencia de entrada hasta e incluyendo &lt;code&gt;delim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c16944c77e932413c2253839ec882702fb001de1" translate="yes" xml:space="preserve">
          <source>Extracts character or characters from stream.</source>
          <target state="translated">Extrae el personaje o los personajes de la corriente.</target>
        </trans-unit>
        <trans-unit id="a68c11784d768fd75f5143a08580523eaca81d6d" translate="yes" xml:space="preserve">
          <source>Extracts characters from stream until end of line or the specified delimiter &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">Extractos personajes de corriente hasta el final de la l&amp;iacute;nea o el delimitador especificado &lt;code&gt;delim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0ac0f2a82fe93a443fa08ceb0fe622f9ece3c06" translate="yes" xml:space="preserve">
          <source>Extracts characters from stream.</source>
          <target state="translated">Extrae los personajes de la corriente.</target>
        </trans-unit>
        <trans-unit id="7649df41de72e363648c6e8cac8be1f6dc3a552f" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;Ith&lt;/code&gt; element element from the array.</source>
          <target state="translated">Extrae el elemento del elemento &lt;code&gt;Ith&lt;/code&gt; de la matriz.</target>
        </trans-unit>
        <trans-unit id="44b2e430b2cfaf879035a796088aa41b5223f736" translate="yes" xml:space="preserve">
          <source>Extracts the current &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;regex_iterator&lt;/code&gt;:</source>
          <target state="translated">Extrae el &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; actual de un &lt;code&gt;regex_iterator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b56e81381fa5a47e6b3ea3eb1d488fda4cab62e7" translate="yes" xml:space="preserve">
          <source>Extracts up to &lt;code&gt;count&lt;/code&gt; immediately available characters from the input stream. The extracted characters are stored into the character array pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Se extrae para &lt;code&gt;count&lt;/code&gt; los caracteres disponibles inmediatamente de la secuencia de entrada. Los caracteres extra&amp;iacute;dos se almacenan en la matriz de caracteres a la que apunta &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e72ac13e9cd4d6af9eb70d5cf0e07a1000b3c95a" translate="yes" xml:space="preserve">
          <source>F is sequenced-before X in thread A</source>
          <target state="translated">F está secuenciada antes de X en el hilo A</target>
        </trans-unit>
        <trans-unit id="7baf4c10d15dfb9c6bb605f66aef033fa6c6e2a5" translate="yes" xml:space="preserve">
          <source>FA is sequenced-before X in thread A</source>
          <target state="translated">FA está secuenciado antes de X en el hilo A</target>
        </trans-unit>
        <trans-unit id="ee8392aac4b3ee280362ef5273dcbf0dce3c5592" translate="yes" xml:space="preserve">
          <source>FEMININE ORDINAL INDICATOR</source>
          <target state="translated">INDICADOR ORDINAL FEMENINO</target>
        </trans-unit>
        <trans-unit id="c061bc777cddf822c848be8c51b3f6a8a14f19f4" translate="yes" xml:space="preserve">
          <source>FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</source>
          <target state="translated">FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="b1c364462df93e13ffc864f5e34d434d3e0896f1" translate="yes" xml:space="preserve">
          <source>FE_DFL_ENV</source>
          <target state="translated">FE_DFL_ENV</target>
        </trans-unit>
        <trans-unit id="afc46bada59e52921ca04acfa3e557f4d34949db" translate="yes" xml:space="preserve">
          <source>FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</source>
          <target state="translated">FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</target>
        </trans-unit>
        <trans-unit id="f17f59f8bb1aa4aa1c2a8be48c8b3cc395132a95" translate="yes" xml:space="preserve">
          <source>FE_UNDERFLOW</source>
          <target state="translated">FE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="5fc0e01507a5cabdda26a6538ed27cbe059c94c7" translate="yes" xml:space="preserve">
          <source>FE_UPWARD</source>
          <target state="translated">FE_UPWARD</target>
        </trans-unit>
        <trans-unit id="6c8821a037c125e39dc3cb69a201a2174bd7c0f8" translate="yes" xml:space="preserve">
          <source>FILENAME_MAX</source>
          <target state="translated">FILENAME_MAX</target>
        </trans-unit>
        <trans-unit id="ec0e6a828868888b35d7b88c45bc8ec8ded65b4c" translate="yes" xml:space="preserve">
          <source>FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</source>
          <target state="translated">FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="7afcf0013539d05e408bc6855b9ff9c33961ba4a" translate="yes" xml:space="preserve">
          <source>FLT_DIGDBL_DIGLDBL_DIG</source>
          <target state="translated">FLT_DIGDBL_DIGLDBL_DIG</target>
        </trans-unit>
        <trans-unit id="fb4b82dd7a09ae0e4cd4ec26fae3ace2a1f492b3" translate="yes" xml:space="preserve">
          <source>FLT_EPSILONDBL_EPSILONLDBL_EPSILON</source>
          <target state="translated">FLT_EPSILONDBL_EPSILONLDBL_EPSILON</target>
        </trans-unit>
        <trans-unit id="19a80ddd685588eb2c01ceaa6c67ca15a9d3cd90" translate="yes" xml:space="preserve">
          <source>FLT_EVAL_METHOD</source>
          <target state="translated">FLT_EVAL_METHOD</target>
        </trans-unit>
        <trans-unit id="27b085fe54adba08fa4a2911aa54c2928531a994" translate="yes" xml:space="preserve">
          <source>FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</source>
          <target state="translated">FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</target>
        </trans-unit>
        <trans-unit id="d23e1d93b48a70a6b3008660a10922fc69e91714" translate="yes" xml:space="preserve">
          <source>FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</source>
          <target state="translated">FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</target>
        </trans-unit>
        <trans-unit id="14a1a55c6769f2d618f216dd4e1926c937963a81" translate="yes" xml:space="preserve">
          <source>FLT_MAXDBL_MAXLDBL_MAX</source>
          <target state="translated">FLT_MAXDBL_MAXLDBL_MAX</target>
        </trans-unit>
        <trans-unit id="1a43181bc7c68633c0d3a314ceb823229a88ee19" translate="yes" xml:space="preserve">
          <source>FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</source>
          <target state="translated">FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</target>
        </trans-unit>
        <trans-unit id="ed2d991f061e360c893c5a713ef996b38ebffdc9" translate="yes" xml:space="preserve">
          <source>FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</source>
          <target state="translated">FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</target>
        </trans-unit>
        <trans-unit id="24b8072d7962d75d2c508ff42b7b1b1555e6bb66" translate="yes" xml:space="preserve">
          <source>FLT_MINDBL_MINLDBL_MIN</source>
          <target state="translated">FLT_MINDBL_MINLDBL_MIN</target>
        </trans-unit>
        <trans-unit id="6869500f7b0f9c2b39432ab1b4dcf3e3690ba2a4" translate="yes" xml:space="preserve">
          <source>FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</source>
          <target state="translated">FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</target>
        </trans-unit>
        <trans-unit id="d64b48614536e2d9f3fd84e0b2d0f3339ef6dae1" translate="yes" xml:space="preserve">
          <source>FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</source>
          <target state="translated">FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</target>
        </trans-unit>
        <trans-unit id="3d8d38284d7c48984126ae4544c8465c506ee097" translate="yes" xml:space="preserve">
          <source>FLT_RADIX</source>
          <target state="translated">FLT_RADIX</target>
        </trans-unit>
        <trans-unit id="234dca4e2a0e92e5608ec0464e330e76723ea1d3" translate="yes" xml:space="preserve">
          <source>FLT_ROUNDS</source>
          <target state="translated">FLT_ROUNDS</target>
        </trans-unit>
        <trans-unit id="7e6cd06ba47da57a942743f790919ca173fb6d20" translate="yes" xml:space="preserve">
          <source>FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</source>
          <target state="translated">FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</target>
        </trans-unit>
        <trans-unit id="60945a4b9de8b69d4d5468fc065e520c99d43f40" translate="yes" xml:space="preserve">
          <source>FOPEN_MAX</source>
          <target state="translated">FOPEN_MAX</target>
        </trans-unit>
        <trans-unit id="052dbc6bd1e79a500f50639c055da0a0bddfcda6" translate="yes" xml:space="preserve">
          <source>FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN</source>
          <target state="translated">FP_NORMAL,FP_SUBNORMAL,FP_ZERO,FP_INFINITO,FP_NAN</target>
        </trans-unit>
        <trans-unit id="4b390f17b3415cc66503253a8e943ae6869cbbbb" translate="yes" xml:space="preserve">
          <source>FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</source>
          <target state="translated">FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</target>
        </trans-unit>
        <trans-unit id="13ad13aaa89439dd8522b85f083a14ec539c93e9" translate="yes" xml:space="preserve">
          <source>FP_ZERO</source>
          <target state="translated">FP_ZERO</target>
        </trans-unit>
        <trans-unit id="8c6c7c8ebbe0f69f73a317ea017f66dfe215ff4a" translate="yes" xml:space="preserve">
          <source>Facet categories</source>
          <target state="translated">Categorías de la faceta</target>
        </trans-unit>
        <trans-unit id="041a83e17c0f537ae2ed62d3b2cdf6826e396193" translate="yes" xml:space="preserve">
          <source>Facet category base classes</source>
          <target state="translated">Clases de base de la categoría de la faceta</target>
        </trans-unit>
        <trans-unit id="b533c7fea0c500ba4ef293884991083e32ec4a68" translate="yes" xml:space="preserve">
          <source>Facets with the same &lt;code&gt;id&lt;/code&gt; belong to the same facet category and replace each other when added to a locale object.</source>
          <target state="translated">Las facetas con la misma &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n pertenecen a la misma categor&amp;iacute;a de faceta y se reemplazan entre s&amp;iacute; cuando se agregan a un objeto de configuraci&amp;oacute;n regional.</target>
        </trans-unit>
        <trans-unit id="66908b176ccb4f40a6f1a10938d28a50727305a6" translate="yes" xml:space="preserve">
          <source>Factor operations</source>
          <target state="translated">Operaciones de factor</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="ce6c5bc258e8bef5e3ae59b1338a20c4748ea8d2" translate="yes" xml:space="preserve">
          <source>Failure to open</source>
          <target state="translated">Fallo en la apertura</target>
        </trans-unit>
        <trans-unit id="d3051aec047cdd51e6d43d2664a5df396a9877fb" translate="yes" xml:space="preserve">
          <source>Failures to meet the postconditions, such as failing to produce a valid return value object</source>
          <target state="translated">Fallas en el cumplimiento de las condiciones postales,como no producir un objeto de valor de retorno válido</target>
        </trans-unit>
        <trans-unit id="3914bd46dc4687d6b7087f5c008acc618475cc00" translate="yes" xml:space="preserve">
          <source>Failures to meet the preconditions of another function that must be called</source>
          <target state="translated">No cumple las condiciones previas de otra función que debe llamarse</target>
        </trans-unit>
        <trans-unit id="c29752c93447e11b1a890d7ac78a70435ca5bdb4" translate="yes" xml:space="preserve">
          <source>Fancy pointers</source>
          <target state="translated">Sugerencias de fantasía...</target>
        </trans-unit>
        <trans-unit id="b494fef582ccfffefb54575ea4e577f7dbaf26c1" translate="yes" xml:space="preserve">
          <source>Fast access but fixed number of elements</source>
          <target state="translated">Acceso rápido pero número fijo de elementos</target>
        </trans-unit>
        <trans-unit id="24dd69ccc43e1ae6d5f5a742d02f0da0f6b32305" translate="yes" xml:space="preserve">
          <source>Fast access but mostly inefficient insertions/deletions</source>
          <target state="translated">Acceso rápido,pero sobre todo inserciones/borrones ineficaces</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="0775fb360f01bab977ed5ec997840be1f65f3719" translate="yes" xml:space="preserve">
          <source>Feature testing</source>
          <target state="translated">Prueba de características</target>
        </trans-unit>
        <trans-unit id="9fe9f4b9291746b85204d55ff6be73414f9570ac" translate="yes" xml:space="preserve">
          <source>Feature testing (C++20)</source>
          <target state="translated">Prueba de características (C++20)</target>
        </trans-unit>
        <trans-unit id="bc0228c9de8004fdac6db7743fdd23e61859a392" translate="yes" xml:space="preserve">
          <source>Fence-atomic synchronization</source>
          <target state="translated">Sincronización atómica de la valla</target>
        </trans-unit>
        <trans-unit id="c0f00371ddb6eac35be65eb720b3cab89de6182d" translate="yes" xml:space="preserve">
          <source>Fence-fence synchronization</source>
          <target state="translated">Sincronización de la valla</target>
        </trans-unit>
        <trans-unit id="e79120c3392d8a2111f0e85788e61d24a2973100" translate="yes" xml:space="preserve">
          <source>Fence-fence synchronization can be used to add synchronization to a sequence of several relaxed atomic operations, for example.</source>
          <target state="translated">La sincronización de la valla puede utilizarse para añadir la sincronización a una secuencia de varias operaciones atómicas relajadas,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="9d413b1e7e21f8acf4d5ba31c56b61a1a190cf03" translate="yes" xml:space="preserve">
          <source>File I/O implementation</source>
          <target state="translated">Implementación de archivos I/O</target>
        </trans-unit>
        <trans-unit id="a1369155ac8ee1937c5466bde76ab0bbbcbba45c" translate="yes" xml:space="preserve">
          <source>File access</source>
          <target state="translated">Acceso a los archivos</target>
        </trans-unit>
        <trans-unit id="ecbca940d8a1676fb3cfcf517eb3d1e3e48574ec" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;b&quot;&lt;/code&gt; can optionally be specified to open a file &lt;a href=&quot;../c#Binary_and_text_modes&quot;&gt;in binary mode&lt;/a&gt;. This flag has no effect on POSIX systems, but on Windows, for example, it disables special handling of &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\x1A'&lt;/code&gt;.</source>
          <target state="translated">El indicador de modo de acceso a archivos &lt;code&gt;&quot;b&quot;&lt;/code&gt; se puede especificar opcionalmente para abrir un archivo &lt;a href=&quot;../c#Binary_and_text_modes&quot;&gt;en modo binario&lt;/a&gt; . Este indicador no tiene efecto en los sistemas POSIX, pero en Windows, por ejemplo, deshabilita el manejo especial de &lt;code&gt;'\n'&lt;/code&gt; y &lt;code&gt;'\x1A'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9675879f138420dc849c3b02c7a08a45f1764ce0" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;x&quot;&lt;/code&gt; can optionally be appended to &quot;w&quot; or &quot;w+&quot; specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C++17)</source>
          <target state="translated">El indicador de modo de acceso a archivos &lt;code&gt;&quot;x&quot;&lt;/code&gt; se puede agregar opcionalmente a los especificadores &quot;w&quot; o &quot;w +&quot;. Este indicador obliga a la funci&amp;oacute;n a fallar si el archivo existe, en lugar de sobrescribirlo. (C ++ 17)</target>
        </trans-unit>
        <trans-unit id="848538ee54491f003e342600d6426cc1665c1d90" translate="yes" xml:space="preserve">
          <source>File descriptor value too large</source>
          <target state="translated">El valor del descriptor del archivo es demasiado grande</target>
        </trans-unit>
        <trans-unit id="e4abf36a5ea54ec41cce22ec0fe706639aba0b93" translate="yes" xml:space="preserve">
          <source>File exists</source>
          <target state="translated">El archivo existe</target>
        </trans-unit>
        <trans-unit id="64fd779c46cf2d931941b36cb1e56f079e1d6e2c" translate="yes" xml:space="preserve">
          <source>File operations</source>
          <target state="translated">Operaciones de archivo</target>
        </trans-unit>
        <trans-unit id="0b24f6042e86aadda1815101f042d04954349481" translate="yes" xml:space="preserve">
          <source>File owner has execute/search permission</source>
          <target state="translated">El propietario del archivo tiene permiso de ejecución/búsqueda</target>
        </trans-unit>
        <trans-unit id="1a3e84e64dd01307f0ee39195f923bfa54b5c0c6" translate="yes" xml:space="preserve">
          <source>File owner has read permission</source>
          <target state="translated">El propietario del archivo tiene permiso de lectura</target>
        </trans-unit>
        <trans-unit id="00a45fcb3c463f25a9813f51c216665d3293d7ab" translate="yes" xml:space="preserve">
          <source>File owner has read, write, and execute/search permissions</source>
          <target state="translated">El propietario del archivo tiene permisos de lectura,escritura y ejecución/búsqueda</target>
        </trans-unit>
        <trans-unit id="01358bbedd5677b98189c5d53b33f357f182c488" translate="yes" xml:space="preserve">
          <source>File owner has write permission</source>
          <target state="translated">El propietario del archivo tiene permiso de escritura</target>
        </trans-unit>
        <trans-unit id="1a996ddad7a713856017f5f90fe0498db20bdbda" translate="yes" xml:space="preserve">
          <source>File position indicator on success or &lt;code&gt;-1L&lt;/code&gt; if failure occurs. Also sets &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">Indicador de posici&amp;oacute;n del archivo en caso de &amp;eacute;xito o &lt;code&gt;-1L&lt;/code&gt; si ocurre una falla. Tambi&amp;eacute;n establece &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; en caso de falla.</target>
        </trans-unit>
        <trans-unit id="a494399ad447f56f41d7522c5db08562d3c24708" translate="yes" xml:space="preserve">
          <source>File positioning</source>
          <target state="translated">Posicionamiento de archivos</target>
        </trans-unit>
        <trans-unit id="36cd96e05c782cee5791cf21bde1893978c5c077" translate="yes" xml:space="preserve">
          <source>File scope</source>
          <target state="translated">Escobas de archivo</target>
        </trans-unit>
        <trans-unit id="a0704a4eaa055ab08e3766911e446737f4f2a445" translate="yes" xml:space="preserve">
          <source>File too large</source>
          <target state="translated">El archivo es demasiado grande.</target>
        </trans-unit>
        <trans-unit id="0205534386e03d869079430b7c0117e9af5229d7" translate="yes" xml:space="preserve">
          <source>File types</source>
          <target state="translated">Tipos de archivos</target>
        </trans-unit>
        <trans-unit id="fae255f2995d1f907f01cf7594e8462316da5be7" translate="yes" xml:space="preserve">
          <source>Filename and line information</source>
          <target state="translated">Nombre de archivo e información de línea</target>
        </trans-unit>
        <trans-unit id="5ba8d30ffba45db4e2f3f220829fe902e2fd990f" translate="yes" xml:space="preserve">
          <source>Filename too long</source>
          <target state="translated">El nombre de archivo es demasiado largo</target>
        </trans-unit>
        <trans-unit id="092fe85f5c2e62269fa44ec1fcbf190e92f16564" translate="yes" xml:space="preserve">
          <source>Filesystem</source>
          <target state="translated">Filesystem</target>
        </trans-unit>
        <trans-unit id="bbc4c49f164b158dbe825399e8316a41a98039c5" translate="yes" xml:space="preserve">
          <source>Filesystem TS</source>
          <target state="translated">Filesystem TS</target>
        </trans-unit>
        <trans-unit id="f6adde9d94ef3f9818beca92c4fb5775d3d08a90" translate="yes" xml:space="preserve">
          <source>Filesystem library</source>
          <target state="translated">Biblioteca del sistema de archivos</target>
        </trans-unit>
        <trans-unit id="d6016e126bb1261237244c868e871626e1164a78" translate="yes" xml:space="preserve">
          <source>Fills [&lt;code&gt;rb&lt;/code&gt;,&lt;code&gt;re&lt;/code&gt;) with 32-bit quantities depending on the initial supplied values and potential previous calls to &lt;code&gt;generate&lt;/code&gt;. If &lt;code&gt;rb == re&lt;/code&gt;, it does nothing.</source>
          <target state="translated">Llena [ &lt;code&gt;rb&lt;/code&gt; , &lt;code&gt;re&lt;/code&gt; ) con cantidades de 32 bits dependiendo de los valores iniciales suministrados y las posibles llamadas anteriores para &lt;code&gt;generate&lt;/code&gt; . Si &lt;code&gt;rb == re&lt;/code&gt; , no hace nada.</target>
        </trans-unit>
        <trans-unit id="0477adab8010ca288bf22b1b3deddefba747b42d" translate="yes" xml:space="preserve">
          <source>Fills the range &lt;code&gt;[begin, end)&lt;/code&gt; with unsigned integer values &lt;code&gt;i&lt;/code&gt;, 0 &amp;le; i &amp;lt; 232</source>
          <target state="translated">Llena el rango &lt;code&gt;[begin, end)&lt;/code&gt; con valores enteros sin signo &lt;code&gt;i&lt;/code&gt; , 0 &amp;le; i &amp;lt;232</target>
        </trans-unit>
        <trans-unit id="da2860ae65231144c9442af16b999bbb60810f8b" translate="yes" xml:space="preserve">
          <source>Fills the range &lt;code&gt;[first, last)&lt;/code&gt; with sequentially increasing values, starting with &lt;code&gt;value&lt;/code&gt; and repetitively evaluating &lt;code&gt;++value&lt;/code&gt;.</source>
          <target state="translated">Llena el rango &lt;code&gt;[first, last)&lt;/code&gt; con valores secuencialmente crecientes, comenzando con el &lt;code&gt;value&lt;/code&gt; y evaluando repetidamente el &lt;code&gt;++value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae117132b523ad7bbcabf063e4512b94303ad825" translate="yes" xml:space="preserve">
          <source>Final classes cannot be used as base classes.</source>
          <target state="translated">Las clases finales no pueden ser usadas como clases de base.</target>
        </trans-unit>
        <trans-unit id="f71bda78a1e6997b4c579d61039ab383458a0b93" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;awaiter.await_resume()&lt;/code&gt; is called, and its result is the result of the whole &lt;code&gt;co_await expr&lt;/code&gt; expression.</source>
          <target state="translated">Finalmente, se llama a &lt;code&gt;awaiter.await_resume()&lt;/code&gt; , y su resultado es el resultado de toda la expresi&amp;oacute;n &lt;code&gt;co_await expr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4db4903bd597b61dd8a328899682e291be0a76a1" translate="yes" xml:space="preserve">
          <source>Finally, calls &lt;code&gt;is.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">Finalmente, llama a &lt;code&gt;is.width(0)&lt;/code&gt; para cancelar los efectos de &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , si los hay.</target>
        </trans-unit>
        <trans-unit id="9e4015259c16ae5de63c7894d2c7b391c4ca0b80" translate="yes" xml:space="preserve">
          <source>Finally, calls &lt;code&gt;os.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">Finalmente, llama a &lt;code&gt;os.width(0)&lt;/code&gt; para cancelar los efectos de &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , si los hay.</target>
        </trans-unit>
        <trans-unit id="177dc3f32e13dff30c58fffec60fe61e244cc93e" translate="yes" xml:space="preserve">
          <source>Finally, outputs each character from the resulting sequence as if by calling &lt;code&gt;out.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(out.width(), seq.size())&lt;/code&gt; and &lt;code&gt;out.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">Finalmente, genera cada car&amp;aacute;cter de la secuencia resultante como si llamara &lt;code&gt;out.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; , donde &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(out.width(), seq.size())&lt;/code&gt; y &lt;code&gt;out.width(0)&lt;/code&gt; para cancelar los efectos de &lt;code&gt;&lt;a href=&quot;setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , si hay alguno.</target>
        </trans-unit>
        <trans-unit id="00d858cc8e88f691053b3dcc6137ac4cde6d6ced" translate="yes" xml:space="preserve">
          <source>Finds an element equal to element pointed to by &lt;code&gt;key&lt;/code&gt; in an array pointed to by &lt;code&gt;ptr&lt;/code&gt;. The array contains &lt;code&gt;count&lt;/code&gt; elements of &lt;code&gt;size&lt;/code&gt; bytes each and must be partitioned with respect to the object pointed to by &lt;code&gt;key&lt;/code&gt;, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">Encuentra un elemento igual al elemento al que apunta la &lt;code&gt;key&lt;/code&gt; en una matriz a la que apunta &lt;code&gt;ptr&lt;/code&gt; . La matriz contiene elementos de &lt;code&gt;count&lt;/code&gt; de bytes de &lt;code&gt;size&lt;/code&gt; cada uno y debe dividirse con respecto al objeto se&amp;ntilde;alado por &lt;code&gt;key&lt;/code&gt; , es decir, todos los elementos que se comparan menos de lo que deben aparecer antes de todos los elementos que se comparan igual a, y esos deben aparecer antes de todos Los elementos que se comparan m&amp;aacute;s que el objeto clave. Una matriz completamente ordenada satisface estos requisitos. Los elementos se comparan utilizando la funci&amp;oacute;n se&amp;ntilde;alada por &lt;code&gt;comp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9927a1e661f4bfd80aaf31b22f6f41e30e9b227" translate="yes" xml:space="preserve">
          <source>Finds real roots of multiple quadratic equations.</source>
          <target state="translated">Encuentra las raíces reales de múltiples ecuaciones cuadráticas.</target>
        </trans-unit>
        <trans-unit id="30bcbdf5d9a1fe0bd647e009803f909f56efc575" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to any of the characters in the given character sequence.</source>
          <target state="translated">Encuentra el primer carácter igual a cualquiera de los caracteres de la secuencia de caracteres dada.</target>
        </trans-unit>
        <trans-unit id="5cdb4e092b97109f8b2048be07ca72c3bde0609f" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to none of the characters in the given character sequence. The search considers only the interval [&lt;code&gt;pos&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;). If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Encuentra el primer car&amp;aacute;cter igual a ninguno de los caracteres en la secuencia de caracteres dada. La b&amp;uacute;squeda solo considera el intervalo [ &lt;code&gt;pos&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ). Si el car&amp;aacute;cter no est&amp;aacute; presente en el intervalo, se &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24f9fbec876cfd13c75d96d81a6a74110daac9d5" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to one of the characters in the given character sequence. The search considers only the interval [&lt;code&gt;pos&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;). If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Encuentra el primer car&amp;aacute;cter igual a uno de los caracteres en la secuencia de caracteres dada. La b&amp;uacute;squeda solo considera el intervalo [ &lt;code&gt;pos&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ). Si el car&amp;aacute;cter no est&amp;aacute; presente en el intervalo, se &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a02ae1c73392d3f6a41d7039bf6f66883821f319" translate="yes" xml:space="preserve">
          <source>Finds the first character in wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that is also in wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Encuentra el primer car&amp;aacute;cter en una cadena ancha apuntada por &lt;code&gt;dest&lt;/code&gt; , que tambi&amp;eacute;n est&amp;aacute; en una cadena ancha apuntada por &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="981d0030e7019507414199bd0e078d7265cd8673" translate="yes" xml:space="preserve">
          <source>Finds the first character not equal to any of the characters in the given character sequence.</source>
          <target state="translated">Encuentra que el primer personaje no es igual a ninguno de los personajes de la secuencia de caracteres dada.</target>
        </trans-unit>
        <trans-unit id="c744c8fe55a01d138ec8c24e1528aec65ec2023a" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the byte string &lt;code&gt;target&lt;/code&gt; in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">Encuentra la primera aparici&amp;oacute;n del &lt;code&gt;target&lt;/code&gt; de la cadena de bytes en la cadena de bytes a la que apunta &lt;code&gt;str&lt;/code&gt; . Los caracteres nulos finales no se comparan.</target>
        </trans-unit>
        <trans-unit id="822e0508dd7e5034ad40e0d29a486e2402585a0d" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the character &lt;code&gt;static_cast&amp;lt;char&amp;gt;(ch)&lt;/code&gt; in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Encuentra la primera aparici&amp;oacute;n del car&amp;aacute;cter &lt;code&gt;static_cast&amp;lt;char&amp;gt;(ch)&lt;/code&gt; en la cadena de bytes a la que apunta &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9388d73210fb9a6adcc18de249cc87e2da6d4106" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Encuentra la primera aparici&amp;oacute;n del car&amp;aacute;cter ancho &lt;code&gt;ch&lt;/code&gt; en la cadena ancha apuntada por &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60954d9dde97ea95b47805de626af5f9bb89a11c" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide string &lt;code&gt;src&lt;/code&gt; in the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">Encuentra la primera aparici&amp;oacute;n de la cadena ancha &lt;code&gt;src&lt;/code&gt; en la cadena ancha apuntada por &lt;code&gt;dest&lt;/code&gt; . Los caracteres nulos finales no se comparan.</target>
        </trans-unit>
        <trans-unit id="fc71329dcb9337103dd5851e9eb7dfa903cd2767" translate="yes" xml:space="preserve">
          <source>Finds the first substring equal to the given character sequence.</source>
          <target state="translated">Encuentra la primera subcadena igual a la secuencia de caracteres dada.</target>
        </trans-unit>
        <trans-unit id="73d8f05c9748bf0bddfc6937b1e51af871f089f0" translate="yes" xml:space="preserve">
          <source>Finds the first substring equal to the given character sequence. Search begins at &lt;code&gt;pos&lt;/code&gt;, i.e. the found substring must not begin in a position preceding &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">Encuentra la primera subcadena igual a la secuencia de caracteres dada. La b&amp;uacute;squeda comienza en la &lt;code&gt;pos&lt;/code&gt; ici&amp;oacute;n , es decir, la subcadena encontrada no debe comenzar en una posici&amp;oacute;n anterior a la &lt;code&gt;pos&lt;/code&gt; ici&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="d519b8e547c2fea611a706cf0f567de8c481f047" translate="yes" xml:space="preserve">
          <source>Finds the greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Encuentra el elemento m&amp;aacute;s grande en el rango &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a0eba935882bc5c40f3eb57edca9ffaa6207e17" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to none of the characters in the given character sequence. The search considers only the interval [0, pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Encuentra el &amp;uacute;ltimo car&amp;aacute;cter igual a ninguno de los caracteres en la secuencia de caracteres dada. La b&amp;uacute;squeda considera solo el intervalo [0, pos]. Si el car&amp;aacute;cter no est&amp;aacute; presente en el intervalo, se &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="031b5bc7f5b52d9b68f531ec16e07add0732f8a9" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to one of characters in the given character sequence. Exact search algorithm is not specified. The search considers only the interval [0; pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Encuentra el &amp;uacute;ltimo car&amp;aacute;cter igual a uno de los caracteres en la secuencia de caracteres dada. El algoritmo de b&amp;uacute;squeda exacto no est&amp;aacute; especificado. La b&amp;uacute;squeda considera solo el intervalo [0; pos]. Si el car&amp;aacute;cter no est&amp;aacute; presente en el intervalo, se &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="262672fc83487a5e2f2a3a72605026935426490e" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the interval [0, pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">Encuentra el &amp;uacute;ltimo car&amp;aacute;cter igual a uno de los caracteres en la secuencia de caracteres dada. El algoritmo de b&amp;uacute;squeda exacto no est&amp;aacute; especificado. La b&amp;uacute;squeda considera solo el intervalo [0, pos]. Si el car&amp;aacute;cter no est&amp;aacute; presente en el intervalo, se &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2eeb42fd9c4368ca6e261a7eaf0eb9173c9ca19" translate="yes" xml:space="preserve">
          <source>Finds the last character not equal to any of the characters in the given character sequence.</source>
          <target state="translated">Encuentra que el último personaje no es igual a ninguno de los personajes de la secuencia de caracteres dada.</target>
        </trans-unit>
        <trans-unit id="c9e927921904e1bd8a7847a95ec12dfc3ed90fd5" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt;) in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">Encuentra la &amp;uacute;ltima aparici&amp;oacute;n de &lt;code&gt;ch&lt;/code&gt; (despu&amp;eacute;s de la conversi&amp;oacute;n a &lt;code&gt;char&lt;/code&gt; ) en la cadena de bytes a la que apunta &lt;code&gt;str&lt;/code&gt; . El car&amp;aacute;cter nulo final se considera parte de la cadena y se puede encontrar si busca &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abb2c2feff5f0426d0ef85cddeeca9860311e3e9" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">Encuentra la &amp;uacute;ltima aparici&amp;oacute;n del car&amp;aacute;cter ancho &lt;code&gt;ch&lt;/code&gt; en la cadena ancha a la que apunta &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aba2a0477e061745abafbf2e570698649cfbd049" translate="yes" xml:space="preserve">
          <source>Finds the last substring equal to the given character sequence.</source>
          <target state="translated">Encuentra la última subcadena igual a la secuencia de caracteres dada.</target>
        </trans-unit>
        <trans-unit id="85ecfa172af6c676f0f2b7ede4563bdf54dbd13d" translate="yes" xml:space="preserve">
          <source>Finds the last substring equal to the given character sequence. Search begins at &lt;code&gt;pos&lt;/code&gt;, i.e. the found substring must not begin in a position following &lt;code&gt;pos&lt;/code&gt;. If &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; or any value not smaller than &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;-1 is passed as &lt;code&gt;pos&lt;/code&gt;, whole string will be searched.</source>
          <target state="translated">Encuentra la &amp;uacute;ltima subcadena igual a la secuencia de caracteres dada. La b&amp;uacute;squeda comienza en la &lt;code&gt;pos&lt;/code&gt; ici&amp;oacute;n , es decir, la subcadena encontrada no debe comenzar en una posici&amp;oacute;n posterior a la &lt;code&gt;pos&lt;/code&gt; ici&amp;oacute;n . Si &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; o cualquier valor no menor que &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; -1 se pasa como &lt;code&gt;pos&lt;/code&gt; , se buscar&amp;aacute; la cadena completa.</target>
        </trans-unit>
        <trans-unit id="4e96707b2590ca4719626a87f0675c2693cd9371" translate="yes" xml:space="preserve">
          <source>Finds the next token in a null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated byte string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">Encuentra el siguiente token en una cadena de bytes terminada en nulo a la que apunta &lt;code&gt;str&lt;/code&gt; . Los caracteres separadores se identifican mediante una cadena de bytes terminada en nulo se&amp;ntilde;alada por &lt;code&gt;delim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="380ef08d0f8e6c7597e5b529abb1fb2b2ba51aa4" translate="yes" xml:space="preserve">
          <source>Finds the next token in a null-terminated wide string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated wide string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">Encuentra el siguiente token en una cadena ancha terminada en nulo a la que apunta &lt;code&gt;str&lt;/code&gt; . Los caracteres separadores se identifican por una cadena ancha terminada en nulo se&amp;ntilde;alada por &lt;code&gt;delim&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59f9527a2060df058f520ec4facfb5d116cfb5ab" translate="yes" xml:space="preserve">
          <source>Finds the smallest and greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Encuentra el elemento m&amp;aacute;s peque&amp;ntilde;o y m&amp;aacute;s grande en el rango &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73f7ebc728f72e9244fbcb71e4bebffbcaa8c095" translate="yes" xml:space="preserve">
          <source>Finds the smallest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Encuentra el elemento m&amp;aacute;s peque&amp;ntilde;o en el rango &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb4718767cbeb7ec2a4050ea8b0704c79bba10d8" translate="yes" xml:space="preserve">
          <source>First clears &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Primero borra &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;eofbit&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c779ca82cc21b768cc6c4bcc4f1d87107bdb7d29" translate="yes" xml:space="preserve">
          <source>First clears &lt;code&gt;eofbit&lt;/code&gt;, then behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, if &lt;code&gt;rdbuf()&lt;/code&gt; is not null, calls &lt;code&gt;rdbuf()-&amp;gt;sputbackc(ch)&lt;/code&gt;, which calls &lt;code&gt;rdbuf()-&amp;gt;pbackfail(ch)&lt;/code&gt; if &lt;code&gt;ch&lt;/code&gt; does not equal the most recently extracted character.</source>
          <target state="translated">Primero borra &lt;code&gt;eofbit&lt;/code&gt; , luego se comporta como &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, si &lt;code&gt;rdbuf()&lt;/code&gt; no es nulo, llama a &lt;code&gt;rdbuf()-&amp;gt;sputbackc(ch)&lt;/code&gt; , que llama a &lt;code&gt;rdbuf()-&amp;gt;pbackfail(ch)&lt;/code&gt; si &lt;code&gt;ch&lt;/code&gt; no es igual al car&amp;aacute;cter extra&amp;iacute;do m&amp;aacute;s recientemente.</target>
        </trans-unit>
        <trans-unit id="13f51e93c18a65140da3cb2cb1dfab78c49243a0" translate="yes" xml:space="preserve">
          <source>First destroys the current contained object (if any) by &lt;code&gt;&lt;a href=&quot;reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt;, then:</source>
          <target state="translated">Primero destruye el objeto contenido actual (si lo hay) mediante &lt;code&gt;&lt;a href=&quot;reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; , luego:</target>
        </trans-unit>
        <trans-unit id="401e859548baba3ec799317e533e96d7551f1830" translate="yes" xml:space="preserve">
          <source>First version</source>
          <target state="translated">Primera versión</target>
        </trans-unit>
        <trans-unit id="1654933a6fa4f43716580ffeb045cae1b208fe38" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;implicit_cast&quot;&gt;Pointer conversions&lt;/a&gt; (pointer to member conversions if the arguments are pointers to members), function pointer conversions,(since C++17) and &lt;a href=&quot;implicit_cast&quot;&gt;qualification conversions&lt;/a&gt; are applied to both operands to obtain the</source>
          <target state="translated">Primero, &lt;a href=&quot;implicit_cast&quot;&gt;las conversiones de&lt;/a&gt; puntero ( conversiones de puntero a miembro si los argumentos son punteros a miembros), las conversiones de puntero de funci&amp;oacute;n (desde C ++ 17) y las &lt;a href=&quot;implicit_cast&quot;&gt;conversiones de calificaci&amp;oacute;n&lt;/a&gt; se aplican a ambos operandos para obtener el</target>
        </trans-unit>
        <trans-unit id="30c242bb4e4e1c97688da86303f8e70ebf723f0f" translate="yes" xml:space="preserve">
          <source>First, allocates or resizes the private storage (dynamic array of &lt;code&gt;long&lt;/code&gt; or another indexable data structure) sufficiently to make &lt;code&gt;index&lt;/code&gt; a valid index, then returns a reference to the &lt;code&gt;long&lt;/code&gt; element of the private storage with the index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">Primero, asigna o cambia el tama&amp;ntilde;o del almacenamiento privado (matriz din&amp;aacute;mica de estructura de datos indexable &lt;code&gt;long&lt;/code&gt; u otra) lo suficiente como para hacer que el &lt;code&gt;index&lt;/code&gt; un &amp;iacute;ndice v&amp;aacute;lido, luego devuelve una referencia al elemento &lt;code&gt;long&lt;/code&gt; del almacenamiento privado con el &amp;iacute;ndice &lt;code&gt;index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c741d459f4a943d6ccb7e91f1d19877e2b46cf15" translate="yes" xml:space="preserve">
          <source>First, allocates or resizes the private storage (dynamic array of &lt;code&gt;void*&lt;/code&gt; or another indexable data structure) sufficiently to make &lt;code&gt;index&lt;/code&gt; a valid index, then returns a reference to the &lt;code&gt;void*&lt;/code&gt; element of the private storage with the index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">Primero, asigna o cambia el tama&amp;ntilde;o del almacenamiento privado (matriz din&amp;aacute;mica de &lt;code&gt;void*&lt;/code&gt; u otra estructura de datos indexable) lo suficiente como para hacer que &lt;code&gt;index&lt;/code&gt; sea un &amp;iacute;ndice v&amp;aacute;lido, luego devuelve una referencia al elemento &lt;code&gt;void*&lt;/code&gt; del almacenamiento privado con el &amp;iacute;ndice &lt;code&gt;index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1a406a5e11adcba583e47ceded69c0a59895e04" translate="yes" xml:space="preserve">
          <source>First, attempts to close the file associated with &lt;code&gt;stream&lt;/code&gt;, ignoring any errors. Then, if &lt;code&gt;filename&lt;/code&gt; is not null, attempts to open the file specified by &lt;code&gt;filename&lt;/code&gt; using &lt;code&gt;mode&lt;/code&gt; as if by &lt;code&gt;fopen&lt;/code&gt;, and associates that file with the file stream pointed to by &lt;code&gt;stream&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is a null pointer, then the function attempts to reopen the file that is already associated with &lt;code&gt;stream&lt;/code&gt; (it is implementation defined which mode changes are allowed in this case).</source>
          <target state="translated">Primero, intenta cerrar el archivo asociado con la &lt;code&gt;stream&lt;/code&gt; , ignorando cualquier error. Luego, si el &lt;code&gt;filename&lt;/code&gt; no es nulo, intenta abrir el archivo especificado por &lt;code&gt;filename&lt;/code&gt; de archivo usando el &lt;code&gt;mode&lt;/code&gt; como por &lt;code&gt;fopen&lt;/code&gt; , y asocia ese archivo con la secuencia de archivos apuntada por &lt;code&gt;stream&lt;/code&gt; . Si el &lt;code&gt;filename&lt;/code&gt; es un puntero nulo, entonces la funci&amp;oacute;n intenta volver a abrir el archivo que ya est&amp;aacute; asociado con la &lt;code&gt;stream&lt;/code&gt; (se define la implementaci&amp;oacute;n qu&amp;eacute; cambios de modo se permiten en este caso).</target>
        </trans-unit>
        <trans-unit id="5badc51c36e2585292a914e3f1823ec376257caf" translate="yes" xml:space="preserve">
          <source>First, before doing anything else, obtains type and permissions of &lt;code&gt;from&lt;/code&gt; by no more than a single call to</source>
          <target state="translated">En primer lugar, antes de hacer cualquier otra cosa, obtiene el tipo y permisos de &lt;code&gt;from&lt;/code&gt; por no m&amp;aacute;s de una sola llamada a</target>
        </trans-unit>
        <trans-unit id="bd0a7f661657d89c37e4c1215e80d0191bb4862d" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt; to transmit all pending output (and delayed flush, if any) to the wrapped stream.</source>
          <target state="translated">Primero, las llamadas &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; para transmitir toda la salida pendiente (y la descarga retardada, si la hay) a la secuencia envuelta.</target>
        </trans-unit>
        <trans-unit id="eab9bd2628b9d318b166ebaf056d0f32c1ae9059" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. If an exception is thrown by the call to &lt;code&gt;emit()&lt;/code&gt;, it is caught and ignored.</source>
          <target state="translated">Primero, las llamadas &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; . Si la llamada a &lt;code&gt;emit()&lt;/code&gt; una excepci&amp;oacute;n , se detecta e ignora.</target>
        </trans-unit>
        <trans-unit id="daac23b0d5c1b3ef73330f0f556ea905967387b5" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. If an exception is thrown by the call to &lt;code&gt;emit()&lt;/code&gt;, it is caught and ignored. Then, destroys the member &lt;code&gt;std::basic_syncbuf&lt;/code&gt; and the base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; as usual.</source>
          <target state="translated">Primero, las llamadas &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; . Si se produce una excepci&amp;oacute;n por la llamada a &lt;code&gt;emit()&lt;/code&gt; , se detecta e ignora. Luego, destruye el miembro &lt;code&gt;std::basic_syncbuf&lt;/code&gt; y la base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; como de costumbre.</target>
        </trans-unit>
        <trans-unit id="99f9e198aa798816c58da32cfc0095d286931e68" translate="yes" xml:space="preserve">
          <source>First, clears the error bits in &lt;code&gt;err&lt;/code&gt; by executing &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt;. Then reads characters from the input sequence &lt;code&gt;[beg, end)&lt;/code&gt; that are expected by the &lt;code&gt;&lt;a href=&quot;../time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; format specifier formed by combining &lt;code&gt;'%'&lt;/code&gt;, &lt;code&gt;modifier&lt;/code&gt; (if not &lt;code&gt;'\0'&lt;/code&gt;), and &lt;code&gt;format&lt;/code&gt;. If the characters do not combine to form a valid conversion specifier, sets &lt;code&gt;failbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If the end of the input stream is reached after reading a character, sets &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If the input string was parsed successfully, updates the corresponding fields of &lt;code&gt;*t&lt;/code&gt;.   For complex conversion specifiers, such as &lt;code&gt;'%x'&lt;/code&gt; or &lt;code&gt;'%c'&lt;/code&gt;, or the directives that use the modifiers &lt;code&gt;'E'&lt;/code&gt; and &lt;code&gt;'O'&lt;/code&gt;, the function may fail to determine some of the values to store in &lt;code&gt;*t&lt;/code&gt;. In such case, it sets &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt; and leaves these fields in unspecified state.</source>
          <target state="translated">Primero, borra los bits de error en &lt;code&gt;err&lt;/code&gt; ejecutando &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; . Luego lee los caracteres de la secuencia de entrada &lt;code&gt;[beg, end)&lt;/code&gt; que espera el especificador de formato &lt;code&gt;&lt;a href=&quot;../time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; formado combinando &lt;code&gt;'%'&lt;/code&gt; , &lt;code&gt;modifier&lt;/code&gt; (si no es &lt;code&gt;'\0'&lt;/code&gt; ) y &lt;code&gt;format&lt;/code&gt; o . Si los caracteres no se combinan para formar un especificador de conversi&amp;oacute;n v&amp;aacute;lido, establece &lt;code&gt;failbit&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; . Si se alcanza el final del flujo de entrada despu&amp;eacute;s de leer un car&amp;aacute;cter, establece &lt;code&gt;eofbit&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; . Si la cadena de entrada se analiz&amp;oacute; correctamente, actualiza los campos correspondientes de &lt;code&gt;*t&lt;/code&gt; . Para los especificadores de conversi&amp;oacute;n complejos, como &lt;code&gt;'%x'&lt;/code&gt; o &lt;code&gt;'%c'&lt;/code&gt; , o las directivas que usan los modificadores &lt;code&gt;'E'&lt;/code&gt; y &lt;code&gt;'O'&lt;/code&gt; , la funci&amp;oacute;n puede fallar al determinar algunos de los valores para almacenar en &lt;code&gt;*t&lt;/code&gt; . En tal caso, establece &lt;code&gt;eofbit&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; y deja estos campos en estado no especificado.</target>
        </trans-unit>
        <trans-unit id="761e411f45989f18b8cdc09dfae5d408bc3760bb" translate="yes" xml:space="preserve">
          <source>First, expr is converted to an awaitable as follows:</source>
          <target state="translated">Primero,el exprés se convierte en una espera de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="49e86d447ef30f5d8ac55d11082a293ce491a304" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, performs the ISO/IEC/IEEE 60559</source>
          <target state="translated">Primero, si &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , realiza el ISO / IEC / IEEE 60559</target>
        </trans-unit>
        <trans-unit id="714bfffed5c4d1159d21c2074b0dd5ebd28587dd" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;T&lt;/code&gt; is a class type and the initializer is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; expression whose cv-unqualified type is the same class as &lt;code&gt;T&lt;/code&gt;, the initializer expression itself, rather than a temporary materialized from it, is used to initialize the destination object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;</source>
          <target state="translated">Primero, si &lt;code&gt;T&lt;/code&gt; es un tipo de clase y el inicializador es una expresi&amp;oacute;n &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; cuyo tipo no calificado por cv es la misma clase que &lt;code&gt;T&lt;/code&gt; , la expresi&amp;oacute;n del inicializador en s&amp;iacute;, en lugar de un material temporal de ella, se usa para inicializar el objeto de destino: ver &lt;a href=&quot;copy_elision&quot;&gt;copia elisi&amp;oacute;n&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a19b536bb9ed4bb6c617709d11bbfa515bb05a0" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;root_name() != base.root_name() || is_absolute() != base.is_absolute() || (!has_root_directory() &amp;amp;&amp;amp; base.has_root_directory())&lt;/code&gt;, returns a default-constructed path.</source>
          <target state="translated">Primero, si &lt;code&gt;root_name() != base.root_name() || is_absolute() != base.is_absolute() || (!has_root_directory() &amp;amp;&amp;amp; base.has_root_directory())&lt;/code&gt; , devuelve una ruta construida por defecto.</target>
        </trans-unit>
        <trans-unit id="0af0623ac822520c62720be6f5b81d9ab7f82065" translate="yes" xml:space="preserve">
          <source>First, records that a flush is pending, by updating the appropriate private flag.</source>
          <target state="translated">Primero,registra que una descarga está pendiente,actualizando la bandera privada apropiada.</target>
        </trans-unit>
        <trans-unit id="a3dedc18a8aa37448d34180fda53b30fdca03e04" translate="yes" xml:space="preserve">
          <source>First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt;), then raises the floating-point exceptions that were saved.</source>
          <target state="translated">Primero, recuerda las excepciones de punto flotante actualmente planteadas, luego restaura el entorno de punto flotante del objeto se&amp;ntilde;alado por &lt;code&gt;envp&lt;/code&gt; (similar a &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt; ), luego levanta las excepciones de punto flotante que se guardaron.</target>
        </trans-unit>
        <trans-unit id="f26f81a265113be2257dfeddeb17e46ef91bc7df" translate="yes" xml:space="preserve">
          <source>First, retrieve the outermost allocator &lt;code&gt;OUTERMOST&lt;/code&gt; by calling &lt;code&gt;this-&amp;gt;outer_allocator()&lt;/code&gt;, and then calling the &lt;code&gt;outer_allocator()&lt;/code&gt; member function recursively on the result of this call until reaching an allocator that has no such member function.</source>
          <target state="translated">En primer lugar, recuperar el asignador m&amp;aacute;s externa &lt;code&gt;OUTERMOST&lt;/code&gt; llamando &lt;code&gt;this-&amp;gt;outer_allocator()&lt;/code&gt; , y luego llamar a la &lt;code&gt;outer_allocator()&lt;/code&gt; funci&amp;oacute;n miembro recursiva en el resultado de esta llamada hasta llegar a un asignador de que no tiene esa funci&amp;oacute;n miembro.</target>
        </trans-unit>
        <trans-unit id="b22ed5216bdf7ab4edb25ec8436348da2427fb87" translate="yes" xml:space="preserve">
          <source>First, saves the current floating-point environment to the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fegetenv&lt;/a&gt;&lt;/code&gt;), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Primero, guarda el entorno de punto flotante actual en el objeto se&amp;ntilde;alado por &lt;code&gt;envp&lt;/code&gt; (similar a &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fegetenv&lt;/a&gt;&lt;/code&gt; ), luego borra todos los indicadores de estado de punto flotante y luego instala el modo sin interrupciones: las futuras excepciones de punto flotante no interrumpir la ejecuci&amp;oacute;n (no atrapar&amp;aacute;), hasta que &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt; entorno de coma flotante .</target>
        </trans-unit>
        <trans-unit id="19ae2c760d73ee6a549348974c9ddff8cc5fef2c" translate="yes" xml:space="preserve">
          <source>First, set each element of the output range to the value &lt;code&gt;0x8b8b8b8b&lt;/code&gt;</source>
          <target state="translated">Primero, establezca cada elemento del rango de salida en el valor &lt;code&gt;0x8b8b8b8b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37c02899047a91960018379b0f4a7201e2a7714f" translate="yes" xml:space="preserve">
          <source>First, the argument-dependent lookup is not considered if the lookup set produced by usual &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; contains any of the following:</source>
          <target state="translated">Primero, la b&amp;uacute;squeda dependiente de argumentos no se considera si el conjunto de b&amp;uacute;squeda producido por usual &lt;a href=&quot;lookup&quot;&gt; b&amp;uacute;squeda no calificada&lt;/a&gt; contiene alguno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="71da67e0b30adfe6e4f96fe9e13991f6f8a033f3" translate="yes" xml:space="preserve">
          <source>Firstly, if this path has an &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension()&lt;/code&gt;&lt;/a&gt;, it is removed from the generic-format view of the pathname.</source>
          <target state="translated">En primer lugar, si este camino tiene un &lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension()&lt;/code&gt; &lt;/a&gt; , se elimina de la vista de formato gen&amp;eacute;rico del nombre de ruta.</target>
        </trans-unit>
        <trans-unit id="d24ff9bf0ed02a5411428beac3e4bd1d30fe9f46" translate="yes" xml:space="preserve">
          <source>Five &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;span&lt;/code&gt;.</source>
          <target state="translated">Se proporcionan cinco &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; por &lt;code&gt;span&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27e98ae5f197207336755cc33861b5d103faad58" translate="yes" xml:space="preserve">
          <source>Fixed width integer types</source>
          <target state="translated">Tipos enteros de ancho fijo</target>
        </trans-unit>
        <trans-unit id="a96f6d996f06dc7144585656dcc077cf300a6377" translate="yes" xml:space="preserve">
          <source>Fixed width integer types (since C++11)</source>
          <target state="translated">Tipos enteros de ancho fijo (desde C++11)</target>
        </trans-unit>
        <trans-unit id="0a6c931f357cf026414e375b77b04d8235b7334d" translate="yes" xml:space="preserve">
          <source>Flag type and operations</source>
          <target state="translated">Tipo de bandera y operaciones</target>
        </trans-unit>
        <trans-unit id="27cbb35a9b1b271932f7636ca4faaede088277a2" translate="yes" xml:space="preserve">
          <source>Flips bits, i.e. changes &lt;code&gt;true&lt;/code&gt; values to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; values to &lt;code&gt;true&lt;/code&gt;. Equivalent to a logical NOT operation on part or all of the bitset.</source>
          <target state="translated">Voltea bits, es decir, cambia &lt;code&gt;true&lt;/code&gt; valores verdaderos a &lt;code&gt;false&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; valores falsos a &lt;code&gt;true&lt;/code&gt; . Equivalente a una operaci&amp;oacute;n NOT l&amp;oacute;gica en parte o en todo el conjunto de bits.</target>
        </trans-unit>
        <trans-unit id="b5dfec7a1df7a1c20eb6ca15e9bee0c75b291919" translate="yes" xml:space="preserve">
          <source>Floating point literal defines a compile-time constant whose value is specified in the source file.</source>
          <target state="translated">El literal de punto flotante define una constante de tiempo de compilación cuyo valor se especifica en el archivo fuente.</target>
        </trans-unit>
        <trans-unit id="530b771e0a4d9da8f37e390916e11d1da9b65536" translate="yes" xml:space="preserve">
          <source>Floating point manipulation functions</source>
          <target state="translated">Funciones de manipulación de punto flotante</target>
        </trans-unit>
        <trans-unit id="4cdfaff55d21c2eb1c0a0dbeace3c9c4e378eda8" translate="yes" xml:space="preserve">
          <source>Floating point types</source>
          <target state="translated">Los tipos de punto flotante</target>
        </trans-unit>
        <trans-unit id="931a4d33f9a7670df77e53c7e39d2883c52b8c58" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned and *str_end is set to str.</source>
          <target state="translated">Valor de coma flotante correspondiente al contenido de &lt;code&gt;str&lt;/code&gt; en caso de &amp;eacute;xito. Si el valor convertido cae fuera del rango del tipo de retorno correspondiente, se produce un error de rango y &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; . Si no hay ning&amp;uacute;n cambio se realiza, &lt;code&gt;​0​&lt;/code&gt; se devuelve y * str_end se establece en str.</target>
        </trans-unit>
        <trans-unit id="5679c54758fee21d770fd6c545d0c43032628157" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">Valor de coma flotante correspondiente al contenido de &lt;code&gt;str&lt;/code&gt; en caso de &amp;eacute;xito. Si el valor convertido cae fuera del rango del tipo de retorno correspondiente, se produce un error de rango y se &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; . Si no hay ning&amp;uacute;n cambio se realiza, &lt;code&gt;​0​&lt;/code&gt; se devuelve.</target>
        </trans-unit>
        <trans-unit id="d2f57b6272c09794ad846fa25baa135845cf2031" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the &amp;mu; distribution parameter.</source>
          <target state="translated">Valor de coma flotante que identifica el par&amp;aacute;metro de distribuci&amp;oacute;n &amp;mu;.</target>
        </trans-unit>
        <trans-unit id="9a1cf11d8c926cc9f1bbac062621307bdc11199f" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the degrees of freedom of the distribution.</source>
          <target state="translated">Valor de punto flotante que identifica los grados de libertad de la distribución.</target>
        </trans-unit>
        <trans-unit id="a725365fc9cc7788cab748ff13281e3d748d0017" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the p distribution parameter.</source>
          <target state="translated">Valor de punto flotante que identifica el parámetro de distribución p.</target>
        </trans-unit>
        <trans-unit id="3bfd050a822b215062fc674739b968774ba30a01" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the rate of events per unit.</source>
          <target state="translated">Valor en punto flotante que identifica la tasa de eventos por unidad.</target>
        </trans-unit>
        <trans-unit id="5c65e500905d168962e036e5e1c8cfd585b5a35a" translate="yes" xml:space="preserve">
          <source>Floating point value in range [0, 1).</source>
          <target state="translated">Valor de punto flotante en el rango [0,1).</target>
        </trans-unit>
        <trans-unit id="a4edd9f5da9c5bff6fa7351be1698e5f17713a8e" translate="yes" xml:space="preserve">
          <source>Floating&amp;ndash;integral conversions</source>
          <target state="translated">Conversiones flotantes integrales</target>
        </trans-unit>
        <trans-unit id="fe4d2e99025a6ead51e9b2e632c32efaa3c94a25" translate="yes" xml:space="preserve">
          <source>Floating-point contraction</source>
          <target state="translated">Contracción en punto flotante</target>
        </trans-unit>
        <trans-unit id="a694704378ed350bc958fb519c8315b5d52a02b7" translate="yes" xml:space="preserve">
          <source>Floating-point conversions</source>
          <target state="translated">Conversiones en punto flotante</target>
        </trans-unit>
        <trans-unit id="037c72279324a50181c71503f07e7e0083f1c23d" translate="yes" xml:space="preserve">
          <source>Floating-point environment</source>
          <target state="translated">Entorno de punto flotante</target>
        </trans-unit>
        <trans-unit id="fc13961bdda58d06692a8ad8f8156b2841512415" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may have greater range and precision than indicated by their types, see &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. Floating-point expressions may also be</source>
          <target state="translated">Las expresiones de punto flotante pueden tener mayor rango y precisi&amp;oacute;n que la indicada por sus tipos, consulte &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; . Las expresiones de coma flotante tambi&amp;eacute;n pueden ser</target>
        </trans-unit>
        <trans-unit id="0e05b4ea4725d83345dcb31354835a769615b781" translate="yes" xml:space="preserve">
          <source>Floating-point promotion</source>
          <target state="translated">Promoción en punto flotante</target>
        </trans-unit>
        <trans-unit id="f74d231baa71e2a641e3234ad91f55a94e0aa7a0" translate="yes" xml:space="preserve">
          <source>Floating-point types may support &lt;a href=&quot;../types/numeric_limits&quot;&gt;special values&lt;/a&gt;:</source>
          <target state="translated">Los tipos de punto flotante pueden admitir &lt;a href=&quot;../types/numeric_limits&quot;&gt;valores especiales&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a26e00b84e77b40bea4bb511f8f60ed076daa97b" translate="yes" xml:space="preserve">
          <source>Flowing off the end of a value-returning function (except &lt;code&gt;main&lt;/code&gt;) without a return statement is undefined behavior.</source>
          <target state="translated">Saliendo del final de una funci&amp;oacute;n de retorno de valor (excepto &lt;code&gt;main&lt;/code&gt; ) sin una declaraci&amp;oacute;n de retorno es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="6666b9fcba2b772c274346c92162b6c1a3611ada" translate="yes" xml:space="preserve">
          <source>Flushes the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.flush()&lt;/code&gt;.</source>
          <target state="translated">Vac&amp;iacute;a la secuencia de salida &lt;code&gt;os&lt;/code&gt; como si llamara &lt;code&gt;os.flush()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cdb990f130f6549318c7c3b84780625f76de3f4" translate="yes" xml:space="preserve">
          <source>Flushes the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.flush()&lt;/code&gt;. Then, if &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, calls &lt;code&gt;buf.emit()&lt;/code&gt;.</source>
          <target state="translated">Vac&amp;iacute;a la secuencia de salida &lt;code&gt;os&lt;/code&gt; como si llamara &lt;code&gt;os.flush()&lt;/code&gt; . Entonces, si &lt;code&gt;os.rdbuf()&lt;/code&gt; realidad apunta a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt; &lt;code&gt;buf&lt;/code&gt; , llama a &lt;code&gt;buf.emit()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4727f15c3dadc6abc3267b67039a85b366a9aeb" translate="yes" xml:space="preserve">
          <source>Flushing is performed in the destructor of the &lt;code&gt;&lt;a href=&quot;../basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; object, which calls &lt;code&gt;str.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; if &lt;code&gt;str.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt; == true&lt;/code&gt;.</source>
          <target state="translated">El vaciado se realiza en el destructor del objeto &lt;code&gt;&lt;a href=&quot;../basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; , que llama a &lt;code&gt;str.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; if &lt;code&gt;str.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt; == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd2e024a054d8c1876c1f1a73eab175647867cec" translate="yes" xml:space="preserve">
          <source>Fold expressions</source>
          <target state="translated">Expresiones de pliegues</target>
        </trans-unit>
        <trans-unit id="820f688950b36fa22a06159885b2b0b589f17953" translate="yes" xml:space="preserve">
          <source>Fold-expressions</source>
          <target state="translated">Fold-expressions</target>
        </trans-unit>
        <trans-unit id="73ea87451f9d5e42c6d3450b515bcb3f98250b83" translate="yes" xml:space="preserve">
          <source>Follow rather than skip directory symlinks.</source>
          <target state="translated">Seguir en lugar de saltarse los enlaces simbólicos del directorio.</target>
        </trans-unit>
        <trans-unit id="c9eac869d3c658b081e1a95ca062116b32f0aaa4" translate="yes" xml:space="preserve">
          <source>Follow symlinks (default behavior)</source>
          <target state="translated">Seguir los enlaces simbólicos (comportamiento predeterminado)</target>
        </trans-unit>
        <trans-unit id="9d728e94fbab96a42d3b4d9a6cb222f5e938822e" translate="yes" xml:space="preserve">
          <source>Following exposition-only concepts are used for several types, but they are not parts of the interface of standard library.</source>
          <target state="translated">Los siguientes conceptos de sólo exposición se utilizan para varios tipos,pero no forman parte de la interfaz de la biblioteca estándar.</target>
        </trans-unit>
        <trans-unit id="6f40e40d82fd8846da49808b0b708490ce0379e1" translate="yes" xml:space="preserve">
          <source>Following member functions are conditionally different from corresponding member functions of &lt;code&gt;&lt;a href=&quot;../utility/optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Las siguientes funciones miembro son condicionalmente diferentes de las funciones miembro correspondientes de &lt;code&gt;&lt;a href=&quot;../utility/optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="2eedcffa258b92b2d623f330307d6610480c73b1" translate="yes" xml:space="preserve">
          <source>For (1), &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">Para (1), &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los &lt;code&gt;T_i&lt;/code&gt; en los &lt;code&gt;Types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27e932e63be3980babb2b5c3e1834eb9ece2f5cb" translate="yes" xml:space="preserve">
          <source>For (1),&lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para (1), &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cce1fc39ab817dad0417c749a97b121fa9da8698" translate="yes" xml:space="preserve">
          <source>For (1-3), if the result would be outside the range [0, 255], the actual stored value is unspecified.</source>
          <target state="translated">En el caso de (1-3),si el resultado estuviera fuera del rango [0,255],el valor real almacenado no se especifica.</target>
        </trans-unit>
        <trans-unit id="80750dcb6fca71c81371e8509ae0e5a32ea184f9" translate="yes" xml:space="preserve">
          <source>For (2), &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">Para (2), &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los &lt;code&gt;T_i&lt;/code&gt; en los &lt;code&gt;Types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf60873df305a2582da8245d9a95bc5dabb1f1c1" translate="yes" xml:space="preserve">
          <source>For (2),&lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para (2), &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e266ee47c94d97b82af99ef255fd0f260a99d2c" translate="yes" xml:space="preserve">
          <source>For (3), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, const U_i&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all corresponding pairs of types &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt; and &lt;code&gt;U_i&lt;/code&gt; in &lt;code&gt;UTypes&lt;/code&gt;.</source>
          <target state="translated">Para (3), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, const U_i&amp;amp;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los pares correspondientes de tipos &lt;code&gt;T_i&lt;/code&gt; en &lt;code&gt;Types&lt;/code&gt; y &lt;code&gt;U_i&lt;/code&gt; en &lt;code&gt;UTypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="235c0ae5251a55b5cc4853b6e31b390a6d489d01" translate="yes" xml:space="preserve">
          <source>For (3),&lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para (3), &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; ambos son &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c23beb9ab1e1686d723073f239e4dd5ad833ba8" translate="yes" xml:space="preserve">
          <source>For (4), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, U_i&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all corresponding pairs of types &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt; and &lt;code&gt;U_i&lt;/code&gt; in &lt;code&gt;UTypes&lt;/code&gt;.</source>
          <target state="translated">Para (4), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, U_i&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los pares correspondientes de tipos &lt;code&gt;T_i&lt;/code&gt; en &lt;code&gt;Types&lt;/code&gt; y &lt;code&gt;U_i&lt;/code&gt; en &lt;code&gt;UTypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d612fce9fe1d1b17e3a906128095373ba91170e6" translate="yes" xml:space="preserve">
          <source>For (4),&lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para (4), &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dc7376755e98b71c2080e8a531379170a9f0d46" translate="yes" xml:space="preserve">
          <source>For (5), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, where &lt;code&gt;T_0&lt;/code&gt; and &lt;code&gt;T_1&lt;/code&gt; are the two types constituting &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">Para (5), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; , donde &lt;code&gt;T_0&lt;/code&gt; y &lt;code&gt;T_1&lt;/code&gt; son los dos tipos que constituyen &lt;code&gt;Types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94214e5075f274a6f5fa7b33c9435afe45df0332" translate="yes" xml:space="preserve">
          <source>For (6), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, where &lt;code&gt;T_0&lt;/code&gt; and &lt;code&gt;T_1&lt;/code&gt; are the two types constituting &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">Para (6), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; , donde &lt;code&gt;T_0&lt;/code&gt; y &lt;code&gt;T_1&lt;/code&gt; son los dos tipos que constituyen los &lt;code&gt;Types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83856baa7fbad81b10e160970bde088c89421d40" translate="yes" xml:space="preserve">
          <source>For 0&amp;le;arg&amp;le;1,</source>
          <target state="translated">Para 0&amp;le;arg&amp;le;1,</target>
        </trans-unit>
        <trans-unit id="3bd6dc6d78016b2a3f1c8c074db727a1bd8e2c50" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types, value representation is a part of the object representation, which means that copying the bytes occupied by the object in the storage is sufficient to produce another object with the same value (except if the value is a</source>
          <target state="translated">Para los tipos &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , la representaci&amp;oacute;n del valor es una parte de la representaci&amp;oacute;n del objeto, lo que significa que copiar los bytes ocupados por el objeto en el almacenamiento es suficiente para producir otro objeto con el mismo valor (excepto si el valor es un</target>
        </trans-unit>
        <trans-unit id="a6d068410c3d5d5e1e66f214a4705f1da0744b99" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">Para el ciclo &lt;a href=&quot;do&quot;&gt;do-&lt;/a&gt; while, act&amp;uacute;a como:</target>
        </trans-unit>
        <trans-unit id="192dfceddbf339e300daed630beff6523e185814" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; and &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">Para &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; y &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt; loop, act&amp;uacute;a como:</target>
        </trans-unit>
        <trans-unit id="25d4ebe9fb8814a98da8afb721d4a6bdeed00a0f" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; &amp;gt; and &amp;ge; respectively</source>
          <target state="translated">Para &lt;a href=&quot;operator_comparison&quot;&gt;operadores relacionales&lt;/a&gt; &amp;gt; y &amp;ge; respectivamente</target>
        </trans-unit>
        <trans-unit id="c82d883f6eaf9d2b9ddb7fd8e6adaa4e2930e681" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; &amp;lt; and &amp;le; respectively</source>
          <target state="translated">Para &lt;a href=&quot;operator_comparison&quot;&gt;operadores relacionales&lt;/a&gt; &amp;lt;y &amp;le; respectivamente</target>
        </trans-unit>
        <trans-unit id="80184e736b13dd44e9e03f7f4a2465c93e2f10ce" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; = and &amp;ne; respectively</source>
          <target state="translated">Para &lt;a href=&quot;operator_comparison&quot;&gt;operadores relacionales&lt;/a&gt; = y &amp;ne; respectivamente</target>
        </trans-unit>
        <trans-unit id="67db5ac16c817d0aad978db1daa9912c166fac6a" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, it acts as.</source>
          <target state="translated">Para &lt;a href=&quot;while&quot;&gt;mientras&lt;/a&gt; bucle, act&amp;uacute;a como.</target>
        </trans-unit>
        <trans-unit id="2ceb12570320e8236ce37933edca4d8d71e4edce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio&quot;&gt;std::micro&lt;/a&gt;&lt;/code&gt;, if the character &amp;micro; (U+00B5) cannot be represented in the encoding used for &lt;code&gt;CharT&lt;/code&gt;, the suffix &quot;&lt;code&gt;us&lt;/code&gt;&quot; is used instead.</source>
          <target state="translated">Para &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio&quot;&gt;std::micro&lt;/a&gt;&lt;/code&gt; , si el car&amp;aacute;cter &amp;micro; (U + 00B5) no se puede representar en la codificaci&amp;oacute;n utilizada para &lt;code&gt;CharT&lt;/code&gt; , se utiliza el sufijo &quot; &lt;code&gt;us&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="decd50a2a6c24904b14b0159d4b4ee28edc12dd8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, the elements are bytes (objects of type char), which are not the same as characters if a multibyte encoding such as UTF-8 is used.</source>
          <target state="translated">Para &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; , los elementos son bytes (objetos de tipo char), que no son lo mismo que caracteres si se usa una codificaci&amp;oacute;n multibyte como UTF-8.</target>
        </trans-unit>
        <trans-unit id="4fc81475176c004bf7dd4b13445be6b3d996668a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; the value type is the same as the key type and both &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; are constant iterators. For &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; the value type is &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Para &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; el tipo de valor es el mismo que el tipo de clave y ambos &lt;code&gt;iterator&lt;/code&gt; y &lt;code&gt;const_iterator&lt;/code&gt; son iteradores constantes. Para &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; el tipo de valor es &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d3533c7dfac4c0a2f11001f27ce7038422be45e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;T*&lt;/code&gt; types, the result may be an undefined address, but the operation otherwise has no undefined behavior. The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is not an object type.</source>
          <target state="translated">Para &lt;code&gt;T*&lt;/code&gt; tipos T * , el resultado puede ser una direcci&amp;oacute;n indefinida, pero la operaci&amp;oacute;n no tiene un comportamiento indefinido. El programa est&amp;aacute; mal formado si &lt;code&gt;T&lt;/code&gt; no es un tipo de objeto.</target>
        </trans-unit>
        <trans-unit id="6d8b259c841d7fe56fd4cbc44dbede3d4a2f5d45" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;T*&lt;/code&gt; types, the result may be an undefined address, but the operations otherwise have no undefined behavior. The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is not an object type.</source>
          <target state="translated">Para &lt;code&gt;T*&lt;/code&gt; tipos T * , el resultado puede ser una direcci&amp;oacute;n indefinida, pero las operaciones no tienen un comportamiento indefinido. El programa est&amp;aacute; mal formado si &lt;code&gt;T&lt;/code&gt; no es un tipo de objeto.</target>
        </trans-unit>
        <trans-unit id="fdab33fa5bc42221e341bfb5aa446019046bda10" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;allocate_shared&lt;/code&gt;, the object (or the individual array elements for (2-5))(since C++20) are destroyed via the expression &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::destroy(a, p)&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;a&lt;/code&gt; is a copy of the allocator passed to &lt;code&gt;allocate_shared&lt;/code&gt;, rebound to the type of the object being destroyed.</source>
          <target state="translated">Para &lt;code&gt;allocate_shared&lt;/code&gt; , el objeto (o los elementos de matriz individuales para (2-5)) (ya que C ++ 20) se destruyen mediante la expresi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::destroy(a, p)&lt;/code&gt; , donde &lt;code&gt;p&lt;/code&gt; es un puntero al objeto y &lt;code&gt;a&lt;/code&gt; es una copia del asignador pasado a &lt;code&gt;allocate_shared&lt;/code&gt; , rebote al tipo del objeto que se destruye.</target>
        </trans-unit>
        <trans-unit id="ffeded1df965bfced36bed8a9a11d97603f70744" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;allocate_shared_default_init&lt;/code&gt;, the object (or individual elements if &lt;code&gt;T&lt;/code&gt; is an array type) will be destroyed by &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;X&lt;/code&gt; is its type.</source>
          <target state="translated">Para &lt;code&gt;allocate_shared_default_init&lt;/code&gt; , el objeto (o elementos individuales si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz) ser&amp;aacute; destruido por &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt; , donde &lt;code&gt;p&lt;/code&gt; es un puntero al objeto y &lt;code&gt;X&lt;/code&gt; es su tipo.</target>
        </trans-unit>
        <trans-unit id="eaf9872d7fc84f0c3657f05544061163d1795a7f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;k = 0,..., m-1&lt;/code&gt;</source>
          <target state="translated">Para &lt;code&gt;k = 0,..., m-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a84133a6d81bd30988c564a8a6cf37a9783a4cf" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;k = m,..., m+n-1&lt;/code&gt;,</source>
          <target state="translated">Para &lt;code&gt;k = m,..., m+n-1&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="3702c14d2d2a72e5ae19407c373383886d03512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;operator,&lt;/code&gt;, the unary &lt;code&gt;operator&amp;amp;&lt;/code&gt;, and &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, if there are no viable functions (see below) in the set of candidate functions, then the operator is reinterpreted as a built-in.</source>
          <target state="translated">Para el &lt;code&gt;operator,&lt;/code&gt; el &lt;code&gt;operator&amp;amp;&lt;/code&gt; unario &amp;amp; , y &lt;code&gt;operator-&amp;gt;&lt;/code&gt; , si no hay funciones viables (ver m&amp;aacute;s abajo) en el conjunto de funciones candidatas, entonces el operador se reinterpreta como integrado.</target>
        </trans-unit>
        <trans-unit id="0d394b44570e5e62b408fa0499880cd8eb0cf013" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::binary_search&lt;/code&gt; to succeed, the range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">Para que &lt;code&gt;std::binary_search&lt;/code&gt; &amp;eacute;xito, el rango &lt;code&gt;[first, last)&lt;/code&gt; debe estar al menos parcialmente ordenado con respecto al &lt;code&gt;value&lt;/code&gt; , es decir, debe cumplir con todos los siguientes requisitos:</target>
        </trans-unit>
        <trans-unit id="82aaf8ae9515fcaa10aa37778070bfaa5e42e07b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::lrint&lt;/code&gt; and &lt;code&gt;std::llrint&lt;/code&gt; functions:</source>
          <target state="translated">Para las &lt;code&gt;std::lrint&lt;/code&gt; y &lt;code&gt;std::llrint&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="386ec7b95ea37fdce144fa4084a418bcda9d46f7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::lround&lt;/code&gt; and &lt;code&gt;std::llround&lt;/code&gt; functions:</source>
          <target state="translated">Para las &lt;code&gt;std::lround&lt;/code&gt; y &lt;code&gt;std::llround&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="93056bf6dac8be93c20bc17806b06200f88a2398" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined move assignment operator copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Para &lt;code&gt;union&lt;/code&gt; tipos de uni&amp;oacute;n , el operador de asignaci&amp;oacute;n de movimiento definido impl&amp;iacute;citamente copia la representaci&amp;oacute;n del objeto (como por &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ab727ef011ac32b32b71004213c9062e03c40ca6" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow happens if &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; or if &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt;.</source>
          <target state="translated">Para el tipo &lt;code&gt;double&lt;/code&gt; compatible con IEEE , el desbordamiento ocurre si &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; o si &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="308485408ad23c9a6a581efd5af8112d70a5819e" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg, and underflow is guaranteed if arg &amp;lt; -708.4.</source>
          <target state="translated">Para el tipo &lt;code&gt;double&lt;/code&gt; compatible con IEEE , el desbordamiento est&amp;aacute; garantizado si 709.8 &amp;lt;arg, y el desbordamiento est&amp;aacute; garantizado si arg &amp;lt;-708.4.</target>
        </trans-unit>
        <trans-unit id="9ebd607b970e88332eac8b1adf8c8066c0dd8e42" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg.</source>
          <target state="translated">Para el tipo &lt;code&gt;double&lt;/code&gt; compatible con IEEE , se garantiza el desbordamiento si 709.8 &amp;lt;arg.</target>
        </trans-unit>
        <trans-unit id="7abd0d73ae7ceb8182e2cfda7bc62d8a3837d067" translate="yes" xml:space="preserve">
          <source>For POSIX-based operating systems, &lt;code&gt;std::filesystem::absolute(p)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;current_path&quot;&gt;std::filesystem::current_path&lt;/a&gt;() / p&lt;/code&gt;.</source>
          <target state="translated">Para los sistemas operativos basados ​​en POSIX, &lt;code&gt;std::filesystem::absolute(p)&lt;/code&gt; es equivalente a &lt;code&gt;&lt;a href=&quot;current_path&quot;&gt;std::filesystem::current_path&lt;/a&gt;() / p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="119d7cdec7ea51fa50da00d5d9417b5384f14791" translate="yes" xml:space="preserve">
          <source>For Windows, &lt;code&gt;absolute&lt;/code&gt; may be implemented as a call to &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx&quot;&gt;GetFullPathNameW&lt;/a&gt;.</source>
          <target state="translated">Para Windows, &lt;code&gt;absolute&lt;/code&gt; se puede implementar como una llamada a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx&quot;&gt;GetFullPathNameW&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e888a145f1992272e7918f8fc284c6a7e06ad4" translate="yes" xml:space="preserve">
          <source>For a</source>
          <target state="translated">Para un</target>
        </trans-unit>
        <trans-unit id="ca411b7633697d58c29db0495dbecc36219406c0" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;dependent_name&quot;&gt;non-dependent name&lt;/a&gt; used in a template definition, unqualified name lookup takes place when the template definition is examined. The binding to the declarations made at that point is not affected by declarations visible at the point of instantiation. For a &lt;a href=&quot;dependent_name&quot;&gt;dependent name&lt;/a&gt; used in a template definition, the lookup is postponed until the template arguments are known, at which time &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; examines function declarations with external linkage(until C++11) that are visible from the template definition context as well as in the template instantiation context, while non-ADL lookup only examines function declarations with external linkage(until C++11) that are visible from the template definition context (in other words, adding a new function declaration after template definition does not make it visible except via ADL). The behavior is undefined if there is a better match with external linkage in the namespaces examined by the ADL lookup, declared in some other translation unit, or if the lookup would have been ambiguous if those translation units were examined. In any case, if a base class depends on a template parameter, its scope is not examined by unqualified name lookup (neither at the point of definition nor at the point of instantiation).</source>
          <target state="translated">Para un &lt;a href=&quot;dependent_name&quot;&gt;nombre no dependiente&lt;/a&gt; utilizado en una definici&amp;oacute;n de plantilla, la b&amp;uacute;squeda de nombre no calificado tiene lugar cuando se examina la definici&amp;oacute;n de plantilla. La vinculaci&amp;oacute;n a las declaraciones realizadas en ese punto no se ve afectada por las declaraciones visibles en el punto de instanciaci&amp;oacute;n. Para un &lt;a href=&quot;dependent_name&quot;&gt;nombre dependiente&lt;/a&gt; utilizado en una definici&amp;oacute;n de plantilla, la b&amp;uacute;squeda se pospone hasta que se conocen los argumentos de la plantilla, momento en el que&lt;a href=&quot;adl&quot;&gt; ADL&lt;/a&gt;examina las declaraciones de funci&amp;oacute;n con enlace externo (hasta C ++ 11) que son visibles desde el contexto de definici&amp;oacute;n de plantilla, as&amp;iacute; como en el contexto de instanciaci&amp;oacute;n de plantilla, mientras que la b&amp;uacute;squeda sin ADL solo examina las declaraciones de funci&amp;oacute;n con enlace externo (hasta C ++ 11) que son visibles desde el contexto de definici&amp;oacute;n de plantilla (en otras palabras, agregar una nueva declaraci&amp;oacute;n de funci&amp;oacute;n despu&amp;eacute;s de que la definici&amp;oacute;n de plantilla no lo haga visible excepto a trav&amp;eacute;s de ADL). El comportamiento no est&amp;aacute; definido si existe una mejor coincidencia con el enlace externo en los espacios de nombres examinados por la b&amp;uacute;squeda ADL, declarados en alguna otra unidad de traducci&amp;oacute;n, o si la b&amp;uacute;squeda hubiera sido ambigua si esas unidades de traducci&amp;oacute;n fueran examinadas. En cualquier caso, si una clase base depende de un par&amp;aacute;metro de plantilla,su alcance no se examina mediante la b&amp;uacute;squeda de nombres no calificados (ni en el punto de definici&amp;oacute;n ni en el punto de instanciaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="883759e78914d4b04a2fe3535a894bcffbf8a177" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; of a non-template class, the default arguments are allowed on the out-of-class definition, and are combined with the default arguments provided by the declaration inside the class body. If these out-of-class defaults would turn a member function into a default, copy, or move constructor the program is ill-formed. For member functions of class templates, all defaults must be provided in the initial declaration of the member function.</source>
          <target state="translated">Para una &lt;a href=&quot;member_functions&quot;&gt;funci&amp;oacute;n miembro&lt;/a&gt; de una clase sin plantilla, los argumentos predeterminados est&amp;aacute;n permitidos en la definici&amp;oacute;n fuera de clase y se combinan con los argumentos predeterminados proporcionados por la declaraci&amp;oacute;n dentro del cuerpo de la clase. Si estos valores predeterminados fuera de clase convertir&amp;iacute;an una funci&amp;oacute;n miembro en un constructor predeterminado, copiar o mover, el programa est&amp;aacute; mal formado. Para las funciones miembro de las plantillas de clase, todos los valores predeterminados se deben proporcionar en la declaraci&amp;oacute;n inicial de la funci&amp;oacute;n miembro.</target>
        </trans-unit>
        <trans-unit id="02ea56864a8e8c007867dec05809cd5a9f98b81f" translate="yes" xml:space="preserve">
          <source>For a container &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.front()&lt;/code&gt; is equivalent to &lt;code&gt;*c.begin()&lt;/code&gt;.</source>
          <target state="translated">Para un contenedor &lt;code&gt;c&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;c.front()&lt;/code&gt; es equivalente a &lt;code&gt;*c.begin()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c061e2be7835c9d94a21ab627e460ae3f5da4b8d" translate="yes" xml:space="preserve">
          <source>For a container &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;return c.back();&lt;/code&gt; is equivalent to &lt;code&gt;{ auto tmp = c.end(); --tmp; return *tmp; }&lt;/code&gt;</source>
          <target state="translated">Para un contenedor &lt;code&gt;c&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;return c.back();&lt;/code&gt; es equivalente a &lt;code&gt;{ auto tmp = c.end(); --tmp; return *tmp; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a12f2ebb81a91e44d54c155d3b7a470c7c32d87a" translate="yes" xml:space="preserve">
          <source>For a given &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt; p&lt;/code&gt;, this specialization ensures that.</source>
          <target state="translated">Para un determinado &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt; p&lt;/code&gt; , esta especializaci&amp;oacute;n asegura eso.</target>
        </trans-unit>
        <trans-unit id="61761986c4556882eacd9227f774252dea0c81ea" translate="yes" xml:space="preserve">
          <source>For a name used anywhere in &lt;a href=&quot;class&quot;&gt;class definition&lt;/a&gt;, except inside a member function body, a default argument of a member function, exception specification of a member function, default member initializer, &lt;a href=&quot;attributes/contract&quot;&gt;contract condition&lt;/a&gt;(since C++20), or inside a nested class definition (including names of the bases from which the nested class is derived), the following scopes are searched:</source>
          <target state="translated">Para un nombre utilizado en cualquier lugar de &lt;a href=&quot;class&quot;&gt;la definici&amp;oacute;n de clase&lt;/a&gt; , excepto dentro de un cuerpo de funci&amp;oacute;n miembro, un argumento predeterminado de una funci&amp;oacute;n miembro, especificaci&amp;oacute;n de excepci&amp;oacute;n de una funci&amp;oacute;n miembro, inicializador de miembro predeterminado, &lt;a href=&quot;attributes/contract&quot;&gt;condici&amp;oacute;n de contrato&lt;/a&gt; (desde C ++ 20) o dentro de una clase anidada definici&amp;oacute;n (incluidos los nombres de las bases de las que se deriva la clase anidada), se buscan los siguientes &amp;aacute;mbitos:</target>
        </trans-unit>
        <trans-unit id="a684765457eef405a769182256e4ade4f401bc30" translate="yes" xml:space="preserve">
          <source>For a name used in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt; in a function declaration, or name used in the expression part of a &lt;a href=&quot;constructor&quot;&gt;member-initializer&lt;/a&gt; of a constructor, the function parameter names are found first, before the enclosing block, class, or namespace scopes are examined:</source>
          <target state="translated">Para un nombre utilizado en un &lt;a href=&quot;default_arguments&quot;&gt;argumento predeterminado&lt;/a&gt; en una declaraci&amp;oacute;n de funci&amp;oacute;n, o un nombre utilizado en la parte de expresi&amp;oacute;n de un &lt;a href=&quot;constructor&quot;&gt;inicializador&lt;/a&gt; de miembro de un constructor, los nombres de los par&amp;aacute;metros de la funci&amp;oacute;n se encuentran primero, antes de examinar los &amp;aacute;mbitos de bloque, clase o espacio de nombres adjuntos:</target>
        </trans-unit>
        <trans-unit id="6ae66449c2d64e5e5aa0c8dcee38ad7d218d4918" translate="yes" xml:space="preserve">
          <source>For a name used in a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function definition inside the body of the class that is granting friendship, unqualified name lookup proceeds the same way as for a member function. For a name used in a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function which is defined outside the body of a class, unqualified name lookup proceeds the same way as for a function in a namespace.</source>
          <target state="translated">Para un nombre usado en una definici&amp;oacute;n de funci&amp;oacute;n de &lt;a href=&quot;friend&quot;&gt;amigo&lt;/a&gt; dentro del cuerpo de la clase que est&amp;aacute; otorgando amistad, la b&amp;uacute;squeda de nombre no calificado procede de la misma manera que para una funci&amp;oacute;n de miembro. Para un nombre utilizado en una funci&amp;oacute;n &lt;a href=&quot;friend&quot;&gt;amiga&lt;/a&gt; que se define fuera del cuerpo de una clase, la b&amp;uacute;squeda de nombres no calificados se realiza de la misma manera que para una funci&amp;oacute;n en un espacio de nombres.</target>
        </trans-unit>
        <trans-unit id="f880effac86bc82db2f16b2948bd47f4311ada8a" translate="yes" xml:space="preserve">
          <source>For a name used in a user-declared namespace outside of any function or class, this namespace is searched before the use of the name, then the namespace enclosing this namespace before the declaration of this namespace, etc until the global namespace is reached.</source>
          <target state="translated">En el caso de un nombre utilizado en un espacio de nombres declarado por el usuario fuera de cualquier función o clase,se busca en este espacio de nombres antes de utilizar el nombre,luego en el espacio de nombres que incluye este espacio de nombres antes de la declaración de este espacio de nombres,etc.hasta llegar al espacio de nombres global.</target>
        </trans-unit>
        <trans-unit id="d01e0277c975bcb293141e811447dfa3ec140823" translate="yes" xml:space="preserve">
          <source>For a name used in global (top-level namespace) scope, outside of any function, class, or user-declared namespace, the global scope before the use of the name is examined:</source>
          <target state="translated">En el caso de un nombre utilizado en el ámbito global (espacio de nombres de nivel superior),fuera de cualquier función,clase o espacio de nombres declarado por el usuario,se examina el ámbito global antes del uso del nombre:</target>
        </trans-unit>
        <trans-unit id="6751cf91d41edea8f420573f4bb5cfa36ba1c19a" translate="yes" xml:space="preserve">
          <source>For a name used in the catch-clause of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, lookup proceeds as if for a name used in the very beginning of the outermost block of the function body (in particular, function parameters are visible, but names declared in that outermost block are not).</source>
          <target state="translated">Para un nombre usado en la cl&amp;aacute;usula catch de un &lt;a href=&quot;function-try-block&quot;&gt;bloque de prueba de funci&amp;oacute;n&lt;/a&gt; , la b&amp;uacute;squeda contin&amp;uacute;a como si se tratara de un nombre usado al comienzo del bloque m&amp;aacute;s externo del cuerpo de la funci&amp;oacute;n (en particular, los par&amp;aacute;metros de la funci&amp;oacute;n son visibles, pero los nombres declarados en ese bloque m&amp;aacute;s externo no lo es).</target>
        </trans-unit>
        <trans-unit id="0ecffe6eebcdaa6e0a2a4a2d57d191d6b1fc5d6c" translate="yes" xml:space="preserve">
          <source>For a name used in the declarator of a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function declaration that friends a member function from another class, if the name isn't a part of any template argument, the unqualified lookup first examines the entire scope of the member function's class. If not found in that scope (or if the name is a part of a template argument), the lookup continues as if for a member function of the class that is granting friendship.</source>
          <target state="translated">Para un nombre usado en el declarador de una declaraci&amp;oacute;n de funci&amp;oacute;n de &lt;a href=&quot;friend&quot;&gt;amigo&lt;/a&gt; que hace amigos de una funci&amp;oacute;n miembro de otra clase, si el nombre no es parte de ning&amp;uacute;n argumento de plantilla, la b&amp;uacute;squeda no calificada primero examina el alcance completo de la clase de la funci&amp;oacute;n miembro. Si no se encuentra en ese &amp;aacute;mbito (o si el nombre es parte de un argumento de plantilla), la b&amp;uacute;squeda contin&amp;uacute;a como si se tratara de una funci&amp;oacute;n miembro de la clase que est&amp;aacute; otorgando amistad.</target>
        </trans-unit>
        <trans-unit id="d95608e8a2ef528dbac2bab8b35c1d8f3a28d62b" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a &lt;a href=&quot;static&quot;&gt;static data member&lt;/a&gt;, lookup proceeds the same way as for a name used in the definition of a member function.</source>
          <target state="translated">Para un nombre utilizado en la definici&amp;oacute;n de un &lt;a href=&quot;static&quot;&gt;miembro de datos est&amp;aacute;ticos&lt;/a&gt; , la b&amp;uacute;squeda se realiza de la misma manera que para un nombre utilizado en la definici&amp;oacute;n de una funci&amp;oacute;n miembro.</target>
        </trans-unit>
        <trans-unit id="f034307944cf4601fdfc2f8a86c32703ec89cf55" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a function, either in its body or as part of default argument, where the function is a member of user-declared or global namespace, the block in which the name is used is searched before the use of the name, then the enclosing block is searched before the start of that block, etc, until reaching the block that is the function body. Then the namespace in which the function is declared is searched until the definition (not necessarily the declaration) of the function that uses the name, then the enclosing namespaces, etc.</source>
          <target state="translated">En el caso de un nombre utilizado en la definición de una función,ya sea en su cuerpo o como parte del argumento por defecto,cuando la función es miembro de un espacio de nombres declarado por el usuario o global,se busca el bloque en el que se utiliza el nombre antes de utilizarlo,luego se busca el bloque que lo encierra antes del comienzo de ese bloque,etc.,hasta llegar al bloque que es el cuerpo de la función.Luego se busca el espacio de nombres en el que se declara la función hasta la definición (no necesariamente la declaración)de la función que utiliza el nombre,luego los espacios de nombres adjuntos,etc.</target>
        </trans-unit>
        <trans-unit id="e69fc9e6436e85bd5e71b5f6fffe00b9251f55e4" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a namespace-member variable outside the namespace, lookup proceeds the same way as for a name used inside the namespace:</source>
          <target state="translated">En el caso de un nombre utilizado en la definición de una variable de miembro del espacio de nombres fuera del espacio de nombres,la búsqueda procede de la misma manera que en el caso de un nombre utilizado dentro del espacio de nombres:</target>
        </trans-unit>
        <trans-unit id="8362e87a521c085b7be1055bd62a4345efa29ea0" translate="yes" xml:space="preserve">
          <source>For a name used in the initializer part of the &lt;a href=&quot;enum&quot;&gt;enumerator declaration&lt;/a&gt;, previously declared enumerators in the same enumeration are found first, before the unqualified name lookup proceeds to examine the enclosing block, class, or namespace scope.</source>
          <target state="translated">Para un nombre utilizado en la parte inicializadora de la &lt;a href=&quot;enum&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; del enumerador , los enumeradores declarados previamente en la misma enumeraci&amp;oacute;n se encuentran primero, antes de que la b&amp;uacute;squeda de nombre no calificado proceda a examinar el bloque, la clase o el alcance del espacio de nombres adjunto.</target>
        </trans-unit>
        <trans-unit id="6979bced06285133967c5c4b103d3e0247545465" translate="yes" xml:space="preserve">
          <source>For a name used inside a member function body, a default argument of a member function, an exception specification of a member function, a default member initializer, a &lt;a href=&quot;attributes/contract&quot;&gt;contract condition&lt;/a&gt; of a member function(since C++20), or a nested class definition (including names of the bases from which the nested class is derived), the scopes searched are the same as in &lt;a href=&quot;unqualified_lookup#Class_definition&quot;&gt;class definition&lt;/a&gt;, except that the entire scope of the class is considered, not just the part prior to the declaration that uses the name. For nested classes the entire body of the enclosing class is searched.</source>
          <target state="translated">Para un nombre utilizado dentro del cuerpo de una funci&amp;oacute;n miembro, un argumento predeterminado de una funci&amp;oacute;n miembro, una especificaci&amp;oacute;n de excepci&amp;oacute;n de una funci&amp;oacute;n miembro, un inicializador de miembro predeterminado, una &lt;a href=&quot;attributes/contract&quot;&gt;condici&amp;oacute;n&lt;/a&gt; de contrato de una funci&amp;oacute;n miembro (desde C ++ 20) o una clase anidada definici&amp;oacute;n (incluidos los nombres de las bases de las que se deriva la clase anidada), los &amp;aacute;mbitos buscados son los mismos que en &lt;a href=&quot;unqualified_lookup#Class_definition&quot;&gt;la definici&amp;oacute;n de clase&lt;/a&gt; , excepto que se considera todo el alcance de la clase, no solo la parte anterior a la declaraci&amp;oacute;n que usa el nombre . Para las clases anidadas, se busca todo el cuerpo de la clase adjunta.</target>
        </trans-unit>
        <trans-unit id="5f9f456dc65dd5916b44e6d8b6b804f14836dd56" translate="yes" xml:space="preserve">
          <source>For a non-union aggregate, element for which a designated initializer is not provided are initialized the same as described above for when the number of initializer clauses is less than the number of members (default member initializers where provided, empty list-initialization otherwise):</source>
          <target state="translated">En el caso de un agregado no sindical,los elementos para los que no se proporciona un inicializador designado se inicializan de la misma manera que se ha descrito anteriormente cuando el número de cláusulas de inicialización es menor que el número de miembros (inicializadores de miembros por defecto cuando se proporcionan,inicialización de lista vacía en caso contrario):</target>
        </trans-unit>
        <trans-unit id="5961fe12a3117fa1b2454e762062290b637aa259" translate="yes" xml:space="preserve">
          <source>For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if.</source>
          <target state="translated">Para un par de modificaciones atómicas de M llamadas A y B,B ocurre después de A en el orden de modificación de M si.</target>
        </trans-unit>
        <trans-unit id="00a88dd4d98c693a356d74c5b2bd02963d1cfab7" translate="yes" xml:space="preserve">
          <source>For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt;s X and Y, and if A is</source>
          <target state="translated">Para un par de operaciones at&amp;oacute;micas en M llamadas A y B, donde A escribe y B lee el valor de M, si hay dos &lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; s X e Y, y si A es</target>
        </trans-unit>
        <trans-unit id="e8a036efd00fe52d195f38f7af9f452d212a3c7c" translate="yes" xml:space="preserve">
          <source>For a regular file &lt;code&gt;p&lt;/code&gt;, returns the size determined as if by reading the &lt;code&gt;st_size&lt;/code&gt; member of the structure obtained by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed).</source>
          <target state="translated">Para un archivo normal &lt;code&gt;p&lt;/code&gt; , devuelve el tama&amp;ntilde;o determinado como si leyera el miembro &lt;code&gt;st_size&lt;/code&gt; de la estructura obtenida por POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (se siguen los enlaces simb&amp;oacute;licos).</target>
        </trans-unit>
        <trans-unit id="1a9910e8a0a912c3015de0a3b33c5c17808e192d" translate="yes" xml:space="preserve">
          <source>For a reverse iterator &lt;code&gt;r&lt;/code&gt; constructed from an iterator &lt;code&gt;i&lt;/code&gt;, the relationship &lt;code&gt;&amp;amp;*r == &amp;amp;*(i-1)&lt;/code&gt; is always true (as long as &lt;code&gt;r&lt;/code&gt; is dereferenceable); thus a reverse iterator constructed from a one-past-the-end iterator dereferences to the last element in a sequence.</source>
          <target state="translated">Para un iterador inverso &lt;code&gt;r&lt;/code&gt; construido a partir de un iterador &lt;code&gt;i&lt;/code&gt; , la relaci&amp;oacute;n &lt;code&gt;&amp;amp;*r == &amp;amp;*(i-1)&lt;/code&gt; siempre es verdadera (siempre que &lt;code&gt;r&lt;/code&gt; sea ​​desreferenciable); as&amp;iacute;, un iterador inverso construido a partir de las desreferenciaciones de un iterador pasado al final al &amp;uacute;ltimo elemento de una secuencia.</target>
        </trans-unit>
        <trans-unit id="ad06b47edb0bcc2d8539e75487122b7c88338360" translate="yes" xml:space="preserve">
          <source>For a span &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.back()&lt;/code&gt; is equivalent to &lt;code&gt;*(c.end()-1)&lt;/code&gt;.</source>
          <target state="translated">Para un lapso &lt;code&gt;c&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;c.back()&lt;/code&gt; es equivalente a &lt;code&gt;*(c.end()-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1fa034a73d65c807607dcc81680fbdbbcb66bcc" translate="yes" xml:space="preserve">
          <source>For a span &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.front()&lt;/code&gt; is equivalent to &lt;code&gt;*c.begin()&lt;/code&gt;.</source>
          <target state="translated">Para un lapso &lt;code&gt;c&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;c.front()&lt;/code&gt; es equivalente a &lt;code&gt;*c.begin()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c154bb2c5d060e3bc21cda45246264cc660e3cf" translate="yes" xml:space="preserve">
          <source>For a standard stream &lt;code&gt;str&lt;/code&gt;, synchronized with the C stream &lt;code&gt;f&lt;/code&gt;, the following pairs of functions have identical effect:</source>
          <target state="translated">Para una secuencia est&amp;aacute;ndar &lt;code&gt;str&lt;/code&gt; , sincronizada con la secuencia C &lt;code&gt;f&lt;/code&gt; , los siguientes pares de funciones tienen el mismo efecto:</target>
        </trans-unit>
        <trans-unit id="de5683ef87cd469dd98d4cc4a0aed5b17f0dbfb7" translate="yes" xml:space="preserve">
          <source>For a type &lt;code&gt;T&lt;/code&gt;, the default value of &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is:</source>
          <target state="translated">Para un tipo &lt;code&gt;T&lt;/code&gt; , el valor predeterminado de &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; es:</target>
        </trans-unit>
        <trans-unit id="a003d5a71c47171b8ec220d6469cdc87d155fcf6" translate="yes" xml:space="preserve">
          <source>For a type &lt;code&gt;TC&lt;/code&gt;:</source>
          <target state="translated">Para un tipo &lt;code&gt;TC&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="28eb0e4e99d6754c04540069cc9b86b6e86b0026" translate="yes" xml:space="preserve">
          <source>For a unary operator &lt;code&gt;@&lt;/code&gt; whose argument has type &lt;code&gt;T1&lt;/code&gt; (after removing cv-qualifications), or binary operator &lt;code&gt;@&lt;/code&gt; whose left operand has type &lt;code&gt;T1&lt;/code&gt; and right operand of type &lt;code&gt;T2&lt;/code&gt; (after removing cv-qualifications), the following sets of candidate functions are prepared:</source>
          <target state="translated">Para un operador unario &lt;code&gt;@&lt;/code&gt; cuyo argumento tiene el tipo &lt;code&gt;T1&lt;/code&gt; (despu&amp;eacute;s de eliminar las calificaciones cv), o el operador binario &lt;code&gt;@&lt;/code&gt; cuyo operando izquierdo tiene el tipo &lt;code&gt;T1&lt;/code&gt; y el operando derecho del tipo &lt;code&gt;T2&lt;/code&gt; (despu&amp;eacute;s de eliminar las calificaciones cv), se preparan los siguientes conjuntos de funciones candidatas :</target>
        </trans-unit>
        <trans-unit id="a0f6b7e105043260b05aaf0d46100e8d47e56be4" translate="yes" xml:space="preserve">
          <source>For a union with bits that participate in the value representations of some members but not the others, compare-and-exchange might always fail because such padding bits have indeterminate values when they do not participate in the value representation of the active member.</source>
          <target state="translated">En el caso de una unión con bits que participan en las representaciones de valor de algunos miembros pero no de los demás,la comparación e intercambio siempre puede fracasar porque esos bits acolchados tienen valores indeterminados cuando no participan en la representación de valor del miembro activo.</target>
        </trans-unit>
        <trans-unit id="1edec90a35f1485dfd1de3cb8edee29c85050704" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;!(a &amp;lt; a)&lt;/code&gt;</source>
          <target state="translated">Por todo &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;!(a &amp;lt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be2f118aaee33f35b4a4d55d4b1363d900dc2269" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;comp(a,a)==false&lt;/code&gt;</source>
          <target state="translated">Para todo &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;comp(a,a)==false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="232a0e7be31828ff9c9e76ce04deca11781e6a26" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;equiv(a,a)==true&lt;/code&gt;</source>
          <target state="translated">Para todo &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;equiv(a,a)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcda67f6f48d3eaf152c442223488264fae5046f" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; is equal to &lt;code&gt;X​::​eq_int_type(X​::​to_int_type(c), X​::​to_int_type(d))&lt;/code&gt;</source>
          <target state="translated">Para todos &lt;code&gt;c&lt;/code&gt; y &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; es igual a &lt;code&gt;X​::​eq_int_type(X​::​to_int_type(c), X​::​to_int_type(d))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2032585f99e27bc2ad7b8385f77f212571492869" translate="yes" xml:space="preserve">
          <source>For all other functions, reaching the end of a catch clause is equivalent to &lt;code&gt;return;&lt;/code&gt; if the function's return type is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">Para todas las dem&amp;aacute;s funciones, alcanzar el final de una cl&amp;aacute;usula catch es equivalente a &lt;code&gt;return;&lt;/code&gt; si el tipo de retorno de la funci&amp;oacute;n es (posiblemente calificado por cv) &lt;code&gt;void&lt;/code&gt; , de lo contrario el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="da7d72e89e6f7a108ff843546e67ee1b3d8bf96b" translate="yes" xml:space="preserve">
          <source>For all other names (variables, namespaces, classes, etc), name lookup must produce a single declaration in order for the program to compile. Lookup for a name in a scope finds all declarations of that name, with one exception, known as the &quot;struct hack&quot; or &quot;type/non-type hiding&quot;: Within the same scope, some occurrences of a name may refer to a declaration of a class/struct/union/enum that is not a typedef, while all other occurrences of the same name either all refer to the same variable, non-static data member (since C++14), or enumerator, or they all refer to possibly overloaded function or function template names. In this case, there is no error, but the type name is hidden from lookup (the code must use &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; to access it).</source>
          <target state="translated">Para todos los dem&amp;aacute;s nombres (variables, espacios de nombres, clases, etc.), la b&amp;uacute;squeda de nombres debe producir una declaraci&amp;oacute;n &amp;uacute;nica para que el programa se compile. La b&amp;uacute;squeda de un nombre en un &amp;aacute;mbito encuentra todas las declaraciones de ese nombre, con una excepci&amp;oacute;n, conocida como &quot;estructura hack&quot; o &quot;tipo / ocultaci&amp;oacute;n de tipo&quot;: dentro del mismo &amp;aacute;mbito, algunas ocurrencias de un nombre pueden referirse a una declaraci&amp;oacute;n de una clase / estructura / uni&amp;oacute;n / enumeraci&amp;oacute;n que no es un typedef, mientras que todas las dem&amp;aacute;s ocurrencias del mismo nombre se refieren a la misma variable, miembro de datos no est&amp;aacute;tico (desde C ++ 14), o enumerador, o todos consulte los nombres de funciones o plantillas de funciones posiblemente sobrecargadas. En este caso, no hay error, pero el nombre del tipo est&amp;aacute; oculto para la b&amp;uacute;squeda (el c&amp;oacute;digo debe usar &lt;a href=&quot;elaborated_type_specifier&quot;&gt;un especificador de tipo elaborado&lt;/a&gt; para acceder a &amp;eacute;l).</target>
        </trans-unit>
        <trans-unit id="10db488ddc48847974dabc392b2f321428b2ad60" translate="yes" xml:space="preserve">
          <source>For all other objects (class objects initialized by a trivial default constructor, non-class objects, arrays of those, etc.), lifetime begins when the properly-aligned storage for the object is allocated and ends when the storage is deallocated or reused by another object.</source>
          <target state="translated">Para todos los demás objetos (objetos de clase inicializados por un constructor trivial por defecto,objetos no de clase,arreglos de esos,etc.),la vida útil comienza cuando se asigna el almacenamiento debidamente alineado para el objeto y termina cuando el almacenamiento es deslocalizado o reutilizado por otro objeto.</target>
        </trans-unit>
        <trans-unit id="760abd8226337c152c576ef554b6c75c15801476" translate="yes" xml:space="preserve">
          <source>For all three operators, the usual arithmetic conversions are performed on both operands and determine the type of the result.</source>
          <target state="translated">Para los tres operadores,las conversiones aritméticas habituales se realizan en ambos operandos y determinan el tipo de resultado.</target>
        </trans-unit>
        <trans-unit id="8d67a35b43e5bf5606d1d36920c0574ac4035475" translate="yes" xml:space="preserve">
          <source>For all values of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a == a&lt;/code&gt; yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para todos los valores de &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;a == a&lt;/code&gt; produce &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd7a423e3b93ec1547e0b8fd506cf138031deb4a" translate="yes" xml:space="preserve">
          <source>For an</source>
          <target state="translated">Para un</target>
        </trans-unit>
        <trans-unit id="abab0bc9e7d335f8452e190fdf3bbe8302cb65a4" translate="yes" xml:space="preserve">
          <source>For an &lt;a href=&quot;expressions#Operators&quot;&gt;operator&lt;/a&gt; used in expression (e.g., &lt;code&gt;operator+&lt;/code&gt; used in &lt;code&gt;a+b&lt;/code&gt;), the lookup rules are slightly different from the operator used in an explicit function-call expression such as &lt;code&gt;operator+(a,b)&lt;/code&gt;: when parsing an expression, two separate lookups are performed: for the non-member operator overloads and for the member operator overloads (for the operators where both forms are permitted). Those sets are then merged with the built-in operator overloads on equal grounds as described in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;. If explicit function call syntax is used, regular unqualified name lookup is performed:</source>
          <target state="translated">Para un &lt;a href=&quot;expressions#Operators&quot;&gt;operador&lt;/a&gt; utilizado en la expresi&amp;oacute;n (p. Ej., &lt;code&gt;operator+&lt;/code&gt; utilizado en &lt;code&gt;a+b&lt;/code&gt; ), las reglas de b&amp;uacute;squeda son ligeramente diferentes del operador utilizado en una expresi&amp;oacute;n expl&amp;iacute;cita de llamada a la funci&amp;oacute;n, como &lt;code&gt;operator+(a,b)&lt;/code&gt; : al analizar una expresi&amp;oacute;n, dos se realizan b&amp;uacute;squedas: para las sobrecargas del operador no miembro y para las sobrecargas del operador miembro (para los operadores donde se permiten ambos formularios). Esos conjuntos se fusionan con las sobrecargas del operador integradas en igualdad de condiciones como se describe en la &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; . Si se utiliza la sintaxis de llamada de funci&amp;oacute;n expl&amp;iacute;cita, se realiza una b&amp;uacute;squeda de nombre no calificado regular:</target>
        </trans-unit>
        <trans-unit id="cfdde08423e6892ce026f332e4722775a6fd0ec4" translate="yes" xml:space="preserve">
          <source>For an inline function or inline variable(since C++17), a definition is required in every translation unit where it is</source>
          <target state="translated">Para una función o variable en línea (desde C++17),se requiere una definición en cada unidad de traducción en la que se encuentre</target>
        </trans-unit>
        <trans-unit id="b13c06c8df9fdd2618a4c37f530dfc9ec64faee7" translate="yes" xml:space="preserve">
          <source>For an object &lt;code&gt;m&lt;/code&gt; of Mutex type:</source>
          <target state="translated">Para un objeto &lt;code&gt;m&lt;/code&gt; de tipo Mutex:</target>
        </trans-unit>
        <trans-unit id="10c618faebd2cba6e4ed1d78498e9c737887c436" translate="yes" xml:space="preserve">
          <source>For an object of type &lt;code&gt;T&lt;/code&gt;,</source>
          <target state="translated">Para un objeto de tipo &lt;code&gt;T&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="9cbc15bac40798667e2c28ef32d8acd0bfca6527" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;year_month_day&lt;/code&gt; object &lt;code&gt;ymd&lt;/code&gt; representing a valid date (&lt;code&gt;ymd.ok() == true&lt;/code&gt;), converting &lt;code&gt;ymd&lt;/code&gt; to &lt;code&gt;sys_days&lt;/code&gt; and back yields the same value.</source>
          <target state="translated">Para cualquier &lt;code&gt;year_month_day&lt;/code&gt; objeto &lt;code&gt;ymd&lt;/code&gt; que representa una fecha v&amp;aacute;lida ( &lt;code&gt;ymd.ok() == true&lt;/code&gt; ), la conversi&amp;oacute;n de &lt;code&gt;ymd&lt;/code&gt; a &lt;code&gt;sys_days&lt;/code&gt; y la parte posterior se obtiene el mismo valor.</target>
        </trans-unit>
        <trans-unit id="f2a393f7232125085f4da3eb01cb2d41b026b8c4" translate="yes" xml:space="preserve">
          <source>For any object &lt;code&gt;z&lt;/code&gt; of type &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[0]&lt;/code&gt; is the real part of z and &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[1]&lt;/code&gt; is the imaginary part of z.</source>
          <target state="translated">Para cualquier objeto &lt;code&gt;z&lt;/code&gt; de tipo &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[0]&lt;/code&gt; es la parte real de z y &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[1]&lt;/code&gt; es la parte imaginaria de z.</target>
        </trans-unit>
        <trans-unit id="aa002637ab58deab74ffaca3cf03066bd188d114" translate="yes" xml:space="preserve">
          <source>For any object of class or aggregate types if it, or any of its subobjects, is initialized by anything other than the &lt;a href=&quot;default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, lifetime begins when initialization ends.</source>
          <target state="translated">Para cualquier objeto de clase o tipos agregados si &amp;eacute;ste, o cualquiera de sus subobjetos, se inicializa por algo que no sea el &lt;a href=&quot;default_constructor#Trivial_default_constructor&quot;&gt;constructor trivial predeterminado&lt;/a&gt; , la vida &amp;uacute;til comienza cuando finaliza la inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cdd8992024517b51f7efb1e98465ebff61447714" translate="yes" xml:space="preserve">
          <source>For any object of class types whose &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;destructor&lt;/a&gt; is not trivial, lifetime ends when the execution of the destructor begins.</source>
          <target state="translated">Para cualquier objeto de tipo de clase cuyo &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;destructor&lt;/a&gt; no sea trivial, la vida &amp;uacute;til finaliza cuando comienza la ejecuci&amp;oacute;n del destructor.</target>
        </trans-unit>
        <trans-unit id="fa44da499e47fc6fac2860172008adb9c1ff9a16" translate="yes" xml:space="preserve">
          <source>For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cefa90cb2c929a28be455e9f8fda7d414ab3948b" translate="yes" xml:space="preserve">
          <source>For any pointer to an element of an array of &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; named &lt;code&gt;p&lt;/code&gt; and any valid array index &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i]&lt;/code&gt; is the real part of the complex number &lt;code&gt;p[i]&lt;/code&gt;, and &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i + 1]&lt;/code&gt; is the imaginary part of the complex number &lt;code&gt;p[i]&lt;/code&gt;</source>
          <target state="translated">Para cualquier puntero a un elemento de una matriz de &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; llamado &lt;code&gt;p&lt;/code&gt; y cualquier &amp;iacute;ndice de matriz v&amp;aacute;lido &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i]&lt;/code&gt; es la parte real del n&amp;uacute;mero complejo &lt;code&gt;p[i]&lt;/code&gt; , y &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i + 1]&lt;/code&gt; es la parte imaginaria del n&amp;uacute;mero complejo &lt;code&gt;p[i]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33bcdf350e21fefb2826ca912ee3190d4a971dc5" translate="yes" xml:space="preserve">
          <source>For any two values &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; of the type &lt;code&gt;&lt;a href=&quot;../../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt1&amp;gt;::value_type&lt;/code&gt;, if &lt;code&gt;pred(A, B) == true&lt;/code&gt;, then &lt;code&gt;hf(A) == hf(B)&lt;/code&gt; shall be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para cualquiera de los dos valores &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; del tipo &lt;code&gt;&lt;a href=&quot;../../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt1&amp;gt;::value_type&lt;/code&gt; , si &lt;code&gt;pred(A, B) == true&lt;/code&gt; , entonces &lt;code&gt;hf(A) == hf(B)&lt;/code&gt; ser&amp;aacute; &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b450ffc7f721529dcdc6d1be9e46c5d50a2a925" translate="yes" xml:space="preserve">
          <source>For any type &lt;code&gt;T&lt;/code&gt; (including incomplete types), other than &lt;a href=&quot;functions&quot;&gt;function type&lt;/a&gt; or &lt;a href=&quot;reference&quot;&gt;reference type&lt;/a&gt;, there are three more distinct types in the C++ type system: const-qualified&lt;code&gt;T&lt;/code&gt;, volatile-qualified&lt;code&gt;T&lt;/code&gt;, and const-volatile-qualified&lt;code&gt;T&lt;/code&gt;.  Note: &lt;a href=&quot;array&quot;&gt;array types&lt;/a&gt; are considered to have the same cv-qualification as their element types.</source>
          <target state="translated">Para cualquier tipo &lt;code&gt;T&lt;/code&gt; (incluidos los tipos incompletos), distintos de &lt;a href=&quot;functions&quot;&gt;tipo de funci&amp;oacute;n&lt;/a&gt; o &lt;a href=&quot;reference&quot;&gt;tipo de referencia&lt;/a&gt; , hay tres tipos m&amp;aacute;s distintos en el sistema de tipo C ++: const cualificado &lt;code&gt;T&lt;/code&gt; , vol&amp;aacute;til cualificado &lt;code&gt;T&lt;/code&gt; , y const vol&amp;aacute;til cualificado &lt;code&gt;T&lt;/code&gt; . Nota: se considera que los &lt;a href=&quot;array&quot;&gt;tipos de matriz&lt;/a&gt; tienen la misma calificaci&amp;oacute;n cv que sus tipos de elementos.</target>
        </trans-unit>
        <trans-unit id="587d19dece0a5e657eee4b9c6dab7110d60627cf" translate="yes" xml:space="preserve">
          <source>For any z, acos(z) = &amp;pi; - acos(-z).</source>
          <target state="translated">Para cualquier z, acos (z) = &amp;pi; - acos (-z).</target>
        </trans-unit>
        <trans-unit id="21aee1213fe266997611327508955de0364192e9" translate="yes" xml:space="preserve">
          <source>For any z, atanh(z) =</source>
          <target state="translated">Para cualquier z,atanh(z)=</target>
        </trans-unit>
        <trans-unit id="e254b6622c2f4cf79e478657cc199aa0c2eea2e9" translate="yes" xml:space="preserve">
          <source>For append streams (&lt;code&gt;mode &amp;amp; ios_base::ate == true&lt;/code&gt;), &lt;code&gt;pptr() == pbase() + s.size()&lt;/code&gt;, so that subsequent output will be appended to the last character copied from &lt;code&gt;s&lt;/code&gt;(since C++11)</source>
          <target state="translated">Para agregar secuencias ( &lt;code&gt;mode &amp;amp; ios_base::ate == true&lt;/code&gt; ), &lt;code&gt;pptr() == pbase() + s.size()&lt;/code&gt; , de modo que la salida posterior se agregar&amp;aacute; al &amp;uacute;ltimo car&amp;aacute;cter copiado de &lt;code&gt;s&lt;/code&gt; (desde C ++ 11 )</target>
        </trans-unit>
        <trans-unit id="c24da57cc18573525a82a6c2c1fa0a27b061d0da" translate="yes" xml:space="preserve">
          <source>For arg&amp;gt;1, &amp;Sigma;&amp;infin;</source>
          <target state="translated">Para arg&amp;gt; 1, &amp;Sigma;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="7046cc5d9597c58aa7e54080523a910de0e052c1" translate="yes" xml:space="preserve">
          <source>For arg&amp;lt;0, 2arg</source>
          <target state="translated">Para arg &amp;lt;0, 2arg</target>
        </trans-unit>
        <trans-unit id="188be9f862ad64a9a657bafc75642d5f5c9f6a4f" translate="yes" xml:space="preserve">
          <source>For arithmetic types not subject to promotion, the common type may be viewed as the type of the (possibly mixed-mode) arithmetic expression such as &lt;code&gt;T0() + T1() + ... + Tn()&lt;/code&gt;.</source>
          <target state="translated">Para los tipos aritm&amp;eacute;ticos no sujetos a promoci&amp;oacute;n, el tipo com&amp;uacute;n puede verse como el tipo de expresi&amp;oacute;n aritm&amp;eacute;tica (posiblemente en modo mixto) como &lt;code&gt;T0() + T1() + ... + Tn()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79dccf2c6a91881692253227b281b3f534531201" translate="yes" xml:space="preserve">
          <source>For arithmetic types, the thousands separator character, obtained from &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt;, is inserted into the sequence according to the grouping rules provided by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;</source>
          <target state="translated">Para los tipos aritm&amp;eacute;ticos, el car&amp;aacute;cter separador de miles, obtenido de &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt; , se inserta en la secuencia de acuerdo con las reglas de agrupaci&amp;oacute;n proporcionadas por &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c01eb08fd12dd04934e4ddc13d646e9cc256574b" translate="yes" xml:space="preserve">
          <source>For auto-returning functions, the parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared return type of the function that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the expression of the &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement, and if the return statement has no operand, &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;void()&lt;/code&gt;. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;T&lt;/code&gt; to get the actual return type:</source>
          <target state="translated">Para las funciones de retorno autom&amp;aacute;tico, el par&amp;aacute;metro &lt;code&gt;P&lt;/code&gt; se obtiene de la siguiente manera: en &lt;code&gt;T&lt;/code&gt; , el tipo de retorno declarado de la funci&amp;oacute;n que incluye &lt;code&gt;auto&lt;/code&gt; , cada aparici&amp;oacute;n de &lt;code&gt;auto&lt;/code&gt; se reemplaza con un par&amp;aacute;metro &lt;code&gt;U&lt;/code&gt; de plantilla de tipo imaginario . El argumento &lt;code&gt;A&lt;/code&gt; es la expresi&amp;oacute;n de la declaraci&amp;oacute;n de &lt;a href=&quot;return&quot;&gt;retorno&lt;/a&gt; , y si la declaraci&amp;oacute;n de retorno no tiene operando, &lt;code&gt;A&lt;/code&gt; es &lt;code&gt;void()&lt;/code&gt; . Despu&amp;eacute;s de deducir &lt;code&gt;U&lt;/code&gt; de &lt;code&gt;P&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; siguiendo las reglas descritas anteriormente, la &lt;code&gt;U&lt;/code&gt; deducida se sustituye en &lt;code&gt;T&lt;/code&gt; para obtener el tipo de retorno real:</target>
        </trans-unit>
        <trans-unit id="21745cae4e72428f50d08dc188de6ed08f485b25" translate="yes" xml:space="preserve">
          <source>For both integer and floating-point types, if &lt;code&gt;showpos&lt;/code&gt; is set, the modifier &lt;code&gt;+&lt;/code&gt; is prepended</source>
          <target state="translated">Tanto para los tipos enteros como para los de punto flotante, si se establece &lt;code&gt;showpos&lt;/code&gt; , el modificador &lt;code&gt;+&lt;/code&gt; se antepone</target>
        </trans-unit>
        <trans-unit id="6e00438cc48aea953c237222b040f934d513cc5a" translate="yes" xml:space="preserve">
          <source>For both overloads, if the iterator type is mutable, &lt;code&gt;f&lt;/code&gt; may modify the elements of the range through the dereferenced iterator. If &lt;code&gt;f&lt;/code&gt; returns a result, the result is ignored.</source>
          <target state="translated">Para ambas sobrecargas, si el tipo de iterador es mutable, &lt;code&gt;f&lt;/code&gt; puede modificar los elementos del rango a trav&amp;eacute;s del iterador desreferenciado. Si &lt;code&gt;f&lt;/code&gt; devuelve un resultado, el resultado se ignora.</target>
        </trans-unit>
        <trans-unit id="d4b87d39492f3a203318f3eec5a45d21ed020f35" translate="yes" xml:space="preserve">
          <source>For both overloads, if the iterator type is mutable, &lt;code&gt;f&lt;/code&gt; may modify the elements of the range through the dereferenced iterator. If &lt;code&gt;f&lt;/code&gt; returns a result, the result is ignored. If &lt;code&gt;n&lt;/code&gt; is less than zero, the behavior is undefined.</source>
          <target state="translated">Para ambas sobrecargas, si el tipo de iterador es mutable, &lt;code&gt;f&lt;/code&gt; puede modificar los elementos del rango a trav&amp;eacute;s del iterador desreferenciado. Si &lt;code&gt;f&lt;/code&gt; devuelve un resultado, el resultado se ignora. Si &lt;code&gt;n&lt;/code&gt; es menor que cero, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="2cbfdeffec6dd0f35e1227e8a499f4b7385ae247" translate="yes" xml:space="preserve">
          <source>For both user-defined or implicitly-defined destructors, after the body of the destructor is executed, the compiler calls the destructors for all non-static non-variant members of the class, in reverse order of declaration, then it calls the destructors of all direct non-virtual base classes in &lt;a href=&quot;constructor#Initialization_order&quot;&gt;reverse order of construction&lt;/a&gt; (which in turn call the destructors of their members and their base classes, etc), and then, if this object is of most-derived class, it calls the destructors of all virtual bases.</source>
          <target state="translated">Para los destructores definidos por el usuario o impl&amp;iacute;citamente, despu&amp;eacute;s de ejecutar el cuerpo del destructor, el compilador llama a los destructores para todos los miembros no est&amp;aacute;ticos no variantes de la clase, en orden inverso a la declaraci&amp;oacute;n, luego llama a los destructores de todas las clases base directas no virtuales en &lt;a href=&quot;constructor#Initialization_order&quot;&gt;orden inverso de construcci&amp;oacute;n&lt;/a&gt; (que a su vez llaman a los destructores de sus miembros y sus clases base, etc.), y luego, si este objeto es de la clase m&amp;aacute;s derivada, llama a los destructores de todas las clases virtuales bases.</target>
        </trans-unit>
        <trans-unit id="db34171dc6d92c22aa5da5d7cd5e78cc97249f77" translate="yes" xml:space="preserve">
          <source>For char arrays shorter than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ptrdiff_t&lt;/code&gt; acts as the signed counterpart of &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;: it can store the size of the array of any type and is, on most platforms, synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::intptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Para matrices de caracteres m&amp;aacute;s cortas que &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ptrdiff_t&lt;/code&gt; act&amp;uacute;a como la contraparte firmada de &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; : puede almacenar el tama&amp;ntilde;o de la matriz de cualquier tipo y, en la mayor&amp;iacute;a de las plataformas, es sin&amp;oacute;nimo de &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::intptr_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3c75e611a43557be37674fd1cb00bb164eeebf" translate="yes" xml:space="preserve">
          <source>For compatibility with C89, an optional comma may appear before the ellipsis if the parameter list contains at least one parameter:</source>
          <target state="translated">Para la compatibilidad con el C89,puede aparecer una coma opcional antes de la elipse si la lista de parámetros contiene al menos un parámetro:</target>
        </trans-unit>
        <trans-unit id="94880bd109360b34fd05f9d76510d26eb3dee88a" translate="yes" xml:space="preserve">
          <source>For constexpr function templates and constexpr member functions of class templates, at least one specialization must satisfy the abovementioned requirements. Other specializations are still considered as constexpr, even though a call to such a function cannot appear in a constant expression.</source>
          <target state="translated">Para las plantillas de funciones de constexpr y las funciones de miembro de constexpr de las plantillas de clases,al menos una especialización debe satisfacer los requisitos mencionados.Las demás especialidades se consideran todavía como constexpr,aunque la llamada a tal función no pueda aparecer en una expresión constante.</target>
        </trans-unit>
        <trans-unit id="9efcdd76c0a92319514fd74592e33806161ca5b0" translate="yes" xml:space="preserve">
          <source>For control over formatting, use &lt;code&gt;std::chrono::format&lt;/code&gt;.</source>
          <target state="translated">Para controlar el formateo, use &lt;code&gt;std::chrono::format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce61db7d14bb600483458137835d50aed271a6ed" translate="yes" xml:space="preserve">
          <source>For creation of a full date, any of the following three orders are accepted:</source>
          <target state="translated">Para la creación de una fecha completa,se aceptan cualquiera de las tres órdenes siguientes:</target>
        </trans-unit>
        <trans-unit id="1e51f626291c443aca3537b45aaca51887d63f76" translate="yes" xml:space="preserve">
          <source>For detailed rules on overload resolution, see &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">Para conocer las reglas detalladas sobre la resoluci&amp;oacute;n de sobrecarga, consulte la &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ccd8ef2913234c8ce975d9ef8bd2b1cb54addbe" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;Ti&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;, the corresponding type &lt;code&gt;Vi&lt;/code&gt; in &lt;code&gt;VTypes...&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Ti&amp;gt;::type&lt;/code&gt; unless application of &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; results in &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; for some type &lt;code&gt;X&lt;/code&gt;, in which case the deduced type is &lt;code&gt;X&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Para cada &lt;code&gt;Ti&lt;/code&gt; en &lt;code&gt;Types...&lt;/code&gt; , el tipo correspondiente &lt;code&gt;Vi&lt;/code&gt; en &lt;code&gt;VTypes...&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Ti&amp;gt;::type&lt;/code&gt; menos que la aplicaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; d&amp;eacute; como resultado &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; para alg&amp;uacute;n tipo &lt;code&gt;X&lt;/code&gt; , en cuyo caso el tipo deducido es &lt;code&gt;X&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdcf0767cd45dcef0e5f166fda3ae1b99a89262" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,j)&lt;/code&gt;, &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; is true</source>
          <target state="translated">Para cada &lt;code&gt;i&lt;/code&gt; en &lt;code&gt;[0,j)&lt;/code&gt; , &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; es verdadero</target>
        </trans-unit>
        <trans-unit id="a48fe3fe8c043eed63afe7b1696e912edb4e26e0" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, performs &lt;code&gt;X​::​assign(s[i], c)&lt;/code&gt;.</source>
          <target state="translated">Para cada &lt;code&gt;i&lt;/code&gt; en &lt;code&gt;[0,n)&lt;/code&gt; , realiza &lt;code&gt;X​::​assign(s[i], c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7673ab38c4ed279e12cc192b7a57b5fd910e9b3" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, performs &lt;code&gt;X​::​assign(s[i], p[i])&lt;/code&gt;</source>
          <target state="translated">Para cada &lt;code&gt;i&lt;/code&gt; en &lt;code&gt;[0,n)&lt;/code&gt; , realiza &lt;code&gt;X​::​assign(s[i], p[i])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a6ddee35ee106c63cce63cef04db68150835b00" translate="yes" xml:space="preserve">
          <source>For each declarator, the initializer may be one of the following:</source>
          <target state="translated">Para cada declarante,el inicializador puede ser uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="71cdc882df31450c88808b61a9ff32adee6518cf" translate="yes" xml:space="preserve">
          <source>For each distinct base class that is specified &lt;code&gt;virtual&lt;/code&gt;, the most derived object contains only one base class subobject of that type, even if the class appears many times in the inheritance hierarchy (as long as it is inherited &lt;code&gt;virtual&lt;/code&gt; every time).</source>
          <target state="translated">Para cada clase base distinta que se especifica &lt;code&gt;virtual&lt;/code&gt; , el objeto m&amp;aacute;s derivado contiene solo un subobjeto de clase base de ese tipo, incluso si la clase aparece muchas veces en la jerarqu&amp;iacute;a de herencia (siempre que se herede &lt;code&gt;virtual&lt;/code&gt; cada vez).</target>
        </trans-unit>
        <trans-unit id="5bfb358921b4b02768fb8323b116ca9ed3bbe11d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; computa</target>
        </trans-unit>
        <trans-unit id="483eec964f0d73c99af70508de57de3007259d4d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc cosine of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; ,se calcula el arco coseno del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="adb75759a95a8aeb64e9736b66397da9bd1d4446" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc sine of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; , calcula el arco seno del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="ca88cd5ed53414ce6dc3bf89279bd5da6137ef0b" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc tangent of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; ,se calcula el arco tangente del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="f7b456dfebcb725eca2a813704a2d061981a4d5d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes common (base 10) logarithm of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; ,se calcula el logaritmo com&amp;uacute;n (base 10) del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="604bbd841643b027a383acee66008e7977d1d958" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes cosine of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; ,se calcula el coseno del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="6f10323acc53f3b6e728d81bacf3f244188492b8" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic cosine of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; ,se calcula el coseno hiperb&amp;oacute;lico del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="d1e0c67a77c4c9f3880463f9d8f3aa99bf732d31" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic sine of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; , calcula el seno hiperb&amp;oacute;lico del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="fea32eb8ad9df99ec39e088fce28cbee17276c80" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic tangent of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; se calcula la tangente hiperb&amp;oacute;lica del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="cd3565d6513a55d7d6d649e63d9ef8dc096c132d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes natural logarithm of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; ,se calcula el logaritmo natural del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="8613519bb915be734bdb83ddf1139c1436d679c7" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes sine of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; , calcula el seno del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="16f2ed1e42028d25247c7e709cdd5ffa277bdfdc" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes tangent of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; se calcula la tangente del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="2e8b5a06d41da5547ea77c34dce52624edf4f443" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes the square root of the value of the element.</source>
          <target state="translated">Para cada elemento en &lt;code&gt;va&lt;/code&gt; , calcula la ra&amp;iacute;z cuadrada del valor del elemento.</target>
        </trans-unit>
        <trans-unit id="de5098d9b31cace81235396b1ac2a117bb05f2f0" translate="yes" xml:space="preserve">
          <source>For each identifier, a variable whose type is &quot;reference to &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&amp;lt;i, E&amp;gt;::type&lt;/code&gt;&quot; is introduced: lvalue reference if its corresponding initializer is an lvalue, rvalue reference otherwise. The initializer for the i-th variable is.</source>
          <target state="translated">Para cada identificador, se introduce una variable cuyo tipo es &quot;referencia a &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&amp;lt;i, E&amp;gt;::type&lt;/code&gt; &quot;: referencia de valor si su inicializador correspondiente es un valor de valor, de lo contrario, referencia de valor. El inicializador para la variable i-&amp;eacute;sima es.</target>
        </trans-unit>
        <trans-unit id="e5405c9dfb873a374ff065f865a38e9ad5451317" translate="yes" xml:space="preserve">
          <source>For each non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; in &lt;code&gt;T&lt;/code&gt; or in a base of &lt;code&gt;T&lt;/code&gt; (unless hidden), whose cv-qualifiers is same or greater than &lt;code&gt;T&lt;/code&gt;'s cv-qualifiers, and where the conversion function converts to:</source>
          <target state="translated">Para cada &lt;a href=&quot;cast_operator&quot;&gt;funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario&lt;/a&gt; no expl&amp;iacute;cita en &lt;code&gt;T&lt;/code&gt; o en una base de &lt;code&gt;T&lt;/code&gt; (a menos que est&amp;eacute; oculta), cuyos calificadores cv son iguales o mayores que los calificadores cv de &lt;code&gt;T&lt;/code&gt; , y donde la funci&amp;oacute;n de conversi&amp;oacute;n se convierte en:</target>
        </trans-unit>
        <trans-unit id="96919b66c472b53a5ced1aa599bee24bc87358ce" translate="yes" xml:space="preserve">
          <source>For each pair of viable function &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt;, the implicit conversion sequences from the &lt;code&gt;i&lt;/code&gt;-th argument to &lt;code&gt;i&lt;/code&gt;-th parameter are ranked to determine which one is better (except the first argument, the</source>
          <target state="translated">Para cada par de funciones viables &lt;code&gt;F1&lt;/code&gt; y &lt;code&gt;F2&lt;/code&gt; , las secuencias de conversi&amp;oacute;n impl&amp;iacute;citas del &lt;code&gt;i&lt;/code&gt; -&amp;eacute;simo argumento al &lt;code&gt;i&lt;/code&gt; -&amp;eacute;simo par&amp;aacute;metro se clasifican para determinar cu&amp;aacute;l es mejor (excepto el primer argumento, el</target>
        </trans-unit>
        <trans-unit id="077e83335df9a76882a31f009c6cc740f8436fb9" translate="yes" xml:space="preserve">
          <source>For each such match &lt;code&gt;m&lt;/code&gt;, copies the non-matched subsequence (&lt;a href=&quot;match_results/prefix&quot;&gt;&lt;code&gt;m.prefix()&lt;/code&gt;&lt;/a&gt;) into &lt;code&gt;out&lt;/code&gt; as if by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(m.prefix().first, m.prefix().second, out)&lt;/code&gt; and then replaces the matched subsequence with the formatted replacement string as if by calling &lt;a href=&quot;match_results/format&quot;&gt;&lt;code&gt;out = m.format(out, fmt, flags)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para cada una de esas coincidencias &lt;code&gt;m&lt;/code&gt; , copia la subsecuencia no coincidente ( &lt;a href=&quot;match_results/prefix&quot;&gt; &lt;code&gt;m.prefix()&lt;/code&gt; &lt;/a&gt; ) en &lt;code&gt;out&lt;/code&gt; como si &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(m.prefix().first, m.prefix().second, out)&lt;/code&gt; y luego reemplaza la subsecuencia coincidente con la cadena de reemplazo formateada como si llamara &lt;a href=&quot;match_results/format&quot;&gt; &lt;code&gt;out = m.format(out, fmt, flags)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35a02408e3ec343aa382ddb9f4539b81b6f6a912" translate="yes" xml:space="preserve">
          <source>For each type, non-type, and template parameter, including parameter packs, a unique fictitious type, value, or template is generated and substituted into function type of the template</source>
          <target state="translated">Para cada parámetro de tipo,no tipo y plantilla,incluidos los paquetes de parámetros,se genera un tipo,valor o plantilla ficticia única que se sustituye en el tipo de función de la plantilla</target>
        </trans-unit>
        <trans-unit id="952fe468d5ee316980e589da22eb6018ea32e1cd" translate="yes" xml:space="preserve">
          <source>For equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).</source>
          <target state="translated">Para los elementos equivalentes de las dos gamas originales,los elementos de la primera gama (conservando su orden original)preceden a los elementos de la segunda gama (conservando su orden original).</target>
        </trans-unit>
        <trans-unit id="f8bf46aa49e5e80eadcaac2f31ab62ee0b13bf20" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;std::atomic&amp;lt;X&amp;gt;&lt;/code&gt; (whether or not specialized), &lt;code&gt;std::atomic&amp;lt;X&amp;gt;::value_type&lt;/code&gt; is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Por cada &lt;code&gt;std::atomic&amp;lt;X&amp;gt;&lt;/code&gt; (especializado o no), &lt;code&gt;std::atomic&amp;lt;X&amp;gt;::value_type&lt;/code&gt; es decir &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57dd021d134106ddd0d180af4fadda643026b891" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;&lt;/code&gt; (whether or not specialized), &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;::value_type&lt;/code&gt; is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Por cada &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;&lt;/code&gt; (especializado o no), &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;::value_type&lt;/code&gt; es decir &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e51dc104fca63d5103f9e0cf646aa86197a6c341" translate="yes" xml:space="preserve">
          <source>For every T that is a pointer-to-member type or the type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the following function signature participates in overload resolution:</source>
          <target state="translated">Para cada T que sea un tipo de puntero a miembro o el tipo &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , la siguiente firma de funci&amp;oacute;n participa en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="d6a1bb30012f8a1244f1eb8a6420656d9d6e09c6" translate="yes" xml:space="preserve">
          <source>For every conversion specifier other than &lt;code&gt;n&lt;/code&gt;, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</source>
          <target state="translated">Para cada especificador de conversi&amp;oacute;n que no sea &lt;code&gt;n&lt;/code&gt; , la secuencia m&amp;aacute;s larga de caracteres de entrada que no excede cualquier ancho de campo especificado y que es exactamente lo que el especificador de conversi&amp;oacute;n espera o es un prefijo de una secuencia que esperar&amp;iacute;a, es lo que se consume de la secuencia. El primer car&amp;aacute;cter, si lo hay, despu&amp;eacute;s de esta secuencia consumida permanece sin leer. Si la secuencia consumida tiene una longitud cero o si la secuencia consumida no se puede convertir como se especific&amp;oacute; anteriormente, la falla de coincidencia ocurre a menos que el final del archivo, un error de codificaci&amp;oacute;n o un error de lectura impida la entrada de la secuencia, en cuyo caso es un falla de entrada.</target>
        </trans-unit>
        <trans-unit id="90c2546abb31c7caf07bad20c6eabba4b2fe603e" translate="yes" xml:space="preserve">
          <source>For every enumeration or pointer to member type &lt;code&gt;T&lt;/code&gt;, optionally volatile-qualified, the following function signature participates in overload resolution:</source>
          <target state="translated">Para cada enumeraci&amp;oacute;n o puntero al miembro tipo &lt;code&gt;T&lt;/code&gt; , opcionalmente calificado como vol&amp;aacute;til, la siguiente firma de funci&amp;oacute;n participa en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="88970b9a9ff96606e8a48b4759fd878eb0266d29" translate="yes" xml:space="preserve">
          <source>For every iterator type &lt;code&gt;It&lt;/code&gt;, a typedef &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_category&lt;/code&gt; is available, which is an alias to one of these five(until C++20)six(since C++20) tag types.</source>
          <target state="translated">Para cada tipo de iterador &lt;code&gt;It&lt;/code&gt; , est&amp;aacute; disponible un typedef &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_category&lt;/code&gt; , que es un alias para uno de estos cinco (hasta C ++ 20) seis (desde C ++ 20) tipos de etiquetas.</target>
        </trans-unit>
        <trans-unit id="e71c9303eec62288eff7b54439f77781e36bc155" translate="yes" xml:space="preserve">
          <source>For every optionally cv-qualified object type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">Para cada tipo de objeto opcionalmente calificado para cv &lt;code&gt;T&lt;/code&gt; , las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="96c0842f465784a49ab8d68561798db17053d280" translate="yes" xml:space="preserve">
          <source>For every pair A1 and A2, where A1 is an arithmetic type (optionally volatile-qualified) and A2 is a promoted arithmetic type, the following function signature participates in overload resolution:</source>
          <target state="translated">Por cada par A1 y A2,donde A1 es un tipo aritmético (opcionalmente calificable como volátil)y A2 es un tipo aritmético promovido,la siguiente función de firma participa en la resolución de la sobrecarga:</target>
        </trans-unit>
        <trans-unit id="20e473aa5e7c31193000e4e17752d2e9b84efea5" translate="yes" xml:space="preserve">
          <source>For every pair I1 and I2, where I1 is an integral type (optionally volatile-qualified) and I2 is a promoted integral type, the following function signatures participate in overload resolution:</source>
          <target state="translated">Por cada par I1 y I2,en el que I1 es un tipo integral (opcionalmente calificado como volátil)y I2 es un tipo integral promovido,las siguientes firmas de funciones participan en la resolución de la sobrecarga:</target>
        </trans-unit>
        <trans-unit id="fef8c5eb5bd67258e2ec4544fa11f3c0a8bfa352" translate="yes" xml:space="preserve">
          <source>For every pair of promoted arithmetic types L and R and for every type P, where P is a pointer, pointer-to-member, or scoped enumeration type, the following function signatures participate in the overload resolution performed in step 5 of the rules above:</source>
          <target state="translated">Por cada par de tipos aritméticos promovidos L y R y por cada tipo P,donde P es un tipo de enumeración de puntero,de puntero a miembro o de alcance,las siguientes firmas de funciones participan en la resolución de la sobrecarga realizada en el paso 5 de las reglas anteriores:</target>
        </trans-unit>
        <trans-unit id="d638c80e090b37ee12468ee54f0147dce03100fb" translate="yes" xml:space="preserve">
          <source>For every parameter in params whose type is specified as &lt;code&gt;auto&lt;/code&gt;, an invented template parameter is added to template-params, in order of appearance. The invented template parameter may be a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; if the corresponding function member of params is a function parameter pack.</source>
          <target state="translated">Para cada par&amp;aacute;metro en par&amp;aacute;metros cuyo tipo se especifica como &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;tico , se agrega un par&amp;aacute;metro de plantilla inventado a los par&amp;aacute;metros de plantilla, en orden de aparici&amp;oacute;n. El par&amp;aacute;metro de plantilla inventado puede ser un &lt;a href=&quot;parameter_pack&quot;&gt;paquete de par&amp;aacute;metros&lt;/a&gt; si el miembro de funci&amp;oacute;n correspondiente de params es un paquete de par&amp;aacute;metros de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="859f56c75df09c6419c76fcbdbe8ae8dbb4f8aed" translate="yes" xml:space="preserve">
          <source>For every type &lt;code&gt;MP&lt;/code&gt; that is a pointer to member object or pointer to member function or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">Para cada tipo &lt;code&gt;MP&lt;/code&gt; que es un puntero al objeto miembro o puntero a la funci&amp;oacute;n miembro o &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="5ba25517699790e207bae588adda9d67eb82eb32" translate="yes" xml:space="preserve">
          <source>For every type &lt;code&gt;P&lt;/code&gt; which is either pointer to object or pointer to function or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;(until C++14), the following function signatures participate in overload resolution:</source>
          <target state="translated">Para cada tipo &lt;code&gt;P&lt;/code&gt; que sea puntero a objeto o puntero a funci&amp;oacute;n o &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; (hasta C ++ 14), las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="ee4a3f0b05542f01bd799b3b751f77169b8294dd" translate="yes" xml:space="preserve">
          <source>For every type other than reference and function, the type system supports three additional &lt;a href=&quot;cv&quot;&gt;cv-qualified versions&lt;/a&gt; of that type (&lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, and &lt;code&gt;const volatile&lt;/code&gt;).</source>
          <target state="translated">Para cada tipo que no sea referencia y funci&amp;oacute;n, el sistema de tipos admite tres &lt;a href=&quot;cv&quot;&gt;versiones&lt;/a&gt; adicionales calificadas por cv de ese tipo ( &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; y &lt;code&gt;const volatile&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ba768967270bb243200289babda957e1dccea676" translate="yes" xml:space="preserve">
          <source>For every valid value of &lt;code&gt;char_type&lt;/code&gt;, there must be a unique value of &lt;code&gt;int_type&lt;/code&gt; distinct from &lt;code&gt;eof()&lt;/code&gt;. For example, a common implementation of &lt;code&gt;char_traits&amp;lt;char&amp;gt;::eof()&lt;/code&gt; is &lt;code&gt;return -1&lt;/code&gt;, and a corresponding valid implementation of &lt;code&gt;char_traits&amp;lt;char&amp;gt;::to_int_type(c)&lt;/code&gt; is &lt;code&gt;return (unsigned char)c&lt;/code&gt;.</source>
          <target state="translated">Para cada valor v&amp;aacute;lido de &lt;code&gt;char_type&lt;/code&gt; , debe haber un valor &amp;uacute;nico de &lt;code&gt;int_type&lt;/code&gt; distinto de &lt;code&gt;eof()&lt;/code&gt; . Por ejemplo, una implementaci&amp;oacute;n com&amp;uacute;n de &lt;code&gt;char_traits&amp;lt;char&amp;gt;::eof()&lt;/code&gt; es &lt;code&gt;return -1&lt;/code&gt; , y una implementaci&amp;oacute;n v&amp;aacute;lida correspondiente de &lt;code&gt;char_traits&amp;lt;char&amp;gt;::to_int_type(c)&lt;/code&gt; es &lt;code&gt;return (unsigned char)c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="220aba5bf092ed62052a3a23de11e863b192c055" translate="yes" xml:space="preserve">
          <source>For every virtual function, there is the</source>
          <target state="translated">Para cada función virtual,existe la</target>
        </trans-unit>
        <trans-unit id="96405e325a2957f41ae4e0cb514953a5e216ba60" translate="yes" xml:space="preserve">
          <source>For example when the regex flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; is set, then the sequence &lt;code&gt;[a-b]&lt;/code&gt; would match some character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform(&quot;a&quot;) &amp;lt;= traits.transform(c1) &amp;lt;= traits.transform(&quot;b&quot;)&lt;/code&gt;. Note that this function takes a character sequence as the argument to accomodate to the ranges defined like &lt;code&gt;[&lt;/code&gt;&lt;code&gt;[.ae.]-d]&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, cuando se establece el indicador regex &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; , la secuencia &lt;code&gt;[a-b]&lt;/code&gt; coincidir&amp;iacute;a con alg&amp;uacute;n car&amp;aacute;cter &lt;code&gt;c1&lt;/code&gt; si &lt;code&gt;traits.transform(&quot;a&quot;) &amp;lt;= traits.transform(c1) &amp;lt;= traits.transform(&quot;b&quot;)&lt;/code&gt; . Tenga en cuenta que esta funci&amp;oacute;n toma una secuencia de caracteres como argumento para acomodar los rangos definidos como &lt;code&gt;[&lt;/code&gt; &lt;code&gt;[.ae.]-d]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="21afdf58d530130e0cd1ecfb369c10eeeccc97f9" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;int b:3;&lt;/code&gt; may have the range of values &lt;code&gt;0..7&lt;/code&gt; or &lt;code&gt;-4..3&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, &lt;code&gt;int b:3;&lt;/code&gt; puede tener el rango de valores &lt;code&gt;0..7&lt;/code&gt; o &lt;code&gt;-4..3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7d231fa0de4c53b5a41ff143b9ff0bc463fe738" translate="yes" xml:space="preserve">
          <source>For example, a gslice with starting index &lt;code&gt;3&lt;/code&gt;, strides &lt;code&gt;{19,4,1&lt;/code&gt;} and lengths &lt;code&gt;{2,4,3} &lt;/code&gt; generates the following set of indices:</source>
          <target state="translated">Por ejemplo, un gslice con &amp;iacute;ndice inicial &lt;code&gt;3&lt;/code&gt; , zancadas &lt;code&gt;{19,4,1&lt;/code&gt; } y longitudes &lt;code&gt;{2,4,3} &lt;/code&gt; genera el siguiente conjunto de &amp;iacute;ndices:</target>
        </trans-unit>
        <trans-unit id="b98b27a6a16bb9a7bf0282ec3a82d51ac5557fa2" translate="yes" xml:space="preserve">
          <source>For example, given &lt;code&gt;const auto&amp;amp; i = expr;&lt;/code&gt;, the type of &lt;code&gt;i&lt;/code&gt; is exactly the type of the argument &lt;code&gt;u&lt;/code&gt; in an imaginary template &lt;code&gt;template&amp;lt;class U&amp;gt; void f(const U&amp;amp; u)&lt;/code&gt; if the function call &lt;code&gt;f(expr)&lt;/code&gt; was compiled. Therefore, &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; may be deduced either as an lvalue reference or rvalue reference according to the initializer, which is used in range-based for loop.</source>
          <target state="translated">Por ejemplo, dado &lt;code&gt;const auto&amp;amp; i = expr;&lt;/code&gt; , el tipo de &lt;code&gt;i&lt;/code&gt; es exactamente el tipo del argumento &lt;code&gt;u&lt;/code&gt; en una plantilla de &lt;code&gt;template&amp;lt;class U&amp;gt; void f(const U&amp;amp; u)&lt;/code&gt; imaginaria &amp;lt;clase U&amp;gt; nula f (const U &amp;amp; u) si se compil&amp;oacute; la llamada a la funci&amp;oacute;n &lt;code&gt;f(expr)&lt;/code&gt; . Por lo tanto, &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; puede deducirse como una referencia de valor o una referencia de valor de acuerdo con el inicializador, que se utiliza en el rango para el bucle.</target>
        </trans-unit>
        <trans-unit id="b64fbd2e8414cb52362895b9416d02f046ec2ac9" translate="yes" xml:space="preserve">
          <source>For example, if a wrapper does not just forward its argument, but calls a member function on the argument, and forwards its result:</source>
          <target state="translated">Por ejemplo,si una envoltura no sólo reenvía su argumento,sino que llama a una función de miembro sobre el argumento,y reenvía su resultado:</target>
        </trans-unit>
        <trans-unit id="3ad08d76cd3366adf2e4002a2a86eba860f92547" translate="yes" xml:space="preserve">
          <source>For example, if used in wrapper such as the following, the template behaves as described below:</source>
          <target state="translated">Por ejemplo,si se utiliza en un envoltorio como el siguiente,la plantilla se comporta como se describe a continuación:</target>
        </trans-unit>
        <trans-unit id="17f92461460ba9421050f5a120102adab4bd7d16" translate="yes" xml:space="preserve">
          <source>For example, in:</source>
          <target state="translated">Por ejemplo,en:</target>
        </trans-unit>
        <trans-unit id="8f787b27b81522ff7994a2b1d11b99ed11a43f0f" translate="yes" xml:space="preserve">
          <source>For example, on Windows, where &lt;code&gt;\&lt;/code&gt; is the preferred separator, the path &lt;code&gt;foo/bar&lt;/code&gt; will be converted to &lt;code&gt;foo\bar&lt;/code&gt;.</source>
          <target state="translated">Por ejemplo, en Windows, donde &lt;code&gt;\&lt;/code&gt; es el separador preferido, la ruta &lt;code&gt;foo/bar&lt;/code&gt; se convertir&amp;aacute; en &lt;code&gt;foo\bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c80798c74b99761f9f8d6a1d7f496bb6f7e553ba" translate="yes" xml:space="preserve">
          <source>For example, on some platforms, bit fields don't straddle bytes, on others they do</source>
          <target state="translated">Por ejemplo,en algunas plataformas,los campos de bits no se extienden a ambos lados de los bytes,en otras sí.</target>
        </trans-unit>
        <trans-unit id="e2df7d9cb75dfece63f96a9945f6d4796b35277d" translate="yes" xml:space="preserve">
          <source>For example, the composite pointer type of &lt;code&gt;void*&lt;/code&gt; and &lt;code&gt;const int*&lt;/code&gt; is &lt;code&gt;const void*&lt;/code&gt;. The composite pointer type of &lt;code&gt;int**&lt;/code&gt; and &lt;code&gt;const int**&lt;/code&gt; is &lt;code&gt;const int* const*&lt;/code&gt;. Note that until C++14, &lt;code&gt;int**&lt;/code&gt; and &lt;code&gt;const int**&lt;/code&gt; could not be compared.</source>
          <target state="translated">Por ejemplo, el tipo de puntero compuesto de &lt;code&gt;void*&lt;/code&gt; y &lt;code&gt;const int*&lt;/code&gt; es &lt;code&gt;const void*&lt;/code&gt; . El tipo de puntero compuesto de &lt;code&gt;int**&lt;/code&gt; y &lt;code&gt;const int**&lt;/code&gt; es &lt;code&gt;const int* const*&lt;/code&gt; . Tenga en cuenta que hasta C ++ 14, &lt;code&gt;int**&lt;/code&gt; y &lt;code&gt;const int**&lt;/code&gt; no se pudieron comparar.</target>
        </trans-unit>
        <trans-unit id="62bb742426a794f8be0f5a25a2d2f7632ae88b7a" translate="yes" xml:space="preserve">
          <source>For example, the following class template does not use the type T in its private members or in the body of push_back.</source>
          <target state="translated">Por ejemplo,la siguiente plantilla de clase no utiliza el tipo T en sus miembros privados o en el cuerpo de push_back.</target>
        </trans-unit>
        <trans-unit id="9c6f9185eeed0381f9dd1d89f296fbc5ee5be5b1" translate="yes" xml:space="preserve">
          <source>For example, to compile &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;;&lt;/code&gt;, the compiler performs:</source>
          <target state="translated">Por ejemplo, para compilar &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;;&lt;/code&gt; , el compilador realiza:</target>
        </trans-unit>
        <trans-unit id="9d4b3358e1df9f2bea37a27eaa5e14ffa2bc6778" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">Por ejemplo, con &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; inicialmente cero,</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="f2cbbd695a1dfd1a4a615d31b844bf65755121de" translate="yes" xml:space="preserve">
          <source>For floating-point &amp;alpha;, the value obtained is the sum of &amp;alpha; independent exponentially distributed random variables, each of which has a mean of &amp;beta;</source>
          <target state="translated">Para &amp;alpha; de punto flotante, el valor obtenido es la suma de variables aleatorias distribuidas exponencialmente independientes &amp;alpha;, cada una de las cuales tiene una media de &amp;beta;</target>
        </trans-unit>
        <trans-unit id="37bba3e4eccd73e2ef72c749ab8c25e15efc6e60" translate="yes" xml:space="preserve">
          <source>For floating-point types with denormalization, &lt;code&gt;min&lt;/code&gt; returns the minimum positive normalized value.</source>
          <target state="translated">Para los tipos de coma flotante con desnormalizaci&amp;oacute;n, &lt;code&gt;min&lt;/code&gt; devuelve el valor normalizado positivo m&amp;iacute;nimo.</target>
        </trans-unit>
        <trans-unit id="b593b953b77c2c511c9c9e8acca67b444d03c30c" translate="yes" xml:space="preserve">
          <source>For floating-point types, if &lt;code&gt;showpoint&lt;/code&gt; is set, the modifier &lt;code&gt;#&lt;/code&gt; is prepended.</source>
          <target state="translated">Para los tipos de punto flotante, si se establece &lt;code&gt;showpoint&lt;/code&gt; , el modificador &lt;code&gt;#&lt;/code&gt; se antepone.</target>
        </trans-unit>
        <trans-unit id="52fff2d809b2cb152e5b4a1ad6291720dc27d5c1" translate="yes" xml:space="preserve">
          <source>For floating-point types, the &lt;a href=&quot;../../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; in effect may be different from the calling thread's floating-point environment. The operation need not be conform to the corresponding &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; traits but is encouraged to do so. If the result is not a representable value for its type, the result is unspecified but the operation otherwise has no undefined behavior.</source>
          <target state="translated">Para los tipos de punto flotante, el &lt;a href=&quot;../../numeric/fenv&quot;&gt;entorno de punto flotante&lt;/a&gt; en efecto puede ser diferente del entorno de punto flotante del hilo de llamada. La operaci&amp;oacute;n no necesita ajustarse a los rasgos &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; correspondientes , pero se recomienda hacerlo. Si el resultado no es un valor representable para su tipo, el resultado no se especifica pero la operaci&amp;oacute;n no tiene un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="5ab94c8e0b590e7f556887eaae16aec44908d571" translate="yes" xml:space="preserve">
          <source>For function and function template names, name lookup can associate multiple declarations with the same name, and may obtain additional declarations from &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;. &lt;a href=&quot;function_template&quot;&gt;Template argument deduction&lt;/a&gt; may also apply, and the set of declarations is passed to &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, which selects the declaration that will be used. &lt;a href=&quot;access&quot;&gt;Member access&lt;/a&gt; rules, if applicable, are considered only after name lookup and overload resolution.</source>
          <target state="translated">Para los nombres de funciones y plantillas de funciones, la b&amp;uacute;squeda de nombres puede asociar varias declaraciones con el mismo nombre y puede obtener declaraciones adicionales de la &lt;a href=&quot;adl&quot;&gt;b&amp;uacute;squeda dependiente&lt;/a&gt; de argumentos . &lt;a href=&quot;function_template&quot;&gt;La deducci&amp;oacute;n de argumentos de plantilla&lt;/a&gt; tambi&amp;eacute;n puede aplicarse, y el conjunto de declaraciones se pasa a la &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; , que selecciona la declaraci&amp;oacute;n que se utilizar&amp;aacute;. &lt;a href=&quot;access&quot;&gt;Las&lt;/a&gt; reglas de acceso de los miembros , si corresponde, se consideran solo despu&amp;eacute;s de la b&amp;uacute;squeda de nombres y la resoluci&amp;oacute;n de sobrecarga.</target>
        </trans-unit>
        <trans-unit id="36d9c94cd9c3cc36a9b671f755d250722c29f111" translate="yes" xml:space="preserve">
          <source>For functions, specifies that the return type will be deduced from its return statements.</source>
          <target state="translated">En el caso de las funciones,especifica que el tipo de devolución se deducirá de sus declaraciones de devolución.</target>
        </trans-unit>
        <trans-unit id="f9d92b090fe79a87f7ef3997de21c665c200fc40" translate="yes" xml:space="preserve">
          <source>For initialization of locals (that is, block scope) static and thread-local variables, see &lt;a href=&quot;storage_duration#Static_local_variables&quot;&gt;static local variables&lt;/a&gt;.</source>
          <target state="translated">Para la inicializaci&amp;oacute;n de variables locales (es decir, alcance de bloque) est&amp;aacute;ticas y locales de hilo, vea &lt;a href=&quot;storage_duration#Static_local_variables&quot;&gt;variables locales est&amp;aacute;ticas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac4327b8179e23975065e9af7bd05ec6be15b5bc" translate="yes" xml:space="preserve">
          <source>For input streams (&lt;code&gt;mode &amp;amp; ios_base::in == true&lt;/code&gt;), &lt;code&gt;eback()&lt;/code&gt; points at the first character, &lt;code&gt;gptr() == eback()&lt;/code&gt;, and &lt;code&gt;egptr() == eback() + s.size()&lt;/code&gt;: the subsequent input will read the first character copied from &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Para flujos de entrada ( &lt;code&gt;mode &amp;amp; ios_base::in == true&lt;/code&gt; ), &lt;code&gt;eback()&lt;/code&gt; apunta al primer car&amp;aacute;cter, &lt;code&gt;gptr() == eback()&lt;/code&gt; y &lt;code&gt;egptr() == eback() + s.size()&lt;/code&gt; : el la entrada posterior leer&amp;aacute; el primer car&amp;aacute;cter copiado de &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec3905377a1c94d495d985035e68f7411ea9980d" translate="yes" xml:space="preserve">
          <source>For input streams (and for update streams on which the last operation was input), the behavior is undefined.</source>
          <target state="translated">Para los flujos de entrada (y para los flujos de actualización en los que se introdujo la última operación),el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="3263d60841f8b602b9cc58bd2747c0e72fde62e4" translate="yes" xml:space="preserve">
          <source>For integer &lt;code&gt;arg&lt;/code&gt;, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.</source>
          <target state="translated">Para el &lt;code&gt;arg&lt;/code&gt; umento entero , el logaritmo binario puede interpretarse como el &amp;iacute;ndice basado en cero del 1 bit m&amp;aacute;s significativo en la entrada.</target>
        </trans-unit>
        <trans-unit id="ed5f0c55df7482886d0bbb61dde66b50525bc79d" translate="yes" xml:space="preserve">
          <source>For integer types, if &lt;code&gt;showbase&lt;/code&gt; is set, the modifier &lt;code&gt;#&lt;/code&gt; is prepended.</source>
          <target state="translated">Para los tipos enteros, si se establece &lt;code&gt;showbase&lt;/code&gt; , el modificador &lt;code&gt;#&lt;/code&gt; se antepone.</target>
        </trans-unit>
        <trans-unit id="cf8479d95c472194fb01daf6a842e55ed66b89af" translate="yes" xml:space="preserve">
          <source>For integer types, length modifier is added to the conversion specification if necessary: &lt;code&gt;h&lt;/code&gt; for &lt;code&gt;short&lt;/code&gt; and &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;ll&lt;/code&gt; for &lt;code&gt;long long&lt;/code&gt; and &lt;code&gt;unsigned long long&lt;/code&gt;</source>
          <target state="translated">Para los tipos enteros, el modificador de longitud se agrega a la especificaci&amp;oacute;n de conversi&amp;oacute;n si es necesario: &lt;code&gt;h&lt;/code&gt; para &lt;code&gt;short&lt;/code&gt; y &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; para &lt;code&gt;long&lt;/code&gt; y &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;ll&lt;/code&gt; para &lt;code&gt;long long&lt;/code&gt; y &lt;code&gt;unsigned long long&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6101d794e56d2d1f4f0a50cfba90d4442ea8210d" translate="yes" xml:space="preserve">
          <source>For integer types, length modifier is added to the conversion specification if necessary: &lt;code&gt;l&lt;/code&gt; for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;ll&lt;/code&gt; for &lt;code&gt;long long&lt;/code&gt; and &lt;code&gt;unsigned long long&lt;/code&gt;(since C++11).</source>
          <target state="translated">Para los tipos enteros, el modificador de longitud se agrega a la especificaci&amp;oacute;n de conversi&amp;oacute;n si es necesario: &lt;code&gt;l&lt;/code&gt; para &lt;code&gt;long&lt;/code&gt; y &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;ll&lt;/code&gt; para &lt;code&gt;long long&lt;/code&gt; y &lt;code&gt;unsigned long long&lt;/code&gt; (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="9635f0a469e86775a961c9f4f06c2d75d2ad2838" translate="yes" xml:space="preserve">
          <source>For integral and arithmetic types, the template argument provided during instantiation must be a &lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of the template parameter's type (so certain implicit conversion applies).</source>
          <target state="translated">Para los tipos integrales y aritm&amp;eacute;ticos, el argumento de plantilla proporcionado durante la creaci&amp;oacute;n de instancias debe ser una &lt;a href=&quot;constant_expression&quot;&gt;expresi&amp;oacute;n constante convertida&lt;/a&gt; del tipo de par&amp;aacute;metro de plantilla (por lo que se aplica cierta conversi&amp;oacute;n impl&amp;iacute;cita).</target>
        </trans-unit>
        <trans-unit id="888e66ad3cd1de9e2997f82859b81050f3f98936" translate="yes" xml:space="preserve">
          <source>For integral arguments, &lt;a href=&quot;abs&quot;&gt;the integral overloads of &lt;code&gt;std::abs&lt;/code&gt;&lt;/a&gt; are likely better matches. If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">Para argumentos integrales, &lt;a href=&quot;abs&quot;&gt;las sobrecargas integrales de &lt;code&gt;std::abs&lt;/code&gt; &lt;/a&gt; son probablemente mejores coincidencias. Si se llama a &lt;code&gt;std::abs&lt;/code&gt; con un argumento de tipo &lt;code&gt;X&lt;/code&gt; ,de modo que &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;X&lt;/code&gt; no se puede convertir a &lt;code&gt;int&lt;/code&gt; por &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;promoci&amp;oacute;n integral&lt;/a&gt; , el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="1060ee889330db82947214695c2314922ae38003" translate="yes" xml:space="preserve">
          <source>For integral operands, it yields the algebraic quotient.</source>
          <target state="translated">Para operandos integrales,produce el cociente algebraico.</target>
        </trans-unit>
        <trans-unit id="88259ad2a8442b91aaef00f672b4f16ecba02e17" translate="yes" xml:space="preserve">
          <source>For lvalue reference parameters, the argument provided at instantiation cannot be a temporary, an unnamed lvalue, or a named lvalue with no linkage (in other words, the argument must have linkage).</source>
          <target state="translated">Para los parámetros de referencia de lvalor,el argumento proporcionado en la instanciación no puede ser un lvalor temporal,un lvalor sin nombre o un lvalor con nombre sin vinculación (en otras palabras,el argumento debe tener vinculación).</target>
        </trans-unit>
        <trans-unit id="07ec985082848563aa89c0c13f4926e059b3c9cc" translate="yes" xml:space="preserve">
          <source>For member functions of class &lt;code&gt;X&lt;/code&gt;, the type of the implicit object parameter is affected by cv-qualifications and ref-qualifications of the member function as described in &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;.</source>
          <target state="translated">Para las funciones miembro de la clase &lt;code&gt;X&lt;/code&gt; , el tipo del par&amp;aacute;metro de objeto impl&amp;iacute;cito se ve afectado por las calificaciones cv y las calificaciones secundarias de la funci&amp;oacute;n miembro como se describe en las &lt;a href=&quot;member_functions&quot;&gt;funciones miembro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19791e90c11ccaf6d487d6bb230d6565f3784cc4" translate="yes" xml:space="preserve">
          <source>For most &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;std::proj(z)==z&lt;/code&gt;, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, 0)&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, -0)&lt;/code&gt;. The sign of the imaginary (zero) component is the sign of &lt;code&gt;&lt;a href=&quot;imag2&quot;&gt;std::imag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="translated">Para la mayor&amp;iacute;a de &lt;code&gt;z&lt;/code&gt; , &lt;code&gt;std::proj(z)==z&lt;/code&gt; , pero todos los infinitos complejos, incluso los n&amp;uacute;meros donde un componente es infinito y el otro es NaN, se convierten en infinito real positivo, &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, 0)&lt;/code&gt; o &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, -0)&lt;/code&gt; . El signo del componente imaginario (cero) es el signo de &lt;code&gt;&lt;a href=&quot;imag2&quot;&gt;std::imag&lt;/a&gt;(z)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedc12147e0e26b892c9c3c4c65e52f5512feb4a" translate="yes" xml:space="preserve">
          <source>For multi-level pointers, the following restrictions apply: a multilevel pointer &lt;code&gt;P1&lt;/code&gt; which is cv1</source>
          <target state="translated">Para punteros multinivel, se aplican las siguientes restricciones: un puntero multinivel &lt;code&gt;P1&lt;/code&gt; que es cv1</target>
        </trans-unit>
        <trans-unit id="376ecc03409163c2995d77d8d27738cf7cb39e45" translate="yes" xml:space="preserve">
          <source>For negative &lt;code&gt;a&lt;/code&gt;, the behavior of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is undefined.</source>
          <target state="translated">Para negativa &lt;code&gt;a&lt;/code&gt; , el comportamiento de &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="1494de8919bb1c4ea96591e8c652173df74c133c" translate="yes" xml:space="preserve">
          <source>For negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is implementation-defined (in most implementations, this performs arithmetic right shift, so that the result remains negative).</source>
          <target state="translated">Para negativa &lt;code&gt;a&lt;/code&gt; , el valor de &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; es definido por la implementaci&amp;oacute;n (en la mayor&amp;iacute;a de las implementaciones, este realiza operaciones aritm&amp;eacute;ticas desplazamiento a la derecha, por lo que el resultado sigue siendo negativo).</target>
        </trans-unit>
        <trans-unit id="8d245548c2af614dd2b79e9d581bbfee18630af5" translate="yes" xml:space="preserve">
          <source>For non-&lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; class types, members with the same &lt;a href=&quot;access&quot;&gt;member access&lt;/a&gt; are always allocated so that the members declared later have higher addresses within a class object. Members with different access control are allocated in unspecified order (the compiler may group them together). Alignment requirements may necessitate padding between members, or after the last member of a class.</source>
          <target state="translated">Para los tipos de clase no &lt;a href=&quot;union&quot;&gt;sindicalizados&lt;/a&gt; , los miembros con el mismo &lt;a href=&quot;access&quot;&gt;acceso de miembro&lt;/a&gt; siempre se asignan para que los miembros declarados m&amp;aacute;s tarde tengan direcciones m&amp;aacute;s altas dentro de un objeto de clase. Los miembros con diferente control de acceso se asignan en un orden no especificado (el compilador puede agruparlos). Los requisitos de alineaci&amp;oacute;n pueden requerir relleno entre los miembros o despu&amp;eacute;s del &amp;uacute;ltimo miembro de una clase.</target>
        </trans-unit>
        <trans-unit id="9b6b58d70b3d593d4d88872f97e32d333db88729" translate="yes" xml:space="preserve">
          <source>For non-appending output streams, &lt;code&gt;pptr() == pbase()&lt;/code&gt;, so that subsequent output will overwrite the characters copied from &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Para las secuencias de salida que no se &lt;code&gt;pptr() == pbase()&lt;/code&gt; , pptr () == pbase () , de modo que la salida posterior sobrescribir&amp;aacute; los caracteres copiados de &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="606fb425d7d848cb68effbf7891839f3901900f6" translate="yes" xml:space="preserve">
          <source>For non-array &lt;code&gt;type&lt;/code&gt;, the single object is constructed in the acquired memory area.</source>
          <target state="translated">Para los no-array &lt;code&gt;type&lt;/code&gt; , el objeto solo se construye en la zona de memoria Adquirida.</target>
        </trans-unit>
        <trans-unit id="2e50302a0b35323ade517a1a99cf0e861fd9f2ad" translate="yes" xml:space="preserve">
          <source>For non-class types, copy and move assignment are indistinguishable and are referred to as</source>
          <target state="translated">Para los tipos que no son de clase,la asignación de copias y mudanzas son indistinguibles y se denominan</target>
        </trans-unit>
        <trans-unit id="961645d5c1ea45b10c1dab6cd681b33d3b3e7623" translate="yes" xml:space="preserve">
          <source>For non-class types, the right operand is first &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to the cv-unqualified type of the left operand, and then its value is copied into the object identified by left operand.</source>
          <target state="translated">Para los tipos que no son de clase, el operando derecho primero se &lt;a href=&quot;implicit_cast&quot;&gt;convierte impl&amp;iacute;citamente&lt;/a&gt; al tipo no calificado por cv del operando izquierdo, y luego su valor se copia en el objeto identificado por el operando izquierdo.</target>
        </trans-unit>
        <trans-unit id="763322c7964e589eee6959c4585b224d003bfdec" translate="yes" xml:space="preserve">
          <source>For non-polymorphic objects, the interpretation of the value is determined from the expression in which the object is used, and is decided at compile time.</source>
          <target state="translated">En el caso de los objetos no polimórficos,la interpretación del valor se determina a partir de la expresión en la que se utiliza el objeto,y se decide en el momento de la compilación.</target>
        </trans-unit>
        <trans-unit id="abfd29ae0e4b12baa41dd1f2957ee892d3a0b889" translate="yes" xml:space="preserve">
          <source>For non-template functions, default arguments can be added to a function that was already declared if the function is redeclared in the same scope. At the point of a function call, the defaults are a union of the defaults provided in all visible declarations for the function. A redeclaration cannot introduce a default for an argument for which a default is already visible (even if the value is the same). A re-declaration in an inner scope does not acquire the default arguments from outer scopes.</source>
          <target state="translated">En el caso de las funciones que no son de plantilla,se pueden añadir argumentos por defecto a una función ya declarada si la función se redeclara en el mismo ámbito.En el momento de la llamada de una función,los valores por defecto son una unión de los valores por defecto proporcionados en todas las declaraciones visibles de la función.Una redeclaración no puede introducir un valor por defecto para un argumento para el que ya está visible un valor por defecto (aunque el valor sea el mismo).Una redeclaración en un ámbito interno no adquiere los argumentos por defecto de los ámbitos externos.</target>
        </trans-unit>
        <trans-unit id="0991570f4540f46325a93449ba04cca879b380b0" translate="yes" xml:space="preserve">
          <source>For non-type template parameter packs whose type uses a placeholder type, the type is independently deduced for each template argument and need not match:</source>
          <target state="translated">En el caso de los paquetes de parámetros de plantilla sin tipo,cuyo tipo utiliza un tipo de marcador de posición,el tipo se deduce de forma independiente para cada argumento de plantilla y no es necesario que coincida:</target>
        </trans-unit>
        <trans-unit id="bd5aba2924605ce9fcbd81eb53c058fae5c7dea4" translate="yes" xml:space="preserve">
          <source>For non-type template parameters, specifies that the type will be deduced from the argument.</source>
          <target state="translated">En el caso de los parámetros de plantilla sin tipo,especifica que el tipo se deducirá del argumento.</target>
        </trans-unit>
        <trans-unit id="7514bfabe1453bf3e4fa04b102092e65768ddd6d" translate="yes" xml:space="preserve">
          <source>For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the move assignment operator performs full member-wise move assignment of the object's direct bases and immediate non-static members, in their declaration order, using built-in assignment for the scalars, memberwise move-assignment for arrays, and move assignment operator for class types (called non-virtually).</source>
          <target state="translated">Para los tipos de clase no sindicalizados ( &lt;code&gt;class&lt;/code&gt; y &lt;code&gt;struct&lt;/code&gt; ), el operador de asignaci&amp;oacute;n de movimiento realiza una asignaci&amp;oacute;n de movimiento completa por miembros de las bases directas del objeto y los miembros no est&amp;aacute;ticos inmediatos, en su orden de declaraci&amp;oacute;n, utilizando la asignaci&amp;oacute;n incorporada para los escalares, miembro mover-asignaci&amp;oacute;n para matrices, y mover operador de asignaci&amp;oacute;n para tipos de clase (llamado no virtualmente).</target>
        </trans-unit>
        <trans-unit id="268fe4cbc20a4aa0215c7d01242785136c98fb6e" translate="yes" xml:space="preserve">
          <source>For nonempty ranges, exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - 1&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">Para rangos no vac&amp;iacute;os, exactamente &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - 1&lt;/code&gt; aplicaciones del predicado correspondiente.</target>
        </trans-unit>
        <trans-unit id="f6180b71feea7358927f872628400b8246c94135" translate="yes" xml:space="preserve">
          <source>For nonempty ranges, exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last) -1&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">Para rangos no vac&amp;iacute;os, exactamente &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last) -1&lt;/code&gt; aplicaciones del predicado correspondiente.</target>
        </trans-unit>
        <trans-unit id="6147555f2527654078938dabd88a3dffc2574f9a" translate="yes" xml:space="preserve">
          <source>For objects of non-aggregate class type, a public &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructor&lt;/a&gt; must be defined (either user-defined or implicitly defined) to satisfy DefaultConstructible.</source>
          <target state="translated">Para los objetos de tipo de clase no agregada, se debe definir un &lt;a href=&quot;../language/default_constructor&quot;&gt;constructor&lt;/a&gt; p&amp;uacute;blico predeterminado (definido por el usuario o impl&amp;iacute;citamente) para satisfacer DefaultConstructible.</target>
        </trans-unit>
        <trans-unit id="5e455249348a9249c3d467d0641b99a240d6d8c9" translate="yes" xml:space="preserve">
          <source>For other contexts where overloaded function names can appear, see &lt;a href=&quot;overloaded_address&quot;&gt;taking the address of an overloaded function&lt;/a&gt;.</source>
          <target state="translated">Para otros contextos donde pueden aparecer nombres de funciones sobrecargadas, vea &lt;a href=&quot;overloaded_address&quot;&gt;tomar la direcci&amp;oacute;n de una funci&amp;oacute;n sobrecargada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2bc8579aeb917ea35ac1bcbad18eb05fd4bdc45" translate="yes" xml:space="preserve">
          <source>For output streams (&lt;code&gt;mode &amp;amp; ios_base::out == true&lt;/code&gt;), &lt;code&gt;pbase()&lt;/code&gt; points at the first character and &lt;code&gt;epptr() &amp;gt;= pbase() + s.size()&lt;/code&gt; (epptr is allowed to point farther so that the following &lt;code&gt;sputc()&lt;/code&gt; wouldn't immediately call &lt;code&gt;overflow()&lt;/code&gt;)</source>
          <target state="translated">Para las secuencias de salida ( &lt;code&gt;mode &amp;amp; ios_base::out == true&lt;/code&gt; ), &lt;code&gt;pbase()&lt;/code&gt; apunta al primer car&amp;aacute;cter y &lt;code&gt;epptr() &amp;gt;= pbase() + s.size()&lt;/code&gt; (epptr puede apuntar m&amp;aacute;s lejos para que el siguiente &lt;code&gt;sputc()&lt;/code&gt; no llamar&amp;iacute;a inmediatamente al &lt;code&gt;overflow()&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8f63d9afe770e3006ba3c31bb680ec6934c94657" translate="yes" xml:space="preserve">
          <source>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the &lt;code&gt;stream&lt;/code&gt;'s buffer to the associated output device.</source>
          <target state="translated">Para las secuencias de salida (y para las secuencias de actualizaci&amp;oacute;n en las que se realiz&amp;oacute; la &amp;uacute;ltima operaci&amp;oacute;n), escribe los datos no escritos de la &lt;code&gt;stream&lt;/code&gt; b&amp;uacute;fer en el dispositivo de salida asociado.</target>
        </trans-unit>
        <trans-unit id="481575f6bdf13b67deef2e241c2a9a6d1c8d891f" translate="yes" xml:space="preserve">
          <source>For output streams, this typically results in writing the contents of the put area into the associated sequence, i.e. flushing of the output buffer. For input streams, this typically empties the get area and forces a re-read from the associated sequence to pick up recent changes. The default behavior (found, for example, in &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;), is to do nothing.</source>
          <target state="translated">Para las secuencias de salida, esto normalmente da como resultado la escritura del contenido del &amp;aacute;rea de colocaci&amp;oacute;n en la secuencia asociada, es decir, el vaciado del b&amp;uacute;fer de salida. Para las secuencias de entrada, esto normalmente vac&amp;iacute;a el &amp;aacute;rea de obtenci&amp;oacute;n y fuerza una relectura de la secuencia asociada para recoger los cambios recientes. El comportamiento predeterminado (encontrado, por ejemplo, en &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; ), es no hacer nada.</target>
        </trans-unit>
        <trans-unit id="a6ae1e52a83b6ade1ae039896874969c5f21c0bf" translate="yes" xml:space="preserve">
          <source>For overload (5), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, const U&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para sobrecarga (5), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, const U&amp;amp;&amp;gt;&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75a2c90c2bfc30a317a46c88b8a56739d5f6fa1d" translate="yes" xml:space="preserve">
          <source>For overload (6), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Para la sobrecarga (6), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2780c151ef71bd4320af5b5a8131bcdca9bcbb78" translate="yes" xml:space="preserve">
          <source>For overloads (1,2), if one of the parameters is an rvalue, the reference returned becomes a dangling reference at the end of the full expression that contains the call to &lt;code&gt;minmax&lt;/code&gt;:</source>
          <target state="translated">Para las sobrecargas (1,2), si uno de los par&amp;aacute;metros es un valor r, la referencia devuelta se convierte en una referencia colgante al final de la expresi&amp;oacute;n completa que contiene la llamada a &lt;code&gt;minmax&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8382a9060c467fcc4ada14b4b211aabe3aa6d683" translate="yes" xml:space="preserve">
          <source>For overloads (3,5,7,9), The function can be implemented with the return type different from &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. In this case, the replacement type has the following properties:</source>
          <target state="translated">Para sobrecargas (3,5,7,9), la funci&amp;oacute;n se puede implementar con el tipo de retorno diferente de &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; . En este caso, el tipo de reemplazo tiene las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="e863547ad76debf1e954b0555a0ab321eb1a4d01" translate="yes" xml:space="preserve">
          <source>For pointers to functions, the valid arguments are pointers to functions with linkage (or constant expressions that evaluate to null pointer values).</source>
          <target state="translated">En el caso de los punteros a funciones,los argumentos válidos son los punteros a funciones con vinculación (o expresiones constantes que evalúan a valores de puntero nulos).</target>
        </trans-unit>
        <trans-unit id="0c14d4f91a6fd67c34187b14315456bf4871a9d3" translate="yes" xml:space="preserve">
          <source>For pointers to member functions and pointers to data members, &lt;code&gt;t1&lt;/code&gt; may be a regular pointer or an object of class type that overloads &lt;code&gt;operator*&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Para punteros a funciones miembro y punteros a miembros de datos, &lt;code&gt;t1&lt;/code&gt; puede ser un puntero regular o un objeto de tipo de clase que sobrecarga al &lt;code&gt;operator*&lt;/code&gt; , como &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a71d4a336a0c5624e650b25202bdefde98d600fd" translate="yes" xml:space="preserve">
          <source>For pointers to members, the argument has to be a pointer to member expressed as &lt;code&gt;&amp;amp;Class::Member&lt;/code&gt; or a constant expression that evaluates to null pointer or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">Para punteros a miembros, el argumento debe ser un puntero a miembro expresado como &lt;code&gt;&amp;amp;Class::Member&lt;/code&gt; o una expresi&amp;oacute;n constante que se eval&amp;uacute;e como puntero nulo o valor &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1d3d2317fc6b323549d75e48efcd87a6d6fa4bd" translate="yes" xml:space="preserve">
          <source>For pointers to objects, the template arguments have to designate the address of a complete object with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; and a &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt; (either internal or external), or a constant expression that evaluates to the appropriate null pointer or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">Para los punteros a los objetos, los argumentos de la plantilla deben designar la direcci&amp;oacute;n de un objeto completo con &lt;a href=&quot;storage_duration&quot;&gt;una duraci&amp;oacute;n de almacenamiento&lt;/a&gt; est&amp;aacute;tico y un &lt;a href=&quot;storage_duration#Linkage&quot;&gt;enlace&lt;/a&gt; (ya sea interno o externo), o una expresi&amp;oacute;n constante que eval&amp;uacute;e el puntero nulo apropiado o el valor &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b3bed6c74847c88d09ff91b5a9eb3064f5365b" translate="yes" xml:space="preserve">
          <source>For portable directory and file naming, see &lt;a href=&quot;../../filesystem&quot;&gt;C++ filesystem library&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem&lt;/a&gt;.</source>
          <target state="translated">Para el directorio port&amp;aacute;til y la nomenclatura de archivos, consulte la &lt;a href=&quot;../../filesystem&quot;&gt;biblioteca del sistema de archivos C ++&lt;/a&gt; o &lt;a href=&quot;http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb935bbe4c86edf17255328af95f195fe665edf1" translate="yes" xml:space="preserve">
          <source>For portable pathname generation from Unicode strings, see &lt;a href=&quot;u8path&quot;&gt;u8path&lt;/a&gt;.</source>
          <target state="translated">Para la generaci&amp;oacute;n de nombre de ruta port&amp;aacute;til a partir de cadenas Unicode, consulte &lt;a href=&quot;u8path&quot;&gt;u8path&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0dfb375daadbb3e77fbf4f5775a23c9dc598be6b" translate="yes" xml:space="preserve">
          <source>For proper values of &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, the following properties are true:</source>
          <target state="translated">Para los valores correctos de &lt;code&gt;i&lt;/code&gt; y &lt;code&gt;j&lt;/code&gt; , las siguientes propiedades son verdaderas:</target>
        </trans-unit>
        <trans-unit id="530c267bd41398cdf37d989d6c0ff07e1066ef3d" translate="yes" xml:space="preserve">
          <source>For prvalue expressions, the dynamic type is always the same as the static type.</source>
          <target state="translated">Para las expresiones de valor,el tipo dinámico es siempre el mismo que el tipo estático.</target>
        </trans-unit>
        <trans-unit id="adfb2dec7da66f103fd2b9cd71521128041db54d" translate="yes" xml:space="preserve">
          <source>For signed &lt;code&gt;Integral&lt;/code&gt; types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results.</source>
          <target state="translated">Para los tipos &lt;code&gt;Integral&lt;/code&gt; signo , la aritm&amp;eacute;tica se define para usar la representaci&amp;oacute;n del complemento a dos. No hay resultados indefinidos.</target>
        </trans-unit>
        <trans-unit id="ed5e530786bebc7b272d33fe3e9f636b75dcece4" translate="yes" xml:space="preserve">
          <source>For signed and non-negative &lt;code&gt;a&lt;/code&gt;, if a * 2b</source>
          <target state="translated">Para a firmado y no negativo &lt;code&gt;a&lt;/code&gt; , si a * 2b</target>
        </trans-unit>
        <trans-unit id="3af751b6ecf63d4481061bc54946dd23bc4bd1ff" translate="yes" xml:space="preserve">
          <source>For signed and non-negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is a * 2b</source>
          <target state="translated">Para a con signo y no negativo &lt;code&gt;a&lt;/code&gt; , el valor de &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; es a * 2b</target>
        </trans-unit>
        <trans-unit id="8d1075cea1a2a6de71e067eda636b7104a7e1c7b" translate="yes" xml:space="preserve">
          <source>For signed integral types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results.</source>
          <target state="translated">Para los tipos integrales con signo, la aritm&amp;eacute;tica se define para usar la representaci&amp;oacute;n del complemento a dos. No hay resultados indefinidos.</target>
        </trans-unit>
        <trans-unit id="7df120d1e9011ddd1ce77a96f4b12ae1b34f6af9" translate="yes" xml:space="preserve">
          <source>For some &lt;code&gt;j&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, &lt;code&gt;X​::​lt(p[j], q[j])&lt;/code&gt; is true and</source>
          <target state="translated">Para algunos &lt;code&gt;j&lt;/code&gt; en &lt;code&gt;[0,n)&lt;/code&gt; , &lt;code&gt;X​::​lt(p[j], q[j])&lt;/code&gt; es verdadero y</target>
        </trans-unit>
        <trans-unit id="81ca343fa42d2babb2e6749bedea9b053e460258" translate="yes" xml:space="preserve">
          <source>For some engines, &quot;fast jump&quot; algorithms are known, which advance the state by many steps (order of millions) without calculating intermediate state transitions, although not necessarily in constant time.</source>
          <target state="translated">Para algunos motores se conocen los algoritmos de &quot;salto rápido&quot;,que hacen avanzar el estado por muchos pasos (del orden de millones)sin calcular las transiciones de estados intermedios,aunque no necesariamente en tiempo constante.</target>
        </trans-unit>
        <trans-unit id="fd4abd3a725738e4ad1d6b4cf76b4fe8cb02df5a" translate="yes" xml:space="preserve">
          <source>For some of the C standard library headers of the form &lt;code&gt;xxx.h&lt;/code&gt;, the C++ standard library both includes an identically-named header and another header of the form &lt;code&gt;cxxx&lt;/code&gt; (all meaningful &lt;code&gt;cxxx&lt;/code&gt; headers are listed above).</source>
          <target state="translated">Para algunos de los encabezados de la biblioteca est&amp;aacute;ndar C del formato &lt;code&gt;xxx.h&lt;/code&gt; , la biblioteca est&amp;aacute;ndar C ++ incluye un encabezado con un nombre id&amp;eacute;ntico y otro encabezado del formulario &lt;code&gt;cxxx&lt;/code&gt; (todos los encabezados significativos &lt;code&gt;cxxx&lt;/code&gt; se enumeran arriba).</target>
        </trans-unit>
        <trans-unit id="cf567f1a3c60615e84656e20417b1a1de74545ac" translate="yes" xml:space="preserve">
          <source>For some of the signals, the implementation may call &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_IGN&lt;/a&gt;)&lt;/code&gt; at the startup of the program. For the rest, the implementation must call &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Para algunas de las se&amp;ntilde;ales, la implementaci&amp;oacute;n puede llamar a &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_IGN&lt;/a&gt;)&lt;/code&gt; al inicio del programa. Por lo dem&amp;aacute;s, la implementaci&amp;oacute;n debe llamar a &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f03372ec69aa391f826e43bea001123512eb679" translate="yes" xml:space="preserve">
          <source>For standard attributes, it will expand to the year and month in which the attribute was added to the working draft (see table below), the presence of vendor-specific attributes is determined by a non-zero value.</source>
          <target state="translated">En el caso de los atributos estándar,se ampliará al año y mes en que se añadió el atributo al borrador de trabajo (véase el cuadro que figura a continuación),la presencia de atributos específicos del proveedor se determina mediante un valor distinto de cero.</target>
        </trans-unit>
        <trans-unit id="b56d8ebf643b96a82d52768c03f8db9aa07210bd" translate="yes" xml:space="preserve">
          <source>For templated functions with deduced return types, the return value may be named in a postcondition without additional restrictions (except that the name of the return value is treated as having a &lt;a href=&quot;../dependent_name#Type-dependent_expressions&quot;&gt;dependent type&lt;/a&gt;). For the non-templated functions with deduced return types, naming the return value is prohibited in declarations (but allowed in the definitions):</source>
          <target state="translated">Para funciones con plantilla con tipos de retorno deducidos, el valor de retorno se puede nombrar en una condici&amp;oacute;n posterior sin restricciones adicionales (excepto que el nombre del valor de retorno se trata como si tuviera un &lt;a href=&quot;../dependent_name#Type-dependent_expressions&quot;&gt;tipo dependiente&lt;/a&gt; ). Para las funciones sin plantilla con tipos de retorno deducidos, el nombre del valor de retorno est&amp;aacute; prohibido en las declaraciones (pero est&amp;aacute; permitido en las definiciones):</target>
        </trans-unit>
        <trans-unit id="6c8bc61f784489c1be269b98b2a834b94911c08f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;A&lt;/code&gt; conversion style</source>
          <target state="translated">Para la &lt;code&gt;A&lt;/code&gt; estilo de conversi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="e2ae91f5c3692945d40532e2d71ac0a4386bf89f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;E&lt;/code&gt; conversion style</source>
          <target state="translated">Para el estilo de conversi&amp;oacute;n &lt;code&gt;E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebb3f8b2a8fff5b3415e1098f326b2c10a1d27f2" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;G&lt;/code&gt; conversion style conversion with style &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt; will be performed.</source>
          <target state="translated">Para el &lt;code&gt;G&lt;/code&gt; conversi&amp;oacute;n estilo de conversi&amp;oacute;n con estilo &lt;code&gt;E&lt;/code&gt; o &lt;code&gt;F&lt;/code&gt; se llevar&amp;aacute; a cabo.</target>
        </trans-unit>
        <trans-unit id="5a1ff43b4f3925bee54ad2942ba18ef8a4606c5a" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;X&lt;/code&gt; conversion letters &lt;code&gt;ABCDEF&lt;/code&gt; are used.</source>
          <target state="translated">Para las letras de conversi&amp;oacute;n &lt;code&gt;X&lt;/code&gt; se usan &lt;code&gt;ABCDEF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57890cceddb7efc24f01d52d8cf7f7dcc8bbc9c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;a&lt;/code&gt; conversion style</source>
          <target state="translated">Para el &lt;code&gt;a&lt;/code&gt; estilo de conversi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="ff2ab4c944a5b84fe46520d57012d6c750be1de1" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;char&lt;/code&gt; specialization, &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;lt&lt;/code&gt; are defined identically to the built-in operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; for type &lt;code&gt;unsigned char&lt;/code&gt; (</source>
          <target state="translated">Para la especializaci&amp;oacute;n &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; y &lt;code&gt;lt&lt;/code&gt; se definen de manera id&amp;eacute;ntica a los operadores integrados &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;&amp;lt;&lt;/code&gt; para el tipo &lt;code&gt;unsigned char&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="41f7d301edd4649ecc9cc5e4ae27295bc06e8657" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;e&lt;/code&gt; conversion style</source>
          <target state="translated">Para el estilo de conversi&amp;oacute;n &lt;code&gt;e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a793f4315aaf80e04799e8d39a2f905e34a3d0ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;g&lt;/code&gt; conversion style conversion with style &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt; will be performed.</source>
          <target state="translated">Para el &lt;code&gt;g&lt;/code&gt; conversi&amp;oacute;n estilo de conversi&amp;oacute;n con estilo &lt;code&gt;e&lt;/code&gt; o &lt;code&gt;f&lt;/code&gt; ser&amp;aacute; realizada.</target>
        </trans-unit>
        <trans-unit id="807d09a568c3d3ab555b52969a3cc98de7806c36" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;x&lt;/code&gt; conversion letters &lt;code&gt;abcdef&lt;/code&gt; are used.</source>
          <target state="translated">Para la conversi&amp;oacute;n &lt;code&gt;x&lt;/code&gt; se usan letras &lt;code&gt;abcdef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="964c75b68c3b67fa44944f427366e59ff71c8628" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, if |arg| &amp;gt; 710.5, then &lt;code&gt;cosh(arg)&lt;/code&gt; overflows.</source>
          <target state="translated">Para el tipo compatible con IEEE &lt;code&gt;double&lt;/code&gt; , if | arg | &amp;gt; 710.5, luego &lt;code&gt;cosh(arg)&lt;/code&gt; desborda .</target>
        </trans-unit>
        <trans-unit id="dc98bc92461ef84f63213928d7e0dd4bec2a4ac3" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, underflow is guaranteed if &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</source>
          <target state="translated">Para el tipo &lt;code&gt;double&lt;/code&gt; compatible con IEEE , el flujo inferior est&amp;aacute; garantizado si &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</target>
        </trans-unit>
        <trans-unit id="5139171c7dc4bf39c00774f4969ee9ed5cb06814" translate="yes" xml:space="preserve">
          <source>For the alphabetic components of the default date format (if any), this function is usually case-insensitive.</source>
          <target state="translated">En el caso de los componentes alfabéticos del formato de fecha predeterminado (si lo hay),esta función suele ser insensible a las mayúsculas y minúsculas.</target>
        </trans-unit>
        <trans-unit id="ca85fb6216b889960979e71b66f45292ecb6fff0" translate="yes" xml:space="preserve">
          <source>For the alphabetic components of the default time format (if any), this function is usually case-insensitive.</source>
          <target state="translated">En el caso de los componentes alfabéticos del formato de tiempo predeterminado (si lo hay),esta función suele ser insensible a las mayúsculas y minúsculas.</target>
        </trans-unit>
        <trans-unit id="3387ca380771e46f30ac460b364c23f3a50ac485" translate="yes" xml:space="preserve">
          <source>For the binary operators (except shifts), if the promoted operands have different types, additional set of implicit conversions is applied, known as</source>
          <target state="translated">En el caso de los operadores binarios (excepto los turnos),si los operandos promocionados tienen diferentes tipos,se aplica un conjunto adicional de conversiones implícitas,conocido como</target>
        </trans-unit>
        <trans-unit id="5834b75a1d37489895cb80d1b1901ebbb10cdea5" translate="yes" xml:space="preserve">
          <source>For the built-in logical AND operator, the result is &lt;code&gt;true&lt;/code&gt; if both operands are &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is &lt;code&gt;false&lt;/code&gt;. This operator is &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;short-circuiting&lt;/a&gt;: if the first operand is &lt;code&gt;false&lt;/code&gt;, the second operand is not evaluated.</source>
          <target state="translated">Para el operador l&amp;oacute;gico AND integrado, el resultado es &lt;code&gt;true&lt;/code&gt; si ambos operandos son &lt;code&gt;true&lt;/code&gt; . De lo contrario, el resultado es &lt;code&gt;false&lt;/code&gt; . Este operador est&amp;aacute; &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;en cortocircuito&lt;/a&gt; : si el primer operando es &lt;code&gt;false&lt;/code&gt; , el segundo operando no se eval&amp;uacute;a.</target>
        </trans-unit>
        <trans-unit id="4f868d872215ad926f03072ef85906893d1cbc9f" translate="yes" xml:space="preserve">
          <source>For the built-in logical NOT operator, the result is &lt;code&gt;true&lt;/code&gt; if the operand is &lt;code&gt;false&lt;/code&gt;. Otherwise, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Para el operador NOT l&amp;oacute;gico incorporado, el resultado es &lt;code&gt;true&lt;/code&gt; si el operando es &lt;code&gt;false&lt;/code&gt; . De lo contrario, el resultado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98a7f937369cdbc13ece1f4624b3c0deaca24c09" translate="yes" xml:space="preserve">
          <source>For the built-in logical OR operator, the result is &lt;code&gt;true&lt;/code&gt; if either the first or the second operand (or both) is &lt;code&gt;true&lt;/code&gt;. This operator is short-circuiting: if the first operand is &lt;code&gt;true&lt;/code&gt;, the second operand is not evaluated.</source>
          <target state="translated">Para el operador OR l&amp;oacute;gico incorporado, el resultado es &lt;code&gt;true&lt;/code&gt; si el primer o el segundo operando (o ambos) es &lt;code&gt;true&lt;/code&gt; . Este operador est&amp;aacute; en cortocircuito: si el primer operando es &lt;code&gt;true&lt;/code&gt; , el segundo operando no se eval&amp;uacute;a.</target>
        </trans-unit>
        <trans-unit id="e1db3901d3c9b8e71a137ee3fd4f6e31711c8ecd" translate="yes" xml:space="preserve">
          <source>For the built-in operator, expression must have arithmetic or unscoped enumeration type. Integral promotion is performed on the operand and determines the type of the result.</source>
          <target state="translated">Para el operador incorporado,la expresión debe tener un tipo de enumeración aritmética o sin alcance.La promoción integral se realiza en el operando y determina el tipo de resultado.</target>
        </trans-unit>
        <trans-unit id="ed7967925e3d9a903dc61fad15c26826b80985cc" translate="yes" xml:space="preserve">
          <source>For the built-in operator, expression must have arithmetic, unscoped enumeration, or pointer type. Integral promotion is performed on the operand if it has integral or unscoped enumeration type and determines the type of the result.</source>
          <target state="translated">Para el operador incorporado,la expresión debe tener un carácter aritmético,de enumeración no circunscrita o de tipo puntero.La promoción integral se realiza en el operando si tiene el tipo de enumeración integral o unscoped y determina el tipo del resultado.</target>
        </trans-unit>
        <trans-unit id="1f4b14dfb9171534a115c48cff5a996c8739f0c3" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must be one of the following:</source>
          <target state="translated">Para el operador incorporado,lhs y rhs debe ser uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="c2fd6c69985c326b9c90b5457d6125aba9680de4" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must both have arithmetic or unscoped enumeration type.</source>
          <target state="translated">Para el operador incorporado,tanto lhs como rhs deben tener un tipo de enumeración aritmética o sin alcance.</target>
        </trans-unit>
        <trans-unit id="21aefc527d6a29a300de35c2b1a6e0de364db29e" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must both have integral or unscoped enumeration type</source>
          <target state="translated">Para el operador incorporado,lhs y rhs deben tener ambos el tipo de enumeración integral o no integral</target>
        </trans-unit>
        <trans-unit id="0e1c1ef458021530f026a00ce0e6a1cdf579bce8" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs may have any non-const scalar type and rhs must be implicitly convertible to the type of lhs.</source>
          <target state="translated">Para el operador incorporado,el lhs puede tener cualquier tipo de escalar no const y el rhs debe ser implícitamente convertible al tipo de lhs.</target>
        </trans-unit>
        <trans-unit id="0fc6e93f0b5ccc41116e96e66ba6cc181fbeaf32" translate="yes" xml:space="preserve">
          <source>For the built-in operators, lhs and rhs must both have integral or unscoped enumeration type. Integral promotions are performed on both operands.</source>
          <target state="translated">Para los operadores incorporados,lhs y rhs deben tener ambos el tipo de enumeración integral o no integral.Las promociones integrales se realizan en ambos operandos.</target>
        </trans-unit>
        <trans-unit id="8b5909dfd25b823a91c25e0c6ebfb4fe115565d4" translate="yes" xml:space="preserve">
          <source>For the built-in operators, lhs and rhs must both have integral or unscoped enumeration type. Usual arithmetic conversions are performed on both operands and determine the type of the result.</source>
          <target state="translated">Para los operadores incorporados,lhs y rhs deben tener ambos el tipo de enumeración integral o no integral.Las conversiones aritméticas habituales se realizan en ambos operandos y determinan el tipo de resultado.</target>
        </trans-unit>
        <trans-unit id="631e90fa71e23701d70b68b196fb2c8886d4ce41" translate="yes" xml:space="preserve">
          <source>For the character sequence &lt;code&gt;[first, last)&lt;/code&gt;, obtains the primary sort key in the imbued locale's collating order, that is, the sort key that is based on the positions of the letters and collation units in the national alphabet, ignoring case, diacritics, variants, etc. If a primary sort key compares less than another primary sort key with &lt;code&gt;operator&amp;lt;&lt;/code&gt;, then the character sequence that produced the first sort key comes before the character sequence that produced the second sort key, in the currently imbued locale's primary collation order.</source>
          <target state="translated">Para la secuencia de caracteres &lt;code&gt;[first, last)&lt;/code&gt; , obtiene la clave de clasificaci&amp;oacute;n primaria en el orden de clasificaci&amp;oacute;n del local imbuido, es decir, la clave de clasificaci&amp;oacute;n que se basa en las posiciones de las letras y las unidades de clasificaci&amp;oacute;n en el alfabeto nacional, ignorando may&amp;uacute;sculas y min&amp;uacute;sculas, signos diacr&amp;iacute;ticos, variantes, etc. Si una clave de clasificaci&amp;oacute;n primaria compara menos que otra clave de clasificaci&amp;oacute;n primaria con el &lt;code&gt;operator&amp;lt;&lt;/code&gt; , entonces la secuencia de caracteres que produjo la primera clave de clasificaci&amp;oacute;n es anterior a la secuencia de caracteres que produjo la segunda clave de clasificaci&amp;oacute;n, en el orden de clasificaci&amp;oacute;n primario de la localidad actualmente imbuida .</target>
        </trans-unit>
        <trans-unit id="e113ddf9e42810bbcd7d53a7fd8437e10332cdc3" translate="yes" xml:space="preserve">
          <source>For the definition of &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&lt;/code&gt;, the following exposition-only concept is defined.</source>
          <target state="translated">Para la definici&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&lt;/code&gt; , se define el siguiente concepto de solo exposici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d1225d08c6a217571442e3f149849eb65e94bce7" translate="yes" xml:space="preserve">
          <source>For the entities that are captured by reference (with the default capture &lt;code&gt;[&amp;amp;]&lt;/code&gt; or when using the character &amp;amp;, e.g. &lt;code&gt;[&amp;amp;a, &amp;amp;b, &amp;amp;c]&lt;/code&gt;), it is unspecified if additional data members are declared in the closure type , but any such additional members must satisfy &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;(since C++17).</source>
          <target state="translated">Para las entidades que se capturan por referencia (con la captura predeterminada &lt;code&gt;[&amp;amp;]&lt;/code&gt; o cuando se usa el car&amp;aacute;cter &amp;amp;, por ejemplo, &lt;code&gt;[&amp;amp;a, &amp;amp;b, &amp;amp;c]&lt;/code&gt; ), no se especifica si se declaran miembros de datos adicionales en el tipo de cierre, pero los miembros adicionales deben satisfacer &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="1a22058978c1262938bcaa97c3c6020766a5ad4e" translate="yes" xml:space="preserve">
          <source>For the first (non-array) form, expression must be a pointer to an object type or a class type &lt;a href=&quot;implicit_cast&quot;&gt;contextually implicitly convertible&lt;/a&gt; to such pointer, and its value must be either</source>
          <target state="translated">Para la primera forma (sin matriz), la expresi&amp;oacute;n debe ser un puntero a un tipo de objeto o un tipo de clase &lt;a href=&quot;implicit_cast&quot;&gt;contextualmente impl&amp;iacute;citamente convertible&lt;/a&gt; a dicho puntero, y su valor debe ser</target>
        </trans-unit>
        <trans-unit id="299adf2377e7d703f91fcfc6dc32f0216b89eb0d" translate="yes" xml:space="preserve">
          <source>For the first (non-const) version, the behavior is undefined if this character is modified to any value other than &lt;code&gt;CharT()&lt;/code&gt; .</source>
          <target state="translated">Para la primera versi&amp;oacute;n (no constante), el comportamiento no est&amp;aacute; definido si este car&amp;aacute;cter se modifica a cualquier valor que no sea &lt;code&gt;CharT()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90655817fab85d8ac14c5bbb029cd02bf793db95" translate="yes" xml:space="preserve">
          <source>For the last two rows of the table, &lt;code&gt;&lt;i&gt;num&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;den&lt;/i&gt;&lt;/code&gt; in the suffix are &lt;code&gt;Period::type::num&lt;/code&gt; and &lt;code&gt;Period::type::den&lt;/code&gt; formatted as a decimal number with no leading zeroes, respectively.</source>
          <target state="translated">Para las dos &amp;uacute;ltimas filas de la tabla, &lt;code&gt;&lt;i&gt;num&lt;/i&gt;&lt;/code&gt; y &lt;code&gt;&lt;i&gt;den&lt;/i&gt;&lt;/code&gt; en el sufijo son &lt;code&gt;Period::type::num&lt;/code&gt; y &lt;code&gt;Period::type::den&lt;/code&gt; formateados como un n&amp;uacute;mero decimal sin ceros a la izquierda, respectivamente.</target>
        </trans-unit>
        <trans-unit id="cbb5833c26a713296ad8005d9e28d5fc0bbfe8a6" translate="yes" xml:space="preserve">
          <source>For the name of a class or class template used within the definition of that class or template or derived from one, unqualified name lookup finds the class that's being defined as if the name was introduced by a member declaration (with public member access). For more detail, see &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt;.</source>
          <target state="translated">Para el nombre de una clase o plantilla de clase utilizada dentro de la definici&amp;oacute;n de esa clase o plantilla o derivada de una, la b&amp;uacute;squeda de nombre no calificada encuentra la clase que se define como si el nombre fuera introducido por una declaraci&amp;oacute;n de miembro (con acceso p&amp;uacute;blico de miembro). Para m&amp;aacute;s detalles, vea &lt;a href=&quot;injected-class-name&quot;&gt;nombre de clase inyectada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43ac5c7c822f021589a3f0df6c74ca1128531b73" translate="yes" xml:space="preserve">
          <source>For the number of elements in the range &lt;code&gt;[first, last)&lt;/code&gt; without any additional criteria, see &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Para conocer el n&amp;uacute;mero de elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; sin ning&amp;uacute;n criterio adicional, vea &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eb35ae41318a2300948bfa04a8b59aa4c523fcb" translate="yes" xml:space="preserve">
          <source>For the objects of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt; (unless they are oversize &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;), every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).</source>
          <target state="translated">Para los objetos de tipo &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; &lt;code&gt;unsigned char&lt;/code&gt; y char sin signo (a menos que sean &lt;a href=&quot;bit_field&quot;&gt;campos de bits de&lt;/a&gt; gran tama&amp;ntilde;o ), se requiere que cada bit de la representaci&amp;oacute;n del objeto participe en la representaci&amp;oacute;n del valor y cada posible patr&amp;oacute;n de bits representa un valor distinto (sin relleno, captura bits, o m&amp;uacute;ltiples representaciones permitidas).</target>
        </trans-unit>
        <trans-unit id="eda418fc0d7e0da6163efe2b320b70eff6e157ef" translate="yes" xml:space="preserve">
          <source>For the overload with an ExecutionPolicy, there may be a performance cost if ForwardIt's value type is not &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">Para la sobrecarga con una ExecutionPolicy, puede haber un costo de rendimiento si el tipo de valor de &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;ForwardIt&lt;/a&gt; no es CopyConstructible .</target>
        </trans-unit>
        <trans-unit id="e5b59a3fe5c4c6ada03047f0bc055b7cec5863b8" translate="yes" xml:space="preserve">
          <source>For the overloads with an ExecutionPolicy, there may be a performance cost if &lt;code&gt;ForwardIt1&lt;/code&gt;'s value_type is not &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">Para las sobrecargas con una ExecutionPolicy, puede haber un costo de rendimiento si &lt;code&gt;ForwardIt1&lt;/code&gt; de ForwardIt1 no es &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca027ab75b905772f5d961e5c587aca010bc2ac6" translate="yes" xml:space="preserve">
          <source>For the overloads with an ExecutionPolicy, there may be a performance cost if the value type of &lt;code&gt;ForwardIterator1&lt;/code&gt; is not both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">Para las sobrecargas con una ExecutionPolicy, puede haber un costo de rendimiento si el tipo de valor de &lt;code&gt;ForwardIterator1&lt;/code&gt; no es tanto &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; como &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf8e99bee770bd19c532d009a039c1a135e9bb1" translate="yes" xml:space="preserve">
          <source>For the purpose of &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, determining the type and value of the &lt;a href=&quot;this&quot;&gt;this pointer&lt;/a&gt; and for accessing non-static class members, the body of the closure type's function call operator is considered in the context of the lambda-expression.</source>
          <target state="translated">Para fines de &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; de nombres , determinar el tipo y el valor de &lt;a href=&quot;this&quot;&gt;este puntero&lt;/a&gt; y para acceder a miembros de clase no est&amp;aacute;ticos, el cuerpo del operador de llamada de funci&amp;oacute;n del tipo de cierre se considera en el contexto de la expresi&amp;oacute;n lambda.</target>
        </trans-unit>
        <trans-unit id="65aeedb9e92b2d4cea74d76c9050bb672b686f5f" translate="yes" xml:space="preserve">
          <source>For the purpose of &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt;, if the next inner allocator is &lt;code&gt;A&lt;/code&gt;, any class &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T,A&amp;gt;::value == true&lt;/code&gt; participates in the recursion as if it was a container. Additionally, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; is treated as such a container by specific overloads of &lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;&lt;code&gt;scoped_allocator_adaptor::construct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para el prop&amp;oacute;sito de &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt; , si el siguiente asignador interno es &lt;code&gt;A&lt;/code&gt; , cualquier clase &lt;code&gt;T&lt;/code&gt; para la cual &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T,A&amp;gt;::value == true&lt;/code&gt; participa en la recursi&amp;oacute;n como si fuera un contenedor. Adem&amp;aacute;s, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; se trata como tal contenedor por sobrecargas espec&amp;iacute;ficas de &lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt; &lt;code&gt;scoped_allocator_adaptor::construct&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cae47b4767abaac03c592dbea46b05ec44cfc59" translate="yes" xml:space="preserve">
          <source>For the purpose of this trait, the extent to which an implementation determines that a type cannot meet the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements is unspecified, except that a minimum &lt;code&gt;T&lt;/code&gt; shall not qualify as a &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; unless it meets all of the following conditions:</source>
          <target state="translated">Para el prop&amp;oacute;sito de este rasgo, el grado en que una implementaci&amp;oacute;n determina que un tipo no puede cumplir con los requisitos del &lt;a href=&quot;../named_req/clock&quot;&gt;Reloj&lt;/a&gt; no se especifica, excepto que un &lt;code&gt;T&lt;/code&gt; m&amp;iacute;nimo no calificar&amp;aacute; como un &lt;a href=&quot;../named_req/clock&quot;&gt;Reloj a&lt;/a&gt; menos que cumpla con todas las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="fbf72513b1cc6b7e687b6187fddcae47438a5f71" translate="yes" xml:space="preserve">
          <source>For the purpose of this trait, two arrays have the same value if their elements have the same values, two non-union classes have the same value if their direct subobjects have the same value, and two unions have the same value if they have the same active member and the value of that member are the same.</source>
          <target state="translated">A efectos de este rasgo,dos matrices tienen el mismo valor si sus elementos tienen los mismos valores,dos clases no sindicadas tienen el mismo valor si sus subobjetos directos tienen el mismo valor,y dos uniones tienen el mismo valor si tienen el mismo miembro activo y el valor de ese miembro es el mismo.</target>
        </trans-unit>
        <trans-unit id="73e5a63a0091c86f2d780d4bd7205bd859be1626" translate="yes" xml:space="preserve">
          <source>For the purpose of unqualified name lookup, all declarations from a namespace nominated by a &lt;a href=&quot;namespace&quot;&gt;using directive&lt;/a&gt; appear as if declared in the nearest enclosing namespace which contains, directly or indirectly, both the using-directive and the nominated namespace.</source>
          <target state="translated">Para fines de b&amp;uacute;squeda de nombres no calificados, todas las declaraciones de un espacio de nombres nominado por una &lt;a href=&quot;namespace&quot;&gt;directiva using&lt;/a&gt; aparecen como si se declararan en el espacio de nombres adjunto m&amp;aacute;s cercano que contiene, directa o indirectamente, la directiva using y el espacio de nombres nominado.</target>
        </trans-unit>
        <trans-unit id="be7ff9400561e79a38fa934ba94eb51a08e444ed" translate="yes" xml:space="preserve">
          <source>For the purposes of the description below, a pointer type &lt;code&gt;Y*&lt;/code&gt; is said to be</source>
          <target state="translated">Para los fines de la descripci&amp;oacute;n a continuaci&amp;oacute;n, se dice que un puntero tipo &lt;code&gt;Y*&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="e8841a4885b112152b14a19649fc94d610b058fa" translate="yes" xml:space="preserve">
          <source>For the purposes of this check, the variable definition is never interpreted as a function declaration, and the use of &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; is not considered an &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to &lt;code&gt;T&lt;/code&gt; and any of the types in &lt;code&gt;Args&lt;/code&gt;. Only the validity of the immediate context of the variable definition is considered.</source>
          <target state="translated">Para los prop&amp;oacute;sitos de esta verificaci&amp;oacute;n, la definici&amp;oacute;n de la variable nunca se interpreta como una declaraci&amp;oacute;n de funci&amp;oacute;n, y el uso de &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; no se considera un &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;uso odr&lt;/a&gt; . &lt;a href=&quot;../language/access&quot;&gt;Las verificaciones de acceso&lt;/a&gt; se realizan como si se &lt;code&gt;Args&lt;/code&gt; de un contexto no relacionado con &lt;code&gt;T&lt;/code&gt; y cualquiera de los tipos de Args . Solo se considera la validez del contexto inmediato de la definici&amp;oacute;n de variable.</target>
        </trans-unit>
        <trans-unit id="0b9a3ac76356afb7c5f4a3ea00f4b7fb14d9e7d4" translate="yes" xml:space="preserve">
          <source>For the rest of overload resolution, the</source>
          <target state="translated">Para el resto de la resolución de la sobrecarga,el</target>
        </trans-unit>
        <trans-unit id="a71380803d7225c2397b15d7056c647fe014ba63" translate="yes" xml:space="preserve">
          <source>For the sake of exposition, assume that &lt;code&gt;regex_iterator&lt;/code&gt; contains the following members:</source>
          <target state="translated">En aras de la exposici&amp;oacute;n, suponga que &lt;code&gt;regex_iterator&lt;/code&gt; contiene los siguientes miembros:</target>
        </trans-unit>
        <trans-unit id="67321d4e15267f4eda7f0452bd90ebdb6e086831" translate="yes" xml:space="preserve">
          <source>For the second (array) form, expression must be a null pointer value or a pointer value previously obtained by an array form of &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;. If expression is anything else, including if it's a pointer obtained by the non-array form of &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;.</source>
          <target state="translated">Para la segunda forma (matriz), la expresi&amp;oacute;n debe ser un valor de puntero nulo o un valor de puntero obtenido previamente por una forma de matriz de &lt;a href=&quot;new&quot;&gt;expresi&amp;oacute;n nueva&lt;/a&gt; . Si la expresi&amp;oacute;n es otra cosa, incluso si es un puntero obtenido por la forma sin matriz de &lt;a href=&quot;new&quot;&gt;nueva expresi&amp;oacute;n&lt;/a&gt; , el comportamiento es &lt;a href=&quot;ub&quot;&gt;indefinido&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9c4273040bcad4221585f3c35b8ea39b7d5d39a" translate="yes" xml:space="preserve">
          <source>For the situations when three-way comparison is not required, &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; provides the usual &lt;a href=&quot;operator_cmp&quot;&gt;relational operators&lt;/a&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc).</source>
          <target state="translated">Para las situaciones en las que no se requiere una comparaci&amp;oacute;n de tres v&amp;iacute;as, &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; proporciona los &lt;a href=&quot;operator_cmp&quot;&gt;operadores relacionales&lt;/a&gt; habituales ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="6f0ec42ffc782d2dbbdc18b148a303310b9bc1a6" translate="yes" xml:space="preserve">
          <source>For the specializations of &lt;code&gt;&lt;a href=&quot;../fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; that are used in the standard library, &lt;code&gt;State&lt;/code&gt; is always &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Para las especializaciones de &lt;code&gt;&lt;a href=&quot;../fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; que se usan en la biblioteca est&amp;aacute;ndar, &lt;code&gt;State&lt;/code&gt; siempre es &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="144964c0df3039e3c71b1f52434a1f307b2a75a0" translate="yes" xml:space="preserve">
          <source>For the static member functions, the</source>
          <target state="translated">Para las funciones del miembro estático,el</target>
        </trans-unit>
        <trans-unit id="eb5c7ff9cfa9a962ebc4d24b7e58d44592b6e8bd" translate="yes" xml:space="preserve">
          <source>For the types that are both &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; and &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, the C++ standard library makes a distinction between</source>
          <target state="translated">Para los tipos que son &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; y &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , la biblioteca est&amp;aacute;ndar de C ++ hace una distinci&amp;oacute;n entre</target>
        </trans-unit>
        <trans-unit id="731f2b2536187de6fbaec0afbeb784f1678b4260" translate="yes" xml:space="preserve">
          <source>For the types that are both &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; and LessThanComparable, the C++ standard library makes a distinction between</source>
          <target state="translated">Para los tipos que son &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; y LessThanComparable, la biblioteca est&amp;aacute;ndar de C ++ hace una distinci&amp;oacute;n entre</target>
        </trans-unit>
        <trans-unit id="a44f5a2bb8a05cc20c72fea8758fde71db78f3d3" translate="yes" xml:space="preserve">
          <source>For the types that are both EqualityComparable and &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, the C++ standard library makes a distinction between</source>
          <target state="translated">Para los tipos que son EqualityComparable y &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , la biblioteca est&amp;aacute;ndar de C ++ hace una distinci&amp;oacute;n entre</target>
        </trans-unit>
        <trans-unit id="ea9de19131b3606684b0baafb3d2151f5a32dd40" translate="yes" xml:space="preserve">
          <source>For the use in derived class definitions, see &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;.</source>
          <target state="translated">Para el uso en definiciones de clase derivadas, consulte el &lt;a href=&quot;using_declaration&quot;&gt;uso de la declaraci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48183fff740905d93ae3026fe871d3be4a4d9ec5" translate="yes" xml:space="preserve">
          <source>For two different parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are not equal, the probability that &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; should be very small, approaching &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_t&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">Para dos par&amp;aacute;metros diferentes &lt;code&gt;k1&lt;/code&gt; y &lt;code&gt;k2&lt;/code&gt; que no son iguales, la probabilidad de que &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; deber&amp;iacute;a ser muy peque&amp;ntilde;a, cercana a &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_t&amp;gt;::max()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc4402b538e707e656178152f7bd8d1b40d16256" translate="yes" xml:space="preserve">
          <source>For two parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are equal, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt;.</source>
          <target state="translated">Para dos par&amp;aacute;metros &lt;code&gt;k1&lt;/code&gt; y &lt;code&gt;k2&lt;/code&gt; que son iguales, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94a3ad0257f1ac1480c81596b592db0d4b3511aa" translate="yes" xml:space="preserve">
          <source>For two-digit input values, many implementations use the same parsing rules as the conversion specifier &lt;code&gt;'%y'&lt;/code&gt; as used by &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;get&quot;&gt;std::time_get::get()&lt;/a&gt;&lt;/code&gt;, and the POSIX function &lt;code&gt;strptime()&lt;/code&gt;: two-digit integer is expected, the values in the range [69,99] results in values 1969 to 1999, range [00,68] results in 2000-2068. Four-digit inputs are typically accepted as-is.</source>
          <target state="translated">Para valores de entrada de dos d&amp;iacute;gitos, muchas implementaciones usan las mismas reglas de an&amp;aacute;lisis que el especificador de conversi&amp;oacute;n &lt;code&gt;'%y'&lt;/code&gt; como lo usan &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;get&quot;&gt;std::time_get::get()&lt;/a&gt;&lt;/code&gt; y la funci&amp;oacute;n POSIX &lt;code&gt;strptime()&lt;/code&gt; : two- se espera un n&amp;uacute;mero entero de d&amp;iacute;gitos, los valores en el rango [69,99] dan como resultado valores de 1969 a 1999, el rango [00,68] da como resultado 2000-2068. Las entradas de cuatro d&amp;iacute;gitos generalmente se aceptan tal cual.</target>
        </trans-unit>
        <trans-unit id="642cd801d14b4a66f154da3cc51856b49e293f28" translate="yes" xml:space="preserve">
          <source>For two-way comparisons, &lt;a href=&quot;operator_cmp&quot;&gt;binary operators&lt;/a&gt; may be more suitable.</source>
          <target state="translated">Para las comparaciones de dos v&amp;iacute;as, &lt;a href=&quot;operator_cmp&quot;&gt;los operadores binarios&lt;/a&gt; pueden ser m&amp;aacute;s adecuados.</target>
        </trans-unit>
        <trans-unit id="fe584cd3d04227e8ee6e63e57235b2b1a239458e" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be BasicLockable, the following conditions have to be satisfied for an object &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;L&lt;/code&gt;:</source>
          <target state="translated">Para que el tipo &lt;code&gt;L&lt;/code&gt; sea ​​BasicLockable, se deben cumplir las siguientes condiciones para un objeto &lt;code&gt;m&lt;/code&gt; de tipo &lt;code&gt;L&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a492045a60cf54bb3785e73eca1da2d9437cc013" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be Lockable, it must meet the above condition as well as the following:</source>
          <target state="translated">Para que el tipo &lt;code&gt;L&lt;/code&gt; sea ​​bloqueable, debe cumplir la condici&amp;oacute;n anterior as&amp;iacute; como lo siguiente:</target>
        </trans-unit>
        <trans-unit id="3192f26467193016e7a310e7cb38a3fb281f3879" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be TimedLockable, the following conditions have to be satisfied for an object &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;L&lt;/code&gt;:</source>
          <target state="translated">Para que el tipo &lt;code&gt;L&lt;/code&gt; sea ​​TimedLockable, se deben cumplir las siguientes condiciones para un objeto &lt;code&gt;m&lt;/code&gt; del tipo &lt;code&gt;L&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e5e7522e5abd30c0f3d5e5a223c5721c59cbeef9" translate="yes" xml:space="preserve">
          <source>For unsigned &lt;code&gt;a&lt;/code&gt; and for signed and non-negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is the integer part of a/2b</source>
          <target state="translated">Para unsigned &lt;code&gt;a&lt;/code&gt; y para firmado y no negativo &lt;code&gt;a&lt;/code&gt; , el valor de &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; es la parte entera de a / 2b</target>
        </trans-unit>
        <trans-unit id="aebdb0e43e858256601ff6d8a7d5738865f2a1f9" translate="yes" xml:space="preserve">
          <source>For unsigned &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is the value of a * 2b</source>
          <target state="translated">Para sin signo &lt;code&gt;a&lt;/code&gt; , el valor de &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; es el valor de a * 2b</target>
        </trans-unit>
        <trans-unit id="d49c3968569060d907f70256e73011fe41b82ee7" translate="yes" xml:space="preserve">
          <source>For variables and other names introduced by simple declarations, the point of declaration is immediately after that name's &lt;a href=&quot;declarations#Declarators&quot;&gt;declarator&lt;/a&gt; and before its initializer, if any:</source>
          <target state="translated">Para las variables y otros nombres introducidos por declaraciones simples, el punto de declaraci&amp;oacute;n es inmediatamente despu&amp;eacute;s del &lt;a href=&quot;declarations#Declarators&quot;&gt;declarador de&lt;/a&gt; ese nombre y antes de su inicializador, si corresponde:</target>
        </trans-unit>
        <trans-unit id="4406791fdc0c802a309313fed6968b3cbed9aba4" translate="yes" xml:space="preserve">
          <source>For variables, specifies that the type of the variable that is being declared will be automatically deduced from its initializer.</source>
          <target state="translated">En el caso de las variables,especifica que el tipo de la variable que se declara se deducirá automáticamente de su inicializador.</target>
        </trans-unit>
        <trans-unit id="5c276069327cb6d9e2ff643e9fb634c6f1cb43de" translate="yes" xml:space="preserve">
          <source>For version (2), the number of arguments must be the same as the number of parameters in macro definition. For versions (3,4), the number of arguments must be more than(until C++20)at least as many as(since C++20) the number of parameters (not counting &lt;code&gt;...&lt;/code&gt;). Otherwise the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.</source>
          <target state="translated">Para la versi&amp;oacute;n (2), el n&amp;uacute;mero de argumentos debe ser el mismo que el n&amp;uacute;mero de par&amp;aacute;metros en la definici&amp;oacute;n de macro. Para las versiones (3,4), el n&amp;uacute;mero de argumentos debe ser mayor que (hasta C ++ 20) al menos tantos (desde C ++ 20) el n&amp;uacute;mero de par&amp;aacute;metros (sin contar &lt;code&gt;...&lt;/code&gt; ). De lo contrario, el programa est&amp;aacute; mal formado. Si el identificador no est&amp;aacute; en notaci&amp;oacute;n funcional, es decir, no tiene par&amp;eacute;ntesis, no se reemplaza en absoluto.</target>
        </trans-unit>
        <trans-unit id="1eb818e764a2afb52d153586d87b0ff7106e9cc9" translate="yes" xml:space="preserve">
          <source>For versions (3,4), replacement-list may contain the token sequence &lt;code&gt;__VA_OPT__ (&lt;/code&gt;content&lt;code&gt;)&lt;/code&gt;, which is replaced by content if &lt;code&gt;__VA_ARGS__&lt;/code&gt; is non-empty, and expands to nothing otherwise.</source>
          <target state="translated">Para las versiones (3,4), la lista de reemplazo puede contener la secuencia de tokens &lt;code&gt;__VA_OPT__ (&lt;/code&gt; contenido &lt;code&gt;)&lt;/code&gt; , que se reemplaza por contenido si &lt;code&gt;__VA_ARGS__&lt;/code&gt; no est&amp;aacute; vac&amp;iacute;o y, de lo contrario, se expande a nada.</target>
        </trans-unit>
        <trans-unit id="689abf1f4ab72838db75e84748d7996dea17600f" translate="yes" xml:space="preserve">
          <source>For virtual calls (if the bases are initialized), the same rules apply as the rules for the virtual calls from constructors and destructors: virtual member functions behave as if the dynamic type of &lt;code&gt;*this&lt;/code&gt; is the class that's being constructed (dynamic dispatch does not propagate down the inheritance hierarchy) and virtual calls (but not static calls) to &lt;a href=&quot;abstract_class&quot;&gt;pure virtual&lt;/a&gt; member functions are undefined behavior.</source>
          <target state="translated">Para las llamadas virtuales (si las bases se inicializan), se aplican las mismas reglas que las reglas para las llamadas virtuales de constructores y destructores: las funciones miembro virtuales se comportan como si el tipo din&amp;aacute;mico de &lt;code&gt;*this&lt;/code&gt; es la clase que se est&amp;aacute; construyendo (el despacho din&amp;aacute;mico no propagarse por la jerarqu&amp;iacute;a de herencia) y las llamadas virtuales (pero no las llamadas est&amp;aacute;ticas) a funciones de miembro &lt;a href=&quot;abstract_class&quot;&gt;virtual puro&lt;/a&gt; son comportamientos indefinidos.</target>
        </trans-unit>
        <trans-unit id="0c5f085443078183be6555b610a3066515f2b25f" translate="yes" xml:space="preserve">
          <source>For zero-sized arrays,</source>
          <target state="translated">Para matrices de tamaño cero,</target>
        </trans-unit>
        <trans-unit id="0a460a0808dc0afa3b1cab6d45b0c32f450b8082" translate="yes" xml:space="preserve">
          <source>Forcing a copy assignment operator to be generated by the compiler.</source>
          <target state="translated">Obligando a un operador de asignación de copias a ser generado por el compilador.</target>
        </trans-unit>
        <trans-unit id="11ad1e8557a20546e9537fc0a5b3a329b83d8d13" translate="yes" xml:space="preserve">
          <source>Forcing a copy constructor to be generated by the compiler.</source>
          <target state="translated">Obligando a un constructor de copias a ser generado por el compilador.</target>
        </trans-unit>
        <trans-unit id="dd180500aac427aa2facdbe0b7cd406cce37ac98" translate="yes" xml:space="preserve">
          <source>Forcing a move assignment operator to be generated by the compiler.</source>
          <target state="translated">Obligando a un operador de asignación de movimientos a ser generado por el compilador.</target>
        </trans-unit>
        <trans-unit id="b5ea5bcf5fc337ca9689a82c3a3c7580484f1408" translate="yes" xml:space="preserve">
          <source>Forcing a move constructor to be generated by the compiler.</source>
          <target state="translated">Obligando a un constructor de movimientos a ser generado por el compilador.</target>
        </trans-unit>
        <trans-unit id="72ef49edf9ca8e31454f8e3e5987fc43ac16422c" translate="yes" xml:space="preserve">
          <source>Form (3) is a special case of elaborated type specifier, usually referred to as</source>
          <target state="translated">El formulario 3)es un caso especial de especificador de tipo elaborado,denominado habitualmente</target>
        </trans-unit>
        <trans-unit id="3851c6a3b646b09f934a18b67d308cc11979b8c6" translate="yes" xml:space="preserve">
          <source>Formal definition of</source>
          <target state="translated">Definición formal de</target>
        </trans-unit>
        <trans-unit id="617d00cd751356da85b2e1f1f2eca6aa12a756a0" translate="yes" xml:space="preserve">
          <source>Formal description</source>
          <target state="translated">Descripción formal</target>
        </trans-unit>
        <trans-unit id="3bfb55cdc85542de2eeac7c01ac22e44b5143662" translate="yes" xml:space="preserve">
          <source>Formally,</source>
          <target state="translated">Formally,</target>
        </trans-unit>
        <trans-unit id="be2c3615928f7aa5bc5a7d980eb4d06a17642a73" translate="yes" xml:space="preserve">
          <source>Formally, &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; is satisfied only if, given any lvalue &lt;code&gt;t&lt;/code&gt; of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and any lvalue &lt;code&gt;u&lt;/code&gt; of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;, and let &lt;code&gt;C&lt;/code&gt; be &lt;code&gt;&lt;a href=&quot;../types/common_reference&quot;&gt;std::common_reference_t&lt;/a&gt;&amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;amp;, const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;&amp;gt;&lt;/code&gt; :</source>
          <target state="translated">Formalmente, &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; se satisface solo si, dado cualquier valor &lt;code&gt;t&lt;/code&gt; de tipo &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; y cualquier valor &lt;code&gt;u&lt;/code&gt; de tipo &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; , y deja que &lt;code&gt;C&lt;/code&gt; sea &lt;code&gt;&lt;a href=&quot;../types/common_reference&quot;&gt;std::common_reference_t&lt;/a&gt;&amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;amp;, const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ac3a456d751219d7a66e0d0371e02798d8d5d3ea" translate="yes" xml:space="preserve">
          <source>Formally, a substring &lt;code&gt;str&lt;/code&gt; is said to be</source>
          <target state="translated">Formalmente, se dice que una &lt;code&gt;str&lt;/code&gt; subcadena es</target>
        </trans-unit>
        <trans-unit id="8819ae53d6eeeb966d61dd310165099d50cdc3e7" translate="yes" xml:space="preserve">
          <source>Formally, a template template-parameter &lt;code&gt;P&lt;/code&gt; is at least as specialized as a template template argument &lt;code&gt;A&lt;/code&gt; if, given the following rewrite to two function templates, the function template corresponding to &lt;code&gt;P&lt;/code&gt; is at least as specialized as the function template corresponding to &lt;code&gt;A&lt;/code&gt; according to the partial ordering rules for &lt;a href=&quot;function_template&quot;&gt;function templates&lt;/a&gt;. Given an invented class template &lt;code&gt;X &lt;/code&gt; with the template parameter list of &lt;code&gt;A&lt;/code&gt; (including default arguments):</source>
          <target state="translated">Formalmente, un par&amp;aacute;metro de plantilla de plantilla &lt;code&gt;P&lt;/code&gt; es al menos tan especializado como un argumento de plantilla de plantilla &lt;code&gt;A&lt;/code&gt; si, dada la siguiente reescritura de dos plantillas de funci&amp;oacute;n, la plantilla de funci&amp;oacute;n correspondiente a &lt;code&gt;P&lt;/code&gt; es al menos tan especializada como la plantilla de funci&amp;oacute;n correspondiente a &lt;code&gt;A&lt;/code&gt; de acuerdo con Las reglas de ordenamiento parcial para &lt;a href=&quot;function_template&quot;&gt;plantillas de funciones&lt;/a&gt; . Dada una plantilla de clase inventada &lt;code&gt;X &lt;/code&gt; con la lista de par&amp;aacute;metros de plantilla de &lt;code&gt;A&lt;/code&gt; (incluidos los argumentos predeterminados):</target>
        </trans-unit>
        <trans-unit id="117e56a1f0fa17b3f88e2093765a4fbfc78944a1" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of &lt;code&gt;init, *j...&lt;/code&gt; for every &lt;code&gt;j&lt;/code&gt; in [first, first + (i - d_first)) over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">Formalmente, asigna a trav&amp;eacute;s de cada iterador &lt;code&gt;i&lt;/code&gt; en [d_first, d_first + (last - first)) el valor de la suma no conmutativa generalizada de &lt;code&gt;init, *j...&lt;/code&gt; por cada &lt;code&gt;j&lt;/code&gt; en [first, first + (i - d_first)) sobre &lt;code&gt;binary_op&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="67dce949f95f6583a76648b394095c1ec1ca39c5" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of &lt;code&gt;init, unary_op(*j)...&lt;/code&gt; for every &lt;code&gt;j&lt;/code&gt; in [first, first + (i - d_first)) over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">Formalmente, asigna a trav&amp;eacute;s de cada iterador &lt;code&gt;i&lt;/code&gt; en [d_first, d_first + (last - first)) el valor de la suma generalizada no conmutativa de &lt;code&gt;init, unary_op(*j)...&lt;/code&gt; para cada &lt;code&gt;j&lt;/code&gt; en [first, first + (i - d_first )) sobre &lt;code&gt;binary_op&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="95a3ed38da232217c4f6f08f54e48cb7d257ddec" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of.</source>
          <target state="translated">Formalmente, asigna a trav&amp;eacute;s de cada iterador &lt;code&gt;i&lt;/code&gt; en [d_first, d_first + (last - first)) el valor de.</target>
        </trans-unit>
        <trans-unit id="42355d6a7c2d7676346a2158f0e06426adf8925e" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of:</source>
          <target state="translated">Formalmente, asigna a trav&amp;eacute;s de cada iterador &lt;code&gt;i&lt;/code&gt; en [d_first, d_first + (last - first)) el valor de:</target>
        </trans-unit>
        <trans-unit id="aa803427d4e1d44c6149f49a34143aabb8a952e0" translate="yes" xml:space="preserve">
          <source>Formally, for each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, count)&lt;/code&gt;, performs &lt;code&gt;assign(src[i], dest[i])&lt;/code&gt;.</source>
          <target state="translated">Formalmente, para cada &lt;code&gt;i&lt;/code&gt; en &lt;code&gt;[0, count)&lt;/code&gt; , realiza la &lt;code&gt;assign(src[i], dest[i])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="554c2426b4e5c1f78a13a29231a721f516bd1cbf" translate="yes" xml:space="preserve">
          <source>Formally, given an expression &lt;code&gt;E&lt;/code&gt; such that &lt;code&gt;decltype((E))&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; and an lvalue &lt;code&gt;t&lt;/code&gt; that denotes the same object as &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; models &lt;code&gt;__ForwardingRange&lt;/code&gt; only if.</source>
          <target state="translated">Formalmente, dada una expresi&amp;oacute;n &lt;code&gt;E&lt;/code&gt; tal que &lt;code&gt;decltype((E))&lt;/code&gt; es &lt;code&gt;T&lt;/code&gt; y un valor &lt;code&gt;t&lt;/code&gt; que denota el mismo objeto que &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; modela &lt;code&gt;__ForwardingRange&lt;/code&gt; solo si.</target>
        </trans-unit>
        <trans-unit id="f43c3db9c814c3ddff2a854cf059e58f985b2721" translate="yes" xml:space="preserve">
          <source>Formally, given an expression &lt;code&gt;E&lt;/code&gt; such that &lt;code&gt;decltype((E))&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; models &lt;code&gt;&lt;a href=&quot;../range/range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; only if.</source>
          <target state="translated">Formalmente, dada una expresi&amp;oacute;n &lt;code&gt;E&lt;/code&gt; tal que &lt;code&gt;decltype((E))&lt;/code&gt; es &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; modela el &lt;code&gt;&lt;a href=&quot;../range/range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; solo si.</target>
        </trans-unit>
        <trans-unit id="067b1a2613c21e1fd48648c5caa1394000d7f227" translate="yes" xml:space="preserve">
          <source>Formally, given.</source>
          <target state="translated">Formalmente,dado.</target>
        </trans-unit>
        <trans-unit id="b90f213e247d65d8f658b379e51068d2511abb68" translate="yes" xml:space="preserve">
          <source>Formally, if &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are expressions, and &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype((E))&amp;gt;&lt;/code&gt;, then.</source>
          <target state="translated">Formalmente, si &lt;code&gt;E&lt;/code&gt; y &lt;code&gt;F&lt;/code&gt; son expresiones, y &lt;code&gt;T&lt;/code&gt; es del tipo &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype((E))&amp;gt;&lt;/code&gt; , entonces.</target>
        </trans-unit>
        <trans-unit id="67f89cac3a2bdd1a32a9d4e925980ecdcd1ff780" translate="yes" xml:space="preserve">
          <source>Formally, returns a value &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Formalmente, devuelve un valor &lt;code&gt;e&lt;/code&gt; tal que &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; para todos los valores &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba8bfc3113f8f3e8c405a965d6f37d86be2d7991" translate="yes" xml:space="preserve">
          <source>Formally, returns the value &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;X::eq_int_type(c, X::to_int_type(x))&lt;/code&gt; is true, and an unspecified value if no such &lt;code&gt;x&lt;/code&gt; exists.</source>
          <target state="translated">Formalmente, devuelve el valor &lt;code&gt;x&lt;/code&gt; tal que &lt;code&gt;X::eq_int_type(c, X::to_int_type(x))&lt;/code&gt; es verdadero y un valor no especificado si no existe tal &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52d033134dacb8018588f4302d9453d80ec19597" translate="yes" xml:space="preserve">
          <source>Formally, the</source>
          <target state="translated">Formalmente,el</target>
        </trans-unit>
        <trans-unit id="52e0a6f1e0d63a4dd3bc991539c544e18482cfab" translate="yes" xml:space="preserve">
          <source>Formally, the C++ standard makes no guarantee on the accuracy of floating-point operations.</source>
          <target state="translated">Formalmente,el estándar C++no garantiza la precisión de las operaciones de punto flotante.</target>
        </trans-unit>
        <trans-unit id="95a4b2acf26b1c49aea8abebe466f09b5002e38b" translate="yes" xml:space="preserve">
          <source>Formally, the syntax is.</source>
          <target state="translated">Formalmente,la sintaxis es.</target>
        </trans-unit>
        <trans-unit id="3e6350defe07d4e2839cc6eb5191b1da5190bee4" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the integral part of log</source>
          <target state="translated">Formalmente,el exponente imparcial es la parte integral de la bitácora</target>
        </trans-unit>
        <trans-unit id="91dd56eddc735a099ddc37f2c2b8d705630baadf" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the signed integral part of log</source>
          <target state="translated">Formalmente,el exponente imparcial es la parte integral firmada del tronco</target>
        </trans-unit>
        <trans-unit id="8179a0c7fe36d2a8a17e5adad38978ddb099049d" translate="yes" xml:space="preserve">
          <source>Formally, to determine which of any two function templates is more specialized, the partial ordering process first transforms one of the two templates as follows:</source>
          <target state="translated">Formalmente,para determinar cuál de las dos plantillas de funciones es más especializada,el proceso de ordenamiento parcial transforma primero una de las dos plantillas de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="3636bbcd81222a968d5588186dbdf6c4b0b042e0" translate="yes" xml:space="preserve">
          <source>Formally, to establish more-specialized-than relationship between partial specializations, each is first converted to a fictitious function template as follows:</source>
          <target state="translated">Formalmente,para establecer una relación más especializada que la que existe entre las especializaciones parciales,cada una se convierte primero en una plantilla de funciones ficticias,como se indica a continuación:</target>
        </trans-unit>
        <trans-unit id="f2967eb9e0cfcedd6a189b6a8d3866a634ebbc35" translate="yes" xml:space="preserve">
          <source>Formally.</source>
          <target state="translated">Formally.</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="9d6e5b21d4a23bd5ccd62830a8a750d8fe1ca459" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">Constantes de formato para la familia de funciones &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2baad9ad4884ebddda05c6c67af479131ae29e6b" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">Constantes de formato para la familia de funciones &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b8afd05c64332502d3616cc67779e98de2c7168" translate="yes" xml:space="preserve">
          <source>Format conversions</source>
          <target state="translated">Conversión de formatos</target>
        </trans-unit>
        <trans-unit id="7175d023e27abe317865a491022a09c5f080a380" translate="yes" xml:space="preserve">
          <source>Format macro constants</source>
          <target state="translated">Formato de las constantes macro</target>
        </trans-unit>
        <trans-unit id="9316b4e7eba6949a72f828ee21024df921672e3c" translate="yes" xml:space="preserve">
          <source>Format observers</source>
          <target state="translated">Formato de los observadores</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">Formato de la cadena</target>
        </trans-unit>
        <trans-unit id="c4bb81b6ba2e3eacfc477a97d7def7d80d2c55be" translate="yes" xml:space="preserve">
          <source>Formats monetary value and writes the result to output stream.</source>
          <target state="translated">Formatea el valor monetario y escribe el resultado en el flujo de salida.</target>
        </trans-unit>
        <trans-unit id="7c20d6ad01a878bb9e8639e10169a49131276aca" translate="yes" xml:space="preserve">
          <source>Formats the streamable object &lt;code&gt;s&lt;/code&gt; using the format string &lt;code&gt;fmt&lt;/code&gt; and the locale &lt;code&gt;loc&lt;/code&gt; (if provided).</source>
          <target state="translated">Formatea el objeto transmisible &lt;code&gt;s&lt;/code&gt; usando la cadena de formato &lt;code&gt;fmt&lt;/code&gt; y la configuraci&amp;oacute;n regional &lt;code&gt;loc&lt;/code&gt; (si existe).</target>
        </trans-unit>
        <trans-unit id="8bf1052f7f8c855373309b9742ea3d34a8c56846" translate="yes" xml:space="preserve">
          <source>Formatted input</source>
          <target state="translated">Entrada con formato</target>
        </trans-unit>
        <trans-unit id="ee59b03a5ff5c727bd5ce0a27fd2bc91e970bc1f" translate="yes" xml:space="preserve">
          <source>Formatted input/output</source>
          <target state="translated">Entrada/salida formateada</target>
        </trans-unit>
        <trans-unit id="c7cf7a590d478b0b7b99c49e642af36f47cd56e2" translate="yes" xml:space="preserve">
          <source>Formatted output</source>
          <target state="translated">Salida formateada</target>
        </trans-unit>
        <trans-unit id="722101e27f69cbe90326b9ee974bad21c5f7f772" translate="yes" xml:space="preserve">
          <source>Formatted output functions &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../manip/put_time&quot;&gt;std::put_time&lt;/a&gt;&lt;/code&gt;, if they encounter the end of the output stream before completing output.</source>
          <target state="translated">Funciones de salida formateadas &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;operador &amp;lt;&amp;lt;&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../manip/put_time&quot;&gt;std::put_time&lt;/a&gt;&lt;/code&gt; , si encuentran el final de la secuencia de salida antes de completar la salida.</target>
        </trans-unit>
        <trans-unit id="c36735a1b156faf0d8948786e00b3f1ee63bfe64" translate="yes" xml:space="preserve">
          <source>FormattedInputFunction</source>
          <target state="translated">FormattedInputFunction</target>
        </trans-unit>
        <trans-unit id="8ad283919e38bfa7958b6669077f83561656b04b" translate="yes" xml:space="preserve">
          <source>FormattedOutputFunction</source>
          <target state="translated">FormattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="841f832857c780b47f478b4f21d34d8995af64b8" translate="yes" xml:space="preserve">
          <source>Formatting</source>
          <target state="translated">Formatting</target>
        </trans-unit>
        <trans-unit id="4f6565ce2772bffe98b3ba5983af96ce7e5de363" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; literal representing an imaginary number.</source>
          <target state="translated">Forma un &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; literal que representa un n&amp;uacute;mero imaginario.</target>
        </trans-unit>
        <trans-unit id="643fc7954cfd8223ed9cf2e31d62065c242ec93d" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing hours.</source>
          <target state="translated">Forma un &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal que representa horas.</target>
        </trans-unit>
        <trans-unit id="331255970e3e48a89f2154f44ef024e28fb6bd1c" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing microseconds.</source>
          <target state="translated">Forma un literal &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; representa microsegundos.</target>
        </trans-unit>
        <trans-unit id="8c586fe6bccfd167b2ec9b0341a50e0e2e23b2bd" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing milliseconds.</source>
          <target state="translated">Forma un literal &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; representa milisegundos.</target>
        </trans-unit>
        <trans-unit id="aabdc8e30aa11c549d953403622d6b09da7416a8" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing minutes.</source>
          <target state="translated">Forma un &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal que representa minutos.</target>
        </trans-unit>
        <trans-unit id="b2b858860ebb5672d0b628f2489cbedb92290864" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing nanoseconds.</source>
          <target state="translated">Forma un literal &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; representa nanosegundos.</target>
        </trans-unit>
        <trans-unit id="d804e0c1b4cad0bfbb3de1fe4b5fa00aa0254978" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing seconds.</source>
          <target state="translated">Forma un &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal que representa segundos.</target>
        </trans-unit>
        <trans-unit id="1f2764e36e954fe7d39b543d927e58cc08e2ae3b" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the day value stored in &lt;code&gt;d&lt;/code&gt; formatted as a decimal number, with a leading zero if the result would otherwise be a single decimal digit. Inserts that string into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!d.ok()&lt;/code&gt;, inserts the string &lt;code&gt;&quot; is not a valid day&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Forma un &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; que consiste en el valor del d&amp;iacute;a almacenado en &lt;code&gt;d&lt;/code&gt; formateado como un n&amp;uacute;mero decimal, con un cero a la izquierda si el resultado ser&amp;iacute;a un solo d&amp;iacute;gito decimal. Inserta esa cadena en el sistema &lt;code&gt;os&lt;/code&gt; . Luego, si &lt;code&gt;!d.ok()&lt;/code&gt; , inserta la cadena &lt;code&gt;&quot; is not a valid day&quot;&lt;/code&gt; en el sistema &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38eae2fb3ad7f9bb81e8d518abb33df758dc07a9" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the year value stored in &lt;code&gt;y&lt;/code&gt; formatted as a decimal number, left-padded with &lt;code&gt;0&lt;/code&gt; to four digits if the result would otherwise be less than four digits. Inserts that string into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!y.ok()&lt;/code&gt;, inserts the string &lt;code&gt;&quot; is not a valid year&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Forma un &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; que consiste en el valor del a&amp;ntilde;o almacenado en &lt;code&gt;y&lt;/code&gt; formateado como un n&amp;uacute;mero decimal, rellenado a la izquierda con &lt;code&gt;0&lt;/code&gt; a cuatro d&amp;iacute;gitos si el resultado ser&amp;iacute;a de otro modo menos de cuatro d&amp;iacute;gitos. Inserta esa cadena en el sistema &lt;code&gt;os&lt;/code&gt; . Luego, si &lt;code&gt;!y.ok()&lt;/code&gt; , inserta la cadena &lt;code&gt;&quot; is not a valid year&quot;&lt;/code&gt; en el sistema &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5578517ed64bd2435fafaf294658c0cb1801f2" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::chrono::day&lt;/code&gt; literal representing a day of the month in the calendar.</source>
          <target state="translated">Forma un literal &lt;code&gt;std::chrono::day&lt;/code&gt; representa un d&amp;iacute;a del mes en el calendario.</target>
        </trans-unit>
        <trans-unit id="07aea1146bfbc451baff20e77016224dc3f5174b" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::chrono::year&lt;/code&gt; literal representing a year in the proleptic Gregorian calendar.</source>
          <target state="translated">Forma un literal &lt;code&gt;std::chrono::year&lt;/code&gt; representa un a&amp;ntilde;o en el calendario gregoriano proleptico.</target>
        </trans-unit>
        <trans-unit id="820c807c48f38eb8ca42664fa731c03b51c0dc19" translate="yes" xml:space="preserve">
          <source>Forms a string literal of the desired type.</source>
          <target state="translated">Forma una cadena literal del tipo deseado.</target>
        </trans-unit>
        <trans-unit id="985e41dbd82d997c605a0a512d9497c566128eb1" translate="yes" xml:space="preserve">
          <source>Forms a string view of a character literal.</source>
          <target state="translated">Forma una vista de cadena de un personaje literal.</target>
        </trans-unit>
        <trans-unit id="70ef5d692d3abeefce2c77380edc61da30bbd98d" translate="yes" xml:space="preserve">
          <source>Forms can be nested and processed recursively: &lt;code&gt;X&amp;lt;int&amp;gt;(*)(char[6])&lt;/code&gt; is an example of &lt;code&gt;type(*)(T)&lt;/code&gt;, where</source>
          <target state="translated">Los formularios se pueden anidar y procesar de forma recursiva: &lt;code&gt;X&amp;lt;int&amp;gt;(*)(char[6])&lt;/code&gt; es un ejemplo de &lt;code&gt;type(*)(T)&lt;/code&gt; , donde</target>
        </trans-unit>
        <trans-unit id="96d68418cb661c4b3699c2e8d5be8b57b843889b" translate="yes" xml:space="preserve">
          <source>Forms the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot;&gt;logical conjunction&lt;/a&gt; of the type traits &lt;code&gt;B...&lt;/code&gt;, effectively performing a logical AND on the sequence of traits.</source>
          <target state="translated">Forma la &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot;&gt;conjunci&amp;oacute;n l&amp;oacute;gica&lt;/a&gt; de los rasgos de tipo &lt;code&gt;B...&lt;/code&gt; , realizando efectivamente un AND l&amp;oacute;gico en la secuencia de rasgos.</target>
        </trans-unit>
        <trans-unit id="abc06d4ed5fe67746f60bf85f949f812a573392b" translate="yes" xml:space="preserve">
          <source>Forms the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_disjunction&quot;&gt;logical disjunction&lt;/a&gt; of the type traits &lt;code&gt;B...&lt;/code&gt;, effectively performing a logical OR on the sequence of traits.</source>
          <target state="translated">Forma la &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_disjunction&quot;&gt;disyunci&amp;oacute;n l&amp;oacute;gica&lt;/a&gt; de los rasgos de tipo &lt;code&gt;B...&lt;/code&gt; , realizando efectivamente un OR l&amp;oacute;gico en la secuencia de rasgos.</target>
        </trans-unit>
        <trans-unit id="bb06b9b7e348bda3d1bd2e01e574d860866f1b4f" translate="yes" xml:space="preserve">
          <source>Forms the logical negation of the type trait &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Forma la negaci&amp;oacute;n l&amp;oacute;gica del tipo rasgo &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82ea89ab75987595e45620e5e795108b1b6e0406" translate="yes" xml:space="preserve">
          <source>Forward declaration</source>
          <target state="translated">Declaración previa</target>
        </trans-unit>
        <trans-unit id="69f690f33d986c3349097e854e0eb9e08b5cc4f9" translate="yes" xml:space="preserve">
          <source>Forward declarations</source>
          <target state="translated">Declaraciones anticipadas</target>
        </trans-unit>
        <trans-unit id="a0a5ca500e9440c8915b30c97f259cacfbb1a922" translate="yes" xml:space="preserve">
          <source>Forward iterator to the new end of the range.</source>
          <target state="translated">Adelante el iterador al nuevo final del rango.</target>
        </trans-unit>
        <trans-unit id="55728db9a1113137c393ce6ac1e01d0996797010" translate="yes" xml:space="preserve">
          <source>Forward progress</source>
          <target state="translated">Progreso hacia adelante</target>
        </trans-unit>
        <trans-unit id="ad2924cf16dd4b5c687b5dd4c3d38f7f20d99988" translate="yes" xml:space="preserve">
          <source>ForwardIterator</source>
          <target state="translated">ForwardIterator</target>
        </trans-unit>
        <trans-unit id="967415c810ff974308b7e163c5a8b2ee4963dfdf" translate="yes" xml:space="preserve">
          <source>ForwardRange</source>
          <target state="translated">ForwardRange</target>
        </trans-unit>
        <trans-unit id="02f29ee395fe54e14061ef2943f36bed0af18091" translate="yes" xml:space="preserve">
          <source>Forwarding references</source>
          <target state="translated">Referencias de reenvío</target>
        </trans-unit>
        <trans-unit id="9cc6112b2b655f82745fcb59748e093ab1fe8817" translate="yes" xml:space="preserve">
          <source>Forwarding references are a special kind of references that preserve the value category of a function argument, making it possible to</source>
          <target state="translated">Las referencias de reenvío son un tipo especial de referencias que preservan la categoría de valor de un argumento de función,lo que permite</target>
        </trans-unit>
        <trans-unit id="2d1b43ed1d5df75c8cdb7fbed98fd0e15496fb8b" translate="yes" xml:space="preserve">
          <source>Four specializations are provided by the standard library.</source>
          <target state="translated">La biblioteca estándar ofrece cuatro especializaciones.</target>
        </trans-unit>
        <trans-unit id="646942bdd43335fac5c5cb8c90a98c4a1571691d" translate="yes" xml:space="preserve">
          <source>Four standalone (locale-independent) specializations are provided by the standard library:</source>
          <target state="translated">La biblioteca estándar ofrece cuatro especializaciones autónomas (independientes del lugar):</target>
        </trans-unit>
        <trans-unit id="6eb9522d427a2669dd67835d7011efde7feafc8c" translate="yes" xml:space="preserve">
          <source>Fourth version</source>
          <target state="translated">Cuarta versión</target>
        </trans-unit>
        <trans-unit id="67c664a3c5100ef6f1199beaf5c8ee1e3784d4ea" translate="yes" xml:space="preserve">
          <source>Free raw memory obtained from allocate_bytes</source>
          <target state="translated">Memoria cruda libre obtenida de allocate_bytes</target>
        </trans-unit>
        <trans-unit id="66c8be8d1a5492d1eb9655f15bf0380194107efe" translate="yes" xml:space="preserve">
          <source>Frees raw memory obtained by allocate_object</source>
          <target state="translated">Libera la memoria bruta obtenida por allocate_object</target>
        </trans-unit>
        <trans-unit id="2715bc5b3d7345dfa8bf763d473dced4c5997198" translate="yes" xml:space="preserve">
          <source>Freestanding and hosted implementations</source>
          <target state="translated">Implementaciones autónomas y alojadas</target>
        </trans-unit>
        <trans-unit id="755e9516e294b0231da60ee53dcb1cf6956a6f7f" translate="yes" xml:space="preserve">
          <source>Friend declarations cannot refer to partial specializations, but can refer to full specializations:</source>
          <target state="translated">Las declaraciones de amigos no pueden referirse a especializaciones parciales,pero pueden referirse a especializaciones completas:</target>
        </trans-unit>
        <trans-unit id="78f907cdd8f4e2ead952047583a3ce2951b50c9e" translate="yes" xml:space="preserve">
          <source>Friend function declaration</source>
          <target state="translated">Declaración de la función del amigo</target>
        </trans-unit>
        <trans-unit id="74ed844100eed25ad0c1bd3b12ca6cc5919b4157" translate="yes" xml:space="preserve">
          <source>Friend function definition</source>
          <target state="translated">Definición de la función de amigo</target>
        </trans-unit>
        <trans-unit id="cc53f78835350ac24156d967e62ee0b5c8a5687b" translate="yes" xml:space="preserve">
          <source>Friendship is not inherited (your friend's children are not your friends).</source>
          <target state="translated">La amistad no se hereda (los hijos de tu amigo no son tus amigos).</target>
        </trans-unit>
        <trans-unit id="8c8cea4fdc1598ec00b1de75a422605f0af14cee" translate="yes" xml:space="preserve">
          <source>Friendship is not transitive (a friend of your friend is not your friend).</source>
          <target state="translated">La amistad no es transitoria (un amigo de tu amigo no es tu amigo).</target>
        </trans-unit>
        <trans-unit id="e8b58840737fe83d2eef7b8580aadc5bae0ab4f5" translate="yes" xml:space="preserve">
          <source>Full names</source>
          <target state="translated">Nombres completos</target>
        </trans-unit>
        <trans-unit id="0ca544d7457648c14cce40272868cda27ebf4451" translate="yes" xml:space="preserve">
          <source>Function Objects</source>
          <target state="translated">Objetos de función</target>
        </trans-unit>
        <trans-unit id="f7f0e1bdfa2f3add115b52939d15e6fd3460937e" translate="yes" xml:space="preserve">
          <source>Function adaptors</source>
          <target state="translated">Adaptadores de función</target>
        </trans-unit>
        <trans-unit id="8231e66ed9c1c9e042523416e1ad72237c2d2874" translate="yes" xml:space="preserve">
          <source>Function argument lists</source>
          <target state="translated">Listas de argumentos de la función</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">Función del cuerpo</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">Llamada de función</target>
        </trans-unit>
        <trans-unit id="61f764306c5b4c873805f4d7503e407f01f0da37" translate="yes" xml:space="preserve">
          <source>Function call expression is similar in syntax to value initialization &lt;code&gt;T()&lt;/code&gt;, to &lt;a href=&quot;explicit_cast&quot;&gt;function-style cast&lt;/a&gt; expression &lt;code&gt;T(A1)&lt;/code&gt;, and to direct initialization of a temporary &lt;code&gt;T(A1, A2, A3, ...)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the name of a type.</source>
          <target state="translated">La expresi&amp;oacute;n de llamada de funci&amp;oacute;n es similar en sintaxis a la inicializaci&amp;oacute;n de valor &lt;code&gt;T()&lt;/code&gt; , a la expresi&amp;oacute;n de &lt;a href=&quot;explicit_cast&quot;&gt;conversi&amp;oacute;n de estilo de funci&amp;oacute;n &lt;/a&gt; &lt;code&gt;T(A1)&lt;/code&gt; y a la inicializaci&amp;oacute;n directa de un &lt;code&gt;T(A1, A2, A3, ...)&lt;/code&gt; temporal (A1, A2, A3, ...) , donde &lt;code&gt;T&lt;/code&gt; es el nombre de un tipo</target>
        </trans-unit>
        <trans-unit id="55cb199824723ac48f856b32fde1674eff49a87b" translate="yes" xml:space="preserve">
          <source>Function call expressions returning &lt;code&gt;void&lt;/code&gt;, cast expressions to &lt;code&gt;void&lt;/code&gt;, and &lt;a href=&quot;throw&quot;&gt;throw-expressions&lt;/a&gt; are classified as prvalue expressions, but they cannot be used to initialize references or as function arguments. They can be used in discarded-value contexts (e.g. on a line of its own, as the left-hand operand of the comma operator, etc.) and in the &lt;code&gt;return&lt;/code&gt; statement in a function returning &lt;code&gt;void&lt;/code&gt;. In addition, throw-expressions may be used as the second and the third operands of the &lt;a href=&quot;operator_other&quot;&gt;conditional operator ?:&lt;/a&gt;.</source>
          <target state="translated">Las expresiones de llamada de funci&amp;oacute;n que devuelven &lt;code&gt;void&lt;/code&gt; , las expresiones de conversi&amp;oacute;n a &lt;code&gt;void&lt;/code&gt; y &lt;a href=&quot;throw&quot;&gt;las expresiones de lanzamiento&lt;/a&gt; se clasifican como expresiones prvalue, pero no se pueden usar para inicializar referencias o como argumentos de funci&amp;oacute;n. Se pueden usar en contextos de valor descartado (por ejemplo, en una l&amp;iacute;nea propia, como el operando de la izquierda del operador de coma, etc.) y en la declaraci&amp;oacute;n &lt;code&gt;return&lt;/code&gt; en una funci&amp;oacute;n que devuelve &lt;code&gt;void&lt;/code&gt; . Adem&amp;aacute;s, las expresiones de lanzamiento se pueden usar como el segundo y el tercer operandos del &lt;a href=&quot;operator_other&quot;&gt;operador condicional?:&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25056cd4f19ab3cf2ddbe426ca4f88659c9ecb1f" translate="yes" xml:space="preserve">
          <source>Function call operator</source>
          <target state="translated">Función llamar al operador</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="translated">Declaración de la función</target>
        </trans-unit>
        <trans-unit id="8d84dffd70068ddd1111084e3623daad3386117d" translate="yes" xml:space="preserve">
          <source>Function declarations may appear in any scope. A function declaration at class scope introduces a class member function (unless the friend specifier is used), see &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt; and &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt; for details.</source>
          <target state="translated">Las declaraciones de funciones pueden aparecer en cualquier &amp;aacute;mbito. Una declaraci&amp;oacute;n de funci&amp;oacute;n en el &amp;aacute;mbito de la clase introduce una funci&amp;oacute;n miembro de la clase (a menos que se use el especificador amigo), vea las &lt;a href=&quot;member_functions&quot;&gt;funciones miembro&lt;/a&gt; y las &lt;a href=&quot;friend&quot;&gt;funciones amigo&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="01a7dcd826dbbad15679402aaa257c1e8bee4fd2" translate="yes" xml:space="preserve">
          <source>Function declarators can be mixed with other declarators, where decl-specifier-seq allows:</source>
          <target state="translated">Los declaradores de función pueden mezclarse con otros declaradores,cuando lo permita el decontra-especificador-seq:</target>
        </trans-unit>
        <trans-unit id="b5f8af75bc5ad30466ed317152a310aba07e877e" translate="yes" xml:space="preserve">
          <source>Function definition</source>
          <target state="translated">Definición de la función</target>
        </trans-unit>
        <trans-unit id="8a31e049889b12e1b53d0e991bba8a50561e7a03" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;&lt;a href=&quot;iswspace&quot;&gt;std::iswspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">La funci&amp;oacute;n descarta cualquier car&amp;aacute;cter de espacio en blanco (seg&amp;uacute;n lo determinado por &lt;code&gt;&lt;a href=&quot;iswspace&quot;&gt;std::iswspace&lt;/a&gt;()&lt;/code&gt; ) hasta que se encuentre el primer car&amp;aacute;cter que no sea un espacio en blanco. Luego se necesitan tantos caracteres como sea posible para formar una representaci&amp;oacute;n v&amp;aacute;lida de punto flotante y convertirlos en un valor de punto flotante. El valor v&amp;aacute;lido de coma flotante puede ser uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="268b166a91a60d5f1a938de3418f1d3678105197" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::isspace()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">La funci&amp;oacute;n descarta cualquier car&amp;aacute;cter de espacio en blanco (seg&amp;uacute;n lo determinado por &lt;code&gt;std::isspace()&lt;/code&gt; ) hasta que se encuentre el primer car&amp;aacute;cter que no sea un espacio en blanco. Luego se necesitan tantos caracteres como sea posible para formar una representaci&amp;oacute;n v&amp;aacute;lida de punto flotante y convertirlos en un valor de punto flotante. El valor v&amp;aacute;lido de coma flotante puede ser uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="56d376c8d143e7051f331c1aba9bc9e6fccbf798" translate="yes" xml:space="preserve">
          <source>Function invocation</source>
          <target state="translated">Invocación de la función</target>
        </trans-unit>
        <trans-unit id="ec031b84374532b3dd5e02a9109e50cae284b830" translate="yes" xml:space="preserve">
          <source>Function macros for integer constants</source>
          <target state="translated">Macros de función para constantes enteras</target>
        </trans-unit>
        <trans-unit id="60be48a55b3f6bfe81f126777640e7116a702836" translate="yes" xml:space="preserve">
          <source>Function macros for minimum-width integer constants</source>
          <target state="translated">Macros de función para constantes enteras de ancho mínimo</target>
        </trans-unit>
        <trans-unit id="bc8a59f44f5ba9847650733c0cafd473c4eed11f" translate="yes" xml:space="preserve">
          <source>Function not supported</source>
          <target state="translated">Función no soportada</target>
        </trans-unit>
        <trans-unit id="b248eacc8c468b679bd61ad8cb82d22de759fe43" translate="yes" xml:space="preserve">
          <source>Function object for computing remainders of divisions. Implements &lt;code&gt;operator%&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para calcular los restos de divisiones. Implementa &lt;code&gt;operator%&lt;/code&gt; para el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4633ecd37c7996641d9e6e60f41f4acaad220fb" translate="yes" xml:space="preserve">
          <source>Function object for performing addition. Effectively calls &lt;code&gt;operator+&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar la suma. Pide Efectivamente &lt;code&gt;operator+&lt;/code&gt; en dos instancias de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d149129b3c23a795999a21bc625bd934320c5a89" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise AND. Effectively calls &lt;code&gt;operator&amp;amp;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar AND bit a bit. Llama efectivamente &lt;code&gt;operator&amp;amp;&lt;/code&gt; del tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b599fdda8a6eff8b08fa4dda5e4633fab0dbe0ce" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise NOT. Effectively calls &lt;code&gt;operator~&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar NO bit a bit. Llama efectivamente &lt;code&gt;operator~&lt;/code&gt; en el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="313209366a119d00dc320937bfc0bbb8786800ec" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise OR. Effectively calls &lt;code&gt;operator|&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar OR bit a bit. Efectivamente llama &lt;code&gt;operator|&lt;/code&gt; en el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5887d43f2e0df69b82fff43b54f846c4704fa46" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise XOR. Effectively calls &lt;code&gt;operator^&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar XOR bit a bit. Llama efectivamente &lt;code&gt;operator^&lt;/code&gt; en el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e180b41511a71768ffe2c960f01fb1039a41108e" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type).</source>
          <target state="translated">Objeto de función para realizar comparaciones.Deduce los tipos de parámetros del operador de llamada de la función de los argumentos (pero no el tipo de retorno).</target>
        </trans-unit>
        <trans-unit id="56f077a1110154764933177a4a8a45a67a0e117f" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialised, invokes &lt;code&gt;operator!=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar comparaciones. A menos especializado, invoca el &lt;code&gt;operator!=&lt;/code&gt; En el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d8efff6ca90765aa3a8bc08e4dd6c03c3e58a69" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialised, invokes &lt;code&gt;operator==&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar comparaciones. A menos especializado, invoca &lt;code&gt;operator==&lt;/code&gt; en el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60aea8fb12e1c43b673c06d961c8619b0f1469c4" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;gt;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar comparaciones. A menos especializado, invoca &lt;code&gt;operator&amp;gt;&lt;/code&gt; en el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="738acefb6a4d9540bfe0b153875600600ca1005f" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;gt;=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar comparaciones. A menos especializado, invoca el &lt;code&gt;operator&amp;gt;=&lt;/code&gt; en el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ed4fd907e2e5e744c2b2efa9d9bc109fe8439c7" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;lt;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar comparaciones. A menos especializado, invoca &lt;code&gt;operator&amp;lt;&lt;/code&gt; en el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86238797ec5cdcf632292c3e4d25c647b5a4693a" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;lt;=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar comparaciones. A menos especializados, invoca el &lt;code&gt;operator&amp;lt;=&lt;/code&gt; en el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fe5410430a56ab0ae8cbfda0c39393d3efaefd1" translate="yes" xml:space="preserve">
          <source>Function object for performing division. Effectively calls &lt;code&gt;operator/&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar divisi&amp;oacute;n. Llama efectivamente &lt;code&gt;operator/&lt;/code&gt; en dos instancias del tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12de586434654aa1a14b6b2d8a259de90a34392f" translate="yes" xml:space="preserve">
          <source>Function object for performing logical AND (logical conjunction). Effectively calls &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar AND l&amp;oacute;gico (conjunci&amp;oacute;n l&amp;oacute;gica). Llama efectivamente &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; del tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1490a0997baca27d81b16387b04a8b28fa19d7e6" translate="yes" xml:space="preserve">
          <source>Function object for performing logical NOT (logical negation). Effectively calls &lt;code&gt;operator!&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar NOT l&amp;oacute;gico (negaci&amp;oacute;n l&amp;oacute;gica). &amp;iexcl;Efectivamente llama al &lt;code&gt;operator!&lt;/code&gt; Para el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26fc81b06029a179ee570f03e59c7d8106976333" translate="yes" xml:space="preserve">
          <source>Function object for performing logical OR (logical disjunction). Effectively calls &lt;code&gt;operator||&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar OR l&amp;oacute;gico (disyunci&amp;oacute;n l&amp;oacute;gica). Llama efectivamente al &lt;code&gt;operator||&lt;/code&gt; en el tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="863b97dec6e3bad00c70886e69a7afbb1c4e16fb" translate="yes" xml:space="preserve">
          <source>Function object for performing multiplication. Effectively calls &lt;code&gt;operator*&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar multiplicaci&amp;oacute;n. Llama efectivamente &lt;code&gt;operator*&lt;/code&gt; en dos instancias del tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a134daaeb15195627f59ee24f26ecba80c6eb4fc" translate="yes" xml:space="preserve">
          <source>Function object for performing negation. Effectively calls &lt;code&gt;operator-&lt;/code&gt; on an instance of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar la negaci&amp;oacute;n. Llama efectivamente &lt;code&gt;operator-&lt;/code&gt; en una instancia de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6be85bc0166110c97cce13deef82fe7cce65ca9c" translate="yes" xml:space="preserve">
          <source>Function object for performing subtraction. Effectively calls &lt;code&gt;operator-&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Objeto de funci&amp;oacute;n para realizar resta. Llama efectivamente &lt;code&gt;operator-&lt;/code&gt; en dos instancias del tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05785bcc60d939df6f0a0f7578eb56a67e1b185f" translate="yes" xml:space="preserve">
          <source>Function objects</source>
          <target state="translated">Objetos de función</target>
        </trans-unit>
        <trans-unit id="b8f9cce63cec2dc22abc32a4cbf9907e736f87ee" translate="yes" xml:space="preserve">
          <source>Function objects, Function invocations, Bind operations and Reference wrappers</source>
          <target state="translated">Objetos de función,invocaciones de función,operaciones de enlace y envoltorios de referencia</target>
        </trans-unit>
        <trans-unit id="474b3e14aec889f00fbd7fffa4899aaf67c18da3" translate="yes" xml:space="preserve">
          <source>Function overloads vs function specializations</source>
          <target state="translated">Sobrecarga de funciones vs.especialización de funciones</target>
        </trans-unit>
        <trans-unit id="05c625ce62f1567c6464e68f3d0c5ca596683e7c" translate="yes" xml:space="preserve">
          <source>Function parameter list</source>
          <target state="translated">Lista de parámetros de función</target>
        </trans-unit>
        <trans-unit id="cacf242390ee182c0b5703d0e286b16458b2d6ac" translate="yes" xml:space="preserve">
          <source>Function parameter pack (a form of &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, appears in a function parameter list of a variadic function template).</source>
          <target state="translated">Paquete de par&amp;aacute;metros de funci&amp;oacute;n (una forma de &lt;a href=&quot;declarations&quot;&gt;declarador&lt;/a&gt; , aparece en una lista de par&amp;aacute;metros de funci&amp;oacute;n de una plantilla de funci&amp;oacute;n variable).</target>
        </trans-unit>
        <trans-unit id="ee2ed22b6c316767fa0eee64138df658812f8372" translate="yes" xml:space="preserve">
          <source>Function parameter scope</source>
          <target state="translated">Alcance de los parámetros de la función</target>
        </trans-unit>
        <trans-unit id="16a39e4b6666353c50f59b56d3cce3eb5dbeca02" translate="yes" xml:space="preserve">
          <source>Function parameters are not allowed in default arguments (even if they are not evaluated)(until C++14) except if they are unevaluated(since C++14). Note that parameters that appear earlier in the parameter list are in &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;:</source>
          <target state="translated">Los par&amp;aacute;metros de funci&amp;oacute;n no est&amp;aacute;n permitidos en los argumentos predeterminados (incluso si no se eval&amp;uacute;an) (hasta C ++ 14) excepto si no est&amp;aacute;n evaluados (desde C ++ 14). Tenga en cuenta que los par&amp;aacute;metros que aparecen anteriormente en la lista de par&amp;aacute;metros est&amp;aacute;n dentro del &lt;a href=&quot;scope&quot;&gt;alcance&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c545df3352143fe60a307ebf941a3169f4b04ba9" translate="yes" xml:space="preserve">
          <source>Function pointer conversions</source>
          <target state="translated">Conversiones de punteros de función</target>
        </trans-unit>
        <trans-unit id="14644346bcc70a878c3eb265226005a7304bec16" translate="yes" xml:space="preserve">
          <source>Function scope</source>
          <target state="translated">Alcance de la función</target>
        </trans-unit>
        <trans-unit id="d879bbf1375b073db057a0370df0b5d2aaf75d77" translate="yes" xml:space="preserve">
          <source>Function template</source>
          <target state="translated">Plantilla de funciones</target>
        </trans-unit>
        <trans-unit id="e8ac637a6e8fb2f46175ee490eb2eb83645238b8" translate="yes" xml:space="preserve">
          <source>Function template &lt;code&gt;std::mem_fn&lt;/code&gt; generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member. Both references and pointers (including smart pointers) to an object can be used when invoking a &lt;code&gt;std::mem_fn&lt;/code&gt;.</source>
          <target state="translated">La plantilla de funci&amp;oacute;n &lt;code&gt;std::mem_fn&lt;/code&gt; genera objetos de contenedor para punteros a miembros, que pueden almacenar, copiar e invocar un puntero a miembro. Tanto las referencias como los punteros (incluidos los punteros inteligentes) a un objeto se pueden usar al invocar un &lt;code&gt;std::mem_fn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba1b466469de4bedf72f07dd5b3b51bc92ecf5e1" translate="yes" xml:space="preserve">
          <source>Function template instantiation</source>
          <target state="translated">Función de la plantilla de instanciación</target>
        </trans-unit>
        <trans-unit id="a76d53230697569d7c028ff1451f97505d469db4" translate="yes" xml:space="preserve">
          <source>Function template overloading</source>
          <target state="translated">Sobrecarga de la plantilla de funciones</target>
        </trans-unit>
        <trans-unit id="86dd3fddcc75cfa4e063a703f32c8ede28f4c30d" translate="yes" xml:space="preserve">
          <source>Function template parameters are substituted (replaced by template arguments) twice:</source>
          <target state="translated">Los parámetros de la plantilla de la función son sustituidos (reemplazados por argumentos de la plantilla)dos veces:</target>
        </trans-unit>
        <trans-unit id="6027571a098596d5e87183ff7d586ec483f03343" translate="yes" xml:space="preserve">
          <source>Function template specialization</source>
          <target state="translated">Especialización de la plantilla de funciones</target>
        </trans-unit>
        <trans-unit id="c03fc20cda6df9ef92fd64413e95464c0412a4fc" translate="yes" xml:space="preserve">
          <source>Function templates &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;cref&lt;/code&gt; are helper functions that generate an object of type &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, using &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; to determine the template argument of the result.</source>
          <target state="translated">Las plantillas de funci&amp;oacute;n &lt;code&gt;ref&lt;/code&gt; y &lt;code&gt;cref&lt;/code&gt; son funciones auxiliares que generan un objeto de tipo &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; , utilizando &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;la deducci&amp;oacute;n de argumentos de plantilla&lt;/a&gt; para determinar el argumento de plantilla del resultado.</target>
        </trans-unit>
        <trans-unit id="d90c99af4d1617c8e3520279788821d8d6072cea" translate="yes" xml:space="preserve">
          <source>Function templates and non-template functions may be overloaded.</source>
          <target state="translated">Las plantillas de funciones y las funciones que no son plantillas pueden estar sobrecargadas.</target>
        </trans-unit>
        <trans-unit id="527a4bc836096e4223cdeb54a2dc838640d3aaaa" translate="yes" xml:space="preserve">
          <source>Function to pointer</source>
          <target state="translated">Función del puntero</target>
        </trans-unit>
        <trans-unit id="ccff159bf6b5506e0e1b9835119cc9060c666c2b" translate="yes" xml:space="preserve">
          <source>Function wrappers</source>
          <target state="translated">Envolturas de función</target>
        </trans-unit>
        <trans-unit id="2e3030f5a7f048cef8382d50828336e71bb753d2" translate="yes" xml:space="preserve">
          <source>Function-like macros</source>
          <target state="translated">Macros funcionales</target>
        </trans-unit>
        <trans-unit id="a542b043e775e7bb5b171b48eca68e3eaf37af10" translate="yes" xml:space="preserve">
          <source>Function-like macros replace each occurrence of defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list.</source>
          <target state="translated">Las macros de tipo funcional sustituyen cada ocurrencia de un identificador definido por una lista de sustitución,tomando además una serie de argumentos,que luego sustituyen las ocurrencias correspondientes de cualquiera de los parámetros de la lista de sustitución.</target>
        </trans-unit>
        <trans-unit id="1bc7ec84b7f54258ed54c7cecbe2e69587cb60b9" translate="yes" xml:space="preserve">
          <source>Function-local static objects in all definitions of the same &lt;a href=&quot;inline&quot;&gt;inline function&lt;/a&gt; (which may be implicitly inline) all refer to the same object defined in one translation unit.</source>
          <target state="translated">Los objetos est&amp;aacute;ticos locales de funci&amp;oacute;n en todas las definiciones de la misma &lt;a href=&quot;inline&quot;&gt;funci&amp;oacute;n en l&amp;iacute;nea&lt;/a&gt; (que pueden estar impl&amp;iacute;citamente en l&amp;iacute;nea) se refieren al mismo objeto definido en una unidad de traducci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fbeb9de485717bfd55eb5b969f4aef0b216aa354" translate="yes" xml:space="preserve">
          <source>Function-local static objects in all function definitions are shared across all translation units (they all refer to the same object defined in one translation unit)</source>
          <target state="translated">Los objetos estáticos locales de la función en todas las definiciones de la función son compartidos por todas las unidades de traducción (todas se refieren al mismo objeto definido en una unidad de traducción)</target>
        </trans-unit>
        <trans-unit id="22b482f447a1cfcb8f938c680757e7b627882a11" translate="yes" xml:space="preserve">
          <source>Function-try-block</source>
          <target state="translated">Function-try-block</target>
        </trans-unit>
        <trans-unit id="36dbe687f7a701ccda0c0ab3d3368fc1726070a3" translate="yes" xml:space="preserve">
          <source>Function-try-block does not catch the exceptions thrown by the copy/move constructors and the destructors of the function parameters passed by value: those exceptions are thrown in context of the caller.</source>
          <target state="translated">Function-try-block no capta las excepciones lanzadas por los constructores de copia/movimiento y los destructores de los parámetros de función pasados por valor:esas excepciones se lanzan en el contexto del llamador.</target>
        </trans-unit>
        <trans-unit id="62fa030d8057f6948ce260fe787ed5a6b93441e6" translate="yes" xml:space="preserve">
          <source>Function-try-block of the top-level function of a thread does not catch the exceptions thrown from the constructors and destructors of &lt;a href=&quot;storage_duration&quot;&gt;thread-local&lt;/a&gt; objects (except for the constructors of function-scoped thread-locals).</source>
          <target state="translated">El bloque de prueba de funci&amp;oacute;n de la funci&amp;oacute;n de nivel superior de un subproceso no detecta las excepciones generadas por los constructores y destructores de objetos &lt;a href=&quot;storage_duration&quot;&gt;locales&lt;/a&gt; de subprocesos (excepto los constructores de subprocesos locales con &amp;aacute;mbito de funci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="e6221f912553a22b3b906841565a95ac6fe744e4" translate="yes" xml:space="preserve">
          <source>FunctionObject</source>
          <target state="translated">FunctionObject</target>
        </trans-unit>
        <trans-unit id="c504a5185db1d5f75bfd32087e1e44501fcf47f1" translate="yes" xml:space="preserve">
          <source>Functional cast</source>
          <target state="translated">El molde funcional</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="b4889f5791eb376ad73674ef2d3c06e94b724603" translate="yes" xml:space="preserve">
          <source>Functions and macro constants for signal management</source>
          <target state="translated">Funciones y constantes macro para la gestión de la señal</target>
        </trans-unit>
        <trans-unit id="a1141ae7da62060d933a86668311750ac59f208e" translate="yes" xml:space="preserve">
          <source>Functions and references to functions are not function object types, but can be used where function object types are expected due to function-to-pointer &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicit conversion&lt;/a&gt;.</source>
          <target state="translated">Las funciones y referencias a funciones no son tipos de objeto de funci&amp;oacute;n, pero pueden usarse donde se esperan tipos de objeto de funci&amp;oacute;n debido a la &lt;a href=&quot;../language/implicit_cast&quot;&gt;conversi&amp;oacute;n impl&amp;iacute;cita de&lt;/a&gt; funci&amp;oacute;n a puntero .</target>
        </trans-unit>
        <trans-unit id="ab7bbe95387b8d4e9017d700d4c60ae66f3da45c" translate="yes" xml:space="preserve">
          <source>Functions are C++ entities that associate a sequence of &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt; (a</source>
          <target state="translated">Las funciones son entidades C ++ que asocian una secuencia de &lt;a href=&quot;statements&quot;&gt;declaraciones&lt;/a&gt; (un</target>
        </trans-unit>
        <trans-unit id="9a1ebfefe2d4935a5dd163de13ea3976c504e0ea" translate="yes" xml:space="preserve">
          <source>Functions are not objects: there are no arrays of functions and functions cannot be passed by value or returned from other functions. Pointers and references to functions are allowed, and may be used where functions themselves cannot.</source>
          <target state="translated">Las funciones no son objetos:no hay conjuntos de funciones y las funciones no pueden ser pasadas por valor o devueltas de otras funciones.Se permiten los punteros y las referencias a las funciones,y se pueden usar donde las funciones mismas no pueden.</target>
        </trans-unit>
        <trans-unit id="e4cd68a9abe69d2fc916398ed73a57ddaba5e3ac" translate="yes" xml:space="preserve">
          <source>Functions differing only in their exception specification cannot be overloaded (just like the return type, exception specification is part of function type, but not part of the function signature)(since C++17).</source>
          <target state="translated">Las funciones que sólo difieren en su especificación de excepción no pueden ser sobrecargadas (al igual que el tipo de retorno,la especificación de excepción es parte del tipo de función,pero no de la firma de la función)(desde C++17).</target>
        </trans-unit>
        <trans-unit id="d805e16a2e1dab2e9501d00d8aa06488d3d1141d" translate="yes" xml:space="preserve">
          <source>Functions in input/output classes returning this type use &lt;code&gt;X::pos_type(X::off_type(-1))&lt;/code&gt; is an invalid value to signal an error</source>
          <target state="translated">Las funciones en las clases de entrada / salida que devuelven este tipo usan &lt;code&gt;X::pos_type(X::off_type(-1))&lt;/code&gt; es un valor no v&amp;aacute;lido para indicar un error</target>
        </trans-unit>
        <trans-unit id="f4f28c856ebb451338613595e08fe5dd22c841b5" translate="yes" xml:space="preserve">
          <source>Functions managing the current thread</source>
          <target state="translated">Funciones que gestionan el hilo actual</target>
        </trans-unit>
        <trans-unit id="d3e493f42a02a1130d7650420222293b27d1128f" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; are called in reverse order of their registration. If an exception tries to propagate out of any of the functions, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. After calling the registered functions, calls &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;std::_Exit&lt;/a&gt;(exit_code)&lt;/code&gt;.</source>
          <target state="translated">Las funciones pasadas a &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; se llaman en orden inverso a su registro. Si una excepci&amp;oacute;n intenta propagarse desde cualquiera de las funciones, se llama a &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Despu&amp;eacute;s de llamar a las funciones registradas, llama a &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;std::_Exit&lt;/a&gt;(exit_code)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2271b1375ac754084b518ec111ad83a20a6f3bb3" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are not called.</source>
          <target state="translated">Las funciones pasadas a &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; no se llaman.</target>
        </trans-unit>
        <trans-unit id="a4c76c24658f2c936074eb17b534063810ef4a85" translate="yes" xml:space="preserve">
          <source>Functions templates cannot be declared &lt;code&gt;virtual&lt;/code&gt;. This applies only to functions that are themselves templates - a regular member function of a class template can be declared virtual.</source>
          <target state="translated">Las plantillas de funciones no pueden declararse &lt;code&gt;virtual&lt;/code&gt; es . Esto se aplica solo a las funciones que son en s&amp;iacute; mismas plantillas: una funci&amp;oacute;n miembro regular de una plantilla de clase puede declararse virtual.</target>
        </trans-unit>
        <trans-unit id="987a9735f7910a78415404d390c2c2321b297df5" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in character data</source>
          <target state="translated">Funciones para determinar el tipo contenido en los datos de los caracteres</target>
        </trans-unit>
        <trans-unit id="56333d40b9d13a5dd6765448f63eb5888129f41c" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in wide character data</source>
          <target state="translated">Funciones para determinar el tipo contenido en los datos de caracteres anchos</target>
        </trans-unit>
        <trans-unit id="268aa8a9dc8a94eb9552c1bc422fd7d569604150" translate="yes" xml:space="preserve">
          <source>Fundamental library concepts</source>
          <target state="translated">Conceptos fundamentales de la biblioteca</target>
        </trans-unit>
        <trans-unit id="9415eca058dab008a0c257d5b5372a414020f727" translate="yes" xml:space="preserve">
          <source>Fundamental types</source>
          <target state="translated">Tipos fundamentales</target>
        </trans-unit>
        <trans-unit id="f9ccc0fa4eefc3fc4fbd603adf877686e0fcb107" translate="yes" xml:space="preserve">
          <source>Fundamental types defined by the language</source>
          <target state="translated">Los tipos fundamentales definidos por el lenguaje</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">Más lecturas</target>
        </trans-unit>
        <trans-unit id="90203b2e01951bcae33561da4c2fe607351b5912" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;auto&lt;/code&gt;and type-constraint&lt;code&gt;auto&lt;/code&gt;(since C++20) can appear in:</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;auto&lt;/code&gt; y restricci&amp;oacute;n de tipo &lt;code&gt;auto&lt;/code&gt; (desde C ++ 20) pueden aparecer en:</target>
        </trans-unit>
        <trans-unit id="6dc21edb8c36c3f6d406c872d0cb241b792a813e" translate="yes" xml:space="preserve">
          <source>Furthermore.</source>
          <target state="translated">Furthermore.</target>
        </trans-unit>
        <trans-unit id="ef3bf279dd511b3249e9a0fa2ada2e63ca452156" translate="yes" xml:space="preserve">
          <source>Future errors</source>
          <target state="translated">Futuros errores</target>
        </trans-unit>
        <trans-unit id="965db80f650641f51dead99c13720e4035c9ef70" translate="yes" xml:space="preserve">
          <source>Futures</source>
          <target state="translated">Futures</target>
        </trans-unit>
        <trans-unit id="4c00eeb89fd7b78411cbeb5ccec11fa4c97f179d" translate="yes" xml:space="preserve">
          <source>GCC 4.6 libstdc++</source>
          <target state="translated">GCC 4.6 libstdc++</target>
        </trans-unit>
        <trans-unit id="8678ed721c5d5bc588ebb7a34742eafcc58d8a66" translate="yes" xml:space="preserve">
          <source>GCC Inline Assembly HOWTO</source>
          <target state="translated">Asamblea en línea del CCG CÓMO</target>
        </trans-unit>
        <trans-unit id="e28f7b13c864b2544bcffb8944485f05b95aa03f" translate="yes" xml:space="preserve">
          <source>GCC assembly with the attribute:</source>
          <target state="translated">Asamblea del CCG con el atributo:</target>
        </trans-unit>
        <trans-unit id="29dc240b146eb494ed0bbceef77ad1534442b61b" translate="yes" xml:space="preserve">
          <source>GCC assembly without the attribute: the entire function is serialized.</source>
          <target state="translated">GCC ensamblado sin el atributo:toda la función es serializada.</target>
        </trans-unit>
        <trans-unit id="607e8f7d61ea73ecc2a3928fe014d54ac981f615" translate="yes" xml:space="preserve">
          <source>GLAGOLITIC CAPITAL LETTER AZU - COMBINING CYRILLIC LETTER IOTIFIED BIG YUS</source>
          <target state="translated">LETRA MAYÚSCULA GLAGOLÍTICA AZU-COMBINACIÓN DE LETRA CIRÍLICA IOTIFICADA BIG YUS</target>
        </trans-unit>
        <trans-unit id="770bd3164fd3f78b840dd2606eee557790bae82f" translate="yes" xml:space="preserve">
          <source>GNU libc function &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/s/hello/manual/libc/Control-Functions.html&quot;&gt;feenableexcept()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates the signal &lt;code&gt;SIGFPE&lt;/code&gt;. If the compiler option &lt;code&gt;-fnon-call-exceptions&lt;/code&gt; was used, the handler for that signal may throw a user-defined C++ exception.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/s/hello/manual/libc/Control-Functions.html&quot;&gt;feenableexcept()&lt;/a&gt;&lt;/code&gt; GNU feenableexcept () permite la captura de las excepciones de punto flotante, lo que genera la se&amp;ntilde;al &lt;code&gt;SIGFPE&lt;/code&gt; . Si se &lt;code&gt;-fnon-call-exceptions&lt;/code&gt; opci&amp;oacute;n del compilador -fnon-call-excepciones , el controlador para esa se&amp;ntilde;al puede lanzar una excepci&amp;oacute;n C ++ definida por el usuario.</target>
        </trans-unit>
        <trans-unit id="7e7d86fda01350dd97d7deed580504fa4ea12720" translate="yes" xml:space="preserve">
          <source>GNU libstdc++ stores 4 additional members: three cached facets and a flag to indicate that fill was initialized.</source>
          <target state="translated">GNU libstdc++almacena 4 miembros adicionales:tres facetas en caché y una bandera para indicar que el relleno fue inicializado.</target>
        </trans-unit>
        <trans-unit id="262e4b5ffc0564ab9152ecabdaf6c1affcaea1bc" translate="yes" xml:space="preserve">
          <source>GOTW issue 47: Uncaught Exceptions</source>
          <target state="translated">GOTW número 47:Excepciones no capturadas</target>
        </trans-unit>
        <trans-unit id="143075ce23be9b2dbef6368dc5e0e4219829451a" translate="yes" xml:space="preserve">
          <source>Garbage collector support</source>
          <target state="translated">Apoyo al recolector de basura</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="c807e9f8f0554603e2d07bd5ea3e21f358d0409a" translate="yes" xml:space="preserve">
          <source>General purpose utilities: &lt;a href=&quot;utility/program&quot;&gt; program control&lt;/a&gt;, &lt;a href=&quot;memory/c&quot;&gt; dynamic memory allocation&lt;/a&gt;, &lt;a href=&quot;numeric/random&quot;&gt; random numbers&lt;/a&gt;, &lt;a href=&quot;algorithm&quot;&gt; sort and search&lt;/a&gt;</source>
          <target state="translated">Utilidades de uso general: &lt;a href=&quot;utility/program&quot;&gt;control de programas&lt;/a&gt; , &lt;a href=&quot;memory/c&quot;&gt;asignaci&amp;oacute;n din&amp;aacute;mica de memoria&lt;/a&gt; , &lt;a href=&quot;numeric/random&quot;&gt;n&amp;uacute;meros aleatorios&lt;/a&gt; , &lt;a href=&quot;algorithm&quot;&gt;ordenar y buscar&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed31062b543a89f89f4324118c873e8e23d6d8a5" translate="yes" xml:space="preserve">
          <source>General-purpose utilities</source>
          <target state="translated">Utilidades de uso general</target>
        </trans-unit>
        <trans-unit id="5c6d1d670f7f626ac925f247ce54a21001aced36" translate="yes" xml:space="preserve">
          <source>Generalized lambda-capture</source>
          <target state="translated">Captura lambda generalizada</target>
        </trans-unit>
        <trans-unit id="f356c8b2b591cd001b93f307940d89de652b1d90" translate="yes" xml:space="preserve">
          <source>Generalized range-based &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">Generalizado basado &lt;code&gt;for&lt;/code&gt; rango para bucle</target>
        </trans-unit>
        <trans-unit id="42544cf1873411d097739bf7d82068c8b915ea3d" translate="yes" xml:space="preserve">
          <source>Generalized sum of &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;*first&lt;/code&gt;, &lt;code&gt;*(first+1)&lt;/code&gt;, ... &lt;code&gt;*(last-1)&lt;/code&gt; over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">Suma generalizada de &lt;code&gt;init&lt;/code&gt; y &lt;code&gt;*first&lt;/code&gt; , &lt;code&gt;*(first+1)&lt;/code&gt; , ... &lt;code&gt;*(last-1)&lt;/code&gt; sobre &lt;code&gt;binary_op&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="13dfcc134e2752a1f9a0a0493daeaa583d9e01a7" translate="yes" xml:space="preserve">
          <source>Generally speaking, the pseudo-random number generator should only be seeded once, before any calls to &lt;code&gt;rand()&lt;/code&gt;, at the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.</source>
          <target state="translated">En t&amp;eacute;rminos generales, el generador de n&amp;uacute;meros pseudoaleatorios solo se debe sembrar una vez, antes de cualquier llamada a &lt;code&gt;rand()&lt;/code&gt; , al comienzo del programa. No se debe sembrar ni volver a sembrar repetidamente cada vez que desee generar un nuevo lote de n&amp;uacute;meros pseudoaleatorios.</target>
        </trans-unit>
        <trans-unit id="7ebbc49a3b2f1f41072b44a34d7a54d1bce22da9" translate="yes" xml:space="preserve">
          <source>Generates a non-deterministic uniformly-distributed random value.</source>
          <target state="translated">Genera un valor aleatorio no determinístico distribuido uniformemente.</target>
        </trans-unit>
        <trans-unit id="974bfaa70e23e754b8c317100b6cf3c9baf7cefa" translate="yes" xml:space="preserve">
          <source>Generates a pseudo-random value. The state of the engine is advanced by one position.</source>
          <target state="translated">Genera un valor pseudo-aleatorio.El estado del motor se adelanta una posición.</target>
        </trans-unit>
        <trans-unit id="69477acbfb73a301833c0442c884476d728e54ee" translate="yes" xml:space="preserve">
          <source>Generates a random floating point number in range [0, 1).</source>
          <target state="translated">Genera un número aleatorio de punto flotante en el rango [0,1)].</target>
        </trans-unit>
        <trans-unit id="e11bac75cd58a1ca2fdf3ef16eb35185ecf226b4" translate="yes" xml:space="preserve">
          <source>Generates a random value. The state of the underlying engine is advanced one or more times.</source>
          <target state="translated">Genera un valor aleatorio.El estado del motor subyacente es avanzado una o más veces.</target>
        </trans-unit>
        <trans-unit id="045d154a63fd09f9bc95c348dc0baa989ebab1d6" translate="yes" xml:space="preserve">
          <source>Generates random numbers according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;Normal (or Gaussian) random number distribution&lt;/a&gt;. It is defined as:   f(x; &amp;mu;,&amp;sigma;) =</source>
          <target state="translated">Genera n&amp;uacute;meros aleatorios de acuerdo con la &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;distribuci&amp;oacute;n normal (o gaussiana) de n&amp;uacute;meros aleatorios&lt;/a&gt; . Se define como: f (x; &amp;mu;, &amp;sigma;) =</target>
        </trans-unit>
        <trans-unit id="74b3ade82ac714c1951306b471876167535085c8" translate="yes" xml:space="preserve">
          <source>Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling &lt;code&gt;g.operator()&lt;/code&gt;.</source>
          <target state="translated">Genera n&amp;uacute;meros aleatorios que se distribuyen de acuerdo con la funci&amp;oacute;n de probabilidad asociada. La entrop&amp;iacute;a se adquiere llamando a &lt;code&gt;g.operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d441fb5f62f87aca029a4bb398180b09920a3f5" translate="yes" xml:space="preserve">
          <source>Generation</source>
          <target state="translated">Generation</target>
        </trans-unit>
        <trans-unit id="742daa97a3eea8220673e99a3db1f627bdf6d93c" translate="yes" xml:space="preserve">
          <source>Generic (polymorphic) lambda expressions</source>
          <target state="translated">Expresiones lambda genéricas (polimórficas)</target>
        </trans-unit>
        <trans-unit id="a3b12ef32437e95ff76df32c3bf2e29d863224ec" translate="yes" xml:space="preserve">
          <source>Generic components may, in addition, offer</source>
          <target state="translated">Los componentes genéricos pueden,además,ofrecer</target>
        </trans-unit>
        <trans-unit id="d399f4838f649a1dd72fc3c7d1626e48aca6fcc9" translate="yes" xml:space="preserve">
          <source>Generic locking algorithms</source>
          <target state="translated">Algoritmos de bloqueo genéricos</target>
        </trans-unit>
        <trans-unit id="522f4aca708bf0b67f4969ccd2a81f0afbce9777" translate="yes" xml:space="preserve">
          <source>Generic mutex management</source>
          <target state="translated">Gestión genérica del mutex</target>
        </trans-unit>
        <trans-unit id="bb5f7091dca0b61fa982fa58c2f04caba2c88133" translate="yes" xml:space="preserve">
          <source>Generic pathname format</source>
          <target state="translated">Formato genérico de la ruta de acceso</target>
        </trans-unit>
        <trans-unit id="5062b24e22ad40ee77724d279398f1dbf438838e" translate="yes" xml:space="preserve">
          <source>Get area</source>
          <target state="translated">Obtener área</target>
        </trans-unit>
        <trans-unit id="f30e54b151b7e1d903f56be15b95cfc3a9e8869c" translate="yes" xml:space="preserve">
          <source>Gets and sets the exception mask of the stream. The exception mask determines the error states on occurrence of which the stream throws exception of type &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Obtiene y establece la m&amp;aacute;scara de excepci&amp;oacute;n de la secuencia. La m&amp;aacute;scara de excepci&amp;oacute;n determina los estados de error en los que la secuencia produce una excepci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;failure&lt;/a&gt;&lt;/code&gt; de tipo .</target>
        </trans-unit>
        <trans-unit id="b970edd37ceef3acb34a7c5e361913bd8492e2aa" translate="yes" xml:space="preserve">
          <source>Gets and sets the underlying string.</source>
          <target state="translated">Consigue y establece la cadena subyacente.</target>
        </trans-unit>
        <trans-unit id="332452f1980fa4e174e790babca85d5c6e588e9e" translate="yes" xml:space="preserve">
          <source>Gets the default memory resource pointer.</source>
          <target state="translated">Obtiene el puntero de recursos de memoria predeterminado.</target>
        </trans-unit>
        <trans-unit id="499d742f096a087b00e3a25ac2c61ce6526047bb" translate="yes" xml:space="preserve">
          <source>Getting the result</source>
          <target state="translated">Obteniendo el resultado</target>
        </trans-unit>
        <trans-unit id="a31c54bbb19e0e2599a1d0ad74d19479e5b692ac" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;, performs O(log N) applications of the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Dado &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; , realiza aplicaciones O (log N) del predicado &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2de26a11901d553b8a58d6c3ba8e560899db14ac" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;},</source>
          <target state="translated">Dado &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; },</target>
        </trans-unit>
        <trans-unit id="201a57a136c12310d1acc1180f1b02b9f2f6f001" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = last - first&lt;/code&gt;.</source>
          <target state="translated">Dado &lt;code&gt;N = last - first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3e5ecd385ba57ca31705c6a420eb24ffafacec4" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, dereferenceable iterators of type &lt;code&gt;It&lt;/code&gt;.</source>
          <target state="translated">Dada &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; , iteradores Dereferenceable de tipo &lt;code&gt;It&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd092018ae73c0887d7dc6c9b1bb5a5adc4b89b7" translate="yes" xml:space="preserve">
          <source>Given N = &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt;,</source>
          <target state="translated">Dado N = &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a60f6d48405c975ae0935013623bdd24a66ebef7" translate="yes" xml:space="preserve">
          <source>Given a BinaryPredicate &lt;code&gt;bin_pred&lt;/code&gt; and a pair of iterators &lt;code&gt;iter1&lt;/code&gt; and &lt;code&gt;iter2&lt;/code&gt; or an iterator &lt;code&gt;iter&lt;/code&gt; and a value &lt;code&gt;value&lt;/code&gt;, the expression &lt;code&gt;bin_pred(*iter1, *iter2)&lt;/code&gt; or, respectively, &lt;code&gt;bin_pred(*iter, value)&lt;/code&gt;, must be &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually convertible&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Dado un BinaryPredicate &lt;code&gt;bin_pred&lt;/code&gt; y un par de iteradores &lt;code&gt;iter1&lt;/code&gt; e &lt;code&gt;iter2&lt;/code&gt; o un iterador &lt;code&gt;iter&lt;/code&gt; y un valor de &lt;code&gt;value&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;bin_pred(*iter1, *iter2)&lt;/code&gt; o, respectivamente, &lt;code&gt;bin_pred(*iter, value)&lt;/code&gt; , debe ser &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextualmente convertible&lt;/a&gt; en &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa890934e1378f6d141dac2f7867c119b8ad1fa" translate="yes" xml:space="preserve">
          <source>Given a function parameter &lt;code&gt;P&lt;/code&gt; that depends on one or more type template parameters &lt;code&gt;T&lt;/code&gt;i, template template parameters &lt;code&gt;TT&lt;/code&gt;i, or non-type template parameters &lt;code&gt;I&lt;/code&gt;i, and the corresponding argument &lt;code&gt;A&lt;/code&gt;, deduction takes place if &lt;code&gt;P&lt;/code&gt; has one of the following forms:</source>
          <target state="translated">Teniendo en cuenta un par&amp;aacute;metro de funci&amp;oacute;n &lt;code&gt;P&lt;/code&gt; que depende de uno o m&amp;aacute;s par&amp;aacute;metros de plantilla tipo &lt;code&gt;T&lt;/code&gt; i, los par&amp;aacute;metros de plantilla plantilla &lt;code&gt;TT&lt;/code&gt; i, o par&amp;aacute;metros de plantilla no de tipo &lt;code&gt;I&lt;/code&gt; i, y el correspondiente argumento &lt;code&gt;A&lt;/code&gt; , la deducci&amp;oacute;n se lleva a cabo si &lt;code&gt;P&lt;/code&gt; tiene una de las siguientes formas:</target>
        </trans-unit>
        <trans-unit id="849104a88d07876b31798d027eae5e4b5ac7a9c0" translate="yes" xml:space="preserve">
          <source>Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned.</source>
          <target state="translated">Dado un puntero ptr a un buffer de espacio de tamaño,devuelve un puntero alineado por la alineación especificada para el número de bytes de tamaño y disminuye el argumento de espacio por el número de bytes utilizados para la alineación.Se devuelve la primera dirección alineada.</target>
        </trans-unit>
        <trans-unit id="1d1642375a13cf9d00a6f14be269e1b8dfaf5497" translate="yes" xml:space="preserve">
          <source>Given a set of types &lt;code&gt;Args...&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...&lt;/code&gt; meet the requirements for arguments to &lt;code&gt;ranges::swap&lt;/code&gt; above, &lt;code&gt;SwapT&lt;/code&gt; will satisfy &lt;code&gt;std::&lt;a href=&quot;../../concepts/invocable&quot;&gt;Invocable&lt;/a&gt;&amp;lt;const SwapT&amp;amp;, Args...&amp;gt;&lt;/code&gt;. Otherwise, no function call operator of &lt;code&gt;SwapT&lt;/code&gt; participates in overload resolution.</source>
          <target state="translated">Dado un conjunto de tipos &lt;code&gt;Args...&lt;/code&gt; , si &lt;code&gt;&lt;a href=&quot;../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...&lt;/code&gt; cumple con los requisitos para argumentos a &lt;code&gt;ranges::swap&lt;/code&gt; arriba, &lt;code&gt;SwapT&lt;/code&gt; satisfar&amp;aacute; &lt;code&gt;std::&lt;a href=&quot;../../concepts/invocable&quot;&gt;Invocable&lt;/a&gt;&amp;lt;const SwapT&amp;amp;, Args...&amp;gt;&lt;/code&gt; . De lo contrario, ning&amp;uacute;n operador de llamada de funci&amp;oacute;n de &lt;code&gt;SwapT&lt;/code&gt; participa en la resoluci&amp;oacute;n de sobrecarga.</target>
        </trans-unit>
        <trans-unit id="cd88ec801294426ab54d23bc136aca37fe96b8e0" translate="yes" xml:space="preserve">
          <source>Given a user-defined &lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&lt;/code&gt; for objects of type &lt;code&gt;T&lt;/code&gt;, implements the usual semantics of other comparison operators.</source>
          <target state="translated">Dado un &lt;code&gt;operator==&lt;/code&gt; definido por el usuario == y un &lt;code&gt;operator&amp;lt;&lt;/code&gt; para objetos de tipo &lt;code&gt;T&lt;/code&gt; , implementa la sem&amp;aacute;ntica habitual de otros operadores de comparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9347968d88bdedbaad63962c44f19bc3e70fd1d7" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;map&lt;/code&gt;:</source>
          <target state="translated">Dada una instancia &lt;code&gt;c&lt;/code&gt; del &lt;code&gt;map&lt;/code&gt; a :</target>
        </trans-unit>
        <trans-unit id="c587de6b8b3e1339541445cfac7615e9dbb23ca9" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;multimap&lt;/code&gt;:</source>
          <target state="translated">Dada una instancia &lt;code&gt;c&lt;/code&gt; de &lt;code&gt;multimap&lt;/code&gt; a :</target>
        </trans-unit>
        <trans-unit id="a14568942f46c8464d02bc68bb11bb1b20d8f671" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;multiset&lt;/code&gt;:</source>
          <target state="translated">Dada una instancia &lt;code&gt;c&lt;/code&gt; de &lt;code&gt;multiset&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3e2459dd2b814290389adeffd53910165c623ff3" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;set&lt;/code&gt;:</source>
          <target state="translated">Dada una instancia &lt;code&gt;c&lt;/code&gt; de &lt;code&gt;set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="881f1c518159f483a92d230aff08438c975cfc40" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_map&lt;/code&gt;:</source>
          <target state="translated">Dada una instancia &lt;code&gt;c&lt;/code&gt; de &lt;code&gt;unordered_map&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fa31a301eaa86d94083d76755aeb6d15245d1d46" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_multimap&lt;/code&gt;:</source>
          <target state="translated">Dada una instancia &lt;code&gt;c&lt;/code&gt; de &lt;code&gt;unordered_multimap&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f6d85ed3e34fe83d62419c16e466b796d53d7bae" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_multiset&lt;/code&gt;:</source>
          <target state="translated">Dada una instancia &lt;code&gt;c&lt;/code&gt; de &lt;code&gt;unordered_multiset&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a229fa6402280d8d3988d3795c697a501535b4a0" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_set&lt;/code&gt;:</source>
          <target state="translated">Dada una instancia &lt;code&gt;c&lt;/code&gt; de &lt;code&gt;unordered_set&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="585b276223e3efe88a4cec484dd924b01d338788" translate="yes" xml:space="preserve">
          <source>Given an object &lt;code&gt;G&lt;/code&gt; obtained from an earlier call to &lt;code&gt;bind_front(f, args...)&lt;/code&gt;, when a glvalue &lt;code&gt;g&lt;/code&gt; designating &lt;code&gt;G&lt;/code&gt; is invoked in a function call expression &lt;code&gt;g(call_args...)&lt;/code&gt;, an invocation of the stored object takes place, as if by.</source>
          <target state="translated">Dado un objeto &lt;code&gt;G&lt;/code&gt; obtenido de una llamada anterior a &lt;code&gt;bind_front(f, args...)&lt;/code&gt; , cuando se invoca un glvalue &lt;code&gt;g&lt;/code&gt; que designa a &lt;code&gt;G&lt;/code&gt; en una funci&amp;oacute;n llamada expresi&amp;oacute;n &lt;code&gt;g(call_args...)&lt;/code&gt; , se produce una invocaci&amp;oacute;n del objeto almacenado, como si por.</target>
        </trans-unit>
        <trans-unit id="a88f34b4e5838dad793cf28d772a20e6a14e6fb1" translate="yes" xml:space="preserve">
          <source>Given an object &lt;code&gt;g&lt;/code&gt; obtained from an earlier call to &lt;code&gt;bind&lt;/code&gt;, when it is invoked in a function call expression &lt;code&gt;g(u1, u2, ... uM)&lt;/code&gt;, an invocation of the stored object takes place, as if by &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V1&amp;gt;(v1), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V2&amp;gt;(v2), ..., &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;VN&amp;gt;(vN))&lt;/code&gt;, where &lt;code&gt;fd&lt;/code&gt; is a value of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; the values and types of the bound arguments &lt;code&gt;v1, v2, ..., vN&lt;/code&gt; are determined as specified below.</source>
          <target state="translated">Dado un objeto &lt;code&gt;g&lt;/code&gt; obtenido de una llamada anterior a &lt;code&gt;bind&lt;/code&gt; , cuando se invoca en una expresi&amp;oacute;n de llamada de funci&amp;oacute;n &lt;code&gt;g(u1, u2, ... uM)&lt;/code&gt; , tiene lugar una invocaci&amp;oacute;n del objeto almacenado, como por &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V1&amp;gt;(v1), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V2&amp;gt;(v2), ..., &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;VN&amp;gt;(vN))&lt;/code&gt; , donde &lt;code&gt;fd&lt;/code&gt; es un valor de tipo &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; los valores y tipos de los argumentos enlazados &lt;code&gt;v1, v2, ..., vN&lt;/code&gt; se determinan como se especifica a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a8337adfa8cf3c8e162bcbe5e0229685e6eb60d8" translate="yes" xml:space="preserve">
          <source>Given the character sequence from the previous steps, if the first character equals &lt;code&gt;ct.widen('-')&lt;/code&gt;, calls &lt;code&gt;mp.neg_format()&lt;/code&gt; to obtain the formatting &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, otherwise calls &lt;code&gt;mp.pos_format()&lt;/code&gt;, where &lt;code&gt;mp&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; facet imbued in &lt;code&gt;str.getloc()&lt;/code&gt;.</source>
          <target state="translated">Dada la secuencia de caracteres de los pasos anteriores, si el primer car&amp;aacute;cter es igual a &lt;code&gt;ct.widen('-')&lt;/code&gt; , llama a &lt;code&gt;mp.neg_format()&lt;/code&gt; para obtener el &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; formato , de lo contrario llama a &lt;code&gt;mp.pos_format()&lt;/code&gt; , donde &lt;code&gt;mp&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; imbuida en &lt;code&gt;str.getloc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66236ee54dcad384d354db9941193df8b20deffb" translate="yes" xml:space="preserve">
          <source>Given the set of candidate functions, constructed as described above, the next step of overload resolution is examining arguments and parameters to reduce the set to the set of</source>
          <target state="translated">Dado el conjunto de funciones candidatas,construidas como se ha descrito anteriormente,el siguiente paso de la resolución de la sobrecarga es el examen de los argumentos y parámetros para reducir el conjunto al conjunto de</target>
        </trans-unit>
        <trans-unit id="c0aebd42da085f11a7898d7938dcfcf81f34f4ad" translate="yes" xml:space="preserve">
          <source>Given the starting value s, a list of strides i</source>
          <target state="translated">Dado el valor inicial s,una lista de avances i</target>
        </trans-unit>
        <trans-unit id="93321ba8b5317191b60feb65e2cf919f7e2a81f1" translate="yes" xml:space="preserve">
          <source>Given.</source>
          <target state="translated">Given.</target>
        </trans-unit>
        <trans-unit id="c46a97000778eff7a9406aa7dac4bb058a740c4f" translate="yes" xml:space="preserve">
          <source>Gives well-defined results for reference types, void types, array types, and function types.</source>
          <target state="translated">Da resultados bien definidos para los tipos de referencia,los tipos de vacío,los tipos de matriz y los tipos de función.</target>
        </trans-unit>
        <trans-unit id="6c1092b384c391c235bf0f03a6b067bc9829d4dd" translate="yes" xml:space="preserve">
          <source>Global objects</source>
          <target state="translated">Los objetos globales</target>
        </trans-unit>
        <trans-unit id="8ecf59cbff938c3c09e7ac755a67fc60c8335206" translate="yes" xml:space="preserve">
          <source>Global replacements</source>
          <target state="translated">Reemplazos globales</target>
        </trans-unit>
        <trans-unit id="6f85091c78ab312c0eeab087e50a90d21a6d8a82" translate="yes" xml:space="preserve">
          <source>Guaranteed copy elision through simplified &lt;a href=&quot;language/value_category&quot;&gt;value categories&lt;/a&gt;</source>
          <target state="translated">Elisi&amp;oacute;n de copia garantizada a trav&amp;eacute;s de &lt;a href=&quot;language/value_category&quot;&gt;categor&amp;iacute;as de valor&lt;/a&gt; simplificadas</target>
        </trans-unit>
        <trans-unit id="daf1a29d21388e553e2e351d8eb2ded2e9be0a7c" translate="yes" xml:space="preserve">
          <source>Guides (2-3) are needed because the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; constructors for &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;s are made templates to avoid causing ambiguities in existing code, and those templates do not support class template argument deduction.</source>
          <target state="translated">Se necesitan gu&amp;iacute;as (2-3) porque los constructores &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; s son plantillas hechas para evitar causar ambig&amp;uuml;edades en el c&amp;oacute;digo existente, y esas plantillas no admiten la deducci&amp;oacute;n de argumentos de plantilla de clase.</target>
        </trans-unit>
        <trans-unit id="ab161f039e51e47e91c7fb547b04ada20d53b4a3" translate="yes" xml:space="preserve">
          <source>H. Sutter (1998) &lt;a href=&quot;http://www.gotw.ca/publications/mill02.htm&quot;&gt;&quot;What's In a Class? - The Interface Principle&quot;&lt;/a&gt; in C++ Report, 10(3)</source>
          <target state="translated">H. Sutter (1998) &lt;a href=&quot;http://www.gotw.ca/publications/mill02.htm&quot;&gt;&quot;&amp;iquest;Qu&amp;eacute; hay en una clase? El principio de la interfaz&quot;&lt;/a&gt; en el informe C ++, 10 (3)</target>
        </trans-unit>
        <trans-unit id="4d2fcf54f70e7b8f49c067c962c20ecc9c2156b7" translate="yes" xml:space="preserve">
          <source>H. Sutter (2000) &quot;Exceptional C++&quot;</source>
          <target state="translated">H.Sutter (2000)&quot;Excepcional C++&quot;</target>
        </trans-unit>
        <trans-unit id="4dba1c99fa72599cb430192c2725ee29e7826d41" translate="yes" xml:space="preserve">
          <source>H. Sutter (2004) &lt;a href=&quot;http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836&quot;&gt;&quot;When and How to Use Exceptions&quot;&lt;/a&gt; in Dr. Dobb's</source>
          <target state="translated">H. Sutter (2004) &lt;a href=&quot;http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836&quot;&gt;&quot;Cu&amp;aacute;ndo y c&amp;oacute;mo usar excepciones&quot;&lt;/a&gt; en Dr. Dobb's</target>
        </trans-unit>
        <trans-unit id="f3726a2cbec5aa86ee541f35ad869f9d462e3d65" translate="yes" xml:space="preserve">
          <source>H.Sutter, A. Alexandrescu (2004) &quot;C++ Coding Standards&quot; Item 73</source>
          <target state="translated">H.Sutter,A.Alexandrescu (2004)&quot;C++Coding Standards&quot; Item 73</target>
        </trans-unit>
        <trans-unit id="3ee760973e367e7fcaab598e6a4779e4ff88cda5" translate="yes" xml:space="preserve">
          <source>H.Sutter, A. Alexandrescu (2004), &quot;C++ Coding Standards&quot;, Item 70</source>
          <target state="translated">H.Sutter,A.Alexandrescu (2004),&quot;C++Coding Standards&quot;,Item 70</target>
        </trans-unit>
        <trans-unit id="202043e89dc2aeb009dea78fe3ba6aecc90d862d" translate="yes" xml:space="preserve">
          <source>HANGZHOU NUMERAL ONE - HANGUL DOUBLE DOT TONE MARK</source>
          <target state="translated">HANGZHOU NUMERAL UNO-HANGUL MARCA DE DOBLE PUNTO DE TONO</target>
        </trans-unit>
        <trans-unit id="498203d3437361cd8d2965b93c0eb3f8af84971a" translate="yes" xml:space="preserve">
          <source>HUGE_VALF, HUGE_VAL, HUGE_VALL</source>
          <target state="translated">GRAN_VALOR,GRAN_VALOR,GRAN_VALOR</target>
        </trans-unit>
        <trans-unit id="0ff054331f849fe26ab715fa596bf0d6c1b9b49c" translate="yes" xml:space="preserve">
          <source>HUGE_VALFHUGE_VALHUGE_VALL</source>
          <target state="translated">HUGE_VALFHUGE_VALHUGE_VALL</target>
        </trans-unit>
        <trans-unit id="b38181b2101d3ec22f60111fb7da75e6dc9d72e8" translate="yes" xml:space="preserve">
          <source>HUGE_VALL</source>
          <target state="translated">HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="71eafe8cf5a2cb341c2f05d96f0f6422891ac1dd" translate="yes" xml:space="preserve">
          <source>Handling of exception specification violations (removed in C++17)</source>
          <target state="translated">Manejo de las violaciones de las especificaciones de excepción (eliminado en C++17)</target>
        </trans-unit>
        <trans-unit id="5c4704b5df9665a78c88de802bae877af50465d2" translate="yes" xml:space="preserve">
          <source>Handling of failures in exception handling</source>
          <target state="translated">Manejo de fallas en el manejo de excepciones</target>
        </trans-unit>
        <trans-unit id="ea1720079c69bfadf4103ddaa2b4cd30fc66377a" translate="yes" xml:space="preserve">
          <source>Handling of variable length argument lists</source>
          <target state="translated">Manejo de listas de argumentos de longitud variable</target>
        </trans-unit>
        <trans-unit id="0e8c641cc752e55897602b479a23cc749b022d01" translate="yes" xml:space="preserve">
          <source>Happens-before</source>
          <target state="translated">Happens-before</target>
        </trans-unit>
        <trans-unit id="94332d550f7e901bb03f8bebf16b0fe18a1b3ec5" translate="yes" xml:space="preserve">
          <source>Hard links typically cannot cross filesystem boundaries.</source>
          <target state="translated">Los enlaces duros normalmente no pueden cruzar los límites del sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="5c50832940f07dd15684fc07335b91ae9b50c034" translate="yes" xml:space="preserve">
          <source>Hardlinking to directories is typically restricted to the superuser.</source>
          <target state="translated">La vinculación con los directorios está típicamente restringida al superusuario.</target>
        </trans-unit>
        <trans-unit id="b2bd7d3deca1dfde9d0e77745248dd3241e3fb2f" translate="yes" xml:space="preserve">
          <source>Hardware could require that an object to be referenced by an &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; have stricter alignment than other &lt;code&gt;T&lt;/code&gt; objects, and whether operations on an &lt;code&gt;atomic_ref&lt;/code&gt; are lock-free can depend on the alignment of the referenced object.</source>
          <target state="translated">El hardware podr&amp;iacute;a requerir que un objeto al que hace referencia un &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; tenga una alineaci&amp;oacute;n m&amp;aacute;s estricta que otros objetos &lt;code&gt;T&lt;/code&gt; , y si las operaciones en un &lt;code&gt;atomic_ref&lt;/code&gt; est&amp;aacute;n libres de bloqueo puede depender de la alineaci&amp;oacute;n del objeto referenciado.</target>
        </trans-unit>
        <trans-unit id="50278ca49d19fb7161c9b6156704c44ac84f382e" translate="yes" xml:space="preserve">
          <source>Has all non-static data members and bit-fields declared in the same class (either all in the derived or all in some base)</source>
          <target state="translated">Tiene todos los miembros de datos no estáticos y los campos de bits declarados en la misma clase (ya sea todos en la base derivada o todos en alguna base)</target>
        </trans-unit>
        <trans-unit id="132088df73d03b2b991fee16006dc96529cc0d11" translate="yes" xml:space="preserve">
          <source>Has no base classes of the same type as the first non-static data member (see &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;)</source>
          <target state="translated">No tiene clases base del mismo tipo que el primer miembro de datos no est&amp;aacute;tico (ver &lt;a href=&quot;../language/ebo&quot;&gt;optimizaci&amp;oacute;n de base vac&amp;iacute;a&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3282080bc3a2066760485abf22d4931cd7cf3786" translate="yes" xml:space="preserve">
          <source>Has no non-static data members of reference type</source>
          <target state="translated">No tiene miembros de datos no estáticos de tipo de referencia</target>
        </trans-unit>
        <trans-unit id="c4b0a2efb77a438bdd71e13e8a4b27ab2c2ef90e" translate="yes" xml:space="preserve">
          <source>Has no two (possibly indirect) base class subobjects of the same type</source>
          <target state="translated">No tiene dos subobjetos de clase base (posiblemente indirectos)del mismo tipo</target>
        </trans-unit>
        <trans-unit id="e78a6eedfa1171855e11a7dd558ba1ee29f9b975" translate="yes" xml:space="preserve">
          <source>Has no virtual functions or virtual base classes</source>
          <target state="translated">No tiene funciones virtuales o clases base virtuales</target>
        </trans-unit>
        <trans-unit id="07ad7632b84dfe67303c7a8f028a0886800e4870" translate="yes" xml:space="preserve">
          <source>Has one or more &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructors&lt;/a&gt;, all of which are either &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial&lt;/a&gt; or deleted, and at least one of which is not deleted.</source>
          <target state="translated">Tiene uno o m&amp;aacute;s &lt;a href=&quot;../language/default_constructor&quot;&gt;constructores predeterminados&lt;/a&gt; , todos los cuales son &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;triviales&lt;/a&gt; o eliminados, y al menos uno de los cuales no se elimina.</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="cc87e65725671e76b83dd75a39435552efd495a6" translate="yes" xml:space="preserve">
          <source>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.</source>
          <target state="translated">Las funciones de hash sólo se requieren para producir el mismo resultado para la misma entrada dentro de una sola ejecución de un programa;esto permite hashes salados que evitan los ataques de negación de servicio por colisión.</target>
        </trans-unit>
        <trans-unit id="4cd57ebbbfb5b1908d66fa1e003e1ce14e29637e" translate="yes" xml:space="preserve">
          <source>Hash functions should not throw exceptions.</source>
          <target state="translated">Las funciones de hash no deben arrojar excepciones.</target>
        </trans-unit>
        <trans-unit id="7250b05d4111b3b36a49cda927210c8e3d368f6a" translate="yes" xml:space="preserve">
          <source>Hash policy</source>
          <target state="translated">Política de Hash</target>
        </trans-unit>
        <trans-unit id="b807d317600ff4b338e846d561ee4e0b84f0360a" translate="yes" xml:space="preserve">
          <source>Hash support</source>
          <target state="translated">Soporte de hachís</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="31341c6f0c7af677ffb8fadcb92038e8ac2b6193" translate="yes" xml:space="preserve">
          <source>Header</source>
          <target state="translated">Header</target>
        </trans-unit>
        <trans-unit id="f123fa3f00736262aa136563dd12c3a430fa1bf8" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive.</source>
          <target state="translated">Los tokens de preprocesamiento de nombre de encabezado solo se forman dentro de una directiva &lt;code&gt;#include&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a9eca02fd1369c5ba18c271ae9822e684c6bc3d" translate="yes" xml:space="preserve">
          <source>Headers required for a</source>
          <target state="translated">Los encabezados requeridos para una</target>
        </trans-unit>
        <trans-unit id="8cd5e50ec159eebcf43e109ff007519db94c87f5" translate="yes" xml:space="preserve">
          <source>Heap allocation</source>
          <target state="translated">Asignación de la pila</target>
        </trans-unit>
        <trans-unit id="adcf91c671cec8bebaf87ee37c2421ff5ebb56fd" translate="yes" xml:space="preserve">
          <source>Heap operations</source>
          <target state="translated">Operaciones de acumulación...</target>
        </trans-unit>
        <trans-unit id="43a1b94a7a6895d855248fbccdd91510cfbd3ac0" translate="yes" xml:space="preserve">
          <source>Helper Classes</source>
          <target state="translated">Clases de ayuda</target>
        </trans-unit>
        <trans-unit id="035f96a8918459049a59bec0947605cd2a64fdef" translate="yes" xml:space="preserve">
          <source>Helper classes</source>
          <target state="translated">Clases para ayudantes</target>
        </trans-unit>
        <trans-unit id="7612db9ee91cb4487af96f647ff4f3cd2038be3a" translate="yes" xml:space="preserve">
          <source>Helper concepts</source>
          <target state="translated">Conceptos de ayuda</target>
        </trans-unit>
        <trans-unit id="058d2ea713d8ed40ef598fece850d00d28cef415" translate="yes" xml:space="preserve">
          <source>Helper functions &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; are often used to generate &lt;code&gt;std::reference_wrapper&lt;/code&gt; objects.</source>
          <target state="translated">Las funciones auxiliares &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; se usan a menudo para generar objetos &lt;code&gt;std::reference_wrapper&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9564c40bd71a52a2d2792a274dcd71ecab83247" translate="yes" xml:space="preserve">
          <source>Helper functions to control the format of input and output</source>
          <target state="translated">Funciones de ayuda para controlar el formato de entrada y salida</target>
        </trans-unit>
        <trans-unit id="24355834da4c51ce8fa25dadf7ca038baf516e2f" translate="yes" xml:space="preserve">
          <source>Helper objects</source>
          <target state="translated">Objetos de ayuda</target>
        </trans-unit>
        <trans-unit id="bbca939563aab0002ed11e9e60251643d9e2435c" translate="yes" xml:space="preserve">
          <source>Helper template</source>
          <target state="translated">Plantilla del ayudante</target>
        </trans-unit>
        <trans-unit id="26e4565205fc729962b9119b4035fad3d08ea499" translate="yes" xml:space="preserve">
          <source>Helper template alias</source>
          <target state="translated">El alias de la plantilla de ayudantes</target>
        </trans-unit>
        <trans-unit id="62f3bc8fedb9c00e4b9d3da1c58627fb9c932c3e" translate="yes" xml:space="preserve">
          <source>Helper templates</source>
          <target state="translated">Plantillas de ayuda</target>
        </trans-unit>
        <trans-unit id="58208feff4ae33c36603b46c3dceaa24f222cc8d" translate="yes" xml:space="preserve">
          <source>Helper types</source>
          <target state="translated">Tipos de ayudantes</target>
        </trans-unit>
        <trans-unit id="0b456005f09a660089e455709c3792d427e45f64" translate="yes" xml:space="preserve">
          <source>Helper variable template</source>
          <target state="translated">Plantilla variable del ayudante</target>
        </trans-unit>
        <trans-unit id="777d2c2c6fac9bb59d841ec60aa0bce62ce73ffb" translate="yes" xml:space="preserve">
          <source>Helper variable templates</source>
          <target state="translated">Plantillas de variables de ayuda</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="7023d54552e06b34cfb338ed903ce5341dc89c1a" translate="yes" xml:space="preserve">
          <source>Here &amp;mu; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;mean&lt;/a&gt; and &amp;sigma; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; (</source>
          <target state="translated">Aqu&amp;iacute; &amp;mu; es la &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;media&lt;/a&gt; y &amp;sigma; es la &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;desviaci&amp;oacute;n est&amp;aacute;ndar&lt;/a&gt; (</target>
        </trans-unit>
        <trans-unit id="de582de9c63661c059dbbb7442ed40762e356594" translate="yes" xml:space="preserve">
          <source>Here the sequence &lt;code&gt;= 0&lt;/code&gt; is known as pure-specifier, and appears either immediately after the declarator or after the optional virt-specifier (&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;).</source>
          <target state="translated">Aqu&amp;iacute; la secuencia &lt;code&gt;= 0&lt;/code&gt; se conoce como pura-especificador, y aparece ya sea inmediatamente despu&amp;eacute;s de la declarador o despu&amp;eacute;s de la virt-especificador opcional ( &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; o &lt;a href=&quot;final&quot;&gt;definitiva&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4d46b65d1ca1962518c48c70d9aa7c8452f90c5" translate="yes" xml:space="preserve">
          <source>Here, &lt;b&gt;insertion&lt;/b&gt; refers to any method which adds one or more elements to the container and &lt;b&gt;erasure&lt;/b&gt; refers to any method which removes one or more elements from the container.</source>
          <target state="translated">Aqu&amp;iacute;, la &lt;b&gt;inserci&amp;oacute;n se&lt;/b&gt; refiere a cualquier m&amp;eacute;todo que agrega uno o m&amp;aacute;s elementos al contenedor y la &lt;b&gt;eliminaci&amp;oacute;n se&lt;/b&gt; refiere a cualquier m&amp;eacute;todo que elimina uno o m&amp;aacute;s elementos del contenedor.</target>
        </trans-unit>
        <trans-unit id="b19a132f13926967d1824a2efe39a0ee64381eb2" translate="yes" xml:space="preserve">
          <source>Hermite polynomials</source>
          <target state="translated">Los polinomios de las hermitas</target>
        </trans-unit>
        <trans-unit id="2dc4f9ad06827dbb0f947199ccb4b57ddbc18030" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="translated">Las secuencias de escape hexadecimales no tienen l&amp;iacute;mite de longitud y terminan en el primer car&amp;aacute;cter que no es un d&amp;iacute;gito hexadecimal v&amp;aacute;lido. Si el valor representado por una &amp;uacute;nica secuencia de escape hexadecimal no se ajusta al rango de valores representados por el tipo de caracteres utilizado en este literal de cadena ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; o &lt;code&gt;wchar_t&lt;/code&gt; ), el resultado no se especifica.</target>
        </trans-unit>
        <trans-unit id="29f4576900e04b4bdfd8b4fe7f982605474c3863" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating literals</source>
          <target state="translated">Literales flotantes hexadecimales</target>
        </trans-unit>
        <trans-unit id="fcb2d1955da83c672014766fe096b6618bd4cc33" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point formatting ignores the stream precision specification, as required by the specification of &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El formato de punto flotante hexadecimal ignora la especificaci&amp;oacute;n de precisi&amp;oacute;n de flujo, como lo requiere la especificaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="903711dad7d075316de1f7c8c822711821173306" translate="yes" xml:space="preserve">
          <source>Higher level memory management utilities</source>
          <target state="translated">Utilidades de gestión de memoria de alto nivel</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="0201fd3572c6260109888327f99b40b98e8c814b" translate="yes" xml:space="preserve">
          <source>History of C++</source>
          <target state="translated">Historia de C++</target>
        </trans-unit>
        <trans-unit id="9c025e64c93f51353b31decb167c0c14635a6990" translate="yes" xml:space="preserve">
          <source>Host is unreachable</source>
          <target state="translated">El anfitrión es inalcanzable</target>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="translated">Hora,minuto,segundo</target>
        </trans-unit>
        <trans-unit id="a84d5827435e6eaee2628507f60c486924602e72" translate="yes" xml:space="preserve">
          <source>However if &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; no applications of the predicate are made.</source>
          <target state="translated">Sin embargo, si &lt;code&gt;ForwardIt1&lt;/code&gt; y &lt;code&gt;ForwardIt2&lt;/code&gt; cumplen los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; y &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; no se realizan aplicaciones del predicado.</target>
        </trans-unit>
        <trans-unit id="06e6faa2b0497056bfffbc66aaba9ed450e5ff3a" translate="yes" xml:space="preserve">
          <source>However, all C++ compilers use &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;two's complement&lt;/a&gt; representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from -2N-1</source>
          <target state="translated">Sin embargo, todos los compiladores de C ++ usan &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;la&lt;/a&gt; representaci&amp;oacute;n del complemento a dos , y a partir de C ++ 20, es la &amp;uacute;nica representaci&amp;oacute;n permitida por el est&amp;aacute;ndar, con el rango garantizado de -2N-1</target>
        </trans-unit>
        <trans-unit id="a5298c4b4732ec5cdb50753f0b7bff99ff4504e8" translate="yes" xml:space="preserve">
          <source>However, base class subobjects are not so constrained, and can be completely optimized out from the object layout:</source>
          <target state="translated">Sin embargo,los subobjetos de la clase base no están tan limitados,y pueden ser completamente optimizados a partir de la disposición del objeto:</target>
        </trans-unit>
        <trans-unit id="0474028c83ae02e6c1719cbd200f19338eb23c2e" translate="yes" xml:space="preserve">
          <source>However, for non-&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;, the number of iterator increments is O(N).</source>
          <target state="translated">Sin embargo, para los no &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; , el n&amp;uacute;mero de incrementos de iterador es O (N).</target>
        </trans-unit>
        <trans-unit id="a7074ce423985ae2c548c5817d3af2b722ab809a" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;BidirIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">Sin embargo, si &lt;code&gt;BidirIt&lt;/code&gt; cumple adicionalmente con los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , la complejidad es constante.</target>
        </trans-unit>
        <trans-unit id="c130fc889986236f01e7bd0a7491d9e506116625" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; then no applications of the predicate are made (size mismatch is detected without looking at any elements).</source>
          <target state="translated">Sin embargo, si &lt;code&gt;InputIt1&lt;/code&gt; y &lt;code&gt;InputIt2&lt;/code&gt; cumplen los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; y &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; , no se realizan aplicaciones del predicado (se detecta una discrepancia de tama&amp;ntilde;o sin mirar ning&amp;uacute;n elemento).</target>
        </trans-unit>
        <trans-unit id="d4de2084e6a7ba7c4a9702f5d91188f9754f96a6" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">Sin embargo, si &lt;code&gt;InputIt&lt;/code&gt; cumple adicionalmente con los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , la complejidad es constante.</target>
        </trans-unit>
        <trans-unit id="923af777ec78d98d0a47fdd5e9f0c732405eb150" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">Sin embargo, si &lt;code&gt;InputIt&lt;/code&gt; o &lt;code&gt;ForwardIt&lt;/code&gt; cumple adicionalmente con los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; , la complejidad es constante.</target>
        </trans-unit>
        <trans-unit id="789aa7b03048a6d89e55166c2876d111a76287b2" translate="yes" xml:space="preserve">
          <source>However, if deduction succeeds for all parameters that participate in template argument deduction, and all template arguments that aren't deduced are explicitly specified or defaulted, then the remaining function parameters are compared with the corresponding function arguments. For each remaining parameter &lt;code&gt;P&lt;/code&gt; with a type that was non-dependent before substitution of any explicitly-specified template arguments, if the corresponding argument &lt;code&gt;A&lt;/code&gt; cannot be implicitly converted to &lt;code&gt;P&lt;/code&gt;, deduction fails.</source>
          <target state="translated">Sin embargo, si la deducci&amp;oacute;n tiene &amp;eacute;xito para todos los par&amp;aacute;metros que participan en la deducci&amp;oacute;n de argumentos de plantilla, y todos los argumentos de plantilla que no se deducen se especifican expl&amp;iacute;citamente o se omiten, los par&amp;aacute;metros de funci&amp;oacute;n restantes se comparan con los argumentos de funci&amp;oacute;n correspondientes. Para cada par&amp;aacute;metro restante &lt;code&gt;P&lt;/code&gt; con un tipo que no era dependiente antes de la sustituci&amp;oacute;n de cualquier argumento de plantilla especificado expl&amp;iacute;citamente, si el argumento correspondiente &lt;code&gt;A&lt;/code&gt; no se puede convertir impl&amp;iacute;citamente a &lt;code&gt;P&lt;/code&gt; , la deducci&amp;oacute;n falla.</target>
        </trans-unit>
        <trans-unit id="d3ec3f026f2aba3bad033eb828adf9c63839692d" translate="yes" xml:space="preserve">
          <source>However, if the declaration uses &lt;a href=&quot;constexpr&quot;&gt;&lt;code&gt;constexpr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;(since C++17) specifier, the member must be declared to have complete type.</source>
          <target state="translated">Sin embargo, si la declaraci&amp;oacute;n usa &lt;a href=&quot;constexpr&quot;&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;/a&gt; o un especificador en &lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt; (desde C ++ 17), se debe declarar que el miembro tiene un tipo completo.</target>
        </trans-unit>
        <trans-unit id="9217191a146bae3519a7a8c89cf7f10d4b0ff050" translate="yes" xml:space="preserve">
          <source>However, one implementation (libc++) is known to construct the &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; objects via two separate allocator &lt;code&gt;construct()&lt;/code&gt; calls, as arguably required by the standards as published, rather than emplacing a &lt;code&gt;value_type&lt;/code&gt; object.</source>
          <target state="translated">Sin embargo, se sabe que una implementaci&amp;oacute;n (libc ++) construye los objetos &lt;code&gt;key_type&lt;/code&gt; y &lt;code&gt;mapped_type&lt;/code&gt; a trav&amp;eacute;s de dos llamadas de &lt;code&gt;construct()&lt;/code&gt; asignador separadas , como posiblemente lo exijan los est&amp;aacute;ndares publicados, en lugar de emplazar un objeto &lt;code&gt;value_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b2db98636723bfe7992740aadfd807719cd51f4" translate="yes" xml:space="preserve">
          <source>However, the attributes that appear after the declarator (in the syntax above), apply to the type of the function, not to the function itself.</source>
          <target state="translated">Sin embargo,los atributos que aparecen después del declarante (en la sintaxis anterior),se aplican al tipo de la función,no a la función misma.</target>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">El coseno hiperb&amp;oacute;lico es una funci&amp;oacute;n completa en el plano complejo y no tiene cortes de rama. Es peri&amp;oacute;dico con respecto al componente imaginario, con per&amp;iacute;odo 2&amp;pi;i.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">Funciones hiperbólicas</target>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">El seno hiperb&amp;oacute;lico es una funci&amp;oacute;n completa en el plano complejo y no tiene cortes de ramas. Es peri&amp;oacute;dico con respecto al componente imaginario, con per&amp;iacute;odo 2&amp;pi;i.</target>
        </trans-unit>
        <trans-unit id="c6a249eb7c58320fe1bb3e19e6e61f7ae663bb92" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">La tangente hiperb&amp;oacute;lica es una funci&amp;oacute;n anal&amp;iacute;tica en la llanura compleja y no tiene cortes de ramas. Es peri&amp;oacute;dico con respecto al componente imaginario, con per&amp;iacute;odo &amp;pi;i, y tiene polos de primer orden a lo largo de la l&amp;iacute;nea imaginaria, en las coordenadas (0, &amp;pi; (1/2 + n)). Sin embargo, ninguna representaci&amp;oacute;n com&amp;uacute;n de coma flotante puede representar exactamente &amp;pi; / 2, por lo tanto, no hay ning&amp;uacute;n valor del argumento para el que se produce un error de polo.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="6b58ece8e2eb85355e743b6e1a72cb6eb0c30006" translate="yes" xml:space="preserve">
          <source>I/O Manipulators</source>
          <target state="translated">Manipuladores I/O</target>
        </trans-unit>
        <trans-unit id="0676b814ab2a9d403059287e94b18b3f3ed5e63c" translate="yes" xml:space="preserve">
          <source>I/O error</source>
          <target state="translated">Error de E/S</target>
        </trans-unit>
        <trans-unit id="3fd6cee6dbc10d47db1d5e293da18cd3279cfd34" translate="yes" xml:space="preserve">
          <source>I/O format flags are obtained, as if by</source>
          <target state="translated">Los indicadores de formato de E/S se obtienen,como si por</target>
        </trans-unit>
        <trans-unit id="00a1147221fe28724b5d852d3cc11debd18ea881" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ Inline Assembly</source>
          <target state="translated">IBM XL C/C++Ensamblaje en línea</target>
        </trans-unit>
        <trans-unit id="97e6907b70a51197746c7a59244053494e95092c" translate="yes" xml:space="preserve">
          <source>ICE</source>
          <target state="translated">ICE</target>
        </trans-unit>
        <trans-unit id="2eb6372a578be72d248c4e343e8fc7a5d78b9a77" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="translated">IEC 60559 recomienda que &lt;code&gt;from&lt;/code&gt; retorna siempre &lt;code&gt;from==to&lt;/code&gt; . En cambio, estas funciones vuelven &lt;code&gt;to&lt;/code&gt; , lo que hace que el comportamiento alrededor de cero sea consistente: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; devuelve &lt;code&gt;+0.0&lt;/code&gt; y &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; devuelve &lt;code&gt;&amp;ndash;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="47a57f6b8f5e7dac870d669f2d10489423c2c097" translate="yes" xml:space="preserve">
          <source>INVERTED UNDERTIE</source>
          <target state="translated">CORBATA INTERIOR INVERTIDA</target>
        </trans-unit>
        <trans-unit id="6f332e7bc9fb4c964cc115b4bb4e0c9c81b651a9" translate="yes" xml:space="preserve">
          <source>INVOKE</source>
          <target state="translated">INVOKE</target>
        </trans-unit>
        <trans-unit id="bfa0e3fd8d2d6bf8a03a66ca3906291682906b88" translate="yes" xml:space="preserve">
          <source>INVOKE&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOCAR &amp;lt;R&amp;gt; (f, t1, t2, ..., tN)</target>
        </trans-unit>
        <trans-unit id="381dd7d678830c863bcf610275aa82caf553b63a" translate="yes" xml:space="preserve">
          <source>INVOKE(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOCACIÓN(f,t1,t2,...,tN)</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="translated">La ISO 30112 define los caracteres de control POSIX como caracteres Unicode U+0000..U+001F,U+007F..U+009F,U+2028,y U+2029 (clases Unicode Cc,Zl,y Zp).</target>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="translated">ISO 30112 define los caracteres de espacio POSIX como caracteres Unicode U+0009..U+000D,U+0020,U+1680,U+180E,U+2000..U+2006,U+2008..U+200A,U+2028,U+2029,U+205F,y U+3000.</target>
        </trans-unit>
        <trans-unit id="83c8d536c17446dc8d23f11cf08547ab6f0ceaef" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-based year</source>
          <target state="translated">ISO 8601 año basado en la semana</target>
        </trans-unit>
        <trans-unit id="660c1f28ee4e6a1155a4515d1d3d38f625034fe8" translate="yes" xml:space="preserve">
          <source>ISO C language standard requires that C compilers support the following three pragmas, and some C++ compiler vendors support them, to varying degrees, in their C++ frontends:</source>
          <target state="translated">El estándar del lenguaje C de la ISO requiere que los compiladores C soporten los siguientes tres pragmas,y algunos proveedores de compiladores C++los soportan,en diversos grados,en sus frontales C++:</target>
        </trans-unit>
        <trans-unit id="f0de3ffcac31393cdc320a257a71c6856ecd9b41" translate="yes" xml:space="preserve">
          <source>Identical to the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">Id&amp;eacute;ntico a la complejidad de &lt;code&gt;Container::emplace_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c1a745105ff9b6c357cf50bdd91090ffef6ae55" translate="yes" xml:space="preserve">
          <source>Identifier removed</source>
          <target state="translated">Se ha eliminado el identificador</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
