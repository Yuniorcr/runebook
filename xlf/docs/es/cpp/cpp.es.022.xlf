<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="09af74812a9060b648ff5292103d113c603a82ef" translate="yes" xml:space="preserve">
          <source>The index-based overloads (1-4) fail to compile if the index &lt;code&gt;I&lt;/code&gt; is neither 0 nor 1.</source>
          <target state="translated">Las sobrecargas basadas en &amp;iacute;ndices (1-4) no se compilan si el &amp;iacute;ndice &lt;code&gt;I&lt;/code&gt; no es ni 0 ni 1.</target>
        </trans-unit>
        <trans-unit id="46437bdc4c7e2e85424bc222273ad44e53f18e36" translate="yes" xml:space="preserve">
          <source>The indicated operator can be applied to type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">El operador indicado se puede aplicar al tipo &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7846514f422b5378fb77af4cf9b31d07acbbdb16" translate="yes" xml:space="preserve">
          <source>The indirection and member operators are overloaded by many iterators and smart pointer classes.</source>
          <target state="translated">Los operadores indirectos y miembros están sobrecargados por muchos iteradores y clases de punteros inteligentes.</target>
        </trans-unit>
        <trans-unit id="8129cebea0ce621764c93ae2762d3f9a991933ef" translate="yes" xml:space="preserve">
          <source>The indirection operator expressions have the form.</source>
          <target state="translated">Las expresiones de operador indirecto tienen la forma.</target>
        </trans-unit>
        <trans-unit id="9f172228ef4f13bff865c966d96876715b4f88e1" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration, and may be obtained by the member functions of &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt;. During directory iteration, calling &lt;code&gt;status&lt;/code&gt; again is unnecessary.</source>
          <target state="translated">La informaci&amp;oacute;n proporcionada por esta funci&amp;oacute;n generalmente tambi&amp;eacute;n se proporciona como un subproducto de la iteraci&amp;oacute;n de directorio, y puede ser obtenida por las funciones miembro de &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt; . Durante la iteraci&amp;oacute;n del directorio, &lt;code&gt;status&lt;/code&gt; es necesario llamar nuevamente al estado .</target>
        </trans-unit>
        <trans-unit id="0116c386923508482ffe7b197c85ac890bdc4bf4" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration. During directory iteration, calling &lt;code&gt;exists(*iterator)&lt;/code&gt; is less efficient than &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt;.</source>
          <target state="translated">La informaci&amp;oacute;n proporcionada por esta funci&amp;oacute;n generalmente tambi&amp;eacute;n se proporciona como un subproducto de la iteraci&amp;oacute;n del directorio. Durante la iteraci&amp;oacute;n del directorio, la llamada &lt;code&gt;exists(*iterator)&lt;/code&gt; es menos eficiente que la &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8eeab648787f5a49f075a54a3ff963c76b7abfc" translate="yes" xml:space="preserve">
          <source>The inherited constructors are equivalent to user-defined constructors with an empty body and with a &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; consisting of a single nested-name-specifier, which forwards all of its arguments to the base class constructor.</source>
          <target state="translated">Los constructores heredados son equivalentes a los constructores definidos por el usuario con un cuerpo vac&amp;iacute;o y con una &lt;a href=&quot;constructor&quot;&gt;lista de inicializadores de miembros que&lt;/a&gt; consta de un &amp;uacute;nico especificador de nombre anidado, que reenv&amp;iacute;a todos sus argumentos al constructor de la clase base.</target>
        </trans-unit>
        <trans-unit id="d9039e574ac657d6dcb969a83965e5c07901ebe3" translate="yes" xml:space="preserve">
          <source>The initial value may be provided in the initializer section of a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; or a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt;. It also takes place during function calls: function parameters and the function return values are also initialized.</source>
          <target state="translated">El valor inicial se puede proporcionar en la secci&amp;oacute;n de inicializador de un &lt;a href=&quot;declarations&quot;&gt;declarador&lt;/a&gt; o una &lt;a href=&quot;new&quot;&gt;nueva expresi&amp;oacute;n&lt;/a&gt; . Tambi&amp;eacute;n tiene lugar durante las llamadas a funciones: los par&amp;aacute;metros de funci&amp;oacute;n y los valores de retorno de funci&amp;oacute;n tambi&amp;eacute;n se inicializan.</target>
        </trans-unit>
        <trans-unit id="dca3507cd72234d2aa0fdea51eb1cebb2b9753f0" translate="yes" xml:space="preserve">
          <source>The initializers where class-or-identifier names a &lt;a href=&quot;derived_class&quot;&gt;virtual base class&lt;/a&gt; are ignored during execution of constructors of any class that is not the most derived class of the object that's being constructed.</source>
          <target state="translated">Los inicializadores donde los nombres de clase o identificador de una &lt;a href=&quot;derived_class&quot;&gt;clase base virtual&lt;/a&gt; se ignoran durante la ejecuci&amp;oacute;n de constructores de cualquier clase que no sea la clase m&amp;aacute;s derivada del objeto que se est&amp;aacute; construyendo.</target>
        </trans-unit>
        <trans-unit id="51f3e6edc128bfcb0be013fd2d1ae1da69f60e07" translate="yes" xml:space="preserve">
          <source>The injected-class-name is the name of a class within the scope of said class.</source>
          <target state="translated">El nombre de la clase inyectada es el nombre de una clase dentro del ámbito de dicha clase.</target>
        </trans-unit>
        <trans-unit id="606b29738683260e78646411c4bd2990a0c81802" translate="yes" xml:space="preserve">
          <source>The injected-class-name of a class template or class template specialization can be used either as a template-name or a type-name wherever it is in scope.</source>
          <target state="translated">El nombre de la clase inyectada de una plantilla de clase o de la especialización de la plantilla de clase puede utilizarse como nombre de la plantilla o como nombre del tipo,independientemente de su ámbito de aplicación.</target>
        </trans-unit>
        <trans-unit id="588b0a23a80aa452a55821a2b55a11188b48a689" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot be used with a function or variable(since C++17) declaration at block scope (inside another function).</source>
          <target state="translated">El especificador en línea no puede utilizarse con una declaración de función o variable (desde C++17)en el ámbito del bloque (dentro de otra función).</target>
        </trans-unit>
        <trans-unit id="11abde87d1d2ac1bfae6d03e1fd645c8d719bd0d" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot re-declare a function or variable(since C++17) that was already defined in the translation unit as non-inline.</source>
          <target state="translated">El especificador en línea no puede volver a declarar una función o variable (desde C++17)que ya estaba definida en la unidad de traducción como no en línea.</target>
        </trans-unit>
        <trans-unit id="5dbd088428b0bac15f8a60242c8b9596e62e2450" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with the conversion specifier selected in Stage 1</source>
          <target state="translated">La entrada se analiza como si fuera &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; con el especificador de conversi&amp;oacute;n seleccionado en la Etapa 1</target>
        </trans-unit>
        <trans-unit id="e89c213728057cbded885c2e82d2eb3ce4460233" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;float&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;long double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">La entrada se analiza como si fuera &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; para entero con signo &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; para entero sin signo &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;float&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;long double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41603f2c61d6937ed51388a6bc806662aaa244d7" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for floating-point &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">La entrada se analiza como si fuera &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; para entero con signo &lt;code&gt;v&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; para entero sin signo &lt;code&gt;v&lt;/code&gt; , o &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; para punto flotante &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eae9126bfe2845e4a7f3d75fa1de5c6799e7530" translate="yes" xml:space="preserve">
          <source>The inputs to an expression consist of its operands.</source>
          <target state="translated">Las entradas de una expresión consisten en sus operandos.</target>
        </trans-unit>
        <trans-unit id="607e5d93133cf024a79ee0801db268525f2aa983" translate="yes" xml:space="preserve">
          <source>The insertion operation in &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;.</source>
          <target state="translated">La operaci&amp;oacute;n de inserci&amp;oacute;n en &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; comporta como una &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c7b3ed830ddfb4f12cf5eaf80d05dfaf6783a2" translate="yes" xml:space="preserve">
          <source>The instantiation of a</source>
          <target state="translated">La instanciación de un</target>
        </trans-unit>
        <trans-unit id="e91461402009e482fb1a78f2f939226ff4aded6b" translate="yes" xml:space="preserve">
          <source>The integer value that is stored together with the callback is typically an index obtained from &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El valor entero que se almacena junto con la devoluci&amp;oacute;n de llamada suele ser un &amp;iacute;ndice obtenido de &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e754c5d2f0c37f77dbd459373feccfde0264f302" translate="yes" xml:space="preserve">
          <source>The integral type generated by the engine. Results are undefined if this is not an unsigned integral type.</source>
          <target state="translated">El tipo integral generado por el motor.Los resultados no se definen si no es un tipo integral sin signo.</target>
        </trans-unit>
        <trans-unit id="40c53aad3caa79b07c6f8ca53ea06f1869a292cc" translate="yes" xml:space="preserve">
          <source>The intent of concepts is to model semantic categories (Number, Range, RegularFunction) rather than syntactic restrictions (HasPlus, Array). According to &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;ISO C++ core guideline T.20&lt;/a&gt;, &quot;The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint.&quot;</source>
          <target state="translated">La intenci&amp;oacute;n de los conceptos es modelar categor&amp;iacute;as sem&amp;aacute;nticas (N&amp;uacute;mero, Rango, Funci&amp;oacute;n Regular) en lugar de restricciones sint&amp;aacute;cticas (HasPlus, Array). De acuerdo con &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;la directriz central ISO C ++ T.20&lt;/a&gt; , &quot;La capacidad de especificar una sem&amp;aacute;ntica significativa es una caracter&amp;iacute;stica definitoria de un concepto verdadero, en oposici&amp;oacute;n a una restricci&amp;oacute;n sint&amp;aacute;ctica&quot;.</target>
        </trans-unit>
        <trans-unit id="619a8685fc9309dd7fa35fcbb4dc104bf7401e8a" translate="yes" xml:space="preserve">
          <source>The intent of this function is to allow &lt;a href=&quot;../../language/range-for&quot;&gt;range for loops&lt;/a&gt; to work with valarrays, not to provide container semantics.</source>
          <target state="translated">La intenci&amp;oacute;n de esta funci&amp;oacute;n es permitir &lt;a href=&quot;../../language/range-for&quot;&gt;que los bucles&lt;/a&gt; funcionen con valarrays, no proporcionar sem&amp;aacute;ntica de contenedor.</target>
        </trans-unit>
        <trans-unit id="8413f561941f9afa4883b6089ece4689223790be" translate="yes" xml:space="preserve">
          <source>The intent of this requirement is to preserve binary compatibility between the C++ library complex number types and the &lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;C language complex number types&lt;/a&gt; (and arrays thereof), which have an identical object representation requirement.</source>
          <target state="translated">La intenci&amp;oacute;n de este requisito es preservar la compatibilidad binaria entre los tipos de n&amp;uacute;meros complejos de la biblioteca C ++ y los &lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;tipos de n&amp;uacute;meros complejos del lenguaje C&lt;/a&gt; (y sus matrices), que tienen un requisito de representaci&amp;oacute;n de objeto id&amp;eacute;ntico.</target>
        </trans-unit>
        <trans-unit id="8f653c0dd9ae48a2397aac170d1b0f16776c082f" translate="yes" xml:space="preserve">
          <source>The interface of C++ standard library is defined by the following collection of headers.</source>
          <target state="translated">La interfaz de la biblioteca estándar de C++está definida por la siguiente colección de encabezados.</target>
        </trans-unit>
        <trans-unit id="6b2570d1e40f42d32deec64488687b81c00f5106" translate="yes" xml:space="preserve">
          <source>The internal pathname in generic pathname format, converted to specified string type.</source>
          <target state="translated">La ruta interna en formato de ruta genérica,convertida a un tipo de cadena especificado.</target>
        </trans-unit>
        <trans-unit id="9e600bbfc64aa5e497181bbfbd63f0f68de6a8dc" translate="yes" xml:space="preserve">
          <source>The internal pathname in native pathname format, converted to specified string type.</source>
          <target state="translated">La ruta interna en formato de ruta nativa,convertida a un tipo de cadena especificado.</target>
        </trans-unit>
        <trans-unit id="004ca417b1356b06ecce1a0eded3b5b9c702a405" translate="yes" xml:space="preserve">
          <source>The inverse of the referenced bit.</source>
          <target state="translated">El inverso del bit de referencia.</target>
        </trans-unit>
        <trans-unit id="94b5c297f476b2d4707fabdba8af9c74ed678810" translate="yes" xml:space="preserve">
          <source>The invocation of &lt;code&gt;setjmp&lt;/code&gt; must appear only in one of the following contexts:</source>
          <target state="translated">La invocaci&amp;oacute;n de &lt;code&gt;setjmp&lt;/code&gt; debe aparecer solo en uno de los siguientes contextos:</target>
        </trans-unit>
        <trans-unit id="e9cf86ded4e35142c7778644f54d0174bfb84173" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multimap&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">No es necesario que el orden de iteraci&amp;oacute;n de este contenedor sea estable (por lo tanto, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; no se puede usar para comparar dos &lt;code&gt;std::unordered_multimap&lt;/code&gt; s), excepto que cada grupo de elementos cuyas claves se comparan</target>
        </trans-unit>
        <trans-unit id="97c9b700924b706247c8bc9808f1bc7725c3a1aa" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multiset&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">No es necesario que el orden de iteraci&amp;oacute;n de este contenedor sea estable (por lo tanto, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; no se puede usar para comparar dos &lt;code&gt;std::unordered_multiset&lt;/code&gt; s), excepto que cada grupo de elementos cuyas claves se comparan</target>
        </trans-unit>
        <trans-unit id="1863ed213c7ef5f7feaa4f2890c2f01f674b7ab4" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;first&lt;/code&gt; does not need to be dereferenceable if &lt;code&gt;first==last&lt;/code&gt;: erasing an empty range is a no-op.</source>
          <target state="translated">El iterador &lt;code&gt;first&lt;/code&gt; no necesita ser desreferenciable si &lt;code&gt;first==last&lt;/code&gt; : borrar un rango vac&amp;iacute;o es un no-op.</target>
        </trans-unit>
        <trans-unit id="416bf9a217d579e782b2dcb1f169937401418ec1" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferencable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">El iterador &lt;code&gt;pos&lt;/code&gt; debe ser v&amp;aacute;lido y Dereferenceable. Por lo tanto, el iterador &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; (que es v&amp;aacute;lido, pero no es descartable) no se puede usar como un valor para &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b61e02fbf920d53ad39bacd79891eb0d1792824a" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferenceable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">El iterador &lt;code&gt;pos&lt;/code&gt; debe ser v&amp;aacute;lido y Dereferenceable. Por lo tanto, el iterador &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; (que es v&amp;aacute;lido, pero no es desreferenciable) no puede usarse como un valor para &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eb90b5d51c71efded43df27cab17311bc850303" translate="yes" xml:space="preserve">
          <source>The iterator equal to &lt;code&gt;first + (last - n_first)&lt;/code&gt;.</source>
          <target state="translated">El iterador igual a &lt;code&gt;first + (last - n_first)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abfb235c9222b9db1250ee25ae21c35e487f8f38" translate="yes" xml:space="preserve">
          <source>The iterator library provides definitions for five(until C++17)six(since C++17) kinds of iterators as well as iterator traits, adaptors, and utility functions.</source>
          <target state="translated">La biblioteca de iteradores proporciona definiciones para cinco (hasta C++17)seis (desde C++17)tipos de iteradores,así como rasgos de iterador,adaptadores y funciones de utilidad.</target>
        </trans-unit>
        <trans-unit id="196d09b17633c1d18330b9904d4f41189e178366" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function is invalidated when the member function &lt;code&gt;resize()&lt;/code&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">El iterador obtenido de esta funci&amp;oacute;n se invalida cuando se llama a la funci&amp;oacute;n miembro &lt;code&gt;resize()&lt;/code&gt; en la matriz &lt;code&gt;v&lt;/code&gt; o cuando finaliza la vida &amp;uacute;til de &lt;code&gt;v&lt;/code&gt; , lo que ocurra primero.</target>
        </trans-unit>
        <trans-unit id="05de9016d2fdcc550169519b30085812eef58929" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function template is invalidated when the member function &lt;a href=&quot;resize&quot;&gt;&lt;code&gt;resize()&lt;/code&gt;&lt;/a&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">El iterador obtenido de esta plantilla de funci&amp;oacute;n se invalida cuando se llama a la funci&amp;oacute;n miembro &lt;a href=&quot;resize&quot;&gt; &lt;code&gt;resize()&lt;/code&gt; &lt;/a&gt; en la matriz &lt;code&gt;v&lt;/code&gt; o cuando finaliza la vida &amp;uacute;til de &lt;code&gt;v&lt;/code&gt; , lo que ocurra primero.</target>
        </trans-unit>
        <trans-unit id="6f533c17b31181fda7a7478422455fda0c5a1103" translate="yes" xml:space="preserve">
          <source>The iterator past the end of the first partition within &lt;code&gt;[first, last)&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">El iterador pasa el final de la primera partici&amp;oacute;n dentro de &lt;code&gt;[first, last)&lt;/code&gt; o &lt;code&gt;last&lt;/code&gt; si todos los elementos satisfacen &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="476e11b985ea98b293af90f225eabcc6be286b5e" translate="yes" xml:space="preserve">
          <source>The key comparison function object.</source>
          <target state="translated">El objeto de la función de comparación de teclas.</target>
        </trans-unit>
        <trans-unit id="de179c257b2f3167c894faa5512c2c228fcea52f" translate="yes" xml:space="preserve">
          <source>The key comparison function.</source>
          <target state="translated">La función de comparación de teclas.</target>
        </trans-unit>
        <trans-unit id="4c74d4bbf1c90d9364823e4f3ebbd85ffbb952ff" translate="yes" xml:space="preserve">
          <source>The keyword &lt;a href=&quot;../keyword/template&quot;&gt;&lt;code&gt;template&lt;/code&gt;&lt;/a&gt; may appear in qualified identifiers as necessary to disambiguate &lt;a href=&quot;dependent_name&quot;&gt;dependent template names&lt;/a&gt;.</source>
          <target state="translated">La &lt;a href=&quot;../keyword/template&quot;&gt; &lt;code&gt;template&lt;/code&gt; &lt;/a&gt; palabras clave puede aparecer en identificadores calificados seg&amp;uacute;n sea necesario para desambiguar &lt;a href=&quot;dependent_name&quot;&gt;los nombres de plantillas dependientes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49c5ea1550a8c0099418f191e52d2190bdb35cb8" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;nullptr&lt;/code&gt; denotes the pointer literal. It is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;. There exist &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; from &lt;code&gt;nullptr&lt;/code&gt; to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; as well as the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La palabra clave &lt;code&gt;nullptr&lt;/code&gt; denota el puntero literal. Es un &lt;a href=&quot;value_category&quot;&gt;valor&lt;/a&gt; de tipo &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; . Existen &lt;a href=&quot;implicit_cast&quot;&gt;conversiones impl&amp;iacute;citas&lt;/a&gt; de &lt;code&gt;nullptr&lt;/code&gt; a valor de puntero nulo de cualquier tipo de puntero y cualquier puntero a tipo de miembro. Existen conversiones similares para cualquier constante de puntero nulo, que incluye valores de tipo &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , as&amp;iacute; como la macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc50291017180e4feb23c15b01028337ea026e19" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is also used to begin a</source>
          <target state="translated">La palabra clave &lt;code&gt;requires&lt;/code&gt; tambi&amp;eacute;n se utiliza para comenzar un</target>
        </trans-unit>
        <trans-unit id="38ca54bb4a4020554bc23191438cf8b9378a16b3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is used to introduce a</source>
          <target state="translated">La palabra clave &lt;code&gt;requires&lt;/code&gt; se utiliza para introducir un</target>
        </trans-unit>
        <trans-unit id="0f400e14a3942078db12d200e17dbee2a1ed3dcd" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; may only be used in this way after operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access through pointer), and &lt;code&gt;.&lt;/code&gt; (member access), the following are all valid examples:</source>
          <target state="translated">La &lt;code&gt;template&lt;/code&gt; palabras clave solo se puede usar de esta manera despu&amp;eacute;s de operadores &lt;code&gt;::&lt;/code&gt; (resoluci&amp;oacute;n de alcance), &lt;code&gt;-&amp;gt;&lt;/code&gt; (acceso de miembro a trav&amp;eacute;s del puntero) y &lt;code&gt;.&lt;/code&gt; (acceso de miembros), los siguientes son ejemplos v&amp;aacute;lidos:</target>
        </trans-unit>
        <trans-unit id="13bd0f41e6a40479c82db81587bd210c9975f65f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; whose value is the address of the object, on which the member function is being called. It can appear in the following contexts:</source>
          <target state="translated">La palabra clave &lt;code&gt;this&lt;/code&gt; es una &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n &lt;/a&gt;&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; cuyo valor es la direcci&amp;oacute;n del objeto, en el que se llama a la funci&amp;oacute;n miembro. Puede aparecer en los siguientes contextos:</target>
        </trans-unit>
        <trans-unit id="5fb21cb06e25fb3ea23dccf8da1e5fef70f7615d" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; can be used even outside of templates.</source>
          <target state="translated">La palabra clave &lt;code&gt;typename&lt;/code&gt; se puede usar incluso fuera de las plantillas.</target>
        </trans-unit>
        <trans-unit id="78b1b9af4e7e3fe2a278d800536b1dea324a61db" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; may only be used in this way before qualified names (e.g. &lt;code&gt;T::x&lt;/code&gt;), but the names need not be dependent.</source>
          <target state="translated">La palabra clave &lt;code&gt;typename&lt;/code&gt; solo se puede usar de esta manera antes de nombres calificados (por ejemplo, &lt;code&gt;T::x&lt;/code&gt; ), pero los nombres no necesitan ser dependientes.</target>
        </trans-unit>
        <trans-unit id="79655a71967b64b901ff64e9dbeb497972506960" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; must only be used in template declarations and definitions and only in contexts in which dependent names can be used. This excludes explicit specialization declarations and explicit instantiation declarations.</source>
          <target state="translated">La palabra clave &lt;code&gt;typename&lt;/code&gt; solo debe usarse en declaraciones y definiciones de plantillas y solo en contextos en los que se pueden usar nombres dependientes. Esto excluye las declaraciones expl&amp;iacute;citas de especializaci&amp;oacute;n y las declaraciones expl&amp;iacute;citas de instanciaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="95a190feaf53fdb99612657d6559e66695dae193" translate="yes" xml:space="preserve">
          <source>The keyword is unused and reserved.</source>
          <target state="translated">La palabra clave está sin usar y reservada.</target>
        </trans-unit>
        <trans-unit id="58bf644951168b25add914fb2af57f56e1426658" translate="yes" xml:space="preserve">
          <source>The keyword-like forms (&lt;code&gt;and&lt;/code&gt;,&lt;code&gt;or&lt;/code&gt;,&lt;code&gt;not&lt;/code&gt;) and the symbol-like forms (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;,&lt;code&gt;||&lt;/code&gt;,&lt;code&gt;!&lt;/code&gt;) can be used interchangeably (See &lt;a href=&quot;operator_alternative&quot;&gt;alternative representations&lt;/a&gt;)</source>
          <target state="translated">La palabra clave-como formas ( &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; ) y el s&amp;iacute;mbolo como formas ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; ) Se pueden utilizar indistintamente (Ver &lt;a href=&quot;operator_alternative&quot;&gt;representaciones alternativas&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8387e8b5a34e9a813a529166973aeadc61823549" translate="yes" xml:space="preserve">
          <source>The lambda expression is a prvalue expression of unique unnamed non-union non-aggregate class type, known as</source>
          <target state="translated">La expresión lambda es una expresión de prorrateo del tipo de clase única no unida no agregada,conocida como</target>
        </trans-unit>
        <trans-unit id="1dc3cef4c1069bfe1bc8a146544fa3fcdd7f2326" translate="yes" xml:space="preserve">
          <source>The largest allocation size that is required to be fulfilled using the pooling mechanism. Attempts to allocate a single block larger than this threshold will be allocated directly from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;largest_required_pool_block&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose a pass-through threshold larger than specified in this field.</source>
          <target state="translated">El tama&amp;ntilde;o de asignaci&amp;oacute;n m&amp;aacute;s grande que debe cumplirse utilizando el mecanismo de agrupaci&amp;oacute;n. Los intentos de asignar un solo bloque mayor que este umbral se asignar&amp;aacute;n directamente desde el &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; . Si &lt;code&gt;largest_required_pool_block&lt;/code&gt; es cero o es mayor que un l&amp;iacute;mite definido por la implementaci&amp;oacute;n, ese l&amp;iacute;mite se usa en su lugar. La implementaci&amp;oacute;n puede elegir un umbral de paso mayor que el especificado en este campo.</target>
        </trans-unit>
        <trans-unit id="0f76fd3117478f278b8a26d22cae6980cc3dc7bc" translate="yes" xml:space="preserve">
          <source>The largest block size and maximum chunk size may be tuned by passing a &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; struct to its constructor.</source>
          <target state="translated">El tama&amp;ntilde;o de bloque m&amp;aacute;s grande y el tama&amp;ntilde;o de fragmento m&amp;aacute;ximo se pueden ajustar pasando una estructura &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; a su constructor.</target>
        </trans-unit>
        <trans-unit id="5a4ed139500fd5d555f2f6faa85fd84cfda82ebd" translate="yes" xml:space="preserve">
          <source>The largest possible number of char-like objects that can be referred to by a &lt;code&gt;basic_string_view&lt;/code&gt;.</source>
          <target state="translated">El mayor n&amp;uacute;mero posible de objetos tipo char a los que se puede hacer referencia mediante una &lt;code&gt;basic_string_view&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8c1d33c39832e1576d640ab855b96a2c40bccb6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::nearbyint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Los valores de punto flotante representables m&amp;aacute;s grandes son enteros exactos en todos los formatos est&amp;aacute;ndar de punto flotante, por lo que &lt;code&gt;std::nearbyint&lt;/code&gt; nunca se desborda por s&amp;iacute; solo; sin embargo, el resultado puede desbordar cualquier tipo de entero (incluido &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ), cuando se almacena en una variable entera.</target>
        </trans-unit>
        <trans-unit id="0e0e71108205254bc43c1052dde67ff6846b625e" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::rint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Los valores de punto flotante representables m&amp;aacute;s grandes son enteros exactos en todos los formatos est&amp;aacute;ndar de punto flotante, por lo que &lt;code&gt;std::rint&lt;/code&gt; nunca se desborda por s&amp;iacute; solo; sin embargo, el resultado puede desbordar cualquier tipo de entero (incluido &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ), cuando se almacena en una variable entera.</target>
        </trans-unit>
        <trans-unit id="fdc448092c1ae5b510cac2bc24fecc523a9a01e6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::round&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Los valores de punto flotante representables m&amp;aacute;s grandes son enteros exactos en todos los formatos est&amp;aacute;ndar de punto flotante, por lo que &lt;code&gt;std::round&lt;/code&gt; nunca se desborda por s&amp;iacute; solo; sin embargo, el resultado puede desbordar cualquier tipo de entero (incluido &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ), cuando se almacena en una variable entera.</target>
        </trans-unit>
        <trans-unit id="149a06b50d59b602c5dedd71bc2f5b4d4782a259" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">Los valores de punto flotante representables m&amp;aacute;s grandes son enteros exactos en todos los formatos est&amp;aacute;ndar de punto flotante, por lo que esta funci&amp;oacute;n nunca se desborda por s&amp;iacute; sola; sin embargo, el resultado puede desbordar cualquier tipo de entero (incluido &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ), cuando se almacena en una variable entera.</target>
        </trans-unit>
        <trans-unit id="ccc3bae22c3039b6aa4ddd26ffed5dd3a3801a47" translate="yes" xml:space="preserve">
          <source>The last character in</source>
          <target state="translated">El último personaje de</target>
        </trans-unit>
        <trans-unit id="d97f60f8595e3388c7571dd07273229e64ab3160" translate="yes" xml:space="preserve">
          <source>The last modification time for the referred-to filesystem object.</source>
          <target state="translated">La última hora de modificación para el objeto referido al sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="003204e389b9da8284fc1fb45f6c42edd43b43df" translate="yes" xml:space="preserve">
          <source>The latin &lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;letter 'ſ' (U+017F)&lt;/a&gt; is the alternative lowercase form of 'S' (U+0053).</source>
          <target state="translated">La &lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;letra&lt;/a&gt; latina 'ſ' (U + 017F) es la forma alternativa min&amp;uacute;scula de 'S' (U + 0053).</target>
        </trans-unit>
        <trans-unit id="7e8b919f2dc439db08daff4c3a4bb57cb3581675" translate="yes" xml:space="preserve">
          <source>The leading zero generated by the conversion specification &lt;code&gt;#o&lt;/code&gt; (resulting from the combination of &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; for example) is not counted as a padding character.</source>
          <target state="translated">El cero &lt;code&gt;#o&lt;/code&gt; generado por la especificaci&amp;oacute;n de conversi&amp;oacute;n #o (resultante de la combinaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; por ejemplo) no se cuenta como un car&amp;aacute;cter de relleno.</target>
        </trans-unit>
        <trans-unit id="bae67611e59a74badd8c128046df5c4dafdb9b1d" translate="yes" xml:space="preserve">
          <source>The length of character sequence pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">La longitud de la secuencia de caracteres se&amp;ntilde;alada por &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="198958162200c69daf435147f9c229df71f282ff" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">La longitud del segmento inicial m&amp;aacute;ximo que contiene solo caracteres de la cadena de bytes a la que apunta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63de454d6ebc822ff35b5de2988085c7a2c0e23c" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">La longitud del segmento inicial m&amp;aacute;ximo que contiene solo caracteres de una cadena ancha a la que apunta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83dc1b81260e13a56926b8fcc5b2fc9652de1176" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">La longitud del segmento inicial m&amp;aacute;ximo que contiene solo caracteres que no se encuentran en la cadena de bytes a la que apunta &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f772a2bec6f10a883f7267bd67367b712ef3954" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the character string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">La longitud del segmento inicial m&amp;aacute;ximo que contiene solo caracteres que no se encuentran en la cadena de caracteres se&amp;ntilde;alada por &lt;code&gt;src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe0dd8d74988395bb6129f5a7e4490356eb2a0b" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated character string.</source>
          <target state="translated">La longitud de la cadena de caracteres con terminación nula.</target>
        </trans-unit>
        <trans-unit id="c0686acb8c60390ca16c8404e742b7a9caf518b0" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">La longitud de la cadena &lt;code&gt;str&lt;/code&gt; terminada en nulo .</target>
        </trans-unit>
        <trans-unit id="70aa39cc3ba65fdf92c15438e02fd88c74004295" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated wide string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">La longitud de la cadena de &lt;code&gt;str&lt;/code&gt; ancha terminada en nulo .</target>
        </trans-unit>
        <trans-unit id="569fe0bc480cb2d8fd1b576d50ac246394b981a8" translate="yes" xml:space="preserve">
          <source>The length of the specified match or sub-match.</source>
          <target state="translated">La longitud del partido o subpartido especificado.</target>
        </trans-unit>
        <trans-unit id="593d216bcb63cbce0afb160433d1ab015cf4835d" translate="yes" xml:space="preserve">
          <source>The length of the transformed string, not including the terminating null-character.</source>
          <target state="translated">La longitud de la cuerda transformada,sin incluir el carácter nulo de terminación.</target>
        </trans-unit>
        <trans-unit id="e3b3ec34feef4d29ba71c02ffc289279c3d65e7e" translate="yes" xml:space="preserve">
          <source>The length of the transformed wide string, not including the terminating null-character.</source>
          <target state="translated">La longitud de la cuerda ancha transformada,sin incluir el carácter nulo de terminación.</target>
        </trans-unit>
        <trans-unit id="ed8baa6719cd710e95a7b3c07ae38fff0961e9d8" translate="yes" xml:space="preserve">
          <source>The level of support for the open modes other than &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; varies among implementations. C++11 explicitly specifies the support for &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; and in this constructor, but &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; have different effects on different implementations.</source>
          <target state="translated">El nivel de soporte para los modos abiertos que no sean &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; var&amp;iacute;a entre las implementaciones. C ++ 11 especifica expl&amp;iacute;citamente el soporte para &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; y en este constructor, pero &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; tener diferentes efectos en diferentes implementaciones.</target>
        </trans-unit>
        <trans-unit id="557e0b119e086c3a7c5bcdd2f05ba46d098531ff" translate="yes" xml:space="preserve">
          <source>The library provides overloads for all signed and unsigned integer types and &lt;code&gt;char&lt;/code&gt; as the referenced type of the parameter &lt;code&gt;value&lt;/code&gt;. 2-4) Floating-point parsers: Expects the pattern identical to the one used by &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale, except that</source>
          <target state="translated">La biblioteca proporciona sobrecargas para todos los tipos enteros con y sin signo y &lt;code&gt;char&lt;/code&gt; como el tipo referenciado del &lt;code&gt;value&lt;/code&gt; par&amp;aacute;metro . 2-4) Analizadores de punto flotante: espera el patr&amp;oacute;n id&amp;eacute;ntico al utilizado por &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; en la configuraci&amp;oacute;n regional predeterminada (&quot;C&quot;), excepto que</target>
        </trans-unit>
        <trans-unit id="0c00bda8553a4155113db78626e8f2751d276761" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Las versiones de biblioteca del &lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ed95002f088794bbcb4dda6067ef23523590d14" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">Las versiones de biblioteca del &lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; y &lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be0df0b3b3695421bdf2d17b88a03ae80713339f" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Las versiones de biblioteca del &lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt; y &lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a277b5aee4eef17b2deb4d6d21114b2a958a7d0" translate="yes" xml:space="preserve">
          <source>The lifetime of a &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; begins when its initialization is complete and ends as if it were a scalar object.</source>
          <target state="translated">La vida &amp;uacute;til de una &lt;a href=&quot;reference&quot;&gt;referencia&lt;/a&gt; comienza cuando se completa su inicializaci&amp;oacute;n y termina como si fuera un objeto escalar.</target>
        </trans-unit>
        <trans-unit id="89060782836e6f22829eef94ab23da8fa518fbc4" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object created when evaluating the default arguments of a default constructor used to initialize an element of an array ends before the next element of the array begins initialization.</source>
          <target state="translated">La vida útil de un objeto temporal creado al evaluar los argumentos por defecto de un constructor por defecto utilizado para inicializar un elemento de una matriz termina antes de que comience la inicialización del siguiente elemento de la matriz.</target>
        </trans-unit>
        <trans-unit id="d83f5d7c17e682f051804ccec8769174402ff049" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object may be extended by binding to a const lvalue reference or to an rvalue reference(since C++11), see &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;reference initialization&lt;/a&gt; for details.</source>
          <target state="translated">La vida &amp;uacute;til de un objeto temporal puede extenderse uni&amp;eacute;ndose a una referencia de valor constante o a una referencia de valor (desde C ++ 11), consulte la &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;inicializaci&amp;oacute;n de referencia&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="076f84edd8eb9b71ed85703e28397b69b08f0333" translate="yes" xml:space="preserve">
          <source>The lifetime of an object must exceed the lifetime of all &lt;code&gt;atomic_ref&lt;/code&gt;s that references the object. While any &lt;code&gt;atomic_ref&lt;/code&gt; instances referencing an object exists, the object must be exclusively accessed through these &lt;code&gt;atomic_ref&lt;/code&gt; instances. No subobject of an object referenced by an &lt;code&gt;atomic_ref&lt;/code&gt; object may be concurrently referenced by any other &lt;code&gt;atomic_ref&lt;/code&gt; object.</source>
          <target state="translated">La vida &amp;uacute;til de un objeto debe exceder la vida &amp;uacute;til de todas las &lt;code&gt;atomic_ref&lt;/code&gt; s que hacen referencia al objeto. Si bien &lt;code&gt;atomic_ref&lt;/code&gt; instancias atomic_ref que hacen referencia a un objeto, se debe acceder al objeto exclusivamente a trav&amp;eacute;s de estas instancias &lt;code&gt;atomic_ref&lt;/code&gt; . Ning&amp;uacute;n subobjeto de un objeto referenciado por un objeto &lt;code&gt;atomic_ref&lt;/code&gt; puede ser referenciado simult&amp;aacute;neamente por ning&amp;uacute;n otro objeto &lt;code&gt;atomic_ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a71cb474b6739261f5b46ecfbc97690fb132e551" translate="yes" xml:space="preserve">
          <source>The lifetime of the array pointed to by the returned pointer is not specified, but in practice it persist as long as the RTTI data structure for the given type exists, which has application lifetime unless loaded from a dynamic library (that can be unloaded).</source>
          <target state="translated">La vida útil del conjunto señalado por el puntero devuelto no se especifica,pero en la práctica persiste mientras exista la estructura de datos RTTI para el tipo dado,que tiene vida útil de aplicación a menos que se cargue desde una biblioteca dinámica (que puede ser descargada).</target>
        </trans-unit>
        <trans-unit id="f43e95e8be78827b0fca16403fd5210ff788dde7" translate="yes" xml:space="preserve">
          <source>The lifetime of the coroutine state is strictly nested within the lifetime of the caller, and</source>
          <target state="translated">La vida del estado de rutina se anida estrictamente dentro de la vida de la persona que llama,y</target>
        </trans-unit>
        <trans-unit id="5a0b7c168044f4f8abc53a10a8fba540177660d1" translate="yes" xml:space="preserve">
          <source>The list of base classes is provided in the base-clause of the &lt;a href=&quot;class&quot;&gt;class declaration syntax&lt;/a&gt;. The base-clause consists of the character &lt;code&gt;:&lt;/code&gt; followed by a comma-separated list of one or more base-specifiers.</source>
          <target state="translated">La lista de clases base se proporciona en la cl&amp;aacute;usula base de la &lt;a href=&quot;class&quot;&gt;sintaxis de declaraci&amp;oacute;n de clase&lt;/a&gt; . La cl&amp;aacute;usula base consta del car&amp;aacute;cter &lt;code&gt;:&lt;/code&gt; seguido de una lista separada por comas de uno o m&amp;aacute;s especificadores base.</target>
        </trans-unit>
        <trans-unit id="e8509d637336c6e1606720db4e003e047c2a510a" translate="yes" xml:space="preserve">
          <source>The list of exceptions in a &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; may also be a pack expansion.</source>
          <target state="translated">La lista de excepciones en una &lt;a href=&quot;except_spec&quot;&gt;especificaci&amp;oacute;n de excepci&amp;oacute;n din&amp;aacute;mica&lt;/a&gt; tambi&amp;eacute;n puede ser una expansi&amp;oacute;n de paquete.</target>
        </trans-unit>
        <trans-unit id="1d2a38cb5249a278425f59d24c4f0053fd48d52a" translate="yes" xml:space="preserve">
          <source>The list of parameters, as in &lt;a href=&quot;function&quot;&gt;named functions&lt;/a&gt;, except that &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; are not allowed(until C++14). If &lt;code&gt;auto&lt;/code&gt; is used as a type of a parameter, the lambda is a</source>
          <target state="translated">La lista de par&amp;aacute;metros, como en las &lt;a href=&quot;function&quot;&gt;funciones con nombre&lt;/a&gt; , excepto que &lt;a href=&quot;default_arguments&quot;&gt;los argumentos predeterminados&lt;/a&gt; no est&amp;aacute;n permitidos (hasta C ++ 14). Si se usa &lt;code&gt;auto&lt;/code&gt; como un tipo de par&amp;aacute;metro, el lambda es un</target>
        </trans-unit>
        <trans-unit id="56ba40ec75d4e586507c6a313f3b68e7ecfe238c" translate="yes" xml:space="preserve">
          <source>The locale before the call to this function. Effectively returns the result of expression &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">La configuraci&amp;oacute;n regional antes de la llamada a esta funci&amp;oacute;n. Devuelve efectivamente el resultado de la expresi&amp;oacute;n &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a529ceb5bbb923af9b086a8c649b5e092235f98" translate="yes" xml:space="preserve">
          <source>The locale facility includes internationalization support for character classification and string collation, numeric, monetary, and date/time formatting and parsing, and message retrieval. Locale settings control the behavior of stream I/O, regular expression library, and other components of the C++ standard library.</source>
          <target state="translated">El servicio de localización incluye apoyo de internacionalización para la clasificación de caracteres y el cotejo de cadenas,el formateo y análisis numérico,monetario y de fecha y hora,y la recuperación de mensajes.La configuración de la localización controla el comportamiento de la E/S del flujo,la biblioteca de expresiones regulares y otros componentes de la biblioteca estándar de C++.</target>
        </trans-unit>
        <trans-unit id="6a18c5b3999c487308a7e91b96715e80aeb807b2" translate="yes" xml:space="preserve">
          <source>The locale object, associated with the stream before the operation.</source>
          <target state="translated">El objeto local,asociado a la corriente antes de la operación.</target>
        </trans-unit>
        <trans-unit id="634778b18ec9739eca32858af18b0dca1f0f0da1" translate="yes" xml:space="preserve">
          <source>The locale used for localized behavior in the regular expression. Must be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">La configuraci&amp;oacute;n regional utilizada para el comportamiento localizado en la expresi&amp;oacute;n regular. Debe ser &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8def683f0d8be3b6186d5dfddb9cf73b5969d06c" translate="yes" xml:space="preserve">
          <source>The logic operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador lógico tienen la forma.</target>
        </trans-unit>
        <trans-unit id="c3300cacfe4a9fc0c17331372ee202459b693b68" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x)&lt;/code&gt;.</source>
          <target state="translated">El complemento l&amp;oacute;gico del resultado de llamar a &lt;code&gt;pred(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cba68059335b1355e50f5ebe51cc201e645ee88a" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x, y)&lt;/code&gt;.</source>
          <target state="translated">El complemento l&amp;oacute;gico del resultado de llamar a &lt;code&gt;pred(x, y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fdd4b0ecee0c4aa58c8a23319359361fe1a2339" translate="yes" xml:space="preserve">
          <source>The lognormal_distribution random number distribution produces random numbers x &amp;gt; 0 according to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;log-normal distribution&lt;/a&gt;:  f(x; m,s) =</source>
          <target state="translated">La distribuci&amp;oacute;n de n&amp;uacute;meros aleatorios lognormal_distribution produce n&amp;uacute;meros aleatorios x&amp;gt; 0 de acuerdo con una &lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;distribuci&amp;oacute;n log-normal&lt;/a&gt; : f (x; m, s) =</target>
        </trans-unit>
        <trans-unit id="c212e644a85dc2243b9b6984f045c993a30403ee" translate="yes" xml:space="preserve">
          <source>The lookup for member &lt;code&gt;get&lt;/code&gt; ignores accessibility as usual and also ignores the exact type of the non-type template parameter. A private &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; member will cause the member interpretation to be used, even though it is ill-formed.</source>
          <target state="translated">La b&amp;uacute;squeda de miembro &lt;code&gt;get&lt;/code&gt; ignora la accesibilidad como de costumbre y tambi&amp;eacute;n ignora el tipo exacto del par&amp;aacute;metro de plantilla sin tipo. Una &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; privada &amp;lt;char *&amp;gt; void get (); member har&amp;aacute; que se use la interpretaci&amp;oacute;n del miembro, aunque est&amp;eacute; mal formada.</target>
        </trans-unit>
        <trans-unit id="25f8094c991911b431b2e09c25ab9f0d486ffb8e" translate="yes" xml:space="preserve">
          <source>The lookup for the identifier &lt;code&gt;swap&lt;/code&gt; in the exception specification finds this function template in addition to anything found by the usual lookup rules, making the exception specification equivalent to C++17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La b&amp;uacute;squeda del &lt;code&gt;swap&lt;/code&gt; identificador en la especificaci&amp;oacute;n de excepci&amp;oacute;n encuentra esta plantilla de funci&amp;oacute;n adem&amp;aacute;s de cualquier cosa encontrada por las reglas de b&amp;uacute;squeda habituales, haciendo que la especificaci&amp;oacute;n de excepci&amp;oacute;n sea equivalente a C ++ 17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d22abe7f13a33e5aaa7ba9fe7d2fe4cac70e1316" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; may be used to determine the offset of any member from the beginning of a standard-layout class.</source>
          <target state="translated">El macro &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; se puede usar para determinar el desplazamiento de cualquier miembro desde el comienzo de una clase de dise&amp;ntilde;o est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="c041240d72efe54a8080b43aef6a5e9d20fb0e98" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; can only be used with standard-layout classes.</source>
          <target state="translated">La macro &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; solo se puede usar con clases de dise&amp;ntilde;o est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="a80e1699fb25e0be7eaf64d7cde6fed39109e343" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NAN&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.</source>
          <target state="translated">La macro &lt;code&gt;NAN&lt;/code&gt; se expande a una expresi&amp;oacute;n constante de tipo &lt;code&gt;float&lt;/code&gt; que se eval&amp;uacute;a como un valor silencioso de no n&amp;uacute;mero (QNaN). Si la implementaci&amp;oacute;n no admite QNaN, esta macro constante no est&amp;aacute; definida.</target>
        </trans-unit>
        <trans-unit id="511bc44ac64af1c05b670d54015e303e4e44b53b" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NULL&lt;/code&gt; is an implementation-defined null pointer constant, which may be.</source>
          <target state="translated">La macro &lt;code&gt;NULL&lt;/code&gt; es una constante de puntero nulo definida por la implementaci&amp;oacute;n, que puede ser.</target>
        </trans-unit>
        <trans-unit id="e7a478300d3bf8ff1fa598a5f4a3701de66a2d50" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;offsetof&lt;/code&gt; expands to an integral constant expression of type &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</source>
          <target state="translated">La macro &lt;code&gt;offsetof&lt;/code&gt; se expande a una expresi&amp;oacute;n constante integral de tipo &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , cuyo valor es el desplazamiento, en bytes, desde el comienzo de un objeto de tipo especificado a su miembro especificado, incluido el relleno, si lo hay.</target>
        </trans-unit>
        <trans-unit id="a5a472a05b4e53b9216f7fc0c3e059710e59c4a4" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;, which expands to the bitwise OR of all other &lt;code&gt;FE_*&lt;/code&gt;, is always defined and is zero if floating-point exceptions are not supported by the implementation.</source>
          <target state="translated">La constante de macro &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; , que se expande al OR bit a bit de todos los dem&amp;aacute;s &lt;code&gt;FE_*&lt;/code&gt; , siempre est&amp;aacute; definida y es cero si la implementaci&amp;oacute;n no admite excepciones de punto flotante.</target>
        </trans-unit>
        <trans-unit id="44aac1c9879022e9fba891603df04ea9ca8e044a" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_DFL_ENV&lt;/code&gt; expands to an expression of type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</source>
          <target state="translated">La constante de macro &lt;code&gt;FE_DFL_ENV&lt;/code&gt; se expande a una expresi&amp;oacute;n de tipo &lt;code&gt;const std::fenv_t*&lt;/code&gt; , que apunta a una copia completa del entorno de punto flotante predeterminado, es decir, el entorno como cargado al inicio del programa.</target>
        </trans-unit>
        <trans-unit id="4e6484c8cfd3a1b8d998f588b04075f3f3fb6a9f" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;math_errhandling&lt;/code&gt; expands to an expression of type &lt;code&gt;int&lt;/code&gt; that is either equal to &lt;code&gt;MATH_ERRNO&lt;/code&gt;, or equal to &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt;, or equal to their bitwise OR (&lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt;).</source>
          <target state="translated">La macro constante &lt;code&gt;math_errhandling&lt;/code&gt; se expande a una expresi&amp;oacute;n de tipo &lt;code&gt;int&lt;/code&gt; que es igual a &lt;code&gt;MATH_ERRNO&lt;/code&gt; , o igual a &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt; , o igual a su OR bit a bit ( &lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d50b82bba3614372048e0562a743464334498a2" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked with arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt;) are implemented as functions returning objects of unspecified type. These manipulators define their own &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; which perform the requested manipulation.</source>
          <target state="translated">Los manipuladores que se invocan con argumentos (por ejemplo, &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt; ) se implementan como funciones que devuelven objetos de tipo no especificado. Estos manipuladores definen su propio &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; u &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; que realiza la manipulaci&amp;oacute;n solicitada.</target>
        </trans-unit>
        <trans-unit id="016c7618765bc086feb76ffa7317750d2349efbd" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked without arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt;) are implemented as functions that take a reference to a stream as their only argument. The special overloads of &lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; accept pointers to these functions. These functions (or instantiations of function templates) are the only &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;addressable functions&lt;/a&gt; in the standard library.(since C++20).</source>
          <target state="translated">Los manipuladores que se invocan sin argumentos (por ejemplo, &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt; ) se implementan como funciones que toman una referencia a una secuencia como &amp;uacute;nico argumento. Las sobrecargas especiales de &lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; aceptan punteros a estas funciones. Estas funciones (o instancias de plantillas de funciones) son las &amp;uacute;nicas &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;funciones direccionables&lt;/a&gt; en la biblioteca est&amp;aacute;ndar (desde C ++ 20).</target>
        </trans-unit>
        <trans-unit id="0acdda7356c347f1e3a711be9e894cc6cb8fd66c" translate="yes" xml:space="preserve">
          <source>The manner in which &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; is made space efficient (as well as whether it is optimized at all) is implementation defined. One potential optimization involves coalescing vector elements such that each element occupies a single bit instead of &lt;code&gt;sizeof(bool)&lt;/code&gt; bytes.</source>
          <target state="translated">La implementaci&amp;oacute;n de la manera en que &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; hace que el espacio sea eficiente (as&amp;iacute; como si est&amp;aacute; optimizado) Una optimizaci&amp;oacute;n potencial implica la fusi&amp;oacute;n de elementos vectoriales de modo que cada elemento ocupe un solo bit en lugar de tama&amp;ntilde;o de bytes &lt;code&gt;sizeof(bool)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08f5f3a85d25f2d17a7f4389b37fef34e9befb11" translate="yes" xml:space="preserve">
          <source>The manner in which the arguments given at the OS command line are converted into the multibyte character arrays referenced by &lt;code&gt;argv&lt;/code&gt; may involve implementation-defined processing:</source>
          <target state="translated">La manera en que los argumentos dados en la l&amp;iacute;nea de comando del sistema operativo se convierten en las matrices de caracteres multibyte a las que hace referencia &lt;code&gt;argv&lt;/code&gt; puede implicar un procesamiento definido por la implementaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="58a4e89b5d75599c18d4cf2463da2bc790d5e376" translate="yes" xml:space="preserve">
          <source>The mapped value of &lt;code&gt;ch&lt;/code&gt; using the mapping identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale.</source>
          <target state="translated">El valor mapeado de &lt;code&gt;ch&lt;/code&gt; usando el mapeo identificado por &lt;code&gt;desc&lt;/code&gt; en la faceta LC_CTYPE de la localizaci&amp;oacute;n C actual.</target>
        </trans-unit>
        <trans-unit id="8da49c2641d38472ced25e1d078a923e49026a41" translate="yes" xml:space="preserve">
          <source>The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">La materializaci&amp;oacute;n de un objeto temporal generalmente se retrasa el mayor tiempo posible para evitar crear un objeto temporal innecesario: ver &lt;a href=&quot;copy_elision&quot;&gt;copia de elisi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="030e1db264f4cf63958d4ac7eff5a182391b9628" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of arc sine is asin z = -</source>
          <target state="translated">La definición matemática del valor principal del seno del arco es asin z=-</target>
        </trans-unit>
        <trans-unit id="97d3912b761a5766d76f8e019b7647d3c28a58a9" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + &amp;radic;z+1&amp;radic;z-1)  For any z, acosh(z) =</source>
          <target state="translated">La definici&amp;oacute;n matem&amp;aacute;tica del valor principal del coseno hiperb&amp;oacute;lico inverso es acosh z = ln (z + &amp;radic;z + 1&amp;radic;z-1) Para cualquier z, acosh (z) =</target>
        </trans-unit>
        <trans-unit id="2ee0c302057514ba3aa0f5c20f8146065a6d4cf3" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + &amp;radic;1+z2</source>
          <target state="translated">La definici&amp;oacute;n matem&amp;aacute;tica del valor principal del seno hiperb&amp;oacute;lico inverso es asinh z = ln (z + &amp;radic;1 + z2</target>
        </trans-unit>
        <trans-unit id="e0ab357d29d58615b6db4b151ccaf98654e0e8b9" translate="yes" xml:space="preserve">
          <source>The mathematical functions in the standard library components do not throw this exception (mathematical functions report range errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Las funciones matem&amp;aacute;ticas en los componentes de la biblioteca est&amp;aacute;ndar no arrojan esta excepci&amp;oacute;n (las funciones matem&amp;aacute;ticas informan errores de rango como se especifica en &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="58113db72a97ac5e55ee3d47627cc11fbb811664" translate="yes" xml:space="preserve">
          <source>The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::overflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">Las funciones matem&amp;aacute;ticas de los componentes de la biblioteca est&amp;aacute;ndar no generan esta excepci&amp;oacute;n (las funciones matem&amp;aacute;ticas informan errores de desbordamiento como se especifica en &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; ). Las bibliotecas de terceros, sin embargo, usan esto. Por ejemplo, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; lanza &lt;code&gt;std::overflow_error&lt;/code&gt; si &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; est&amp;aacute; habilitado (la configuraci&amp;oacute;n predeterminada).</target>
        </trans-unit>
        <trans-unit id="b1ce23e380db1867330cee83f35a43a3c26b63df" translate="yes" xml:space="preserve">
          <source>The maximum allocation size for OuterAlloc.</source>
          <target state="translated">El tamaño máximo de la asignación para OuterAlloc.</target>
        </trans-unit>
        <trans-unit id="e6a66616954e988ad69d8232b96f5ad75ebaeb3d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;ExternT&lt;/code&gt; characters that could be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; to produce one &lt;code&gt;InternT&lt;/code&gt; character.</source>
          <target state="translated">El n&amp;uacute;mero m&amp;aacute;ximo de caracteres &lt;code&gt;ExternT&lt;/code&gt; que se podr&amp;iacute;an consumir si se convierte mediante &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; para producir un car&amp;aacute;cter &lt;code&gt;InternT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5d2605f57cf7a516878f1456bacc8bf68ff240d" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks that will be allocated at once from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; to replenish the pool. If the value of &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose to use a smaller value than is specified in this field and may use different values for different pools.</source>
          <target state="translated">El n&amp;uacute;mero m&amp;aacute;ximo de bloques que se asignar&amp;aacute;n de una vez desde &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; para reponer el grupo. Si el valor de &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; es cero o es mayor que un l&amp;iacute;mite definido por la implementaci&amp;oacute;n, ese l&amp;iacute;mite se usa en su lugar. La implementaci&amp;oacute;n puede optar por usar un valor m&amp;aacute;s peque&amp;ntilde;o que el especificado en este campo y puede usar valores diferentes para diferentes grupos.</target>
        </trans-unit>
        <trans-unit id="ef98d6b10d2a64071a19841e541af22baf6b008a" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">El n&amp;uacute;mero m&amp;aacute;ximo de niveles de propiedad no est&amp;aacute; especificado. Una llamada a &lt;code&gt;try_lock&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; si se supera este n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="bf578a55e820eb222bfd9c3060644e38bddddff9" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_for&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">El n&amp;uacute;mero m&amp;aacute;ximo de niveles de propiedad no est&amp;aacute; especificado. Una llamada a &lt;code&gt;try_lock_for&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; si se supera este n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="7496f6de330e88cd441a674882cf192e5823a0c2" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_until&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">El n&amp;uacute;mero m&amp;aacute;ximo de niveles de propiedad no est&amp;aacute; especificado. Una llamada a &lt;code&gt;try_lock_until&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;false&lt;/code&gt; si se supera este n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="516d0ea27a06242455894ddf3d9021aca322b598" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. An exception of type &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; will be thrown if this number is exceeded.</source>
          <target state="translated">El n&amp;uacute;mero m&amp;aacute;ximo de niveles de propiedad no est&amp;aacute; especificado. Se &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; una excepci&amp;oacute;n de tipo std :: system_error si se excede este n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="3f7c181bde374eeb6452476ff6b3a7543371ba08" translate="yes" xml:space="preserve">
          <source>The maximum number of times that a &lt;code&gt;recursive_mutex&lt;/code&gt; may be locked is unspecified, but after that number is reached, calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; will throw &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; and calls to &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero m&amp;aacute;ximo de veces que un &lt;code&gt;recursive_mutex&lt;/code&gt; puede estar bloqueado no est&amp;aacute; especificado, pero despu&amp;eacute;s de alcanzar ese n&amp;uacute;mero, las llamadas al &lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; arrojar&amp;aacute;n &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; y las llamadas a &lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; devolver&amp;aacute;n &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a24b749dcce9aa560cb6a3f3aa6c86777a9e5381" translate="yes" xml:space="preserve">
          <source>The maximum of the elements.</source>
          <target state="translated">El máximo de los elementos.</target>
        </trans-unit>
        <trans-unit id="2d061d5c7925797cceba9d91fa06eb294531985d" translate="yes" xml:space="preserve">
          <source>The maximum potentially generated value.</source>
          <target state="translated">El máximo valor potencial generado.</target>
        </trans-unit>
        <trans-unit id="69a097b71a9a8b372efe8c272aa3e609c3c54fe8" translate="yes" xml:space="preserve">
          <source>The maximum supported allocation size.</source>
          <target state="translated">El tamaño máximo de la asignación apoyada.</target>
        </trans-unit>
        <trans-unit id="8c16c9cf3f818c29edfdff221593b78944e7d444" translate="yes" xml:space="preserve">
          <source>The maximum value potentially generated by the distribution.</source>
          <target state="translated">El valor máximo que puede generar la distribución.</target>
        </trans-unit>
        <trans-unit id="f173db7218831b033970ba26eec47af5157e549e" translate="yes" xml:space="preserve">
          <source>The meaning and the type of the result of this function is implementation-defined. On a POSIX system, this may be a value of type &lt;code&gt;pthread_cond_t*&lt;/code&gt;. On a Windows system, this may be a &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt;.</source>
          <target state="translated">El significado y el tipo del resultado de esta funci&amp;oacute;n est&amp;aacute; definida por la implementaci&amp;oacute;n. En un sistema POSIX, este puede ser un valor de tipo &lt;code&gt;pthread_cond_t*&lt;/code&gt; . En un sistema Windows, esto puede ser una &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b50f9c9a68f338aee12b4deb4d472419d36c02" translate="yes" xml:space="preserve">
          <source>The meaning of the format specifiers are:</source>
          <target state="translated">El significado de los especificadores de formato son:</target>
        </trans-unit>
        <trans-unit id="5c2b2f950c575d77dea5f7dca516f87942977025" translate="yes" xml:space="preserve">
          <source>The mechanism for selecting the build level is implementation-defined. Combining translation units that were translated at different build levels is conditionally-supported.</source>
          <target state="translated">El mecanismo para seleccionar el nivel de construcción está definido por la aplicación.La combinación de unidades de traducción que fueron traducidas en diferentes niveles de construcción es apoyada condicionalmente.</target>
        </trans-unit>
        <trans-unit id="69ef650d47f1d92c2572bf80d049412bb1aad754" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;operator()&lt;/code&gt; effectively returns the same value as &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;operator()&lt;/code&gt; miembro () devuelve efectivamente el mismo valor que &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68d7297c4dbfb9ca93d5a11a625ec7d05314ebfc" translate="yes" xml:space="preserve">
          <source>The member access operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador de acceso de miembros tienen la forma.</target>
        </trans-unit>
        <trans-unit id="9ac4e03045a811db7fdf9a33fae47eaa532e51b8" translate="yes" xml:space="preserve">
          <source>The member access operator expressions through pointers to members have the form.</source>
          <target state="translated">El miembro accede a expresiones de operador a través de punteros a los miembros tienen la forma.</target>
        </trans-unit>
        <trans-unit id="d1f68969edf8b53ae807e1ece64ebe13ea9b9298" translate="yes" xml:space="preserve">
          <source>The member access through pointer to member &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;smart pointer interface&lt;/a&gt;, and in fact is used in that capacity by actors in &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt;. It is more common in EDSLs such as &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt;.</source>
          <target state="translated">El miembro accede a trav&amp;eacute;s del puntero al &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; miembro -&amp;gt; * . No hay inconvenientes espec&amp;iacute;ficos para sobrecargar este operador, pero rara vez se usa en la pr&amp;aacute;ctica. Se sugiri&amp;oacute; que podr&amp;iacute;a ser parte de la &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;interfaz de puntero inteligente&lt;/a&gt; y, de hecho, los actores lo &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;utilizan&lt;/a&gt; en boost.phoenix . Es m&amp;aacute;s com&amp;uacute;n en EDSL como &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="239a9f71d3cf420873e0877dbfed19f440ad8974" translate="yes" xml:space="preserve">
          <source>The member character sequence in a buffer open for writing can be over-allocated for efficiency purposes. In that case, only the</source>
          <target state="translated">La secuencia de caracteres miembros en un buffer abierto para la escritura puede ser sobreasignada por razones de eficiencia.En ese caso,sólo el</target>
        </trans-unit>
        <trans-unit id="05e762769a30065e204bb28bf51cb0273777e561" translate="yes" xml:space="preserve">
          <source>The member constants in &lt;code&gt;basic_regex&lt;/code&gt; are duplicates of the &lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type&lt;/a&gt; constants defined in the namespace &lt;code&gt;std::regex_constants&lt;/code&gt;.</source>
          <target state="translated">Las constantes miembro en &lt;code&gt;basic_regex&lt;/code&gt; son duplicados de las constantes &lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type&lt;/a&gt; definidas en el espacio de nombres &lt;code&gt;std::regex_constants&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15df05692a271ee845f25f3cb5b040794f20a534" translate="yes" xml:space="preserve">
          <source>The member function &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Se llama a la funci&amp;oacute;n miembro &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efb92cc5bc9ac09558948d91fa6f04f3671a172b" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher.</source>
          <target state="translated">La funci&amp;oacute;n miembro llamada por la sobrecarga del buscador de &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; para realizar una b&amp;uacute;squeda con este buscador.</target>
        </trans-unit>
        <trans-unit id="02d35ef45a2be736ac5d48567bf5243bd00060f5" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher. &lt;code&gt;RandomIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">La funci&amp;oacute;n miembro llamada por la sobrecarga del buscador de &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; para realizar una b&amp;uacute;squeda con este buscador. &lt;code&gt;RandomIt2&lt;/code&gt; debe cumplir con los requisitos de &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d5b7b86f4cef7432fea2b9bc1aebd9323994e41" translate="yes" xml:space="preserve">
          <source>The member functions introduced by a using-declaration into a derived class are considered to be members of the derived class for the purpose of defining the type of the</source>
          <target state="translated">Las funciones de miembro introducidas por una declaración de uso en una clase derivada se consideran miembros de la clase derivada a los efectos de definir el tipo de la</target>
        </trans-unit>
        <trans-unit id="764b4e1ee289e17bad4f60ec0a9d42691689afe9" translate="yes" xml:space="preserve">
          <source>The member functions of &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;std::initializer_list&lt;/code&gt; overloads of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Las funciones miembro de &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; y las sobrecargas &lt;code&gt;std::initializer_list&lt;/code&gt; de &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc2f6b335fdc83b3a9f3feda6af5eaac09524b21" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the hash of the underlying type might throw.</source>
          <target state="translated">No se garantiza que las funciones de los miembros de esta especialización no sean más que una excepción,ya que el hachís del tipo subyacente podría arrojar.</target>
        </trans-unit>
        <trans-unit id="ef67f3b96aad3f43ceefc11f4c679e1c0ac92843" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the pointer may be a fancy pointer and its hash might throw.</source>
          <target state="translated">No se garantiza que las funciones de los miembros de esta especialización no sean más que las de un puntero de fantasía y su hachís.</target>
        </trans-unit>
        <trans-unit id="833dfb1c2bf2f506172d76aae796695e09f833e7" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept.</source>
          <target state="translated">No se garantiza que las funciones de los miembros de esta especialización no sean más que una excepción.</target>
        </trans-unit>
        <trans-unit id="5e5711660055f235ace0e4ed3873cb22e451c3b1" translate="yes" xml:space="preserve">
          <source>The member functions return defined default values unless the &lt;code&gt;matched&lt;/code&gt; member is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Las funciones miembro devuelven valores predeterminados definidos a menos que el miembro &lt;code&gt;matched&lt;/code&gt; sea &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b48a3030fca44418386968b5abfc5df76aac60a3" translate="yes" xml:space="preserve">
          <source>The member interpretation is used if the range type has a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt;. This is done regardless of whether the member is a type, data member, function, or enumerator, and regardless of its accessibility. Thus a class like &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; cannot be used with the range-based for loop even if the namespace-scope begin/end functions are present.</source>
          <target state="translated">La interpretaci&amp;oacute;n del miembro se usa si el tipo de rango tiene un miembro llamado &lt;code&gt;begin&lt;/code&gt; y un miembro llamado &lt;code&gt;end&lt;/code&gt; . Esto se hace independientemente de si el miembro es un tipo, miembro de datos, funci&amp;oacute;n o enumerador, e independientemente de su accesibilidad. Por lo tanto, una clase como &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; no se puede usar con el bucle for basado en rango, incluso si las funciones de inicio / fin del espacio de nombres est&amp;aacute;n presentes.</target>
        </trans-unit>
        <trans-unit id="d02cf71c651a6bbe450e9796516bdcd13d4f27a6" translate="yes" xml:space="preserve">
          <source>The member names of the</source>
          <target state="translated">Los nombres de los miembros de la</target>
        </trans-unit>
        <trans-unit id="b6068893a255d37e81d9aa5432b3ceed4971bdcc" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;conjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;conjunction&lt;/code&gt;.</source>
          <target state="translated">Los nombres de los miembros de la clase base, que no sean &lt;code&gt;conjunction&lt;/code&gt; y &lt;code&gt;operator=&lt;/code&gt; , no est&amp;aacute;n ocultos y est&amp;aacute;n disponibles inequ&amp;iacute;vocamente en &lt;code&gt;conjunction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab1bc84edd2dcc31d9c428be3ac37ab55ba141eb" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;disjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;disjunction&lt;/code&gt;.</source>
          <target state="translated">Los nombres de miembros de la clase base, que no sean &lt;code&gt;disjunction&lt;/code&gt; y &lt;code&gt;operator=&lt;/code&gt; , no est&amp;aacute;n ocultos y est&amp;aacute;n disponibles de manera inequ&amp;iacute;voca en &lt;code&gt;disjunction&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88413da3549b10a5d3c5e5a05a9f77dbd30567cc" translate="yes" xml:space="preserve">
          <source>The member operator() is noexcept if the &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; expression it calls is noexcept (in other words, it preserves the exception specification of the underlying call operator).</source>
          <target state="translated">El operador miembro () es noexcept si la expresi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; invoke que llama es noexcept (en otras palabras, conserva la especificaci&amp;oacute;n de excepci&amp;oacute;n del operador de llamada subyacente).</target>
        </trans-unit>
        <trans-unit id="99180f77f5a8ca80c11eb2a7965cbabfd4d9c9cc" translate="yes" xml:space="preserve">
          <source>The member specification, or the</source>
          <target state="translated">La especificación del miembro,o la</target>
        </trans-unit>
        <trans-unit id="6247f710bbdb924881ced1b35c970d774f909927" translate="yes" xml:space="preserve">
          <source>The member template class &lt;code&gt;rebind&lt;/code&gt; provides a way to obtain an allocator for a different type. For example,</source>
          <target state="translated">El &lt;code&gt;rebind&lt;/code&gt; clase de plantilla miembro proporciona una forma de obtener un asignador para un tipo diferente. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="03f1ae3b478686fb238fb267920a6735d4e1a474" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;X::pointer&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">El miembro tipo &lt;code&gt;X::pointer&lt;/code&gt; de &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a0ec56c51738314ed8d919d00be55a70b110d4" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;is_transparent&lt;/code&gt; indicates to the caller that this function object is a</source>
          <target state="translated">El tipo de miembro &lt;code&gt;is_transparent&lt;/code&gt; indica al llamante que este objeto de funci&amp;oacute;n es un</target>
        </trans-unit>
        <trans-unit id="97d1ac879c7a04ed1084ddb26ee5600ac333f1dc" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::iterator&lt;/code&gt; and &lt;code&gt;X::const_iterator&lt;/code&gt; are &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterators&lt;/a&gt;</source>
          <target state="translated">Los tipos de miembro &lt;code&gt;X::iterator&lt;/code&gt; y &lt;code&gt;X::const_iterator&lt;/code&gt; son &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterators&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="189eb458b5906253d856798d17eff7858e326e0c" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::pointer&lt;/code&gt;, &lt;code&gt;X::const_pointer&lt;/code&gt;, &lt;code&gt;X::void_pointer&lt;/code&gt; and &lt;code&gt;X::const_void_pointer&lt;/code&gt; of every &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">Los tipos de miembros &lt;code&gt;X::pointer&lt;/code&gt; , &lt;code&gt;X::const_pointer&lt;/code&gt; , &lt;code&gt;X::void_pointer&lt;/code&gt; y &lt;code&gt;X::const_void_pointer&lt;/code&gt; de cada &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; tipo &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="743df5645d4509941f7715864c429844824ed55b" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; may be aliases to the same type. Since &lt;code&gt;iterator&lt;/code&gt; is convertible to &lt;code&gt;const_iterator&lt;/code&gt;, &lt;code&gt;const_iterator&lt;/code&gt; should be used in function parameter lists to avoid violations of the One Definition Rule.</source>
          <target state="translated">Los tipos de miembro &lt;code&gt;iterator&lt;/code&gt; y &lt;code&gt;const_iterator&lt;/code&gt; pueden ser alias a del mismo tipo. Desde &lt;code&gt;iterator&lt;/code&gt; es convertible en &lt;code&gt;const_iterator&lt;/code&gt; , &lt;code&gt;const_iterator&lt;/code&gt; se debe utilizar en las listas de par&amp;aacute;metros de funci&amp;oacute;n para evitar violaci&amp;oacute;nes de la Regla de una definici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4efe6ec44ec82b96dea5c4b0710d2c28b043d1ac" translate="yes" xml:space="preserve">
          <source>The members have the following meaning:</source>
          <target state="translated">Los miembros tienen el siguiente significado:</target>
        </trans-unit>
        <trans-unit id="e6dadd198818909e166ec932a678a2a940461078" translate="yes" xml:space="preserve">
          <source>The memory available to a C++ program is one or more contiguous sequences of</source>
          <target state="translated">La memoria disponible para un programa C++es una o más secuencias contiguas de</target>
        </trans-unit>
        <trans-unit id="037dde83ce079503b4e08f9c73501e2afb83137e" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; respectively. The (1-2) versions use &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; by default.</source>
          <target state="translated">Los modelos de memoria para las operaciones de lectura-modificaci&amp;oacute;n-escritura y carga son &lt;code&gt;succ&lt;/code&gt; y &lt;code&gt;fail&lt;/code&gt; respectivamente. Las versiones (1-2) usan &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; por defecto.</target>
        </trans-unit>
        <trans-unit id="5a1f66f39bcd63450604a4fcb472208a00fc0663" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; respectively. In the (2) and (4) versions &lt;code&gt;order&lt;/code&gt; is used for both read-modify-write and load operations, except that &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; are used for the load operation if &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">Los modelos de memoria para las operaciones de lectura-modificaci&amp;oacute;n-escritura y carga son &lt;code&gt;success&lt;/code&gt; y &lt;code&gt;failure&lt;/code&gt; respectivamente. En las versiones (2) y (4), el &lt;code&gt;order&lt;/code&gt; se usa para las operaciones de lectura-modificaci&amp;oacute;n-escritura y carga, excepto que &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; se usan para la operaci&amp;oacute;n de carga si &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; , o &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="1aed46d8db03878f84ce9975ff764e9083e6702c" translate="yes" xml:space="preserve">
          <source>The memory resource pointer used by this polymorphic allocator.</source>
          <target state="translated">El puntero de recursos de memoria usado por este asignador polimórfico.</target>
        </trans-unit>
        <trans-unit id="6f83b6ed70462af18ce1b14250e467f4f95844bf" translate="yes" xml:space="preserve">
          <source>The memory-writing conversion specifier &lt;code&gt;%n&lt;/code&gt; is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked &lt;code&gt;printf_s&lt;/code&gt; family of functions.</source>
          <target state="translated">El especificador de conversi&amp;oacute;n de escritura en memoria &lt;code&gt;%n&lt;/code&gt; es un objetivo com&amp;uacute;n de las vulnerabilidades de seguridad en las que las cadenas de formato dependen de la entrada del usuario y no son compatibles con la familia de funciones &lt;code&gt;printf_s&lt;/code&gt; con control de l&amp;iacute;mites .</target>
        </trans-unit>
        <trans-unit id="f9bdd1c45276cceff72dd22eaf8b65416fc4d7fe" translate="yes" xml:space="preserve">
          <source>The message from the catalog or a copy of &lt;code&gt;dfault&lt;/code&gt; if none was found.</source>
          <target state="translated">El mensaje del cat&amp;aacute;logo o una copia de &lt;code&gt;dfault&lt;/code&gt; si no se encontr&amp;oacute; ninguno.</target>
        </trans-unit>
        <trans-unit id="9d90f0cf5503392d1c2a08fa622e0683a067c582" translate="yes" xml:space="preserve">
          <source>The minimum of the elements.</source>
          <target state="translated">El mínimo de los elementos.</target>
        </trans-unit>
        <trans-unit id="c57eecd663caaf3065c20e7f0d66aee57b9dc3f2" translate="yes" xml:space="preserve">
          <source>The minimum potentially generated value.</source>
          <target state="translated">El valor mínimo potencialmente generado.</target>
        </trans-unit>
        <trans-unit id="537c9aead08e9763da9b55897fd3bfcdaaa4e86a" translate="yes" xml:space="preserve">
          <source>The minimum value potentially generated by the distribution.</source>
          <target state="translated">El valor mínimo que puede generar la distribución.</target>
        </trans-unit>
        <trans-unit id="b3bcade615775889eac9bb5e7a58de484f254bd4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EC&lt;/code&gt; writes the locale's alternative representation of the century.</source>
          <target state="translated">El comando modificado &lt;code&gt;%EC&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa de la localidad del siglo.</target>
        </trans-unit>
        <trans-unit id="75f0dc4bd53f64c06e6fa0ff392db719eabb0f3d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; interprets the locale's alternate time representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%EX&lt;/code&gt; interpreta la representaci&amp;oacute;n de tiempo alternativo del entorno local.</target>
        </trans-unit>
        <trans-unit id="8bec27fca38ee75b95e3d0eaf504b8384963b028" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; writes the locale's alternate time representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%EX&lt;/code&gt; escribe la representaci&amp;oacute;n de tiempo alternativo del entorno local.</target>
        </trans-unit>
        <trans-unit id="ee3cd7f7d1a25a1212fb29ddd03a9ef8472c165d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EY&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%EY&lt;/code&gt; interpreta la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="1c68da4605fcc44c21d173eb10055c069c70b906" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; interprets the locale's alternative date and time representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Ec&lt;/code&gt; interpreta la representaci&amp;oacute;n alternativa de fecha y hora del entorno local.</target>
        </trans-unit>
        <trans-unit id="a9a1950a1c24f9659bd1e5f981ceb85d050b8767" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; writes the locale's alternative date and time representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Ec&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa de fecha y hora del entorno local.</target>
        </trans-unit>
        <trans-unit id="e5775f2037b71dc38628c3500d791bc260bbebcb" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; interprets the locale's alternate date representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Ex&lt;/code&gt; interpreta la representaci&amp;oacute;n de fecha alternativa de la configuraci&amp;oacute;n regional.</target>
        </trans-unit>
        <trans-unit id="bb64ab15333504747771454a51c8294973e64441" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; produces the locale's alternate date representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Ex&lt;/code&gt; produce la representaci&amp;oacute;n de fecha alternativa de la configuraci&amp;oacute;n regional.</target>
        </trans-unit>
        <trans-unit id="14f6995f41f4a2d2134344889d2b79f5bfd0bf66" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%OH&lt;/code&gt; interpreta la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="da00c4361910133feb2655f2790d2c1bb35c3217" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%OH&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="02e1996d6f854882e96f32146e024df272f3e789" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OI&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%OI&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="283ff3b42755095dc2a58cb25631e8f808fd7dc4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%OM&lt;/code&gt; interpreta la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="2256cc6eb2ce9c6dcb14d9932189e3173fe6fb7b" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%OM&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="e18d9132406fc6f5671d9b0f4de1913dbd9ea54c" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%OS&lt;/code&gt; interpreta la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="735aa83ce9d55484119953184990a8a3c5ef2bf3" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%OS&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="8dc1c917e7b33d49bec0f32a6ee8ce91fe3898be" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OU&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%OU&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="fed0585fe25d67debd6eae7991bab2b8338b1306" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OV&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%OV&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="39e0e2ebc4225fd4de3a9212027bfa57ba77c5c1" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OW&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%OW&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="b8c0342bc98a8d9ac901f7fa48dc3728088a24cf" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Od&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Od&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="23a1adfc45649b52f8d2f79649429566f6756cd0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Oe&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Oe&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="3f211113e01d87804b53bf0839dc4545235c21b5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Om&lt;/code&gt; interpreta la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="6bfc0f055c1fd26cc9dfcc3dd3e7269715d8fbdd" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Om&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="4738bf4fa0770676817bc173268ec85ebdefcba5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Ou&lt;/code&gt; interpreta la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="28885626f1f9a4c0bc54a2f829547cf0075f8fc0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Ou&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="46f001b91727d0cd13635e13519f0c94ccb1c799" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Ow&lt;/code&gt; interpreta la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="116f6b00825f4347d9b3ad162c904523d7a741ec" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">El comando modificado &lt;code&gt;%Ow&lt;/code&gt; escribe la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="eeffbf82acb0112a4308b4adc0a39d3f2e8cd8e8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%EC&lt;/code&gt; and &lt;code&gt;%OC&lt;/code&gt; interpret the locale's alternative representation of the century.</source>
          <target state="translated">Los comandos modificados &lt;code&gt;%EC&lt;/code&gt; y &lt;code&gt;%OC&lt;/code&gt; interpretan la representaci&amp;oacute;n alternativa del siglo del entorno local.</target>
        </trans-unit>
        <trans-unit id="1f8b1cf22bf3b662efdfa9705f03b9deebed9290" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ed&lt;/code&gt; and &lt;code&gt;%Ee&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">Los comandos modificados &lt;code&gt;%Ed&lt;/code&gt; y &lt;code&gt;%Ee&lt;/code&gt; interpretan la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="3d9c4fc10338b78eb69266a4a35ef3927badf16c" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ey&lt;/code&gt; and &lt;code&gt;%Oy&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">Los comandos modificados &lt;code&gt;%Ey&lt;/code&gt; y &lt;code&gt;%Oy&lt;/code&gt; interpretan la representaci&amp;oacute;n alternativa del entorno local.</target>
        </trans-unit>
        <trans-unit id="c680b13d4cfe115916d50f79a4e761597d1ce5f8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; insert a &lt;code&gt;:&lt;/code&gt; between the hours and minutes (e.g., &lt;code&gt;-04:30&lt;/code&gt;).</source>
          <target state="translated">Los comandos modificados &lt;code&gt;%Ez&lt;/code&gt; y &lt;code&gt;%Oz&lt;/code&gt; insertan a &lt;code&gt;:&lt;/code&gt; entre las horas y los minutos (por ejemplo, &lt;code&gt;-04:30&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="967e201acaf95797b9f2a6182b751263d355c430" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; parses the format &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; (i.e., requiring a &lt;code&gt;:&lt;/code&gt; between the hours and minutes and making the leading zero for hour optional).</source>
          <target state="translated">Los comandos modificados &lt;code&gt;%Ez&lt;/code&gt; y &lt;code&gt;%Oz&lt;/code&gt; analizan el formato &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; (es decir, requieren un &lt;code&gt;:&lt;/code&gt; entre las horas y los minutos y hacen que el cero inicial de la hora sea opcional).</target>
        </trans-unit>
        <trans-unit id="b675bd758d57655fae835bb898a51c3bcb35971b" translate="yes" xml:space="preserve">
          <source>The monetary format is an array of four &lt;code&gt;char&lt;/code&gt;s convertible to &lt;code&gt;std::money_base::part&lt;/code&gt;. In that sequence, each of &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;sign&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; appears exactly once, and either &lt;code&gt;space&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt; appears in the remaining position. The value &lt;code&gt;none&lt;/code&gt;, if present, is not first; the value &lt;code&gt;space&lt;/code&gt;, if present, is neither first nor last.</source>
          <target state="translated">El formato monetaria es un conjunto de cuatro &lt;code&gt;char&lt;/code&gt; s convertibles en &lt;code&gt;std::money_base::part&lt;/code&gt; . En esa secuencia, cada &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;sign&lt;/code&gt; o y &lt;code&gt;value&lt;/code&gt; aparece exactamente una vez, y el &lt;code&gt;space&lt;/code&gt; o &lt;code&gt;none&lt;/code&gt; aparece en la posici&amp;oacute;n restante. El valor &lt;code&gt;none&lt;/code&gt; , si est&amp;aacute; presente, no es el primero; el &lt;code&gt;space&lt;/code&gt; valores , si est&amp;aacute; presente, no es ni el primero ni el &amp;uacute;ltimo.</target>
        </trans-unit>
        <trans-unit id="57df9eb0b96a23c853c95f72ee4e1aa61512a265" translate="yes" xml:space="preserve">
          <source>The month value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">El valor del mes almacenado en &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e90e2ca09851d3473823a48772a0e35e7c3866b3" translate="yes" xml:space="preserve">
          <source>The most-derived type of &lt;code&gt;other&lt;/code&gt; may not match the most derived type of &lt;code&gt;*this&lt;/code&gt;. A derived class implementation therefore must typically check whether the most derived types of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; match using &lt;code&gt;dynamic_cast&lt;/code&gt;, and immediately return &lt;code&gt;false&lt;/code&gt; if the cast fails.</source>
          <target state="translated">El tipo m&amp;aacute;s derivado de &lt;code&gt;other&lt;/code&gt; puede no coincidir con el tipo m&amp;aacute;s derivado de &lt;code&gt;*this&lt;/code&gt; . Por lo tanto, una implementaci&amp;oacute;n de clase derivada generalmente debe verificar si los tipos m&amp;aacute;s derivados de &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; coinciden con &lt;code&gt;dynamic_cast&lt;/code&gt; , e inmediatamente devolver &lt;code&gt;false&lt;/code&gt; si falla la conversi&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="16d05d9f68ef63dd77ebb7c2b2b018270c08172b" translate="yes" xml:space="preserve">
          <source>The motivation behind &lt;code&gt;std::result_of&lt;/code&gt; is to determine the result of invoking a &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;, in particular if that result type is different for different sets of arguments.</source>
          <target state="translated">La motivaci&amp;oacute;n detr&amp;aacute;s de &lt;code&gt;std::result_of&lt;/code&gt; es determinar el resultado de invocar un &lt;a href=&quot;../named_req/callable&quot;&gt;invocable&lt;/a&gt; , en particular si ese tipo de resultado es diferente para diferentes conjuntos de argumentos.</target>
        </trans-unit>
        <trans-unit id="be939183f398e144c5a9f5a26339a5ff2df358bf" translate="yes" xml:space="preserve">
          <source>The move assignment operator for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de movimiento para la clase &lt;code&gt;T&lt;/code&gt; es trivial si se cumple todo lo siguiente:</target>
        </trans-unit>
        <trans-unit id="913a05bd12f57d4991f4c434437ba8fdc8ca96af" translate="yes" xml:space="preserve">
          <source>The move assignment operator is called whenever it is selected by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.</source>
          <target state="translated">El operador de asignaci&amp;oacute;n de movimiento se llama siempre que se selecciona por &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; , por ejemplo, cuando aparece un objeto en el lado izquierdo de una expresi&amp;oacute;n de asignaci&amp;oacute;n, donde el lado derecho es un valor del mismo tipo o impl&amp;iacute;citamente convertible.</target>
        </trans-unit>
        <trans-unit id="964822bbec02f38193fe2598cdea03b6e1354a55" translate="yes" xml:space="preserve">
          <source>The move constructor for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">El constructor de movimientos para la clase &lt;code&gt;T&lt;/code&gt; es trivial si se cumple todo lo siguiente:</target>
        </trans-unit>
        <trans-unit id="43ecab829b4442770406c7743a4c24f8d39184e8" translate="yes" xml:space="preserve">
          <source>The move constructor is typically called when an object is &lt;a href=&quot;initialization&quot;&gt;initialized&lt;/a&gt; (by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; or &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;) from &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; (xvalue or prvalue)(until C++17)xvalue(since C++17) of the same type, including.</source>
          <target state="translated">El constructor de movimiento generalmente se llama cuando un objeto se &lt;a href=&quot;initialization&quot;&gt;inicializa&lt;/a&gt; (por inicializaci&amp;oacute;n &lt;a href=&quot;direct_initialization&quot;&gt;directa&lt;/a&gt; o inicializaci&amp;oacute;n de &lt;a href=&quot;copy_initialization&quot;&gt;copia&lt;/a&gt; ) desde &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; (xvalue o prvalue) (hasta C ++ 17) xvalue (desde C ++ 17) del mismo tipo, incluido.</target>
        </trans-unit>
        <trans-unit id="6c57480f2676fa3a3bf78ec56583003322efec68" translate="yes" xml:space="preserve">
          <source>The multibyte encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">La codificación multibyte utilizada por esta función está especificada por el local C actualmente activo.</target>
        </trans-unit>
        <trans-unit id="3934767ca9f156dfb707eb56bde26fbae9cf9bf0" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored.</source>
          <target state="translated">El carácter nulo multibyte fue convertido y almacenado.</target>
        </trans-unit>
        <trans-unit id="a13f36d11d813ad1aa81620c3624a0829c3d680e" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">El car&amp;aacute;cter nulo multibyte se convirti&amp;oacute; y almacen&amp;oacute;. &lt;code&gt;src&lt;/code&gt; se establece en &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;*ps&lt;/code&gt; representa el estado de cambio inicial.</target>
        </trans-unit>
        <trans-unit id="afaeafb6cba6f4e054dc4876689069feee1d4951" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined.</source>
          <target state="translated">El mutex debe ser bloqueado por el hilo de ejecución actual en modo compartido,de lo contrario,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="9efc369f87fb8cd445bfe13d9edeb971e0837953" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.</source>
          <target state="translated">El mutex debe ser bloqueado por el hilo de ejecución actual,de lo contrario,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="2c6d8525b20aacdba1419fafc3fc7f5ae08bc2dd" translate="yes" xml:space="preserve">
          <source>The n distribution parameter.</source>
          <target state="translated">El parámetro de distribución n.</target>
        </trans-unit>
        <trans-unit id="96123ca150593776b8703cdefba85a9b3570e940" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;array::elems&lt;/code&gt; is only for exposition, it's not part of the interface.</source>
          <target state="translated">El nombre &lt;code&gt;array::elems&lt;/code&gt; es solo para exposici&amp;oacute;n, no es parte de la interfaz.</target>
        </trans-unit>
        <trans-unit id="db9a37193da19fc9dd60f45b310779d49a73e6a1" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;posix&lt;/code&gt; is reserved for a future top-level namespace. The behavior is undefined if a program declares or defines anything in that namespace.</source>
          <target state="translated">El nombre &lt;code&gt;posix&lt;/code&gt; est&amp;aacute; reservado para un futuro espacio de nombres de nivel superior. El comportamiento no est&amp;aacute; definido si un programa declara o define algo en ese espacio de nombres.</target>
        </trans-unit>
        <trans-unit id="3705e1c5df92bb63d55f69679ede335b0b4b0b65" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="translated">El nombre &lt;code&gt;proxy&lt;/code&gt; es solo para exposici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fc982d2e54ad63316d942020cd2cc954f5238174" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;ranges::swap&lt;/code&gt; denotes a</source>
          <target state="translated">El nombre &lt;code&gt;ranges::swap&lt;/code&gt; denota un</target>
        </trans-unit>
        <trans-unit id="2aed87bc0a44df46c92723b411bf691a391dd142" translate="yes" xml:space="preserve">
          <source>The name of a non-static data member or a non-static member function can only appear in the following three situations:</source>
          <target state="translated">El nombre de un miembro de datos no estático o una función de miembro no estático sólo puede aparecer en las tres situaciones siguientes:</target>
        </trans-unit>
        <trans-unit id="89cb222de00d870b7103bfa145f09bcde84c1415" translate="yes" xml:space="preserve">
          <source>The name of an enumerator introduced in a &lt;a href=&quot;enum&quot;&gt;scoped enumeration&lt;/a&gt; begins at the point of declaration and ends at the end of the enum specifier (in contrast, unscoped enumerators are in scope after the end of the enum specifier).</source>
          <target state="translated">El nombre de un enumerador introducido en una &lt;a href=&quot;enum&quot;&gt;enumeraci&amp;oacute;n con &amp;aacute;mbito&lt;/a&gt; comienza en el punto de la declaraci&amp;oacute;n y finaliza al final del especificador enum (en contraste, los enumeradores sin &amp;aacute;mbito tienen alcance despu&amp;eacute;s del final del especificador enum).</target>
        </trans-unit>
        <trans-unit id="10cae2ebd2504e13706f02700ec469c53921536e" translate="yes" xml:space="preserve">
          <source>The name of an unscoped enumeration may be omitted: such declaration only introduces the enumerators into the enclosing scope:</source>
          <target state="translated">Puede omitirse el nombre de una enumeración sin alcance:tal declaración sólo introduce a los enumeradores en el ámbito adjunto:</target>
        </trans-unit>
        <trans-unit id="814dfe2ccc46c197be3bf6a8df03805774f01aa8" translate="yes" xml:space="preserve">
          <source>The name of every &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; member (static, non-static, function, type, etc) has an associated &quot;member access&quot;. When a name of the member is used anywhere a program, its access is checked, and if it does not satisfy the access rules, the program does not compile:</source>
          <target state="translated">El nombre de cada miembro de la &lt;a href=&quot;class&quot;&gt;clase&lt;/a&gt; (est&amp;aacute;tico, no est&amp;aacute;tico, funci&amp;oacute;n, tipo, etc.) tiene un &quot;acceso de miembro&quot; asociado. Cuando se usa el nombre del miembro en cualquier lugar de un programa, se verifica su acceso y, si no cumple con las reglas de acceso, el programa no compila:</target>
        </trans-unit>
        <trans-unit id="59568709b5ee764a18b13d2df686742954820331" translate="yes" xml:space="preserve">
          <source>The name of the associated &lt;code&gt;type_info&lt;/code&gt; object.</source>
          <target state="translated">El nombre del objeto &lt;code&gt;type_info&lt;/code&gt; asociado .</target>
        </trans-unit>
        <trans-unit id="ccf301417aa7c5ce4d3a1d2609e3c2ea16a28b7f" translate="yes" xml:space="preserve">
          <source>The name of the locale or &quot;*&quot; if unnamed.</source>
          <target state="translated">El nombre de la localidad o &quot;*&quot; si no se nombra.</target>
        </trans-unit>
        <trans-unit id="ab62ba490e7db4c1ba2cce1f51033276d065dbc5" translate="yes" xml:space="preserve">
          <source>The name of the nested class exists in the scope of the enclosing class, and name lookup from a member function of a nested class visits the scope of the enclosing class after examining the scope of the nested class. Like any member of its enclosing class, the nested class has access to all names (private, protected, etc) to which the enclosing class has access, but it is otherwise independent and has no special access to the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer of the enclosing class.</source>
          <target state="translated">El nombre de la clase anidada existe en el alcance de la clase adjunta, y la b&amp;uacute;squeda de nombres de una funci&amp;oacute;n miembro de una clase anidada visita el alcance de la clase adjunta despu&amp;eacute;s de examinar el alcance de la clase anidada. Al igual que cualquier miembro de su clase de cierre, la clase anidada tiene acceso a todos los nombres (privados, protegidos, etc.) a los que tiene acceso la clase de cierre, pero de lo contrario es independiente y no tiene acceso especial al puntero de &lt;a href=&quot;this&quot;&gt;este&lt;/a&gt; de la clase de cierre.</target>
        </trans-unit>
        <trans-unit id="8748ab247c13f054caf5ac6393ba32b0c81004a9" translate="yes" xml:space="preserve">
          <source>The name of the parameter is optional:</source>
          <target state="translated">El nombre del parámetro es opcional:</target>
        </trans-unit>
        <trans-unit id="5fef32c68362194a9310ccea4c204a96d5f83c27" translate="yes" xml:space="preserve">
          <source>The name of the required language linkage</source>
          <target state="translated">El nombre del enlace de idioma requerido</target>
        </trans-unit>
        <trans-unit id="6a22edb52d9ca8d339db6db0919c173b04d7cfae" translate="yes" xml:space="preserve">
          <source>The name of this function can have one of the two forms:</source>
          <target state="translated">El nombre de esta función puede tener una de las dos formas:</target>
        </trans-unit>
        <trans-unit id="2e85a699586442a78b31c18e7ca7ed56aace9084" translate="yes" xml:space="preserve">
          <source>The name of this function stands for &quot;stream: how many characters?&quot;, so it is pronounced &quot;S how many C&quot;, rather than &quot;show many C&quot;</source>
          <target state="translated">El nombre de esta función significa &quot;corriente:¿cuántos caracteres?&quot;,por lo que se pronuncia &quot;S cuántas C&quot;,en lugar de &quot;mostrar muchas C&quot;</target>
        </trans-unit>
        <trans-unit id="4177d34d388a7f7f015fd91e4b891be839e0252a" translate="yes" xml:space="preserve">
          <source>The name of this time zone (e.g., &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt;).</source>
          <target state="translated">El nombre de esta zona horaria (p. Ej., &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b1f3d7cdd9264d99f9f78cc280cd57b23e748c7e" translate="yes" xml:space="preserve">
          <source>The name stands for &quot;string pointer break&quot;, because it returns a pointer to the first of the separator (&quot;break&quot;) characters.</source>
          <target state="translated">El nombre significa &quot;rotura de puntero de cadena&quot;,porque devuelve un puntero al primero de los caracteres separadores (&quot;break&quot;).</target>
        </trans-unit>
        <trans-unit id="1ee1404e6d3d16d932267176149d19223296bb12" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; are arbitrary, as well as the representation of the types of the parameters: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; is equally valid.</source>
          <target state="translated">Los nombres &lt;code&gt;argc&lt;/code&gt; y &lt;code&gt;argv&lt;/code&gt; son arbitrarios, as&amp;iacute; como la representaci&amp;oacute;n de los tipos de par&amp;aacute;metros: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; es igualmente v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="15246282307805d7fde541df72df9de56fc0168b" translate="yes" xml:space="preserve">
          <source>The names used in the default arguments are looked up, checked for &lt;a href=&quot;access&quot;&gt;accessibility&lt;/a&gt;, and bound at the point of declaration, but are executed at the point of the function call:</source>
          <target state="translated">Los nombres utilizados en los argumentos predeterminados se buscan, se verifica la &lt;a href=&quot;access&quot;&gt;accesibilidad&lt;/a&gt; y se vinculan en el punto de declaraci&amp;oacute;n, pero se ejecutan en el punto de la llamada a la funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="dc8c0c1bca9964f296fb879c9e2285406fd9815a" translate="yes" xml:space="preserve">
          <source>The namespace &lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt; provides generic operators &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt;</source>
          <target state="translated">El espacio de nombres &lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt; proporciona operadores gen&amp;eacute;ricos &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; Y &lt;code&gt;&amp;gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="747b64b0884ce26c6ee214fc6fa900b44b84b929" translate="yes" xml:space="preserve">
          <source>The namespace &lt;code&gt;std&lt;/code&gt; is used to place names of the standard C++ library. See &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;Extending namespace std&lt;/a&gt; for the rules about adding names to it.</source>
          <target state="translated">El espacio de nombres &lt;code&gt;std&lt;/code&gt; se utiliza para colocar nombres de biblioteca de C ++ est&amp;aacute;ndar. Consulte &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;Extensi&amp;oacute;n del espacio de nombres est&amp;aacute;ndar&lt;/a&gt; para conocer las reglas sobre c&amp;oacute;mo agregarle nombres.</target>
        </trans-unit>
        <trans-unit id="029adc599436884611e1679c479ef261e73420f2" translate="yes" xml:space="preserve">
          <source>The namespace alias &lt;code&gt;std::view&lt;/code&gt; is provided as a shorthand for &lt;code&gt;std::ranges::view&lt;/code&gt;.</source>
          <target state="translated">El alias de espacio de nombres &lt;code&gt;std::view&lt;/code&gt; se proporciona como una forma abreviada de &lt;code&gt;std::ranges::view&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a00a6ec7f2538958f4971dfcb23715d488c7aa23" translate="yes" xml:space="preserve">
          <source>The namespace-body defines a &lt;a href=&quot;scope&quot;&gt;namespace scope&lt;/a&gt;, which affects &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">El cuerpo del espacio de nombres define un &lt;a href=&quot;scope&quot;&gt;&amp;aacute;mbito de espacio de nombres&lt;/a&gt; , que afecta la &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda de nombres&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44461e8e669298aaabf78d64c5cf761c5b270b21" translate="yes" xml:space="preserve">
          <source>The native handle of this condition variable.</source>
          <target state="translated">El manejo nativo de esta variable de la condición.</target>
        </trans-unit>
        <trans-unit id="0fd9941f111f60c6088fd13f324a4124b6730d22" translate="yes" xml:space="preserve">
          <source>The native string representation of the pathname, using native syntax, native character type, and native character encoding. This string is suitable for use with OS APIs.</source>
          <target state="translated">La representación de la cadena nativa de la ruta,usando la sintaxis nativa,el tipo de carácter nativo y la codificación de caracteres nativos.Esta cadena es adecuada para su uso con las API de los sistemas operativos.</target>
        </trans-unit>
        <trans-unit id="da3734864c7a6f4ae8da4b63030befa1148f5321" translate="yes" xml:space="preserve">
          <source>The natural logarithm of a complex number z with polar coordinate components (r,&amp;theta;) equals ln r + i(&amp;theta;+2n&amp;pi;), with the principal value ln r + i&amp;theta;</source>
          <target state="translated">El logaritmo natural de un n&amp;uacute;mero complejo z con componentes de coordenadas polares (r, &amp;theta;) es igual a ln r + i (&amp;theta; + 2n&amp;pi;), con el valor principal ln r + i&amp;theta;</target>
        </trans-unit>
        <trans-unit id="3e1f12a369d7befe692c93f44687eb7110ca778a" translate="yes" xml:space="preserve">
          <source>The nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">Se devuelve el valor entero m&amp;aacute;s cercano a &lt;code&gt;arg&lt;/code&gt; , de acuerdo con el &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo actual&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a00868e0a58251c056ae90a3de93adcb746a8300" translate="yes" xml:space="preserve">
          <source>The new alias alias_name provides an alternate method of accessing ns_name.</source>
          <target state="translated">El nuevo alias alias_name proporciona un método alternativo para acceder a ns_name.</target>
        </trans-unit>
        <trans-unit id="429783cbe5a2b5c7d1031e7777e0e7ddc7639a9d" translate="yes" xml:space="preserve">
          <source>The new expression looks for appropriate allocation function's name firstly in the class scope, and after that in the global scope. Note, that as per &lt;a href=&quot;../../language/lookup&quot;&gt;name lookup rules&lt;/a&gt;, any allocation functions declared in class scope hides all global allocation functions for the new-expressions that attempt to allocate objects of this class.</source>
          <target state="translated">La nueva expresi&amp;oacute;n busca el nombre de la funci&amp;oacute;n de asignaci&amp;oacute;n apropiada en primer lugar en el alcance de la clase, y luego en el alcance global. Tenga en cuenta que, seg&amp;uacute;n las &lt;a href=&quot;../../language/lookup&quot;&gt;reglas de b&amp;uacute;squeda&lt;/a&gt; por nombre , cualquier funci&amp;oacute;n de asignaci&amp;oacute;n declarada en el alcance de la clase oculta todas las funciones de asignaci&amp;oacute;n global para las nuevas expresiones que intentan asignar objetos de esta clase.</target>
        </trans-unit>
        <trans-unit id="b4f387edefbb790808ceeca9099abd48faba678a" translate="yes" xml:space="preserve">
          <source>The new string can be one of:</source>
          <target state="translated">La nueva cuerda puede ser una de ellas:</target>
        </trans-unit>
        <trans-unit id="c9828879c32005d467860b7e9f5f3d8c58eb5420" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;rv&lt;/code&gt; is unspecified.</source>
          <target state="translated">El nuevo valor de &lt;code&gt;rv&lt;/code&gt; no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="5d39b572de7e7c5941b91ef76f32e21e73a603a2" translate="yes" xml:space="preserve">
          <source>The new, nameless, locale.</source>
          <target state="translated">El nuevo,sin nombre,lugar.</target>
        </trans-unit>
        <trans-unit id="da2f7bd8f4e5182cfeb3ed50ce6c838f6be3f42c" translate="yes" xml:space="preserve">
          <source>The new-expression allocates storage by calling the appropriate &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;. If &lt;code&gt;type&lt;/code&gt; is a non-array type, the name of the function is &lt;code&gt;operator new&lt;/code&gt;. If &lt;code&gt;type&lt;/code&gt; is an array type, the name of the function is &lt;code&gt;operator new[]&lt;/code&gt;.</source>
          <target state="translated">La nueva expresi&amp;oacute;n asigna almacenamiento llamando a la &lt;a href=&quot;../memory/new/operator_new&quot;&gt;funci&amp;oacute;n de asignaci&amp;oacute;n&lt;/a&gt; adecuada . Si &lt;code&gt;type&lt;/code&gt; es un tipo sin matriz, el nombre de la funci&amp;oacute;n es &lt;code&gt;operator new&lt;/code&gt; . Si &lt;code&gt;type&lt;/code&gt; es un tipo de matriz, el nombre de la funci&amp;oacute;n es &lt;code&gt;operator new[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f81c62ecf75f1df624cbf52969b5f6fcc7a10310" translate="yes" xml:space="preserve">
          <source>The new-line character &lt;code&gt;\n&lt;/code&gt; has special meaning when used in &lt;a href=&quot;../io/c&quot;&gt;text mode I/O&lt;/a&gt;: it is converted to the OS-specific newline representation, usually a byte or byte sequence. Some systems mark their lines with length fields instead.</source>
          <target state="translated">El car&amp;aacute;cter de nueva l&amp;iacute;nea &lt;code&gt;\n&lt;/code&gt; tiene un significado especial cuando se usa en &lt;a href=&quot;../io/c&quot;&gt;modo de texto de E / S&lt;/a&gt; : se convierte en la representaci&amp;oacute;n de nueva l&amp;iacute;nea espec&amp;iacute;fica del sistema operativo, generalmente un byte o secuencia de bytes. Algunos sistemas marcan sus l&amp;iacute;neas con campos de longitud en su lugar.</target>
        </trans-unit>
        <trans-unit id="5004a5f082175ce95c41ab6d7df587cd32a7942b" translate="yes" xml:space="preserve">
          <source>The newly-created object of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">El objeto reci&amp;eacute;n creado de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3ab198cc816c45e12af507dd340aff4fdc62a4" translate="yes" xml:space="preserve">
          <source>The next character in the get area, &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">El siguiente car&amp;aacute;cter en el &amp;aacute;rea de obtenci&amp;oacute;n, &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; en caso de &amp;eacute;xito, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="b97d648e7c3b9a6a63758b3451bbdb0486f22240" translate="yes" xml:space="preserve">
          <source>The next character is extracted from &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;char_type ct = *in;&lt;/code&gt;</source>
          <target state="translated">El siguiente car&amp;aacute;cter se extrae de &lt;code&gt;in&lt;/code&gt; como si por &lt;code&gt;char_type ct = *in;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4680ffa8ce226ac6776cedbea3e5f170c27a198" translate="yes" xml:space="preserve">
          <source>The next multibyte character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">El siguiente car&amp;aacute;cter multibyte a almacenar exceder&amp;iacute;a &lt;code&gt;len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceaab5e3743ebc5e67758c93a0ae4928508e66de" translate="yes" xml:space="preserve">
          <source>The next wide character from the stream or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file has been reached. If an encoding error occurred, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">El siguiente car&amp;aacute;cter ancho de la secuencia o &lt;code&gt;WEOF&lt;/code&gt; si se produjo un error o se alcanz&amp;oacute; el final del archivo. Si se produjo un error de codificaci&amp;oacute;n, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; se establece en &lt;code&gt;EILSEQ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e768a510933a94e869abc7fbe11cfe3c7af6736" translate="yes" xml:space="preserve">
          <source>The next wide character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">El siguiente car&amp;aacute;cter ancho que se almacenar&amp;aacute; exceder&amp;iacute;a &lt;code&gt;len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01a927ab9df8533e7f8f33e9f6abfb695cfb7e25" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is a part of the function type and may appear as part of any &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt;.</source>
          <target state="translated">La especificaci&amp;oacute;n noexcept es una parte del tipo de funci&amp;oacute;n y puede aparecer como parte de cualquier &lt;a href=&quot;function&quot;&gt;declarador de funci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e8e2aa7b768b907757e4c37f13e697b69a77fae" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is not a part of the function type (just like &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;) and can only appear as a part of a &lt;a href=&quot;lambda&quot;&gt;lambda declarator&lt;/a&gt; or a top-level &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt; when declaring functions, variables, non-static data members of type function, pointer to function, reference to function, or pointer to member function, and also when declaring a parameter or a return type in one of those declarations that in turn happens to be a pointer or reference to function. It cannot appear in a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt; declaration.</source>
          <target state="translated">La especificaci&amp;oacute;n noexcept no es parte del tipo de funci&amp;oacute;n (al igual que &lt;a href=&quot;except_spec&quot;&gt;la especificaci&amp;oacute;n de excepci&amp;oacute;n din&amp;aacute;mica&lt;/a&gt; ) y solo puede aparecer como parte de un &lt;a href=&quot;lambda&quot;&gt;declarador lambda&lt;/a&gt; o un &lt;a href=&quot;function&quot;&gt;declarador de funciones de&lt;/a&gt; nivel superior al declarar funciones, variables, miembros de tipo de datos no est&amp;aacute;ticos funci&amp;oacute;n, puntero a funci&amp;oacute;n, referencia a funci&amp;oacute;n o puntero a funci&amp;oacute;n miembro, y tambi&amp;eacute;n al declarar un par&amp;aacute;metro o un tipo de retorno en una de esas declaraciones que a su vez resulta ser un puntero o referencia a funci&amp;oacute;n. No puede aparecer en una declaraci&amp;oacute;n &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; o &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91d5dbc9bc5e94a5126d0bce53badf87576b47e0" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; always returns &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n sin conversi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; siempre devuelve &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc09343d894c712f42534e3a3a7a2e71d277a115" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n sin conversi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; devuelve &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3181f2172f64e8c18c66b621b97fc46888a027ba" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n sin conversi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; devuelve &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a64105f39486401f5acc80b055bc1c3fc01a2fb5" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n sin conversi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e57a9aa4e3c88808abdb8487b916a663a9f0cec4" translate="yes" xml:space="preserve">
          <source>The non-negative value of type &lt;code&gt;catalog&lt;/code&gt; that can be used with &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. Returns a negative value if the catalog could not be opened.</source>
          <target state="translated">El valor no negativo del tipo &lt;code&gt;catalog&lt;/code&gt; que se puede usar con &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; . Devuelve un valor negativo si no se pudo abrir el cat&amp;aacute;logo.</target>
        </trans-unit>
        <trans-unit id="02e334d13769a2c905eebc3be84f4142a27bd649" translate="yes" xml:space="preserve">
          <source>The non-throwing overload has no special action on error.</source>
          <target state="translated">La sobrecarga de no lanzamiento no tiene una acción especial sobre el error.</target>
        </trans-unit>
        <trans-unit id="34e36164ec9a95125dc49a45834357890507b833" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;-1&lt;/code&gt; on errors.</source>
          <target state="translated">La sobrecarga no arrojada devuelve &lt;code&gt;-1&lt;/code&gt; en caso de errores.</target>
        </trans-unit>
        <trans-unit id="aa28e66303348738c761475c96ff70e7788d369b" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;false&lt;/code&gt; on errors.</source>
          <target state="translated">La sobrecarga no arrojada devuelve &lt;code&gt;false&lt;/code&gt; en los errores.</target>
        </trans-unit>
        <trans-unit id="919ace58ca21119d988f2559255ddff1ca1db7ec" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on errors.</source>
          <target state="translated">La sobrecarga no &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; devuelve static_cast &amp;lt;uintmax_t&amp;gt; (-1) en caso de error.</target>
        </trans-unit>
        <trans-unit id="998e79778beab53392bc4f00d5142904ec8702e3" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns an empty path on errors.</source>
          <target state="translated">La sobrecarga de no tirar devuelve un camino vacío en los errores.</target>
        </trans-unit>
        <trans-unit id="afb768fa11ed8a7e400ee259f3f1ed7b0405bd1e" translate="yes" xml:space="preserve">
          <source>The non-throwing overload sets all members to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on error.</source>
          <target state="translated">La sobrecarga no &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; establece todos los miembros en static_cast &amp;lt;uintmax_t&amp;gt; (-1) en caso de error.</target>
        </trans-unit>
        <trans-unit id="fa9c9a7d355030087b9f4a3bf568048262b6a45c" translate="yes" xml:space="preserve">
          <source>The norm calculated by this function is also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;field norm&lt;/a&gt; or &lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;absolute square&lt;/a&gt;.</source>
          <target state="translated">La norma calculada por esta funci&amp;oacute;n tambi&amp;eacute;n se conoce como &lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;norma de campo&lt;/a&gt; o &lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;cuadrado absoluto&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e486b6025e3738e962c61297301601872036ad5" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;(E)&lt;/code&gt; is the normal form of &lt;code&gt;E&lt;/code&gt;;</source>
          <target state="translated">La forma normal de una expresi&amp;oacute;n &lt;code&gt;(E)&lt;/code&gt; es la forma normal de &lt;code&gt;E&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="9bddf9d40a32b5e00d57e01971707d640e804497" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; names a concept, is the normal form of the constraint expression of &lt;code&gt;C&lt;/code&gt;, after substituting A1, A2, ... , AN for &lt;code&gt;C&lt;/code&gt;'s respective template parameters in the parameter mappings of each atomic constraint of C. If any such substitution into the parameter mappings results in an invalid type or expression, the program is ill-formed, no diagnostic required.</source>
          <target state="translated">La forma normal de una expresi&amp;oacute;n &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt; , donde &lt;code&gt;C&lt;/code&gt; nombra un concepto, es la forma normal de la expresi&amp;oacute;n de restricci&amp;oacute;n de &lt;code&gt;C&lt;/code&gt; , despu&amp;eacute;s de sustituir A1, A2, ..., AN por &lt;code&gt;C&lt;/code&gt; ' s par&amp;aacute;metros de plantilla respectivos en las asignaciones de par&amp;aacute;metros de cada restricci&amp;oacute;n at&amp;oacute;mica de C. Si cualquiera de estas sustituciones en las asignaciones de par&amp;aacute;metros da como resultado un tipo o expresi&amp;oacute;n no v&amp;aacute;lida, el programa est&amp;aacute; mal formado, no se requiere diagn&amp;oacute;stico.</target>
        </trans-unit>
        <trans-unit id="5086c57862725f37980d863e1b8836e88a15cef7" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; is the conjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">La forma normal de una expresi&amp;oacute;n &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; es la conjunci&amp;oacute;n de las formas normales de &lt;code&gt;E1&lt;/code&gt; y &lt;code&gt;E2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="218bd31f9dfc47e61adeda7a1fae8d05c1d9c91a" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 || E2&lt;/code&gt; is the disjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">La forma normal de una expresi&amp;oacute;n &lt;code&gt;E1 || E2&lt;/code&gt; es la disyunci&amp;oacute;n de las formas normales de &lt;code&gt;E1&lt;/code&gt; y &lt;code&gt;E2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cfc995fd9a247d5a41e7c2c9e5f1255a95384b9" translate="yes" xml:space="preserve">
          <source>The normal form of any other expression &lt;code&gt;E&lt;/code&gt; is the atomic constraint whose expression is &lt;code&gt;E&lt;/code&gt; and whose parameter mapping is the identity mapping. This includes all &lt;a href=&quot;fold&quot;&gt;fold expressions&lt;/a&gt;, even those folding over the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; operators.</source>
          <target state="translated">La forma normal de cualquier otra expresi&amp;oacute;n &lt;code&gt;E&lt;/code&gt; es la restricci&amp;oacute;n at&amp;oacute;mica cuya expresi&amp;oacute;n es &lt;code&gt;E&lt;/code&gt; y cuyo mapeo de par&amp;aacute;metros es el mapeo de identidad. Esto incluye todas las &lt;a href=&quot;fold&quot;&gt;expresiones de plegado&lt;/a&gt; , incluso aquellas plegadas sobre &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; o &lt;code&gt;||&lt;/code&gt; operadores</target>
        </trans-unit>
        <trans-unit id="fe2c62a2f9883108b9601f6b362958e238efecab" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock.</source>
          <target state="translated">El hilo notificador no necesita mantener el bloqueo en el mismo mutex que el que mantiene el hilo o hilos en espera;de hecho,hacerlo es una pesadilla,ya que el hilo notificado se bloquearía de nuevo inmediatamente,esperando que el hilo notificador libere el bloqueo.</target>
        </trans-unit>
        <trans-unit id="74b817b062ef6088a10c131453eb749d4d9679d7" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock. However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this &quot;hurry up and wait&quot; scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.</source>
          <target state="translated">El hilo notificador no necesita mantener el bloqueo en el mismo mutex que el que mantiene el hilo o hilos en espera;de hecho,hacerlo es una pesadilla,ya que el hilo notificado se bloquearía inmediatamente de nuevo,esperando que el hilo notificador libere el bloqueo.Sin embargo,algunas implementaciones (en particular muchas implementaciones de pthreads)reconocen esta situación y evitan este escenario de &quot;apurarse y esperar&quot; transfiriendo el hilo en espera de la cola de la variable de condición directamente a la cola del mutex dentro de la llamada de notificación,sin despertarlo.</target>
        </trans-unit>
        <trans-unit id="d72947b7a5e5177d55e7da50e671e2cfaa9b935b" translate="yes" xml:space="preserve">
          <source>The null character (&lt;code&gt;'\0'&lt;/code&gt;, &lt;code&gt;L'\0'&lt;/code&gt;, &lt;code&gt;char16_t()&lt;/code&gt;, etc) is always appended to the string literal: thus, a string literal &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; is a &lt;code&gt;const char[6]&lt;/code&gt; holding the characters &lt;code&gt;'H'&lt;/code&gt;, &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'o'&lt;/code&gt;, and &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">El car&amp;aacute;cter nulo ( &lt;code&gt;'\0'&lt;/code&gt; , &lt;code&gt;L'\0'&lt;/code&gt; , &lt;code&gt;char16_t()&lt;/code&gt; , etc.) siempre se agrega al literal de cadena: por lo tanto, un literal de cadena &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; es un &lt;code&gt;const char[6]&lt;/code&gt; contiene los caracteres &lt;code&gt;'H'&lt;/code&gt; , &lt;code&gt;'e'&lt;/code&gt; , &lt;code&gt;'l'&lt;/code&gt; , &lt;code&gt;'l'&lt;/code&gt; , &lt;code&gt;'o'&lt;/code&gt; y &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faf4539050f33260142e5e1942efa29dd4846fe8" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored.</source>
          <target state="translated">El carácter nulo fue convertido y almacenado.</target>
        </trans-unit>
        <trans-unit id="248246a3944930a0737208d795018f3412610899" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">El car&amp;aacute;cter nulo fue convertido y almacenado. &lt;code&gt;src&lt;/code&gt; se establece en &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;*ps&lt;/code&gt; representa el estado de cambio inicial.</target>
        </trans-unit>
        <trans-unit id="c07d16928e24253bdda00754b26c48658241a00d" translate="yes" xml:space="preserve">
          <source>The null directive (&lt;code&gt;#&lt;/code&gt; followed by a line break) is allowed and has no effect.</source>
          <target state="translated">La directiva nula ( &lt;code&gt;#&lt;/code&gt; seguida de un salto de l&amp;iacute;nea) est&amp;aacute; permitida y no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="025c68351e84ef6a409e2a0b3cccd1343af71a32" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the string.</source>
          <target state="translated">El n&amp;uacute;mero de elementos &lt;code&gt;CharT&lt;/code&gt; en la cadena.</target>
        </trans-unit>
        <trans-unit id="ed5405dde434342736b19ab060ea61207493342f" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the view.</source>
          <target state="translated">El n&amp;uacute;mero de elementos &lt;code&gt;CharT&lt;/code&gt; en la vista.</target>
        </trans-unit>
        <trans-unit id="e56138bf523de60c8f035f5f12250f1f8ed8ee0d" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;externT&lt;/code&gt; characters that would be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; until either all &lt;code&gt;from_end-from&lt;/code&gt; characters were consumed or &lt;code&gt;max&lt;/code&gt;&lt;code&gt;internT&lt;/code&gt; characters were produced, or a conversion error occurred.</source>
          <target state="translated">El n&amp;uacute;mero de caracteres &lt;code&gt;externT&lt;/code&gt; que se consumir&amp;iacute;an si los convierte &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; hasta que se hayan consumido todos &lt;code&gt;from_end-from&lt;/code&gt; caracteres from_end-from o se &lt;code&gt;internT&lt;/code&gt; producido el &lt;code&gt;max&lt;/code&gt; caracteres internos o se haya producido un error de conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7563f8961703d5358be5cd18a6c7fd7caeb16313" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;shared_ptr&lt;/code&gt; instances sharing the ownership of the managed object at the instant of the call.</source>
          <target state="translated">El n&amp;uacute;mero de instancias &lt;code&gt;shared_ptr&lt;/code&gt; que comparten la propiedad del objeto administrado en el instante de la llamada.</target>
        </trans-unit>
        <trans-unit id="69061d2f8b406eee14a4cb45eba7155a2d754383" translate="yes" xml:space="preserve">
          <source>The number of bits in a bit field sets the limit to the range of values it can hold:</source>
          <target state="translated">El número de bits en un campo de bits establece el límite del rango de valores que puede contener:</target>
        </trans-unit>
        <trans-unit id="3f9099e3c7d873d70b362e3a89df1f5709452578" translate="yes" xml:space="preserve">
          <source>The number of buckets in the container.</source>
          <target state="translated">El número de cubos en el contenedor.</target>
        </trans-unit>
        <trans-unit id="c785090a06b869af10617d403684a6661945ed63" translate="yes" xml:space="preserve">
          <source>The number of bytes (between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;) that complete a valid multibyte character.</source>
          <target state="translated">El n&amp;uacute;mero de bytes (entre &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; ) que completa un car&amp;aacute;cter multibyte v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="4be8b408517c6e0f5de03175a85f9c74465aa587" translate="yes" xml:space="preserve">
          <source>The number of bytes stored in the array object (including any shift sequences). This may be zero when &lt;code&gt;c8&lt;/code&gt; is not the final code unit in the UTF-8 representation of a code point.</source>
          <target state="translated">El n&amp;uacute;mero de bytes almacenados en el objeto de matriz (incluidas las secuencias de cambio). Esto puede ser cero cuando &lt;code&gt;c8&lt;/code&gt; no es la unidad de c&amp;oacute;digo final en la representaci&amp;oacute;n UTF-8 de un punto de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="1b02eec6dc83ccdd83bcea1a56eb671b42ec3a69" translate="yes" xml:space="preserve">
          <source>The number of bytes written into the character array pointed to by &lt;code&gt;str&lt;/code&gt; not including the terminating &lt;code&gt;'\0'&lt;/code&gt; on success. If &lt;code&gt;count&lt;/code&gt; was reached before the entire string could be stored, &lt;code&gt;​0​&lt;/code&gt; is returned and the contents are undefined.</source>
          <target state="translated">El n&amp;uacute;mero de bytes escritos en la matriz de caracteres se&amp;ntilde;alados por &lt;code&gt;str&lt;/code&gt; sin incluir la terminaci&amp;oacute;n &lt;code&gt;'\0'&lt;/code&gt; en caso de &amp;eacute;xito. Si &lt;code&gt;count&lt;/code&gt; se alcanz&amp;oacute; antes de que se podr&amp;iacute;a almacenar toda la cadena, &lt;code&gt;​0​&lt;/code&gt; se devuelve y el contenido est&amp;aacute;n definidos.</target>
        </trans-unit>
        <trans-unit id="d8967c57de8e646af979d9e3d24efce148b0348b" translate="yes" xml:space="preserve">
          <source>The number of characters actually extracted.</source>
          <target state="translated">El número de caracteres realmente extraídos.</target>
        </trans-unit>
        <trans-unit id="a55f46f0cba247803d518fc84899892627e6d13a" translate="yes" xml:space="preserve">
          <source>The number of characters available for non-blocking read (either the size of the get area or the number of characters ready for reading from the associated character sequence), or &lt;code&gt;-1&lt;/code&gt; if no characters are available in the associated sequence as far as &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; can tell.</source>
          <target state="translated">El n&amp;uacute;mero de caracteres disponibles para la lectura sin bloqueo (ya sea el tama&amp;ntilde;o del &amp;aacute;rea de obtenci&amp;oacute;n o el n&amp;uacute;mero de caracteres listos para leer de la secuencia de caracteres asociada), o &lt;code&gt;-1&lt;/code&gt; si no hay caracteres disponibles en la secuencia asociada hasta &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; puede decir.</target>
        </trans-unit>
        <trans-unit id="8ec083d621e3f753125e182fe5084fd848f34df3" translate="yes" xml:space="preserve">
          <source>The number of characters available for reading from the file, or &lt;code&gt;-1&lt;/code&gt; if the end of file was reached.</source>
          <target state="translated">El n&amp;uacute;mero de caracteres disponibles para leer del archivo, o &lt;code&gt;-1&lt;/code&gt; si se alcanz&amp;oacute; el final del archivo.</target>
        </trans-unit>
        <trans-unit id="daf9eb1b235764a22547b341d3cc6ad96b107014" translate="yes" xml:space="preserve">
          <source>The number of characters consumed by the most recent conversion operation.</source>
          <target state="translated">El número de caracteres consumidos por la operación de conversión más reciente.</target>
        </trans-unit>
        <trans-unit id="31a745112d734fafc43f6e526f229e8cc0817594" translate="yes" xml:space="preserve">
          <source>The number of characters extracted by the last unformatted input operation.</source>
          <target state="translated">El número de caracteres extraídos por la última operación de entrada sin formato.</target>
        </trans-unit>
        <trans-unit id="025f13559fc4a76405d90651c0e5de33b6d88a9a" translate="yes" xml:space="preserve">
          <source>The number of characters in the put area, or zero if nothing was output.</source>
          <target state="translated">El número de caracteres en el área de puesta,o cero si no se emitió nada.</target>
        </trans-unit>
        <trans-unit id="b36a0d1d6266f14401ce912fa34b84443739b9ed" translate="yes" xml:space="preserve">
          <source>The number of characters successfully read. If it is less than &lt;code&gt;count&lt;/code&gt; the input sequence has reached the end.</source>
          <target state="translated">El n&amp;uacute;mero de caracteres le&amp;iacute;dos con &amp;eacute;xito. Si es inferior al &lt;code&gt;count&lt;/code&gt; la secuencia de entrada ha llegado al final.</target>
        </trans-unit>
        <trans-unit id="755b4ee802930b67c7f96314436110b4b1007db7" translate="yes" xml:space="preserve">
          <source>The number of characters successfully written.</source>
          <target state="translated">El número de caracteres escritos con éxito.</target>
        </trans-unit>
        <trans-unit id="0424ddfc94d33a5b039d2cf4e4fb1ccac4396955" translate="yes" xml:space="preserve">
          <source>The number of characters that are certainly available in the associated character sequence, or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;showmanyc&lt;/code&gt; can determine, without blocking, that no characters are available. If &lt;code&gt;showmanyc&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; will definitely return &lt;code&gt;Traits::eof&lt;/code&gt; or throw.</source>
          <target state="translated">El n&amp;uacute;mero de caracteres que ciertamente est&amp;aacute;n disponibles en la secuencia de caracteres asociada, o &lt;code&gt;-1&lt;/code&gt; si &lt;code&gt;showmanyc&lt;/code&gt; puede determinar, sin bloquear, que no hay caracteres disponibles. Si &lt;code&gt;showmanyc&lt;/code&gt; devuelve &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; definitivamente devolver&amp;aacute;n &lt;code&gt;Traits::eof&lt;/code&gt; o throw.</target>
        </trans-unit>
        <trans-unit id="572abc135ef958490a79fa0e1af5c7c67e142749" translate="yes" xml:space="preserve">
          <source>The number of characters written to the put area.</source>
          <target state="translated">El número de caracteres escritos en el área de la puesta.</target>
        </trans-unit>
        <trans-unit id="be9d72f9b5ea67854905c61a719c823300aee734" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most 2 * log</source>
          <target state="translated">El n&amp;uacute;mero de comparaciones realizadas es logar&amp;iacute;tmico en la distancia entre el &lt;code&gt;first&lt;/code&gt; y el &lt;code&gt;last&lt;/code&gt; (a lo sumo 2 * log</target>
        </trans-unit>
        <trans-unit id="d7d13597f2fd284fd58cd626f0e7ce58b0a1966e" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most log</source>
          <target state="translated">El n&amp;uacute;mero de comparaciones realizadas es logar&amp;iacute;tmico en la distancia entre el &lt;code&gt;first&lt;/code&gt; y el &lt;code&gt;last&lt;/code&gt; (a lo m&amp;aacute;s log</target>
        </trans-unit>
        <trans-unit id="91c8ac1c75a7c617f2a0ac89cd3799820e4457ed" translate="yes" xml:space="preserve">
          <source>The number of digits between the &lt;code&gt;thousand-sep&lt;/code&gt;s (maximum size of &lt;code&gt;digits&lt;/code&gt;) is specified by the result of &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de d&amp;iacute;gitos entre los &lt;code&gt;thousand-sep&lt;/code&gt; s (tama&amp;ntilde;o m&amp;aacute;ximo de &lt;code&gt;digits&lt;/code&gt; ) se especifica por el resultado de la &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f0b350cad560ae534bf63d3c358b99770cd98ec" translate="yes" xml:space="preserve">
          <source>The number of digits to be displayed after the decimal point. In common U.S. locales, this is the value &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de d&amp;iacute;gitos que se mostrar&amp;aacute;n despu&amp;eacute;s del punto decimal. En las configuraciones regionales comunes de EE. UU., Este es el valor &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c33eec86884077ae614b5177f47626b4225aee87" translate="yes" xml:space="preserve">
          <source>The number of elements in &lt;code&gt;Ints&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de elementos en &lt;code&gt;Ints&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b450587ddfddf28cae24e2b30442386956861df" translate="yes" xml:space="preserve">
          <source>The number of elements in the bucket &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de elementos en el cubo &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa1ca4d47e01f9e18e5e6074af9cfd49cb03a9d8" translate="yes" xml:space="preserve">
          <source>The number of elements in the container.</source>
          <target state="translated">El número de elementos en el contenedor.</target>
        </trans-unit>
        <trans-unit id="68853860c0d5a8f06c3b286e4f1020c334bca256" translate="yes" xml:space="preserve">
          <source>The number of elements in the span.</source>
          <target state="translated">El número de elementos en el intervalo.</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">El número de elementos eliminados.</target>
        </trans-unit>
        <trans-unit id="57b03f33847e8f2cd5650b62940211a1dd591b64" translate="yes" xml:space="preserve">
          <source>The number of hard links for &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de enlaces duros para &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cce184fd3e4e941c3606117950b45af922d77f66" translate="yes" xml:space="preserve">
          <source>The number of hard links for the referred-to filesystem object.</source>
          <target state="translated">El número de enlaces duros para el objeto referido al sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="61f0b12e8e21833dacb834088dec03bd1d45a5bc" translate="yes" xml:space="preserve">
          <source>The number of increments needed to go from &lt;code&gt;first&lt;/code&gt; to &lt;code&gt;last&lt;/code&gt;. The value may be negative if random-access iterators are used and &lt;code&gt;first&lt;/code&gt; is reachable from &lt;code&gt;last&lt;/code&gt;(since C++11).</source>
          <target state="translated">El n&amp;uacute;mero de incrementos necesarios para pasar del &lt;code&gt;first&lt;/code&gt; al &lt;code&gt;last&lt;/code&gt; . El valor puede ser negativo si se utilizan iteradores de acceso aleatorio y el &lt;code&gt;first&lt;/code&gt; es accesible desde el &lt;code&gt;last&lt;/code&gt; (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="50988967f711f6f1b94fadc8faa1c4123b2c14c3" translate="yes" xml:space="preserve">
          <source>The number of marked sub-expressions within the regular expression.</source>
          <target state="translated">El número de subexpresiones marcadas dentro de la expresión regular.</target>
        </trans-unit>
        <trans-unit id="c70fa04485fef696ceac1a34cbd7f1b495aed9ee" translate="yes" xml:space="preserve">
          <source>The number of submatches.</source>
          <target state="translated">El número de submatches.</target>
        </trans-unit>
        <trans-unit id="d956e6449331c6b04b931088c9ef0870fa076aa0" translate="yes" xml:space="preserve">
          <source>The number of ticks for this duration.</source>
          <target state="translated">El número de garrapatas para esta duración.</target>
        </trans-unit>
        <trans-unit id="d4eed26281a1ccba1c3fbe30a41dad631fb16096" translate="yes" xml:space="preserve">
          <source>The numbers that are supported by &lt;code&gt;std::numpunct&lt;/code&gt; have the format described below. Here &lt;code&gt;digit&lt;/code&gt; represents the radix set specified by the &lt;code&gt;fmtflags&lt;/code&gt; argument value, &lt;code&gt;thousands-sep&lt;/code&gt; and &lt;code&gt;decimal-point&lt;/code&gt; are the results of &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; functions respectively. The format of integer values is as follows:</source>
          <target state="translated">Los n&amp;uacute;meros admitidos por &lt;code&gt;std::numpunct&lt;/code&gt; tienen el formato que se describe a continuaci&amp;oacute;n. Aqu&amp;iacute; &lt;code&gt;digit&lt;/code&gt; representa el conjunto radix especificado por el &lt;code&gt;fmtflags&lt;/code&gt; valor de argumento, &lt;code&gt;thousands-sep&lt;/code&gt; y &lt;code&gt;decimal-point&lt;/code&gt; son los resultados de &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; funciones respectivamente. El formato de los valores enteros es el siguiente:</target>
        </trans-unit>
        <trans-unit id="9bab7274b85a85fa328c276ae190e2933c1da232" translate="yes" xml:space="preserve">
          <source>The numeric input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the end of the stream was encountered while reading the next character, on Stage 2 of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; processing. Depending on the parsing state, &lt;code&gt;failbit&lt;/code&gt; may or may not be set at the same time: for example, &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; sets &lt;code&gt;eofbit&lt;/code&gt;, but not &lt;code&gt;failbit&lt;/code&gt;: the integer &lt;code&gt;1&lt;/code&gt; was successfully parsed and stored in &lt;code&gt;n&lt;/code&gt;. On the other hand, &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; sets both &lt;code&gt;eofbit&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt;: there was not enough characters to complete the parsing of the boolean &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Las sobrecargas num&amp;eacute;ricas de entrada de &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; si se encontr&amp;oacute; el final de la secuencia al leer el siguiente car&amp;aacute;cter, en la Etapa 2 de &lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt; . Dependiendo del estado de an&amp;aacute;lisis, &lt;code&gt;failbit&lt;/code&gt; puede o no establecerse al mismo tiempo: por ejemplo, &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; establece &lt;code&gt;eofbit&lt;/code&gt; , pero no &lt;code&gt;failbit&lt;/code&gt; : el entero &lt;code&gt;1&lt;/code&gt; se analiz&amp;oacute; y almacen&amp;oacute; con &amp;eacute;xito en &lt;code&gt;n&lt;/code&gt; . Por otro lado, &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; establece tanto &lt;code&gt;eofbit&lt;/code&gt; como &lt;code&gt;failbit&lt;/code&gt; : no hab&amp;iacute;a suficientes caracteres para completar el an&amp;aacute;lisis del booleano &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d4dfe124ae3866d608f524aa57220b740c6faaa" translate="yes" xml:space="preserve">
          <source>The numeric value if &lt;code&gt;ch&lt;/code&gt; indeed represents a digit in the currently imbued locale that is valid for the numeric base &lt;code&gt;radix&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; on error.</source>
          <target state="translated">El valor num&amp;eacute;rico si &lt;code&gt;ch&lt;/code&gt; representa un d&amp;iacute;gito en el entorno local actualmente imbuido que es v&amp;aacute;lido para la &lt;code&gt;radix&lt;/code&gt; base num&amp;eacute;rica , o &lt;code&gt;-1&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="cea1f54bd02da8f425b152ab8d2a7f0fbeca2475" translate="yes" xml:space="preserve">
          <source>The numeric, pointer, and boolean input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; (technically, the overloads of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; they call), if the input cannot be parsed as a valid value or if the value parsed does not fit in the destination type.</source>
          <target state="translated">Las sobrecargas num&amp;eacute;ricas, de puntero y de entrada booleana de &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; (t&amp;eacute;cnicamente, las sobrecargas de &lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt; they call), si la entrada no se puede analizar como un valor v&amp;aacute;lido o si el valor analizado no cabe en el tipo de destino</target>
        </trans-unit>
        <trans-unit id="0220d8c40333a0093943bf969db90f89079c2dd9" translate="yes" xml:space="preserve">
          <source>The object</source>
          <target state="translated">El objeto</target>
        </trans-unit>
        <trans-unit id="984c0e6a80490ef643982434d691b02d8e724169" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">El objeto &lt;code&gt;u&lt;/code&gt; est&amp;aacute; &lt;a href=&quot;../language/default_initialization&quot;&gt;inicializado por defecto&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fdf35addca2d2e61228bbe293b020ce2b060c9" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">El objeto &lt;code&gt;u&lt;/code&gt; tiene &lt;a href=&quot;../language/value_initialization&quot;&gt;valor inicializado&lt;/a&gt; o &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;agregado inicializado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d66e0c5c8edf403a2575eab1d9bd1a5f03140bf4" translate="yes" xml:space="preserve">
          <source>The object created by a new-expression is initialized according to the following rules:</source>
          <target state="translated">El objeto creado por una nueva expresión se inicializa según las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="6a3691e4261c0727fb8c31da0443f64d25b8f791" translate="yes" xml:space="preserve">
          <source>The object denoted by the glvalue is not accessed if:</source>
          <target state="translated">El objeto denotado por el glvalue no es accesible si:</target>
        </trans-unit>
        <trans-unit id="25231b05a1580da27ff890c7619a820a11b0eb7b" translate="yes" xml:space="preserve">
          <source>The object is default-initialized.</source>
          <target state="translated">El objeto está inicializado por defecto.</target>
        </trans-unit>
        <trans-unit id="43048e7b920911676623be86d837ae144bd2a9c0" translate="yes" xml:space="preserve">
          <source>The object is destroyed using &lt;a href=&quot;../language/delete&quot;&gt;&lt;code&gt;delete-expression&lt;/code&gt;&lt;/a&gt; or a custom deleter that is supplied to &lt;code&gt;shared_ptr&lt;/code&gt; during construction.</source>
          <target state="translated">El objeto se destruye utilizando &lt;a href=&quot;../language/delete&quot;&gt; &lt;code&gt;delete-expression&lt;/code&gt; &lt;/a&gt; o un eliminador personalizado que se proporciona a &lt;code&gt;shared_ptr&lt;/code&gt; durante la construcci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ff26c6e45a2e565960b0a55f98032b59b34935b9" translate="yes" xml:space="preserve">
          <source>The object is disposed of using a potentially user-supplied deleter by calling &lt;code&gt;get_deleter()(ptr)&lt;/code&gt;. The default deleter uses the &lt;code&gt;delete&lt;/code&gt; operator, which destroys the object and deallocates the memory.</source>
          <target state="translated">El objeto se elimina utilizando un eliminador potencialmente proporcionado por el &lt;code&gt;get_deleter()(ptr)&lt;/code&gt; llamando a get_deleter () (ptr) . El eliminador predeterminado utiliza el operador de &lt;code&gt;delete&lt;/code&gt; , que destruye el objeto y desasigna la memoria.</target>
        </trans-unit>
        <trans-unit id="3d70e838df487033e13d3e82fefeabf6dda9f65a" translate="yes" xml:space="preserve">
          <source>The object is disposed of using the associated deleter when either of the following happens:</source>
          <target state="translated">El objeto se desecha usando el deletéreo asociado cuando ocurre cualquiera de los siguientes casos:</target>
        </trans-unit>
        <trans-unit id="6079965a1e8cbec0fa1c764e9dc6325a1f66300d" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;optional&lt;/code&gt; object that</source>
          <target state="translated">El objeto se inicializa con / asignado a partir de un valor de tipo &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; o un objeto &lt;code&gt;optional&lt;/code&gt; que</target>
        </trans-unit>
        <trans-unit id="2eb07629fc5eb59fd1eeea479f34c50d51c4b7cf" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;T&lt;/code&gt; or another &lt;code&gt;optional&lt;/code&gt; that</source>
          <target state="translated">El objeto se inicializa con / asignado desde un valor de tipo &lt;code&gt;T&lt;/code&gt; u otro &lt;code&gt;optional&lt;/code&gt; que</target>
        </trans-unit>
        <trans-unit id="106e7472fad2690d4a66e2210e0161c76f0e3d6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;a href=&quot;../money_base&quot;&gt;&lt;code&gt;std::money_base::format&lt;/code&gt;&lt;/a&gt; describing the formatting used by this locale.</source>
          <target state="translated">El objeto de tipo &lt;a href=&quot;../money_base&quot;&gt; &lt;code&gt;std::money_base::format&lt;/code&gt; &lt;/a&gt; describe el formato utilizado por este entorno local.</target>
        </trans-unit>
        <trans-unit id="a2654facce30fa17d2f2a6f53431efdc1fad3b19" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::moneypunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">El objeto de tipo &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; contiene los grupos. Las especializaciones est&amp;aacute;ndar de &lt;code&gt;std::moneypunct&lt;/code&gt; devuelven una cadena vac&amp;iacute;a, lo que indica que no hay agrupaci&amp;oacute;n. Las agrupaciones t&amp;iacute;picas (por ejemplo, el entorno local &lt;code&gt;en_US&lt;/code&gt; ) devuelven &lt;code&gt;&quot;\003&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2953e9f8be35412309323e09c4560896f13bada8" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">El objeto de tipo &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; contiene los grupos. Las especializaciones est&amp;aacute;ndar de &lt;code&gt;std::numpunct&lt;/code&gt; devuelven una cadena vac&amp;iacute;a, lo que indica que no hay agrupaci&amp;oacute;n. Las agrupaciones t&amp;iacute;picas (por ejemplo, el entorno local &lt;code&gt;en_US&lt;/code&gt; ) devuelven &lt;code&gt;&quot;\003&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f2911ed4a3e7e4e904c59b8350c8e9466228f6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;CharT&lt;/code&gt; holding the decimal point character.</source>
          <target state="translated">El objeto de tipo &lt;code&gt;CharT&lt;/code&gt; que contiene el car&amp;aacute;cter de punto decimal.</target>
        </trans-unit>
        <trans-unit id="4f95c2c5399637a34a9ee8645410f77e300b41a0" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. In common U.S. locales, this is &lt;code&gt;','&lt;/code&gt; or &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">El objeto de tipo &lt;code&gt;char_type&lt;/code&gt; para usar como separador de miles. En las configuraciones regionales comunes de EE. UU., Es &lt;code&gt;','&lt;/code&gt; o &lt;code&gt;L','&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80bb88b1b4433caf62a715152b1b50f8ad2b9e79" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;','&lt;/code&gt; and &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">El objeto de tipo &lt;code&gt;char_type&lt;/code&gt; para usar como separador de miles. Las especializaciones est&amp;aacute;ndar de &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;','&lt;/code&gt; y &lt;code&gt;L','&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a260dce16a0baabc887328041b098cae9e79f602" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;string_type&lt;/code&gt; holding the currency symbol or code.</source>
          <target state="translated">El objeto de tipo &lt;code&gt;string_type&lt;/code&gt; que contiene el s&amp;iacute;mbolo o c&amp;oacute;digo de moneda.</target>
        </trans-unit>
        <trans-unit id="16c53b267fd0abe28bee8b120878e85d544083a4" translate="yes" xml:space="preserve">
          <source>The object or the type declared by such a declaration will have its &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; equal to the strictest (largest) non-zero expression of all &lt;code&gt;alignas&lt;/code&gt; specifiers used in the declaration, unless it would weaken the natural alignment of the type.</source>
          <target state="translated">El objeto o el tipo declarado por dicha declaraci&amp;oacute;n tendr&amp;aacute; un &lt;a href=&quot;objects#Alignment&quot;&gt;requisito de alineaci&amp;oacute;n&lt;/a&gt; igual a la expresi&amp;oacute;n distinta de cero m&amp;aacute;s estricta (m&amp;aacute;s grande) de todos los especificadores de &lt;code&gt;alignas&lt;/code&gt; utilizados en la declaraci&amp;oacute;n, a menos que debilite la alineaci&amp;oacute;n natural del tipo.</target>
        </trans-unit>
        <trans-unit id="50b34d11b1100c8ed664baedbf8283fc21bb891d" translate="yes" xml:space="preserve">
          <source>The objects are locked by an unspecified series of calls to &lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;try_lock&lt;/code&gt;, and &lt;code&gt;unlock&lt;/code&gt;. If a call to &lt;code&gt;lock&lt;/code&gt; or &lt;code&gt;unlock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">Los objetos est&amp;aacute;n bloqueados por una serie de llamadas no especificadas para &lt;code&gt;lock&lt;/code&gt; , &lt;code&gt;try_lock&lt;/code&gt; y &lt;code&gt;unlock&lt;/code&gt; . Si una llamada para &lt;code&gt;lock&lt;/code&gt; o &lt;code&gt;unlock&lt;/code&gt; resulta en una excepci&amp;oacute;n, se llama a &lt;code&gt;unlock&lt;/code&gt; para cualquier objeto bloqueado antes de volver a lanzarlo.</target>
        </trans-unit>
        <trans-unit id="833b82da6caa8dd8aeb20cf9477fe5f85be57f81" translate="yes" xml:space="preserve">
          <source>The objects created by new-expressions (objects with dynamic storage duration) persist until the pointer returned by the new-expression is used in a matching &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. If the original value of pointer is lost, the object becomes unreachable and cannot be deallocated: a</source>
          <target state="translated">Los objetos creados por nuevas expresiones (objetos con duraci&amp;oacute;n de almacenamiento din&amp;aacute;mico) persisten hasta que el puntero devuelto por la nueva expresi&amp;oacute;n se utiliza en una &lt;a href=&quot;delete&quot;&gt;expresi&amp;oacute;n de eliminaci&amp;oacute;n&lt;/a&gt; coincidente . Si se pierde el valor original del puntero, el objeto se vuelve inalcanzable y no se puede desasignar: a</target>
        </trans-unit>
        <trans-unit id="b2967e2fb3ae07f3f5e3a1fec435ab589fa1f55b" translate="yes" xml:space="preserve">
          <source>The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">Los objetos pueden superponerse: la copia se realiza como si los caracteres se copiaran en una matriz de caracteres temporal y luego los caracteres se copiaron de la matriz a &lt;code&gt;dest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a17a553ce0d57587be0e8416824c075ef07c922" translate="yes" xml:space="preserve">
          <source>The obtained character on success or &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">El personaje obtenido en el &amp;eacute;xito o &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; en el fracaso.</target>
        </trans-unit>
        <trans-unit id="04be47c26eb26c26238109edcd20d6d4d1bb0dc8" translate="yes" xml:space="preserve">
          <source>The obtained wide character or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file reached.</source>
          <target state="translated">El car&amp;aacute;cter ancho obtenido o &lt;code&gt;WEOF&lt;/code&gt; si se produjo un error o se alcanz&amp;oacute; el final del archivo.</target>
        </trans-unit>
        <trans-unit id="2110df2bf8befabdd98eb59b3910b478af8f2dcc" translate="yes" xml:space="preserve">
          <source>The official document on Feature Test Recommendations</source>
          <target state="translated">El documento oficial sobre las recomendaciones de la prueba de características</target>
        </trans-unit>
        <trans-unit id="f708415e16cfe9e7bf1990f786292e4c9e381ac6" translate="yes" xml:space="preserve">
          <source>The offset of the first member of a standard-layout type is always zero (&lt;a href=&quot;../language/ebo&quot;&gt;empty-base optimization&lt;/a&gt; is mandatory).</source>
          <target state="translated">El desplazamiento del primer miembro de un tipo de dise&amp;ntilde;o est&amp;aacute;ndar siempre es cero (la &lt;a href=&quot;../language/ebo&quot;&gt;optimizaci&amp;oacute;n de base vac&amp;iacute;a&lt;/a&gt; es obligatoria).</target>
        </trans-unit>
        <trans-unit id="607857504a9e70bca8a47464af6277ec197d69cc" translate="yes" xml:space="preserve">
          <source>The old value of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">El antiguo valor de &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d886bb54edd589fbd6ce35fc4f8d5d2fed63519" translate="yes" xml:space="preserve">
          <source>The only data stored in a &lt;code&gt;duration&lt;/code&gt; is a tick count of type &lt;code&gt;Rep&lt;/code&gt;. If &lt;code&gt;Rep&lt;/code&gt; is floating point, then the &lt;code&gt;duration&lt;/code&gt; can represent fractions of ticks. &lt;code&gt;Period&lt;/code&gt; is included as part of the duration's type, and is only used when converting between different durations.</source>
          <target state="translated">Los &amp;uacute;nicos datos almacenados en una &lt;code&gt;duration&lt;/code&gt; son un recuento de ticks de tipo &lt;code&gt;Rep&lt;/code&gt; . Si &lt;code&gt;Rep&lt;/code&gt; es punto flotante, la &lt;code&gt;duration&lt;/code&gt; puede representar fracciones de tics. &lt;code&gt;Period&lt;/code&gt; se incluye como parte del tipo de duraci&amp;oacute;n y solo se usa al convertir entre diferentes duraciones.</target>
        </trans-unit>
        <trans-unit id="b2218d6760efda73de78e40ceb5f652b71248a9b" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::nearbyint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;std::nearbyint&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La &amp;uacute;nica diferencia entre &lt;code&gt;std::nearbyint&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; es que &lt;code&gt;std::nearbyint&lt;/code&gt; nunca aumenta &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50d45e1a42306e63fbd2dd995b7cef21bbf82264" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::rint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La &amp;uacute;nica diferencia entre &lt;code&gt;std::rint&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; es que &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; nunca aumenta &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb56d0a76a6c53bff26b5b866f1ad038bed2665b" translate="yes" xml:space="preserve">
          <source>The only exceptions are that non-type template parameters of</source>
          <target state="translated">Las únicas excepciones son que los parámetros de la plantilla no tipo de</target>
        </trans-unit>
        <trans-unit id="f6e8829ff8f2f1e7710d51780b5775f091279131" translate="yes" xml:space="preserve">
          <source>The only specifier that is allowed to appear twice in a decl-specifier-seq is &lt;code&gt;long&lt;/code&gt; (which can appear twice). All other repeats, such as &lt;code&gt;const static const&lt;/code&gt;, or &lt;code&gt;virtual inline virtual&lt;/code&gt; are errors.</source>
          <target state="translated">El &amp;uacute;nico especificador que puede aparecer dos veces en un decl-specifier-seq es &lt;code&gt;long&lt;/code&gt; (que puede aparecer dos veces). Todas las dem&amp;aacute;s repeticiones, como &lt;code&gt;const static const&lt;/code&gt; o &lt;code&gt;virtual inline virtual&lt;/code&gt; son errores.</target>
        </trans-unit>
        <trans-unit id="776dd59d6ff8d1a9ef4d3f03ca55cae7469eb4a0" translate="yes" xml:space="preserve">
          <source>The only specifiers allowed in the decl-specifier-seq of a constructor declaration are &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;, &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;code&gt;explicit&lt;/code&gt; and &lt;code&gt;constexpr&lt;/code&gt; (in particular, no return type is allowed). Note that &lt;a href=&quot;member_functions&quot;&gt;cv- and ref-qualifiers&lt;/a&gt; are not allowed either; const and volatile semantics of an object under construction don't kick in until the most-derived constructor completes.</source>
          <target state="translated">Los &amp;uacute;nicos especificadores permitidos en el decl-specifier-seq de una declaraci&amp;oacute;n de constructor son &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; , &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; , &lt;code&gt;explicit&lt;/code&gt; y &lt;code&gt;constexpr&lt;/code&gt; (en particular, no se permite ning&amp;uacute;n tipo de retorno). Tenga en cuenta que los &lt;a href=&quot;member_functions&quot;&gt;calificadores cv y ref&lt;/a&gt; tampoco est&amp;aacute;n permitidos; La sem&amp;aacute;ntica constante y vol&amp;aacute;til de un objeto en construcci&amp;oacute;n no se activa hasta que se completa el constructor m&amp;aacute;s derivado.</target>
        </trans-unit>
        <trans-unit id="d61491cad2b2617e213366873d893b816a75646e" translate="yes" xml:space="preserve">
          <source>The only standard &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; member constant &lt;code&gt;is_always_lock_free&lt;/code&gt; is also provided by this specialization.</source>
          <target state="translated">La &amp;uacute;nica constante est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; member &lt;code&gt;is_always_lock_free&lt;/code&gt; tambi&amp;eacute;n es proporcionada por esta especializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b892e85a0c7fdd49003290d933695bc0a6e29fec" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los &amp;uacute;nicos componentes de biblioteca est&amp;aacute;ndar que &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; esta excepci&amp;oacute;n son std :: wstring_convert :: from_bytes y &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2e814e1afd8365ad73dca6904c0b4c6f214183c" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los &amp;uacute;nicos componentes de la biblioteca est&amp;aacute;ndar que &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; esta excepci&amp;oacute;n son std :: bitset :: to_ulong y &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3648d0d11e1d50129adc447f795d03447db5902" translate="yes" xml:space="preserve">
          <source>The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly const-qualified, but not volatile-qualified).</source>
          <target state="translated">Los únicos tipos que se pueden copiar trivialmente son los tipos escalares,las clases que se pueden copiar trivialmente y las matrices de tales tipos/clases (posiblemente calificados como constantes,pero no como volátiles).</target>
        </trans-unit>
        <trans-unit id="b25a51f5e3f4b6ece2ce4ed04dda4a2b91159629" translate="yes" xml:space="preserve">
          <source>The only valid use of &lt;code&gt;operator*&lt;/code&gt; with an output iterator is on the left of an assignment: &lt;code&gt;operator*&lt;/code&gt; may return a proxy object, which defines a member &lt;code&gt;operator=&lt;/code&gt; (which may be a template).</source>
          <target state="translated">El &amp;uacute;nico uso v&amp;aacute;lido del &lt;code&gt;operator*&lt;/code&gt; con un iterador de salida est&amp;aacute; a la izquierda de una asignaci&amp;oacute;n: el &lt;code&gt;operator*&lt;/code&gt; puede devolver un objeto proxy, que define un &lt;code&gt;operator=&lt;/code&gt; miembro = (que puede ser una plantilla).</target>
        </trans-unit>
        <trans-unit id="b9566ed81642e87a223297fba2ea3d2e3900b558" translate="yes" xml:space="preserve">
          <source>The only way to replace an allocator is copy-assignment, move-assignment, and swap:</source>
          <target state="translated">La única manera de reemplazar un asignador es copiar-asignar,mover-asignar e intercambiar:</target>
        </trans-unit>
        <trans-unit id="d1f3d8e5a7c4ed4c1fad80ee519fc4a484fdc734" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in postfix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. The result is &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; copy of the original value of the operand. As a side-effect, for non-boolean operands, the expression &lt;code&gt;x++&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;x--&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x -= 1&lt;/code&gt;. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">El expr operando de un operador incorporado incremento o decremento postfijo debe ser una (no const) modificable &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; de tipo aritm&amp;eacute;tico no booleana o puntero a completa &lt;a href=&quot;type-id&quot;&gt;tipo de objeto&lt;/a&gt; . El resultado es &lt;a href=&quot;value_category&quot;&gt;una&lt;/a&gt; copia prvalue del valor original del operando. Como efecto secundario, para los operandos no booleanos, la expresi&amp;oacute;n &lt;code&gt;x++&lt;/code&gt; modifica el valor de su operando como si evaluara &lt;code&gt;x += 1&lt;/code&gt; , y la expresi&amp;oacute;n &lt;code&gt;x--&lt;/code&gt; modifica el valor de su operando como si evaluara &lt;code&gt;x -= 1&lt;/code&gt; . Todas las reglas de conversi&amp;oacute;n aritm&amp;eacute;tica y reglas aritm&amp;eacute;ticas de puntero definidas para &lt;a href=&quot;operator_arithmetic&quot;&gt;operadores aritm&amp;eacute;ticos.&lt;/a&gt; aplique y determine la conversi&amp;oacute;n impl&amp;iacute;cita (si la hay) aplicada al operando, as&amp;iacute; como el tipo de retorno de la expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="46362931546b6ab532aa0058b79c1a3e9f6e3d4e" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in prefix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. For non-boolean operands, the expression &lt;code&gt;++x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;--x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x -= 1&lt;/code&gt;, that is, the prefix increment or decrement is an lvalue expression that identifies the modified operand. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">El expr operando de una en una funci&amp;oacute;n de prefijo incremento o decremento operador debe ser una (no const) modificable &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; de tipo aritm&amp;eacute;tico no booleana o puntero a completa &lt;a href=&quot;type-id&quot;&gt;tipo de objeto&lt;/a&gt; . Para operandos no booleanos, la expresi&amp;oacute;n &lt;code&gt;++x&lt;/code&gt; es exactamente equivalente a &lt;code&gt;x += 1&lt;/code&gt; , y la expresi&amp;oacute;n &lt;code&gt;--x&lt;/code&gt; es exactamente equivalente a &lt;code&gt;x -= 1&lt;/code&gt; , es decir, el incremento o decremento de prefijo es una expresi&amp;oacute;n de valor que identifica el operando modificado. Todas las reglas de conversi&amp;oacute;n aritm&amp;eacute;tica y las reglas aritm&amp;eacute;ticas de puntero definidas para &lt;a href=&quot;operator_arithmetic&quot;&gt;operadores aritm&amp;eacute;ticos se&lt;/a&gt; aplican y determinan la conversi&amp;oacute;n impl&amp;iacute;cita (si la hay) aplicada al operando, as&amp;iacute; como el tipo de retorno de la expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="87d402fbb54b3649a9536c28ce47e12a587d6550" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;sizeof&lt;/code&gt; can't be a C-style type cast: the expression &lt;code&gt;sizeof (int) * p&lt;/code&gt; is unambiguously interpreted as &lt;code&gt;(sizeof(int)) * p&lt;/code&gt;, but not &lt;code&gt;sizeof((int)*p)&lt;/code&gt;.</source>
          <target state="translated">El operando de &lt;code&gt;sizeof&lt;/code&gt; no puede ser una conversi&amp;oacute;n tipo C: la expresi&amp;oacute;n &lt;code&gt;sizeof (int) * p&lt;/code&gt; se interpreta inequ&amp;iacute;vocamente como &lt;code&gt;(sizeof(int)) * p&lt;/code&gt; , pero no &lt;code&gt;sizeof((int)*p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="085c6a701b7e7a71f8bd49b79840a23c53c15e50" translate="yes" xml:space="preserve">
          <source>The operand of the built-in indirection operator must be pointer to object or a pointer to function, and the result is the lvalue referring to the pointer or function to which expr points.</source>
          <target state="translated">El operando del operador indirecto incorporado debe ser puntero al objeto o un puntero a la función,y el resultado es el valor l que se refiere al puntero o la función a la que apunta expr.</target>
        </trans-unit>
        <trans-unit id="a41ba177e9a175366d24e342abbe5cb594a72284" translate="yes" xml:space="preserve">
          <source>The operands of any operator may be other expressions or primary expressions (e.g. in &lt;code&gt;1+2*3&lt;/code&gt;, the operands of operator+ are the subexpression &lt;code&gt;2*3&lt;/code&gt; and the primary expression &lt;code&gt;1&lt;/code&gt;).</source>
          <target state="translated">Los operandos de cualquier operador pueden ser otras expresiones o expresiones primarias (por ejemplo, en &lt;code&gt;1+2*3&lt;/code&gt; , los operandos del operador + son la subexpresi&amp;oacute;n &lt;code&gt;2*3&lt;/code&gt; y la expresi&amp;oacute;n primaria &lt;code&gt;1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d012c764a34c8f374b29407cde1eb1fdbb47c2a6" translate="yes" xml:space="preserve">
          <source>The operands of the operators &lt;a href=&quot;typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sizeof&quot;&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;noexcept&quot;&gt;&lt;code&gt;noexcept&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;decltype&quot;&gt;&lt;code&gt;decltype&lt;/code&gt;&lt;/a&gt;(since C++11) are expressions that are not evaluated (unless they are polymorphic glvalues and are the operands of &lt;code&gt;typeid&lt;/code&gt;), since these operators only query the compile-time properties of their operands. Thus, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; does not perform console output.</source>
          <target state="translated">Los operandos de los operadores &lt;a href=&quot;typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;sizeof&quot;&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;noexcept&quot;&gt; &lt;code&gt;noexcept&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;decltype&quot;&gt; &lt;code&gt;decltype&lt;/code&gt; &lt;/a&gt; (desde C ++ 11) son expresiones que no se eval&amp;uacute;an (a menos que sean valores polim&amp;oacute;rficos y sean operandos de &lt;code&gt;typeid&lt;/code&gt; ), ya que estos operadores solo consultan las propiedades de tiempo de compilaci&amp;oacute;n de sus operandos. Por lo tanto, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; no realiza la salida de la consola.</target>
        </trans-unit>
        <trans-unit id="85054a8ab24569b5d580787ed8730ffc9c0905a7" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">La operaci&amp;oacute;n se comporta como si &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; adquieran un &amp;uacute;nico mutex asociado con el objeto de promesa al actualizar el objeto de promesa.</target>
        </trans-unit>
        <trans-unit id="ff918beb1f805c40357e0f6201e33f727cf409ae" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_value_at_thread_exit&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">La operaci&amp;oacute;n se comporta como si &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;set_value_at_thread_exit&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; adquieran un &amp;uacute;nico mutex asociado con el objeto de promesa al actualizar el objeto de promesa.</target>
        </trans-unit>
        <trans-unit id="0dc1d1f6cd97262d10d4163c6f4669641d9589c9" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_exception&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">La operaci&amp;oacute;n se comporta como si &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;set_exception&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; adquieran un &amp;uacute;nico mutex asociado con el objeto de promesa al actualizar el objeto de promesa.</target>
        </trans-unit>
        <trans-unit id="894be649e20a0f667a76b29adef6436e4b7cbd04" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;set_value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">La operaci&amp;oacute;n se comporta como si &lt;code&gt;set_value&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; adquieran un &amp;uacute;nico mutex asociado con el objeto de promesa al actualizar el objeto de promesa.</target>
        </trans-unit>
        <trans-unit id="ada6c00780096e7ea571132eafd7f86af9d8f166" translate="yes" xml:space="preserve">
          <source>The operation is performed as if the following is executed:</source>
          <target state="translated">La operación se realiza como si se ejecutara lo siguiente:</target>
        </trans-unit>
        <trans-unit id="9c665cf102b9a36a3c0f45e7d1968e4deab591b0" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;operator!&lt;/code&gt; is commonly overloaded by the user-defined classes that are intended to be used in boolean contexts. Such classes also provide a user-defined conversion function &lt;code&gt;explicit operator bool()&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; for the standard library example), and the expected behavior of &lt;code&gt;operator!&lt;/code&gt; is to return the value opposite of &lt;code&gt;operator bool&lt;/code&gt;.</source>
          <target state="translated">El operador &lt;code&gt;operator!&lt;/code&gt; com&amp;uacute;nmente est&amp;aacute; sobrecargado por las clases definidas por el usuario que est&amp;aacute;n destinadas a ser utilizadas en contextos booleanos. Dichas clases tambi&amp;eacute;n proporcionan una funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario &lt;code&gt;explicit operator bool()&lt;/code&gt; (ver &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; para el ejemplo de la biblioteca est&amp;aacute;ndar), y el comportamiento esperado del &lt;code&gt;operator!&lt;/code&gt; es devolver el valor opuesto al &lt;code&gt;operator bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f80c851a7fa156f63455e4364c3b3e9685929eb0" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;.&lt;/code&gt; (member access), &lt;code&gt;.*&lt;/code&gt; (member access through pointer to member), and &lt;code&gt;?:&lt;/code&gt; (ternary conditional) cannot be overloaded.</source>
          <target state="translated">Los operadores &lt;code&gt;::&lt;/code&gt; (resoluci&amp;oacute;n de alcance), &lt;code&gt;.&lt;/code&gt; (acceso de miembro),. &lt;code&gt;.*&lt;/code&gt; (acceso de miembro a trav&amp;eacute;s del puntero a miembro) y &lt;code&gt;?:&lt;/code&gt; (condicional ternario) no se pueden sobrecargar.</target>
        </trans-unit>
        <trans-unit id="aac712726a5efd650938a3acaadc33f6fc3919ae" translate="yes" xml:space="preserve">
          <source>The order of destruction of non-local variables is described in &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El orden de destrucci&amp;oacute;n de las variables no locales se describe en &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35758388f82a3ab09aa2cb82071589277664456d" translate="yes" xml:space="preserve">
          <source>The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range &lt;code&gt;[middle, last)&lt;/code&gt; is unspecified.</source>
          <target state="translated">No se garantiza la preservaci&amp;oacute;n del orden de elementos iguales. El orden de los elementos restantes en el rango &lt;code&gt;[middle, last)&lt;/code&gt; no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="8b4e996418f65beaf879b200f677d977522bbc6c" translate="yes" xml:space="preserve">
          <source>The order of member initializers in the list is irrelevant: the actual order of initialization is as follows:</source>
          <target state="translated">El orden de los miembros inicializadores de la lista es irrelevante:el orden real de inicialización es el siguiente:</target>
        </trans-unit>
        <trans-unit id="4ee2462340320dfffdb2356e18adfc9d73dab60f" translate="yes" xml:space="preserve">
          <source>The order of the elements that are not erased is preserved. (This makes it possible to erase individual elements while iterating through the container.).</source>
          <target state="translated">El orden de los elementos que no se borran se conserva.(Esto hace posible borrar elementos individuales mientras se itera a través del contenedor).</target>
        </trans-unit>
        <trans-unit id="45de463a3e1e66d3a48db307eb7e59ab651dcd8a" translate="yes" xml:space="preserve">
          <source>The order of the elements that compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">El orden de los elementos que se comparan equivalentes es el orden de inserción y no cambia.(desde C++11).</target>
        </trans-unit>
        <trans-unit id="abd27fd7960ecb4b3cee9ed3bc8fa827648946bf" translate="yes" xml:space="preserve">
          <source>The order of the key-value pairs whose keys compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">El orden de los pares llave-valor cuyas claves se comparan equivalentes es el orden de inserción y no cambia.(desde C++11).</target>
        </trans-unit>
        <trans-unit id="a9ef10d36f3c0c975aa40ae381346f09fe5d7ab9" translate="yes" xml:space="preserve">
          <source>The ordering comparisons are done lexicographically -- the comparison is performed by a function equivalent to &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Las comparaciones de pedidos se realizan lexicogr&amp;aacute;ficamente: la comparaci&amp;oacute;n se realiza mediante una funci&amp;oacute;n equivalente a &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0966d7161405c174477a1237dbe2bf1df99477d" translate="yes" xml:space="preserve">
          <source>The ordering is strict weak ordering relation.</source>
          <target state="translated">El ordenamiento es una estricta relación de ordenamiento débil.</target>
        </trans-unit>
        <trans-unit id="1f12ff5d7e6a675fd2031dd36912c9789309ddc9" translate="yes" xml:space="preserve">
          <source>The original intent of the &lt;code&gt;inline&lt;/code&gt; keyword was to serve as an indicator to the optimizer that &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;inline substitution of a function&lt;/a&gt; is preferred over function call, that is, instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (passing the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.</source>
          <target state="translated">La intenci&amp;oacute;n original de la palabra clave en &lt;code&gt;inline&lt;/code&gt; era servir como un indicador para el optimizador de que la &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;sustituci&amp;oacute;n en l&amp;iacute;nea de una funci&amp;oacute;n&lt;/a&gt; es preferible a la llamada a la funci&amp;oacute;n, es decir, en lugar de ejecutar la instrucci&amp;oacute;n de llamada a la funci&amp;oacute;n CPU para transferir el control al cuerpo de la funci&amp;oacute;n, una copia de El cuerpo de la funci&amp;oacute;n se ejecuta sin generar la llamada. Esto evita la sobrecarga creada por la llamada a la funci&amp;oacute;n (pasando los argumentos y recuperando el resultado) pero puede resultar en un ejecutable m&amp;aacute;s grande ya que el c&amp;oacute;digo para la funci&amp;oacute;n debe repetirse varias veces.</target>
        </trans-unit>
        <trans-unit id="083eed7b2639f184e8f8cd016a58c77c340553d1" translate="yes" xml:space="preserve">
          <source>The output iterator &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; makes it possible for standard algorithms to store results in uninitialized memory. Whenever the algorithm writes an object of type &lt;code&gt;T&lt;/code&gt; to the dereferenced iterator, the object is copy-constructed into the location in the uninitialized storage pointed to by the iterator. The template parameter &lt;code&gt;OutputIt&lt;/code&gt; is any type that meets the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and has &lt;code&gt;operator*&lt;/code&gt; defined to return an object, for which &lt;code&gt;operator&amp;amp;&lt;/code&gt; returns an object of type &lt;code&gt;T*&lt;/code&gt;. Usually, the type &lt;code&gt;T*&lt;/code&gt; is used as &lt;code&gt;OutputIt&lt;/code&gt;.</source>
          <target state="translated">El iterador de salida &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; hace posible que los algoritmos est&amp;aacute;ndar almacenen resultados en la memoria no inicializada. Cada vez que el algoritmo escribe un objeto de tipo &lt;code&gt;T&lt;/code&gt; en el iterador desreferenciado, el objeto se construye de forma copiada en la ubicaci&amp;oacute;n del almacenamiento no inicializado se&amp;ntilde;alado por el iterador. El par&amp;aacute;metro de plantilla &lt;code&gt;OutputIt&lt;/code&gt; es cualquier tipo que cumpla con los requisitos de &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; y tenga un &lt;code&gt;operator*&lt;/code&gt; definido para devolver un objeto, para el cual el &lt;code&gt;operator&amp;amp;&lt;/code&gt; devuelve un objeto de tipo &lt;code&gt;T*&lt;/code&gt; . Por lo general, el tipo &lt;code&gt;T*&lt;/code&gt; se usa como &lt;code&gt;OutputIt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e482ce31b119d64121012b0392dad700a664ac70" translate="yes" xml:space="preserve">
          <source>The outputs of an expression consist of its result and all operands modified by the expression (if any).</source>
          <target state="translated">Los resultados de una expresión consisten en su resultado y en todos los operandos modificados por la expresión (si los hay).</target>
        </trans-unit>
        <trans-unit id="9c85e268da67030ad87455310612ee6e33a42e99" translate="yes" xml:space="preserve">
          <source>The overload (3) only participates in overload resolution if &lt;code&gt;Sseq&lt;/code&gt; qualifies as a &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;. In particular, it is excluded from the set of candidate functions if &lt;code&gt;Sseq&lt;/code&gt; is convertible to &lt;code&gt;result_type&lt;/code&gt;.</source>
          <target state="translated">La sobrecarga (3) solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;Sseq&lt;/code&gt; califica como &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt; . En particular, se excluye del conjunto de funciones candidatas si &lt;code&gt;Sseq&lt;/code&gt; es convertible a &lt;code&gt;result_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06bb537d779118fbd7f2e14985ef313bb0e992d7" translate="yes" xml:space="preserve">
          <source>The overload (3) zeroes out elements of non-class types such as &lt;code&gt;int&lt;/code&gt;, which is different from the behavior of &lt;a href=&quot;../../language/new&quot;&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;/a&gt;, which leaves them uninitialized. To match the behavior of &lt;code&gt;new[]&lt;/code&gt;, a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt; can be provided which leaves such elements uninitialized.</source>
          <target state="translated">La sobrecarga (3) pone a cero elementos de tipos que no son de clase, como &lt;code&gt;int&lt;/code&gt; , que es diferente del comportamiento de &lt;a href=&quot;../../language/new&quot;&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;/a&gt; , lo que los deja sin inicializar. Para que coincida con el comportamiento de &lt;code&gt;new[]&lt;/code&gt; , se puede proporcionar un &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;Allocator :: construct personalizado&lt;/a&gt; que deja dichos elementos sin inicializar.</target>
        </trans-unit>
        <trans-unit id="6bf1e7ebfe0e6d90d794292aee13cc0558b63e2d" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">La sobrecarga de &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; devuelve un puntero al primer elemento de &lt;code&gt;il&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="038f0a2e5a071bb2843d1c518dc177b71222920c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the first element in the numeric array.</source>
          <target state="translated">La sobrecarga de &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; devuelve un iterador de tipo no especificado que se refiere al primer elemento en la matriz num&amp;eacute;rica.</target>
        </trans-unit>
        <trans-unit id="84c575ea93991f4dfe1b4bf2acfc46b67a8cd82c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to one past the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">La sobrecarga de &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;initializer_list&lt;/code&gt; devuelve un puntero a uno pasado el &amp;uacute;ltimo elemento de &lt;code&gt;il&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3e880f9ab6d60647899982795a8dda9c2944720" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the one past the last element in the numeric array.</source>
          <target state="translated">La sobrecarga de &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;valarray&lt;/code&gt; devuelve un iterador de tipo no especificado que hace referencia al pasado del &amp;uacute;ltimo elemento en la matriz num&amp;eacute;rica.</target>
        </trans-unit>
        <trans-unit id="dc73911917476c7646928434557b596727d6486b" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">La sobrecarga de &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;initializer_list&lt;/code&gt; devuelve un &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; apuntando al &amp;uacute;ltimo elemento de &lt;code&gt;il&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce6318ab93622dbaf9e7b41535ac8be907e21159" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">La sobrecarga de &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;initializer_list&lt;/code&gt; devuelve un &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; apuntando al primer elemento de &lt;code&gt;il&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c43a69d1f5e72f32062b0ff1de3c8b0d1df1068" translate="yes" xml:space="preserve">
          <source>The overload of operator &lt;code&gt;-&amp;gt;&lt;/code&gt; must either return a raw pointer, or return an object (by reference or by value) for which operator &lt;code&gt;-&amp;gt;&lt;/code&gt; is in turn overloaded.</source>
          <target state="translated">La sobrecarga del operador &lt;code&gt;-&amp;gt;&lt;/code&gt; debe devolver un puntero sin formato, o devolver un objeto (por referencia o por valor) para el que el operador &lt;code&gt;-&amp;gt;&lt;/code&gt; a su vez est&amp;aacute; sobrecargado.</target>
        </trans-unit>
        <trans-unit id="59c7e08ff39317162bda21db4d04832d07f05332" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">La sobrecarga que no toma un &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; par&amp;aacute;metro arroja &lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; en los errores subyacentes de la API del sistema operativo, construido con &lt;code&gt;p&lt;/code&gt; como el primer argumento de ruta y el c&amp;oacute;digo de error del sistema operativo como el argumento del c&amp;oacute;digo de error. La sobrecarga que toma un &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; establece en el c&amp;oacute;digo de error API del sistema operativo si falla una llamada a la API del sistema operativo, y ejecuta &lt;code&gt;ec.clear()&lt;/code&gt; si no se producen errores. Cualquier sobrecarga no marcada como &lt;code&gt;noexcept&lt;/code&gt; puede arrojar &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si falla la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="68156db91adc064f5a1b3f123b0b56bb2aa82cf8" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">La sobrecarga que no toma un &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; par&amp;aacute;metro arroja &lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; en los errores subyacentes de la API del sistema operativo, construido con el c&amp;oacute;digo de error del sistema operativo como argumento del c&amp;oacute;digo de error. La sobrecarga que toma un &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; establece en el c&amp;oacute;digo de error API del sistema operativo si falla una llamada a la API del sistema operativo, y ejecuta &lt;code&gt;ec.clear()&lt;/code&gt; si no se producen errores. Cualquier sobrecarga no marcada como &lt;code&gt;noexcept&lt;/code&gt; puede arrojar &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si falla la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="a24af84b98cf1ff1037189e681754591d35e0d1f" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;from&lt;/code&gt; as the first path argument, &lt;code&gt;to&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">La sobrecarga que no toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; par&amp;aacute;metros lanza &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; en los errores de la API del sistema operativo subyacente, construidos con &lt;code&gt;from&lt;/code&gt; el primer argumento de la ruta, &lt;code&gt;to&lt;/code&gt; que el segundo argumento de la ruta, y el c&amp;oacute;digo de error del sistema operativo como el argumento de c&amp;oacute;digo de error. La sobrecarga que toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; establece en el c&amp;oacute;digo de error API del sistema operativo si falla una llamada a la API del sistema operativo, y ejecuta &lt;code&gt;ec.clear()&lt;/code&gt; si no se producen errores. Cualquier sobrecarga no marcada como &lt;code&gt;noexcept&lt;/code&gt; puede arrojar &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si falla la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="5c99e4f6d242cae156fe8c53c180077d5056a8e5" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;old_p&lt;/code&gt; as the first path argument, &lt;code&gt;new_p&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">La sobrecarga que no toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; par&amp;aacute;metro arroja &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; en los errores subyacentes de la API del sistema operativo, construido con &lt;code&gt;old_p&lt;/code&gt; como primer argumento de ruta, &lt;code&gt;new_p&lt;/code&gt; como el segundo argumento de ruta y el c&amp;oacute;digo de error del sistema operativo como argumento de c&amp;oacute;digo de error. La sobrecarga que toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; establece en el c&amp;oacute;digo de error API del sistema operativo si falla una llamada a la API del sistema operativo, y ejecuta &lt;code&gt;ec.clear()&lt;/code&gt; si no se producen errores. Cualquier sobrecarga no marcada como &lt;code&gt;noexcept&lt;/code&gt; puede arrojar &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si falla la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="a0951321ca4ae56851938cae8c8021bfe0924467" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p1&lt;/code&gt; as the first path argument, &lt;code&gt;p2&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">La sobrecarga que no toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; par&amp;aacute;metro arroja &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; en los errores subyacentes de la API del sistema operativo, construido con &lt;code&gt;p1&lt;/code&gt; como el primer argumento de ruta, &lt;code&gt;p2&lt;/code&gt; como el segundo argumento de ruta y el c&amp;oacute;digo de error del sistema operativo como argumento de c&amp;oacute;digo de error. La sobrecarga que toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; establece en el c&amp;oacute;digo de error API del sistema operativo si falla una llamada a la API del sistema operativo, y ejecuta &lt;code&gt;ec.clear()&lt;/code&gt; si no se producen errores. Cualquier sobrecarga no marcada como &lt;code&gt;noexcept&lt;/code&gt; puede arrojar &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si falla la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="097925b28af9c725f044eb3f3ff1a0803fb41ab3" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">La sobrecarga que no toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; par&amp;aacute;metro arroja &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; en los errores subyacentes de la API del sistema operativo, construido con &lt;code&gt;p&lt;/code&gt; como el primer argumento de ruta y el c&amp;oacute;digo de error del sistema operativo como el argumento del c&amp;oacute;digo de error. La sobrecarga que toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; establece en el c&amp;oacute;digo de error API del sistema operativo si falla una llamada a la API del sistema operativo, y ejecuta &lt;code&gt;ec.clear()&lt;/code&gt; si no se producen errores. Cualquier sobrecarga no marcada como &lt;code&gt;noexcept&lt;/code&gt; puede arrojar &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si falla la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="2743dce817550a96f75513fc032ccf30bdcdc608" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument, &lt;code&gt;base&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">La sobrecarga que no toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; par&amp;aacute;metro arroja &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; en los errores subyacentes de la API del sistema operativo, construido con &lt;code&gt;p&lt;/code&gt; como primer argumento de ruta, &lt;code&gt;base&lt;/code&gt; como el segundo argumento de ruta y el c&amp;oacute;digo de error del sistema operativo como argumento de c&amp;oacute;digo de error. La sobrecarga que toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; establece en el c&amp;oacute;digo de error API del sistema operativo si falla una llamada a la API del sistema operativo, y ejecuta &lt;code&gt;ec.clear()&lt;/code&gt; si no se producen errores. Cualquier sobrecarga no marcada como &lt;code&gt;noexcept&lt;/code&gt; puede arrojar &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si falla la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="45cad57e74ff3ba3f508e070185a6b0faa062d9c" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;path to be returned&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">La sobrecarga que no toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; par&amp;aacute;metro arroja &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; en los errores subyacentes de la API del sistema operativo, construido con la &lt;code&gt;path to be returned&lt;/code&gt; como primer argumento de ruta y el c&amp;oacute;digo de error del sistema operativo como argumento de c&amp;oacute;digo de error. La sobrecarga que toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; establece en el c&amp;oacute;digo de error API del sistema operativo si falla una llamada a la API del sistema operativo, y ejecuta &lt;code&gt;ec.clear()&lt;/code&gt; si no se producen errores. Cualquier sobrecarga no marcada como &lt;code&gt;noexcept&lt;/code&gt; puede arrojar &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si falla la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="63b27ca41e532a5a7a9cbe39b5246376a55b9912" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;target&lt;/code&gt; as the first path argument, &lt;code&gt;link&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">La sobrecarga que no toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; par&amp;aacute;metro arroja &lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt; en los errores subyacentes de la API del sistema operativo, construido con &lt;code&gt;target&lt;/code&gt; como el primer argumento de ruta, &lt;code&gt;link&lt;/code&gt; como el segundo argumento de ruta y el c&amp;oacute;digo de error del sistema operativo como argumento de c&amp;oacute;digo de error. La sobrecarga que toma un &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; establece en el c&amp;oacute;digo de error API del sistema operativo si falla una llamada a la API del sistema operativo y ejecuta &lt;code&gt;ec.clear()&lt;/code&gt; si no se producen errores. Cualquier sobrecarga no marcada como &lt;code&gt;noexcept&lt;/code&gt; puede arrojar &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si falla la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="7b44057a826fb8d870cd4cdd23aeed9b3f71f525" translate="yes" xml:space="preserve">
          <source>The overload with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; reports errors as follows:</source>
          <target state="translated">La sobrecarga con un par&amp;aacute;metro de plantilla llamado &lt;code&gt;ExecutionPolicy&lt;/code&gt; informa los errores de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="be64bc9e876275165a0c7eba9eb5ad84ea913bf6" translate="yes" xml:space="preserve">
          <source>The overloads (2-6) provide allocator propagation into &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;, which supports neither leading-allocator nor trailing-allocator calling conventions (unlike, e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, which uses leading-allocator convention).</source>
          <target state="translated">Las sobrecargas (2-6) proporcionan propagaci&amp;oacute;n del asignador en &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; , que no admite convenios de llamada de asignador principal ni de asignador final (a diferencia de, por ejemplo, &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , que utiliza la convenci&amp;oacute;n de asignador principal).</target>
        </trans-unit>
        <trans-unit id="684f3f556fb197adb926e01a526a9556d8043a2d" translate="yes" xml:space="preserve">
          <source>The overloads (5,6) are often implemented as a loop that calls the overload (3) with &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; as the hint; they are optimized for appending a sorted sequence (such as another set) whose smallest element is greater than the last element in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Las sobrecargas (5,6) a menudo se implementan como un bucle que llama a la sobrecarga (3) con &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; como pista; est&amp;aacute;n optimizados para agregar una secuencia ordenada (como otro conjunto) cuyo elemento m&amp;aacute;s peque&amp;ntilde;o es mayor que el &amp;uacute;ltimo elemento en &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70d94f85af425ede81ffbbe7061489408578ee30" translate="yes" xml:space="preserve">
          <source>The overloads are marked as &lt;code&gt;constexpr&lt;/code&gt; since C++14.</source>
          <target state="translated">Las sobrecargas se marcan como &lt;code&gt;constexpr&lt;/code&gt; desde C ++ 14.</target>
        </trans-unit>
        <trans-unit id="44fe9b19e02fae03d565fc0de302ad3d97db79e7" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">Las sobrecargas no tomar &lt;code&gt;opts&lt;/code&gt; como par&amp;aacute;metro utiliza una instancia predeterminada construida de &lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; &lt;/a&gt; como las opciones. Las sobrecargas que no toman el &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;upstream&lt;/code&gt; como par&amp;aacute;metro utilizan el valor de retorno de std :: pmr :: get_default_resource () como recurso de memoria ascendente.</target>
        </trans-unit>
        <trans-unit id="5088ac896f932a6a0d4f549d22b00102f8ee7619" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">Las sobrecargas no tomar &lt;code&gt;opts&lt;/code&gt; como par&amp;aacute;metro utiliza una instancia predeterminada construida de &lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; &lt;/a&gt; como las opciones. Las sobrecargas que no toman el &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; &lt;code&gt;upstream&lt;/code&gt; como par&amp;aacute;metro utilizan el valor de retorno de std :: pmr :: get_default_resource como recurso de memoria ascendente.</target>
        </trans-unit>
        <trans-unit id="8126e43884394c17d3457633c0894495b6f29864" translate="yes" xml:space="preserve">
          <source>The overloads of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; that take a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument (&lt;code&gt;b&lt;/code&gt; in a@b), they must be implemented as non-members.</source>
          <target state="translated">Las sobrecargas de &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; que toman un &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; como el argumento de la izquierda se conocen como operadores de inserci&amp;oacute;n y extracci&amp;oacute;n. Como toman el tipo definido por el usuario como el argumento correcto ( &lt;code&gt;b&lt;/code&gt; en a @ b), deben implementarse como no miembros.</target>
        </trans-unit>
        <trans-unit id="435446cb476ebaebe355f8cf48105e0dddc8213e" translate="yes" xml:space="preserve">
          <source>The overloads of operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; lose short-circuit evaluation.</source>
          <target state="translated">Las sobrecargas de los operadores &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; perder la evaluaci&amp;oacute;n de cortocircuito</target>
        </trans-unit>
        <trans-unit id="c77c38e018a2a03f4663ee8fdfa0fd3a61518b4d" translate="yes" xml:space="preserve">
          <source>The overloads taking parameters named &lt;code&gt;pos1&lt;/code&gt; or &lt;code&gt;pos2&lt;/code&gt; throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if the argument is out of range.</source>
          <target state="translated">Las sobrecargas que toman par&amp;aacute;metros denominados &lt;code&gt;pos1&lt;/code&gt; o &lt;code&gt;pos2&lt;/code&gt; arrojan &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; si el argumento est&amp;aacute; fuera de rango.</target>
        </trans-unit>
        <trans-unit id="15de6f30385481ec7a64ac4f54a04bf7a70486ea" translate="yes" xml:space="preserve">
          <source>The overloads that do not use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument becomes the element of a pair. The overloads that use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument is used to construct, piecewise, a new object of specified type, which will become the element of the pair.</source>
          <target state="translated">Las sobrecargas que no usan &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; suponen que cada argumento de tupla se convierte en el elemento de un par. Las sobrecargas que usan &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; suponen que cada argumento de tupla se usa para construir, por partes, un nuevo objeto de tipo especificado, que se convertir&amp;aacute; en el elemento del par.</target>
        </trans-unit>
        <trans-unit id="b7bdb96b9c09362e092f33a4cbae2fe72c83f4e2" translate="yes" xml:space="preserve">
          <source>The overloads with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; report errors as follows:</source>
          <target state="translated">Las sobrecargas con un par&amp;aacute;metro de plantilla denominado &lt;code&gt;ExecutionPolicy&lt;/code&gt; informan de los siguientes errores:</target>
        </trans-unit>
        <trans-unit id="a864b224232c408c9511f10f7feafcbf33889a52" translate="yes" xml:space="preserve">
          <source>The override for the virtual member function &lt;code&gt;what()&lt;/code&gt; may by provided, but is not required.</source>
          <target state="translated">La anulaci&amp;oacute;n de la funci&amp;oacute;n de miembro virtual &lt;code&gt;what()&lt;/code&gt; puede proporcionarse, pero no es obligatoria.</target>
        </trans-unit>
        <trans-unit id="8d89be08f6f6c31578200be6591584e87d1fdf78" translate="yes" xml:space="preserve">
          <source>The overriders of &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt; functions do not acquire the default arguments from the base class declarations, and when the virtual function call is made, the default arguments are decided based on the static type of the object (note: this can be avoided with &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;non-virtual interface&lt;/a&gt; pattern).</source>
          <target state="translated">Los anuladores de funciones &lt;a href=&quot;virtual&quot;&gt;virtuales&lt;/a&gt; no adquieren los argumentos predeterminados de las declaraciones de clase base, y cuando se realiza la llamada a la funci&amp;oacute;n virtual, los argumentos predeterminados se deciden en funci&amp;oacute;n del tipo est&amp;aacute;tico del objeto (nota: esto se puede evitar con &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;no virtual&lt;/a&gt; patr&amp;oacute;n de interfaz ).</target>
        </trans-unit>
        <trans-unit id="c2ff4997fdc8d657823adaf82ddae1edd807b428" translate="yes" xml:space="preserve">
          <source>The ownership of an object can only be shared with another &lt;code&gt;shared_ptr&lt;/code&gt; by copy constructing or copy assigning its value to another &lt;code&gt;shared_ptr&lt;/code&gt;. Constructing a new &lt;code&gt;shared_ptr&lt;/code&gt; using the raw underlying pointer owned by another &lt;code&gt;shared_ptr&lt;/code&gt; leads to undefined behavior.</source>
          <target state="translated">La propiedad de un objeto solo se puede compartir con otro &lt;code&gt;shared_ptr&lt;/code&gt; copiando construcci&amp;oacute;n o copia asignando su valor a otro &lt;code&gt;shared_ptr&lt;/code&gt; . La construcci&amp;oacute;n de un nuevo &lt;code&gt;shared_ptr&lt;/code&gt; utilizando el puntero subyacente sin procesar propiedad de otro &lt;code&gt;shared_ptr&lt;/code&gt; conduce a un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="fa11b27c4386988848a8387d60af610e8a21c655" translate="yes" xml:space="preserve">
          <source>The paragraph defining the strict aliasing rule in the standard contains two additional bullets partially inherited from C:</source>
          <target state="translated">El párrafo que define la estricta regla de los alias en la norma contiene dos viñetas adicionales heredadas parcialmente de C:</target>
        </trans-unit>
        <trans-unit id="8d946d0089157a6f8805e15b4ad51c2da0943b9d" translate="yes" xml:space="preserve">
          <source>The parallelizable version of this algorithm, &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt;, requires &lt;code&gt;op1&lt;/code&gt; and &lt;code&gt;op2&lt;/code&gt; to be commutative and associative, but &lt;code&gt;std::inner_product&lt;/code&gt; makes no such requirement, and always performs the operations in the order given.</source>
          <target state="translated">La versi&amp;oacute;n paralelizable de este algoritmo, &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt; , requiere que &lt;code&gt;op1&lt;/code&gt; y &lt;code&gt;op2&lt;/code&gt; sean conmutativos y asociativos, pero &lt;code&gt;std::inner_product&lt;/code&gt; no exige tal requisito, y siempre realiza las operaciones en el orden indicado.</target>
        </trans-unit>
        <trans-unit id="88022664eeccd42a9c9975d465fba66ce4506250" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared type of the variable that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt; or, if the initialization is copy-list-initialization, with &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the initializer expression. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;P&lt;/code&gt; to get the actual variable type:</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;P&lt;/code&gt; se obtiene de la siguiente manera: en &lt;code&gt;T&lt;/code&gt; , el tipo declarado de la variable que incluye &lt;code&gt;auto&lt;/code&gt; , cada aparici&amp;oacute;n de &lt;code&gt;auto&lt;/code&gt; se reemplaza con un par&amp;aacute;metro de plantilla de tipo imaginario &lt;code&gt;U&lt;/code&gt; o, si la inicializaci&amp;oacute;n es copy-list-initialization, con &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt; . El argumento &lt;code&gt;A&lt;/code&gt; es la expresi&amp;oacute;n inicializadora. Despu&amp;eacute;s de deducir &lt;code&gt;U&lt;/code&gt; de &lt;code&gt;P&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; siguiendo las reglas descritas anteriormente, la &lt;code&gt;U&lt;/code&gt; deducida se sustituye por &lt;code&gt;P&lt;/code&gt; para obtener el tipo de variable real:</target>
        </trans-unit>
        <trans-unit id="ced868183336be7e9556ada04c5529aea418503e" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;i&lt;/code&gt; shall be less than the number of elements in the array; otherwise, the behavior is undefined.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;i&lt;/code&gt; ser&amp;aacute; menor que el n&amp;uacute;mero de elementos en la matriz; de lo contrario, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="399902f69cf10a83ab53fc5cc2b8d7444ca7d8d2" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;init&lt;/code&gt; appears last, differing from &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt;, because it is optional for this function.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;init&lt;/code&gt; aparece en &amp;uacute;ltimo lugar, diferente de &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt; , porque es opcional para esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="309510cf9024b1695506845548ff6ef69f7b6db0" translate="yes" xml:space="preserve">
          <source>The parameter is passed by value and is subject to slicing.</source>
          <target state="translated">El parámetro se pasa por valor y está sujeto a rebanadas.</target>
        </trans-unit>
        <trans-unit id="7f622764221043c46158533031680f20b679054a" translate="yes" xml:space="preserve">
          <source>The parameter types and the return type of the function must match the target exactly, no implicit conversions are considered (e.g. a function returning a pointer to derived won't get selected when initializing a pointer to function returning a pointer to base).</source>
          <target state="translated">Los tipos de parámetros y el tipo de retorno de la función deben coincidir exactamente con el objetivo,no se consideran conversiones implícitas (por ejemplo,una función que devuelve un puntero a derivado no se seleccionará cuando se inicialice un puntero a función que devuelva un puntero a base).</target>
        </trans-unit>
        <trans-unit id="04103a3447a63b6cf20e5c231a8fc7a4ccdc71ac" translate="yes" xml:space="preserve">
          <source>The parameter types, as well as the return type of a function cannot be &lt;a href=&quot;incomplete_type&quot;&gt;incomplete&lt;/a&gt;&lt;a href=&quot;class&quot;&gt;class types&lt;/a&gt;, except for deleted functions(since C++11). The completeness check is made in the context of the function</source>
          <target state="translated">Los tipos de par&amp;aacute;metros, as&amp;iacute; como el tipo de retorno de una funci&amp;oacute;n, no pueden ser &lt;a href=&quot;class&quot;&gt;tipos de clase &lt;/a&gt;&lt;a href=&quot;incomplete_type&quot;&gt;incompletos&lt;/a&gt; , excepto para funciones eliminadas (desde C ++ 11). La comprobaci&amp;oacute;n de integridad se realiza en el contexto de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="72593e2e10e937d3bd8a9e45b5e7630cd1c55e97" translate="yes" xml:space="preserve">
          <source>The parameters declared in the declarator of a function definition are &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt; within the body. If a parameter is not used in the function body, it does not need to be named (it's sufficient to use an abstract declarator).</source>
          <target state="translated">Los par&amp;aacute;metros declarados en el declarador de una definici&amp;oacute;n de funci&amp;oacute;n est&amp;aacute;n dentro del &lt;a href=&quot;scope&quot;&gt;alcance&lt;/a&gt; del cuerpo. Si un par&amp;aacute;metro no se usa en el cuerpo de la funci&amp;oacute;n, no necesita ser nombrado (es suficiente usar un declarador abstracto).</target>
        </trans-unit>
        <trans-unit id="d233ef2eab4dce31ee515ec28dc0e9bc316caee3" translate="yes" xml:space="preserve">
          <source>The parameters m and s are, respectively, the mean and standard deviation of the natural logarithm of x.</source>
          <target state="translated">Los parámetros m y s son,respectivamente,la media y la desviación estándar del logaritmo natural de x.</target>
        </trans-unit>
        <trans-unit id="cef460ed950b6b80761f1b32499ca34a65c8b52d" translate="yes" xml:space="preserve">
          <source>The parameters of a distribution object may be changed either permanently, by using &lt;code&gt;d.param(p)&lt;/code&gt; or just for the duration of a single operator() call, by using &lt;code&gt;d(g,p)&lt;/code&gt;.</source>
          <target state="translated">Los par&amp;aacute;metros de un objeto de distribuci&amp;oacute;n pueden cambiarse permanentemente, usando &lt;code&gt;d.param(p)&lt;/code&gt; o solo durante la duraci&amp;oacute;n de una llamada de operador &amp;uacute;nico (), usando &lt;code&gt;d(g,p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2936a021e331baf2a03da363a001e002fbef98a" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, size and stride respectively.</source>
          <target state="translated">Los parámetros de la rebanada...inicio,tamaño y paso respectivamente.</target>
        </trans-unit>
        <trans-unit id="0269c7638cb516f0a5e4f2122a21b168b3bc2795" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, sizes and strides respectively.</source>
          <target state="translated">Los parámetros de la rebanada...inicio,tamaños y zancadas respectivamente.</target>
        </trans-unit>
        <trans-unit id="467dc40c372e73f0c2c12405d62c7e8ef32d3367" translate="yes" xml:space="preserve">
          <source>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as</source>
          <target state="translated">Los parámetros de la forma de dos parámetros de la función principal permiten que se pasen cadenas de caracteres multibyte arbitrarias desde el entorno de ejecución (éstas se conocen típicamente como</target>
        </trans-unit>
        <trans-unit id="3c5a1d2074edfc3d26b83a970525326f7df017be" translate="yes" xml:space="preserve">
          <source>The parsed date is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">La fecha analizada se almacena en los campos correspondientes de la estructura &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; se&amp;ntilde;alada por el argumento &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f535b74a20fe9252e07e454d87e684ef404bcaa" translate="yes" xml:space="preserve">
          <source>The parsed month is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt;.</source>
          <target state="translated">El mes analizado se almacena en el campo &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c30cfbbbd6f7927a29d7fcfe63ecd32a351360" translate="yes" xml:space="preserve">
          <source>The parsed time is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">El tiempo analizado se almacena en los campos correspondientes de la estructura &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; se&amp;ntilde;alada por el argumento &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14f5b5d4d2f8aed5cb8f99bcda8328dda074ac91" translate="yes" xml:space="preserve">
          <source>The parsed weekday is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt;.</source>
          <target state="translated">El d&amp;iacute;a de la semana analizado se almacena en el campo &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cdf3188b56cdad85a77a2a64d2b697625de2a7b" translate="yes" xml:space="preserve">
          <source>The parsed year is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure field &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt;.</source>
          <target state="translated">El a&amp;ntilde;o analizado se almacena en el campo de estructura &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c55bd34e7cff3055dc08d70fe226b40f2972b1b5" translate="yes" xml:space="preserve">
          <source>The partial specialization (5) only exists if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; is not convertible to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n parcial (5) solo existe si &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; no es convertible a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23f549c7dd61d901fe54500a09da11aa34be717c" translate="yes" xml:space="preserve">
          <source>The partial specialization of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax.</source>
          <target state="translated">La especializaci&amp;oacute;n parcial de &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; para pares proporciona una forma en tiempo de compilaci&amp;oacute;n para obtener el n&amp;uacute;mero de elementos en un par, que siempre es 2, utilizando una sintaxis tipo tupla.</target>
        </trans-unit>
        <trans-unit id="c5221fc4cfc2057c802611cbc8029455768b8710" translate="yes" xml:space="preserve">
          <source>The partial specializations of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if &lt;code&gt;I &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="translated">Las especializaciones parciales de &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; para pares proporcionan acceso en tiempo de compilaci&amp;oacute;n a los tipos de elementos del par, utilizando una sintaxis tipo tupla. El programa est&amp;aacute; mal formado si &lt;code&gt;I &amp;gt;= 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9182a1c88da6a522cf7ab9faaecc8994e994260" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate shared_ptr objects atomically.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla parcial de &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; permite a los usuarios manipular los objetos shared_ptr at&amp;oacute;micamente.</target>
        </trans-unit>
        <trans-unit id="eb0acd7ca55c8a975ce7a1790dcea9fa121ca3b5" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate weak_ptr objects atomically.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla parcial de &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; permite a los usuarios manipular objetos d&amp;eacute;biles_ptr at&amp;oacute;micamente.</target>
        </trans-unit>
        <trans-unit id="3b413e1a3d2902ad2bd6f7353c7ed24fbd704a4c" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator deserves particular mention. In general this iterator is invalidated as though it were a normal iterator to a non-erased element. So &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; is never invalidated, &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; is invalidated only on rehash, &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; is always invalidated (since it is always after the modified elements), and so on.</source>
          <target state="translated">El iterador pasado al final merece una menci&amp;oacute;n particular. En general, este iterador se invalida como si fuera un iterador normal de un elemento no borrado. Por lo tanto, &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; nunca se invalida, &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; se invalida solo en rehash, &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; siempre se invalida (ya que siempre est&amp;aacute; despu&amp;eacute;s de los elementos modificados), y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="4b284ed6473a51bd21fc130bcb9ebaf961cac342" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator is also invalidated unless the erased elements are at the beginning of the container and the last element is not erased.</source>
          <target state="translated">El iterador &quot;pasa-el-fin&quot; también se invalida a menos que los elementos borrados estén al principio del contenedor y el último elemento no se borre.</target>
        </trans-unit>
        <trans-unit id="b0677f6c9e33d408c8fc74dad13a28a32a573cdb" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator may be invalidated (implementation defined)</source>
          <target state="translated">El iterador del pasado puede ser invalidado (se define la aplicación)</target>
        </trans-unit>
        <trans-unit id="3b5524c20e358d594b020e8bdb5b108f709ab7d9" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator.</source>
          <target state="translated">El iterador del pasado.</target>
        </trans-unit>
        <trans-unit id="5e5a668c57f23b6460fdf63ef2455241134daf73" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;&quot;/&quot;&lt;/code&gt; is absolute on a POSIX OS, but is relative on Windows.</source>
          <target state="translated">La ruta &lt;code&gt;&quot;/&quot;&lt;/code&gt; es absoluta en un sistema operativo POSIX, pero es relativa en Windows.</target>
        </trans-unit>
        <trans-unit id="82f5c6939e80a9a4b63791641284d31cb36ab963" translate="yes" xml:space="preserve">
          <source>The path can be traversed element-wise via iterators returned by the &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; functions, which views the path in generic format and iterates over root name, root directory, and the subsequent file name elements (directory separators are skipped except the one that identifies the root directory). If the very last element in the path is a directory separator, the last iterator will dereference to an empty element.</source>
          <target state="translated">La ruta puede ser recorrida por elementos a trav&amp;eacute;s de iteradores devueltos por las funciones &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; , que visualizan la ruta en formato gen&amp;eacute;rico e iteran sobre el nombre ra&amp;iacute;z, el directorio ra&amp;iacute;z y los elementos de nombre de archivo posteriores (se omiten los separadores de directorio excepto el que identifica el directorio ra&amp;iacute;z). Si el &amp;uacute;ltimo elemento en la ruta es un separador de directorio, el &amp;uacute;ltimo iterador desreferenciar&amp;aacute; a un elemento vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="1e16e300f585e54bf938d0439911d56726dd815b" translate="yes" xml:space="preserve">
          <source>The path constructed from the input string after conversion from UTF-8 to the filesystem's native character encoding.</source>
          <target state="translated">La ruta construida a partir de la cadena de entrada después de la conversión de UTF-8 a la codificación de caracteres nativos del sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="6e603cf030e4d0195d580420c1da816f92ceb1c9" translate="yes" xml:space="preserve">
          <source>The path name has the following syntax:</source>
          <target state="translated">El nombre de la ruta tiene la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="e8eb701045d3a46c2ebb72285abb0e82f58fd37e" translate="yes" xml:space="preserve">
          <source>The path to the parent directory.</source>
          <target state="translated">La ruta del directorio principal.</target>
        </trans-unit>
        <trans-unit id="1ceffb6cd0e4fed5091cf63b5f6b9f72943aad5c" translate="yes" xml:space="preserve">
          <source>The perimeter of an ellipse with eccentricity &lt;code&gt;k&lt;/code&gt; and semimajor axis a equals 4aE(k), where E is &lt;code&gt;std::comp_ellint_2&lt;/code&gt;. When eccentricity equals 0, the ellipse degenerates to a circle with radius a and the perimeter equals 2&amp;pi;a, so E(0) = &amp;pi;/2. When eccentricity equals 1, the ellipse degenerates to a line of length 2a, whose perimeter is 4a, so E(1) = 1.</source>
          <target state="translated">El per&amp;iacute;metro de una elipse con excentricidad &lt;code&gt;k&lt;/code&gt; y semieje mayor a es igual a 4aE (k), donde E es &lt;code&gt;std::comp_ellint_2&lt;/code&gt; . Cuando la excentricidad es igual a 0, la elipse se degenera en un c&amp;iacute;rculo con radio a y el per&amp;iacute;metro es igual a 2&amp;pi;a, entonces E (0) = &amp;pi; / 2. Cuando la excentricidad es igual a 1, la elipse se degenera en una l&amp;iacute;nea de longitud 2a, cuyo per&amp;iacute;metro es 4a, entonces E (1) = 1.</target>
        </trans-unit>
        <trans-unit id="e4b5a30aa03db848f6592cd57db56eefa2e1e7f9" translate="yes" xml:space="preserve">
          <source>The period of the resulting duration is the greatest common divisor of &lt;code&gt;Period1&lt;/code&gt; and &lt;code&gt;Period2&lt;/code&gt;.</source>
          <target state="translated">El per&amp;iacute;odo de la duraci&amp;oacute;n resultante es el m&amp;aacute;ximo divisor com&amp;uacute;n de &lt;code&gt;Period1&lt;/code&gt; y &lt;code&gt;Period2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b1ecc6341dad0825427d240ecf259972a63f062" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; can be used in conversion-type-id, indicating a &lt;a href=&quot;function#Return_type_deduction&quot;&gt;deduced return type&lt;/a&gt;:</source>
          <target state="translated">El marcador de posici&amp;oacute;n &lt;a href=&quot;auto&quot;&gt;autom&amp;aacute;tico&lt;/a&gt; se puede utilizar en conversion-type-id, indicando un &lt;a href=&quot;function#Return_type_deduction&quot;&gt;tipo de retorno deducido&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="11988032bccc6150348612dc3dc97330efc38f94" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;auto&lt;/code&gt; may be accompanied by modifiers, such as &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, which will participate in the type deduction. The placeholder &lt;code&gt;decltype(auto)&lt;/code&gt; must be the the sole constituent of the declared type.(since C++14).</source>
          <target state="translated">El marcador de posici&amp;oacute;n &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;tico puede ir acompa&amp;ntilde;ado de modificadores, como &lt;code&gt;const&lt;/code&gt; o &lt;code&gt;&amp;amp;&lt;/code&gt; , que participar&amp;aacute;n en la deducci&amp;oacute;n de tipo. El marcador de posici&amp;oacute;n &lt;code&gt;decltype(auto)&lt;/code&gt; debe ser el &amp;uacute;nico componente del tipo declarado (desde C ++ 14).</target>
        </trans-unit>
        <trans-unit id="8188f0beadbdc9f67fbcab0cca288be6624dd85d" translate="yes" xml:space="preserve">
          <source>The placement form &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; is not allowed because the matching signature of the deallocation function, &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt;, is a usual (not placement) deallocation function.</source>
          <target state="translated">El formulario de ubicaci&amp;oacute;n &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; no est&amp;aacute; permitido porque la firma coincidente de la funci&amp;oacute;n de desasignaci&amp;oacute;n, &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt; , es habitual (no ubicaci&amp;oacute;n) Funci&amp;oacute;n de desasignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5912c23fdb49cda02bccb62c7fc1895dae110adc" translate="yes" xml:space="preserve">
          <source>The platform-dependent error value.</source>
          <target state="translated">El valor de error dependiente de la plataforma.</target>
        </trans-unit>
        <trans-unit id="22e0322c3fe2739912f4200c9d7cc04be3a7791f" translate="yes" xml:space="preserve">
          <source>The point of declaration for an &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt; is immediately following the opening brace of its class (or class template) definition.</source>
          <target state="translated">El punto de declaraci&amp;oacute;n para un &lt;a href=&quot;injected-class-name&quot;&gt;nombre de clase inyectado&lt;/a&gt; sigue inmediatamente a la llave de apertura de su definici&amp;oacute;n de clase (o plantilla de clase).</target>
        </trans-unit>
        <trans-unit id="0cc6d0e2bd00875eb3b647ab691eaf3a40b734e4" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt; is immediately after the identifier-list of the structured binding declaration, but structured binding initializers are prohibited from referring to any of the names being introduced.</source>
          <target state="translated">El punto de declaraci&amp;oacute;n de un &lt;a href=&quot;structured_binding&quot;&gt;enlace estructurado&lt;/a&gt; es inmediatamente despu&amp;eacute;s de la lista de identificadores de la declaraci&amp;oacute;n de enlace estructurado, pero los inicializadores de enlace estructurado tienen prohibido hacer referencia a cualquiera de los nombres que se introducen.</target>
        </trans-unit>
        <trans-unit id="d2eaa3ef9aed1f964e68ecd40fdb0b4090b12a22" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;type_alias&quot;&gt;type alias or alias template&lt;/a&gt; is immediately after the type-id to which the alias refers:</source>
          <target state="translated">El punto de declaraci&amp;oacute;n de un &lt;a href=&quot;type_alias&quot;&gt;alias de tipo o plantilla de alias&lt;/a&gt; es inmediatamente despu&amp;eacute;s del tipo-id al que se refiere el alias:</target>
        </trans-unit>
        <trans-unit id="fead0939c1b9750ab484b917a8bc503ed969f8da" translate="yes" xml:space="preserve">
          <source>The point of declaration of a class or template is immediately after the identifier that names the class (or the &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; that names the template specialization) appears in its &lt;a href=&quot;classes&quot;&gt;class-head&lt;/a&gt;, and is already in scope in the list of the base classes:</source>
          <target state="translated">El punto de declaraci&amp;oacute;n de una clase o plantilla est&amp;aacute; inmediatamente despu&amp;eacute;s del identificador que nombra la clase (o el &lt;a href=&quot;templates#template-id&quot;&gt;id de plantilla&lt;/a&gt; que nombra la especializaci&amp;oacute;n de plantilla) aparece en su &lt;a href=&quot;classes&quot;&gt;encabezado de clase&lt;/a&gt; , y ya est&amp;aacute; dentro del alcance en la lista de las clases base:</target>
        </trans-unit>
        <trans-unit id="9f0644324f7e4cf1aefd74a5866f04764d1f1056" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumeration is immediately after the identifier that names it appears in the &lt;a href=&quot;enum&quot;&gt;enum specifier&lt;/a&gt; or opaque enum declaration, whichever is used first:</source>
          <target state="translated">El punto de declaraci&amp;oacute;n de una enumeraci&amp;oacute;n es inmediatamente despu&amp;eacute;s del identificador que lo nombra aparece en el &lt;a href=&quot;enum&quot;&gt;especificador de enumeraci&amp;oacute;n&lt;/a&gt; o la declaraci&amp;oacute;n de enumeraci&amp;oacute;n opaca, lo que se use primero:</target>
        </trans-unit>
        <trans-unit id="47421c40dd3c8897ae17db10f6de7045e0604b49" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumerator is immediately after its definition (not before the initializer as it is for variables):</source>
          <target state="translated">El punto de declaración de un enumerador es inmediatamente después de su definición (no antes del inicializador como en el caso de las variables):</target>
        </trans-unit>
        <trans-unit id="82b67920a9148c6fc228fb43bc313b703cc12c0e" translate="yes" xml:space="preserve">
          <source>The pointed-to type of a pointer-to-member may be a pointer-to-member itself: pointers to members can be multilevel, and can be cv-qualifed differently at every level. Mixed multi-level combinations of pointers and pointers-to-members are also allowed:</source>
          <target state="translated">El tipo de puntero a miembro puede ser un puntero a miembro en sí mismo:los punteros a miembros pueden ser de varios niveles,y pueden ser calificados de forma diferente en cada nivel.También se permiten combinaciones mixtas de varios niveles de punteros y de punteros a miembros:</target>
        </trans-unit>
        <trans-unit id="857df6b1a996ed03a792d5426b8be017166c9590" translate="yes" xml:space="preserve">
          <source>The pointer held by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">El puntero sostenido por &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a569ae03f99a2e029c35053360ec402ea8825c3" translate="yes" xml:space="preserve">
          <source>The pointer held by the &lt;code&gt;shared_ptr&lt;/code&gt; directly is the one returned by &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;, while the pointer/object held by the control block is the one that will be deleted when the number of shared owners reaches zero. These pointers are not necessarily equal.</source>
          <target state="translated">El puntero retenido por &lt;code&gt;shared_ptr&lt;/code&gt; directamente es el que devuelve &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; , mientras que el puntero / objeto retenido por el bloque de control es el que se eliminar&amp;aacute; cuando el n&amp;uacute;mero de propietarios compartidos llegue a cero. Estos punteros no son necesariamente iguales.</target>
        </trans-unit>
        <trans-unit id="0b9194591fdc314a0ecc3f4298cf510d1793c0b0" translate="yes" xml:space="preserve">
          <source>The pointer is such that the range &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; is valid and the values in it correspond to the values stored in the string with an additional null character after the last position.</source>
          <target state="translated">El puntero es tal que el rango &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; es v&amp;aacute;lido y los valores que contiene corresponden a los valores almacenados en la cadena con un car&amp;aacute;cter nulo adicional despu&amp;eacute;s de la &amp;uacute;ltima posici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bc4de43f158ae279800dabe183ad787c290be28c" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">El puntero obtenido de &lt;code&gt;c_str()&lt;/code&gt; puede ser invalidado por:</target>
        </trans-unit>
        <trans-unit id="25f266f248c76589a2ccd4234acbb0c2d4e4eacd" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may only be treated as a pointer to a null-terminated character string if the string object does not contain other null characters.</source>
          <target state="translated">El puntero obtenido de &lt;code&gt;c_str()&lt;/code&gt; solo puede tratarse como un puntero a una cadena de caracteres terminada en nulo si el objeto de cadena no contiene otros caracteres nulos.</target>
        </trans-unit>
        <trans-unit id="83480f14010d5cb1f67d2563b68adf44bf7bc56e" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;data()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">El puntero obtenido de &lt;code&gt;data()&lt;/code&gt; puede ser invalidado por:</target>
        </trans-unit>
        <trans-unit id="f8a783b19ce6451ba52b4dc182db830ef0e17f42" translate="yes" xml:space="preserve">
          <source>The pointer returned by the call to &lt;code&gt;a.allocate(n)&lt;/code&gt;.</source>
          <target state="translated">El puntero devuelto por la llamada a &lt;code&gt;a.allocate(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62efe07fde27af3eb6cd42fa101df3a460a161fb" translate="yes" xml:space="preserve">
          <source>The pointer safety used by this implementation.</source>
          <target state="translated">La seguridad del puntero utilizada por esta aplicación.</target>
        </trans-unit>
        <trans-unit id="cdcc993eb7230b5cf2a0e319e9141223d606af16" translate="yes" xml:space="preserve">
          <source>The pointer to convert</source>
          <target state="translated">El puntero para convertir</target>
        </trans-unit>
        <trans-unit id="3616897fc4a7fb62d60e2791e6f3b00f4006b358" translate="yes" xml:space="preserve">
          <source>The pointer to the allocated storage.</source>
          <target state="translated">El indicador del almacenamiento asignado.</target>
        </trans-unit>
        <trans-unit id="3c8844a746827bb53e8a970ddaf5df27d6244fac" translate="yes" xml:space="preserve">
          <source>The pointer to the block of storage to be reclaimed is passed to the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; that was selected by the process above as the first argument. The size of the block is passed as the optional &lt;code&gt;std::size_t&lt;/code&gt; argument. The alignment requirement is passed as the optional &lt;code&gt;std::align_val_t&lt;/code&gt; argument.(since C++17).</source>
          <target state="translated">El puntero al bloque de almacenamiento a reclamar se pasa a la &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;funci&amp;oacute;n de desasignaci&amp;oacute;n&lt;/a&gt; seleccionada por el proceso anterior como primer argumento. El tama&amp;ntilde;o del bloque se pasa como el argumento opcional &lt;code&gt;std::size_t&lt;/code&gt; . El requisito de alineaci&amp;oacute;n se pasa como el argumento opcional &lt;code&gt;std::align_val_t&lt;/code&gt; (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="2f9790c4ee1ba3e3c2d585a13b1c938331446c70" translate="yes" xml:space="preserve">
          <source>The popular Edsger W. Dijkstra essay, &lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;&amp;ldquo;Goto Considered Harmful&amp;rdquo;&lt;/a&gt;, presents a survey of the many subtle problems the careless use of this keyword can introduce.</source>
          <target state="translated">El popular ensayo de Edsger W. Dijkstra, &lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;&quot;Goto Considerado Da&amp;ntilde;ino&quot;&lt;/a&gt; , presenta una encuesta de los muchos problemas sutiles que puede introducir el uso descuidado de esta palabra clave.</target>
        </trans-unit>
        <trans-unit id="3db1aee0e463b1a7e37a693db9028dc4dd6c01b3" translate="yes" xml:space="preserve">
          <source>The portion of the declaration preceding &lt;code&gt;[&lt;/code&gt; applies to the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;, not to the introduced identifiers.</source>
          <target state="translated">La parte de la declaraci&amp;oacute;n anterior &lt;code&gt;[&lt;/code&gt; se aplica a la variable oculta &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; , no a los identificadores introducidos.</target>
        </trans-unit>
        <trans-unit id="63e5a10c38c160db27db345693a402cc1e1242ee" translate="yes" xml:space="preserve">
          <source>The position of the first character of the specified match or sub-match.</source>
          <target state="translated">La posición del primer personaje del partido o subpartido especificado.</target>
        </trans-unit>
        <trans-unit id="28cd458ec55f909805d8bb05b742449475997ff5" translate="yes" xml:space="preserve">
          <source>The possible values for this type (&lt;code&gt;icase&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, etc.) are duplicated inside &lt;a href=&quot;basic_regex/constants&quot;&gt;std::basic_regex&lt;/a&gt;.</source>
          <target state="translated">Los valores posibles para este tipo ( &lt;code&gt;icase&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , etc.) est&amp;aacute;n duplicados dentro de &lt;a href=&quot;basic_regex/constants&quot;&gt;std :: basic_regex&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f158078e6b12f488989a09d27a17236fe92bc958" translate="yes" xml:space="preserve">
          <source>The possible values of FLT_ROUNDS match the possible values of &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt;, returned by &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los valores posibles de FLT_ROUNDS coinciden con los valores posibles de &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt; , devueltos por &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb1f284e6c90d25d80dca04b6d988a3435fc3bfd" translate="yes" xml:space="preserve">
          <source>The postconditions are as follows:</source>
          <target state="translated">Las condiciones postales son las siguientes:</target>
        </trans-unit>
        <trans-unit id="61121624309d02b453ed84455806314e9c9e17f9" translate="yes" xml:space="preserve">
          <source>The postfix increment and decrement expressions have the form.</source>
          <target state="translated">Las expresiones de incremento y decremento del postfijo tienen la forma.</target>
        </trans-unit>
        <trans-unit id="6bb958d510683e21b0e77aaa67075c099774e223" translate="yes" xml:space="preserve">
          <source>The potential scope of a function parameter (including parameters of a lambda expression) or of a function-local predefined variable begins at its point of declaration.</source>
          <target state="translated">El alcance potencial de un parámetro de función (incluidos los parámetros de una expresión lambda)o de una variable predefinida de función local comienza en su punto de declaración.</target>
        </trans-unit>
        <trans-unit id="f221d1f923c37987bf0e3c89da004e995c3dde61" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; begins at the point of declaration and includes the rest of the class body and all function bodies (even if defined outside the class definition or before the declaration of the name), default arguments, exception specifications, in-class brace-or-equal initializers, &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;(since C++20), and all these things in nested classes, recursively.</source>
          <target state="translated">El alcance potencial de un nombre declarado en una &lt;a href=&quot;class&quot;&gt;clase&lt;/a&gt; comienza en el punto de declaraci&amp;oacute;n e incluye el resto del cuerpo de la clase y todos los cuerpos de funci&amp;oacute;n (incluso si se define fuera de la definici&amp;oacute;n de clase o antes de la declaraci&amp;oacute;n del nombre), argumentos predeterminados, especificaciones de excepci&amp;oacute;n , inicializadores de par&amp;eacute;ntesis o igual en clase, &lt;a href=&quot;attributes/contract&quot;&gt;condiciones de contrato&lt;/a&gt; (desde C ++ 20) y todas estas cosas en clases anidadas, de forma recursiva.</target>
        </trans-unit>
        <trans-unit id="2d5497083d21c504b3ed59ade0ed30f3ffbb92bc" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in an exception handler begins at the point of declaration and ends when the exception handler ends, and is not in scope in another exception handler or in the enclosing block.</source>
          <target state="translated">El posible alcance de un nombre declarado en un gestor de excepciones comienza en el punto de declaración y termina cuando termina el gestor de excepciones,y no está en el alcance en otro gestor de excepciones o en el bloque adjunto.</target>
        </trans-unit>
        <trans-unit id="86aa2a90d28cbbde1fb0589dd802c3a11b1e29f7" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in the</source>
          <target state="translated">El alcance potencial de un nombre declarado en el</target>
        </trans-unit>
        <trans-unit id="a17d45e1f219a3300a9f28b3d08fce8f429503aa" translate="yes" xml:space="preserve">
          <source>The potential scope of a template parameter name begins immediately at the point of declaration and continues to the end of the smallest template declaration in which it was introduced. In particular, a template parameter can be used in the declarations of subsequent template parameters and in the specifications of base classes, but can't be used in the declarations of the preceding template parameters.</source>
          <target state="translated">El alcance potencial del nombre de un parámetro de plantilla comienza inmediatamente en el punto de la declaración y continúa hasta el final de la declaración de la plantilla más pequeña en la que se introdujo.En particular,un parámetro de la plantilla puede utilizarse en las declaraciones de los parámetros de la plantilla subsiguientes y en las especificaciones de las clases base,pero no puede utilizarse en las declaraciones de los parámetros de la plantilla precedentes.</target>
        </trans-unit>
        <trans-unit id="32a82cbca985e3e0dfa23c0dbaf5a6027c95d501" translate="yes" xml:space="preserve">
          <source>The potential scope of a variable introduced by a declaration in a &lt;a href=&quot;statements#Compound_statements&quot;&gt;block (compound statement)&lt;/a&gt; begins at the point of declaration and ends at the end of the block. Actual scope is the same as potential scope unless there is a nested block with a declaration that introduces identical name (in which case, the entire potential scope of the nested declaration is excluded from the scope of the outer declaration).</source>
          <target state="translated">El alcance potencial de una variable introducida por una declaraci&amp;oacute;n en un &lt;a href=&quot;statements#Compound_statements&quot;&gt;bloque (declaraci&amp;oacute;n compuesta)&lt;/a&gt; comienza en el punto de declaraci&amp;oacute;n y termina al final del bloque. El alcance real es el mismo que el alcance potencial a menos que haya un bloque anidado con una declaraci&amp;oacute;n que introduzca un nombre id&amp;eacute;ntico (en cuyo caso, todo el alcance potencial de la declaraci&amp;oacute;n anidada se excluye del alcance de la declaraci&amp;oacute;n externa).</target>
        </trans-unit>
        <trans-unit id="3ba3386f44571d8f14970c593d609182dd9626af" translate="yes" xml:space="preserve">
          <source>The potential scope of any entity declared in a &lt;a href=&quot;namespace&quot;&gt;namespace&lt;/a&gt; begins at the declaration and consists of the concatenation of all namespace definitions for the same namespace name that follow, plus, for any &lt;a href=&quot;namespace&quot;&gt;using-directive&lt;/a&gt; that introduced this name or its entire namespace into another scope, the rest of that scope.</source>
          <target state="translated">El alcance potencial de cualquier entidad declarada en un &lt;a href=&quot;namespace&quot;&gt;espacio de nombres&lt;/a&gt; comienza en la declaraci&amp;oacute;n y consiste en la concatenaci&amp;oacute;n de todas las definiciones de espacio de nombres para el mismo nombre de espacio de nombres que sigue, adem&amp;aacute;s, para cualquier &lt;a href=&quot;namespace&quot;&gt;directiva de uso&lt;/a&gt; que haya introducido este nombre o todo su espacio de nombres en otro alcance, El resto de ese alcance.</target>
        </trans-unit>
        <trans-unit id="4ae5d318818acfe339b9d375cb9ce2cfc0456829" translate="yes" xml:space="preserve">
          <source>The potential scope of the name of the parameter of a template template parameter is the smallest template parameter list in which that name appears.</source>
          <target state="translated">El alcance potencial del nombre del parámetro de un parámetro de plantilla es la lista de parámetros de plantilla más pequeña en la que aparece ese nombre.</target>
        </trans-unit>
        <trans-unit id="124da4714b4bf54af7be4c07efe71d32136057e5" translate="yes" xml:space="preserve">
          <source>The precision of the result is at least &lt;code&gt;std::chrono::seconds&lt;/code&gt;, and will be finer if the argument has finer precision.</source>
          <target state="translated">La precisi&amp;oacute;n del resultado es al menos &lt;code&gt;std::chrono::seconds&lt;/code&gt; , y ser&amp;aacute; m&amp;aacute;s fina si el argumento tiene una precisi&amp;oacute;n m&amp;aacute;s fina.</target>
        </trans-unit>
        <trans-unit id="a20b15248f8c5353561f8b4cb6be91d86d20e646" translate="yes" xml:space="preserve">
          <source>The predicate of a contract condition has the same semantic restrictions as if it appeared as the first &lt;a href=&quot;../statements#Expression_statements&quot;&gt;expression statement&lt;/a&gt; in the body of the function it applies to.</source>
          <target state="translated">El predicado de una condici&amp;oacute;n de contrato tiene las mismas restricciones sem&amp;aacute;nticas que si apareciera como la primera &lt;a href=&quot;../statements#Expression_statements&quot;&gt;declaraci&amp;oacute;n de expresi&amp;oacute;n&lt;/a&gt; en el cuerpo de la funci&amp;oacute;n a la que se aplica.</target>
        </trans-unit>
        <trans-unit id="e2463bc948c065d9d75e509585a1ee11887f0dca" translate="yes" xml:space="preserve">
          <source>The prefix increment and decrement expressions have the form.</source>
          <target state="translated">Las expresiones de incremento y decremento del prefijo tienen la forma.</target>
        </trans-unit>
        <trans-unit id="05a52076d2dc5c8b894927a5e244dc4ac56fe7ce" translate="yes" xml:space="preserve">
          <source>The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:</source>
          <target state="translated">Las directivas de preprocesamiento controlan el comportamiento del preprocesador.Cada directiva ocupa una línea y tiene el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="cb413a6249ff3f9ad8dd052d27dcc328f60aee81" translate="yes" xml:space="preserve">
          <source>The preprocessor has the source file translation capabilities:</source>
          <target state="translated">El preprocesador tiene la capacidad de traducción del archivo fuente:</target>
        </trans-unit>
        <trans-unit id="6aa350ea11bb9c5aa25e6e5ec9306cca0035172c" translate="yes" xml:space="preserve">
          <source>The preprocessor is executed at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 4&lt;/a&gt;, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.</source>
          <target state="translated">El preprocesador se ejecuta en la &lt;a href=&quot;language/translation_phases&quot;&gt;fase de traducci&amp;oacute;n 4&lt;/a&gt; , antes de la compilaci&amp;oacute;n. El resultado del preprocesamiento es un archivo &amp;uacute;nico que luego se pasa al compilador real.</target>
        </trans-unit>
        <trans-unit id="e2bdd9572501029c63f84fab6d94f93d8f91603f" translate="yes" xml:space="preserve">
          <source>The preprocessor supports conditional compilation of parts of source file. This behavior is controlled by &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, &lt;code&gt;#ifndef&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; directives.</source>
          <target state="translated">El preprocesador admite la compilaci&amp;oacute;n condicional de partes del archivo fuente. Este comportamiento es controlado por &lt;code&gt;#if&lt;/code&gt; , &lt;code&gt;#else&lt;/code&gt; , &lt;code&gt;#elif&lt;/code&gt; , &lt;code&gt;#ifdef&lt;/code&gt; , &lt;code&gt;#ifndef&lt;/code&gt; y &lt;code&gt;#endif&lt;/code&gt; directivas.</target>
        </trans-unit>
        <trans-unit id="d389a7945641ac5522e189cd36aef892dd202d1a" translate="yes" xml:space="preserve">
          <source>The preprocessor supports text macro replacement. Function-like text macro replacement is also supported.</source>
          <target state="translated">El preprocesador soporta el reemplazo de macros de texto.También admite el reemplazo de macros de texto de tipo funcional.</target>
        </trans-unit>
        <trans-unit id="0e2ac736e4b9518fd1201761b13af480e31f9a2e" translate="yes" xml:space="preserve">
          <source>The previous locale, as returned by &lt;code&gt;ios_base::imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">La configuraci&amp;oacute;n regional anterior, seg&amp;uacute;n lo devuelto por &lt;code&gt;ios_base::imbue(loc)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e848927c4ddc2faed727fdcad88567a9f851617" translate="yes" xml:space="preserve">
          <source>The previous value of the global C++ locale.</source>
          <target state="translated">El valor anterior de la localidad global de C++.</target>
        </trans-unit>
        <trans-unit id="cf70cdf040bccb32e02858713f2da17f9c793063" translate="yes" xml:space="preserve">
          <source>The previously-installed new handler, or a null pointer value if none was installed.</source>
          <target state="translated">El nuevo manejador previamente instalado,o un valor de puntero nulo si no se instaló ninguno.</target>
        </trans-unit>
        <trans-unit id="a35f0efbfe83164488e9c67a5958dce490abc58e" translate="yes" xml:space="preserve">
          <source>The previously-installed terminate handler, or a null pointer value if none was installed.</source>
          <target state="translated">El manejador de terminación previamente instalado,o un valor de puntero nulo si no se instaló ninguno.</target>
        </trans-unit>
        <trans-unit id="d1f9375683ee644e852554818b0e7f65b024d681" translate="yes" xml:space="preserve">
          <source>The previously-installed unexpected handler, or a null pointer value if none was installed.</source>
          <target state="translated">El manipulador inesperado previamente instalado,o un valor de puntero nulo si no se instaló ninguno.</target>
        </trans-unit>
        <trans-unit id="9af84654120543bdc403c77640e19172f575072a" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; satisfying both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;. The program is ill-formed if any of following values is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">El principal &lt;code&gt;std::atomic&lt;/code&gt; plantilla puede ser instanciada con cualquier &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; tipo &lt;code&gt;T&lt;/code&gt; que satisface tanto &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; y &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; . El programa est&amp;aacute; mal formado si alguno de los siguientes valores es &lt;code&gt;false&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="175466bae183473a68237507d57dfae6c15d71d1" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic_ref&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; (including &lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">La plantilla &lt;code&gt;std::atomic_ref&lt;/code&gt; primaria se puede instanciar con cualquier tipo &lt;code&gt;T&lt;/code&gt; &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; (incluido &lt;code&gt;bool&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="7b6fd84220d2a0c86df329eafb7ba3556e2d99b3" translate="yes" xml:space="preserve">
          <source>The primary purpose of function-try-blocks is to respond to an exception thrown from the member initializer list in a constructor by logging and rethrowing, modifying the exception object and rethrowing, throwing a different exception instead, or terminating the program. They are rarely used with destructors or with regular functions.</source>
          <target state="translated">El propósito principal de los bloqueos de prueba de funciones es responder a una excepción lanzada desde la lista de inicialización de miembros en un constructor registrando y volviendo a lanzar,modificando el objeto de la excepción y volviendo a lanzar,lanzando en su lugar una excepción diferente o terminando el programa.Rara vez se utilizan con los destructores o con las funciones regulares.</target>
        </trans-unit>
        <trans-unit id="3f7bdf2c45988d2e398ec47fc464d9bf36ad8ecc" translate="yes" xml:space="preserve">
          <source>The primary sort key for the character sequence &lt;code&gt;[first, last)&lt;/code&gt; in the currently imbued locale, ignoring case, variant, diacritics, etc.</source>
          <target state="translated">La clave de ordenaci&amp;oacute;n primaria para la secuencia de caracteres &lt;code&gt;[first, last)&lt;/code&gt; en el entorno local actualmente imbuido, ignorando may&amp;uacute;sculas y min&amp;uacute;sculas, variantes, signos diacr&amp;iacute;ticos, etc.</target>
        </trans-unit>
        <trans-unit id="f9b3c50b7c4e0adf0fa987d32fbfaf6e0639923e" translate="yes" xml:space="preserve">
          <source>The primary template (1) is not defined; four specializations are provided to handle four different levels of precision.</source>
          <target state="translated">La plantilla primaria (1)no está definida;se proporcionan cuatro especializaciones para manejar cuatro niveles diferentes de precisión.</target>
        </trans-unit>
        <trans-unit id="4f13817f1998ddc17a9521a91f34ffa2754e64b4" translate="yes" xml:space="preserve">
          <source>The primary template is an empty struct. The standard defines the following specializations:</source>
          <target state="translated">La plantilla primaria es una estructura vacía.El estándar define las siguientes especializaciones:</target>
        </trans-unit>
        <trans-unit id="32aa772a60f7448e2e58e9b419a72a7e62908590" translate="yes" xml:space="preserve">
          <source>The primary template is empty. A specialization is provided for &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt;, the default time zone pointer type.</source>
          <target state="translated">La plantilla principal est&amp;aacute; vac&amp;iacute;a. Se proporciona una especializaci&amp;oacute;n para &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt; , el tipo de puntero de zona horaria predeterminado.</target>
        </trans-unit>
        <trans-unit id="5795dc517124b691e8ea332cfeb4ab8696d76a2b" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">El uso principal de &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; es proporcionar un valor l que pueda ser devuelto por el &lt;code&gt;operator[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="895b09aec5064e185b6472594b973b52d8ec16a6" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;std::bitset::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;a href=&quot;operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El uso principal de &lt;code&gt;std::bitset::reference&lt;/code&gt; es proporcionar un valor l que pueda ser devuelto por el &lt;a href=&quot;operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44ca87a7b0da64f5b77109af8b1bf5da6aee13a7" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; member is not affected by this assignment operator.</source>
          <target state="translated">El miembro privado &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; no se ve afectado por este operador de asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b15b5ef90ed5ddcf44be29f564148c6afcb6afcc" translate="yes" xml:space="preserve">
          <source>The probability of &lt;code&gt;h(a)==h(b)&lt;/code&gt; for &lt;code&gt;a!=b&lt;/code&gt; should approach &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">La probabilidad de &lt;code&gt;h(a)==h(b)&lt;/code&gt; para &lt;code&gt;a!=b&lt;/code&gt; deber&amp;iacute;a acercarse a &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95fdc02e0f2a75a69ee3b45caa87c045c455c0be" translate="yes" xml:space="preserve">
          <source>The program is ill-formed</source>
          <target state="translated">El programa está mal formado</target>
        </trans-unit>
        <trans-unit id="f17c9446e3d0891d6f0a550093638571c34482fa" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is not true.</source>
          <target state="translated">El programa est&amp;aacute; mal formado si &lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; no es cierto.</target>
        </trans-unit>
        <trans-unit id="80681cb4437f6410dadbaf99fd1bc0640c36b450" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;Duration&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El programa est&amp;aacute; mal formado si &lt;code&gt;Duration&lt;/code&gt; no es una especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; Duration .</target>
        </trans-unit>
        <trans-unit id="ba17539f8936e17a1b0aee08e3a960ba67a68e62" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is negative. If &lt;code&gt;N&lt;/code&gt; is zero, the indicated type is &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">El programa est&amp;aacute; mal formado si &lt;code&gt;N&lt;/code&gt; es negativo. Si &lt;code&gt;N&lt;/code&gt; es cero, el tipo indicado es &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5a8f5795052236111eac68e22aa48d3e329cc1b" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is not a power of 2. The behavior is undefined if &lt;code&gt;ptr&lt;/code&gt; does not point to an object of type &lt;code&gt;T&lt;/code&gt; (ignoring cv-qualification at every level), or if the object's alignment is not at least &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">El programa est&amp;aacute; mal formado si &lt;code&gt;N&lt;/code&gt; no es una potencia de 2. El comportamiento no est&amp;aacute; definido si &lt;code&gt;ptr&lt;/code&gt; no apunta a un objeto de tipo &lt;code&gt;T&lt;/code&gt; (ignorando la calificaci&amp;oacute;n cv en todos los niveles), o si la alineaci&amp;oacute;n del objeto no es al menos &lt;code&gt;N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67bdd1bd8f7bc35a5850d5aff836099617861a78" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is a function type or (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">El programa est&amp;aacute; mal formado si &lt;code&gt;T&lt;/code&gt; es un tipo de funci&amp;oacute;n o (posiblemente calificado por cv) &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="965acd7bfed42ab433acdc02bbf59b653e8dc291" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if an explicit or partial specialization of &lt;code&gt;std::initializer_list&lt;/code&gt; is declared.</source>
          <target state="translated">El programa est&amp;aacute; mal formado si se declara una especializaci&amp;oacute;n expl&amp;iacute;cita o parcial de &lt;code&gt;std::initializer_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a07725707756ca1bff455b3ddbe27d61f7822a9f" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if any of the following is not &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">El programa est&amp;aacute; mal formado si alguno de los siguientes no es &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f0c2c540025d21052bca08f15510071c65acf1a0" translate="yes" xml:space="preserve">
          <source>The program is well-formed (compiles) only if there exists one unambiguous</source>
          <target state="translated">El programa está bien formado (compila)sólo si existe uno inequívoco</target>
        </trans-unit>
        <trans-unit id="86e09b8d70231ec8b200a5fc3393b854ca51d06f" translate="yes" xml:space="preserve">
          <source>The programmer must ensure that no threads attempt to wait on &lt;code&gt;*this&lt;/code&gt; once the destructor has been started, especially when the waiting threads are calling the wait functions in a loop or are using the overloads of the wait functions that take a predicate.</source>
          <target state="translated">El programador debe asegurarse de que ning&amp;uacute;n subproceso intente esperar &lt;code&gt;*this&lt;/code&gt; una vez que se ha iniciado el destructor, especialmente cuando los subprocesos en espera est&amp;aacute;n llamando a las funciones de espera en un bucle o est&amp;aacute;n utilizando las sobrecargas de las funciones de espera que toman un predicado.</target>
        </trans-unit>
        <trans-unit id="74ef69212c8f3a8d15110cc0d0e198f7faccc793" translate="yes" xml:space="preserve">
          <source>The programming language &lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt; was first to introduce value categories for expressions: all CPL expressions can be evaluated in &quot;right-hand mode&quot;, but only certain kinds of expression are meaningful in &quot;left-hand mode&quot;. When evaluated in right-hand mode, an expression is regarded as being a rule for the computation of a value (the right-hand value, or</source>
          <target state="translated">El lenguaje de programaci&amp;oacute;n &lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt; fue el primero en introducir categor&amp;iacute;as de valores para las expresiones: todas las expresiones CPL pueden evaluarse en &quot;modo de mano derecha&quot;, pero solo ciertos tipos de expresiones son significativas en &quot;modo de mano izquierda&quot;. Cuando se eval&amp;uacute;a en el modo de la mano derecha, una expresi&amp;oacute;n se considera como una regla para el c&amp;aacute;lculo de un valor (el valor de la mano derecha o</target>
        </trans-unit>
        <trans-unit id="67ad89355eacc86b3d6314eddebeebee7f14036d" translate="yes" xml:space="preserve">
          <source>The promise is the &quot;push&quot; end of the promise-future communication channel: the operation that stores a value in the shared state</source>
          <target state="translated">La promesa es el final &quot;push&quot; del canal de comunicación promesa-futuro:la operación que almacena un valor en el estado compartido</target>
        </trans-unit>
        <trans-unit id="3f2caa469d3c691e3afe5b09718f95bd2b49a72b" translate="yes" xml:space="preserve">
          <source>The public functions of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; call this function only if &lt;code&gt;gptr() == nullptr&lt;/code&gt; or &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt;.</source>
          <target state="translated">Las funciones p&amp;uacute;blicas de &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; llaman a esta funci&amp;oacute;n solo si &lt;code&gt;gptr() == nullptr&lt;/code&gt; o &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="775a778b55294eaa175c0471abd743cb50326787" translate="yes" xml:space="preserve">
          <source>The purpose of strict aliasing and related rules is to enable type-based alias analysis, which would be decimated if a program can validly create a situation where two pointers to unrelated types (e.g., an &lt;code&gt;int*&lt;/code&gt; and a &lt;code&gt;float*&lt;/code&gt;) could simultaneously exist and both can be used to load or store the same memory (see &lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;this email on SG12 reflector&lt;/a&gt;). Thus, any technique that is seemingly capable of creating such a situation necessarily invokes undefined behavior.</source>
          <target state="translated">El prop&amp;oacute;sito del alias estricto y las reglas relacionadas es permitir el an&amp;aacute;lisis de alias basado en tipos, que se diezmar&amp;iacute;a si un programa puede crear v&amp;aacute;lidamente una situaci&amp;oacute;n en la que dos punteros a tipos no relacionados (por ejemplo, un &lt;code&gt;int*&lt;/code&gt; y un &lt;code&gt;float*&lt;/code&gt; ) puedan existir simult&amp;aacute;neamente y ambos se pueden usar para cargar o almacenar la misma memoria (consulte &lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;este correo electr&amp;oacute;nico en el reflector SG12&lt;/a&gt; ). Por lo tanto, cualquier t&amp;eacute;cnica que aparentemente sea capaz de crear tal situaci&amp;oacute;n necesariamente invoca un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="537f9c0125fb3b536c8c2bddb97b517098935b00" translate="yes" xml:space="preserve">
          <source>The purpose of this adaptor is to correctly initialize stateful allocators in nested containers, such as when all levels of a nested container must be placed in the same shared memory segment. The adaptor's constructor takes the arguments for all allocators in the list, and each nested container obtains its allocator's state from the adaptor as needed.</source>
          <target state="translated">El propósito de este adaptador es inicializar correctamente los asignadores de estado en contenedores anidados,como cuando todos los niveles de un contenedor anidado deben ser colocados en el mismo segmento de memoria compartida.El constructor del adaptador toma los argumentos de todos los asignadores de la lista,y cada contenedor anidado obtiene su estado de asignador del adaptador según sea necesario.</target>
        </trans-unit>
        <trans-unit id="7c2a811b6c5574010f60bbd62805b17f3c0731ed" translate="yes" xml:space="preserve">
          <source>The purpose of this exception type is similar to the error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; (thrown in &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; from member functions of &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;) and the related errno constant &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El prop&amp;oacute;sito de este tipo de excepci&amp;oacute;n es similar a la condici&amp;oacute;n de error &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; (arrojado en &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; desde las funciones miembro de &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; ) y la constante errno relacionada &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e645b45a5ffa08db62d4e0d26bad721f50ada62" translate="yes" xml:space="preserve">
          <source>The purpose of this rule is to help guard against violations of the &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODR&lt;/a&gt; for template instantiations:</source>
          <target state="translated">El prop&amp;oacute;sito de esta regla es ayudar a proteger contra violaciones de la &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODR&lt;/a&gt; para instancias de plantilla:</target>
        </trans-unit>
        <trans-unit id="e80a3e01ac05bea47ec62aef3af475352cd5d29f" translate="yes" xml:space="preserve">
          <source>The question mark escape sequence &lt;code&gt;\?&lt;/code&gt; is used to prevent &lt;a href=&quot;operator_alternative&quot;&gt;trigraphs&lt;/a&gt; from being interpreted inside string literals: a string such as &lt;code&gt;&quot;??/&quot;&lt;/code&gt; is compiled as &lt;code&gt;&quot;\&quot;&lt;/code&gt;, but if the second question mark is escaped, as in &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt;, it becomes &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</source>
          <target state="translated">La secuencia de escape de signo de interrogaci&amp;oacute;n &lt;code&gt;\?&lt;/code&gt; se usa para evitar que los &lt;a href=&quot;operator_alternative&quot;&gt;trigrafos&lt;/a&gt; se interpreten dentro de los literales de cadena: una cadena como &lt;code&gt;&quot;??/&quot;&lt;/code&gt; se compila como &lt;code&gt;&quot;\&quot;&lt;/code&gt; , pero si se escapa el segundo signo de interrogaci&amp;oacute;n, como en &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt; , se convierte en &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20eb771689c7638596c471df8669135309db406f" translate="yes" xml:space="preserve">
          <source>The quiet NaN value that corresponds to the identifying string &lt;code&gt;arg&lt;/code&gt; or zero if the implementation does not support quiet NaNs.</source>
          <target state="translated">El valor de NaN silencioso que corresponde a la cadena de identificaci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; o cero si la implementaci&amp;oacute;n no admite NaN silenciosos.</target>
        </trans-unit>
        <trans-unit id="eeac3ad06c66b3de50e5a83b3d29765e5993887a" translate="yes" xml:space="preserve">
          <source>The quotient is rounded in implementation-defined direction.</source>
          <target state="translated">El cociente se redondea en la dirección definida por la aplicación.</target>
        </trans-unit>
        <trans-unit id="ee33d1b33c8c2f838818ad7eab65d1c620ffa44b" translate="yes" xml:space="preserve">
          <source>The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that &lt;code&gt;quot * y + rem == x&lt;/code&gt;.</source>
          <target state="translated">El cociente es el cociente algebraico con cualquier parte fraccional descartada (truncada hacia cero). El resto es tal que &lt;code&gt;quot * y + rem == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="501288be26edd4ded7871c5498abfbb8d63a43ff" translate="yes" xml:space="preserve">
          <source>The quotient is the result of the expression &lt;code&gt;x/y&lt;/code&gt;. The remainder is the result of the expression &lt;code&gt;x%y&lt;/code&gt;.</source>
          <target state="translated">El cociente es el resultado de la expresi&amp;oacute;n &lt;code&gt;x/y&lt;/code&gt; . El resto es el resultado de la expresi&amp;oacute;n &lt;code&gt;x%y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fcb33188a4836ac6fb56038cd09dd6ed5942b11" translate="yes" xml:space="preserve">
          <source>The quotient is truncated towards zero (fractional part is discarded).</source>
          <target state="translated">El cociente se trunca hacia el cero (se descarta la parte fraccionaria).</target>
        </trans-unit>
        <trans-unit id="9dadf256e2d94d3cccaced5125b0d93a91578c9e" translate="yes" xml:space="preserve">
          <source>The random number library provides classes that generate random and pseudo-random numbers. These classes include:</source>
          <target state="translated">La biblioteca de números aleatorios proporciona clases que generan números aleatorios y pseudoaleatorios.Estas clases incluyen:</target>
        </trans-unit>
        <trans-unit id="b2af36c522baaa6141e4d68a47e9b38cf32d1814" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">El rango &lt;code&gt;[first, last)&lt;/code&gt; debe ordenarse al menos parcialmente con respecto al &lt;code&gt;value&lt;/code&gt; , es decir, debe cumplir con todos los siguientes requisitos:</target>
        </trans-unit>
        <trans-unit id="cc9d0a4e1c6b28a575aa6a4d6fa56412715ff389" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; or &lt;code&gt;!comp(value, element)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">El rango &lt;code&gt;[first, last)&lt;/code&gt; debe dividirse con respecto a la expresi&amp;oacute;n &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; o &lt;code&gt;!comp(value, element)&lt;/code&gt; , es decir, todos los elementos para los que la expresi&amp;oacute;n es &lt;code&gt;true&lt;/code&gt; deben preceder a todos los elementos para los que la expresi&amp;oacute;n es &lt;code&gt;false&lt;/code&gt; . Un rango completamente ordenado cumple este criterio.</target>
        </trans-unit>
        <trans-unit id="531a6257f348bdfa0bffcab8f3aeb4dc7a540c17" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;element &amp;lt; value&lt;/code&gt; or &lt;code&gt;comp(element, value)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">El rango &lt;code&gt;[first, last)&lt;/code&gt; debe dividirse con respecto al &lt;code&gt;element &amp;lt; value&lt;/code&gt; expresi&amp;oacute;n &amp;lt;valor o &lt;code&gt;comp(element, value)&lt;/code&gt; , es decir, todos los elementos para los que la expresi&amp;oacute;n es &lt;code&gt;true&lt;/code&gt; deben preceder a todos los elementos para los que la expresi&amp;oacute;n es &lt;code&gt;false&lt;/code&gt; . Un rango completamente ordenado cumple este criterio.</target>
        </trans-unit>
        <trans-unit id="17dad5b9e23c675ce64ce4c16ba529098428b325" translate="yes" xml:space="preserve">
          <source>The ranges library provides components for dealing with ranges of elements, including a variety of view adapters.</source>
          <target state="translated">La biblioteca de gamas proporciona componentes para tratar las gamas de elementos,incluyendo una variedad de adaptadores de vista.</target>
        </trans-unit>
        <trans-unit id="bce2ca348110e7ef080f1a3a0d8246186d739693" translate="yes" xml:space="preserve">
          <source>The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to &lt;a href=&quot;implicit_cast&quot;&gt;three conversions&lt;/a&gt;).</source>
          <target state="translated">El rango de la secuencia de conversi&amp;oacute;n est&amp;aacute;ndar es el peor de los rangos de las conversiones est&amp;aacute;ndar que tiene (puede haber hasta &lt;a href=&quot;implicit_cast&quot;&gt;tres conversiones&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ebf3fa4c200bf79dc188b73503ec27a644a93938" translate="yes" xml:space="preserve">
          <source>The raw pointer overloads assume ownership of the pointed-to object. Therefore, constructing a &lt;code&gt;shared_ptr&lt;/code&gt; using the raw pointer overload for an object that is already managed by a &lt;code&gt;shared_ptr&lt;/code&gt;, such as by &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; is likely to lead to undefined behavior, even if the object is of a type derived from &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Las sobrecargas de puntero sin formato asumen la propiedad del objeto se&amp;ntilde;alado. Por lo tanto, la construcci&amp;oacute;n de un &lt;code&gt;shared_ptr&lt;/code&gt; utilizando la sobrecarga del puntero sin formato para un objeto que ya est&amp;aacute; administrado por &lt;code&gt;shared_ptr&lt;/code&gt; , como &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; es probable que conduzca a un comportamiento indefinido, incluso si el objeto es de un tipo derivado de &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad324bd2c8bc22b00758a73ea2fd6b6e48382778" translate="yes" xml:space="preserve">
          <source>The reallocation is done by either:</source>
          <target state="translated">La reasignación se hace por cualquiera de los dos:</target>
        </trans-unit>
        <trans-unit id="cb5dae53afd6af85ce084febad2ae76f3864e626" translate="yes" xml:space="preserve">
          <source>The rebind member template alias makes it possible, given a pointer-like type that points to T, to obtain the same pointer-like type that points to U. For example,</source>
          <target state="translated">El alias de la plantilla de miembros de Rebind permite,dado un tipo de puntero que apunta a la T,obtener el mismo tipo de puntero que apunta a la U.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="3a46abffdd1369d6dca8a8856866579f7f37a7e3" translate="yes" xml:space="preserve">
          <source>The recognized byte order marks are:</source>
          <target state="translated">Las marcas de orden byte reconocidas son:</target>
        </trans-unit>
        <trans-unit id="39e0ee2810678b74b9059ddc4c64426403f4f32c" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;iword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;iword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by a previous call to &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">La referencia puede ser invalidada por cualquier operaci&amp;oacute;n en este objeto &lt;code&gt;ios_base&lt;/code&gt; , incluida otra llamada a &lt;code&gt;iword()&lt;/code&gt; , pero los valores almacenados se retienen, de modo que la lectura de &lt;code&gt;iword(index)&lt;/code&gt; con el mismo &amp;iacute;ndice m&amp;aacute;s adelante producir&amp;aacute; el mismo valor (hasta el siguiente llame a &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt; ). El valor se puede usar para cualquier prop&amp;oacute;sito. El &amp;iacute;ndice del elemento debe obtenerse mediante una llamada previa a &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; , de lo contrario, el comportamiento no est&amp;aacute; definido. Los nuevos elementos se inicializan a &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ac5c33641fd17dd4dcc39d735304c205b8e343f" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;pword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;pword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;copyfmt()&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La referencia puede ser invalidada por cualquier operaci&amp;oacute;n en este objeto &lt;code&gt;ios_base&lt;/code&gt; , incluida otra llamada a &lt;code&gt;pword()&lt;/code&gt; , pero los valores almacenados se retienen, de modo que la lectura de &lt;code&gt;pword(index)&lt;/code&gt; con el mismo &amp;iacute;ndice m&amp;aacute;s adelante producir&amp;aacute; el mismo valor (hasta el siguiente llamar a &lt;code&gt;copyfmt()&lt;/code&gt; ). El valor se puede usar para cualquier prop&amp;oacute;sito. El &amp;iacute;ndice del elemento debe ser obtenido por &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; , de lo contrario el comportamiento es indefinido. Los nuevos elementos se inicializan a &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f727f18de8aecc68a97ca4d05e8709c96ae21252" translate="yes" xml:space="preserve">
          <source>The referenced bit.</source>
          <target state="translated">La parte de referencia.</target>
        </trans-unit>
        <trans-unit id="01bad1a5bcb168d5223121e0f4bf36c7d217674b" translate="yes" xml:space="preserve">
          <source>The regex iterators are used to traverse the entire set of regular expression matches found within a sequence.</source>
          <target state="translated">Los iteradores regex se utilizan para atravesar todo el conjunto de coincidencias de expresiones regulares que se encuentran dentro de una secuencia.</target>
        </trans-unit>
        <trans-unit id="743f5a5a38b3f31dca5dec3dbda309eac3fee182" translate="yes" xml:space="preserve">
          <source>The regex library uses this trait to match characters against equivalence classes. For example, the regex &lt;code&gt;[[=a=]]&lt;/code&gt; is equivalent to the character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; is equivalent to &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; (which is true for any &lt;code&gt;c1&lt;/code&gt; from &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; in the U.S. English locale). Note that &lt;code&gt;transform_primary()&lt;/code&gt; takes a character sequence argument because equivalence classes may be multicharacter, such as &lt;code&gt;[[=ch=]]&lt;/code&gt; in Czech or &lt;code&gt;[[=dzs=]]&lt;/code&gt; in Hungarian.</source>
          <target state="translated">La biblioteca de expresiones regulares utiliza este rasgo para unir caracteres con clases de equivalencia. Por ejemplo, la expresi&amp;oacute;n regular &lt;code&gt;[[=a=]]&lt;/code&gt; es equivalente al car&amp;aacute;cter &lt;code&gt;c1&lt;/code&gt; si &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; es equivalente a &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; (que es cierto para cualquier &lt;code&gt;c1&lt;/code&gt; de &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; en los EE. UU. Ingl&amp;eacute;s local). Tenga en cuenta que &lt;code&gt;transform_primary()&lt;/code&gt; toma un argumento de secuencia de caracteres porque las clases de equivalencia pueden tener varios caracteres, como &lt;code&gt;[[=ch=]]&lt;/code&gt; en checo o &lt;code&gt;[[=dzs=]]&lt;/code&gt; en h&amp;uacute;ngaro.</target>
        </trans-unit>
        <trans-unit id="9f22234d3d01dbb3d192f98f1564dcc90f3845ce" translate="yes" xml:space="preserve">
          <source>The regex traits class is used to encapsulate the localizable aspects of a regex.</source>
          <target state="translated">La clase de rasgos regex se utiliza para encapsular los aspectos localizables de un regex.</target>
        </trans-unit>
        <trans-unit id="8e02428e99c6a674a0fa0458c46a3675989e16b2" translate="yes" xml:space="preserve">
          <source>The registered functions will not be called on &lt;a href=&quot;exit&quot;&gt;normal program termination&lt;/a&gt;. If a function need to be called in that case, &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; must be used.</source>
          <target state="translated">Las funciones registradas no ser&amp;aacute;n llamadas en &lt;a href=&quot;exit&quot;&gt;la terminaci&amp;oacute;n normal del programa&lt;/a&gt; . Si se necesita llamar a una funci&amp;oacute;n en ese caso, se debe usar &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f472a11dda174644bf194c3cc7207153d73cf754" translate="yes" xml:space="preserve">
          <source>The regular expressions library provides a class that represents &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expressions&lt;/a&gt;, which are a kind of mini-language used to perform pattern matching within strings. Almost all operations with regexes can be characterized by operating on several of the following objects:</source>
          <target state="translated">La biblioteca de expresiones regulares proporciona una clase que representa &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;expresiones regulares&lt;/a&gt; , que son una especie de mini-lenguaje utilizado para realizar la coincidencia de patrones dentro de las cadenas. Casi todas las operaciones con expresiones regulares pueden caracterizarse operando en varios de los siguientes objetos:</target>
        </trans-unit>
        <trans-unit id="2e11489a7a30fc1b23c96dca40b2ff8e966f4c67" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="translated">La funci&amp;oacute;n relacionada &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;POSPO popen&lt;/a&gt; hace que la salida generada por el &lt;code&gt;command&lt;/code&gt; est&amp;eacute; disponible para la persona que llama.</target>
        </trans-unit>
        <trans-unit id="315f5ac4df7e6df130a13d2b962900690dfeac97" translate="yes" xml:space="preserve">
          <source>The related function &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; appends a newline character to the output, while &lt;code&gt;std::fputs&lt;/code&gt; writes the string unmodified.</source>
          <target state="translated">La funci&amp;oacute;n relacionada &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; agrega un car&amp;aacute;cter de nueva l&amp;iacute;nea a la salida, mientras que &lt;code&gt;std::fputs&lt;/code&gt; escribe la cadena sin modificar.</target>
        </trans-unit>
        <trans-unit id="d291a968b1bde0de4066d9697100b3323d6aed59" translate="yes" xml:space="preserve">
          <source>The removal of the top-level cv-qualifiers does not affect the type of the parameter as it appears within the function:</source>
          <target state="translated">La eliminación de los calificadores cv de nivel superior no afecta al tipo de parámetro tal como aparece dentro de la función:</target>
        </trans-unit>
        <trans-unit id="5f57795c7e42d94ba6cd16bf8ded7489abce05bb" translate="yes" xml:space="preserve">
          <source>The replaceable deallocation functions (1-10) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. These functions are</source>
          <target state="translated">Las funciones de desasignaci&amp;oacute;n reemplazables (1-10) se declaran impl&amp;iacute;citamente en cada unidad de traducci&amp;oacute;n incluso si el encabezado &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; no est&amp;aacute; incluido. Estas funciones son</target>
        </trans-unit>
        <trans-unit id="757b1dc67e0f36307d54e167b8d8bfa8908ff42c" translate="yes" xml:space="preserve">
          <source>The representation of the named collating element as a character string.</source>
          <target state="translated">La representación del elemento de cotejo nombrado como una cadena de caracteres.</target>
        </trans-unit>
        <trans-unit id="b55071f5f9ba9ea7bf92c82884c22a3d16d81678" translate="yes" xml:space="preserve">
          <source>The representation type of &lt;code&gt;C1::duration&lt;/code&gt;.</source>
          <target state="translated">El tipo de representaci&amp;oacute;n de &lt;code&gt;C1::duration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1064d717e4d3fd4142b0aa2898a18bce9888f7d4" translate="yes" xml:space="preserve">
          <source>The requested subspan &lt;code&gt;r&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt;. If &lt;code&gt;Count&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt;; otherwise &lt;code&gt;r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">El subspan solicitado &lt;code&gt;r&lt;/code&gt; , tal que &lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt; . Si &lt;code&gt;Count&lt;/code&gt; es &lt;code&gt;std::dynamic_extent&lt;/code&gt; , &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt; ; de lo contrario, &lt;code&gt;r.size() == Count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe5a8c15412cf1fce3c28473df37a2f3d1062165" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements.</source>
          <target state="translated">Los requisitos que se imponen a los elementos dependen de las operaciones reales realizadas en el contenedor. Generalmente, se requiere que el tipo de elemento sea un tipo completo y cumpla con los requisitos de &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt; , pero muchas funciones miembro imponen requisitos m&amp;aacute;s estrictos.</target>
        </trans-unit>
        <trans-unit id="f623316ac29c804d31fa0890dce0da472d8e6d58" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">Los requisitos que se imponen a los elementos dependen de las operaciones reales realizadas en el contenedor. Generalmente, se requiere que el tipo de elemento cumpla con los requisitos de &lt;a href=&quot;../named_req/eraseable&quot;&gt;Borrable&lt;/a&gt; , pero muchas funciones miembro imponen requisitos m&amp;aacute;s estrictos. Este contenedor (pero no sus miembros) puede instanciarse con un tipo de elemento incompleto si el asignador cumple los &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;requisitos de integridad&lt;/a&gt; del asignador .</target>
        </trans-unit>
        <trans-unit id="7e9510a237cd6950e335a276b93cd34d804cbc1a" translate="yes" xml:space="preserve">
          <source>The result is</source>
          <target state="translated">El resultado es</target>
        </trans-unit>
        <trans-unit id="c3b6b8e653050978d1c05509c50d363265c5437e" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;false&lt;/code&gt; if the expression contains at least one of the following potentially evaluated constructs:</source>
          <target state="translated">El resultado es &lt;code&gt;false&lt;/code&gt; si la expresi&amp;oacute;n contiene al menos uno de los siguientes constructos potencialmente evaluados:</target>
        </trans-unit>
        <trans-unit id="d1a4aaa48d46c71750bcb89a022288521d191ab7" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if the set of &lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;potential exceptions&lt;/i&gt;&lt;/a&gt; of the expression is empty, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">El resultado es &lt;code&gt;true&lt;/code&gt; si el conjunto de &lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;posibles excepciones&lt;/i&gt;&lt;/a&gt; de la expresi&amp;oacute;n est&amp;aacute; vac&amp;iacute;o, y &lt;code&gt;false&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="be94375a32ef05e8f88fd30d56ae6e5233b9d27e" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">El resultado es un &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; especializaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; , de manera que dado &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; y &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (calculado sin desbordamiento aritm&amp;eacute;tico), &lt;code&gt;U&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2524aa66759b404de95e3dd437f92ac60fcc7942" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">El resultado es un &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; especializaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; , de manera que dado &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; y &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (calculado sin desbordamiento aritm&amp;eacute;tico), &lt;code&gt;U&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acb3b2cb8d2a5ff6feda727827cb87392d9546ad" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">El resultado es un &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; especializaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; , de manera que dado &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; y &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; (computado sin desbordamiento aritm&amp;eacute;tico), &lt;code&gt;U&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f389c36e6b41ab6b3fdb4d5ce8f967c0c0ccebe" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">El resultado es un &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; especializaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; , de manera que dado &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; y &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computado sin desbordamiento aritm&amp;eacute;tico), &lt;code&gt;U&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e68dbec571d137df08d9f883c38ccb0b5e7b5985" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="translated">El resultado es un valor de &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2c4bb4518db49d6f285ab22da7870886f0081c4" translate="yes" xml:space="preserve">
          <source>The result is ready</source>
          <target state="translated">El resultado está listo</target>
        </trans-unit>
        <trans-unit id="580dbf951c94723d3af7b9d08b23514681e24e3d" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the enum's underlying type to the destination type.</source>
          <target state="translated">El resultado es el mismo que la &lt;a href=&quot;implicit_cast&quot;&gt;conversi&amp;oacute;n impl&amp;iacute;cita&lt;/a&gt; del tipo subyacente de la enumeraci&amp;oacute;n al tipo de destino.</target>
        </trans-unit>
        <trans-unit id="cbbaf37dfe4267e58c22583ee6fab6ad33d0d8fd" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration, and then to the enumeration type.</source>
          <target state="translated">El resultado es lo mismo que &lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;convertir&lt;/a&gt; el valor original primero al tipo subyacente de la enumeraci&amp;oacute;n, y luego al tipo de enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a957f8ea1f391e7935ddb74dad2e1448951ecef7" translate="yes" xml:space="preserve">
          <source>The result may have little or no significance if the magnitude of &lt;code&gt;arg&lt;/code&gt; is large.</source>
          <target state="translated">El resultado puede tener poca o ninguna importancia si la magnitud de &lt;code&gt;arg&lt;/code&gt; es grande.</target>
        </trans-unit>
        <trans-unit id="870fcd3df093829aaa26fd2db3dbce5ac0e9700e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;!arg&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;!arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e1af8324720028e132b94fe61c4514f56e4941" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;-arg&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;-arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a411985e21ab920e38a5852e204b8af0e20a27e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ec200a207a639219d15d9ccfe372f86eab6036" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e64ce1e5aed1c40811afecb3dc7fbb9b0c9b98a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee0825f237fb1718d9a9117588e0d38939c42fd3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; is implementation-defined.</source>
          <target state="translated">El resultado de &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; est&amp;aacute; definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="acf2c3f21b47e9f1630796369e072a4335640eda" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs != rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs != rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e6e472de88efa439e4f8ac01ef503fb42158a44" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs % rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs % rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4c5e47c305ac62f9aa59e69771dddcae5c999a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e95d02148bc8a4f7ae12814dcba7c7fe81fbedaf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa6dd6207a762f8224d24ca1b87c1fcc621652fa" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f4b083947ef6aa836be0e4780f07e0aadcf1e43" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8f2b531e796e45b234ba714ef92019621ac8f1b" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3e99c51790273d3fd02297fcb57fd200d05fec1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e05f6b812268f1065a685db8b9a51d0ed85af871" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs * rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs * rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa8335ddae097460592407def0f6f7f6531b4bde" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs + rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs + rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="632ae131fa96ce384c426b305a35eb2730ac7e17" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs - rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs - rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="914a5eae959d8077c3946fcd30325aab12d6c2f1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs / rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs / rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1542bda1bc0df08cd4e2da32ce9c1c4158ea1b29" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs ^ rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs ^ rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f829b25d22cfb56ef72ca8c031ffcc768468e0a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs | rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs | rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c15c8b1e6d71bff19e0100cd1bb43d0aaf22d25a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs || rhs&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;lhs || rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a2cfe39bb4bca238a75c100d57a8e16e49b74ab" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;operator*&lt;/code&gt; or &lt;code&gt;operator-&amp;gt;&lt;/code&gt; on the end iterator is undefined behavior.</source>
          <target state="translated">El resultado del &lt;code&gt;operator*&lt;/code&gt; u &lt;code&gt;operator-&amp;gt;&lt;/code&gt; en el iterador final es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="006f10ce7b3c5cdf0abdf83cfb46f3ea491450f3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;sizeof&lt;/code&gt; is always nonzero, even if applied to an empty class type.</source>
          <target state="translated">El resultado de &lt;code&gt;sizeof&lt;/code&gt; siempre es distinto de cero, incluso si se aplica a un tipo de clase vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="cff04ad9446c1f408f431157236a6d0631af546f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;~arg&lt;/code&gt;.</source>
          <target state="translated">El resultado de &lt;code&gt;~arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9685a2aebbafc6d384174b50e75064f891cc1ef" translate="yes" xml:space="preserve">
          <source>The result of attempting to determine the size of a directory (as well as any other file that is not a regular file or a symlink) is implementation-defined.</source>
          <target state="translated">El resultado de intentar determinar el tamaño de un directorio (así como de cualquier otro archivo que no sea un archivo regular o un enlace simbólico)está definido por la aplicación.</target>
        </trans-unit>
        <trans-unit id="247e8d93cf388f43a2c1c6cc6c4100ee34ada80f" translate="yes" xml:space="preserve">
          <source>The result of calling most member functions of the match_results object that is not</source>
          <target state="translated">El resultado de llamar a la mayoría de las funciones miembros del objeto match_results que no es</target>
        </trans-unit>
        <trans-unit id="21e3ce4be4c110e9cc76bfe73bc7a78e82910174" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to members (after conversions) is defined as follows:</source>
          <target state="translated">El resultado de la comparación de dos punteros a los miembros (después de las conversiones)se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="32f37ca48793604634e4bf49c6103814193272fa" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to objects (after conversions) is defined as follows:</source>
          <target state="translated">El resultado de la comparación de dos punteros a los objetos (después de las conversiones)se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="0290b3221f34a8546049c1fe37f0a1d16a5a5bef" translate="yes" xml:space="preserve">
          <source>The result of converting a negative number string into an unsigned integer was specified to produce zero until C++17, although some implementations followed the protocol of &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; which negates in the target type, giving &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&quot;-1&quot;&lt;/code&gt;, and so produce the largest value of the target type instead. As of C++17, strictly following &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; is the correct behavior.</source>
          <target state="translated">El resultado de convertir una cadena de n&amp;uacute;mero negativa en un entero sin signo se especific&amp;oacute; para producir cero hasta C ++ 17, aunque algunas implementaciones siguieron el protocolo de &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; que se niega en el tipo de destino, dando &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&quot;-1&quot;&lt;/code&gt; , y as&amp;iacute; que produzca el mayor valor del tipo de destino en su lugar. A partir de C ++ 17, seguir estrictamente &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; es el comportamiento correcto.</target>
        </trans-unit>
        <trans-unit id="dd0729a11dfb5de4b72c38a2205cbf06dfb22a46" translate="yes" xml:space="preserve">
          <source>The result of equality comparison of two pointers (after conversions) is defined as follows:</source>
          <target state="translated">El resultado de la comparación de igualdad de dos punteros (después de las conversiones)se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="47a73f53b39aa715441c99e5f455152b99e4705b" translate="yes" xml:space="preserve">
          <source>The result of operator~ is the bitwise NOT (one's complement) value of the argument (after promotion). The result of operator&amp;amp; is the bitwise AND value of the operands (after usual arithmetic conversions). The result of operator| is the bitwise OR value of the operands (after usual arithmetic conversions). The result of operator^ is the bitwise XOR value of the operands (after usual arithmetic conversions).</source>
          <target state="translated">El resultado del operador ~ es el valor NOT a nivel de bit (complemento de uno) del argumento (despu&amp;eacute;s de la promoci&amp;oacute;n). El resultado del operador &amp;amp; es el valor AND bit a bit de los operandos (despu&amp;eacute;s de las conversiones aritm&amp;eacute;ticas habituales). El resultado del operador | es el valor OR bit a bit de los operandos (despu&amp;eacute;s de las conversiones aritm&amp;eacute;ticas habituales). El resultado del operador ^ es el valor XOR bit a bit de los operandos (despu&amp;eacute;s de las conversiones aritm&amp;eacute;ticas habituales).</target>
        </trans-unit>
        <trans-unit id="e0eb608d51cf5832fadd72c5babd7a6e03e98a43" translate="yes" xml:space="preserve">
          <source>The result of path concatenation.</source>
          <target state="translated">El resultado de la concatenación de caminos.</target>
        </trans-unit>
        <trans-unit id="4f62a6ed94a5ad3247f5fc515a6a3e14d480ed26" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. That duration unit represents the length of the average Gregorian month, and the resulting duration bears no relationship to the number of days in the particular months represented by the operands. For example, &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; is not the number of seconds in March (&lt;code&gt;2678400s&lt;/code&gt;), but &lt;code&gt;2629746s&lt;/code&gt; (30.436875 days).</source>
          <target state="translated">El resultado de restar valores de dos &lt;code&gt;month&lt;/code&gt; es una duraci&amp;oacute;n de tipo &lt;code&gt;std::chrono::months&lt;/code&gt; . Esa unidad de duraci&amp;oacute;n representa la duraci&amp;oacute;n del mes gregoriano promedio, y la duraci&amp;oacute;n resultante no guarda relaci&amp;oacute;n con el n&amp;uacute;mero de d&amp;iacute;as en los meses particulares representados por los operandos. Por ejemplo, &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; no es la cantidad de segundos en marzo ( &lt;code&gt;2678400s&lt;/code&gt; ), sino &lt;code&gt;2629746s&lt;/code&gt; (30.436875 d&amp;iacute;as).</target>
        </trans-unit>
        <trans-unit id="17172fd81702e28b82e8d13798f7b61c7c8f7b83" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::years&lt;/code&gt;. This duration unit represents the length of the average Gregorian year, and the resulting duration bears no relationship to the number of days in the particular years represented by the operands. For example, the result of &lt;code&gt;2018y - 2017y&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt;, which represents 365.2425 days, not 365 days.</source>
          <target state="translated">El resultado de restar valores de dos &lt;code&gt;year&lt;/code&gt; es una duraci&amp;oacute;n de tipo &lt;code&gt;std::chrono::years&lt;/code&gt; . Esta unidad de duraci&amp;oacute;n representa la duraci&amp;oacute;n del a&amp;ntilde;o gregoriano promedio, y la duraci&amp;oacute;n resultante no guarda relaci&amp;oacute;n con el n&amp;uacute;mero de d&amp;iacute;as en los a&amp;ntilde;os particulares representados por los operandos. Por ejemplo, el resultado de &lt;code&gt;2018y - 2017y&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt; , que representa 365.2425 d&amp;iacute;as, no 365 d&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="36c4afa551c41832fffe70e348da9af50d440abe" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year_month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. This duration unit represents the length of the average Gregorian month (30.436875 days), and the resulting duration bears no relationship to the actual number of days in the time period at issue. For example, the result of &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt;, even though February 2017 only contains 28 days.</source>
          <target state="translated">El resultado de restar dos valores &lt;code&gt;year_month&lt;/code&gt; es una duraci&amp;oacute;n de tipo &lt;code&gt;std::chrono::months&lt;/code&gt; . Esta unidad de duraci&amp;oacute;n representa la duraci&amp;oacute;n del mes gregoriano promedio (30.436875 d&amp;iacute;as), y la duraci&amp;oacute;n resultante no guarda relaci&amp;oacute;n con el n&amp;uacute;mero real de d&amp;iacute;as en el per&amp;iacute;odo de tiempo en cuesti&amp;oacute;n. Por ejemplo, el resultado de &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt; , aunque febrero de 2017 solo contiene 28 d&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="a3315b545d55c361d494aaf334e4af2659a2548d" translate="yes" xml:space="preserve">
          <source>The result of the comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*obj&lt;/code&gt; was equal to &lt;code&gt;*expected&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">El resultado de la comparaci&amp;oacute;n: &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;*obj&lt;/code&gt; era igual a &lt;code&gt;*expected&lt;/code&gt; , de lo contrario , &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e25c0d3525dfeb8bfa6ff74fcf703d161b32cfb4" translate="yes" xml:space="preserve">
          <source>The result of the conversion as described above:</source>
          <target state="translated">El resultado de la conversión como se ha descrito anteriormente:</target>
        </trans-unit>
        <trans-unit id="3870571eecc090d22dc21a8b93d45f1df9a1dda1" translate="yes" xml:space="preserve">
          <source>The result of the conversion, determined as described above.</source>
          <target state="translated">El resultado de la conversión,determinado como se ha descrito anteriormente.</target>
        </trans-unit>
        <trans-unit id="5cfae012b116826024fbc12ba5aac5a29cc79ff0" translate="yes" xml:space="preserve">
          <source>The result of the expression always has type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">El resultado de la expresi&amp;oacute;n siempre tiene tipo &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d11a68b7fc68b552ec64c618e13fe680bd75b63e" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">El tipo de resultado generado por el generador. El efecto no est&amp;aacute; definido si no se trata de &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; o &lt;code&gt;long double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e80eecc0596c35730188bd9f4d1c551f3febc94" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">El tipo de resultado generado por el generador. El efecto no est&amp;aacute; definido si no se trata de &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; o &lt;code&gt;unsigned long long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5521797ee22c876e97965af0d7522808846e3d59" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;T&lt;/code&gt; (1-3) or &lt;code&gt;bool&lt;/code&gt; (4).</source>
          <target state="translated">El valor del resultado se puede convertir inequ&amp;iacute;vocamente a &lt;code&gt;T&lt;/code&gt; (1-3) o &lt;code&gt;bool&lt;/code&gt; (4).</target>
        </trans-unit>
        <trans-unit id="f6bb786c46da806f276663a0a370a0140bec8af4" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">El valor del resultado puede convertirse inequ&amp;iacute;vocamente en &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43655266ec179e649b00784deeb0b1a3c97d236d" translate="yes" xml:space="preserve">
          <source>The resultant offset converted to &lt;code&gt;pos_type&lt;/code&gt; on success or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">El desplazamiento resultante se convierte en &lt;code&gt;pos_type&lt;/code&gt; en caso de &amp;eacute;xito o &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="ef23966d370102deb412213da03cdcdb6c680d1f" translate="yes" xml:space="preserve">
          <source>The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">El rango resultante no puede superponerse con ninguno de los rangos de entrada.</target>
        </trans-unit>
        <trans-unit id="29d5035de2621e71a90038d6802a888a677db3c5" translate="yes" xml:space="preserve">
          <source>The resulting range is also sorted. Equivalent elements are treated individually, that is, if some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; times. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">El rango resultante tambi&amp;eacute;n se ordena. Los elementos equivalentes son tratados de forma individual, es decir, si un elemento se encuentra &lt;code&gt;m&lt;/code&gt; veces en &lt;code&gt;[first1, last1)&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; veces en &lt;code&gt;[first2, last2)&lt;/code&gt; , que se copiar&amp;aacute; en &lt;code&gt;d_first&lt;/code&gt; exactamente &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; veces. El rango resultante no puede solaparse con ninguno de los rangos de entrada.</target>
        </trans-unit>
        <trans-unit id="aaddb0a6756a877f4864ff06a8fc5e72ffd2f6e1" translate="yes" xml:space="preserve">
          <source>The resulting string contains &lt;code&gt;N&lt;/code&gt; characters with the first character corresponds to the last (&lt;code&gt;N-1&lt;/code&gt;th) bit and the last character corresponding to the first bit.</source>
          <target state="translated">La cadena resultante contiene &lt;code&gt;N&lt;/code&gt; caracteres con el primer car&amp;aacute;cter corresponde al &amp;uacute;ltimo bit ( &lt;code&gt;N-1&lt;/code&gt; &amp;ordm; ) y el &amp;uacute;ltimo car&amp;aacute;cter correspondiente al primer bit.</target>
        </trans-unit>
        <trans-unit id="b17d4cd7b0868b24196c899cf5191cb1faa7ed25" translate="yes" xml:space="preserve">
          <source>The resulting valarray with circularly shifted elements.</source>
          <target state="translated">El valarray resultante con elementos desplazados circularmente.</target>
        </trans-unit>
        <trans-unit id="7458cef4d81e04aca531157faaf437f90b8b5f76" translate="yes" xml:space="preserve">
          <source>The resulting valarray with shifted elements.</source>
          <target state="translated">El valarray resultante con elementos desplazados.</target>
        </trans-unit>
        <trans-unit id="83ad9cb498edc1aa4891b4efbe63cabce32603fe" translate="yes" xml:space="preserve">
          <source>The resulting valarray with values acquired by applying function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">El valarray resultante con valores adquiridos aplicando la funci&amp;oacute;n &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e5c65b16e68930d61a611b38a71296f2506a4cf" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;).</source>
          <target state="translated">El valor resultante (es decir, el resultado de aplicar el operador binario correspondiente al valor que precede inmediatamente a los efectos de la funci&amp;oacute;n miembro correspondiente en el &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;orden&lt;/a&gt; de modificaci&amp;oacute;n de &lt;code&gt;*this&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e814d10c5d370f3f42c2fca47efc512b44b14a3c" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function).</source>
          <target state="translated">El valor resultante (es decir,el resultado de aplicar el operador binario correspondiente al valor inmediatamente anterior a los efectos de la función miembro correspondiente).</target>
        </trans-unit>
        <trans-unit id="3389100e45b720cf6eb81e6827f7706cb90c9259" translate="yes" xml:space="preserve">
          <source>The return from the</source>
          <target state="translated">El regreso de la</target>
        </trans-unit>
        <trans-unit id="53209406292002d9313d7e4939097156f31cc15e" translate="yes" xml:space="preserve">
          <source>The return statements in a discarded statement do not participate in function return type deduction:</source>
          <target state="translated">Las declaraciones de retorno en una declaración descartada no participan en la deducción del tipo de retorno de la función:</target>
        </trans-unit>
        <trans-unit id="3ed22644873dd55c750986fea93019dbd3388a1d" translate="yes" xml:space="preserve">
          <source>The return type does not add more than two levels of template nesting over the most deeply-nested argument type.</source>
          <target state="translated">El tipo de retorno no añade más de dos niveles de anidación de plantillas sobre el tipo de argumento más profundamente anidado.</target>
        </trans-unit>
        <trans-unit id="7613f3aef88eece4db1f4660060fab1d18285727" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;void*&lt;/code&gt; (rather than, e.g., &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt;) to support conversion to an arbitrary pointer type &lt;code&gt;U*&lt;/code&gt; by &lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno es &lt;code&gt;void*&lt;/code&gt; (en lugar de, por ejemplo, &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt; ) para admitir la conversi&amp;oacute;n a un puntero arbitrario tipo &lt;code&gt;U*&lt;/code&gt; por &lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d5d71418aa972f29b239eb90d69468e90bb0941" translate="yes" xml:space="preserve">
          <source>The return type is the type of the left operand after integral promotions.</source>
          <target state="translated">El tipo de retorno es el tipo de la operando izquierda después de las promociones integrales.</target>
        </trans-unit>
        <trans-unit id="4fa9717f5967413803e02aa6bb2883c955d4365a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../numeric/valarray/begin2&quot;&gt;&lt;code&gt;begin(valarray)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../numeric/valarray/end2&quot;&gt;&lt;code&gt;end(valarray)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">El tipo de retorno de &lt;a href=&quot;../numeric/valarray/begin2&quot;&gt; &lt;code&gt;begin(valarray)&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../numeric/valarray/end2&quot;&gt; &lt;code&gt;end(valarray)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b467b24eb3e95658db04cc2efccee281ce62fa6" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a function. Otherwise, not defined</source>
          <target state="translated">El tipo de retorno de &lt;code&gt;T&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; es una funci&amp;oacute;n. De lo contrario, no est&amp;aacute; definido</target>
        </trans-unit>
        <trans-unit id="fc619118262950fb869b5d544147bd07c7f92619" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::begin&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno de &lt;code&gt;filter_view::begin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a173a812528e6c04c2d8704d2f8d1773cc20a31" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::end&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno de &lt;code&gt;filter_view::end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8cc94f3fe57edcbe4e00cf3aaac26990fe1598" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::begin&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno de &lt;code&gt;iota_view::begin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7eef554336055de8435461fe71844804d344403e" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::end&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno de &lt;code&gt;iota_view::end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d16c75ab67ddd9e46691a2a894ba5baeac787d8" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and one object per each of &lt;code&gt;args...&lt;/code&gt;, of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt;, similarly constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno de &lt;code&gt;std::bind&lt;/code&gt; contiene un objeto miembro de tipo &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; construido a partir de &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; , y un objeto por cada uno de los &lt;code&gt;args...&lt;/code&gt; , de tipo &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt; , construido de manera similar a partir de &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fde0844a0606e7893f2ea00fd18105a16696460c" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise. The type defines the following members:</source>
          <target state="translated">El tipo de retorno de &lt;code&gt;std::bind&lt;/code&gt; es &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; si todos sus objetos miembros (especificados anteriormente) son CopyConstructible, y es &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible de lo&lt;/a&gt; contrario. El tipo define los siguientes miembros:</target>
        </trans-unit>
        <trans-unit id="6c0953e38415f15fb34763f7446d0d031ca5c65a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind_front&lt;/code&gt; behaves as if its copy/move constructors perform a memberwise copy/move. It is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise.</source>
          <target state="translated">El tipo de retorno de &lt;code&gt;std::bind_front&lt;/code&gt; comporta como si sus constructores de copia / movimiento realizaran una copia / movimiento a nivel de miembro. Es &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; si todos sus objetos miembros (especificados anteriormente) son CopyConstructible, y es &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible de lo&lt;/a&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="f29ace211ba147bca17300e0f5b8c1b51fd281da" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::not_fn&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno de &lt;code&gt;std::not_fn&lt;/code&gt; contiene un objeto miembro de tipo &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="313e4bd0b86dc792bb66113e7c07635c9c275b3f" translate="yes" xml:space="preserve">
          <source>The return type of a conditional operator is also accessible as the binary type trait &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno de un operador condicional tambi&amp;eacute;n es accesible como el rasgo de tipo binario &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76f32cdf7dc810987e937f22df27363914ee508e" translate="yes" xml:space="preserve">
          <source>The return type of a function call expression is the return type of the chosen function, decided using static binding (ignoring the &lt;code&gt;virtual&lt;/code&gt; keyword), even if the overriding function that's actually called returns a different type. This allows the overriding functions to return pointers or references to classes that are derived from the return type returned by the base function, i.e. C++ supports &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant return types&lt;/a&gt;. If &lt;code&gt;E&lt;/code&gt; specifies a destructor, the return type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">El tipo de retorno de una expresi&amp;oacute;n de llamada de funci&amp;oacute;n es el tipo de retorno de la funci&amp;oacute;n elegida, decidida mediante el enlace est&amp;aacute;tico (ignorando la palabra clave &lt;code&gt;virtual&lt;/code&gt; ), incluso si la funci&amp;oacute;n de anulaci&amp;oacute;n que en realidad se llama devuelve un tipo diferente. Esto permite que las funciones primarias devuelvan punteros o referencias a clases que se derivan del tipo de retorno devuelto por la funci&amp;oacute;n base, es decir, C ++ admite &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;tipos de retorno covariantes&lt;/a&gt; . Si &lt;code&gt;E&lt;/code&gt; especifica un destructor, el tipo de retorno es &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6bd94bee25a2724e9aec02300daa9aa8d7ac730" translate="yes" xml:space="preserve">
          <source>The return type of a function cannot be a function type or an array type (but can be a pointer or reference to those).</source>
          <target state="translated">El tipo de retorno de una función no puede ser un tipo de función o un tipo de matriz (sino que puede ser un puntero o una referencia a ellos).</target>
        </trans-unit>
        <trans-unit id="a43d728e1df955f1a8f98c6da37b2ab9a5744ca1" translate="yes" xml:space="preserve">
          <source>The return value may differ significantly from what &lt;code&gt;std::cout&lt;/code&gt; prints by default, see the example.</source>
          <target state="translated">El valor de retorno puede diferir significativamente de lo que &lt;code&gt;std::cout&lt;/code&gt; imprime por defecto, vea el ejemplo.</target>
        </trans-unit>
        <trans-unit id="39db23f7094ebdbb293d88cb43a6cdf8f30e157e" translate="yes" xml:space="preserve">
          <source>The return value of the called function.</source>
          <target state="translated">El valor de retorno de la función llamada.</target>
        </trans-unit>
        <trans-unit id="181f5da030f77aa6d4d1c3eb608e9f1004e2dfd0" translate="yes" xml:space="preserve">
          <source>The return value of the function call operation applied to an object of a type satisfying Compare, when &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;, yields &lt;code&gt;true&lt;/code&gt; if the first argument of the call appears before the second in the</source>
          <target state="translated">El valor de retorno de la operaci&amp;oacute;n de llamada de funci&amp;oacute;n aplicada a un objeto de un tipo que satisface Comparar, cuando se &lt;a href=&quot;../language/implicit_cast&quot;&gt;convierte contextualmente&lt;/a&gt; a &lt;code&gt;bool&lt;/code&gt; , produce &lt;code&gt;true&lt;/code&gt; si el primer argumento de la llamada aparece antes del segundo en el</target>
        </trans-unit>
        <trans-unit id="f9d8bf866400df7265b9950e52989553174c0d39" translate="yes" xml:space="preserve">
          <source>The returned array is not required to be null-terminated.</source>
          <target state="translated">No es necesario que la matriz devuelta sea anulada.</target>
        </trans-unit>
        <trans-unit id="ee570e1ba2b43205f25df937e0cf18a3c9775dfe" translate="yes" xml:space="preserve">
          <source>The returned array is null-terminated, that is, &lt;code&gt;data()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; perform the same function.</source>
          <target state="translated">La matriz devuelta est&amp;aacute; terminada en nulo, es decir, &lt;code&gt;data()&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; realizan la misma funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="15def1750d934cba236118e97433bceee9bb7467" translate="yes" xml:space="preserve">
          <source>The returned object (call wrapper) has the following properties:</source>
          <target state="translated">El objeto devuelto (envoltorio de llamada)tiene las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="be9a9d8ae5b68cc7ac697a304429ef14785fc160" translate="yes" xml:space="preserve">
          <source>The returned object behaves as if it holds a member object &lt;code&gt;fd&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and an &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; object &lt;code&gt;tup&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; (this unwraps any &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;s), except that the returned object's assignment behavior is unspecified and the names are for exposition only.</source>
          <target state="translated">El objeto devuelto se comporta como si tuviera un objeto miembro &lt;code&gt;fd&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; construido a partir de &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; , y un objeto &lt;code&gt;tup&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; construido con &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; ( &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Args&amp;gt; (args) ...) (esto desenvuelve cualquier &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; s), excepto que el comportamiento de asignaci&amp;oacute;n del objeto devuelto no est&amp;aacute; especificado y los nombres son solo para exposici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0b9ca1ed6de835f3a54269685f7c58a1fccb4f90" translate="yes" xml:space="preserve">
          <source>The returned pointer may outlive the last &lt;code&gt;shared_ptr&lt;/code&gt; if, for example, &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;s remain and the implementation doesn't destroy the deleter until the entire control block is destroyed.</source>
          <target state="translated">El puntero devuelto puede sobrevivir al &amp;uacute;ltimo &lt;code&gt;shared_ptr&lt;/code&gt; si, por ejemplo, &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; s permanece y la implementaci&amp;oacute;n no destruye el eliminador hasta que se destruya todo el bloque de control.</target>
        </trans-unit>
        <trans-unit id="db84c45c9a8b4735697eb1edd0bf4e4888aff852" translate="yes" xml:space="preserve">
          <source>The returned range is defined by two iterators, one pointing to the first element that is</source>
          <target state="translated">El rango de retorno está definido por dos iteradores,uno apuntando al primer elemento que es</target>
        </trans-unit>
        <trans-unit id="fe922ac7f6db254043abd336f6ccd992ca241559" translate="yes" xml:space="preserve">
          <source>The returned string is constructed as if by &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt;, which implies that the returned string's allocator will be default-constructed &amp;mdash; the new allocator will</source>
          <target state="translated">La cadena devuelta se construye como si fuera &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt; , lo que implica que el asignador de la cadena devuelta se construir&amp;aacute; por defecto; el nuevo asignador</target>
        </trans-unit>
        <trans-unit id="be7ba042cf486f9205da2c739695a1dd6890e1f2" translate="yes" xml:space="preserve">
          <source>The returned string must not be modified by the program, but may be overwritten by a subsequent call to the &lt;code&gt;strerror&lt;/code&gt; function. &lt;code&gt;strerror&lt;/code&gt; is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</source>
          <target state="translated">La cadena devuelta no debe ser modificada por el programa, pero puede sobrescribirse mediante una llamada posterior a la funci&amp;oacute;n &lt;code&gt;strerror&lt;/code&gt; . &lt;code&gt;strerror&lt;/code&gt; se requiere que strerror sea seguro para subprocesos. Las implementaciones pueden devolver diferentes punteros a literales de cadena de solo lectura est&amp;aacute;tica o pueden devolver el mismo puntero una y otra vez, apuntando a un b&amp;uacute;fer est&amp;aacute;tico en el que strerror coloca la cadena.</target>
        </trans-unit>
        <trans-unit id="6d5cdc0268f97ea1271d25f2faca49793842f74b" translate="yes" xml:space="preserve">
          <source>The returned value has the same sign as &lt;code&gt;x&lt;/code&gt; and is less than &lt;code&gt;y&lt;/code&gt; in magnitude.</source>
          <target state="translated">El valor devuelto tiene el mismo signo que &lt;code&gt;x&lt;/code&gt; y es menor que &lt;code&gt;y&lt;/code&gt; en magnitud.</target>
        </trans-unit>
        <trans-unit id="d9cdb2a3429ed04aaceb9e604669e39a56f8c661" translate="yes" xml:space="preserve">
          <source>The returned value is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and independent of the current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt;.</source>
          <target state="translated">El valor devuelto es exacto ( &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; nunca se eleva) e independiente del &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo&lt;/a&gt; actual .</target>
        </trans-unit>
        <trans-unit id="724b8307d3008dac328f6b273599dff3480427e3" translate="yes" xml:space="preserve">
          <source>The returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">El valor devuelto es exacto, se ignora el &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo actual&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f67fd770b1a87fd05c53e4a98601aa49812e9bb3" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: two objects of &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type with different object representations may represent the same value. For example, multiple floating-point bit patterns represent the same special value &lt;a href=&quot;../numeric/math/nan&quot;&gt;NaN&lt;/a&gt;. More commonly, some bits of the object representation may not participate in the value representation at all; such bits may be padding introduced to satisfy &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirements&lt;/a&gt;, &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; sizes, etc.</source>
          <target state="translated">Lo contrario no es necesariamente cierto: dos objetos de tipo &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; con diferentes representaciones de objetos pueden representar el mismo valor. Por ejemplo, m&amp;uacute;ltiples patrones de bits de coma flotante representan el mismo valor especial &lt;a href=&quot;../numeric/math/nan&quot;&gt;NaN&lt;/a&gt; . M&amp;aacute;s com&amp;uacute;nmente, algunos bits de la representaci&amp;oacute;n del objeto pueden no participar en la representaci&amp;oacute;n del valor; dichos bits pueden ser rellenados para satisfacer los &lt;a href=&quot;objects#Alignment&quot;&gt;requisitos de alineaci&amp;oacute;n&lt;/a&gt; , tama&amp;ntilde;os de &lt;a href=&quot;bit_field&quot;&gt;campo de bits&lt;/a&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="4612adf8349954cddb8de34f362396a471ea78cb" translate="yes" xml:space="preserve">
          <source>The root directory of the path.</source>
          <target state="translated">El directorio raíz de la ruta.</target>
        </trans-unit>
        <trans-unit id="48c9793d32d94f49061760abdfca8adc649ed9d7" translate="yes" xml:space="preserve">
          <source>The root name of the path.</source>
          <target state="translated">El nombre de la raíz del camino.</target>
        </trans-unit>
        <trans-unit id="6a021f552f47982e6c4bf64045a925f56bdd2012" translate="yes" xml:space="preserve">
          <source>The root path of the path.</source>
          <target state="translated">El camino de la raíz del camino.</target>
        </trans-unit>
        <trans-unit id="744a04bfacb0b83210251e4e038c93877d0b3385" translate="yes" xml:space="preserve">
          <source>The rounding mode can be changed with &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;FLT_ROUNDS&lt;/code&gt; reflects that change.</source>
          <target state="translated">El modo de redondeo se puede cambiar con &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;FLT_ROUNDS&lt;/code&gt; refleja ese cambio.</target>
        </trans-unit>
        <trans-unit id="cfa7f1285b2f2a30572b8c02c0ae8fcae8230942" translate="yes" xml:space="preserve">
          <source>The rule about &quot;more efficient implementations&quot; permits bulk I/O without intermediate buffering: that's how &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; simply passes the pointer to the POSIX &lt;code&gt;read()&lt;/code&gt; system call in some implementations of iostreams.</source>
          <target state="translated">La regla sobre &quot;implementaciones m&amp;aacute;s eficientes&quot; permite E / S masivas sin almacenamiento intermedio: as&amp;iacute; es como &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; simplemente pasa el puntero a la llamada al sistema POSIX &lt;code&gt;read()&lt;/code&gt; en algunas implementaciones de iostreams.</target>
        </trans-unit>
        <trans-unit id="f0e4bed8bfc25aa394d951bf5cd88212770eda2b" translate="yes" xml:space="preserve">
          <source>The rule of three/five/zero</source>
          <target state="translated">La regla de tres/cinco/cero</target>
        </trans-unit>
        <trans-unit id="d764d84251b9e1e79eaf8ddf3fa38a07d394b2ff" translate="yes" xml:space="preserve">
          <source>The safe bool problem</source>
          <target state="translated">El problema del bool seguro</target>
        </trans-unit>
        <trans-unit id="f2d334ca41df29ef25e36114b826d7adfb1af5ef" translate="yes" xml:space="preserve">
          <source>The same applies to the constructors of the next class in the I/O hierarchy, &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt;. Further-derived classes (&lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;) are always constructed with a concrete streambuffer object and call &lt;a href=&quot;../basic_ios/init&quot;&gt;&lt;code&gt;basic_ios::init()&lt;/code&gt;&lt;/a&gt;, possibly more than once, to complete initialization of their virtual base.</source>
          <target state="translated">Lo mismo se aplica a los constructores de la pr&amp;oacute;xima clase en la jerarqu&amp;iacute;a de E / S, &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; . Las clases derivadas ( &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; ) siempre se construyen con un objeto streambuffer concreto y llaman a &lt;a href=&quot;../basic_ios/init&quot;&gt; &lt;code&gt;basic_ios::init()&lt;/code&gt; &lt;/a&gt; , posiblemente m&amp;aacute;s de una vez, para completar la inicializaci&amp;oacute;n de su base virtual.</target>
        </trans-unit>
        <trans-unit id="49089319d0e011162dc486f0fa5c79c193f99bb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;S(il.begin(), il.end())&lt;/code&gt;</source>
          <target state="translated">Lo mismo que &lt;code&gt;S(il.begin(), il.end())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1208e3c0bd83fd14a6cdf867c21125c8a325392a" translate="yes" xml:space="preserve">
          <source>The same function may be registered more than once.</source>
          <target state="translated">La misma función puede registrarse más de una vez.</target>
        </trans-unit>
        <trans-unit id="9cb1515f8feac0bd625cac49b53fdf5bc0c4a06a" translate="yes" xml:space="preserve">
          <source>The same value is returned every time this function is called.</source>
          <target state="translated">El mismo valor se devuelve cada vez que se llama a esta función.</target>
        </trans-unit>
        <trans-unit id="16a9673c83d6b7f5a89950887b3ffafe04e2f9d5" translate="yes" xml:space="preserve">
          <source>The same words are defined in the C programming language in the include file &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; as macros. Because in C++ these are built into the language, the C++ version of &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;, as well as &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;, does not define anything.</source>
          <target state="translated">Las mismas palabras se definen en el lenguaje de programaci&amp;oacute;n C en el archivo de inclusi&amp;oacute;n &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; como macros. Debido a que en C ++ estos est&amp;aacute;n integrados en el lenguaje, la versi&amp;oacute;n C ++ de &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; , as&amp;iacute; como &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt; , no define nada.</target>
        </trans-unit>
        <trans-unit id="73fcd6a6bc40829dafc0c35e7f085fcf47650726" translate="yes" xml:space="preserve">
          <source>The scope of an entity declared in an unnamed namespace or in an inline namespace includes the enclosing namespace;</source>
          <target state="translated">El ámbito de aplicación de una entidad declarada en un espacio de nombres sin nombre o en un espacio de nombres en línea incluye el espacio de nombres adjunto;</target>
        </trans-unit>
        <trans-unit id="3bae590b6111c1b60bedc945d731d9c449dedcba" translate="yes" xml:space="preserve">
          <source>The scope of the name introduced by condition, if it is a declaration, is the combined scope of both statements' bodies:</source>
          <target state="translated">El alcance del nombre introducido por condición,si se trata de una declaración,es el alcance combinado de los cuerpos de ambas declaraciones:</target>
        </trans-unit>
        <trans-unit id="3e817d7c9bc7bbed9e0982e173160a7e98299780" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;choose&lt;/code&gt; can be passed to certain member functions of &lt;code&gt;std::chrono::time_zone&lt;/code&gt; and &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; to control how ambiguous or nonexistent local times should be resolved. Passing &lt;code&gt;choose::earliest&lt;/code&gt; causes the earlier time point to be returned, while passing &lt;code&gt;choose::latest&lt;/code&gt; causes the later time point to be returned. (For nonexistent local times, these two time points are identical.).</source>
          <target state="translated">La &lt;code&gt;choose&lt;/code&gt; enumeraci&amp;oacute;n de &amp;aacute;mbito se puede pasar a ciertas funciones miembro de &lt;code&gt;std::chrono::time_zone&lt;/code&gt; y &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; para controlar c&amp;oacute;mo se deben resolver las horas locales ambiguas o inexistentes. Pasar &lt;code&gt;choose::earliest&lt;/code&gt; hace que se devuelva el punto de tiempo anterior, mientras que pasar &lt;code&gt;choose::latest&lt;/code&gt; hace que se devuelva el punto de tiempo posterior. (Para horas locales inexistentes, estos dos puntos de tiempo son id&amp;eacute;nticos).</target>
        </trans-unit>
        <trans-unit id="840423b9be273862a9c8be4dd758424980f72802" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::cv_status&lt;/code&gt; describes whether a timed wait returned because of timeout or not.</source>
          <target state="translated">La enumeraci&amp;oacute;n de alcance &lt;code&gt;std::cv_status&lt;/code&gt; describe si una espera programada regres&amp;oacute; debido al tiempo de espera o no.</target>
        </trans-unit>
        <trans-unit id="a95fd75e62cf2bde9aca6a6e4779c05a5b287de7" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::errc&lt;/code&gt; defines the values of portable error conditions that correspond to the POSIX error codes.</source>
          <target state="translated">La enumeraci&amp;oacute;n de alcance &lt;code&gt;std::errc&lt;/code&gt; define los valores de las condiciones de error port&amp;aacute;tiles que corresponden a los c&amp;oacute;digos de error POSIX.</target>
        </trans-unit>
        <trans-unit id="0ef7ce4c4de2f78554ef3fcfe42b9b69c424fdff" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::future_errc&lt;/code&gt; defines the error codes reported by &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; and related classes in &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; exception objects. Only four error codes are required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::future_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La enumeraci&amp;oacute;n de alcance &lt;code&gt;std::future_errc&lt;/code&gt; define los c&amp;oacute;digos de error informados por &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; y las clases relacionadas en los objetos de excepci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; . Solo se requieren cuatro c&amp;oacute;digos de error, aunque la implementaci&amp;oacute;n puede definir c&amp;oacute;digos de error adicionales. Debido a que se proporciona la especializaci&amp;oacute;n adecuada de &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; , los valores de tipo &lt;code&gt;std::future_errc&lt;/code&gt; son impl&amp;iacute;citamente convertibles a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca50a2fc4180751cf2b50c765d0d95358b35a4a9" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::io_errc&lt;/code&gt; defines the error codes reported by I/O streams in &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; exception objects. Only one error code (&lt;code&gt;std::io_errc::stream&lt;/code&gt;) is required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::io_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La enumeraci&amp;oacute;n de alcance &lt;code&gt;std::io_errc&lt;/code&gt; define los c&amp;oacute;digos de error informados por las secuencias de E / S en los objetos de excepci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; . Solo se requiere un c&amp;oacute;digo de error ( &lt;code&gt;std::io_errc::stream&lt;/code&gt; ), aunque la implementaci&amp;oacute;n puede definir c&amp;oacute;digos de error adicionales. Debido a que se proporciona la especializaci&amp;oacute;n adecuada de &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; , los valores de tipo &lt;code&gt;std::io_errc&lt;/code&gt; son impl&amp;iacute;citamente convertibles a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf90aead8c2a5530e7c352d89f0a4c787a4c9dca" translate="yes" xml:space="preserve">
          <source>The scoped enumeration type &lt;code&gt;pointer_safety&lt;/code&gt; lists the pointer safety modes supported by C++</source>
          <target state="translated">El tipo de enumeraci&amp;oacute;n con &amp;aacute;mbito &lt;code&gt;pointer_safety&lt;/code&gt; enumera los modos de seguridad de puntero compatibles con C ++</target>
        </trans-unit>
        <trans-unit id="2dc9a7f6fd0f7a91a7650300695af1e539734973" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is a name of (formally, an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; that names) a data member or member function of &lt;code&gt;T&lt;/code&gt; or of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt; (e.g. &lt;code&gt;E1.E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt;), optionally &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified&lt;/a&gt; (e.g. &lt;code&gt;E1.B::E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt;), optionally using &lt;a href=&quot;dependent_name&quot;&gt;template disambiguator&lt;/a&gt; (e.g. &lt;code&gt;E1.template E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt;).</source>
          <target state="translated">El segundo operando de ambos operadores es un nombre de (formalmente, una &lt;a href=&quot;name#In_expressions&quot;&gt;expresi&amp;oacute;n de identificaci&amp;oacute;n&lt;/a&gt; que nombra) un miembro de datos o funci&amp;oacute;n miembro de &lt;code&gt;T&lt;/code&gt; o de una clase base &lt;code&gt;B&lt;/code&gt; de &lt;code&gt;T&lt;/code&gt; no ambigua y accesible (por ejemplo, &lt;code&gt;E1.E2&lt;/code&gt; o &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt; ) , opcionalmente &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;calificado&lt;/a&gt; (por ejemplo, &lt;code&gt;E1.B::E2&lt;/code&gt; o &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt; ), opcionalmente usando &lt;a href=&quot;dependent_name&quot;&gt;desambigador de plantilla&lt;/a&gt; (por ejemplo, &lt;code&gt;E1.template E2&lt;/code&gt; o &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="19215a02c420276aa98badc49ffb9d2736ab482c" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is an expression of type pointer to member ( &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;data&lt;/a&gt; or &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;function&lt;/a&gt;) of &lt;code&gt;T&lt;/code&gt; or pointer to member of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">El segundo operando de ambos operadores es una expresi&amp;oacute;n de tipo puntero a miembro ( &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;datos&lt;/a&gt; o &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;funci&amp;oacute;n&lt;/a&gt; ) de &lt;code&gt;T&lt;/code&gt; o puntero a miembro de una clase base &lt;code&gt;B&lt;/code&gt; de &lt;code&gt;T&lt;/code&gt; inequ&amp;iacute;voca y accesible .</target>
        </trans-unit>
        <trans-unit id="0c55eea87a0f8d8889265157fbe6787960184823" translate="yes" xml:space="preserve">
          <source>The second overload contains a separate template parameter for the head of the arguments and a parameter pack, this allows the recursive call to pass only the tail of the parameters until it becomes empty.</source>
          <target state="translated">La segunda sobrecarga contiene un parámetro de plantilla separado para la cabeza de los argumentos y un paquete de parámetros,esto permite que la llamada recursiva pase sólo la cola de los parámetros hasta que se vacíe.</target>
        </trans-unit>
        <trans-unit id="be075fc3b764cc15641e30da0af7956f238d21f0" translate="yes" xml:space="preserve">
          <source>The second pass through the callbacks may be used to deep-copy the user-defined objects pointed to by the pointers in &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El segundo paso a trav&amp;eacute;s de las devoluciones de llamada se puede utilizar para copiar en profundidad los objetos definidos por el usuario se&amp;ntilde;alados por los punteros en &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0a5b7b985ce580725fc7689da25a9594bd797ad" translate="yes" xml:space="preserve">
          <source>The second signature behaves as if called with &lt;code&gt;opts&lt;/code&gt; set to &lt;code&gt;perm_options::replace&lt;/code&gt;.</source>
          <target state="translated">La segunda firma se comporta como si llaman con &lt;code&gt;opts&lt;/code&gt; fijados a &lt;code&gt;perm_options::replace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2748b8b2515518309d2bd896dc6dc045638385c8" translate="yes" xml:space="preserve">
          <source>The selected elements must exist.</source>
          <target state="translated">Los elementos seleccionados deben existir.</target>
        </trans-unit>
        <trans-unit id="da6776cef8700dee0f22e58931e5d3627bef7c47" translate="yes" xml:space="preserve">
          <source>The semantics of inheriting constructors were retroactively changed by a &lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;defect report against C++11&lt;/a&gt;. Previously, an inheriting constructor declaration caused a set of synthesized constructor declarations to be injected into the derived class, which caused redundant argument copies/moves, had problematic interactions with some forms of SFINAE, and in some cases can be unimplementable on major ABIs. Older compilers may still implement the previous semantics.</source>
          <target state="translated">La sem&amp;aacute;ntica de los constructores heredados se modific&amp;oacute; retroactivamente por un &lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;informe de defectos contra C ++ 11&lt;/a&gt; . Anteriormente, una declaraci&amp;oacute;n de constructor heredado causaba que un conjunto de declaraciones de constructor sintetizadas se inyectaran en la clase derivada, lo que causaba copias / movimientos de argumentos redundantes, ten&amp;iacute;a interacciones problem&amp;aacute;ticas con algunas formas de SFINAE, y en algunos casos puede no ser implementable en las principales ABI. Los compiladores m&amp;aacute;s antiguos a&amp;uacute;n pueden implementar la sem&amp;aacute;ntica anterior.</target>
        </trans-unit>
        <trans-unit id="bfeb9ddde9efbc3c0ab3714a0a6e7a8a3efc2e2c" translate="yes" xml:space="preserve">
          <source>The semantics of the member functions are defined are as follows.</source>
          <target state="translated">La semántica de las funciones de los miembros se define de la siguiente manera.</target>
        </trans-unit>
        <trans-unit id="276fbc8f397db984b2189ed81138a185a9b8f9c5" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt;&lt;code&gt;clog&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La sem&amp;aacute;ntica de esta funci&amp;oacute;n est&amp;aacute;n destinadas a ser compatibles con la funci&amp;oacute;n C &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt; &lt;code&gt;clog&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="630a0686e90df2d1198d4a4bff7aa262b9655ed1" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt;&lt;code&gt;csqrt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La sem&amp;aacute;ntica de esta funci&amp;oacute;n est&amp;aacute; destinada a ser coherente con la funci&amp;oacute;n C &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt; &lt;code&gt;csqrt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f09342387ba1e64c32080173dab4604297f52ab0" translate="yes" xml:space="preserve">
          <source>The sequence denoted by this pair of iterators consists of the following:</source>
          <target state="translated">La secuencia denotada por este par de iteradores consiste en lo siguiente:</target>
        </trans-unit>
        <trans-unit id="8cf1423eae846ac729f66d139e28a402cef688fa" translate="yes" xml:space="preserve">
          <source>The sequence of &lt;code&gt;char&lt;/code&gt;s accumulated in Stage 2 is converted to a numeric value</source>
          <target state="translated">La secuencia de &lt;code&gt;char&lt;/code&gt; s acumula en la Etapa 2 se convierte en un valor num&amp;eacute;rico</target>
        </trans-unit>
        <trans-unit id="61ab9fb3fc586d17241f33750480c6a753617cad" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;d.param()&lt;/code&gt;</source>
          <target state="translated">La secuencia de n&amp;uacute;meros devueltos por invocaciones sucesivas de esta llamada con la misma &lt;code&gt;g&lt;/code&gt; se distribuye aleatoriamente de acuerdo con la distribuci&amp;oacute;n parametrizada por &lt;code&gt;d.param()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ad57e0d60c4213ba3be7acf41e0955df808546a" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">La secuencia de n&amp;uacute;meros devueltos por invocaciones sucesivas de esta llamada con la misma &lt;code&gt;g&lt;/code&gt; se distribuye aleatoriamente de acuerdo con la distribuci&amp;oacute;n parametrizada por &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="326be078a4bda5f44b21dfc8b70dd484a2be09be" translate="yes" xml:space="preserve">
          <source>The set of candidate functions and the list of arguments is prepared in a unique way for each of the contexts where overload resolution is used:</source>
          <target state="translated">El conjunto de funciones candidatas y la lista de argumentos se prepara de manera única para cada uno de los contextos en los que se utiliza la resolución de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="5fc5fc4fdccda5729ebc678de9b6bf863450c8f5" translate="yes" xml:space="preserve">
          <source>The set of candidate functions to be submitted for overload resolution is a union of the sets above. The argument list for the purpose of overload resolution consists of the operands of the operator except for &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, where the second operand is not an argument for the function call (see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;).</source>
          <target state="translated">El conjunto de funciones candidatas que se presentar&amp;aacute;n para la resoluci&amp;oacute;n de sobrecarga es una uni&amp;oacute;n de los conjuntos anteriores. La lista de argumentos con el prop&amp;oacute;sito de resoluci&amp;oacute;n de sobrecarga consiste en los operandos del operador, excepto &lt;code&gt;operator-&amp;gt;&lt;/code&gt; , donde el segundo operando no es un argumento para la llamada a la funci&amp;oacute;n (ver &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;operador de acceso de miembros&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a1904e66df24bc3e43e3c61d84a3ad2129497a05" translate="yes" xml:space="preserve">
          <source>The set of declarations found by ordinary &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; and the set of declarations found in all elements of the associated set produced by ADL, are merged, with the following special rules.</source>
          <target state="translated">El conjunto de declaraciones encontradas por la &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda no calificada&lt;/a&gt; ordinaria y el conjunto de declaraciones encontradas en todos los elementos del conjunto asociado producido por ADL, se fusionan, con las siguientes reglas especiales.</target>
        </trans-unit>
        <trans-unit id="633b59c91cf4f999e02e8403d839498119457c8d" translate="yes" xml:space="preserve">
          <source>The set of interval boundaries b</source>
          <target state="translated">El conjunto de límites de intervalo b</target>
        </trans-unit>
        <trans-unit id="e3b735a300b426d2245b4cf296a3150fc21a63b1" translate="yes" xml:space="preserve">
          <source>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is &lt;code&gt;{0,1&lt;/code&gt;}, for base-3 integers is &lt;code&gt;{0,1,2&lt;/code&gt;}, and so on. For bases larger than &lt;code&gt;10&lt;/code&gt;, valid digits include alphabetic characters, starting from &lt;code&gt;Aa&lt;/code&gt; for base-11 integer, to &lt;code&gt;Zz&lt;/code&gt; for base-36 integer. The case of the characters is ignored.</source>
          <target state="translated">El conjunto de valores v&amp;aacute;lidos para base es {0,2,3, ..., 36}. El conjunto de d&amp;iacute;gitos v&amp;aacute;lidos para los enteros de base 2 es &lt;code&gt;{0,1&lt;/code&gt; }, para los enteros de base 3 es &lt;code&gt;{0,1,2&lt;/code&gt; }, y as&amp;iacute; sucesivamente. Para bases mayores de &lt;code&gt;10&lt;/code&gt; , los d&amp;iacute;gitos v&amp;aacute;lidos incluyen caracteres alfab&amp;eacute;ticos, comenzando desde &lt;code&gt;Aa&lt;/code&gt; para entero de base 11, hasta &lt;code&gt;Zz&lt;/code&gt; para entero de base 36. Se ignora el caso de los personajes.</target>
        </trans-unit>
        <trans-unit id="54f77766bc9f988f0c109a0b9a274a2d62a58aff" translate="yes" xml:space="preserve">
          <source>The shared state already stores a value or exception. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El estado compartido ya almacena un valor o excepci&amp;oacute;n. La categor&amp;iacute;a de error se establece en &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd74c3ed26047fa14c5abbda7f8120251339635c" translate="yes" xml:space="preserve">
          <source>The shared state has already been retrieved via a call to &lt;code&gt;get_future&lt;/code&gt;. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_already_retrieved&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">El estado compartido ya se ha recuperado mediante una llamada a &lt;code&gt;get_future&lt;/code&gt; . La categor&amp;iacute;a de error se establece en &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_already_retrieved&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="817c4cd2132343bd97c84575fd05e4ae8b2ee89e" translate="yes" xml:space="preserve">
          <source>The shared state is only made ready after the current thread exits and all objects of</source>
          <target state="translated">El estado compartido sólo está listo después de que el hilo actual salga y todos los objetos de</target>
        </trans-unit>
        <trans-unit id="6e13e04bbcf515d86b1c971f508fc8ad239fb065" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;conjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">La creaci&amp;oacute;n de instancias de cortocircuito diferencia la &lt;code&gt;conjunction&lt;/code&gt; de las expresiones de plegado: una expresi&amp;oacute;n de plegado como &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; crea una instancia de cada &lt;code&gt;B&lt;/code&gt; en &lt;code&gt;Bs&lt;/code&gt; , mientras que &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; detiene la creaci&amp;oacute;n de instancias una vez que se puede determinar el valor . Esto es particularmente &amp;uacute;til si el tipo posterior es costoso de instanciar o puede causar un error grave cuando se instancia con el tipo incorrecto.</target>
        </trans-unit>
        <trans-unit id="4b6b7f6a466d865c0d71c17ba70598d418424cc5" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;disjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... || Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">La creaci&amp;oacute;n de instancias de cortocircuito diferencia la &lt;code&gt;disjunction&lt;/code&gt; de las expresiones de plegado: una expresi&amp;oacute;n de plegado como &lt;code&gt;(... || Bs::value)&lt;/code&gt; instancia cada &lt;code&gt;B&lt;/code&gt; en &lt;code&gt;Bs&lt;/code&gt; , mientras que &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; detiene la creaci&amp;oacute;n de instancias una vez que el valor puede ser determinado. Esto es particularmente &amp;uacute;til si el tipo posterior es costoso de instanciar o puede causar un error grave cuando se instancia con el tipo incorrecto.</target>
        </trans-unit>
        <trans-unit id="a6fb9e43d23dc62112f027d6321e004ed3458fa2" translate="yes" xml:space="preserve">
          <source>The side-effect A on a scalar M (a write) is</source>
          <target state="translated">El efecto secundario A en un escalar M (una escritura)es</target>
        </trans-unit>
        <trans-unit id="35d03624f1f46c34b182260c7be6e91d340366f1" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the objects being compared.</source>
          <target state="translated">El signo del resultado es el signo de la diferencia entre los valores del primer par de bytes (ambos interpretados como caracteres &lt;code&gt;unsigned char&lt;/code&gt; ) que difieren en los objetos que se comparan.</target>
        </trans-unit>
        <trans-unit id="e97cc12d1f3f2487de1b90ed0cc2090797374f8e" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared.</source>
          <target state="translated">El signo del resultado es el signo de la diferencia entre los valores del primer par de caracteres (ambos interpretados como caracteres &lt;code&gt;unsigned char&lt;/code&gt; ) que difieren en las cadenas que se comparan.</target>
        </trans-unit>
        <trans-unit id="cde6f3dc011075607068991f0904ec95fd72723b" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.</source>
          <target state="translated">El signo del resultado es el signo de la diferencia entre los valores del primer par de caracteres anchos que difieren en las matrices que se están comparando.</target>
        </trans-unit>
        <trans-unit id="f67aeb4832459c9bfc7aeb9f457a87aa921f1247" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</source>
          <target state="translated">El signo del resultado es el signo de la diferencia entre los valores del primer par de caracteres anchos que difieren en las cadenas que se comparan.</target>
        </trans-unit>
        <trans-unit id="7c011cc304f5801ea8e7fc6376c1a87eaf494c1e" translate="yes" xml:space="preserve">
          <source>The signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;.</source>
          <target state="translated">La firma no necesita tener &lt;code&gt;const &amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d5cf620ffd0c069fb09e6109069ba28e165d978" translate="yes" xml:space="preserve">
          <source>The signature of the comparison function should be equivalent to the following:</source>
          <target state="translated">La firma de la función de comparación debe ser equivalente a la siguiente:</target>
        </trans-unit>
        <trans-unit id="a6eece811de82334f897e04a0286d22b8a1880ad" translate="yes" xml:space="preserve">
          <source>The signature of the function should be equivalent to the following:</source>
          <target state="translated">La firma de la función debe ser equivalente a la siguiente:</target>
        </trans-unit>
        <trans-unit id="e16d376fc732d9fd890a8e68862e00b90427d089" translate="yes" xml:space="preserve">
          <source>The signature of the predicate function should be equivalent to the following:</source>
          <target state="translated">La firma de la función predicada debe ser equivalente a la siguiente:</target>
        </trans-unit>
        <trans-unit id="5471ac941bf0f0fd4abf99ed5f3d659518a0c817" translate="yes" xml:space="preserve">
          <source>The similarly-named container member functions &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove_if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove_if&lt;/code&gt;&lt;/a&gt; erase the removed elements.</source>
          <target state="translated">La &lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove&lt;/code&gt; &lt;/a&gt; funciones de miembro de contenedor con un nombre similar lista :: eliminar , &lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove_if&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove_if&lt;/code&gt; &lt;/a&gt; borra los elementos eliminados.</target>
        </trans-unit>
        <trans-unit id="d18977a380068b230c78baa2354437eff8114c95" translate="yes" xml:space="preserve">
          <source>The sine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the sine is sin z =</source>
          <target state="translated">El seno es una función completa en el plano complejo,y no tiene cortes en las ramas.La definición matemática del seno es sin z =</target>
        </trans-unit>
        <trans-unit id="b269c185388406409d66b389ee290905aa3250c2" translate="yes" xml:space="preserve">
          <source>The single total order might not be consistent with</source>
          <target state="translated">El orden total único podría no ser coherente con</target>
        </trans-unit>
        <trans-unit id="a1e4ac9052c7611ed3e612ed7782e64fa0ddd565" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;A&lt;/code&gt;'s state is no less than the size of &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">El tama&amp;ntilde;o de &lt;code&gt;A&lt;/code&gt; estado 's no es menos que el tama&amp;ntilde;o de &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa4ef58b6f217f15dfbc54c8b0b3fa97f978e5a" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">El tama&amp;ntilde;o de &lt;code&gt;c&lt;/code&gt; o &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a42f803c92acdfd49c509a1473d94317255f86f" translate="yes" xml:space="preserve">
          <source>The size of any &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; or member subobject (unless &lt;code&gt;[[no_unique_address]]&lt;/code&gt; -- see below)(since C++20) is required to be at least 1 even if the type is an empty &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (that is, a class or struct that has no non-static data members), in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct.</source>
          <target state="translated">El tama&amp;ntilde;o de cualquier &lt;a href=&quot;objects&quot;&gt;objeto&lt;/a&gt; o subobjeto miembro (a menos que &lt;code&gt;[[no_unique_address]]&lt;/code&gt; - ver m&amp;aacute;s abajo) (ya que C ++ 20) debe ser al menos 1, incluso si el tipo es un &lt;a href=&quot;class&quot;&gt;tipo de clase&lt;/a&gt; vac&amp;iacute;o (es decir, una clase o estructura que no tiene miembros de datos no est&amp;aacute;ticos), para poder garantizar que las direcciones de objetos distintos del mismo tipo sean siempre distintas.</target>
        </trans-unit>
        <trans-unit id="60fb803f3af93287267581b597b353fbed331445" translate="yes" xml:space="preserve">
          <source>The size of the file, in bytes.</source>
          <target state="translated">El tamaño del archivo,en bytes.</target>
        </trans-unit>
        <trans-unit id="fdc6fa0a097f223b138fc7c44f70083d5b4bcb5a" translate="yes" xml:space="preserve">
          <source>The size of the private container that was populated at construction time.</source>
          <target state="translated">El tamaño del contenedor privado que se pobló en el momento de la construcción.</target>
        </trans-unit>
        <trans-unit id="3facb159d302e57398e2b32d50c748002ccee995" translate="yes" xml:space="preserve">
          <source>The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).</source>
          <target state="translated">El tamaño del buffer de retroceso varía en la práctica de 4k (Linux,MacOS)a tan sólo 4 (Solaris)o el mínimo garantizado 1 (HPUX,AIX).</target>
        </trans-unit>
        <trans-unit id="c2459bce198cb000b381177d5cc738c181699405" translate="yes" xml:space="preserve">
          <source>The size of the referred-to filesystem object.</source>
          <target state="translated">El tamaño del objeto del sistema de archivos referido.</target>
        </trans-unit>
        <trans-unit id="2a786a72bf82ea447c9d87b5be65ed00ac14cb03" translate="yes" xml:space="preserve">
          <source>The size of the sequence in bytes, i.e., &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt;.</source>
          <target state="translated">El tama&amp;ntilde;o de la secuencia en bytes, es decir, &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66997ef04e230b1f79e491df0b1540977ef30033" translate="yes" xml:space="preserve">
          <source>The sizeof... operator</source>
          <target state="translated">El tamaño del...operador</target>
        </trans-unit>
        <trans-unit id="e03ce5e1c2c2d6a504f6be8da7e802aa894a2643" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;q&lt;/code&gt; in &lt;code&gt;[p,p+n)&lt;/code&gt; such that &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; is true</source>
          <target state="translated">La &lt;code&gt;q&lt;/code&gt; m&amp;aacute;s peque&amp;ntilde;a en &lt;code&gt;[p,p+n)&lt;/code&gt; tal que &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; es verdadera</target>
        </trans-unit>
        <trans-unit id="164a8a1e2ed3ac9211701d99d6d1f9abf5da92d6" translate="yes" xml:space="preserve">
          <source>The smallest integral power of two that is not smaller than &lt;code&gt;x&lt;/code&gt;, or an unspecified value if the result cannot be represented in &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">La potencia integral m&amp;aacute;s peque&amp;ntilde;a de los dos que no es menor que &lt;code&gt;x&lt;/code&gt; , o un valor no especificado si el resultado no se puede representar en &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6019aa352c36bf78f73a83e660e2da74f2e4c2ce" translate="yes" xml:space="preserve">
          <source>The socket is not connected</source>
          <target state="translated">El enchufe no está conectado</target>
        </trans-unit>
        <trans-unit id="c1a77c31870ff87a240876e0120da8708b5e5e1e" translate="yes" xml:space="preserve">
          <source>The sole exceptions to the maximal munch rule are:</source>
          <target state="translated">Las únicas excepciones a la regla de la máxima munición son:</target>
        </trans-unit>
        <trans-unit id="023ae07779bac9c8efdef6a9eb724121da731b80" translate="yes" xml:space="preserve">
          <source>The source of the messages is implementation-defined.</source>
          <target state="translated">La fuente de los mensajes está definida por la aplicación.</target>
        </trans-unit>
        <trans-unit id="be9039b113cba4c87f833cb8a33bdd196413e28b" translate="yes" xml:space="preserve">
          <source>The span must have static extent (i.e., &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;I&lt;/code&gt; must be an integer value in range &lt;code&gt;[0, N)&lt;/code&gt;. This is enforced at compile time as opposed to &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">El lapso debe tener medida est&amp;aacute;tica (es decir, &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt; ) y &lt;code&gt;I&lt;/code&gt; debe ser un valor entero en el rango &lt;code&gt;[0, N)&lt;/code&gt; . Esto se aplica en tiempo de compilaci&amp;oacute;n en oposici&amp;oacute;n al &lt;code&gt;operator[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e5608fbdb3aeacdd6ea3d40e4a18d5358477dba" translate="yes" xml:space="preserve">
          <source>The special pathname dot (&lt;code&gt;&quot;.&quot;&lt;/code&gt;) is a hard link to its parent directory. The special pathname dot-dot &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a hard link to the directory that is the parent of its parent.</source>
          <target state="translated">El nombre de ruta especial dot ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; ) Es un enlace r&amp;iacute;gido a su directorio padre. El nombre de ruta especial punto-punto &lt;code&gt;&quot;..&quot;&lt;/code&gt; es un enlace r&amp;iacute;gido al directorio que es el padre de su padre.</target>
        </trans-unit>
        <trans-unit id="d5b3112d1aecd8e0bc024d6e95c5b21d74c58b9f" translate="yes" xml:space="preserve">
          <source>The special pathnames dot and dot-dot are skipped.</source>
          <target state="translated">Los nombres especiales punto y punto-punto se saltan.</target>
        </trans-unit>
        <trans-unit id="3fec246ae7b3831f5d777421b3527ac038580e09" translate="yes" xml:space="preserve">
          <source>The special unnamed bit field of size zero can be forced to break up padding. It specifies that the next bit field begins at the beginning of its allocation unit:</source>
          <target state="translated">El campo de bits especial sin nombre del tamaño cero puede ser forzado a romper el acolchado.Especifica que el siguiente campo de bits comienza al principio de su unidad de asignación:</target>
        </trans-unit>
        <trans-unit id="05614a0a97be351dbad65c4504f830ce86618f1b" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace()&lt;/code&gt; member until C++14.</source>
          <target state="translated">La especializaci&amp;oacute;n &lt;a href=&quot;../vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;&lt;/a&gt; no ten&amp;iacute;a miembro &lt;code&gt;emplace()&lt;/code&gt; hasta C ++ 14.</target>
        </trans-unit>
        <trans-unit id="c0c58597769cd63f71580480f8d3215395bbf758" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace_back()&lt;/code&gt; member until C++14.</source>
          <target state="translated">La especializaci&amp;oacute;n &lt;a href=&quot;../vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;&lt;/a&gt; no ten&amp;iacute;a miembro &lt;code&gt;emplace_back()&lt;/code&gt; hasta C ++ 14.</target>
        </trans-unit>
        <trans-unit id="8bec2e9d713031b66c24ef679d2b78ee8bb1782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">La especializaci&amp;oacute;n &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; tiene una base p&amp;uacute;blica e inequ&amp;iacute;voca.</target>
        </trans-unit>
        <trans-unit id="3d5cf9884b92e823e93ea4f01a9bf287d1156634" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">La especializaci&amp;oacute;n &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; tiene una base p&amp;uacute;blica e inequ&amp;iacute;voca.</target>
        </trans-unit>
        <trans-unit id="186f2d291b8a6a9a42e951016f0b61a5ce492295" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">La especializaci&amp;oacute;n &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; est&amp;aacute; habilitada (consulte &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; ) si &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; est&amp;aacute; habilitado y, de lo contrario, est&amp;aacute; deshabilitado.</target>
        </trans-unit>
        <trans-unit id="600411d4c48669f0d407c466842e7104a0cdd005" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">La especializaci&amp;oacute;n &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; est&amp;aacute; habilitada (consulte &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; ) si &lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; est&amp;aacute; habilitado, y est&amp;aacute; deshabilitado de lo contrario.</target>
        </trans-unit>
        <trans-unit id="42f1297302612956b663a74e0024532e227a782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if every specialization in &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">La especializaci&amp;oacute;n &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; est&amp;aacute; habilitada (consulte &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; ) si todas las especializaciones en &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; est&amp;aacute;n habilitadas, y est&amp;aacute; deshabilitado de lo contrario.</target>
        </trans-unit>
        <trans-unit id="2c76460cbd0b8d4d937dbc5c694d6c7635ce71fd" translate="yes" xml:space="preserve">
          <source>The specializations &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt;, &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; are &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt; for representing and manipulating &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex numbers&lt;/a&gt;.</source>
          <target state="translated">Las especializaciones &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt; , &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt; y &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; son &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt; para representar y manipular &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;n&amp;uacute;meros complejos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86590d0709c4e9c53d7a3642895c8ee4ba57e923" translate="yes" xml:space="preserve">
          <source>The specification of release-consume ordering is being revised, and the use of &lt;code&gt;memory_order_consume&lt;/code&gt; is temporarily discouraged.</source>
          <target state="translated">La especificaci&amp;oacute;n del orden de liberaci&amp;oacute;n-consumo se est&amp;aacute; revisando y se desaconseja temporalmente el uso de &lt;code&gt;memory_order_consume&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29817af7f9fc3c9588fba123d6e7dc6efdcdd019" translate="yes" xml:space="preserve">
          <source>The specified non-type arguments must either match the types of the corresponding non-type template parameters, or be &lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;convertible to them&lt;/a&gt;.</source>
          <target state="translated">Los argumentos de tipo no especificados deben coincidir con los tipos de los par&amp;aacute;metros de plantilla de tipo no correspondientes o ser &lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;convertibles a ellos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd71ab6119537a05f604ee514973d18be587dd3" translate="yes" xml:space="preserve">
          <source>The specified template arguments must match the template parameters in kind (i.e., type for type, non-type for non-type, and template for template). There cannot be more arguments than there are parameters (unless one parameter is a parameter pack, in which case there has to be an argument for each non-pack parameter).</source>
          <target state="translated">Los argumentos de la plantilla especificados deben coincidir con los parámetros de la plantilla en especie (es decir,tipo por tipo,no tipo por no tipo y plantilla por plantilla).No puede haber más argumentos que parámetros (a menos que un parámetro sea un paquete de parámetros,en cuyo caso tiene que haber un argumento para cada parámetro no paquete).</target>
        </trans-unit>
        <trans-unit id="f0a5a1232f69709176b03e5e2f09bcf1138b3d55" translate="yes" xml:space="preserve">
          <source>The standard 32-bit IEEE 754 floating-point type has a 24 bit fractional part (23 bits written, one implied), which may suggest that it can represent 7 digit decimals (&lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 7.22), but relative rounding errors are non-uniform and some floating-point values with 7 decimal digits do not survive conversion to 32-bit float and back: the smallest positive example is &lt;code&gt;8.589973e9&lt;/code&gt;, which becomes &lt;code&gt;8.589974e9&lt;/code&gt; after the roundtrip. These rounding errors cannot exceed one bit in the representation, and &lt;code&gt;digits10&lt;/code&gt; is calculated as &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt;, which is 6.92. Rounding down results in the value 6.</source>
          <target state="translated">El tipo est&amp;aacute;ndar de coma flotante IEEE 754 de 32 bits tiene una parte fraccionaria de 24 bits (23 bits escritos, uno impl&amp;iacute;cito), lo que puede sugerir que puede representar decimales de 7 d&amp;iacute;gitos ( &lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; es 7.22), pero los errores de redondeo relativos no son uniformes y algunos valores de coma flotante con 7 d&amp;iacute;gitos decimales no sobreviven a la conversi&amp;oacute;n a flotante de 32 bits y viceversa: el ejemplo positivo m&amp;aacute;s peque&amp;ntilde;o es &lt;code&gt;8.589973e9&lt;/code&gt; , que se convierte en &lt;code&gt;8.589974e9&lt;/code&gt; despu&amp;eacute;s del viaje de ida y vuelta. Estos errores de redondeo no pueden exceder un bit en la representaci&amp;oacute;n, y los &lt;code&gt;digits10&lt;/code&gt; se calculan como &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; , que es 6.92. El redondeo hacia abajo da como resultado el valor 6.</target>
        </trans-unit>
        <trans-unit id="73e09cdf1b741ad1b3350d5372e33ae3558bb73f" translate="yes" xml:space="preserve">
          <source>The standard C streams are the following: &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los flujos est&amp;aacute;ndar de C son los siguientes: &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bc3d7739fd70319e077ff236f69aa7397545b58" translate="yes" xml:space="preserve">
          <source>The standard C++ streams are the following: &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los flujos est&amp;aacute;ndares C ++ son los siguientes: &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1559238f4f96f1308a43f7cac736eb900505d58" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">Los contenedores est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfacen estos requisitos.</target>
        </trans-unit>
        <trans-unit id="9b92ff236d7217d097c5d77ce3d7b6e24187e96b" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">Los contenedores est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; satisfacen estos requisitos.</target>
        </trans-unit>
        <trans-unit id="3348805983e91545ed6f0183b3ad7d17819a000e" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Los contenedores est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfacen estos requisitos. Por defecto, si no se especifica ninguna clase de contenedor para una instancia de clase de pila particular, se usa el contenedor est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da4c870ff1fa0a006bae378b114850461217f6df" translate="yes" xml:space="preserve">
          <source>The standard defines a set of &lt;a href=&quot;preprocessor/replace&quot;&gt;preprocessor macros&lt;/a&gt; corresponding to C++ language and library features introduced in C++11 or later. They are intended as a simple and portable way to detect the presence of said features.</source>
          <target state="translated">El est&amp;aacute;ndar define un conjunto de &lt;a href=&quot;preprocessor/replace&quot;&gt;macros&lt;/a&gt; de preprocesador correspondientes al lenguaje C ++ y las caracter&amp;iacute;sticas de la biblioteca introducidas en C ++ 11 o posterior. Pretenden ser una forma simple y port&amp;aacute;til de detectar la presencia de dichas caracter&amp;iacute;sticas.</target>
        </trans-unit>
        <trans-unit id="7a975074992a026641c667980782c267b65820dd" translate="yes" xml:space="preserve">
          <source>The standard does not define any behavior for this function except that &lt;code&gt;setbuf(0, 0)&lt;/code&gt; called before any I/O has taken place is required to set unbuffered output.</source>
          <target state="translated">El est&amp;aacute;ndar no define ning&amp;uacute;n comportamiento para esta funci&amp;oacute;n, excepto que se &lt;code&gt;setbuf(0, 0)&lt;/code&gt; llamado antes de que se realice cualquier E / S para configurar la salida sin b&amp;uacute;fer.</target>
        </trans-unit>
        <trans-unit id="11c9f11d649487cf00471f2a0a3ced302b1b169d" translate="yes" xml:space="preserve">
          <source>The standard encourages, but doesn't require that the main thread and the threads started by &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; offer concurrent forward progress guarantee.</source>
          <target state="translated">El est&amp;aacute;ndar alienta, pero no requiere que el subproceso principal y los subprocesos iniciados por &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; ofrezcan garant&amp;iacute;a simult&amp;aacute;nea de progreso hacia adelante.</target>
        </trans-unit>
        <trans-unit id="3769b4f39ad7629c09afe04cb807040c01f86974" translate="yes" xml:space="preserve">
          <source>The standard error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; typically indicates the condition where the result, rather than the input, is out of range, and is more closely related to &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La condici&amp;oacute;n de error est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; generalmente indica la condici&amp;oacute;n en la que el resultado, en lugar de la entrada, est&amp;aacute; fuera de rango y est&amp;aacute; m&amp;aacute;s estrechamente relacionado con &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ea76ab6562da741fc1f1f80fa940f195cc6f7f0" translate="yes" xml:space="preserve">
          <source>The standard itself doesn't specify precedence levels. They are derived from the grammar.</source>
          <target state="translated">La norma en sí no especifica los niveles de precedencia.Se derivan de la gramática.</target>
        </trans-unit>
        <trans-unit id="464d44c8fa9af2bc062b88f7cb6e09d51921375c" translate="yes" xml:space="preserve">
          <source>The standard library</source>
          <target state="translated">La biblioteca estándar</target>
        </trans-unit>
        <trans-unit id="501d2fd270600c1ad4722fe615b8c6d60795a8cf" translate="yes" xml:space="preserve">
          <source>The standard library also defines a function template &lt;a href=&quot;../../algorithm/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt; taking a pair of iterators and a value, this overload is one of the standard &lt;a href=&quot;../../algorithm&quot;&gt;algorithms&lt;/a&gt;.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar tambi&amp;eacute;n define una plantilla de funci&amp;oacute;n &lt;a href=&quot;../../algorithm/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt; tomando un par de iteradores y un valor, esta sobrecarga es uno de los &lt;a href=&quot;../../algorithm&quot;&gt;algoritmos&lt;/a&gt; est&amp;aacute;ndar .</target>
        </trans-unit>
        <trans-unit id="6f9befce5f0ccf765011ba595f540e481507757b" translate="yes" xml:space="preserve">
          <source>The standard library also defines an overload of &lt;code&gt;std::remove&lt;/code&gt; taking &lt;code&gt;const char*&lt;/code&gt;, used to delete files: &lt;a href=&quot;../io/c/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar tambi&amp;eacute;n define una sobrecarga de &lt;code&gt;std::remove&lt;/code&gt; tomando &lt;code&gt;const char*&lt;/code&gt; , utilizada para eliminar archivos: &lt;a href=&quot;../io/c/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0eb84bf9201f6099169c60c1dc16401b24988119" translate="yes" xml:space="preserve">
          <source>The standard library also provides a number of pre-defined &lt;a href=&quot;../utility/functional&quot;&gt;function object templates&lt;/a&gt; as well as the methods to compose new ones (including &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar tambi&amp;eacute;n proporciona una serie de &lt;a href=&quot;../utility/functional&quot;&gt;plantillas de objetos de funci&amp;oacute;n predefinidas&lt;/a&gt; , as&amp;iacute; como los m&amp;eacute;todos para componer otras nuevas (incluidas &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b555b9bc9fd6124abd76d1e9d57fcd86813932ea" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; allows for creating a substitution failure in order to enable or disable particular overloads based on a condition evaluated at compile time.</source>
          <target state="translated">El componente de biblioteca est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; permite crear una falla de sustituci&amp;oacute;n para habilitar o deshabilitar sobrecargas particulares basadas en una condici&amp;oacute;n evaluada en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4fdaf88b78e9440c1d7c4b829cd2c20de63b3687" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; is another utility metafunction that simplifies SFINAE applications.</source>
          <target state="translated">El componente de biblioteca est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; es otra metafunci&amp;oacute;n de utilidad que simplifica las aplicaciones SFINAE.</target>
        </trans-unit>
        <trans-unit id="90d7e9c58cdd097e6e1be1842b8c59bbecc70529" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report domain errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::domain_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">Los componentes de la biblioteca est&amp;aacute;ndar no lanzan esta excepci&amp;oacute;n (las funciones matem&amp;aacute;ticas informan errores de dominio como se especifica en &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; ). Las bibliotecas de terceros, sin embargo, usan esto. Por ejemplo, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; arroja &lt;code&gt;std::domain_error&lt;/code&gt; si &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; est&amp;aacute; habilitado (la configuraci&amp;oacute;n predeterminada).</target>
        </trans-unit>
        <trans-unit id="46dcc8a3d08bda1ff1e95e9b8404ca3dc28f1aeb" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report underflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::underflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">Los componentes de la biblioteca est&amp;aacute;ndar no lanzan esta excepci&amp;oacute;n (las funciones matem&amp;aacute;ticas informan errores de subdesbordamiento como se especifica en &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; ). Las bibliotecas de terceros, sin embargo, usan esto. Por ejemplo, &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; lanza &lt;code&gt;std::underflow_error&lt;/code&gt; si &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; est&amp;aacute; habilitado (la configuraci&amp;oacute;n predeterminada).</target>
        </trans-unit>
        <trans-unit id="45b5eeaea89ac1fd73a4e45ba45af272f555ab4a" translate="yes" xml:space="preserve">
          <source>The standard library defines two trivial awaitables: &lt;code&gt;std::suspend_always&lt;/code&gt; and &lt;code&gt;std::suspend_never&lt;/code&gt;.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar define dos triviales esperables: &lt;code&gt;std::suspend_always&lt;/code&gt; y &lt;code&gt;std::suspend_never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="131ce88470ae44f681ca4c49d07e5f0002f442b1" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (5-8) directly calls the corresponding throwing versions (1-4). The standard library implementation of the throwing array versions (2,4) directly calls the corresponding single-object version (1,3). Thus, replacing the throwing single object allocation functions is sufficient to handle all allocations.</source>
          <target state="translated">Las implementaciones estándar de la biblioteca de las versiones no lanzadas (5-8)llaman directamente a las versiones lanzadas correspondientes (1-4).La implementación de las librerías estándar de las versiones de tirar (2,4)llama directamente a la correspondiente versión de un solo objeto (1,3).Por lo tanto,el reemplazo de las funciones de asignación de un solo objeto de lanzamiento es suficiente para manejar todas las asignaciones.</target>
        </trans-unit>
        <trans-unit id="987bfd8dffed15aac50d7b564b0338f3cfc187ca" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (9,10) directly call the corresponding throwing versions (1,2). The standard library implementations of the size-aware deallocation functions (5-8) directly call the corresponding size-unaware deallocation functions (1-4). The standard library implementations of size-unaware throwing array forms (2,4) directly calls the corresponding single-object forms (1,3).</source>
          <target state="translated">Las implementaciones estándar de la biblioteca de las versiones no lanzadas (9,10)llaman directamente a las versiones lanzadas correspondientes (1,2).Las implementaciones estándar de las librerías de las funciones de deallocation con conocimiento de tamaño (5-8)llaman directamente a las correspondientes funciones de deallocation sin conocimiento de tamaño (1-4).Las implementaciones de la biblioteca estándar de las formas de distribución de tamaño desconocido (2,4)llaman directamente a las correspondientes formas de un solo objeto (1,3).</target>
        </trans-unit>
        <trans-unit id="6f67e8db943a7e5f11fa3e591652be01e6c72c81" translate="yes" xml:space="preserve">
          <source>The standard library placement forms of operator delete (13,14) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement delete (25,26) with matching signature: &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; or &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt;.</source>
          <target state="translated">Las formas de colocaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar de eliminaci&amp;oacute;n de operador (13,14) no se pueden reemplazar y solo se pueden personalizar si la nueva expresi&amp;oacute;n de ubicaci&amp;oacute;n no utiliz&amp;oacute; la sintaxis &lt;code&gt;::new&lt;/code&gt; , proporcionando una eliminaci&amp;oacute;n de ubicaci&amp;oacute;n espec&amp;iacute;fica de clase (25,26) con firma coincidente: &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; o &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f331f596fff7bf452e9368230c890e4ad858b73" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::bit_and&lt;/code&gt; cuando no se especifica &lt;code&gt;T&lt;/code&gt; , lo que deja los tipos de par&amp;aacute;metros y el tipo de retorno para deducir.</target>
        </trans-unit>
        <trans-unit id="51b8639942df5edd3c966b0d456710b62ece3289" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::bit_not&lt;/code&gt; cuando no se especifica &lt;code&gt;T&lt;/code&gt; , lo que deja los tipos de par&amp;aacute;metros y el tipo de retorno para deducir.</target>
        </trans-unit>
        <trans-unit id="3f85f5fb8d6b87c4f54a098871a34860fd38598a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::bit_or&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="0cf5638980a6e182479f5dbc4a0b88370ff66486" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_xor&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::bit_xor&lt;/code&gt; cuando no se especifica &lt;code&gt;T&lt;/code&gt; , lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="b457595199deea57bcd493866c929556b33e76c3" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::divides&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::divides&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="424b00c8e42201af9548ab0448e6ee7a2e60cfef" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::equal_to&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja los tipos de par&amp;aacute;metros y el tipo de retorno para deducir.</target>
        </trans-unit>
        <trans-unit id="445dfbf3571b7bf4a2bdaa8ee7d29b4668dc155f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::greater&lt;/code&gt; cuando no se especifica &lt;code&gt;T&lt;/code&gt; , lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="2e57796087a77aba47733fc29c950505cf26b1be" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::greater_equal&lt;/code&gt; cuando no se especifica &lt;code&gt;T&lt;/code&gt; , lo que deja los tipos de par&amp;aacute;metros y el tipo de retorno para deducir.</target>
        </trans-unit>
        <trans-unit id="d03ee57547fa44cc25d3f2cc6819498bf61e5b4f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::less&lt;/code&gt; cuando no se especifica &lt;code&gt;T&lt;/code&gt; , lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="1df3c94ad21dfdfe9d3b7d094b740848f19b97b6" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::less_equal&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="c43777e85f59e5d1bbafcf4b62e738707fc73cc8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::logical_and&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="22cce0c9b0e471c051bc216994974900fed662a5" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::logical_not&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="b18a6f7d7f176eaa205b868246f5b1e0eaa0fbbe" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::logical_or&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="4a1acb46cad97b294ab7069cf7f2c49e0f7cf8b1" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::minus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::minus&lt;/code&gt; cuando no se especifica &lt;code&gt;T&lt;/code&gt; , lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="6416b0b039efddd187d08d4923fac1b5ea6b2919" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::modulus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::modulus&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="9e894075f88d07cc0fe2281d2c4c9b7877d9b39c" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::multiplies&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::multiplies&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="f5aca230aea77b0bd8892a57f74c1c692d9e92c8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::negate&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::negate&lt;/code&gt; cuando no se especifica &lt;code&gt;T&lt;/code&gt; , lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="3a6ba7f3f95659a4fcbc1e1535d8d51d3f4d4522" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::not_equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::not_equal_to&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="b5b5790ca4e3a36f7013249f817e8e9a00cbb0f8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::owner_less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified. In this case, the parameter types are deduced from the arguments (each of which must still be either a &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::owner_less&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica. En este caso, los tipos de par&amp;aacute;metros se deducen de los argumentos (cada uno de los cuales debe ser &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="120610675bef9d2af7c4846670094bb75886286b" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::plus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::plus&lt;/code&gt; cuando &lt;code&gt;T&lt;/code&gt; no se especifica, lo que deja que se deduzcan los tipos de par&amp;aacute;metros y el tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="e47ae8777ca4465b596890ef95a90b212d5b7e1a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::vector&lt;/code&gt; for the type &lt;code&gt;bool&lt;/code&gt;, which may be optimized for space efficiency.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona una especializaci&amp;oacute;n de &lt;code&gt;std::vector&lt;/code&gt; para el tipo &lt;code&gt;bool&lt;/code&gt; , que puede optimizarse para la eficiencia del espacio.</target>
        </trans-unit>
        <trans-unit id="0fefa50e2fa7d26d5c3b1a75d91a4ce66ae1e5fa" translate="yes" xml:space="preserve">
          <source>The standard library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks (i.e. functions launched in separate threads). These values are communicated in a</source>
          <target state="translated">La biblioteca estándar ofrece facilidades para obtener valores que se devuelven y para captar excepciones que se lanzan por tareas asíncronas (es decir,funciones lanzadas en hilos separados).Estos valores se comunican en un</target>
        </trans-unit>
        <trans-unit id="093ef8202a6c5dfcd0f104f718c58b45c3a78863" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic&lt;/code&gt; template for the following types with additional properties that the primary template does not have:</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona especializaciones parciales de la plantilla &lt;code&gt;std::atomic&lt;/code&gt; para los siguientes tipos con propiedades adicionales que la plantilla primaria no tiene:</target>
        </trans-unit>
        <trans-unit id="228f6a886c12bbc3f7a888fe93cf312d114dba7e" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic_ref&lt;/code&gt; template for for all pointer types. In addition to the operations provided for all atomic types, these specializations additionally support atomic arithmetic operations appropriate to pointer types, such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar proporciona especializaciones parciales de la plantilla &lt;code&gt;std::atomic_ref&lt;/code&gt; para todos los tipos de puntero. Adem&amp;aacute;s de las operaciones proporcionadas para todos los tipos at&amp;oacute;micos, estas especializaciones tambi&amp;eacute;n admiten operaciones aritm&amp;eacute;ticas at&amp;oacute;micas apropiadas para los tipos de puntero, como &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad36dcf418bbed48c178ac3a02f2b5e9c8c7da73" translate="yes" xml:space="preserve">
          <source>The standard library provides the following searchers:</source>
          <target state="translated">La biblioteca estándar proporciona los siguientes buscadores:</target>
        </trans-unit>
        <trans-unit id="3b2efd68490dfb7a4918757f6cf2c4bb0801f472" translate="yes" xml:space="preserve">
          <source>The standard library types that are aliases of arithmetic types (such as &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt;) may also be examined with the &lt;code&gt;std::numeric_limits&lt;/code&gt; type traits.</source>
          <target state="translated">Los tipos de biblioteca est&amp;aacute;ndar que son alias de los tipos aritm&amp;eacute;ticos (como &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt; ) tambi&amp;eacute;n pueden examinarse con los rasgos de tipo &lt;code&gt;std::numeric_limits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffd7a9f649b4d9408cc4e3d1e7589d2c8b29d694" translate="yes" xml:space="preserve">
          <source>The standard library's non-allocating placement forms of operator new (9-10) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement new (19,20) with matching signature: &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; or &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt;.</source>
          <target state="translated">Las formas de colocaci&amp;oacute;n no asignadas de la biblioteca est&amp;aacute;ndar del operador nuevo (9-10) no se pueden reemplazar y solo se pueden personalizar si la expresi&amp;oacute;n nueva de ubicaci&amp;oacute;n no utiliz&amp;oacute; la sintaxis &lt;code&gt;::new&lt;/code&gt; , proporcionando una ubicaci&amp;oacute;n espec&amp;iacute;fica de clase nueva (19, 20) con firma coincidente: &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; o &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4981b4624e460e124e89bf34f4ff3f0393f76006" translate="yes" xml:space="preserve">
          <source>The standard output objects &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; have their &lt;code&gt;unitbuf&lt;/code&gt; bit set by default.</source>
          <target state="translated">Los objetos de salida est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; tienen su bit &lt;code&gt;unitbuf&lt;/code&gt; establecido de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="9e153cc38ba0d2871317e848fbb767c71742cdb1" translate="yes" xml:space="preserve">
          <source>The standard recommends that a &lt;a href=&quot;../../chrono/steady_clock&quot;&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/a&gt; is used to measure the duration. If an implementation uses a &lt;a href=&quot;../../chrono/system_clock&quot;&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/a&gt; instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">El est&amp;aacute;ndar recomienda que se &lt;a href=&quot;../../chrono/steady_clock&quot;&gt; &lt;code&gt;steady_clock&lt;/code&gt; &lt;/a&gt; un reloj constante para medir la duraci&amp;oacute;n. Si una implementaci&amp;oacute;n usa un &lt;a href=&quot;../../chrono/system_clock&quot;&gt; &lt;code&gt;system_clock&lt;/code&gt; &lt;/a&gt; , el tiempo de espera tambi&amp;eacute;n puede ser sensible a los ajustes del reloj.</target>
        </trans-unit>
        <trans-unit id="4670d79858faa026fd927ad092884ff7288c02f9" translate="yes" xml:space="preserve">
          <source>The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">La norma recomienda que se utilice un reloj fijo para medir la duración.Si una implementación utiliza un reloj de sistema en su lugar,el tiempo de espera también puede ser sensible a los ajustes de reloj.</target>
        </trans-unit>
        <trans-unit id="3e741a6a70c81c69a623d13af6d5fd11444c21c7" translate="yes" xml:space="preserve">
          <source>The standard signed integer types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt;;</source>
          <target state="translated">Los tipos enteros con signo est&amp;aacute;ndar: &lt;code&gt;signed char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; y &lt;code&gt;long long&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="f7faa7d4edc03214148f1c3967ed705a6e4cf33e" translate="yes" xml:space="preserve">
          <source>The standard specializations of &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; return the pattern &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</source>
          <target state="translated">Las especializaciones est&amp;aacute;ndar de &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; devuelven el patr&amp;oacute;n &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="297a7545b93be6b8ae2bf103d5942d598d8acf23" translate="yes" xml:space="preserve">
          <source>The standard unsigned integer types: &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, and &lt;code&gt;unsigned long long&lt;/code&gt;;</source>
          <target state="translated">Los tipos enteros sin signo est&amp;aacute;ndar: &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; y &lt;code&gt;unsigned long long&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b3faee826fe7d429ac217f2296c04e167f193a78" translate="yes" xml:space="preserve">
          <source>The start of the get area, for all writeable &lt;code&gt;std::strstreambuf&lt;/code&gt; objects constructed through the interface provided by &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;, is also the start of the put area.</source>
          <target state="translated">El inicio del &amp;aacute;rea de obtenci&amp;oacute;n, para todos los objetos &lt;code&gt;std::strstreambuf&lt;/code&gt; grabables construidos a trav&amp;eacute;s de la interfaz proporcionada por &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; , es tambi&amp;eacute;n el inicio del &amp;aacute;rea de colocaci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="29e1675652ac7f6393431e47f0ec2642d6a47e2b" translate="yes" xml:space="preserve">
          <source>The starting directory has depth of 0, its subdirectories have depth 1, etc.</source>
          <target state="translated">El directorio inicial tiene una profundidad de 0,sus subdirectorios tienen una profundidad de 1,etc.</target>
        </trans-unit>
        <trans-unit id="9c4774217cf581390531d456216df78cfba88d58" translate="yes" xml:space="preserve">
          <source>The state of &lt;code&gt;A&lt;/code&gt; includes the state of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">El estado de &lt;code&gt;A&lt;/code&gt; incluye el estado de &lt;code&gt;B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf3c2fc8c65fee8f63cb40617161a425c9833d2a" translate="yes" xml:space="preserve">
          <source>The statement that begins with &lt;code&gt;if constexpr&lt;/code&gt; is known as the</source>
          <target state="translated">La declaraci&amp;oacute;n que comienza con &lt;code&gt;if constexpr&lt;/code&gt; se conoce como</target>
        </trans-unit>
        <trans-unit id="8d7a45218be20de00c71ea80e61b6068a9ec7bbd" translate="yes" xml:space="preserve">
          <source>The static data members &lt;code&gt;nom&lt;/code&gt; and &lt;code&gt;den&lt;/code&gt; representing the numerator and denominator are calculated by dividing &lt;code&gt;Num&lt;/code&gt; and &lt;code&gt;Denom&lt;/code&gt; by their greatest common divisor. However, two &lt;code&gt;std::ratio&lt;/code&gt; with different &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; are distinct types even if they represent the same rational number (after reduction). A &lt;code&gt;ratio&lt;/code&gt; type can be reduced to the lowest terms via its &lt;code&gt;type&lt;/code&gt; member: &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; is &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Los miembros de datos est&amp;aacute;ticos &lt;code&gt;nom&lt;/code&gt; y &lt;code&gt;den&lt;/code&gt; que representan el numerador y el denominador se calculan dividiendo &lt;code&gt;Num&lt;/code&gt; y &lt;code&gt;Denom&lt;/code&gt; por su m&amp;aacute;ximo divisor com&amp;uacute;n. Sin embargo, dos &lt;code&gt;std::ratio&lt;/code&gt; con &lt;code&gt;Num&lt;/code&gt; o &lt;code&gt;Denom&lt;/code&gt; diferentes son tipos distintos incluso si representan el mismo n&amp;uacute;mero racional (despu&amp;eacute;s de la reducci&amp;oacute;n). Un tipo de &lt;code&gt;ratio&lt;/code&gt; puede reducirse a los t&amp;eacute;rminos m&amp;aacute;s bajos a trav&amp;eacute;s de su miembro de &lt;code&gt;type&lt;/code&gt; : &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; es &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0f731b0d49e9b2f3318f0fcd7bbe6ca8c907339" translate="yes" xml:space="preserve">
          <source>The status of the file referred to by the entry.</source>
          <target state="translated">El estado del archivo al que se refiere la entrada.</target>
        </trans-unit>
        <trans-unit id="6e3ebc55efb178a42fb9d7d48d59cf130b8a23d3" translate="yes" xml:space="preserve">
          <source>The status of the pending recursion flag can be queried with &lt;a href=&quot;recursion_pending&quot;&gt;&lt;code&gt;recursion_pending()&lt;/code&gt;&lt;/a&gt;, which is &lt;code&gt;false&lt;/code&gt; after this call. It is reset back to &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;increment&quot;&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/a&gt;, and its initial value is also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">El estado del indicador de recursi&amp;oacute;n pendiente se puede consultar con &lt;a href=&quot;recursion_pending&quot;&gt; &lt;code&gt;recursion_pending()&lt;/code&gt; &lt;/a&gt; , que es &lt;code&gt;false&lt;/code&gt; despu&amp;eacute;s de esta llamada. Se restablece a &lt;code&gt;true&lt;/code&gt; despu&amp;eacute;s del &lt;a href=&quot;increment&quot;&gt; &lt;code&gt;increment&lt;/code&gt; o&lt;/a&gt; , y su valor inicial tambi&amp;eacute;n es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb43bc5c74e77ae80142a18f784fbac3e0c33b7" translate="yes" xml:space="preserve">
          <source>The stem of the filename identified by the path (i.e. the filename without the final extension).</source>
          <target state="translated">El tallo del nombre de archivo identificado por el camino (es decir,el nombre de archivo sin la extensión final).</target>
        </trans-unit>
        <trans-unit id="11590b2e7256668527e3216f99ac4fd9c7a4d00b" translate="yes" xml:space="preserve">
          <source>The storage class specifiers are a part of the decl-specifier-seq of a name's &lt;a href=&quot;declarations&quot;&gt;declaration syntax&lt;/a&gt;. Together with the &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; of the name, they control two independent properties of the name: its</source>
          <target state="translated">Los especificadores de clase de almacenamiento son parte de la decl-specifier-seq de la &lt;a href=&quot;declarations&quot;&gt;sintaxis de declaraci&amp;oacute;n&lt;/a&gt; de un nombre . Junto con el &lt;a href=&quot;scope&quot;&gt;alcance&lt;/a&gt; del nombre, controlan dos propiedades independientes del nombre: su</target>
        </trans-unit>
        <trans-unit id="2f39d087c3a629b33b3a42976145e493b6fa58f5" translate="yes" xml:space="preserve">
          <source>The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is cheaper than the expansion of a &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; because it does not involve copying of the existing elements to a new memory location. On the other hand, deques typically have large minimal memory cost; a deque holding just one element has to allocate its full internal array (e.g. 8 times the object size on 64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).</source>
          <target state="translated">El almacenamiento de una deque se expande y contrae autom&amp;aacute;ticamente seg&amp;uacute;n sea necesario. La expansi&amp;oacute;n de una deque es m&amp;aacute;s barata que la expansi&amp;oacute;n de un &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; porque no implica la copia de los elementos existentes en una nueva ubicaci&amp;oacute;n de memoria. Por otro lado, los deques suelen tener un costo m&amp;iacute;nimo de memoria grande; una deque que contiene solo un elemento tiene que asignar su matriz interna completa (por ejemplo, 8 veces el tama&amp;ntilde;o del objeto en libstdc ++ de 64 bits; 16 veces el tama&amp;ntilde;o del objeto o 4096 bytes, lo que sea mayor, en libc ++ de 64 bits).</target>
        </trans-unit>
        <trans-unit id="b072292a5a1e2322c8e92bfdf268810f5282c203" translate="yes" xml:space="preserve">
          <source>The storage of the vector is handled automatically, being expanded and contracted as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; function.  Extra memory can be returned to the system via a call to &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;.(since C++11).</source>
          <target state="translated">El almacenamiento del vector se maneja autom&amp;aacute;ticamente, expandi&amp;eacute;ndose y contray&amp;eacute;ndose seg&amp;uacute;n sea necesario. Los vectores generalmente ocupan m&amp;aacute;s espacio que los arreglos est&amp;aacute;ticos, porque se asigna m&amp;aacute;s memoria para manejar el crecimiento futuro. De esta manera, un vector no necesita reasignarse cada vez que se inserta un elemento, sino solo cuando se agota la memoria adicional. La cantidad total de memoria asignada se puede consultar utilizando la funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; . Se puede devolver memoria adicional al sistema mediante una llamada a &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; . (Desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="5892901fc4af7c4daeffcdff331dcbef5c156bb6" translate="yes" xml:space="preserve">
          <source>The stored callable object is called the</source>
          <target state="translated">El objeto llamable almacenado se llama</target>
        </trans-unit>
        <trans-unit id="80952d2ca5513e2ab7bc4e81a28581ccd51f605f" translate="yes" xml:space="preserve">
          <source>The stored deleter object.</source>
          <target state="translated">El objeto deletéreo almacenado.</target>
        </trans-unit>
        <trans-unit id="17b16ef531268271e85ec6f43ec173d4f90c59ff" translate="yes" xml:space="preserve">
          <source>The stored duration.</source>
          <target state="translated">La duración almacenada.</target>
        </trans-unit>
        <trans-unit id="09a69b97d4bafa467ed76343a615b25a40c0cb70" translate="yes" xml:space="preserve">
          <source>The stored error category.</source>
          <target state="translated">La categoría de error almacenada.</target>
        </trans-unit>
        <trans-unit id="2281cefb9cf8d901883c448695a82804629a024b" translate="yes" xml:space="preserve">
          <source>The stored error code.</source>
          <target state="translated">El código de error almacenado.</target>
        </trans-unit>
        <trans-unit id="8af42892a4e54ba3e506e55de93429bf0536f70e" translate="yes" xml:space="preserve">
          <source>The stored pointer.</source>
          <target state="translated">El puntero almacenado.</target>
        </trans-unit>
        <trans-unit id="433b5f42f978f29dcfd09128154cee8fea3f71e9" translate="yes" xml:space="preserve">
          <source>The stored reference.</source>
          <target state="translated">La referencia almacenada.</target>
        </trans-unit>
        <trans-unit id="6c6f751d334cb9f8c0297588312a1852b3d27541" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">La tarea almacenada ya ha sido invocada. La categor&amp;iacute;a de error se establece en &lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4df572d2c0e354b7f394388b3d124d21e95f48d8" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;code&gt;promise_already_satisfied&lt;/code&gt;.</source>
          <target state="translated">La tarea almacenada ya ha sido invocada. La categor&amp;iacute;a de error se establece en &lt;code&gt;promise_already_satisfied&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="657cc28deb3f80f24e72e3ed2e272bb85d039858" translate="yes" xml:space="preserve">
          <source>The stream-based I/O library uses &lt;a href=&quot;io/manip&quot;&gt; I/O manipulators&lt;/a&gt; (e.g. &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt;, etc.) to control how streams behave.</source>
          <target state="translated">La biblioteca de E / S basada en secuencias utiliza &lt;a href=&quot;io/manip&quot;&gt;manipuladores de E / S&lt;/a&gt; (por ejemplo, &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt; , etc.) para controlar c&amp;oacute;mo se comportan las secuencias.</target>
        </trans-unit>
        <trans-unit id="f1f8e1bf31666f17d818c7fb3629dbe63dce8038" translate="yes" xml:space="preserve">
          <source>The stream-based input/output library is organized around abstract input/output devices. These abstract devices allow the same code to handle input/output to files, memory streams, or custom adaptor devices that perform arbitrary operations (e.g. compression) on the fly.</source>
          <target state="translated">La biblioteca de entrada/salida basada en la corriente se organiza en torno a dispositivos abstractos de entrada/salida.Estos dispositivos abstractos permiten que el mismo código maneje la entrada/salida a archivos,flujos de memoria o dispositivos adaptadores personalizados que realizan operaciones arbitrarias (por ejemplo,la compresión)sobre la marcha.</target>
        </trans-unit>
        <trans-unit id="685e0728588ef7b354ca6ae06a3e39b651660d7d" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the streambuf argument is a null pointer or if no characters were inserted into the streambuf.</source>
          <target state="translated">La sobrecarga de &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt; de basic_istream :: operator &amp;gt;&amp;gt; si el argumento streambuf es un puntero nulo o si no se insertaron caracteres en el streambuf.</target>
        </trans-unit>
        <trans-unit id="2d18ba3c4f605fc8501feb5b3351b46aa1577fcc" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; if the function inserts no characters.</source>
          <target state="translated">La sobrecarga de &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; de basic_ostream :: operator &amp;lt;&amp;lt; si la funci&amp;oacute;n no inserta caracteres.</target>
        </trans-unit>
        <trans-unit id="1ef23ffa702914245f81e5026dac9d4ebc2e587a" translate="yes" xml:space="preserve">
          <source>The string converted to the specified floating point type.</source>
          <target state="translated">La cadena convertida al tipo de punto flotante especificado.</target>
        </trans-unit>
        <trans-unit id="47c093236b31b3a204fe8f923fb21ca46aefe47b" translate="yes" xml:space="preserve">
          <source>The string converted to the specified signed integer type.</source>
          <target state="translated">La cadena convertida al tipo entero con signo especificado.</target>
        </trans-unit>
        <trans-unit id="ce8f7eeb006b0c3d2b2b94eccb0b5ba0bb13623e" translate="yes" xml:space="preserve">
          <source>The string converted to the specified unsigned integer type.</source>
          <target state="translated">La cadena convertida al tipo entero sin signo especificado.</target>
        </trans-unit>
        <trans-unit id="90cd8c741b9656548cd7c47ccb8f4e7b236d4d51" translate="yes" xml:space="preserve">
          <source>The string input function &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; if it completes by reaching the end of the stream, as opposed to reaching the specified terminating character.</source>
          <target state="translated">La funci&amp;oacute;n de entrada de cadena &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; si se completa al llegar al final de la secuencia, en lugar de alcanzar el car&amp;aacute;cter de terminaci&amp;oacute;n especificado.</target>
        </trans-unit>
        <trans-unit id="fe144c3255daec881252d2a4f155b9abf0e72d73" translate="yes" xml:space="preserve">
          <source>The string library also provides class template &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; that defines types and functions for &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;(since C++17). The following specializations are defined:</source>
          <target state="translated">La biblioteca de cadenas tambi&amp;eacute;n proporciona plantillas de clase &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; que definen tipos y funciones para &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; (desde C ++ 17). Se definen las siguientes especializaciones:</target>
        </trans-unit>
        <trans-unit id="7a1c4ed4b5630d5ddaa1db0afbceba65c0447876" translate="yes" xml:space="preserve">
          <source>The string literal.</source>
          <target state="translated">El literal de la cuerda.</target>
        </trans-unit>
        <trans-unit id="fe351b72d36bc72e8b0524c53861ac272e34795a" translate="yes" xml:space="preserve">
          <source>The string of type &lt;code&gt;string_type&lt;/code&gt; holding the characters to be used as positive or negative sign.</source>
          <target state="translated">La cadena de tipo &lt;code&gt;string_type&lt;/code&gt; que contiene los caracteres que se utilizar&amp;aacute;n como signo positivo o negativo.</target>
        </trans-unit>
        <trans-unit id="645bada75f5704a14a70ee6b3ad9c4dbbc4a0cd1" translate="yes" xml:space="preserve">
          <source>The string transformed so that lexicographic comparison of the transformed strings may be used instead of collating of the originals. In the &quot;C&quot; locale, the returned string is the exact copy of &lt;code&gt;[low, high)&lt;/code&gt;. In other locales, the contents of the returned string are implementation-defined, and the size may be considerably longer.</source>
          <target state="translated">La cadena se transform&amp;oacute; para que se pueda utilizar la comparaci&amp;oacute;n lexicogr&amp;aacute;fica de las cadenas transformadas en lugar de cotejar los originales. En la configuraci&amp;oacute;n regional &quot;C&quot;, la cadena devuelta es la copia exacta de &lt;code&gt;[low, high)&lt;/code&gt; . En otras configuraciones regionales, el contenido de la cadena devuelta est&amp;aacute; definido por la implementaci&amp;oacute;n, y el tama&amp;ntilde;o puede ser considerablemente m&amp;aacute;s largo.</target>
        </trans-unit>
        <trans-unit id="bed8f4fdf0727af913eee7d7f8de3facf8e379a9" translate="yes" xml:space="preserve">
          <source>The string_literal is typically a short program written in assembly language, which is executed whenever this declaration is executed. Different C++ compilers have wildly varying rules for asm-declarations, and different conventions for the interaction with the surrounding C++ code.</source>
          <target state="translated">El string_literal es típicamente un programa corto escrito en lenguaje ensamblador,que se ejecuta siempre que se ejecuta esta declaración.Los diferentes compiladores de C++tienen reglas muy variadas para las declaraciones asm,y diferentes convenciones para la interacción con el código C++circundante.</target>
        </trans-unit>
        <trans-unit id="f3fd3bc3bb5bbc2174bee8f5c8d22f3d7dbcda9d" translate="yes" xml:space="preserve">
          <source>The string_view literal.</source>
          <target state="translated">El literal &quot;string_view&quot;.</target>
        </trans-unit>
        <trans-unit id="9ed1cae434c8ab95486c8c0f6cf75e8ebd7662a2" translate="yes" xml:space="preserve">
          <source>The struct combines the performance and accessibility of a C-style array with the benefits of a standard container, such as knowing its own size, supporting assignment, random access iterators, etc.</source>
          <target state="translated">La estructura combina el rendimiento y la accesibilidad de una matriz de estilo C con los beneficios de un contenedor estándar,como el conocimiento de su propio tamaño,la asignación de apoyo,los iteradores de acceso aleatorio,etc.</target>
        </trans-unit>
        <trans-unit id="771b48d395936f4ddd7641ad97ebda6634abdf95" translate="yes" xml:space="preserve">
          <source>The subscript operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador de subíndice tienen la forma.</target>
        </trans-unit>
        <trans-unit id="1ee3ffed03585e5f9ff776a096eb8348d437e9c7" translate="yes" xml:space="preserve">
          <source>The substitution of template arguments into a requires-expression used in a declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt; may result in the formation of invalid types or expressions in its requirements, or the violation of semantic constraints of those requirements. In such cases, the requires-expression evaluates to &lt;code&gt;false&lt;/code&gt; and does not cause the program to be ill-formed. The substitution and semantic constraint checking proceeds in lexical order and stops when a condition that determines the result of the requires-expression is encountered. If substitution (if any) and semantic constraint checking succeed, the requires-expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">La sustituci&amp;oacute;n de argumentos de plantilla en una expresi&amp;oacute;n requerida utilizada en una declaraci&amp;oacute;n de una &lt;a href=&quot;templates#Templated_entity&quot;&gt;entidad con plantilla&lt;/a&gt; puede dar como resultado la formaci&amp;oacute;n de tipos o expresiones no v&amp;aacute;lidos en sus requisitos, o la violaci&amp;oacute;n de las restricciones sem&amp;aacute;nticas de esos requisitos. En tales casos, la expresi&amp;oacute;n requerida se eval&amp;uacute;a como &lt;code&gt;false&lt;/code&gt; y no hace que el programa est&amp;eacute; mal formado. La verificaci&amp;oacute;n de sustituci&amp;oacute;n y restricci&amp;oacute;n sem&amp;aacute;ntica se realiza en orden l&amp;eacute;xico y se detiene cuando se encuentra una condici&amp;oacute;n que determina el resultado de la expresi&amp;oacute;n requerida. Si la sustituci&amp;oacute;n (si existe) y la comprobaci&amp;oacute;n de restricciones sem&amp;aacute;nticas tienen &amp;eacute;xito, la expresi&amp;oacute;n requerida se eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2246f7cf19b24f35ba44d7128f9f00cdf8cea437" translate="yes" xml:space="preserve">
          <source>The sum of the elements.</source>
          <target state="translated">La suma de los elementos.</target>
        </trans-unit>
        <trans-unit id="89d93f088c99aca77c5be8b564b1d94b144b5b67" translate="yes" xml:space="preserve">
          <source>The sum of the returned value and the value stored in &lt;code&gt;*iptr&lt;/code&gt; gives &lt;code&gt;x&lt;/code&gt; (allowing for rounding).</source>
          <target state="translated">La suma del valor devuelto y el valor almacenado en &lt;code&gt;*iptr&lt;/code&gt; da &lt;code&gt;x&lt;/code&gt; (permitiendo el redondeo).</target>
        </trans-unit>
        <trans-unit id="ff4ca6cf4d2e109c127290c18455fd2a7491a92c" translate="yes" xml:space="preserve">
          <source>The supplied lock &lt;code&gt;lk&lt;/code&gt; is held until the thread exits. Once this function has been called, no more threads may acquire the same lock in order to wait on &lt;code&gt;cond&lt;/code&gt;. If some thread is waiting on this condition variable, it should not attempt to release and reacquire the lock when it wakes up spuriously.</source>
          <target state="translated">El bloqueo suministrado &lt;code&gt;lk&lt;/code&gt; se mantiene hasta que sale el hilo. Una vez que se ha llamado a esta funci&amp;oacute;n, no m&amp;aacute;s subprocesos pueden adquirir el mismo bloqueo para esperar en &lt;code&gt;cond&lt;/code&gt; . Si alg&amp;uacute;n subproceso est&amp;aacute; esperando esta variable de condici&amp;oacute;n, no debe intentar liberar y volver a adquirir el bloqueo cuando se despierte de manera espuria.</target>
        </trans-unit>
        <trans-unit id="e9ad164a9bae7d10fe5fec949515a05485fa2d71" translate="yes" xml:space="preserve">
          <source>The supplied version of the header &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; shall declare at least the functions &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;utility/program/quick_exit&quot;&gt;std::quick_exit&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="translated">La versi&amp;oacute;n suministrada del encabezado &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; declarar&amp;aacute; al menos las funciones &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;utility/program/quick_exit&quot;&gt;std::quick_exit&lt;/a&gt;&lt;/code&gt; (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="5b99d0c2b824af433d36c158441c754d3faf4148" translate="yes" xml:space="preserve">
          <source>The swap functions do not invalidate any of the iterators inside the container, but they do invalidate the iterator marking the end of the swap region.</source>
          <target state="translated">Las funciones de intercambio no invalidan ninguno de los iteradores dentro del contenedor,pero sí invalidan el iterador que marca el final de la región de intercambio.</target>
        </trans-unit>
        <trans-unit id="21c84344f10b85ba83941112b65c0b80df28cba9" translate="yes" xml:space="preserve">
          <source>The synchronization is established only between the threads</source>
          <target state="translated">La sincronización se establece sólo entre los hilos</target>
        </trans-unit>
        <trans-unit id="af5a157ab893f882387e99debe5b0576aec5458b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;T object();&lt;/code&gt; does not initialize an object; it declares a function that takes no arguments and returns &lt;code&gt;T&lt;/code&gt;. The way to value-initialize a named variable before C++11 was &lt;code&gt;T object = T();&lt;/code&gt;, which value-initializes a temporary and then copy-initializes the object: most compilers &lt;a href=&quot;copy_elision&quot;&gt;optimize out the copy&lt;/a&gt; in this case.</source>
          <target state="translated">La sintaxis &lt;code&gt;T object();&lt;/code&gt; no inicializa un objeto; se declara una funci&amp;oacute;n que no tiene argumentos y devuelve &lt;code&gt;T&lt;/code&gt; . La forma de inicializar valores de una variable nombrada antes de C ++ 11 era &lt;code&gt;T object = T();&lt;/code&gt; , cuyo valor inicializa un temporal y luego copia-inicializa el objeto: la mayor&amp;iacute;a de los compiladores &lt;a href=&quot;copy_elision&quot;&gt;optimizan la copia&lt;/a&gt; en este caso.</target>
        </trans-unit>
        <trans-unit id="ae224bb840d8d7b9d78b650bc1b03492b672c0b6" translate="yes" xml:space="preserve">
          <source>The syntax forms (3,4) are known as designated initializers: each designator must name a direct non-static data members of T, and all designators used in the expression must appear in the same order as the data members of T.</source>
          <target state="translated">Las formas sintácticas (3,4)se conocen como inicializadores designados:cada designador debe nombrar un miembro de datos no estático directo de T,y todos los designadores utilizados en la expresión deben aparecer en el mismo orden que los miembros de datos de T.</target>
        </trans-unit>
        <trans-unit id="f00bfbaecf20babfadbc5e22b52d48a548c5a848" translate="yes" xml:space="preserve">
          <source>The syntax of</source>
          <target state="translated">La sintaxis de</target>
        </trans-unit>
        <trans-unit id="6f89d606c1975f38aa5544527e8e97e16b6bb96a" translate="yes" xml:space="preserve">
          <source>The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a &lt;code&gt;(&lt;/code&gt; as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching &lt;code&gt;)&lt;/code&gt; token, skipping intervening matched pairs of left and right parentheses.</source>
          <target state="translated">La sintaxis de una invocaci&amp;oacute;n de macro similar a una funci&amp;oacute;n es similar a la sintaxis de una llamada a funci&amp;oacute;n: cada instancia del nombre de macro seguido de a &lt;code&gt;(&lt;/code&gt; como el siguiente token de preprocesamiento introduce la secuencia de tokens que se reemplaza por la lista de reemplazo. La secuencia se termina mediante la coincidencia &lt;code&gt;)&lt;/code&gt; ficha, saltar intervienen pares emparejados de par&amp;eacute;ntesis izquierdo y derecho.</target>
        </trans-unit>
        <trans-unit id="9bcf66af5c16c1977a2766c06868ed208b549d02" translate="yes" xml:space="preserve">
          <source>The syntax of a user-defined deduction guide is the syntax of a function declaration with a trailing return type, except that it uses the name of a class template as the function name:</source>
          <target state="translated">La sintaxis de una guía de deducción definida por el usuario es la sintaxis de una declaración de función con un tipo de retorno posterior,excepto que utiliza el nombre de una plantilla de clase como nombre de la función:</target>
        </trans-unit>
        <trans-unit id="de7f5913c9173da622b172081363583fac269c9b" translate="yes" xml:space="preserve">
          <source>The syntax of an individual capture in captures is.</source>
          <target state="translated">La sintaxis de una captura individual en las capturas es.</target>
        </trans-unit>
        <trans-unit id="702f4bc2e64078809bb1b5388513237231aab2e6" translate="yes" xml:space="preserve">
          <source>The system-supplied locales normally do not collate two strings as equivalent (&lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; does not return &lt;code&gt;​0​&lt;/code&gt;) if &lt;a href=&quot;../../string/basic_string/operator_cmp&quot;&gt;&lt;code&gt;basic_string::operator==&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;, but a user-installed &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet may provide different collation rules, for example, it may treat strings as equivalent if they have the same Unicode normalized form.</source>
          <target state="translated">Las locales proporcionados por el sistema normalmente no se clasifican dos cadenas como equivalente ( &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; no devuelve &lt;code&gt;​0​&lt;/code&gt; ) si &lt;a href=&quot;../../string/basic_string/operator_cmp&quot;&gt; &lt;code&gt;basic_string::operator==&lt;/code&gt; &lt;/a&gt; vuelve &lt;code&gt;false&lt;/code&gt; , sino un instalado por el usuario &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; las facetas pueden proporcionar diferentes reglas de comparaci&amp;oacute;n, por ejemplo, puede tratar cadenas como equivalentes si tienen la misma forma normalizada Unicode.</target>
        </trans-unit>
        <trans-unit id="48237f3ec26215b3606e67c0e6d68687b01822f6" translate="yes" xml:space="preserve">
          <source>The target of the symlink (which may not necessarily exist).</source>
          <target state="translated">El objetivo del enlace simbólico (que puede no existir necesariamente).</target>
        </trans-unit>
        <trans-unit id="676256b3d34d8447f5998ce9c718f12a262b3700" translate="yes" xml:space="preserve">
          <source>The template argument that can be used with a non-type template parameter can be any &lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of the type of the template parameter.</source>
          <target state="translated">El argumento de plantilla que se puede usar con un par&amp;aacute;metro de plantilla que no sea de tipo puede ser cualquier &lt;a href=&quot;constant_expression&quot;&gt;expresi&amp;oacute;n constante convertida&lt;/a&gt; del tipo del par&amp;aacute;metro de plantilla.</target>
        </trans-unit>
        <trans-unit id="50cbc99825f7a6c9a124b9687858d33d44b2131c" translate="yes" xml:space="preserve">
          <source>The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs.</source>
          <target state="translated">La plantilla puede especializarse para los iteradores definidos por el usuario,de modo que se pueda recuperar la información sobre el iterador aunque el tipo no proporcione los tipedefs habituales.</target>
        </trans-unit>
        <trans-unit id="557201976e8a00a9ece65cd2feec4760fa0f5cd2" translate="yes" xml:space="preserve">
          <source>The template function &lt;code&gt;async&lt;/code&gt; runs the function &lt;code&gt;f&lt;/code&gt; asynchronously (potentially in a separate thread which may be part of a thread pool) and returns a &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; that will eventually hold the result of that function call.</source>
          <target state="translated">La funci&amp;oacute;n de plantilla &lt;code&gt;async&lt;/code&gt; ejecuta la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; de forma asincr&amp;oacute;nica (potencialmente en un subproceso separado que puede ser parte de un grupo de subprocesos) y devuelve un &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; que finalmente contendr&amp;aacute; el resultado de esa llamada de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eff5e7944f6337f3549b2f87230ec73fcb57ba24" translate="yes" xml:space="preserve">
          <source>The template may be specialized for any user-defined &lt;code&gt;T&lt;/code&gt; type: the specialization must satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">La plantilla puede estar especializada para cualquier tipo &lt;code&gt;T&lt;/code&gt; definido por el usuario : la especializaci&amp;oacute;n debe satisfacer &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; con</target>
        </trans-unit>
        <trans-unit id="57234bb7a67c620ea3f65bd79181da8581f11c93" translate="yes" xml:space="preserve">
          <source>The template parameter &lt;code&gt;TimeZonePtr&lt;/code&gt; allows users to supply their own time zone pointer types and further customize the behavior of &lt;code&gt;zoned_time&lt;/code&gt; via &lt;code&gt;std::chrono::zoned_traits&lt;/code&gt;. Custom time zone types need not support all the operations supported by &lt;code&gt;std::chrono::time_zone&lt;/code&gt;, only those used by the functions actually called on the &lt;code&gt;zoned_time&lt;/code&gt;.</source>
          <target state="translated">El par&amp;aacute;metro de plantilla &lt;code&gt;TimeZonePtr&lt;/code&gt; permite a los usuarios proporcionar sus propios tipos de puntero de zona horaria y personalizar a&amp;uacute;n m&amp;aacute;s el comportamiento de &lt;code&gt;zoned_time&lt;/code&gt; a trav&amp;eacute;s de &lt;code&gt;std::chrono::zoned_traits&lt;/code&gt; . Los tipos de zonas horarias personalizadas no necesitan admitir todas las operaciones admitidas por &lt;code&gt;std::chrono::time_zone&lt;/code&gt; , solo aquellas utilizadas por las funciones realmente llamadas en &lt;code&gt;zoned_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="976e95956188ddd1cc5dc013bb47e40cd53b4619" translate="yes" xml:space="preserve">
          <source>The template parameter list and the template argument list of a member of a partial specialization must match the parameter list and the argument list of the partial specialization.</source>
          <target state="translated">La lista de parámetros de la plantilla y la lista de argumentos de la plantilla de un miembro de una especialización parcial deben coincidir con la lista de parámetros y la lista de argumentos de la especialización parcial.</target>
        </trans-unit>
        <trans-unit id="35c19ab099f7c63eddf13b79738caebc5d6c5994" translate="yes" xml:space="preserve">
          <source>The template parameter list may be followed by an optional &lt;a href=&quot;constraints#Requires_clauses&quot;&gt;requires-clause&lt;/a&gt; that specifies the &lt;a href=&quot;constraints&quot;&gt;constraints&lt;/a&gt; on the template arguments.</source>
          <target state="translated">La lista de par&amp;aacute;metros de la plantilla puede ir seguida de una &lt;a href=&quot;constraints#Requires_clauses&quot;&gt;cl&amp;aacute;usula obligatoria&lt;/a&gt; opcional que especifica las &lt;a href=&quot;constraints&quot;&gt;restricciones&lt;/a&gt; en los argumentos de la plantilla.</target>
        </trans-unit>
        <trans-unit id="0e09d82796b1385db8c4e7f7eb0aae7cb58e1066" translate="yes" xml:space="preserve">
          <source>The template parameter lists of template template parameters can have their own default arguments, which are only in effect where the template template parameter itself is in scope:</source>
          <target state="translated">Las listas de parámetros de la plantilla de parámetros de la plantilla pueden tener sus propios argumentos por defecto,que sólo tienen efecto cuando el propio parámetro de la plantilla está en el ámbito de aplicación:</target>
        </trans-unit>
        <trans-unit id="9b6ab43de318de05ac5e805e82ee83900637e335" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; class allows users to obtain hashes of the identifiers of threads.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para la clase &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener hash de los identificadores de hilos.</target>
        </trans-unit>
        <trans-unit id="1617c98734849159498d6d58c8ee6130545cbbf2" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b98ae6aa533d3d486ad6a1f3c3dd5a2a2cc3c3" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="189f220de4b5df21be91fb36e6e09506d95caaf2" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa82fede24ddf383b749f64c40120c7a6b969fc" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e08e96dcabc0ff66b712bd52aab0a0c10bbb4f5" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c9f3d1ec6cfcd95caae7ac3bda8cf8e03255245" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d968cfa6e1f3e875e46aac917073ba195240e6bb" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce7952ddebf3c0d01e620facea4a820fd43fa101" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; class allows users to obtain hashes of the values contained in &lt;code&gt;optional&lt;/code&gt; objects.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para la clase &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener valores hash de los valores contenidos en objetos &lt;code&gt;optional&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db5007b65d07bfed77b8824218281a413afda965" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; template allows users to obtain hashes of &lt;code&gt;variant&lt;/code&gt; objects.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para la plantilla &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos &lt;code&gt;variant&lt;/code&gt; es .</target>
        </trans-unit>
        <trans-unit id="8ddcabf8bbccc8b0c948a37b70ba7a9f9c022693" translate="yes" xml:space="preserve">
          <source>The template specializations of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the various string classes allow users to obtain hashes of strings.</source>
          <target state="translated">Las especializaciones de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para las diversas clases de cadenas permiten a los usuarios obtener hashes de cadenas.</target>
        </trans-unit>
        <trans-unit id="584921a66a2cf4fe71de6a59a91614782dd86242" translate="yes" xml:space="preserve">
          <source>The template version of this assignment operator in the specialization for arrays, &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; behaves the same as in the primary template, except that will only participate in overload resolution if all of the following is true:</source>
          <target state="translated">La versi&amp;oacute;n de plantilla de este operador de asignaci&amp;oacute;n en la especializaci&amp;oacute;n para matrices, &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; comporta igual que en la plantilla primaria, excepto que solo participar&amp;aacute; en la resoluci&amp;oacute;n de sobrecarga si se cumple todo lo siguiente:</target>
        </trans-unit>
        <trans-unit id="0ac5be2688655da010f5c804e64763bf5f3459f9" translate="yes" xml:space="preserve">
          <source>The template version of this assignment operator only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not an array type and &lt;code&gt;unique_ptr&amp;lt;U,E&amp;gt;::pointer&lt;/code&gt; is implicitly convertible to &lt;code&gt;pointer&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;Deleter&amp;amp;, E&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;(since C++17).</source>
          <target state="translated">La versi&amp;oacute;n de la plantilla de este operador de asignaci&amp;oacute;n solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;U&lt;/code&gt; no es un tipo de matriz y &lt;code&gt;unique_ptr&amp;lt;U,E&amp;gt;::pointer&lt;/code&gt; es convertible impl&amp;iacute;citamente en &lt;code&gt;pointer&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;Deleter&amp;amp;, E&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; ( desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="22030dbd3e1d3908354d7549e8f30d9f71beae72" translate="yes" xml:space="preserve">
          <source>The templated class &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; generalizes how sequences of characters are manipulated and stored. String creation, manipulation, and destruction are all handled by a convenient set of class methods and related functions.</source>
          <target state="translated">La clase con plantilla &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; generaliza c&amp;oacute;mo se manipulan y almacenan las secuencias de caracteres. La creaci&amp;oacute;n, manipulaci&amp;oacute;n y destrucci&amp;oacute;n de cadenas se manejan mediante un conjunto conveniente de m&amp;eacute;todos de clase y funciones relacionadas.</target>
        </trans-unit>
        <trans-unit id="ae2a3669d2ccc3c953612c7002da0c5821d0cf01" translate="yes" xml:space="preserve">
          <source>The templated class &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; provides a lightweight object that offers read-only access to a string or a part of a string using an interface similar to the interface of &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La clase con plantilla &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; proporciona un objeto liviano que ofrece acceso de solo lectura a una cadena o parte de una cadena usando una interfaz similar a la interfaz de &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5938eb91acf69026cdeecae1d1a114be0e7c8cbb" translate="yes" xml:space="preserve">
          <source>The temporary object is constructed from the function argument or return value, respectively, and the function's parameter or return object is initialized as if by using the non-deleted trivial constructor to copy the temporary (even if that constructor is inaccessible or would not be selected by overload resolution to perform a copy or move of the object).</source>
          <target state="translated">El objeto temporal se construye a partir del argumento de la función o del valor de retorno,respectivamente,y el parámetro de la función o el objeto de retorno se inicializa como si se utilizara el constructor trivial no eliminado para copiar el temporal (incluso si ese constructor es inaccesible o no se seleccionaría por resolución de sobrecarga para realizar una copia o un desplazamiento del objeto).</target>
        </trans-unit>
        <trans-unit id="d35cf85afe81dba05bfcd30078a13ec4b61a6248" translate="yes" xml:space="preserve">
          <source>The terminating null character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">El car&amp;aacute;cter nulo de terminaci&amp;oacute;n de &lt;code&gt;str&lt;/code&gt; no est&amp;aacute; escrito.</target>
        </trans-unit>
        <trans-unit id="0b502a26934eaa1380b44846902030ef133c5174" translate="yes" xml:space="preserve">
          <source>The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">El car&amp;aacute;cter nulo final se considera parte de la cadena y se puede encontrar si busca &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e942509d6816ccf9d123b1cf1595fd4cb7dbdb4" translate="yes" xml:space="preserve">
          <source>The terminating null wide character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">El car&amp;aacute;cter ancho nulo de terminaci&amp;oacute;n de &lt;code&gt;str&lt;/code&gt; no est&amp;aacute; escrito.</target>
        </trans-unit>
        <trans-unit id="f64c2cf450c071f73e284e57290f6f2917e30baf" translate="yes" xml:space="preserve">
          <source>The test &lt;code&gt;ptr-&amp;gt;weak_this.expired()&lt;/code&gt; in the exposition code above makes sure that &lt;code&gt;weak_this&lt;/code&gt; is not reassigned if it already indicates an owner. This test is required as of C++17.</source>
          <target state="translated">La prueba &lt;code&gt;ptr-&amp;gt;weak_this.expired()&lt;/code&gt; en el c&amp;oacute;digo de exposici&amp;oacute;n anterior se asegura de que &lt;code&gt;weak_this&lt;/code&gt; no se reasigne si ya indica un propietario. Esta prueba se requiere a partir de C ++ 17.</target>
        </trans-unit>
        <trans-unit id="a76ffdb1119a59ee47d50b27acec60df78d37530" translate="yes" xml:space="preserve">
          <source>The textual representation is written with &lt;code&gt;os.fmtflags&lt;/code&gt; set to &lt;code&gt;ios_base::dec&lt;/code&gt;|&lt;code&gt;ios_base::left&lt;/code&gt; and the fill character set to the space character. The textual representation of the engine's internal state is a set of decimal numbers separated by spaces.</source>
          <target state="translated">La representaci&amp;oacute;n textual se escribe con &lt;code&gt;os.fmtflags&lt;/code&gt; establecido en &lt;code&gt;ios_base::dec&lt;/code&gt; | &lt;code&gt;ios_base::left&lt;/code&gt; y el conjunto de caracteres de relleno al espacio. La representaci&amp;oacute;n textual del estado interno del motor es un conjunto de n&amp;uacute;meros decimales separados por espacios.</target>
        </trans-unit>
        <trans-unit id="a79d1b4a44870cfcd4b53d3f95a0c8fcc074b16b" translate="yes" xml:space="preserve">
          <source>The textual representation of &lt;code&gt;A&lt;/code&gt; includes the textual representation of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">La representaci&amp;oacute;n textual de &lt;code&gt;A&lt;/code&gt; incluye la representaci&amp;oacute;n textual de &lt;code&gt;B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="484f772cf54bb66a16db5954b6b4e3c3d93ea751" translate="yes" xml:space="preserve">
          <source>The thread that intends to modify the variable has to.</source>
          <target state="translated">El hilo que pretende modificar la variable tiene que hacerlo.</target>
        </trans-unit>
        <trans-unit id="e07534c510b6011cf58e1ef843a07565960e50d4" translate="yes" xml:space="preserve">
          <source>The three-way comparison operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador de comparación de tres vías tienen la forma.</target>
        </trans-unit>
        <trans-unit id="ab243e4025d54ef42cc354407fff2484190465e4" translate="yes" xml:space="preserve">
          <source>The throw-expression &lt;code&gt;throw &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;;&lt;/code&gt; is not guaranteed to be matched by a pointer catch clause, because the exception object type may be &lt;code&gt;int&lt;/code&gt;, but &lt;code&gt;throw nullptr;&lt;/code&gt; is assuredly matched by any pointer or pointer-to-member catch clause.</source>
          <target state="translated">La expresi&amp;oacute;n de &lt;code&gt;throw &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;;&lt;/code&gt; no se garantiza que coincida con una cl&amp;aacute;usula catch de puntero, porque el tipo de objeto de excepci&amp;oacute;n puede ser &lt;code&gt;int&lt;/code&gt; , pero &lt;code&gt;throw nullptr;&lt;/code&gt; seguramente coincide con cualquier puntero o cl&amp;aacute;usula catch de puntero a miembro.</target>
        </trans-unit>
        <trans-unit id="7ac8ab79b96ed80e6fe4f38b7019eb38273067c1" translate="yes" xml:space="preserve">
          <source>The throw-expression is classified as &lt;a href=&quot;value_category&quot;&gt;prvalue expression&lt;/a&gt; of type &lt;code&gt;void&lt;/code&gt;. Like any other expression, it may be a sub-expression in another expression, most commonly in the &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;conditional operator&lt;/a&gt;:</source>
          <target state="translated">La expresi&amp;oacute;n de lanzamiento se clasifica como &lt;a href=&quot;value_category&quot;&gt;expresi&amp;oacute;n prvalue&lt;/a&gt; de tipo &lt;code&gt;void&lt;/code&gt; . Como cualquier otra expresi&amp;oacute;n, puede ser una subexpresi&amp;oacute;n en otra expresi&amp;oacute;n, m&amp;aacute;s com&amp;uacute;nmente en el &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;operador condicional&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f868d34253cbb949d0014de0f9071a9627d84ee5" translate="yes" xml:space="preserve">
          <source>The throwing overload is additionally specified to throw &lt;code&gt;&lt;a href=&quot;filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;status(p)&lt;/code&gt; would throw.</source>
          <target state="translated">La sobrecarga de lanzamiento se especifica adicionalmente para lanzar &lt;code&gt;&lt;a href=&quot;filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; si se lanza el &lt;code&gt;status(p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc934bec30518ea798c5b7ac6343fa0fedd9880c" translate="yes" xml:space="preserve">
          <source>The tick period of the clock in seconds.</source>
          <target state="translated">El período de tictac del reloj en segundos.</target>
        </trans-unit>
        <trans-unit id="2af4361db95a4cd97928b9e845816898c3e9820b" translate="yes" xml:space="preserve">
          <source>The tied stream, or a null pointer if there was no tied stream.</source>
          <target state="translated">El arroyo atado,o un puntero nulo si no había un arroyo atado.</target>
        </trans-unit>
        <trans-unit id="a5636311e3a8dbe661c517df9ff905b4bc0cff87" translate="yes" xml:space="preserve">
          <source>The time input manipulator &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; (technically, &lt;a href=&quot;../../locale/time_get/get&quot;&gt;&lt;code&gt;time_get::get&lt;/code&gt;&lt;/a&gt; it calls), if the input cannot be unambiguously parsed as a time value according to the given format string.</source>
          <target state="translated">El manipulador de entrada de tiempo &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; (t&amp;eacute;cnicamente, &lt;a href=&quot;../../locale/time_get/get&quot;&gt; &lt;code&gt;time_get::get&lt;/code&gt; &lt;/a&gt; it llama), si la entrada no puede analizarse sin ambig&amp;uuml;edades como un valor de tiempo de acuerdo con la cadena de formato dada.</target>
        </trans-unit>
        <trans-unit id="9fa1c3ac8a91c2dbb258d7d0b1ca35724a76b047" translate="yes" xml:space="preserve">
          <source>The timeout has expired</source>
          <target state="translated">El tiempo de espera ha expirado</target>
        </trans-unit>
        <trans-unit id="cda93e07e16d4fa1f6f842ae631aef263d983dc5" translate="yes" xml:space="preserve">
          <source>The top-level scope of a translation unit (&quot;file scope&quot; or &quot;global scope&quot;) is also a namespace and is properly called &quot;global namespace scope&quot;. The potential scope of any entity declared in the global namespace scope begins at the declaration and continues to the end of the translation unit.</source>
          <target state="translated">El ámbito de nivel superior de una unidad de traducción (&quot;ámbito de archivo&quot; o &quot;ámbito global&quot;)es también un espacio de nombres y se denomina propiamente &quot;ámbito de espacio de nombres global&quot;.El posible alcance de cualquier entidad declarada en el ámbito del espacio de nombres mundial comienza en la declaración y continúa hasta el final de la unidad de traducción.</target>
        </trans-unit>
        <trans-unit id="f4b95d9b7d4331d266dae2fa32fe8fccb817c35a" translate="yes" xml:space="preserve">
          <source>The trait &lt;code&gt;std::is_copy_assignable&lt;/code&gt; is less strict than &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; because it does not check the type of the result of the assignment (which, for a &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; type, must be an lvalue of type &lt;code&gt;T&lt;/code&gt;) and does not check the semantic requirement that the argument expression remains unchanged. It also does not check that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, which is required of all &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; types.</source>
          <target state="translated">El rasgo &lt;code&gt;std::is_copy_assignable&lt;/code&gt; es menos estricto que &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; porque no verifica el tipo del resultado de la asignaci&amp;oacute;n (que, para un tipo &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , debe ser un valor de tipo &lt;code&gt;T&lt;/code&gt; ) y no verifica el requisito sem&amp;aacute;ntico del argumento la expresi&amp;oacute;n permanece sin cambios. Tampoco verifica que &lt;code&gt;T&lt;/code&gt; satisfaga &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , que se requiere de todos los tipos de &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31f748256061c85c5babfc77d3f3bd56ed39666b" translate="yes" xml:space="preserve">
          <source>The trait &lt;code&gt;std::is_move_assignable&lt;/code&gt; is less strict than &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; because it does not check the type of the result of the assignment (which, for a &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; type, must be &lt;code&gt;T&amp;amp;&lt;/code&gt;), nor the semantic requirement that the target's value after the assignment is equivalent to the source's value before the assignment.</source>
          <target state="translated">El rasgo &lt;code&gt;std::is_move_assignable&lt;/code&gt; es menos estricto que &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; porque no verifica el tipo del resultado de la asignaci&amp;oacute;n (que, para un tipo &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , debe ser &lt;code&gt;T&amp;amp;&lt;/code&gt; ), ni el requisito sem&amp;aacute;ntico de que el valor del objetivo despu&amp;eacute;s de la asignaci&amp;oacute;n sea equivalente al valor de la fuente antes de la asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c13322dcd5d602786d0d4da2697757a492c38ddc" translate="yes" xml:space="preserve">
          <source>The transformed type is a publicly accessible nested type named &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">El tipo transformado es un tipo anidado de acceso p&amp;uacute;blico denominado &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd0c6a8d80fefbf063a7c6fc4d41e35477e554e0" translate="yes" xml:space="preserve">
          <source>The transition algorithm of the LCG function is x</source>
          <target state="translated">El algoritmo de transición de la función LCG es x</target>
        </trans-unit>
        <trans-unit id="ed030a839d21fbb758c903e3966139f3e58ea684" translate="yes" xml:space="preserve">
          <source>The tuple need not be &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, and instead may be anything that supports &lt;code&gt;std::get&lt;/code&gt; and &lt;code&gt;std::tuple_size&lt;/code&gt;; in particular, &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">La tupla no necesita ser &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , y en su lugar puede ser cualquier cosa que admita &lt;code&gt;std::get&lt;/code&gt; y &lt;code&gt;std::tuple_size&lt;/code&gt; ; en particular, se pueden usar &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faab3655bae1576862bf3243d78b803053240daa" translate="yes" xml:space="preserve">
          <source>The tuple-like interpretation is always used if &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is a complete type, even if that would cause the program to be ill-formed:</source>
          <target state="translated">La interpretaci&amp;oacute;n tipo tupla siempre se usa si &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; es un tipo completo, incluso si eso causar&amp;iacute;a que el programa est&amp;eacute; mal formado:</target>
        </trans-unit>
        <trans-unit id="280f7270ad4976a06da0f10d73ed8109ee8c86a2" translate="yes" xml:space="preserve">
          <source>The two overloads are distinct because the types of the parameter &lt;code&gt;func&lt;/code&gt; are distinct (&lt;a href=&quot;../../language/language_linkage&quot;&gt;language linkage&lt;/a&gt; is part of its type).</source>
          <target state="translated">Las dos sobrecargas son distintas porque los tipos del par&amp;aacute;metro &lt;code&gt;func&lt;/code&gt; son distintos (el &lt;a href=&quot;../../language/language_linkage&quot;&gt;enlace de idioma&lt;/a&gt; es parte de su tipo).</target>
        </trans-unit>
        <trans-unit id="ced307005cb72698444581ef51d2ce693acf63e2" translate="yes" xml:space="preserve">
          <source>The two overloads provided by the C++ standard library are distinct because the types of the parameter &lt;code&gt;comp&lt;/code&gt; are distinct (&lt;a href=&quot;../language/language_linkage&quot;&gt;language linkage&lt;/a&gt; is part of its type).</source>
          <target state="translated">Los dos sobrecargas proporcionadas por la biblioteca est&amp;aacute;ndar de C ++ son distintos debido a que los tipos de par&amp;aacute;metro de &lt;code&gt;comp&lt;/code&gt; son distintos ( &lt;a href=&quot;../language/language_linkage&quot;&gt;vinculaci&amp;oacute;n lenguaje&lt;/a&gt; es parte de su tipo).</target>
        </trans-unit>
        <trans-unit id="7e0c402d18cba21bbc3c62ac427b669b87db8687" translate="yes" xml:space="preserve">
          <source>The two-way comparison operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador de comparación bidireccional tienen la forma.</target>
        </trans-unit>
        <trans-unit id="b32340d0d14dfd5d1c51dde23771404f36595788" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">El tipo &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3e4f9ee4f9a6dc679b68e252ddbe4d829628a2f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;D&lt;/code&gt; satisfies RandomNumberDistribution if.</source>
          <target state="translated">El tipo &lt;code&gt;D&lt;/code&gt; satisface RandomNumberDistribution si.</target>
        </trans-unit>
        <trans-unit id="9d9d3aa5279931f61ae09ea879f4c70a82c6ceaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;G&lt;/code&gt; satisfies UniformRandomBitGenerator if.</source>
          <target state="translated">El tipo &lt;code&gt;G&lt;/code&gt; satisface UniformRandomBitGenerator si.</target>
        </trans-unit>
        <trans-unit id="c21b37c97960f36e90434bac25ddcd2dc1e68569" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dca3e5d709f32f44d0ddfe5eab719ca4892184c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="23ab122f56da738cdd552f61aadec9d1cd833ab0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="b6b3d6cdd7d4f3c9acce01cee40f271ece634a18" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252d2ffb66f7d81557faa1f7f4f4ea09867d93b2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;destructible&quot;&gt;destructible&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="4b8f1bcfc4815dc189422b13e3981c0b3806ab7c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7e27b1e0bc61deba4ad72e16345b7759b232775" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e98de10f38832410717d032044fe5876aae1620" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19b959ec118b4fc4e346a0c4b3066583c69eb391" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e6b1f70b5515f9b7f9ece951c8b0565a4faeae3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies ConstexprIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si ConstexprIterator.</target>
        </trans-unit>
        <trans-unit id="99ec40230a473cc7e644a50a1f568278d332cce3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyBidirectionalIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyBidirectionalIterator.</target>
        </trans-unit>
        <trans-unit id="fb470c2619e1df677c704caef889c4118fc3151e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyContiguousIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyContiguousIterator.</target>
        </trans-unit>
        <trans-unit id="630cbbc2820c720d8b04165d105e0a9744bea443" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyForwardIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyForwardIterator.</target>
        </trans-unit>
        <trans-unit id="0ffbcd885e9525a21db6be67dd85f4aff0c605f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyInputIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyInputIterator.</target>
        </trans-unit>
        <trans-unit id="98c67370e8cebdd88c142031ae165afb773d121a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyIterator.</target>
        </trans-unit>
        <trans-unit id="685b9ef2517672d40d4de466c9757d30ae0a366e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyRandomAccessIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyRandomAccessIterator.</target>
        </trans-unit>
        <trans-unit id="c0271171a00bcc035de12ccb951df5f4eb58be30" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies some iterator requirements MeowIterator</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface algunos requisitos iterador MeowIterator</target>
        </trans-unit>
        <trans-unit id="3fa432a57da4f847b5c070a3bfc7c01c5763011a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;ForwardIt&lt;/code&gt; pueda ser desreferenciado y se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3a1ebcc723e658952997b5498f82af157e85e51" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;OutputIt&lt;/code&gt; pueda ser desreferenciado y se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="949b21cde2cc2392d063407c9e220c78be2ec5c8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;CopyInsertable&lt;/strong&gt; into the container &lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt;, and, given.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; es &lt;strong&gt;CopyInsertable&lt;/strong&gt; en el contenedor &lt;code&gt;X&lt;/code&gt; cuyo &lt;code&gt;value_type&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;T&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; en &lt;code&gt;X&lt;/code&gt; , y, dado.</target>
        </trans-unit>
        <trans-unit id="3d96c921cf6324f16eef56dd97bb17fac1318864" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;DefaultInsertable&lt;/strong&gt; into the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; es &lt;strong&gt;DefaultInsertable&lt;/strong&gt; en el &lt;a href=&quot;container&quot;&gt;contenedor &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; cuyo &lt;code&gt;value_type&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;T&lt;/code&gt; si, dado.</target>
        </trans-unit>
        <trans-unit id="4a2192b55df7721f52fc4a376a8910667373086e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;EmplaceConstructible&lt;/strong&gt; into the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; (whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt;) from the arguments &lt;code&gt;args&lt;/code&gt; if, given.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; es &lt;strong&gt;EmplaceConstructible&lt;/strong&gt; en el &lt;a href=&quot;container&quot;&gt;contenedor &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; (cuyo &lt;code&gt;value_type&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;T&lt;/code&gt; ) de los argumentos &lt;code&gt;args&lt;/code&gt; if, dado.</target>
        </trans-unit>
        <trans-unit id="5237f2595087683918faff0e0fb827167c77ec98" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;Erasable&lt;/strong&gt; from the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; es &lt;strong&gt;borrable&lt;/strong&gt; del &lt;a href=&quot;container&quot;&gt;contenedor &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; cuyo &lt;code&gt;value_type&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;T&lt;/code&gt; si, dado.</target>
        </trans-unit>
        <trans-unit id="7c4f49cd45501a79870e1b3afa64d91ff0308500" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;MoveInsertable&lt;/strong&gt; into the container &lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; es &lt;strong&gt;MoveInsertable&lt;/strong&gt; en el contenedor &lt;code&gt;X&lt;/code&gt; cuyo &lt;code&gt;value_type&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;T&lt;/code&gt; si, dado.</target>
        </trans-unit>
        <trans-unit id="0e41120cbb6ece4723895cfa12eeda9a968c6032" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is not allowed to be an &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, even if the size or internal structure of &lt;code&gt;T&lt;/code&gt; is never used, as in &lt;code&gt;&amp;amp;x[0]&lt;/code&gt;.</source>
          <target state="translated">No se permite que el tipo &lt;code&gt;T&lt;/code&gt; sea ​​un &lt;a href=&quot;incomplete_type&quot;&gt;tipo incompleto&lt;/a&gt; , incluso si el tama&amp;ntilde;o o la estructura interna de &lt;code&gt;T&lt;/code&gt; nunca se usa, como en &lt;code&gt;&amp;amp;x[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94188845ce20ed55f2a876e3342aa84bc7330295" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="4d4404ddfa538ff7555e67eecb1dbcc3ff5cdc1a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;, &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt; , &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt; y</target>
        </trans-unit>
        <trans-unit id="0db4b9570ecd95be9606704e9f21eff1149143a0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="6647adc652b8dbbc01016470d35eed7d2fe7e630" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface &lt;a href=&quot;moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="4262127f8a223198cec9f54e58d1717c6a50c453" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object&lt;/a&gt;&lt;/code&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object&lt;/a&gt;&lt;/code&gt; , y</target>
        </trans-unit>
        <trans-unit id="3f046e47e7505811e9555f3b245d7d20697f7a3e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Callable if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface Callable if.</target>
        </trans-unit>
        <trans-unit id="49e6eff2866df130bb7fd318296a16096d51e92f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Compare if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface Compare if.</target>
        </trans-unit>
        <trans-unit id="66ff21aa578ecf4f62632269d8614fbe18a110bb" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies CopyAssignable if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface CopyAssignable si.</target>
        </trans-unit>
        <trans-unit id="0ad2a77779033cb383bdf5ceddef00240ba13b76" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies CopyConstructible if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface CopyConstructible si.</target>
        </trans-unit>
        <trans-unit id="2e05ec58d3dab38ca771379d16b2fe5adee88104" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies DefaultConstructible if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface DefaultConstructible if.</target>
        </trans-unit>
        <trans-unit id="cc55fbe4fbf6e0f85ba467734b5b915583f84e1b" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Destructible if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface Destructible if.</target>
        </trans-unit>
        <trans-unit id="dfe96628803d13e4d50a5465ce9ed6a67992a048" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies EqualityComparable if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface EqualityComparable if.</target>
        </trans-unit>
        <trans-unit id="41ee5c2d1ddb0009a5b5ac10f88ce89d5cc10e9a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies FunctionObject if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface FunctionObject if.</target>
        </trans-unit>
        <trans-unit id="3ae67a347ab32c589872346530c83699208f4eaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Hash if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface Hash si.</target>
        </trans-unit>
        <trans-unit id="9d2af4bf93a9ceba9a70379149efdadf03a56bc7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies LessThanComparable if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface LessThanComparable if.</target>
        </trans-unit>
        <trans-unit id="52a749029f41bfcab44646101c78f08a559bdcdd" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies MoveAssignable if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface MoveAssignable si.</target>
        </trans-unit>
        <trans-unit id="aaf38d3e0ca9bb3163280eb3190656f5f78d0b7e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies MoveConstructible if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface MoveConstructible si.</target>
        </trans-unit>
        <trans-unit id="3c095863553c4d9f9528e17b876f6565ea71dc1e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;TC::time_point::clock&lt;/code&gt; meets the TrivialClock requirements, recursively.</source>
          <target state="translated">El tipo &lt;code&gt;TC::time_point::clock&lt;/code&gt; cumple los requisitos de TrivialClock, de forma recursiva.</target>
        </trans-unit>
        <trans-unit id="8c5bdf5c0ebdfaea70c628010c98d8c02bdb6a1e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type1&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;ForwardIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a &lt;code&gt;Type1&lt;/code&gt; . El tipo &lt;code&gt;Type2&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;T&lt;/code&gt; pueda convertirse impl&amp;iacute;citamente en &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76589c2d20456a54480cd63abef696cc4671a0d0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type1&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;T&lt;/code&gt; pueda convertirse impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; . El tipo &lt;code&gt;Type2&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;ForwardIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e15c34b8b5699cfcccd67dddcde261f5330e1e3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type1&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;T&lt;/code&gt; pueda convertirse impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; . El tipo &lt;code&gt;Type2&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;InputIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a &lt;code&gt;Type2&lt;/code&gt; . El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que a un objeto de tipo &lt;code&gt;T&lt;/code&gt; se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c7c828977f3aee5181d50399292252dea34b2f7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type1&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; pueda convertirse impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; . El tipo &lt;code&gt;Type2&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;InputIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a &lt;code&gt;Type2&lt;/code&gt; . El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que a un objeto de tipo &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="446f611669a83b2fef5ed0fe51541c392716bba5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;Type&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;InputIt&lt;/code&gt; pueda ser desreferenciado y luego impl&amp;iacute;citamente convertido a &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a83e5bd1fdfaaf9d85e03162ceb874df7fc25ab" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;InputIt&lt;/code&gt; pueda ser desreferenciado y luego impl&amp;iacute;citamente convertido a &lt;code&gt;Type&lt;/code&gt; . El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;OutputIt&lt;/code&gt; pueda ser desreferenciado y se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f2ee2c7e39e16c2fc94f6e2cd419b938a6ba925" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;double&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;double&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;double&lt;/code&gt; pueda ser desreferenciado y luego impl&amp;iacute;citamente convertido a &lt;code&gt;Type&lt;/code&gt; . El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que se pueda desreferenciar un objeto de tipo &lt;code&gt;double&lt;/code&gt; y asignarle un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b435ca7efbcb7d3a69a4c425c8166ae1ecf9b3b8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface el &lt;a href=&quot;container&quot;&gt;contenedor&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51c4cd0302a38d9ca2d378e53146319f03ed2267" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface el &lt;a href=&quot;container&quot;&gt;Contenedor&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="6607d21d863fd1139823f255f3616f78582f1b99" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd2220d4e7d2be0a6e2436dc20ed5fc81f925717" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies ContiguousContainer if.</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface ContiguousContainer si.</target>
        </trans-unit>
        <trans-unit id="9c59f17268ae0799c6c9ad4a2f510730b7974007" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies LegacyOutputIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface LegacyOutputIterator si.</target>
        </trans-unit>
        <trans-unit id="4ce304e60343f172de9a358f8aec0594d119616e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies SequenceContainer if.</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface SequenceContainer si.</target>
        </trans-unit>
        <trans-unit id="0b0a4238d5b55da548fec0c52f2f145ef62aca2f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; supports &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; es compatible con &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c91c4098ab4ce6057b1eb103c2691ca5d989b78" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; must be exactly</source>
          <target state="translated">El tipo &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; debe ser exactamente</target>
        </trans-unit>
        <trans-unit id="3d90dab02f7f3b6e43e81a90b17cf46259c35fe4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::negation&amp;lt;B&amp;gt;&lt;/code&gt; is a &lt;a href=&quot;../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with a BaseCharacteristic of &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::bool_constant&lt;/a&gt;&amp;lt;!bool(B::value)&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;std::negation&amp;lt;B&amp;gt;&lt;/code&gt; &lt;a href=&quot;../named_req/unarytypetrait&quot;&gt;negation &lt;/a&gt;&amp;lt;B&amp;gt; es un UnaryTypeTrait con una BaseCharacteristic de &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::bool_constant&lt;/a&gt;&amp;lt;!bool(B::value)&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83883f03d07c1a12ee9dfb5e67e0fc6f4a49f177" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::partial_ordering&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">El tipo &lt;code&gt;std::partial_ordering&lt;/code&gt; tiene cuatro valores v&amp;aacute;lidos, implementados como miembros de datos est&amp;aacute;ticos constantes de su tipo:</target>
        </trans-unit>
        <trans-unit id="baf068b5f9f0a2f3a687379dab87c44a84ac79f2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::streamoff&lt;/code&gt; is a signed integral type of sufficient size to represent the maximum possible file size supported by the operating system. Typically, this is a typedef to &lt;code&gt;long long&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;std::streamoff&lt;/code&gt; es un tipo integral con signo de tama&amp;ntilde;o suficiente para representar el tama&amp;ntilde;o m&amp;aacute;ximo posible de archivo admitido por el sistema operativo. Por lo general, este es un typedef a &lt;code&gt;long long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="081a86b87857472711ceb628824320cbad10918c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::streamsize&lt;/code&gt; is a signed integral type used to represent the number of characters transferred in an I/O operation or the size of an I/O buffer. It is used as a signed counterpart of &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, similar to the POSIX type &lt;code&gt;ssize_t&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;std::streamsize&lt;/code&gt; es un tipo integral con signo que se utiliza para representar el n&amp;uacute;mero de caracteres transferidos en una operaci&amp;oacute;n de E / S o el tama&amp;ntilde;o de un b&amp;uacute;fer de E / S. Se utiliza como una contraparte firmada de &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , similar al tipo POSIX &lt;code&gt;ssize_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35bd4cec907f3b6ac35655e3dc99fe6dc74b2c63" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::strong_equality&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">El tipo &lt;code&gt;std::strong_equality&lt;/code&gt; tiene cuatro valores v&amp;aacute;lidos, implementados como miembros de datos est&amp;aacute;ticos constantes de su tipo:</target>
        </trans-unit>
        <trans-unit id="d1fa9bb7b57f78a76b739de735267fbd796b77b7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::strong_ordering&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">El tipo &lt;code&gt;std::strong_ordering&lt;/code&gt; tiene cuatro valores v&amp;aacute;lidos, implementados como miembros de datos est&amp;aacute;ticos constantes de su tipo:</target>
        </trans-unit>
        <trans-unit id="caaff90770bed5d2d4f0c217a33a582a915365ac" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::weak_equality&lt;/code&gt; has only two valid values, implemented as const static data members of its type: &lt;code&gt;std::weak_equality::equivalent&lt;/code&gt; and &lt;code&gt;std::weak_equality::nonequivalent&lt;/code&gt;:</source>
          <target state="translated">El tipo &lt;code&gt;std::weak_equality&lt;/code&gt; tiene solo dos valores v&amp;aacute;lidos, implementados como miembros de datos est&amp;aacute;ticos constantes de su tipo: &lt;code&gt;std::weak_equality::equivalent&lt;/code&gt; y &lt;code&gt;std::weak_equality::nonequivalent&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5b1a20430a83aa89500e66ebd1c9900c5d380b9b" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::weak_ordering&lt;/code&gt; has three valid values, implemented as const static data members of its type:</source>
          <target state="translated">El tipo &lt;code&gt;std::weak_ordering&lt;/code&gt; tiene tres valores v&amp;aacute;lidos, implementados como miembros de datos est&amp;aacute;ticos constantes de su tipo:</target>
        </trans-unit>
        <trans-unit id="eea5d0d3527e4ae7b88635106c278af003375133" translate="yes" xml:space="preserve">
          <source>The type T may be an incomplete type.</source>
          <target state="translated">El tipo T puede ser un tipo incompleto.</target>
        </trans-unit>
        <trans-unit id="47e3c39ad9f26d80f148e942aab053b6361ba66e" translate="yes" xml:space="preserve">
          <source>The type allows subnormal values</source>
          <target state="translated">El tipo permite valores subnormales</target>
        </trans-unit>
        <trans-unit id="89d3d7da193a1958b43f17239e6e96abc49dd3f5" translate="yes" xml:space="preserve">
          <source>The type and value category of the conditional expression &lt;code&gt;E1 ? E2 : E3&lt;/code&gt; are determined according to the following rules:</source>
          <target state="translated">El tipo y la categor&amp;iacute;a de valor de la expresi&amp;oacute;n condicional &lt;code&gt;E1 ? E2 : E3&lt;/code&gt; se determinan de acuerdo con las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="b0032656c660ab91cfc9f1912ec36a11287348d7" translate="yes" xml:space="preserve">
          <source>The type deduced by these deduction guides may change in a later standard revision (in particular, this might happen if &lt;code&gt;noexcept&lt;/code&gt; support is added to &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; in a later standard).</source>
          <target state="translated">El tipo deducido por estas gu&amp;iacute;as de deducci&amp;oacute;n puede cambiar en una revisi&amp;oacute;n est&amp;aacute;ndar posterior (en particular, esto podr&amp;iacute;a suceder si &lt;code&gt;noexcept&lt;/code&gt; se agrega compatibilidad con &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; en un est&amp;aacute;ndar posterior).</target>
        </trans-unit>
        <trans-unit id="8dcc1ea760f892b4e6eddb08b2acf9f9c879aeb1" translate="yes" xml:space="preserve">
          <source>The type defined by &lt;code&gt;std::aligned_storage&amp;lt;&amp;gt;::type&lt;/code&gt; can be used to create uninitialized memory blocks suitable to hold the objects of given type, optionally aligned stricter than their natural alignment requirement, for example on a cache or page boundary.</source>
          <target state="translated">El tipo definido por &lt;code&gt;std::aligned_storage&amp;lt;&amp;gt;::type&lt;/code&gt; se puede usar para crear bloques de memoria sin inicializar adecuados para contener los objetos de un tipo dado, opcionalmente m&amp;aacute;s estrictamente alineado que su requisito de alineaci&amp;oacute;n natural, por ejemplo en un cach&amp;eacute; o l&amp;iacute;mite de p&amp;aacute;gina.</target>
        </trans-unit>
        <trans-unit id="015fb8d559015f4868df42502a384ec989660bc6" translate="yes" xml:space="preserve">
          <source>The type does not have to implement &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operator&lt;/a&gt; in order to satisfy this type requirement: a &lt;a href=&quot;../language/as_operator&quot;&gt;copy assignment operator&lt;/a&gt; that takes its parameter by value or as a &lt;code&gt;const Type&amp;amp;&lt;/code&gt;, will bind to rvalue argument.</source>
          <target state="translated">El tipo no tiene que implementar el &lt;a href=&quot;../language/move_operator&quot;&gt;operador de asignaci&amp;oacute;n de movimiento&lt;/a&gt; para satisfacer este requisito de tipo: un &lt;a href=&quot;../language/as_operator&quot;&gt;operador de asignaci&amp;oacute;n de copia&lt;/a&gt; que toma su par&amp;aacute;metro por valor o como un &lt;code&gt;const Type&amp;amp;&lt;/code&gt; , se unir&amp;aacute; al argumento rvalue.</target>
        </trans-unit>
        <trans-unit id="4ee6bc4a29e09101e3ca894cf68274fb41416543" translate="yes" xml:space="preserve">
          <source>The type does not have to implement a &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operator&lt;/a&gt; in order to satisfy this trait; see &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; for details.</source>
          <target state="translated">El tipo no tiene que implementar un &lt;a href=&quot;../language/move_operator&quot;&gt;operador de asignaci&amp;oacute;n de movimiento&lt;/a&gt; para satisfacer este rasgo; ver &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="71c7ef3196579896dbcb86da29f6c58aaeef4821" translate="yes" xml:space="preserve">
          <source>The type does not support subnormal values</source>
          <target state="translated">El tipo no soporta valores subnormales</target>
        </trans-unit>
        <trans-unit id="c0aefe5f52f0c91ab7dcca87fc13463e2b84f15b" translate="yes" xml:space="preserve">
          <source>The type mbstate_t is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of &lt;code&gt;mbstate_t&lt;/code&gt; represents the initial conversion state, although other values of &lt;code&gt;mbstate_t&lt;/code&gt; may exist that also represent the initial conversion state.</source>
          <target state="translated">El tipo mbstate_t es un tipo trivial sin matriz que puede representar cualquiera de los estados de conversi&amp;oacute;n que pueden ocurrir en un conjunto definido por la implementaci&amp;oacute;n de reglas de codificaci&amp;oacute;n de caracteres multibyte compatibles. El valor de inicializaci&amp;oacute;n cero de &lt;code&gt;mbstate_t&lt;/code&gt; representa el estado de conversi&amp;oacute;n inicial, aunque pueden existir otros valores de &lt;code&gt;mbstate_t&lt;/code&gt; que tambi&amp;eacute;n representen el estado de conversi&amp;oacute;n inicial.</target>
        </trans-unit>
        <trans-unit id="ee6f31452577bc5b29d1b96501ba9c9ead4fd373" translate="yes" xml:space="preserve">
          <source>The type must meet &lt;a href=&quot;clock&quot;&gt;Clock&lt;/a&gt; requirements.</source>
          <target state="translated">El tipo debe cumplir los requisitos del &lt;a href=&quot;clock&quot;&gt;reloj&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="417fa810ac7b429d2e715174963cd48512430822" translate="yes" xml:space="preserve">
          <source>The type must meet all of the following requirements:</source>
          <target state="translated">El tipo debe cumplir todos los requisitos siguientes:</target>
        </trans-unit>
        <trans-unit id="5fe47f690f454a471c8cf3ffe3e0c793213ba10d" translate="yes" xml:space="preserve">
          <source>The type must satisfy the following additional expressions, given two values &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; that are of the type, and that &lt;code&gt;np&lt;/code&gt; is a value of &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type (possibly &lt;code&gt;const&lt;/code&gt; qualified):</source>
          <target state="translated">El tipo debe satisfacer las siguientes expresiones adicionales, dados dos valores &lt;code&gt;p&lt;/code&gt; y &lt;code&gt;q&lt;/code&gt; que son del tipo, y que &lt;code&gt;np&lt;/code&gt; es un valor del tipo &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; (posiblemente &lt;code&gt;const&lt;/code&gt; calificado):</target>
        </trans-unit>
        <trans-unit id="369901cace11f8d9f2b85e35e2783ef729d22cb1" translate="yes" xml:space="preserve">
          <source>The type must work with &amp;lt; operator and the result should have standard semantics.</source>
          <target state="translated">El tipo debe funcionar con &amp;lt;operator y el resultado debe tener una sem&amp;aacute;ntica est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="8ccea44fbb2fd126230d043404a673c987073e90" translate="yes" xml:space="preserve">
          <source>The type must work with == operator and the result should have standard semantics.</source>
          <target state="translated">El tipo debe funcionar con ==operador y el resultado debe tener una semántica estándar.</target>
        </trans-unit>
        <trans-unit id="a401af7b772905929e6c578148662943f7e9b5a8" translate="yes" xml:space="preserve">
          <source>The type need not be &lt;a href=&quot;incomplete_type&quot;&gt;complete&lt;/a&gt; or have an available &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, and can be &lt;a href=&quot;abstract_class&quot;&gt;abstract&lt;/a&gt;. This rule doesn't apply to sub-expressions: in &lt;code&gt;decltype(f(g()))&lt;/code&gt;, &lt;code&gt;g()&lt;/code&gt; must have a complete type, but &lt;code&gt;f()&lt;/code&gt; need not.</source>
          <target state="translated">El tipo no necesita estar &lt;a href=&quot;incomplete_type&quot;&gt;completo&lt;/a&gt; o tener un &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; disponible , y puede ser &lt;a href=&quot;abstract_class&quot;&gt;abstracto&lt;/a&gt; . Esta regla no se aplica a las &lt;code&gt;decltype(f(g()))&lt;/code&gt; : en decltype (f (g ())) , &lt;code&gt;g()&lt;/code&gt; debe tener un tipo completo, pero &lt;code&gt;f()&lt;/code&gt; no necesita.</target>
        </trans-unit>
        <trans-unit id="c83f8d22479920f797dda997ec4470602b5cb196" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;E&lt;/code&gt; after substitution must be exactly &lt;code&gt;bool&lt;/code&gt;. No conversion is permitted:</source>
          <target state="translated">El tipo de &lt;code&gt;E&lt;/code&gt; despu&amp;eacute;s de la sustituci&amp;oacute;n debe ser exactamente &lt;code&gt;bool&lt;/code&gt; . No se permite la conversi&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="092bcee309aef84863a0a22c05df0ff5cc2306f8" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;N&lt;/code&gt; in the type &lt;code&gt;T[N]&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El tipo de &lt;code&gt;N&lt;/code&gt; en el tipo &lt;code&gt;T[N]&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e00aa691520243fc7bb95963a65a42850ff0ee2d" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;replacement&lt;/code&gt; is &lt;code&gt;std::filesystem::path&lt;/code&gt; even though it is not intended to represent an object on the file system in order to correctly account for the filesystem character encoding.</source>
          <target state="translated">El tipo de &lt;code&gt;replacement&lt;/code&gt; es &lt;code&gt;std::filesystem::path&lt;/code&gt; , aunque no est&amp;aacute; destinado a representar un objeto en el sistema de archivos para tener en cuenta correctamente la codificaci&amp;oacute;n de caracteres del sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="73ef25a9616ca1a936ee4e3bf75aad3a667fbb50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;this&lt;/code&gt; in a member function of class &lt;code&gt;X&lt;/code&gt; is &lt;code&gt;X*&lt;/code&gt; (pointer to X). If the member function is &lt;a href=&quot;member_functions&quot;&gt;cv-qualified&lt;/a&gt;, the type of &lt;code&gt;this&lt;/code&gt; is &lt;code&gt;cv X*&lt;/code&gt; (pointer to identically cv-qualified X). Since constructors and destructors cannot be cv-qualified, the type of &lt;code&gt;this&lt;/code&gt; in them is always &lt;code&gt;X*&lt;/code&gt;, even when constructing or destroying a const object.</source>
          <target state="translated">El tipo de &lt;code&gt;this&lt;/code&gt; en una funci&amp;oacute;n miembro de la clase &lt;code&gt;X&lt;/code&gt; es &lt;code&gt;X*&lt;/code&gt; (puntero a X). Si la funci&amp;oacute;n miembro est&amp;aacute; &lt;a href=&quot;member_functions&quot;&gt;calificada para cv&lt;/a&gt; , el tipo de &lt;code&gt;this&lt;/code&gt; es &lt;code&gt;cv X*&lt;/code&gt; (puntero a X id&amp;eacute;nticamente calificado para cv). Dado que los constructores y destructores no pueden ser calificados para cv, el tipo de &lt;code&gt;this&lt;/code&gt; en ellos siempre es &lt;code&gt;X*&lt;/code&gt; , incluso cuando se construye o destruye un objeto constante.</target>
        </trans-unit>
        <trans-unit id="4a3330b556852ca71717541f2c81d240e408418f" translate="yes" xml:space="preserve">
          <source>The type of a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; appearing in an alias template declaration is different between instantiations of that template, even when the lambda expression is not dependent.</source>
          <target state="translated">El tipo de una &lt;a href=&quot;lambda&quot;&gt;expresi&amp;oacute;n lambda que&lt;/a&gt; aparece en una declaraci&amp;oacute;n de plantilla de alias es diferente entre las instancias de esa plantilla, incluso cuando la expresi&amp;oacute;n lambda no es dependiente.</target>
        </trans-unit>
        <trans-unit id="1c03df0e9a6c3883eefceaf776f001998a556f7d" translate="yes" xml:space="preserve">
          <source>The type of a bit field can only be integral or enumeration type.</source>
          <target state="translated">El tipo de campo de bits sólo puede ser de tipo integral o de enumeración.</target>
        </trans-unit>
        <trans-unit id="3e828f47acdf8dd1be944f104aebcd681e249b7b" translate="yes" xml:space="preserve">
          <source>The type of a non-type template parameter may be deduced if it includes a placeholder type (&lt;code&gt;auto&lt;/code&gt;, a placeholder for a deduced class type(since C++20), or &lt;code&gt;decltype(auto)&lt;/code&gt;). The deduction is performed as if by deducing the type of the variable &lt;code&gt;x&lt;/code&gt; in the invented declaration &lt;code&gt;T x = template-argument;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the declared type of the template parameter. If the deduced type is not permitted for a non-type template parameter, the program is ill-formed.</source>
          <target state="translated">El tipo de un par&amp;aacute;metro de plantilla sin tipo puede deducirse si incluye un tipo de marcador de posici&amp;oacute;n ( &lt;code&gt;auto&lt;/code&gt; , un marcador de posici&amp;oacute;n para un tipo de clase deducido (desde C ++ 20) o &lt;code&gt;decltype(auto)&lt;/code&gt; ). La deducci&amp;oacute;n se realiza como si deduciendo el tipo de la variable &lt;code&gt;x&lt;/code&gt; en la declaraci&amp;oacute;n inventada &lt;code&gt;T x = template-argument;&lt;/code&gt; , donde &lt;code&gt;T&lt;/code&gt; es el tipo declarado del par&amp;aacute;metro de plantilla. Si el tipo deducido no est&amp;aacute; permitido para un par&amp;aacute;metro de plantilla sin tipo, el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="9f077ca46cbdc83666da091d5f4c5c63b8be8535" translate="yes" xml:space="preserve">
          <source>The type of a pointer to array of unknown bound, or of a type defined by a &lt;code&gt;typedef&lt;/code&gt; declaration to be an array of unknown bound, cannot be completed.</source>
          <target state="translated">El tipo de un puntero a una matriz de enlace desconocido, o de un tipo definido por una declaraci&amp;oacute;n &lt;code&gt;typedef&lt;/code&gt; como una matriz de enlace desconocido, no se puede completar.</target>
        </trans-unit>
        <trans-unit id="e1654f0998b812161591ecd53f879aa981b5cfa6" translate="yes" xml:space="preserve">
          <source>The type of an expression that results from the compile-time analysis of the program is known as the</source>
          <target state="translated">El tipo de expresión que resulta del análisis en tiempo de compilación del programa se conoce como el</target>
        </trans-unit>
        <trans-unit id="dc3ab407bca97dd7b2182e8d6089591cbf78c0f6" translate="yes" xml:space="preserve">
          <source>The type of each data member is the type of the corresponding captured entity, except if the entity has reference type (in that case, references to functions are captured as lvalue references to the referenced functions, and references to objects are captured as copies of the referenced objects).</source>
          <target state="translated">El tipo de cada miembro de los datos es el tipo de la correspondiente entidad capturada,excepto si la entidad tiene un tipo de referencia (en ese caso,las referencias a las funciones se capturan como referencias de valor a las funciones referidas,y las referencias a los objetos se capturan como copias de los objetos referidos).</target>
        </trans-unit>
        <trans-unit id="85801fe2a975f6f74abeb5935ecc5a8cbc8a24c1" translate="yes" xml:space="preserve">
          <source>The type of each function parameter in the parameter list is determined according to the following rules:</source>
          <target state="translated">El tipo de cada parámetro de la función en la lista de parámetros se determina de acuerdo con las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="14480ff70d6d9671051d3a3bebfef0ffda9aa55c" translate="yes" xml:space="preserve">
          <source>The type of function callbacks that can be registered using &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; to be called on specific events.</source>
          <target state="translated">El tipo de devoluciones de llamada de funci&amp;oacute;n que se pueden registrar utilizando &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; para que se invoque en eventos espec&amp;iacute;ficos.</target>
        </trans-unit>
        <trans-unit id="16e7bff806ed1fa4ab8073e5ade6ccec0c8f929f" translate="yes" xml:space="preserve">
          <source>The type of the</source>
          <target state="translated">El tipo de</target>
        </trans-unit>
        <trans-unit id="b1b79e1851bb8cd4e0abe53b7badea94acb8b63a" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array must be a &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">El tipo de los elementos de la matriz debe ser &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; ; de lo contrario, el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="2a440bce9393578dcc59e67d819369eb6fff9dc5" translate="yes" xml:space="preserve">
          <source>The type of the elements.</source>
          <target state="translated">El tipo de los elementos.</target>
        </trans-unit>
        <trans-unit id="39cb107adf449bbc790a8800f9b0f24f9bbe1ba6" translate="yes" xml:space="preserve">
          <source>The type of the function being declared is composed from the</source>
          <target state="translated">El tipo de la función que se declara se compone de la</target>
        </trans-unit>
        <trans-unit id="9bbb6b4e7d477a9cc16a3aa9d6f2075047c3171b" translate="yes" xml:space="preserve">
          <source>The type of the integer literal is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.</source>
          <target state="translated">El tipo del entero literal es el primer tipo en el que puede caber el valor,de la lista de tipos que depende de la base numérica y del sufijo del entero que se haya utilizado.</target>
        </trans-unit>
        <trans-unit id="68e06d906da63b0e924e6b7c9ec59a39e6b3cb3e" translate="yes" xml:space="preserve">
          <source>The type of the literal</source>
          <target state="translated">El tipo de la literalidad</target>
        </trans-unit>
        <trans-unit id="66d91e0faa820f737700bea3d6d88e6c67abbd4b" translate="yes" xml:space="preserve">
          <source>The type of the stored elements. The behavior is undefined if &lt;code&gt;T&lt;/code&gt; is not the same type as &lt;code&gt;Container::value_type&lt;/code&gt;.(since C++17)</source>
          <target state="translated">El tipo de los elementos almacenados. El comportamiento no est&amp;aacute; definido si &lt;code&gt;T&lt;/code&gt; no es del mismo tipo que &lt;code&gt;Container::value_type&lt;/code&gt; . (Desde C ++ 17)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
